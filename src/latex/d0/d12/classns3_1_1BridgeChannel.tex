\hypertarget{classns3_1_1BridgeChannel}{}\section{ns3\+:\+:Bridge\+Channel Class Reference}
\label{classns3_1_1BridgeChannel}\index{ns3\+::\+Bridge\+Channel@{ns3\+::\+Bridge\+Channel}}


Virtual channel implementation for bridges (\hyperlink{classns3_1_1BridgeNetDevice}{Bridge\+Net\+Device}).  




{\ttfamily \#include $<$bridge-\/channel.\+h$>$}



Inheritance diagram for ns3\+:\+:Bridge\+Channel\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Bridge\+Channel\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1BridgeChannel_a18146e0d84129a743f3224cf99a1183d}{Bridge\+Channel} ()
\item 
virtual \hyperlink{classns3_1_1BridgeChannel_a10cd65b14332a912036187bfeb4a8a07}{$\sim$\+Bridge\+Channel} ()
\item 
void \hyperlink{classns3_1_1BridgeChannel_a55a31a5f88740271f790bbc25c2e2d4d}{Add\+Channel} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Channel}{Channel} $>$ bridged\+Channel)
\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1BridgeChannel_a71e89d3c21406c1896ac78aef7a48c9b}{Get\+N\+Devices} (void) const 
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ \hyperlink{classns3_1_1BridgeChannel_a0cd52c2034998de11dc13e821d547202}{Get\+Device} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) const 
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1BridgeChannel_a712e64db6fe85a59c1b38cfa914c9a77}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1BridgeChannel_af465ebedcecfd063a0e3af7b141a59b2}{Bridge\+Channel} (const \hyperlink{classns3_1_1BridgeChannel}{Bridge\+Channel} \&)
\begin{DoxyCompactList}\small\item\em Copy constructor. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1BridgeChannel}{Bridge\+Channel} \& \hyperlink{classns3_1_1BridgeChannel_a130ad1622b24c84d704b9a17292bd1e8}{operator=} (const \hyperlink{classns3_1_1BridgeChannel}{Bridge\+Channel} \&)
\begin{DoxyCompactList}\small\item\em Copy constructor. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::vector$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Channel}{Channel} $>$ $>$ \hyperlink{classns3_1_1BridgeChannel_a2676f0c161f4b53635ae5a4e2e0d356d}{m\+\_\+bridged\+Channels}
\begin{DoxyCompactList}\small\item\em pool of bridged channels \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Virtual channel implementation for bridges (\hyperlink{classns3_1_1BridgeNetDevice}{Bridge\+Net\+Device}). 

Just like \hyperlink{classns3_1_1BridgeNetDevice}{Bridge\+Net\+Device} aggregates multiple Net\+Devices, \hyperlink{classns3_1_1BridgeChannel}{Bridge\+Channel} aggregates multiple channels and make them appear as a single channel to upper layers. 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Bridge\+Channel@{ns3\+::\+Bridge\+Channel}!Bridge\+Channel@{Bridge\+Channel}}
\index{Bridge\+Channel@{Bridge\+Channel}!ns3\+::\+Bridge\+Channel@{ns3\+::\+Bridge\+Channel}}
\subsubsection[{\texorpdfstring{Bridge\+Channel()}{BridgeChannel()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Bridge\+Channel\+::\+Bridge\+Channel (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BridgeChannel_a18146e0d84129a743f3224cf99a1183d}{}\label{classns3_1_1BridgeChannel_a18146e0d84129a743f3224cf99a1183d}

\begin{DoxyCode}
40   : \hyperlink{classns3_1_1Channel_a52285184d570dde461e3a03529f96bdc}{Channel} ()
41 \{
42   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
43 \}
\end{DoxyCode}
\index{ns3\+::\+Bridge\+Channel@{ns3\+::\+Bridge\+Channel}!````~Bridge\+Channel@{$\sim$\+Bridge\+Channel}}
\index{````~Bridge\+Channel@{$\sim$\+Bridge\+Channel}!ns3\+::\+Bridge\+Channel@{ns3\+::\+Bridge\+Channel}}
\subsubsection[{\texorpdfstring{$\sim$\+Bridge\+Channel()}{~BridgeChannel()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Bridge\+Channel\+::$\sim$\+Bridge\+Channel (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1BridgeChannel_a10cd65b14332a912036187bfeb4a8a07}{}\label{classns3_1_1BridgeChannel_a10cd65b14332a912036187bfeb4a8a07}

\begin{DoxyCode}
46 \{
47   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
48 
49   \textcolor{keywordflow}{for} (std::vector< Ptr<Channel> >::iterator iter = \hyperlink{classns3_1_1BridgeChannel_a2676f0c161f4b53635ae5a4e2e0d356d}{m\_bridgedChannels}.begin ();
50        iter != \hyperlink{classns3_1_1BridgeChannel_a2676f0c161f4b53635ae5a4e2e0d356d}{m\_bridgedChannels}.end (); iter++)
51     \{
52       *iter = 0;
53     \}
54   \hyperlink{classns3_1_1BridgeChannel_a2676f0c161f4b53635ae5a4e2e0d356d}{m\_bridgedChannels}.clear ();
55 \}
\end{DoxyCode}
\index{ns3\+::\+Bridge\+Channel@{ns3\+::\+Bridge\+Channel}!Bridge\+Channel@{Bridge\+Channel}}
\index{Bridge\+Channel@{Bridge\+Channel}!ns3\+::\+Bridge\+Channel@{ns3\+::\+Bridge\+Channel}}
\subsubsection[{\texorpdfstring{Bridge\+Channel(const Bridge\+Channel \&)}{BridgeChannel(const BridgeChannel &)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Bridge\+Channel\+::\+Bridge\+Channel (
\begin{DoxyParamCaption}
\item[{const {\bf Bridge\+Channel} \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BridgeChannel_af465ebedcecfd063a0e3af7b141a59b2}{}\label{classns3_1_1BridgeChannel_af465ebedcecfd063a0e3af7b141a59b2}


Copy constructor. 

Defined and unimplemented to avoid misuse 

\subsection{Member Function Documentation}
\index{ns3\+::\+Bridge\+Channel@{ns3\+::\+Bridge\+Channel}!Add\+Channel@{Add\+Channel}}
\index{Add\+Channel@{Add\+Channel}!ns3\+::\+Bridge\+Channel@{ns3\+::\+Bridge\+Channel}}
\subsubsection[{\texorpdfstring{Add\+Channel(\+Ptr$<$ Channel $>$ bridged\+Channel)}{AddChannel(Ptr< Channel > bridgedChannel)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Bridge\+Channel\+::\+Add\+Channel (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Channel} $>$}]{bridged\+Channel}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BridgeChannel_a55a31a5f88740271f790bbc25c2e2d4d}{}\label{classns3_1_1BridgeChannel_a55a31a5f88740271f790bbc25c2e2d4d}
Adds a channel to the bridged pool 
\begin{DoxyParams}{Parameters}
{\em bridged\+Channel} & the channel to add to the pool \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
60 \{
61   \hyperlink{classns3_1_1BridgeChannel_a2676f0c161f4b53635ae5a4e2e0d356d}{m\_bridgedChannels}.push\_back (bridgedChannel);
62 \}
\end{DoxyCode}
\index{ns3\+::\+Bridge\+Channel@{ns3\+::\+Bridge\+Channel}!Get\+Device@{Get\+Device}}
\index{Get\+Device@{Get\+Device}!ns3\+::\+Bridge\+Channel@{ns3\+::\+Bridge\+Channel}}
\subsubsection[{\texorpdfstring{Get\+Device(uint32\+\_\+t i) const }{GetDevice(uint32_t i) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Net\+Device} $>$ ns3\+::\+Bridge\+Channel\+::\+Get\+Device (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1BridgeChannel_a0cd52c2034998de11dc13e821d547202}{}\label{classns3_1_1BridgeChannel_a0cd52c2034998de11dc13e821d547202}

\begin{DoxyParams}{Parameters}
{\em i} & index of \hyperlink{classns3_1_1NetDevice}{Net\+Device} to retrieve \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
one of the Net\+Devices connected to this channel.
\end{DoxyReturn}
This method must be implemented by subclasses. 

Implements \hyperlink{classns3_1_1Channel_a6644f4a9058be99c1a975ba415420b21}{ns3\+::\+Channel}.


\begin{DoxyCode}
79 \{
80   uint32\_t ndevices = 0;
81   \textcolor{keywordflow}{for} (std::vector< Ptr<Channel> >::const\_iterator iter = \hyperlink{classns3_1_1BridgeChannel_a2676f0c161f4b53635ae5a4e2e0d356d}{m\_bridgedChannels}.begin ();
82        iter != \hyperlink{classns3_1_1BridgeChannel_a2676f0c161f4b53635ae5a4e2e0d356d}{m\_bridgedChannels}.end (); iter++)
83     \{
84       \textcolor{keywordflow}{if} ((\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} - ndevices) < (*iter)->GetNDevices ())
85         \{
86           \textcolor{keywordflow}{return} (*iter)->GetDevice (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} - ndevices);
87         \}
88       ndevices += (*iter)->GetNDevices ();
89     \}
90   \textcolor{keywordflow}{return} NULL;
91 \}
\end{DoxyCode}
\index{ns3\+::\+Bridge\+Channel@{ns3\+::\+Bridge\+Channel}!Get\+N\+Devices@{Get\+N\+Devices}}
\index{Get\+N\+Devices@{Get\+N\+Devices}!ns3\+::\+Bridge\+Channel@{ns3\+::\+Bridge\+Channel}}
\subsubsection[{\texorpdfstring{Get\+N\+Devices(void) const }{GetNDevices(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Bridge\+Channel\+::\+Get\+N\+Devices (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1BridgeChannel_a71e89d3c21406c1896ac78aef7a48c9b}{}\label{classns3_1_1BridgeChannel_a71e89d3c21406c1896ac78aef7a48c9b}
\begin{DoxyReturn}{Returns}
the number of Net\+Devices connected to this \hyperlink{classns3_1_1Channel}{Channel}.
\end{DoxyReturn}
This method must be implemented by subclasses. 

Implements \hyperlink{classns3_1_1Channel_ae9ff413402685d9952b4fbc4fa80d220}{ns3\+::\+Channel}.


\begin{DoxyCode}
66 \{
67   uint32\_t ndevices = 0;
68   \textcolor{keywordflow}{for} (std::vector< Ptr<Channel> >::const\_iterator iter = \hyperlink{classns3_1_1BridgeChannel_a2676f0c161f4b53635ae5a4e2e0d356d}{m\_bridgedChannels}.begin ();
69        iter != \hyperlink{classns3_1_1BridgeChannel_a2676f0c161f4b53635ae5a4e2e0d356d}{m\_bridgedChannels}.end (); iter++)
70     \{
71       ndevices += (*iter)->GetNDevices ();
72     \}
73   \textcolor{keywordflow}{return} ndevices;
74 \}
\end{DoxyCode}
\index{ns3\+::\+Bridge\+Channel@{ns3\+::\+Bridge\+Channel}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Bridge\+Channel@{ns3\+::\+Bridge\+Channel}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Bridge\+Channel\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1BridgeChannel_a712e64db6fe85a59c1b38cfa914c9a77}{}\label{classns3_1_1BridgeChannel_a712e64db6fe85a59c1b38cfa914c9a77}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
30 \{
31   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::BridgeChannel"})
32     .SetParent<\hyperlink{classns3_1_1Channel_a52285184d570dde461e3a03529f96bdc}{Channel}> ()
33     .SetGroupName(\textcolor{stringliteral}{"Bridge"})
34     .AddConstructor<\hyperlink{classns3_1_1BridgeChannel_a18146e0d84129a743f3224cf99a1183d}{BridgeChannel}> ()
35   ;
36   \textcolor{keywordflow}{return} tid;
37 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Bridge\+Channel@{ns3\+::\+Bridge\+Channel}!operator=@{operator=}}
\index{operator=@{operator=}!ns3\+::\+Bridge\+Channel@{ns3\+::\+Bridge\+Channel}}
\subsubsection[{\texorpdfstring{operator=(const Bridge\+Channel \&)}{operator=(const BridgeChannel &)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Bridge\+Channel}\& ns3\+::\+Bridge\+Channel\+::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf Bridge\+Channel} \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BridgeChannel_a130ad1622b24c84d704b9a17292bd1e8}{}\label{classns3_1_1BridgeChannel_a130ad1622b24c84d704b9a17292bd1e8}


Copy constructor. 

Defined and unimplemented to avoid misuse \begin{DoxyReturn}{Returns}

\end{DoxyReturn}


\subsection{Member Data Documentation}
\index{ns3\+::\+Bridge\+Channel@{ns3\+::\+Bridge\+Channel}!m\+\_\+bridged\+Channels@{m\+\_\+bridged\+Channels}}
\index{m\+\_\+bridged\+Channels@{m\+\_\+bridged\+Channels}!ns3\+::\+Bridge\+Channel@{ns3\+::\+Bridge\+Channel}}
\subsubsection[{\texorpdfstring{m\+\_\+bridged\+Channels}{m_bridgedChannels}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<$ {\bf Ptr}$<${\bf Channel}$>$ $>$ ns3\+::\+Bridge\+Channel\+::m\+\_\+bridged\+Channels\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BridgeChannel_a2676f0c161f4b53635ae5a4e2e0d356d}{}\label{classns3_1_1BridgeChannel_a2676f0c161f4b53635ae5a4e2e0d356d}


pool of bridged channels 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
bridge/model/\hyperlink{bridge-channel_8h}{bridge-\/channel.\+h}\item 
bridge/model/\hyperlink{bridge-channel_8cc}{bridge-\/channel.\+cc}\end{DoxyCompactItemize}
