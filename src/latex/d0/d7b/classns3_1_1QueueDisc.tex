\hypertarget{classns3_1_1QueueDisc}{}\section{ns3\+:\+:Queue\+Disc Class Reference}
\label{classns3_1_1QueueDisc}\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}


{\ttfamily \#include $<$queue-\/disc.\+h$>$}



Inheritance diagram for ns3\+:\+:Queue\+Disc\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Queue\+Disc\+:
% FIG 1
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classns3_1_1QueueDisc_a0b9b32e71d5becf66e6ac4b3d3de7c8b}{Wake\+Mode} \{ \hyperlink{classns3_1_1QueueDisc_a0b9b32e71d5becf66e6ac4b3d3de7c8ba56fb0e52526a39cefb47d24550bf47c6}{W\+A\+K\+E\+\_\+\+R\+O\+OT} = 0x00, 
\hyperlink{classns3_1_1QueueDisc_a0b9b32e71d5becf66e6ac4b3d3de7c8bad2dbf3b0b56e3e0d4d0f8f944c4d0fcd}{W\+A\+K\+E\+\_\+\+C\+H\+I\+LD} = 0x01
 \}\begin{DoxyCompactList}\small\item\em Used to determine whether the queue disc itself or its children must be activated when a netdevice wakes a transmission queue. \end{DoxyCompactList}
\item 
typedef \hyperlink{classns3_1_1Queue}{Queue}$<$ \hyperlink{classns3_1_1QueueDiscItem}{Queue\+Disc\+Item} $>$ \hyperlink{classns3_1_1QueueDisc_a3acb7d460465f9f13c6fbbdeae7508f8}{Internal\+Queue}
\begin{DoxyCompactList}\small\item\em Internal queues store \hyperlink{classns3_1_1QueueDiscItem}{Queue\+Disc\+Item} objects. \end{DoxyCompactList}\item 
typedef \hyperlink{classns3_1_1Callback}{Callback}$<$ void, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1QueueDiscItem}{Queue\+Disc\+Item} $>$ $>$ \hyperlink{classns3_1_1QueueDisc_abcb41646ec54f8206bc14df2c93762f4}{Parent\+Drop\+Callback}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Callback}{Callback} invoked by a child queue disc to notify the parent of a packet drop. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1QueueDisc_a0e328ad3196b7d16783b8680722381d6}{Queue\+Disc} ()
\item 
virtual \hyperlink{classns3_1_1QueueDisc_a13e58692c0f31d303091b022cb73c216}{$\sim$\+Queue\+Disc} ()
\item 
uint32\+\_\+t \hyperlink{classns3_1_1QueueDisc_a6ee992f32c1671512f0948fd6cc46a7e}{Get\+N\+Packets} (void) const 
\begin{DoxyCompactList}\small\item\em Get the number of packets stored by the queue disc. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1QueueDisc_ac87d3bbf7381d64808f6764bdfd812e5}{Get\+N\+Bytes} (void) const 
\begin{DoxyCompactList}\small\item\em Get the amount of bytes stored by the queue disc. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1QueueDisc_ae28596b0b2ad428a9140726b0a0943c7}{Get\+Total\+Received\+Packets} (void) const 
\begin{DoxyCompactList}\small\item\em Get the total number of received packets. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1QueueDisc_a954d8df1c4519c41a35e5f7c805a2141}{Get\+Total\+Received\+Bytes} (void) const 
\begin{DoxyCompactList}\small\item\em Get the total amount of received bytes. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1QueueDisc_a0ec6ad7777a361db9a1a609bede088a9}{Get\+Total\+Dropped\+Packets} (void) const 
\begin{DoxyCompactList}\small\item\em Get the total number of dropped packets. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1QueueDisc_adea5022bc83cb149d66b667edfe85745}{Get\+Total\+Dropped\+Bytes} (void) const 
\begin{DoxyCompactList}\small\item\em Get the total amount of dropped bytes. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1QueueDisc_ab7a24479351628abd5c21d5c25d77038}{Get\+Total\+Requeued\+Packets} (void) const 
\begin{DoxyCompactList}\small\item\em Get the total number of requeued packets. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1QueueDisc_a401e7e3609c49327ca72b1e5d7b0fcbc}{Get\+Total\+Requeued\+Bytes} (void) const 
\begin{DoxyCompactList}\small\item\em Get the total amount of requeued bytes. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1QueueDisc_af7dc06af070d01ff4cf515ab2a844ef3}{Set\+Net\+Device} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device)
\begin{DoxyCompactList}\small\item\em Set the \hyperlink{classns3_1_1NetDevice}{Net\+Device} on which this queue discipline is installed. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ \hyperlink{classns3_1_1QueueDisc_afae7bdc1c4f46a06bf31e269f832a41a}{Get\+Net\+Device} (void) const 
\begin{DoxyCompactList}\small\item\em Get the \hyperlink{classns3_1_1NetDevice}{Net\+Device} on which this queue discipline is installed. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1QueueDisc_ab35519e5f10b3226c4b2a07e009bcc20}{Set\+Quota} (const uint32\+\_\+t quota)
\begin{DoxyCompactList}\small\item\em Set the maximum number of dequeue operations following a packet enqueue. \end{DoxyCompactList}\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1QueueDisc_a1d058b896f93e346227a59c49085626e}{Get\+Quota} (void) const 
\begin{DoxyCompactList}\small\item\em Get the maximum number of dequeue operations following a packet enqueue. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1QueueDisc_af452fb01b98fed312125163f1fe85431}{Enqueue} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1QueueDiscItem}{Queue\+Disc\+Item} $>$ item)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1QueueDiscItem}{Queue\+Disc\+Item} $>$ \hyperlink{classns3_1_1QueueDisc_a6c13fc489822c1487f61c2289f2e3629}{Dequeue} (void)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1QueueDiscItem}{Queue\+Disc\+Item} $>$ \hyperlink{classns3_1_1QueueDisc_a952cddf7fbe32e180a170a7be21875fa}{Peek} (void) const 
\item 
void \hyperlink{classns3_1_1QueueDisc_a424eceba41cb013436f353c622c082ff}{Run} (void)
\item 
void \hyperlink{classns3_1_1QueueDisc_a0599223e2a3976ef042a56c2923a2b61}{Add\+Internal\+Queue} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1QueueDisc_a3acb7d460465f9f13c6fbbdeae7508f8}{Internal\+Queue} $>$ queue)
\begin{DoxyCompactList}\small\item\em Add an internal queue to the tail of the list of queues. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1QueueDisc_a3acb7d460465f9f13c6fbbdeae7508f8}{Internal\+Queue} $>$ \hyperlink{classns3_1_1QueueDisc_adf09b498c07c5677c26ea4b8309def74}{Get\+Internal\+Queue} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) const 
\begin{DoxyCompactList}\small\item\em Get the i-\/th internal queue. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1QueueDisc_a98e658dc1b0b32104ffc9e07afd205c6}{Get\+N\+Internal\+Queues} (void) const 
\begin{DoxyCompactList}\small\item\em Get the number of internal queues. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1QueueDisc_a45efdc512f64cb8e0d57ad4f208ed4b7}{Add\+Packet\+Filter} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1PacketFilter}{Packet\+Filter} $>$ filter)
\begin{DoxyCompactList}\small\item\em Add a packet filter to the tail of the list of filters used to classify packets. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1PacketFilter}{Packet\+Filter} $>$ \hyperlink{classns3_1_1QueueDisc_a35a230851eabeb444ea7e00798895b42}{Get\+Packet\+Filter} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) const 
\begin{DoxyCompactList}\small\item\em Get the i-\/th packet filter. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1QueueDisc_aff24dd5be3fe3aa46b88c00659e09b23}{Get\+N\+Packet\+Filters} (void) const 
\begin{DoxyCompactList}\small\item\em Get the number of packet filters. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1QueueDisc_a153f1f65efcaa976c9a93cd53b777416}{Add\+Queue\+Disc\+Class} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1QueueDiscClass}{Queue\+Disc\+Class} $>$ qd\+Class)
\begin{DoxyCompactList}\small\item\em Add a queue disc class to the tail of the list of classes. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1QueueDiscClass}{Queue\+Disc\+Class} $>$ \hyperlink{classns3_1_1QueueDisc_a584d228f7bff3f754d32793a38134556}{Get\+Queue\+Disc\+Class} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) const 
\begin{DoxyCompactList}\small\item\em Get the i-\/th queue disc class. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1QueueDisc_a8165c6afde992b073bc4d3bb283ed138}{Get\+N\+Queue\+Disc\+Classes} (void) const 
\begin{DoxyCompactList}\small\item\em Get the number of queue disc classes. \end{DoxyCompactList}\item 
int32\+\_\+t \hyperlink{classns3_1_1QueueDisc_a560004f3fbca4e2cb9938fa3938f4be3}{Classify} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1QueueDiscItem}{Queue\+Disc\+Item} $>$ item)
\item 
virtual \hyperlink{classns3_1_1QueueDisc_a0b9b32e71d5becf66e6ac4b3d3de7c8b}{Wake\+Mode} \hyperlink{classns3_1_1QueueDisc_a51a079153b474eec1bad9abe715d9510}{Get\+Wake\+Mode} (void) const 
\item 
virtual void \hyperlink{classns3_1_1QueueDisc_ac0a9b81f70b0ef63d3bd31718691e6e9}{Set\+Parent\+Drop\+Callback} (\hyperlink{classns3_1_1QueueDisc_abcb41646ec54f8206bc14df2c93762f4}{Parent\+Drop\+Callback} cb)
\begin{DoxyCompactList}\small\item\em Set the parent drop callback. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1QueueDisc_a425dcb905ce9b18fa5e83316fc63961e}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1QueueDisc_ad2eafba04edabab10bc6ea9d5ea273e1}{Do\+Dispose} (void)
\begin{DoxyCompactList}\small\item\em Dispose of the object. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1QueueDisc_a7b75249652866a0725c6f280bd618123}{Do\+Initialize} (void)
\begin{DoxyCompactList}\small\item\em Check whether the configuration is correct and initialize parameters. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1QueueDisc_a4e8bbd3afbd927df3342dd015f30b08c}{Drop} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1QueueDiscItem}{Queue\+Disc\+Item} $>$ item)
\begin{DoxyCompactList}\small\item\em Drop a packet. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1QueueDisc_abec93e451217e4b2660c71abebdd08fd}{Queue\+Disc} (const \hyperlink{classns3_1_1QueueDisc}{Queue\+Disc} \&o)
\begin{DoxyCompactList}\small\item\em Copy constructor. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1QueueDisc}{Queue\+Disc} \& \hyperlink{classns3_1_1QueueDisc_a9a2023229369d282aa4714124cf772f2}{operator=} (const \hyperlink{classns3_1_1QueueDisc}{Queue\+Disc} \&o)
\begin{DoxyCompactList}\small\item\em Assignment operator. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1QueueDisc_aee0b845da519a8121dbe5a397ed63b54}{Notify\+Parent\+Drop} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1QueueDiscItem}{Queue\+Disc\+Item} $>$ item)
\begin{DoxyCompactList}\small\item\em Notify the parent queue disc of a packet drop. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1QueueDisc_a22d77d2ec26e6fe5476d976d9d5e3a66}{Do\+Enqueue} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1QueueDiscItem}{Queue\+Disc\+Item} $>$ item)=0
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1QueueDiscItem}{Queue\+Disc\+Item} $>$ \hyperlink{classns3_1_1QueueDisc_afefae1a05f45db101c2c75d67a440c63}{Do\+Dequeue} (void)=0
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1QueueDiscItem}{Queue\+Disc\+Item} $>$ \hyperlink{classns3_1_1QueueDisc_aff6a0523b7132a4df6cf202ab49bd788}{Do\+Peek} (void) const =0
\item 
virtual bool \hyperlink{classns3_1_1QueueDisc_ace6ef0c9afd0954c4629ad454bf975f5}{Check\+Config} (void)=0
\item 
virtual void \hyperlink{classns3_1_1QueueDisc_a600ed3e7110b9d506b28ad62beb84592}{Initialize\+Params} (void)=0
\item 
bool \hyperlink{classns3_1_1QueueDisc_a9fc8e2a52e7600d3d93141241f7bd7cd}{Run\+Begin} (void)
\item 
void \hyperlink{classns3_1_1QueueDisc_a1022461238c22b5ce07bc0fd2527e2f3}{Run\+End} (void)
\item 
bool \hyperlink{classns3_1_1QueueDisc_a009f73a521cc0ebf309d8d15f8b190ea}{Restart} (void)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1QueueDiscItem}{Queue\+Disc\+Item} $>$ \hyperlink{classns3_1_1QueueDisc_aab4beacb808b917dde38fe835c199f28}{Dequeue\+Packet} (void)
\item 
void \hyperlink{classns3_1_1QueueDisc_a45cd8fdd2469b9e9d7551af22cfdb1a2}{Requeue} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1QueueDiscItem}{Queue\+Disc\+Item} $>$ item)
\item 
bool \hyperlink{classns3_1_1QueueDisc_a294d52aeecb986d4f2b3bcb4514c013e}{Transmit} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1QueueDiscItem}{Queue\+Disc\+Item} $>$ item)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::vector$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1QueueDisc_a3acb7d460465f9f13c6fbbdeae7508f8}{Internal\+Queue} $>$ $>$ \hyperlink{classns3_1_1QueueDisc_ae6507c7002e15afd8944a34f239331d7}{m\+\_\+queues}
\begin{DoxyCompactList}\small\item\em Internal queues. \end{DoxyCompactList}\item 
std\+::vector$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1PacketFilter}{Packet\+Filter} $>$ $>$ \hyperlink{classns3_1_1QueueDisc_a04bc2a1d90315527c6ba411eb2cb722a}{m\+\_\+filters}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Packet}{Packet} filters. \end{DoxyCompactList}\item 
std\+::vector$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1QueueDiscClass}{Queue\+Disc\+Class} $>$ $>$ \hyperlink{classns3_1_1QueueDisc_a054d624a7a6f10a11cffec1f858feb3c}{m\+\_\+classes}
\begin{DoxyCompactList}\small\item\em Classes. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedValue}{Traced\+Value}$<$ uint32\+\_\+t $>$ \hyperlink{classns3_1_1QueueDisc_a7afc9edf0fdb517d088ebe8d3747fbef}{m\+\_\+n\+Packets}
\begin{DoxyCompactList}\small\item\em Number of packets in the queue. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedValue}{Traced\+Value}$<$ uint32\+\_\+t $>$ \hyperlink{classns3_1_1QueueDisc_a5c9e0e5c858f333bb15089eea58a1e3b}{m\+\_\+n\+Bytes}
\begin{DoxyCompactList}\small\item\em Number of bytes in the queue. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1QueueDisc_afc5d0c189f8d08582a84fce36fea8745}{m\+\_\+n\+Total\+Received\+Packets}
\begin{DoxyCompactList}\small\item\em Total received packets. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1QueueDisc_a8ebcd87d1d417d30e1e916a406c681c0}{m\+\_\+n\+Total\+Received\+Bytes}
\begin{DoxyCompactList}\small\item\em Total received bytes. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1QueueDisc_a2974596141f300298255f0ae85faf0cc}{m\+\_\+n\+Total\+Dropped\+Packets}
\begin{DoxyCompactList}\small\item\em Total dropped packets. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1QueueDisc_a06645b0916c11b3da27195ed99ca8ce7}{m\+\_\+n\+Total\+Dropped\+Bytes}
\begin{DoxyCompactList}\small\item\em Total dropped bytes. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1QueueDisc_a098d0d792113e93b94c8f89178ac2af6}{m\+\_\+n\+Total\+Requeued\+Packets}
\begin{DoxyCompactList}\small\item\em Total requeued packets. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1QueueDisc_aa1c2f1af9a66078a2507d2632eef82ae}{m\+\_\+n\+Total\+Requeued\+Bytes}
\begin{DoxyCompactList}\small\item\em Total requeued bytes. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1QueueDisc_a4f7e8c8503be408b6bbf82e0648c9fc8}{m\+\_\+quota}
\begin{DoxyCompactList}\small\item\em Maximum number of packets dequeued in a qdisc run. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ \hyperlink{classns3_1_1QueueDisc_ad9a47fe0eb33b8e1ef760966b1ad6b7c}{m\+\_\+device}
\begin{DoxyCompactList}\small\item\em The \hyperlink{classns3_1_1NetDevice}{Net\+Device} on which this queue discipline is installed. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDeviceQueueInterface}{Net\+Device\+Queue\+Interface} $>$ \hyperlink{classns3_1_1QueueDisc_a265febf26e8325dbb3ba1f905ea1912d}{m\+\_\+dev\+Queue\+Iface}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1NetDevice}{Net\+Device} queue interface. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1QueueDisc_a6d00230b60de29bd32d0a2488290380f}{m\+\_\+running}
\begin{DoxyCompactList}\small\item\em The queue disc is performing multiple dequeue operations. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1QueueDiscItem}{Queue\+Disc\+Item} $>$ \hyperlink{classns3_1_1QueueDisc_a43cae3d282e28914b1b5e1b782c7e854}{m\+\_\+requeued}
\begin{DoxyCompactList}\small\item\em The last packet that failed to be transmitted. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1QueueDisc_abcb41646ec54f8206bc14df2c93762f4}{Parent\+Drop\+Callback} \hyperlink{classns3_1_1QueueDisc_ac0ecab7418e3e1e6453f9cf1b194b74f}{m\+\_\+parent\+Drop\+Callback}
\begin{DoxyCompactList}\small\item\em Parent drop callback. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1QueueDiscItem}{Queue\+Disc\+Item} $>$ $>$ \hyperlink{classns3_1_1QueueDisc_a7614788f662bc6df8c98a646f494dd61}{m\+\_\+trace\+Enqueue}
\begin{DoxyCompactList}\small\item\em Traced callback\+: fired when a packet is enqueued. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1QueueDiscItem}{Queue\+Disc\+Item} $>$ $>$ \hyperlink{classns3_1_1QueueDisc_a1be3a308037b0feb28ae284b9be04bfc}{m\+\_\+trace\+Dequeue}
\begin{DoxyCompactList}\small\item\em Traced callback\+: fired when a packet is dequeued. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1QueueDiscItem}{Queue\+Disc\+Item} $>$ $>$ \hyperlink{classns3_1_1QueueDisc_a599ba8331f01a8b7ff1d690a8c52dedc}{m\+\_\+trace\+Requeue}
\begin{DoxyCompactList}\small\item\em Traced callback\+: fired when a packet is requeued. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1QueueDiscItem}{Queue\+Disc\+Item} $>$ $>$ \hyperlink{classns3_1_1QueueDisc_a4d59074e7f6aa601eee90f5cd87d423f}{m\+\_\+trace\+Drop}
\begin{DoxyCompactList}\small\item\em Traced callback\+: fired when a packet is dropped. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Private Attributes}
\begin{DoxyCompactItemize}
\item 
static const uint32\+\_\+t \hyperlink{classns3_1_1QueueDisc_a057a2c6dd982ffb206ce2a42eb4f46fa}{D\+E\+F\+A\+U\+L\+T\+\_\+\+Q\+U\+O\+TA} = 64
\begin{DoxyCompactList}\small\item\em Default quota (as in /proc/sys/net/core/dev\+\_\+weight) \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
\hyperlink{classns3_1_1QueueDisc}{Queue\+Disc} is an abstract base class providing the interface and implementing the operations common to all the queueing disciplines. Child classes need to implement the methods used to enqueue a packet (Do\+Enqueue), dequeue a single packet (Do\+Dequeue), get a copy of the next packet to extract (Do\+Peek), check whether the current configuration is correct (Check\+Config).

As in Linux, a queue disc may contain distinct elements\+:
\begin{DoxyItemize}
\item queues, which actually store the packets waiting for transmission
\item classes, which allow to reserve a different treatment to different packets
\item filters, which determine the queue or class which a packet is destined to
\end{DoxyItemize}

Notice that a child queue disc must be attached to every class and a packet filter is only able to classify packets of a single protocol. Also, while in Linux some queue discs (e.\+g., fq-\/codel) use an internal classifier and do not make use of packet filters, in ns-\/3 every queue disc including multiple queues or multiple classes needs an external filter to classify packets (this is to avoid having the traffic-\/control module depend on other modules such as internet).

\hyperlink{classns3_1_1Queue}{Queue} disc configuration vary from queue disc to queue disc. A typical taxonomy divides queue discs in classful (i.\+e., support classes) and classless (i.\+e., do not support classes). More recently, after the appearance of multi-\/queue devices (such as Wifi), some multi-\/queue aware queue discs have been introduced. Multi-\/queue aware queue discs handle as many queues (or queue discs -- without using classes) as the number of transmission queues used by the device on which the queue disc is installed. An attempt is made, also, to enqueue each packet in the \char`\"{}same\char`\"{} queue both within the queue disc and within the device.

The traffic control layer interacts with a queue disc in a simple manner\+: after requesting to enqueue a packet, the traffic control layer requests the qdisc to \char`\"{}run\char`\"{}, i.\+e., to dequeue a set of packets, until a predefined number (\char`\"{}quota\char`\"{}) of packets is dequeued or the netdevice stops the queue disc. A netdevice may stop the queue disc when its transmission queue(s) is/are (almost) full. Also, a netdevice may wake the queue disc when its transmission queue(s) is/are (almost) empty. Waking a queue disc is equivalent to make it run.

The design and implementation of this class is heavily inspired by Linux. For more details, see the traffic-\/control model page. 

\subsection{Member Typedef Documentation}
\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Internal\+Queue@{Internal\+Queue}}
\index{Internal\+Queue@{Internal\+Queue}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Internal\+Queue}{InternalQueue}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Queue}$<${\bf Queue\+Disc\+Item}$>$ {\bf ns3\+::\+Queue\+Disc\+::\+Internal\+Queue}}\hypertarget{classns3_1_1QueueDisc_a3acb7d460465f9f13c6fbbdeae7508f8}{}\label{classns3_1_1QueueDisc_a3acb7d460465f9f13c6fbbdeae7508f8}


Internal queues store \hyperlink{classns3_1_1QueueDiscItem}{Queue\+Disc\+Item} objects. 

\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Parent\+Drop\+Callback@{Parent\+Drop\+Callback}}
\index{Parent\+Drop\+Callback@{Parent\+Drop\+Callback}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Parent\+Drop\+Callback}{ParentDropCallback}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Callback}$<$void, {\bf Ptr}$<$const {\bf Queue\+Disc\+Item}$>$ $>$ {\bf ns3\+::\+Queue\+Disc\+::\+Parent\+Drop\+Callback}}\hypertarget{classns3_1_1QueueDisc_abcb41646ec54f8206bc14df2c93762f4}{}\label{classns3_1_1QueueDisc_abcb41646ec54f8206bc14df2c93762f4}


\hyperlink{classns3_1_1Callback}{Callback} invoked by a child queue disc to notify the parent of a packet drop. 



\subsection{Member Enumeration Documentation}
\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Wake\+Mode@{Wake\+Mode}}
\index{Wake\+Mode@{Wake\+Mode}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Wake\+Mode}{WakeMode}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf ns3\+::\+Queue\+Disc\+::\+Wake\+Mode}}\hypertarget{classns3_1_1QueueDisc_a0b9b32e71d5becf66e6ac4b3d3de7c8b}{}\label{classns3_1_1QueueDisc_a0b9b32e71d5becf66e6ac4b3d3de7c8b}


Used to determine whether the queue disc itself or its children must be activated when a netdevice wakes a transmission queue. 

\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{W\+A\+K\+E\+\_\+\+R\+O\+OT@{W\+A\+K\+E\+\_\+\+R\+O\+OT}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!W\+A\+K\+E\+\_\+\+R\+O\+OT@{W\+A\+K\+E\+\_\+\+R\+O\+OT}}\item[{\em 
W\+A\+K\+E\+\_\+\+R\+O\+OT\hypertarget{classns3_1_1QueueDisc_a0b9b32e71d5becf66e6ac4b3d3de7c8ba56fb0e52526a39cefb47d24550bf47c6}{}\label{classns3_1_1QueueDisc_a0b9b32e71d5becf66e6ac4b3d3de7c8ba56fb0e52526a39cefb47d24550bf47c6}
}]\index{W\+A\+K\+E\+\_\+\+C\+H\+I\+LD@{W\+A\+K\+E\+\_\+\+C\+H\+I\+LD}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!W\+A\+K\+E\+\_\+\+C\+H\+I\+LD@{W\+A\+K\+E\+\_\+\+C\+H\+I\+LD}}\item[{\em 
W\+A\+K\+E\+\_\+\+C\+H\+I\+LD\hypertarget{classns3_1_1QueueDisc_a0b9b32e71d5becf66e6ac4b3d3de7c8bad2dbf3b0b56e3e0d4d0f8f944c4d0fcd}{}\label{classns3_1_1QueueDisc_a0b9b32e71d5becf66e6ac4b3d3de7c8bad2dbf3b0b56e3e0d4d0f8f944c4d0fcd}
}]\end{description}
\end{Desc}

\begin{DoxyCode}
326     \{
327       \hyperlink{classns3_1_1QueueDisc_a0b9b32e71d5becf66e6ac4b3d3de7c8ba56fb0e52526a39cefb47d24550bf47c6}{WAKE\_ROOT} = 0x00,
328       \hyperlink{classns3_1_1QueueDisc_a0b9b32e71d5becf66e6ac4b3d3de7c8bad2dbf3b0b56e3e0d4d0f8f944c4d0fcd}{WAKE\_CHILD} = 0x01
329     \};
\end{DoxyCode}


\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Queue\+Disc@{Queue\+Disc}}
\index{Queue\+Disc@{Queue\+Disc}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Queue\+Disc()}{QueueDisc()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Queue\+Disc\+::\+Queue\+Disc (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1QueueDisc_a0e328ad3196b7d16783b8680722381d6}{}\label{classns3_1_1QueueDisc_a0e328ad3196b7d16783b8680722381d6}

\begin{DoxyCode}
139   :  \hyperlink{classns3_1_1QueueDisc_a7afc9edf0fdb517d088ebe8d3747fbef}{m\_nPackets} (0),
140      \hyperlink{classns3_1_1QueueDisc_a5c9e0e5c858f333bb15089eea58a1e3b}{m\_nBytes} (0),
141      \hyperlink{classns3_1_1QueueDisc_afc5d0c189f8d08582a84fce36fea8745}{m\_nTotalReceivedPackets} (0),
142      \hyperlink{classns3_1_1QueueDisc_a8ebcd87d1d417d30e1e916a406c681c0}{m\_nTotalReceivedBytes} (0),
143      \hyperlink{classns3_1_1QueueDisc_a2974596141f300298255f0ae85faf0cc}{m\_nTotalDroppedPackets} (0),
144      \hyperlink{classns3_1_1QueueDisc_a06645b0916c11b3da27195ed99ca8ce7}{m\_nTotalDroppedBytes} (0),
145      \hyperlink{classns3_1_1QueueDisc_a098d0d792113e93b94c8f89178ac2af6}{m\_nTotalRequeuedPackets} (0),
146      \hyperlink{classns3_1_1QueueDisc_aa1c2f1af9a66078a2507d2632eef82ae}{m\_nTotalRequeuedBytes} (0),
147      \hyperlink{classns3_1_1QueueDisc_a6d00230b60de29bd32d0a2488290380f}{m\_running} (\textcolor{keyword}{false})
148 \{
149   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
150 \}
\end{DoxyCode}
\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!````~Queue\+Disc@{$\sim$\+Queue\+Disc}}
\index{````~Queue\+Disc@{$\sim$\+Queue\+Disc}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{$\sim$\+Queue\+Disc()}{~QueueDisc()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Queue\+Disc\+::$\sim$\+Queue\+Disc (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1QueueDisc_a13e58692c0f31d303091b022cb73c216}{}\label{classns3_1_1QueueDisc_a13e58692c0f31d303091b022cb73c216}

\begin{DoxyCode}
153 \{
154   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
155 \}
\end{DoxyCode}
\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Queue\+Disc@{Queue\+Disc}}
\index{Queue\+Disc@{Queue\+Disc}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Queue\+Disc(const Queue\+Disc \&o)}{QueueDisc(const QueueDisc &o)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Queue\+Disc\+::\+Queue\+Disc (
\begin{DoxyParamCaption}
\item[{const {\bf Queue\+Disc} \&}]{o}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_abec93e451217e4b2660c71abebdd08fd}{}\label{classns3_1_1QueueDisc_abec93e451217e4b2660c71abebdd08fd}


Copy constructor. 


\begin{DoxyParams}{Parameters}
{\em o} & object to copy\\
\hline
\end{DoxyParams}
Defined and unimplemented to avoid misuse 

\subsection{Member Function Documentation}
\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Add\+Internal\+Queue@{Add\+Internal\+Queue}}
\index{Add\+Internal\+Queue@{Add\+Internal\+Queue}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Add\+Internal\+Queue(\+Ptr$<$ Internal\+Queue $>$ queue)}{AddInternalQueue(Ptr< InternalQueue > queue)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Queue\+Disc\+::\+Add\+Internal\+Queue (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Internal\+Queue} $>$}]{queue}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1QueueDisc_a0599223e2a3976ef042a56c2923a2b61}{}\label{classns3_1_1QueueDisc_a0599223e2a3976ef042a56c2923a2b61}


Add an internal queue to the tail of the list of queues. 


\begin{DoxyParams}{Parameters}
{\em queue} & the queue to be added \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
283 \{
284   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
285   \textcolor{comment}{// set the drop callback on the internal queue, so that the queue disc is}
286   \textcolor{comment}{// notified of packets dropped by the internal queue}
287   queue->TraceConnectWithoutContext (\textcolor{stringliteral}{"Drop"}, \hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1QueueDisc_a4e8bbd3afbd927df3342dd015f30b08c}{QueueDisc::Drop}, \textcolor{keyword}{this}));
288   \hyperlink{classns3_1_1QueueDisc_ae6507c7002e15afd8944a34f239331d7}{m\_queues}.push\_back (queue);
289 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2




Here is the caller graph for this function\+:
% FIG 3


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Add\+Packet\+Filter@{Add\+Packet\+Filter}}
\index{Add\+Packet\+Filter@{Add\+Packet\+Filter}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Add\+Packet\+Filter(\+Ptr$<$ Packet\+Filter $>$ filter)}{AddPacketFilter(Ptr< PacketFilter > filter)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Queue\+Disc\+::\+Add\+Packet\+Filter (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet\+Filter} $>$}]{filter}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1QueueDisc_a45efdc512f64cb8e0d57ad4f208ed4b7}{}\label{classns3_1_1QueueDisc_a45efdc512f64cb8e0d57ad4f208ed4b7}


Add a packet filter to the tail of the list of filters used to classify packets. 


\begin{DoxyParams}{Parameters}
{\em filter} & the packet filter to be added \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
306 \{
307   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
308   \hyperlink{classns3_1_1QueueDisc_a04bc2a1d90315527c6ba411eb2cb722a}{m\_filters}.push\_back (filter);
309 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Add\+Queue\+Disc\+Class@{Add\+Queue\+Disc\+Class}}
\index{Add\+Queue\+Disc\+Class@{Add\+Queue\+Disc\+Class}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Add\+Queue\+Disc\+Class(\+Ptr$<$ Queue\+Disc\+Class $>$ qd\+Class)}{AddQueueDiscClass(Ptr< QueueDiscClass > qdClass)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Queue\+Disc\+::\+Add\+Queue\+Disc\+Class (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Queue\+Disc\+Class} $>$}]{qd\+Class}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1QueueDisc_a153f1f65efcaa976c9a93cd53b777416}{}\label{classns3_1_1QueueDisc_a153f1f65efcaa976c9a93cd53b777416}


Add a queue disc class to the tail of the list of classes. 


\begin{DoxyParams}{Parameters}
{\em qd\+Class} & the queue disc class to be added \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
326 \{
327   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
328   \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (qdClass->GetQueueDisc () == 0, \textcolor{stringliteral}{"Cannot add a class with no attached queue
       disc"});
329   \textcolor{comment}{// the child queue disc cannot be one with wake mode equal to WAKE\_CHILD because}
330   \textcolor{comment}{// such queue discs do not implement the enqueue/dequeue methods}
331   \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (qdClass->GetQueueDisc ()->GetWakeMode () == 
      \hyperlink{classns3_1_1QueueDisc_a0b9b32e71d5becf66e6ac4b3d3de7c8bad2dbf3b0b56e3e0d4d0f8f944c4d0fcd}{WAKE\_CHILD},
332                    \textcolor{stringliteral}{"A queue disc with WAKE\_CHILD as wake mode can only be a root queue disc"});
333   \textcolor{comment}{// set the parent drop callback on the child queue disc, so that it can notify}
334   \textcolor{comment}{// packet drops to the parent queue disc}
335   qdClass->GetQueueDisc ()->SetParentDropCallback (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1QueueDisc_a4e8bbd3afbd927df3342dd015f30b08c}{QueueDisc::Drop}, \textcolor{keyword}{this}));
336   \hyperlink{classns3_1_1QueueDisc_a054d624a7a6f10a11cffec1f858feb3c}{m\_classes}.push\_back (qdClass);
337 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5




Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Check\+Config@{Check\+Config}}
\index{Check\+Config@{Check\+Config}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Check\+Config(void)=0}{CheckConfig(void)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool ns3\+::\+Queue\+Disc\+::\+Check\+Config (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [pure virtual]}}\hypertarget{classns3_1_1QueueDisc_ace6ef0c9afd0954c4629ad454bf975f5}{}\label{classns3_1_1QueueDisc_ace6ef0c9afd0954c4629ad454bf975f5}
Check whether the current configuration is correct. Default objects (such as internal queues) might be created by this method to ensure the configuration is correct. \begin{DoxyReturn}{Returns}
true if the configuration is correct, false otherwise 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1RedQueueDisc_a86e75c3ab20213f1451bdc7270d18114}{ns3\+::\+Red\+Queue\+Disc}, \hyperlink{classns3_1_1CoDelQueueDisc_a580a58842272e8110ebae6f1503f6327}{ns3\+::\+Co\+Del\+Queue\+Disc}, \hyperlink{classns3_1_1PieQueueDisc_af6eda43da222e1013754c8ed50ebeda4}{ns3\+::\+Pie\+Queue\+Disc}, \hyperlink{classns3_1_1FqCoDelQueueDisc_a18368ef335c681f62b337862583068a7}{ns3\+::\+Fq\+Co\+Del\+Queue\+Disc}, and \hyperlink{classns3_1_1PfifoFastQueueDisc_a9fa5e68b79b7431cd734f4e8845bdced}{ns3\+::\+Pfifo\+Fast\+Queue\+Disc}.



Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Classify@{Classify}}
\index{Classify@{Classify}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Classify(\+Ptr$<$ Queue\+Disc\+Item $>$ item)}{Classify(Ptr< QueueDiscItem > item)}}]{\setlength{\rightskip}{0pt plus 5cm}int32\+\_\+t ns3\+::\+Queue\+Disc\+::\+Classify (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Queue\+Disc\+Item} $>$}]{item}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1QueueDisc_a560004f3fbca4e2cb9938fa3938f4be3}{}\label{classns3_1_1QueueDisc_a560004f3fbca4e2cb9938fa3938f4be3}
Classify a packet by calling the packet filters, one at a time, until either a filter able to classify the packet is found or all the filters have been processed. 
\begin{DoxyParams}{Parameters}
{\em item} & item to classify \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
-\/1 if no filter able to classify the packet has been found, the value returned by first filter found to be able to classify the packet otherwise. 
\end{DoxyReturn}

\begin{DoxyCode}
354 \{
355   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << item);
356 
357   int32\_t ret = \hyperlink{classns3_1_1PacketFilter_a5395721034f6c71a021436b928a0cd95}{PacketFilter::PF\_NO\_MATCH};
358   \textcolor{keywordflow}{for} (std::vector<Ptr<PacketFilter> >::iterator \hyperlink{buildings__pathloss_8m_aa52d3a6e3de5a80a97c12364caeaa125}{f} = \hyperlink{classns3_1_1QueueDisc_a04bc2a1d90315527c6ba411eb2cb722a}{m\_filters}.begin ();
359        \hyperlink{buildings__pathloss_8m_aa52d3a6e3de5a80a97c12364caeaa125}{f} != \hyperlink{classns3_1_1QueueDisc_a04bc2a1d90315527c6ba411eb2cb722a}{m\_filters}.end () && ret == \hyperlink{classns3_1_1PacketFilter_a5395721034f6c71a021436b928a0cd95}{PacketFilter::PF\_NO\_MATCH}; 
      \hyperlink{buildings__pathloss_8m_aa52d3a6e3de5a80a97c12364caeaa125}{f}++)
360     \{
361       ret = (*f)->Classify (item);
362     \}
363   \textcolor{keywordflow}{return} ret;
364 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Dequeue@{Dequeue}}
\index{Dequeue@{Dequeue}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Dequeue(void)}{Dequeue(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Queue\+Disc\+Item} $>$ ns3\+::\+Queue\+Disc\+::\+Dequeue (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1QueueDisc_a6c13fc489822c1487f61c2289f2e3629}{}\label{classns3_1_1QueueDisc_a6c13fc489822c1487f61c2289f2e3629}
Request the queue discipline to extract a packet. This function only updates the statistics and calls the (private) Do\+Dequeue function, which must be implemented by derived classes. \begin{DoxyReturn}{Returns}
0 if the operation was not successful; the item otherwise. 
\end{DoxyReturn}

\begin{DoxyCode}
436 \{
437   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
438 
439   Ptr<QueueDiscItem> item;
440   item = \hyperlink{classns3_1_1QueueDisc_afefae1a05f45db101c2c75d67a440c63}{DoDequeue} ();
441 
442   \textcolor{keywordflow}{if} (item != 0)
443     \{
444       \hyperlink{classns3_1_1QueueDisc_a7afc9edf0fdb517d088ebe8d3747fbef}{m\_nPackets}--;
445       \hyperlink{classns3_1_1QueueDisc_a5c9e0e5c858f333bb15089eea58a1e3b}{m\_nBytes} -= item->GetSize ();
446 
447       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"m\_traceDequeue (p)"});
448       \hyperlink{classns3_1_1QueueDisc_a1be3a308037b0feb28ae284b9be04bfc}{m\_traceDequeue} (item);
449     \}
450 
451   \textcolor{keywordflow}{return} item;
452 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9




Here is the caller graph for this function\+:
% FIG 10


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Dequeue\+Packet@{Dequeue\+Packet}}
\index{Dequeue\+Packet@{Dequeue\+Packet}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Dequeue\+Packet(void)}{DequeuePacket(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Queue\+Disc\+Item} $>$ ns3\+::\+Queue\+Disc\+::\+Dequeue\+Packet (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_aab4beacb808b917dde38fe835c199f28}{}\label{classns3_1_1QueueDisc_aab4beacb808b917dde38fe835c199f28}
Modelled after the Linux function dequeue\+\_\+skb (net/sched/sch\+\_\+generic.\+c) \begin{DoxyReturn}{Returns}
the requeued packet, if any, or the packet dequeued by the queue disc, otherwise. 
\end{DoxyReturn}

\begin{DoxyCode}
518 \{
519   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
520   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1QueueDisc_a265febf26e8325dbb3ba1f905ea1912d}{m\_devQueueIface});
521   Ptr<QueueDiscItem> item;
522 
523   \textcolor{comment}{// First check if there is a requeued packet}
524   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1QueueDisc_a43cae3d282e28914b1b5e1b782c7e854}{m\_requeued} != 0)
525     \{
526         \textcolor{comment}{// If the queue where the requeued packet is destined to is not stopped, return}
527         \textcolor{comment}{// the requeued packet; otherwise, return an empty packet.}
528         \textcolor{comment}{// If the device does not support flow control, the device queue is never stopped}
529         \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1QueueDisc_a265febf26e8325dbb3ba1f905ea1912d}{m\_devQueueIface}->GetTxQueue (\hyperlink{classns3_1_1QueueDisc_a43cae3d282e28914b1b5e1b782c7e854}{m\_requeued}->GetTxQueueIndex ())->
      IsStopped ())
530           \{
531             item = \hyperlink{classns3_1_1QueueDisc_a43cae3d282e28914b1b5e1b782c7e854}{m\_requeued};
532             \hyperlink{classns3_1_1QueueDisc_a43cae3d282e28914b1b5e1b782c7e854}{m\_requeued} = 0;
533 
534             \hyperlink{classns3_1_1QueueDisc_a7afc9edf0fdb517d088ebe8d3747fbef}{m\_nPackets}--;
535             \hyperlink{classns3_1_1QueueDisc_a5c9e0e5c858f333bb15089eea58a1e3b}{m\_nBytes} -= item->GetSize ();
536 
537             \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"m\_traceDequeue (p)"});
538             \hyperlink{classns3_1_1QueueDisc_a1be3a308037b0feb28ae284b9be04bfc}{m\_traceDequeue} (item);
539           \}
540     \}
541   \textcolor{keywordflow}{else}
542     \{
543       \textcolor{comment}{// If the device is multi-queue (actually, Linux checks if the queue disc has}
544       \textcolor{comment}{// multiple queues), ask the queue disc to dequeue a packet (a multi-queue aware}
545       \textcolor{comment}{// queue disc should try not to dequeue a packet destined to a stopped queue).}
546       \textcolor{comment}{// Otherwise, ask the queue disc to dequeue a packet only if the (unique) queue}
547       \textcolor{comment}{// is not stopped.}
548       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1QueueDisc_a265febf26e8325dbb3ba1f905ea1912d}{m\_devQueueIface}->GetNTxQueues ()>1 || !\hyperlink{classns3_1_1QueueDisc_a265febf26e8325dbb3ba1f905ea1912d}{m\_devQueueIface}->GetTxQueue 
      (0)->IsStopped ())
549         \{
550           item = \hyperlink{classns3_1_1QueueDisc_a6c13fc489822c1487f61c2289f2e3629}{Dequeue} ();
551           \textcolor{comment}{// If the item is not null, add the header to the packet.}
552           \textcolor{keywordflow}{if} (item != 0)
553             \{
554               item->AddHeader ();
555             \}
556           \textcolor{comment}{// Here, Linux tries bulk dequeues}
557         \}
558     \}
559   \textcolor{keywordflow}{return} item;
560 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 11




Here is the caller graph for this function\+:
% FIG 12


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Do\+Dequeue@{Do\+Dequeue}}
\index{Do\+Dequeue@{Do\+Dequeue}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Do\+Dequeue(void)=0}{DoDequeue(void)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Ptr}$<${\bf Queue\+Disc\+Item}$>$ ns3\+::\+Queue\+Disc\+::\+Do\+Dequeue (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [pure virtual]}}\hypertarget{classns3_1_1QueueDisc_afefae1a05f45db101c2c75d67a440c63}{}\label{classns3_1_1QueueDisc_afefae1a05f45db101c2c75d67a440c63}
This function actually extracts a packet from the queue disc. \begin{DoxyReturn}{Returns}
0 if the operation was not successful; the item otherwise. 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1RedQueueDisc_a166dbfb99b576f2ff6e1d1871b6afb14}{ns3\+::\+Red\+Queue\+Disc}, \hyperlink{classns3_1_1CoDelQueueDisc_a6128cb8655b87b67f04424c68058e751}{ns3\+::\+Co\+Del\+Queue\+Disc}, \hyperlink{classns3_1_1PieQueueDisc_a7e3501e4e4a58b13d619f983a303e9cf}{ns3\+::\+Pie\+Queue\+Disc}, \hyperlink{classns3_1_1FqCoDelQueueDisc_a2b531c934b2559ab878dc97f95f2ca3e}{ns3\+::\+Fq\+Co\+Del\+Queue\+Disc}, and \hyperlink{classns3_1_1PfifoFastQueueDisc_aa5fe80fa033b5df94f626d99e99d52f3}{ns3\+::\+Pfifo\+Fast\+Queue\+Disc}.



Here is the caller graph for this function\+:
% FIG 13


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Do\+Dispose(void)}{DoDispose(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Queue\+Disc\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1QueueDisc_ad2eafba04edabab10bc6ea9d5ea273e1}{}\label{classns3_1_1QueueDisc_ad2eafba04edabab10bc6ea9d5ea273e1}


Dispose of the object. 



Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.



Reimplemented in \hyperlink{classns3_1_1RedQueueDisc_abacb7d43d9b3f20a59b5e4a57c7be8e2}{ns3\+::\+Red\+Queue\+Disc}, and \hyperlink{classns3_1_1PieQueueDisc_a8753e73c53483d005228c173cec22de9}{ns3\+::\+Pie\+Queue\+Disc}.


\begin{DoxyCode}
159 \{
160   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
161   \hyperlink{classns3_1_1QueueDisc_ae6507c7002e15afd8944a34f239331d7}{m\_queues}.clear ();
162   \hyperlink{classns3_1_1QueueDisc_a04bc2a1d90315527c6ba411eb2cb722a}{m\_filters}.clear ();
163   \hyperlink{classns3_1_1QueueDisc_a054d624a7a6f10a11cffec1f858feb3c}{m\_classes}.clear ();
164   \hyperlink{classns3_1_1QueueDisc_ad9a47fe0eb33b8e1ef760966b1ad6b7c}{m\_device} = 0;
165   \hyperlink{classns3_1_1QueueDisc_a265febf26e8325dbb3ba1f905ea1912d}{m\_devQueueIface} = 0;
166   \hyperlink{classns3_1_1QueueDisc_a43cae3d282e28914b1b5e1b782c7e854}{m\_requeued} = 0;
167   \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{Object::DoDispose} ();
168 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 14




Here is the caller graph for this function\+:
% FIG 15


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Do\+Enqueue@{Do\+Enqueue}}
\index{Do\+Enqueue@{Do\+Enqueue}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Do\+Enqueue(\+Ptr$<$ Queue\+Disc\+Item $>$ item)=0}{DoEnqueue(Ptr< QueueDiscItem > item)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool ns3\+::\+Queue\+Disc\+::\+Do\+Enqueue (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Queue\+Disc\+Item} $>$}]{item}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [pure virtual]}}\hypertarget{classns3_1_1QueueDisc_a22d77d2ec26e6fe5476d976d9d5e3a66}{}\label{classns3_1_1QueueDisc_a22d77d2ec26e6fe5476d976d9d5e3a66}
This function actually enqueues a packet into the queue disc. 
\begin{DoxyParams}{Parameters}
{\em item} & item to enqueue \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the operation was successful; false otherwise 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1RedQueueDisc_ae0be138c29bf158336a7a74a90790c2a}{ns3\+::\+Red\+Queue\+Disc}, \hyperlink{classns3_1_1PieQueueDisc_a583c0ac9ca43810a32af239e23e31614}{ns3\+::\+Pie\+Queue\+Disc}, \hyperlink{classns3_1_1CoDelQueueDisc_a0c68a40b422edf668a1f225be498ff97}{ns3\+::\+Co\+Del\+Queue\+Disc}, \hyperlink{classns3_1_1FqCoDelQueueDisc_a9763ff304b86d8c3d2f951d20e102d0a}{ns3\+::\+Fq\+Co\+Del\+Queue\+Disc}, and \hyperlink{classns3_1_1PfifoFastQueueDisc_aac7fa518f6f59bf89a7a5fa5b9579d8b}{ns3\+::\+Pfifo\+Fast\+Queue\+Disc}.



Here is the caller graph for this function\+:
% FIG 16


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Do\+Initialize@{Do\+Initialize}}
\index{Do\+Initialize@{Do\+Initialize}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Do\+Initialize(void)}{DoInitialize(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Queue\+Disc\+::\+Do\+Initialize (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1QueueDisc_a7b75249652866a0725c6f280bd618123}{}\label{classns3_1_1QueueDisc_a7b75249652866a0725c6f280bd618123}


Check whether the configuration is correct and initialize parameters. 

This method is not virtual to prevent subclasses from redefining it. Subclasses must instead provide the implementation of the Check\+Config and Initialize\+Params methods (which are called by this method). 

Reimplemented from \hyperlink{classns3_1_1Object_af8482a521433409fb5c7f749398c9dbe}{ns3\+::\+Object}.


\begin{DoxyCode}
172 \{
173   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
174   \textcolor{comment}{// When adding a new interface, the traffic control aggregates}
175   \textcolor{comment}{// a NetDeviceQueueInterface object to the netdevice}
176   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1QueueDisc_ad9a47fe0eb33b8e1ef760966b1ad6b7c}{m\_device})
177     \{
178       \hyperlink{classns3_1_1QueueDisc_a265febf26e8325dbb3ba1f905ea1912d}{m\_devQueueIface} = \hyperlink{classns3_1_1QueueDisc_ad9a47fe0eb33b8e1ef760966b1ad6b7c}{m\_device}->GetObject<NetDeviceQueueInterface> ();
179     \}
180 
181   \textcolor{comment}{// Check the configuration and initialize the parameters of this queue disc}
182   \textcolor{keywordtype}{bool} ok = \hyperlink{classns3_1_1QueueDisc_ace6ef0c9afd0954c4629ad454bf975f5}{CheckConfig} ();
183   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (ok, \textcolor{stringliteral}{"The queue disc configuration is not correct"});
184   \hyperlink{unused_8h_a3ba03ad859378e9f01285afb60f0e3ab}{NS\_UNUSED} (ok); \textcolor{comment}{// suppress compiler warning}
185   \hyperlink{classns3_1_1QueueDisc_a600ed3e7110b9d506b28ad62beb84592}{InitializeParams} ();
186 
187   \textcolor{comment}{// Check the configuration and initialize the parameters of the child queue discs}
188   \textcolor{keywordflow}{for} (std::vector<Ptr<QueueDiscClass> >::iterator cl = \hyperlink{classns3_1_1QueueDisc_a054d624a7a6f10a11cffec1f858feb3c}{m\_classes}.begin ();
189        cl != \hyperlink{classns3_1_1QueueDisc_a054d624a7a6f10a11cffec1f858feb3c}{m\_classes}.end (); cl++)
190     \{
191       (*cl)->GetQueueDisc ()->Initialize ();
192     \}
193 
194   \hyperlink{classns3_1_1Object_af8482a521433409fb5c7f749398c9dbe}{Object::DoInitialize} ();
195 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 17


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Do\+Peek@{Do\+Peek}}
\index{Do\+Peek@{Do\+Peek}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Do\+Peek(void) const =0}{DoPeek(void) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Ptr}$<$const {\bf Queue\+Disc\+Item}$>$ ns3\+::\+Queue\+Disc\+::\+Do\+Peek (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [pure virtual]}}\hypertarget{classns3_1_1QueueDisc_aff6a0523b7132a4df6cf202ab49bd788}{}\label{classns3_1_1QueueDisc_aff6a0523b7132a4df6cf202ab49bd788}
This function returns a copy of the next packet the queue disc will extract. \begin{DoxyReturn}{Returns}
0 if the operation was not successful; the packet otherwise. 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1RedQueueDisc_a351367bffb926ff50712cc269d8e3442}{ns3\+::\+Red\+Queue\+Disc}, \hyperlink{classns3_1_1CoDelQueueDisc_ab3a785ea16fa4ef303519b7bec301a6c}{ns3\+::\+Co\+Del\+Queue\+Disc}, \hyperlink{classns3_1_1PieQueueDisc_a7603fcf6f104697bef0f1a1d24826071}{ns3\+::\+Pie\+Queue\+Disc}, \hyperlink{classns3_1_1FqCoDelQueueDisc_ad17794fb594849c91102f5cc267b55ca}{ns3\+::\+Fq\+Co\+Del\+Queue\+Disc}, and \hyperlink{classns3_1_1PfifoFastQueueDisc_ac94bb03da6c61c6b4d2755ca77704470}{ns3\+::\+Pfifo\+Fast\+Queue\+Disc}.



Here is the caller graph for this function\+:
% FIG 18


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Drop@{Drop}}
\index{Drop@{Drop}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Drop(\+Ptr$<$ const Queue\+Disc\+Item $>$ item)}{Drop(Ptr< const QueueDiscItem > item)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Queue\+Disc\+::\+Drop (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Queue\+Disc\+Item} $>$}]{item}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classns3_1_1QueueDisc_a4e8bbd3afbd927df3342dd015f30b08c}{}\label{classns3_1_1QueueDisc_a4e8bbd3afbd927df3342dd015f30b08c}


Drop a packet. 


\begin{DoxyParams}{Parameters}
{\em item} & item that was dropped This method is called by subclasses to notify parent (this class) of packet drops. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
380 \{
381   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << item);
382 
383   \textcolor{comment}{// if the wake mode of this queue disc is WAKE\_CHILD, packets are directly}
384   \textcolor{comment}{// enqueued/dequeued from the child queue discs, thus this queue disc does not}
385   \textcolor{comment}{// keep valid packets/bytes counters and no actions need to be performed.}
386   \textcolor{keywordflow}{if} (this->\hyperlink{classns3_1_1QueueDisc_a51a079153b474eec1bad9abe715d9510}{GetWakeMode} () == \hyperlink{classns3_1_1QueueDisc_a0b9b32e71d5becf66e6ac4b3d3de7c8bad2dbf3b0b56e3e0d4d0f8f944c4d0fcd}{WAKE\_CHILD})
387     \{
388       \textcolor{keywordflow}{return};
389     \}
390 
391   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\hyperlink{classns3_1_1QueueDisc_a7afc9edf0fdb517d088ebe8d3747fbef}{m\_nPackets} >= 1u, \textcolor{stringliteral}{"No packet in the queue disc, cannot drop"});
392   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\hyperlink{classns3_1_1QueueDisc_a5c9e0e5c858f333bb15089eea58a1e3b}{m\_nBytes} >= item->GetSize (), \textcolor{stringliteral}{"The size of the packet that"}
393                  << \textcolor{stringliteral}{" is reported to be dropped is greater than the amount of bytes"}
394                  << \textcolor{stringliteral}{"stored in the queue disc"});
395 
396   \hyperlink{classns3_1_1QueueDisc_a7afc9edf0fdb517d088ebe8d3747fbef}{m\_nPackets}--;
397   \hyperlink{classns3_1_1QueueDisc_a5c9e0e5c858f333bb15089eea58a1e3b}{m\_nBytes} -= item->GetSize ();
398   \hyperlink{classns3_1_1QueueDisc_a2974596141f300298255f0ae85faf0cc}{m\_nTotalDroppedPackets}++;
399   \hyperlink{classns3_1_1QueueDisc_a06645b0916c11b3da27195ed99ca8ce7}{m\_nTotalDroppedBytes} += item->GetSize ();
400 
401   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"m\_traceDrop (p)"});
402   \hyperlink{classns3_1_1QueueDisc_a4d59074e7f6aa601eee90f5cd87d423f}{m\_traceDrop} (item);
403 
404   \hyperlink{classns3_1_1QueueDisc_aee0b845da519a8121dbe5a397ed63b54}{NotifyParentDrop} (item);
405 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 19




Here is the caller graph for this function\+:
% FIG 20


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Enqueue@{Enqueue}}
\index{Enqueue@{Enqueue}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Enqueue(\+Ptr$<$ Queue\+Disc\+Item $>$ item)}{Enqueue(Ptr< QueueDiscItem > item)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Queue\+Disc\+::\+Enqueue (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Queue\+Disc\+Item} $>$}]{item}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1QueueDisc_af452fb01b98fed312125163f1fe85431}{}\label{classns3_1_1QueueDisc_af452fb01b98fed312125163f1fe85431}
Pass a packet to store to the queue discipline. This function only updates the statistics and calls the (private) Do\+Enqueue function, which must be implemented by derived classes. 
\begin{DoxyParams}{Parameters}
{\em item} & item to enqueue \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the operation was successful; false otherwise 
\end{DoxyReturn}

\begin{DoxyCode}
420 \{
421   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << item);
422 
423   \hyperlink{classns3_1_1QueueDisc_a7afc9edf0fdb517d088ebe8d3747fbef}{m\_nPackets}++;
424   \hyperlink{classns3_1_1QueueDisc_a5c9e0e5c858f333bb15089eea58a1e3b}{m\_nBytes} += item->GetSize ();
425   \hyperlink{classns3_1_1QueueDisc_afc5d0c189f8d08582a84fce36fea8745}{m\_nTotalReceivedPackets}++;
426   \hyperlink{classns3_1_1QueueDisc_a8ebcd87d1d417d30e1e916a406c681c0}{m\_nTotalReceivedBytes} += item->GetSize ();
427 
428   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"m\_traceEnqueue (p)"});
429   \hyperlink{classns3_1_1QueueDisc_a7614788f662bc6df8c98a646f494dd61}{m\_traceEnqueue} (item);
430 
431   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1QueueDisc_a22d77d2ec26e6fe5476d976d9d5e3a66}{DoEnqueue} (item);
432 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 21




Here is the caller graph for this function\+:
% FIG 22


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Get\+Internal\+Queue@{Get\+Internal\+Queue}}
\index{Get\+Internal\+Queue@{Get\+Internal\+Queue}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Get\+Internal\+Queue(uint32\+\_\+t i) const }{GetInternalQueue(uint32_t i) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Queue\+Disc\+::\+Internal\+Queue} $>$ ns3\+::\+Queue\+Disc\+::\+Get\+Internal\+Queue (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1QueueDisc_adf09b498c07c5677c26ea4b8309def74}{}\label{classns3_1_1QueueDisc_adf09b498c07c5677c26ea4b8309def74}


Get the i-\/th internal queue. 


\begin{DoxyParams}{Parameters}
{\em i} & the index of the queue \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the i-\/th internal queue. 
\end{DoxyReturn}

\begin{DoxyCode}
293 \{
294   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1QueueDisc_ae6507c7002e15afd8944a34f239331d7}{m\_queues}.size ());
295   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1QueueDisc_ae6507c7002e15afd8944a34f239331d7}{m\_queues}[\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}];
296 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 23


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Get\+N\+Bytes@{Get\+N\+Bytes}}
\index{Get\+N\+Bytes@{Get\+N\+Bytes}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Get\+N\+Bytes(void) const }{GetNBytes(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Queue\+Disc\+::\+Get\+N\+Bytes (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1QueueDisc_ac87d3bbf7381d64808f6764bdfd812e5}{}\label{classns3_1_1QueueDisc_ac87d3bbf7381d64808f6764bdfd812e5}


Get the amount of bytes stored by the queue disc. 

\begin{DoxyReturn}{Returns}
the amount of bytes stored by the queue disc.
\end{DoxyReturn}
Note that the amount of bytes stored by the queue disc is updated as soon as a packet is received by the queue disc and before actually enqueuing the packet (i.\+e., before calling Do\+Enqueue). Thus, while implementing the Do\+Enqueue method of a subclass, keep in mind that Get\+N\+Bytes returns the amount of bytes stored in the queue disc, including the size of the packet that we are trying to enqueue. 
\begin{DoxyCode}
206 \{
207   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
208   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1QueueDisc_a5c9e0e5c858f333bb15089eea58a1e3b}{m\_nBytes};
209 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 24


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Get\+Net\+Device@{Get\+Net\+Device}}
\index{Get\+Net\+Device@{Get\+Net\+Device}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Get\+Net\+Device(void) const }{GetNetDevice(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Net\+Device} $>$ ns3\+::\+Queue\+Disc\+::\+Get\+Net\+Device (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1QueueDisc_afae7bdc1c4f46a06bf31e269f832a41a}{}\label{classns3_1_1QueueDisc_afae7bdc1c4f46a06bf31e269f832a41a}


Get the \hyperlink{classns3_1_1NetDevice}{Net\+Device} on which this queue discipline is installed. 

\begin{DoxyReturn}{Returns}
the \hyperlink{classns3_1_1NetDevice}{Net\+Device} on which this queue discipline is installed. 
\end{DoxyReturn}

\begin{DoxyCode}
262 \{
263   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
264   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1QueueDisc_ad9a47fe0eb33b8e1ef760966b1ad6b7c}{m\_device};
265 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 25


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Get\+N\+Internal\+Queues@{Get\+N\+Internal\+Queues}}
\index{Get\+N\+Internal\+Queues@{Get\+N\+Internal\+Queues}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Get\+N\+Internal\+Queues(void) const }{GetNInternalQueues(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Queue\+Disc\+::\+Get\+N\+Internal\+Queues (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1QueueDisc_a98e658dc1b0b32104ffc9e07afd205c6}{}\label{classns3_1_1QueueDisc_a98e658dc1b0b32104ffc9e07afd205c6}


Get the number of internal queues. 

\begin{DoxyReturn}{Returns}
the number of internal queues. 
\end{DoxyReturn}

\begin{DoxyCode}
300 \{
301   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1QueueDisc_ae6507c7002e15afd8944a34f239331d7}{m\_queues}.size ();
302 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 26


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Get\+N\+Packet\+Filters@{Get\+N\+Packet\+Filters}}
\index{Get\+N\+Packet\+Filters@{Get\+N\+Packet\+Filters}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Get\+N\+Packet\+Filters(void) const }{GetNPacketFilters(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Queue\+Disc\+::\+Get\+N\+Packet\+Filters (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1QueueDisc_aff24dd5be3fe3aa46b88c00659e09b23}{}\label{classns3_1_1QueueDisc_aff24dd5be3fe3aa46b88c00659e09b23}


Get the number of packet filters. 

\begin{DoxyReturn}{Returns}
the number of packet filters. 
\end{DoxyReturn}

\begin{DoxyCode}
320 \{
321   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1QueueDisc_a04bc2a1d90315527c6ba411eb2cb722a}{m\_filters}.size ();
322 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 27


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Get\+N\+Packets@{Get\+N\+Packets}}
\index{Get\+N\+Packets@{Get\+N\+Packets}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Get\+N\+Packets(void) const }{GetNPackets(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Queue\+Disc\+::\+Get\+N\+Packets (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1QueueDisc_a6ee992f32c1671512f0948fd6cc46a7e}{}\label{classns3_1_1QueueDisc_a6ee992f32c1671512f0948fd6cc46a7e}


Get the number of packets stored by the queue disc. 

\begin{DoxyReturn}{Returns}
the number of packets stored by the queue disc.
\end{DoxyReturn}
Note that the number of packets stored by the queue disc is updated as soon as a packet is received by the queue disc and before actually enqueuing the packet (i.\+e., before calling Do\+Enqueue). Thus, while implementing the Do\+Enqueue method of a subclass, keep in mind that Get\+N\+Packets returns the number of packets stored in the queue disc, including the packet that we are trying to enqueue. 
\begin{DoxyCode}
199 \{
200   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
201   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1QueueDisc_a7afc9edf0fdb517d088ebe8d3747fbef}{m\_nPackets};
202 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 28


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Get\+N\+Queue\+Disc\+Classes@{Get\+N\+Queue\+Disc\+Classes}}
\index{Get\+N\+Queue\+Disc\+Classes@{Get\+N\+Queue\+Disc\+Classes}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Get\+N\+Queue\+Disc\+Classes(void) const }{GetNQueueDiscClasses(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Queue\+Disc\+::\+Get\+N\+Queue\+Disc\+Classes (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1QueueDisc_a8165c6afde992b073bc4d3bb283ed138}{}\label{classns3_1_1QueueDisc_a8165c6afde992b073bc4d3bb283ed138}


Get the number of queue disc classes. 

\begin{DoxyReturn}{Returns}
the number of queue disc classes. 
\end{DoxyReturn}

\begin{DoxyCode}
348 \{
349   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1QueueDisc_a054d624a7a6f10a11cffec1f858feb3c}{m\_classes}.size ();
350 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 29


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Get\+Packet\+Filter@{Get\+Packet\+Filter}}
\index{Get\+Packet\+Filter@{Get\+Packet\+Filter}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Get\+Packet\+Filter(uint32\+\_\+t i) const }{GetPacketFilter(uint32_t i) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Packet\+Filter} $>$ ns3\+::\+Queue\+Disc\+::\+Get\+Packet\+Filter (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1QueueDisc_a35a230851eabeb444ea7e00798895b42}{}\label{classns3_1_1QueueDisc_a35a230851eabeb444ea7e00798895b42}


Get the i-\/th packet filter. 


\begin{DoxyParams}{Parameters}
{\em i} & the index of the packet filter \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the i-\/th packet filter. 
\end{DoxyReturn}

\begin{DoxyCode}
313 \{
314   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1QueueDisc_a04bc2a1d90315527c6ba411eb2cb722a}{m\_filters}.size ());
315   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1QueueDisc_a04bc2a1d90315527c6ba411eb2cb722a}{m\_filters}[\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}];
316 \}
\end{DoxyCode}
\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Get\+Queue\+Disc\+Class@{Get\+Queue\+Disc\+Class}}
\index{Get\+Queue\+Disc\+Class@{Get\+Queue\+Disc\+Class}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Get\+Queue\+Disc\+Class(uint32\+\_\+t i) const }{GetQueueDiscClass(uint32_t i) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Queue\+Disc\+Class} $>$ ns3\+::\+Queue\+Disc\+::\+Get\+Queue\+Disc\+Class (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1QueueDisc_a584d228f7bff3f754d32793a38134556}{}\label{classns3_1_1QueueDisc_a584d228f7bff3f754d32793a38134556}


Get the i-\/th queue disc class. 


\begin{DoxyParams}{Parameters}
{\em i} & the index of the queue disc class \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the i-\/th queue disc class. 
\end{DoxyReturn}

\begin{DoxyCode}
341 \{
342   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1QueueDisc_a054d624a7a6f10a11cffec1f858feb3c}{m\_classes}.size ());
343   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1QueueDisc_a054d624a7a6f10a11cffec1f858feb3c}{m\_classes}[\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}];
344 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 30


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Get\+Quota@{Get\+Quota}}
\index{Get\+Quota@{Get\+Quota}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Get\+Quota(void) const }{GetQuota(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Queue\+Disc\+::\+Get\+Quota (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1QueueDisc_a1d058b896f93e346227a59c49085626e}{}\label{classns3_1_1QueueDisc_a1d058b896f93e346227a59c49085626e}


Get the maximum number of dequeue operations following a packet enqueue. 

\begin{DoxyReturn}{Returns}
the maximum number of dequeue operations following a packet enqueue. 
\end{DoxyReturn}

\begin{DoxyCode}
276 \{
277   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
278   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1QueueDisc_a4f7e8c8503be408b6bbf82e0648c9fc8}{m\_quota};
279 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 31


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Get\+Total\+Dropped\+Bytes@{Get\+Total\+Dropped\+Bytes}}
\index{Get\+Total\+Dropped\+Bytes@{Get\+Total\+Dropped\+Bytes}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Get\+Total\+Dropped\+Bytes(void) const }{GetTotalDroppedBytes(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Queue\+Disc\+::\+Get\+Total\+Dropped\+Bytes (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1QueueDisc_adea5022bc83cb149d66b667edfe85745}{}\label{classns3_1_1QueueDisc_adea5022bc83cb149d66b667edfe85745}


Get the total amount of dropped bytes. 

\begin{DoxyReturn}{Returns}
the total amount of dropped bytes. 
\end{DoxyReturn}

\begin{DoxyCode}
234 \{
235   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
236   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1QueueDisc_a06645b0916c11b3da27195ed99ca8ce7}{m\_nTotalDroppedBytes};
237 \}
\end{DoxyCode}
\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Get\+Total\+Dropped\+Packets@{Get\+Total\+Dropped\+Packets}}
\index{Get\+Total\+Dropped\+Packets@{Get\+Total\+Dropped\+Packets}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Get\+Total\+Dropped\+Packets(void) const }{GetTotalDroppedPackets(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Queue\+Disc\+::\+Get\+Total\+Dropped\+Packets (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1QueueDisc_a0ec6ad7777a361db9a1a609bede088a9}{}\label{classns3_1_1QueueDisc_a0ec6ad7777a361db9a1a609bede088a9}


Get the total number of dropped packets. 

\begin{DoxyReturn}{Returns}
the total number of dropped packets. 
\end{DoxyReturn}

\begin{DoxyCode}
227 \{
228   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
229   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1QueueDisc_a2974596141f300298255f0ae85faf0cc}{m\_nTotalDroppedPackets};
230 \}
\end{DoxyCode}
\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Get\+Total\+Received\+Bytes@{Get\+Total\+Received\+Bytes}}
\index{Get\+Total\+Received\+Bytes@{Get\+Total\+Received\+Bytes}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Get\+Total\+Received\+Bytes(void) const }{GetTotalReceivedBytes(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Queue\+Disc\+::\+Get\+Total\+Received\+Bytes (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1QueueDisc_a954d8df1c4519c41a35e5f7c805a2141}{}\label{classns3_1_1QueueDisc_a954d8df1c4519c41a35e5f7c805a2141}


Get the total amount of received bytes. 

\begin{DoxyReturn}{Returns}
the total amount of received bytes. 
\end{DoxyReturn}

\begin{DoxyCode}
220 \{
221   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
222   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1QueueDisc_a8ebcd87d1d417d30e1e916a406c681c0}{m\_nTotalReceivedBytes};
223 \}
\end{DoxyCode}
\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Get\+Total\+Received\+Packets@{Get\+Total\+Received\+Packets}}
\index{Get\+Total\+Received\+Packets@{Get\+Total\+Received\+Packets}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Get\+Total\+Received\+Packets(void) const }{GetTotalReceivedPackets(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Queue\+Disc\+::\+Get\+Total\+Received\+Packets (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1QueueDisc_ae28596b0b2ad428a9140726b0a0943c7}{}\label{classns3_1_1QueueDisc_ae28596b0b2ad428a9140726b0a0943c7}


Get the total number of received packets. 

\begin{DoxyReturn}{Returns}
the total number of received packets. 
\end{DoxyReturn}

\begin{DoxyCode}
213 \{
214   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
215   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1QueueDisc_afc5d0c189f8d08582a84fce36fea8745}{m\_nTotalReceivedPackets};
216 \}
\end{DoxyCode}
\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Get\+Total\+Requeued\+Bytes@{Get\+Total\+Requeued\+Bytes}}
\index{Get\+Total\+Requeued\+Bytes@{Get\+Total\+Requeued\+Bytes}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Get\+Total\+Requeued\+Bytes(void) const }{GetTotalRequeuedBytes(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Queue\+Disc\+::\+Get\+Total\+Requeued\+Bytes (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1QueueDisc_a401e7e3609c49327ca72b1e5d7b0fcbc}{}\label{classns3_1_1QueueDisc_a401e7e3609c49327ca72b1e5d7b0fcbc}


Get the total amount of requeued bytes. 

\begin{DoxyReturn}{Returns}
the total amount of requeued bytes. 
\end{DoxyReturn}

\begin{DoxyCode}
248 \{
249   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
250   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1QueueDisc_aa1c2f1af9a66078a2507d2632eef82ae}{m\_nTotalRequeuedBytes};
251 \}
\end{DoxyCode}
\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Get\+Total\+Requeued\+Packets@{Get\+Total\+Requeued\+Packets}}
\index{Get\+Total\+Requeued\+Packets@{Get\+Total\+Requeued\+Packets}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Get\+Total\+Requeued\+Packets(void) const }{GetTotalRequeuedPackets(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Queue\+Disc\+::\+Get\+Total\+Requeued\+Packets (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1QueueDisc_ab7a24479351628abd5c21d5c25d77038}{}\label{classns3_1_1QueueDisc_ab7a24479351628abd5c21d5c25d77038}


Get the total number of requeued packets. 

\begin{DoxyReturn}{Returns}
the total number of requeued packets. 
\end{DoxyReturn}

\begin{DoxyCode}
241 \{
242   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
243   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1QueueDisc_a098d0d792113e93b94c8f89178ac2af6}{m\_nTotalRequeuedPackets};
244 \}
\end{DoxyCode}
\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Queue\+Disc\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1QueueDisc_a425dcb905ce9b18fa5e83316fc63961e}{}\label{classns3_1_1QueueDisc_a425dcb905ce9b18fa5e83316fc63961e}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
93 \{
94   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::QueueDisc"})
95     .SetParent<\hyperlink{classns3_1_1Object_a40860402e64d8008fb42329df7097cdb}{Object}> ()
96     .SetGroupName (\textcolor{stringliteral}{"TrafficControl"})
97     .AddAttribute (\textcolor{stringliteral}{"Quota"}, \textcolor{stringliteral}{"The maximum number of packets dequeued in a qdisc run"},
98                    UintegerValue (\hyperlink{classns3_1_1QueueDisc_a057a2c6dd982ffb206ce2a42eb4f46fa}{DEFAULT\_QUOTA}),
99                    MakeUintegerAccessor (&\hyperlink{classns3_1_1QueueDisc_ab35519e5f10b3226c4b2a07e009bcc20}{QueueDisc::SetQuota},
100                                          &\hyperlink{classns3_1_1QueueDisc_a1d058b896f93e346227a59c49085626e}{QueueDisc::GetQuota}),
101                    MakeUintegerChecker<uint32\_t> ())
102     .AddAttribute (\textcolor{stringliteral}{"InternalQueueList"}, \textcolor{stringliteral}{"The list of internal queues."},
103                    \hyperlink{namespacens3_a5de726d8bcea7a51fd68ce5167a66713}{ObjectVectorValue} (),
104                    \hyperlink{namespacens3_a6ad5b3621a5dc72b7030cbb07c73adf6}{MakeObjectVectorAccessor} (&
      \hyperlink{classns3_1_1QueueDisc_ae6507c7002e15afd8944a34f239331d7}{QueueDisc::m\_queues}),
105                    MakeObjectVectorChecker<InternalQueue> ())
106     .AddAttribute (\textcolor{stringliteral}{"PacketFilterList"}, \textcolor{stringliteral}{"The list of packet filters."},
107                    \hyperlink{namespacens3_a5de726d8bcea7a51fd68ce5167a66713}{ObjectVectorValue} (),
108                    \hyperlink{namespacens3_a6ad5b3621a5dc72b7030cbb07c73adf6}{MakeObjectVectorAccessor} (&
      \hyperlink{classns3_1_1QueueDisc_a04bc2a1d90315527c6ba411eb2cb722a}{QueueDisc::m\_filters}),
109                    MakeObjectVectorChecker<PacketFilter> ())
110     .AddAttribute (\textcolor{stringliteral}{"QueueDiscClassList"}, \textcolor{stringliteral}{"The list of queue disc classes."},
111                    \hyperlink{namespacens3_a5de726d8bcea7a51fd68ce5167a66713}{ObjectVectorValue} (),
112                    \hyperlink{namespacens3_a6ad5b3621a5dc72b7030cbb07c73adf6}{MakeObjectVectorAccessor} (&
      \hyperlink{classns3_1_1QueueDisc_a054d624a7a6f10a11cffec1f858feb3c}{QueueDisc::m\_classes}),
113                    MakeObjectVectorChecker<QueueDiscClass> ())
114     .AddTraceSource (\textcolor{stringliteral}{"Enqueue"}, \textcolor{stringliteral}{"Enqueue a packet in the queue disc"},
115                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1QueueDisc_a7614788f662bc6df8c98a646f494dd61}{QueueDisc::m\_traceEnqueue}),
116                      \textcolor{stringliteral}{"ns3::QueueDiscItem::TracedCallback"})
117     .AddTraceSource (\textcolor{stringliteral}{"Dequeue"}, \textcolor{stringliteral}{"Dequeue a packet from the queue disc"},
118                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1QueueDisc_a1be3a308037b0feb28ae284b9be04bfc}{QueueDisc::m\_traceDequeue}),
119                      \textcolor{stringliteral}{"ns3::QueueDiscItem::TracedCallback"})
120     .AddTraceSource (\textcolor{stringliteral}{"Requeue"}, \textcolor{stringliteral}{"Requeue a packet in the queue disc"},
121                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1QueueDisc_a599ba8331f01a8b7ff1d690a8c52dedc}{QueueDisc::m\_traceRequeue}),
122                      \textcolor{stringliteral}{"ns3::QueueDiscItem::TracedCallback"})
123     .AddTraceSource (\textcolor{stringliteral}{"Drop"}, \textcolor{stringliteral}{"Drop a packet stored in the queue disc"},
124                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1QueueDisc_a4d59074e7f6aa601eee90f5cd87d423f}{QueueDisc::m\_traceDrop}),
125                      \textcolor{stringliteral}{"ns3::QueueDiscItem::TracedCallback"})
126     .AddTraceSource (\textcolor{stringliteral}{"PacketsInQueue"},
127                      \textcolor{stringliteral}{"Number of packets currently stored in the queue disc"},
128                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1QueueDisc_a7afc9edf0fdb517d088ebe8d3747fbef}{QueueDisc::m\_nPackets}),
129                      \textcolor{stringliteral}{"ns3::TracedValueCallback::Uint32"})
130     .AddTraceSource (\textcolor{stringliteral}{"BytesInQueue"},
131                      \textcolor{stringliteral}{"Number of bytes currently stored in the queue disc"},
132                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1QueueDisc_a5c9e0e5c858f333bb15089eea58a1e3b}{QueueDisc::m\_nBytes}),
133                      \textcolor{stringliteral}{"ns3::TracedValueCallback::Uint32"})
134   ;
135   \textcolor{keywordflow}{return} tid;
136 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 32


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Get\+Wake\+Mode@{Get\+Wake\+Mode}}
\index{Get\+Wake\+Mode@{Get\+Wake\+Mode}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Get\+Wake\+Mode(void) const }{GetWakeMode(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Queue\+Disc\+::\+Wake\+Mode} ns3\+::\+Queue\+Disc\+::\+Get\+Wake\+Mode (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1QueueDisc_a51a079153b474eec1bad9abe715d9510}{}\label{classns3_1_1QueueDisc_a51a079153b474eec1bad9abe715d9510}
When setting up the wake callbacks on the netdevice queues, it is necessary to determine which queue disc (the root queue disc or one of its children) should be activated when the netdevice wakes one of its transmission queues. The implementation of this method for the base class returns W\+A\+K\+E\+\_\+\+R\+O\+OT, i.\+e., the root queue disc is activated. Subclasses implementing queue discs adopting a different strategy (e.\+g., multi-\/queue aware queue discs such as mq) have to redefine this method.

\begin{DoxyReturn}{Returns}
the wake mode adopted by this queue disc. 
\end{DoxyReturn}

\begin{DoxyCode}
368 \{
369   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1QueueDisc_a0b9b32e71d5becf66e6ac4b3d3de7c8ba56fb0e52526a39cefb47d24550bf47c6}{WAKE\_ROOT};
370 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 33


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Initialize\+Params@{Initialize\+Params}}
\index{Initialize\+Params@{Initialize\+Params}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Initialize\+Params(void)=0}{InitializeParams(void)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Queue\+Disc\+::\+Initialize\+Params (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [pure virtual]}}\hypertarget{classns3_1_1QueueDisc_a600ed3e7110b9d506b28ad62beb84592}{}\label{classns3_1_1QueueDisc_a600ed3e7110b9d506b28ad62beb84592}
Initialize parameters (if any) before the first packet is enqueued. 

Implemented in \hyperlink{classns3_1_1CoDelQueueDisc_a080a75b9680b67884cebc6fb429c0b95}{ns3\+::\+Co\+Del\+Queue\+Disc}, \hyperlink{classns3_1_1RedQueueDisc_adac83b0cbf66f22a6176304b3907995e}{ns3\+::\+Red\+Queue\+Disc}, \hyperlink{classns3_1_1PieQueueDisc_a181280e056b60150b024ab899b71f8f9}{ns3\+::\+Pie\+Queue\+Disc}, \hyperlink{classns3_1_1FqCoDelQueueDisc_ae4463340ee6d6a4c6d9a267ea9e3aa35}{ns3\+::\+Fq\+Co\+Del\+Queue\+Disc}, and \hyperlink{classns3_1_1PfifoFastQueueDisc_abea83fd533e5e527f04a58cd079de204}{ns3\+::\+Pfifo\+Fast\+Queue\+Disc}.



Here is the caller graph for this function\+:
% FIG 34


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Notify\+Parent\+Drop@{Notify\+Parent\+Drop}}
\index{Notify\+Parent\+Drop@{Notify\+Parent\+Drop}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Notify\+Parent\+Drop(\+Ptr$<$ const Queue\+Disc\+Item $>$ item)}{NotifyParentDrop(Ptr< const QueueDiscItem > item)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Queue\+Disc\+::\+Notify\+Parent\+Drop (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Queue\+Disc\+Item} $>$}]{item}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_aee0b845da519a8121dbe5a397ed63b54}{}\label{classns3_1_1QueueDisc_aee0b845da519a8121dbe5a397ed63b54}


Notify the parent queue disc of a packet drop. 


\begin{DoxyParams}{Parameters}
{\em item} & item that was dropped \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
409 \{
410   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << item);
411   \textcolor{comment}{// the parent drop callback is clearly null on root queue discs}
412   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1QueueDisc_ac0ecab7418e3e1e6453f9cf1b194b74f}{m\_parentDropCallback}.\hyperlink{classns3_1_1Callback_aa8e27826badbf37f84763f36f70d9b54}{IsNull} ())
413     \{
414       \hyperlink{classns3_1_1QueueDisc_ac0ecab7418e3e1e6453f9cf1b194b74f}{m\_parentDropCallback} (item);
415     \}
416 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 35




Here is the caller graph for this function\+:
% FIG 36


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!operator=@{operator=}}
\index{operator=@{operator=}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{operator=(const Queue\+Disc \&o)}{operator=(const QueueDisc &o)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Queue\+Disc}\& ns3\+::\+Queue\+Disc\+::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf Queue\+Disc} \&}]{o}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_a9a2023229369d282aa4714124cf772f2}{}\label{classns3_1_1QueueDisc_a9a2023229369d282aa4714124cf772f2}


Assignment operator. 


\begin{DoxyParams}{Parameters}
{\em o} & object to copy \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the copied object
\end{DoxyReturn}
Defined and unimplemented to avoid misuse \index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Peek@{Peek}}
\index{Peek@{Peek}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Peek(void) const }{Peek(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ const {\bf Queue\+Disc\+Item} $>$ ns3\+::\+Queue\+Disc\+::\+Peek (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1QueueDisc_a952cddf7fbe32e180a170a7be21875fa}{}\label{classns3_1_1QueueDisc_a952cddf7fbe32e180a170a7be21875fa}
Get a copy of the next packet the queue discipline will extract, without actually extracting the packet. This function only calls the (private) Do\+Peek function, which must be implemented by derived classes. \begin{DoxyReturn}{Returns}
0 if the operation was not successful; the item otherwise. 
\end{DoxyReturn}

\begin{DoxyCode}
456 \{
457   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
458   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1QueueDisc_aff6a0523b7132a4df6cf202ab49bd788}{DoPeek} ();
459 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 37




Here is the caller graph for this function\+:
% FIG 38


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Requeue@{Requeue}}
\index{Requeue@{Requeue}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Requeue(\+Ptr$<$ Queue\+Disc\+Item $>$ item)}{Requeue(Ptr< QueueDiscItem > item)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Queue\+Disc\+::\+Requeue (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Queue\+Disc\+Item} $>$}]{item}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_a45cd8fdd2469b9e9d7551af22cfdb1a2}{}\label{classns3_1_1QueueDisc_a45cd8fdd2469b9e9d7551af22cfdb1a2}
Modelled after the Linux function dev\+\_\+requeue\+\_\+skb (net/sched/sch\+\_\+generic.\+c) Requeues a packet whose transmission failed. 
\begin{DoxyParams}{Parameters}
{\em item} & the packet to requeue \\
\hline
\end{DoxyParams}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000161}{Todo}]netif\+\_\+schedule (q); \end{DoxyRefDesc}

\begin{DoxyCode}
564 \{
565   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << item);
566   \hyperlink{classns3_1_1QueueDisc_a43cae3d282e28914b1b5e1b782c7e854}{m\_requeued} = item;
568 
569   \hyperlink{classns3_1_1QueueDisc_a7afc9edf0fdb517d088ebe8d3747fbef}{m\_nPackets}++;       \textcolor{comment}{// it's still part of the queue}
570   \hyperlink{classns3_1_1QueueDisc_a5c9e0e5c858f333bb15089eea58a1e3b}{m\_nBytes} += item->GetSize ();
571   \hyperlink{classns3_1_1QueueDisc_a098d0d792113e93b94c8f89178ac2af6}{m\_nTotalRequeuedPackets}++;
572   \hyperlink{classns3_1_1QueueDisc_aa1c2f1af9a66078a2507d2632eef82ae}{m\_nTotalRequeuedBytes} += item->GetSize ();
573 
574   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"m\_traceRequeue (p)"});
575   \hyperlink{classns3_1_1QueueDisc_a599ba8331f01a8b7ff1d690a8c52dedc}{m\_traceRequeue} (item);
576 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 39


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Restart@{Restart}}
\index{Restart@{Restart}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Restart(void)}{Restart(void)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Queue\+Disc\+::\+Restart (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_a009f73a521cc0ebf309d8d15f8b190ea}{}\label{classns3_1_1QueueDisc_a009f73a521cc0ebf309d8d15f8b190ea}
Modelled after the Linux function qdisc\+\_\+restart (net/sched/sch\+\_\+generic.\+c) Dequeue a packet (by calling Dequeue\+Packet) and send it to the device (by calling Transmit). \begin{DoxyReturn}{Returns}
true if a packet is successfully sent to the device. 
\end{DoxyReturn}

\begin{DoxyCode}
504 \{
505   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
506   Ptr<QueueDiscItem> item = \hyperlink{classns3_1_1QueueDisc_aab4beacb808b917dde38fe835c199f28}{DequeuePacket}();
507   \textcolor{keywordflow}{if} (item == 0)
508     \{
509       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"No packet to send"});
510       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
511     \}
512 
513   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1QueueDisc_a294d52aeecb986d4f2b3bcb4514c013e}{Transmit} (item);
514 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 40




Here is the caller graph for this function\+:
% FIG 41


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Run@{Run}}
\index{Run@{Run}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Run(void)}{Run(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Queue\+Disc\+::\+Run (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1QueueDisc_a424eceba41cb013436f353c622c082ff}{}\label{classns3_1_1QueueDisc_a424eceba41cb013436f353c622c082ff}
Modelled after the Linux function \+\_\+\+\_\+qdisc\+\_\+run (net/sched/sch\+\_\+generic.\+c) Dequeues multiple packets, until a quota is exceeded or sending a packet to the device failed. \begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000160}{Todo}]netif\+\_\+schedule (q); \end{DoxyRefDesc}

\begin{DoxyCode}
463 \{
464   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
465 
466   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1QueueDisc_a9fc8e2a52e7600d3d93141241f7bd7cd}{RunBegin} ())
467     \{
468       uint32\_t quota = \hyperlink{classns3_1_1QueueDisc_a4f7e8c8503be408b6bbf82e0648c9fc8}{m\_quota};
469       \textcolor{keywordflow}{while} (\hyperlink{classns3_1_1QueueDisc_a009f73a521cc0ebf309d8d15f8b190ea}{Restart} ())
470         \{
471           quota -= 1;
472           \textcolor{keywordflow}{if} (quota <= 0)
473             \{
475               \textcolor{keywordflow}{break};
476             \}
477         \}
478       \hyperlink{classns3_1_1QueueDisc_a1022461238c22b5ce07bc0fd2527e2f3}{RunEnd} ();
479     \}
480 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 42




Here is the caller graph for this function\+:
% FIG 43


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Run\+Begin@{Run\+Begin}}
\index{Run\+Begin@{Run\+Begin}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Run\+Begin(void)}{RunBegin(void)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Queue\+Disc\+::\+Run\+Begin (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_a9fc8e2a52e7600d3d93141241f7bd7cd}{}\label{classns3_1_1QueueDisc_a9fc8e2a52e7600d3d93141241f7bd7cd}
Modelled after the Linux function qdisc\+\_\+run\+\_\+begin (include/net/sch\+\_\+generic.\+h). \begin{DoxyReturn}{Returns}
false if the qdisc is already running; otherwise, set the qdisc as running and return true. 
\end{DoxyReturn}

\begin{DoxyCode}
484 \{
485   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
486   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1QueueDisc_a6d00230b60de29bd32d0a2488290380f}{m\_running})
487     \{
488       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
489     \}
490 
491   \hyperlink{classns3_1_1QueueDisc_a6d00230b60de29bd32d0a2488290380f}{m\_running} = \textcolor{keyword}{true};
492   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
493 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 44


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Run\+End@{Run\+End}}
\index{Run\+End@{Run\+End}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Run\+End(void)}{RunEnd(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Queue\+Disc\+::\+Run\+End (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_a1022461238c22b5ce07bc0fd2527e2f3}{}\label{classns3_1_1QueueDisc_a1022461238c22b5ce07bc0fd2527e2f3}
Modelled after the Linux function qdisc\+\_\+run\+\_\+end (include/net/sch\+\_\+generic.\+h). Set the qdisc as not running. 
\begin{DoxyCode}
497 \{
498   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
499   \hyperlink{classns3_1_1QueueDisc_a6d00230b60de29bd32d0a2488290380f}{m\_running} = \textcolor{keyword}{false};
500 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 45


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Set\+Net\+Device@{Set\+Net\+Device}}
\index{Set\+Net\+Device@{Set\+Net\+Device}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Set\+Net\+Device(\+Ptr$<$ Net\+Device $>$ device)}{SetNetDevice(Ptr< NetDevice > device)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Queue\+Disc\+::\+Set\+Net\+Device (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{device}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1QueueDisc_af7dc06af070d01ff4cf515ab2a844ef3}{}\label{classns3_1_1QueueDisc_af7dc06af070d01ff4cf515ab2a844ef3}


Set the \hyperlink{classns3_1_1NetDevice}{Net\+Device} on which this queue discipline is installed. 


\begin{DoxyParams}{Parameters}
{\em device} & the \hyperlink{classns3_1_1NetDevice}{Net\+Device} on which this queue discipline is installed. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
255 \{
256   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << device);
257   \hyperlink{classns3_1_1QueueDisc_ad9a47fe0eb33b8e1ef760966b1ad6b7c}{m\_device} = device;
258 \}
\end{DoxyCode}
\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Set\+Parent\+Drop\+Callback@{Set\+Parent\+Drop\+Callback}}
\index{Set\+Parent\+Drop\+Callback@{Set\+Parent\+Drop\+Callback}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Set\+Parent\+Drop\+Callback(\+Parent\+Drop\+Callback cb)}{SetParentDropCallback(ParentDropCallback cb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Queue\+Disc\+::\+Set\+Parent\+Drop\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Parent\+Drop\+Callback}}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1QueueDisc_ac0a9b81f70b0ef63d3bd31718691e6e9}{}\label{classns3_1_1QueueDisc_ac0a9b81f70b0ef63d3bd31718691e6e9}


Set the parent drop callback. 


\begin{DoxyParams}{Parameters}
{\em cb} & the callback to set\\
\hline
\end{DoxyParams}
Called when a queue disc class is added to a queue disc in order to set a callback to the Drop method of the parent queue disc. 
\begin{DoxyCode}
374 \{
375   \hyperlink{classns3_1_1QueueDisc_ac0ecab7418e3e1e6453f9cf1b194b74f}{m\_parentDropCallback} = cb;
376 \}
\end{DoxyCode}
\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Set\+Quota@{Set\+Quota}}
\index{Set\+Quota@{Set\+Quota}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Set\+Quota(const uint32\+\_\+t quota)}{SetQuota(const uint32_t quota)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Queue\+Disc\+::\+Set\+Quota (
\begin{DoxyParamCaption}
\item[{const uint32\+\_\+t}]{quota}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1QueueDisc_ab35519e5f10b3226c4b2a07e009bcc20}{}\label{classns3_1_1QueueDisc_ab35519e5f10b3226c4b2a07e009bcc20}


Set the maximum number of dequeue operations following a packet enqueue. 


\begin{DoxyParams}{Parameters}
{\em quota} & the maximum number of dequeue operations following a packet enqueue. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
269 \{
270   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << quota);
271   \hyperlink{classns3_1_1QueueDisc_a4f7e8c8503be408b6bbf82e0648c9fc8}{m\_quota} = quota;
272 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 46


\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!Transmit@{Transmit}}
\index{Transmit@{Transmit}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{Transmit(\+Ptr$<$ Queue\+Disc\+Item $>$ item)}{Transmit(Ptr< QueueDiscItem > item)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Queue\+Disc\+::\+Transmit (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Queue\+Disc\+Item} $>$}]{item}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_a294d52aeecb986d4f2b3bcb4514c013e}{}\label{classns3_1_1QueueDisc_a294d52aeecb986d4f2b3bcb4514c013e}
Modelled after the Linux function sch\+\_\+direct\+\_\+xmit (net/sched/sch\+\_\+generic.\+c) Sends a packet to the device if the device queue is not stopped, and requeues it otherwise. 
\begin{DoxyParams}{Parameters}
{\em item} & the packet to transmit \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the device queue is not stopped and the queue disc is not empty 
\end{DoxyReturn}

\begin{DoxyCode}
580 \{
581   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << item);
582   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1QueueDisc_a265febf26e8325dbb3ba1f905ea1912d}{m\_devQueueIface});
583 
584   \textcolor{comment}{// if the device queue is stopped, requeue the packet and return false.}
585   \textcolor{comment}{// Note that if the underlying device is tc-unaware, packets are never}
586   \textcolor{comment}{// requeued because the queues of tc-unaware devices are never stopped}
587   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1QueueDisc_a265febf26e8325dbb3ba1f905ea1912d}{m\_devQueueIface}->GetTxQueue (item->GetTxQueueIndex ())->IsStopped ())
588     \{
589       \hyperlink{classns3_1_1QueueDisc_a45cd8fdd2469b9e9d7551af22cfdb1a2}{Requeue} (item);
590       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
591     \}
592 
593   \textcolor{comment}{// a single queue device makes no use of the priority tag}
594   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1QueueDisc_a265febf26e8325dbb3ba1f905ea1912d}{m\_devQueueIface}->GetNTxQueues () == 1)
595     \{
596       SocketPriorityTag priorityTag;
597       item->GetPacket ()->RemovePacketTag (priorityTag);
598     \}
599   \hyperlink{classns3_1_1QueueDisc_ad9a47fe0eb33b8e1ef760966b1ad6b7c}{m\_device}->Send (item->GetPacket (), item->GetAddress (), item->GetProtocol ());
600 
601   \textcolor{comment}{// the behavior here slightly diverges from Linux. In Linux, it is advised that}
602   \textcolor{comment}{// the function called when a packet needs to be transmitted (ndo\_start\_xmit)}
603   \textcolor{comment}{// should always return NETDEV\_TX\_OK, which means that the packet is consumed by}
604   \textcolor{comment}{// the device driver and thus is not requeued. However, the ndo\_start\_xmit function}
605   \textcolor{comment}{// of the device driver is allowed to return NETDEV\_TX\_BUSY (and hence the packet}
606   \textcolor{comment}{// is requeued) when there is no room for the received packet in the device queue,}
607   \textcolor{comment}{// despite the queue is not stopped. This case is considered as a corner case or}
608   \textcolor{comment}{// an hard error, and should be avoided.}
609   \textcolor{comment}{// Here, we do not handle such corner case and always assume that the packet is}
610   \textcolor{comment}{// consumed by the netdevice. Thus, we ignore the value returned by Send and a}
611   \textcolor{comment}{// packet sent to a netdevice is never requeued. The reason is that the semantics}
612   \textcolor{comment}{// of the value returned by NetDevice::Send does not match that of the value}
613   \textcolor{comment}{// returned by ndo\_start\_xmit.}
614 
615   \textcolor{comment}{// if the queue disc is empty or the device queue is now stopped, return false so}
616   \textcolor{comment}{// that the Run method does not attempt to dequeue other packets and exits}
617   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1QueueDisc_a6ee992f32c1671512f0948fd6cc46a7e}{GetNPackets} () == 0 || \hyperlink{classns3_1_1QueueDisc_a265febf26e8325dbb3ba1f905ea1912d}{m\_devQueueIface}->GetTxQueue (item->GetTxQueueIndex (
      ))->IsStopped ())
618     \{
619       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
620     \}
621 
622   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
623 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 47




Here is the caller graph for this function\+:
% FIG 48




\subsection{Member Data Documentation}
\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!D\+E\+F\+A\+U\+L\+T\+\_\+\+Q\+U\+O\+TA@{D\+E\+F\+A\+U\+L\+T\+\_\+\+Q\+U\+O\+TA}}
\index{D\+E\+F\+A\+U\+L\+T\+\_\+\+Q\+U\+O\+TA@{D\+E\+F\+A\+U\+L\+T\+\_\+\+Q\+U\+O\+TA}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{D\+E\+F\+A\+U\+L\+T\+\_\+\+Q\+U\+O\+TA}{DEFAULT_QUOTA}}]{\setlength{\rightskip}{0pt plus 5cm}const uint32\+\_\+t ns3\+::\+Queue\+Disc\+::\+D\+E\+F\+A\+U\+L\+T\+\_\+\+Q\+U\+O\+TA = 64\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_a057a2c6dd982ffb206ce2a42eb4f46fa}{}\label{classns3_1_1QueueDisc_a057a2c6dd982ffb206ce2a42eb4f46fa}


Default quota (as in /proc/sys/net/core/dev\+\_\+weight) 

\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!m\+\_\+classes@{m\+\_\+classes}}
\index{m\+\_\+classes@{m\+\_\+classes}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{m\+\_\+classes}{m_classes}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<${\bf Ptr}$<${\bf Queue\+Disc\+Class}$>$ $>$ ns3\+::\+Queue\+Disc\+::m\+\_\+classes\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_a054d624a7a6f10a11cffec1f858feb3c}{}\label{classns3_1_1QueueDisc_a054d624a7a6f10a11cffec1f858feb3c}


Classes. 

\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!m\+\_\+device@{m\+\_\+device}}
\index{m\+\_\+device@{m\+\_\+device}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{m\+\_\+device}{m_device}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Net\+Device}$>$ ns3\+::\+Queue\+Disc\+::m\+\_\+device\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_ad9a47fe0eb33b8e1ef760966b1ad6b7c}{}\label{classns3_1_1QueueDisc_ad9a47fe0eb33b8e1ef760966b1ad6b7c}


The \hyperlink{classns3_1_1NetDevice}{Net\+Device} on which this queue discipline is installed. 

\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!m\+\_\+dev\+Queue\+Iface@{m\+\_\+dev\+Queue\+Iface}}
\index{m\+\_\+dev\+Queue\+Iface@{m\+\_\+dev\+Queue\+Iface}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{m\+\_\+dev\+Queue\+Iface}{m_devQueueIface}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Net\+Device\+Queue\+Interface}$>$ ns3\+::\+Queue\+Disc\+::m\+\_\+dev\+Queue\+Iface\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_a265febf26e8325dbb3ba1f905ea1912d}{}\label{classns3_1_1QueueDisc_a265febf26e8325dbb3ba1f905ea1912d}


\hyperlink{classns3_1_1NetDevice}{Net\+Device} queue interface. 

\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!m\+\_\+filters@{m\+\_\+filters}}
\index{m\+\_\+filters@{m\+\_\+filters}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{m\+\_\+filters}{m_filters}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<${\bf Ptr}$<${\bf Packet\+Filter}$>$ $>$ ns3\+::\+Queue\+Disc\+::m\+\_\+filters\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_a04bc2a1d90315527c6ba411eb2cb722a}{}\label{classns3_1_1QueueDisc_a04bc2a1d90315527c6ba411eb2cb722a}


\hyperlink{classns3_1_1Packet}{Packet} filters. 

\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!m\+\_\+n\+Bytes@{m\+\_\+n\+Bytes}}
\index{m\+\_\+n\+Bytes@{m\+\_\+n\+Bytes}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{m\+\_\+n\+Bytes}{m_nBytes}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Value}$<$uint32\+\_\+t$>$ ns3\+::\+Queue\+Disc\+::m\+\_\+n\+Bytes\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_a5c9e0e5c858f333bb15089eea58a1e3b}{}\label{classns3_1_1QueueDisc_a5c9e0e5c858f333bb15089eea58a1e3b}


Number of bytes in the queue. 

\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!m\+\_\+n\+Packets@{m\+\_\+n\+Packets}}
\index{m\+\_\+n\+Packets@{m\+\_\+n\+Packets}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{m\+\_\+n\+Packets}{m_nPackets}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Value}$<$uint32\+\_\+t$>$ ns3\+::\+Queue\+Disc\+::m\+\_\+n\+Packets\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_a7afc9edf0fdb517d088ebe8d3747fbef}{}\label{classns3_1_1QueueDisc_a7afc9edf0fdb517d088ebe8d3747fbef}


Number of packets in the queue. 

\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!m\+\_\+n\+Total\+Dropped\+Bytes@{m\+\_\+n\+Total\+Dropped\+Bytes}}
\index{m\+\_\+n\+Total\+Dropped\+Bytes@{m\+\_\+n\+Total\+Dropped\+Bytes}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{m\+\_\+n\+Total\+Dropped\+Bytes}{m_nTotalDroppedBytes}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Queue\+Disc\+::m\+\_\+n\+Total\+Dropped\+Bytes\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_a06645b0916c11b3da27195ed99ca8ce7}{}\label{classns3_1_1QueueDisc_a06645b0916c11b3da27195ed99ca8ce7}


Total dropped bytes. 

\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!m\+\_\+n\+Total\+Dropped\+Packets@{m\+\_\+n\+Total\+Dropped\+Packets}}
\index{m\+\_\+n\+Total\+Dropped\+Packets@{m\+\_\+n\+Total\+Dropped\+Packets}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{m\+\_\+n\+Total\+Dropped\+Packets}{m_nTotalDroppedPackets}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Queue\+Disc\+::m\+\_\+n\+Total\+Dropped\+Packets\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_a2974596141f300298255f0ae85faf0cc}{}\label{classns3_1_1QueueDisc_a2974596141f300298255f0ae85faf0cc}


Total dropped packets. 

\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!m\+\_\+n\+Total\+Received\+Bytes@{m\+\_\+n\+Total\+Received\+Bytes}}
\index{m\+\_\+n\+Total\+Received\+Bytes@{m\+\_\+n\+Total\+Received\+Bytes}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{m\+\_\+n\+Total\+Received\+Bytes}{m_nTotalReceivedBytes}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Queue\+Disc\+::m\+\_\+n\+Total\+Received\+Bytes\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_a8ebcd87d1d417d30e1e916a406c681c0}{}\label{classns3_1_1QueueDisc_a8ebcd87d1d417d30e1e916a406c681c0}


Total received bytes. 

\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!m\+\_\+n\+Total\+Received\+Packets@{m\+\_\+n\+Total\+Received\+Packets}}
\index{m\+\_\+n\+Total\+Received\+Packets@{m\+\_\+n\+Total\+Received\+Packets}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{m\+\_\+n\+Total\+Received\+Packets}{m_nTotalReceivedPackets}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Queue\+Disc\+::m\+\_\+n\+Total\+Received\+Packets\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_afc5d0c189f8d08582a84fce36fea8745}{}\label{classns3_1_1QueueDisc_afc5d0c189f8d08582a84fce36fea8745}


Total received packets. 

\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!m\+\_\+n\+Total\+Requeued\+Bytes@{m\+\_\+n\+Total\+Requeued\+Bytes}}
\index{m\+\_\+n\+Total\+Requeued\+Bytes@{m\+\_\+n\+Total\+Requeued\+Bytes}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{m\+\_\+n\+Total\+Requeued\+Bytes}{m_nTotalRequeuedBytes}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Queue\+Disc\+::m\+\_\+n\+Total\+Requeued\+Bytes\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_aa1c2f1af9a66078a2507d2632eef82ae}{}\label{classns3_1_1QueueDisc_aa1c2f1af9a66078a2507d2632eef82ae}


Total requeued bytes. 

\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!m\+\_\+n\+Total\+Requeued\+Packets@{m\+\_\+n\+Total\+Requeued\+Packets}}
\index{m\+\_\+n\+Total\+Requeued\+Packets@{m\+\_\+n\+Total\+Requeued\+Packets}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{m\+\_\+n\+Total\+Requeued\+Packets}{m_nTotalRequeuedPackets}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Queue\+Disc\+::m\+\_\+n\+Total\+Requeued\+Packets\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_a098d0d792113e93b94c8f89178ac2af6}{}\label{classns3_1_1QueueDisc_a098d0d792113e93b94c8f89178ac2af6}


Total requeued packets. 

\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!m\+\_\+parent\+Drop\+Callback@{m\+\_\+parent\+Drop\+Callback}}
\index{m\+\_\+parent\+Drop\+Callback@{m\+\_\+parent\+Drop\+Callback}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{m\+\_\+parent\+Drop\+Callback}{m_parentDropCallback}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Parent\+Drop\+Callback} ns3\+::\+Queue\+Disc\+::m\+\_\+parent\+Drop\+Callback\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_ac0ecab7418e3e1e6453f9cf1b194b74f}{}\label{classns3_1_1QueueDisc_ac0ecab7418e3e1e6453f9cf1b194b74f}


Parent drop callback. 

\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!m\+\_\+queues@{m\+\_\+queues}}
\index{m\+\_\+queues@{m\+\_\+queues}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{m\+\_\+queues}{m_queues}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<${\bf Ptr}$<${\bf Internal\+Queue}$>$ $>$ ns3\+::\+Queue\+Disc\+::m\+\_\+queues\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_ae6507c7002e15afd8944a34f239331d7}{}\label{classns3_1_1QueueDisc_ae6507c7002e15afd8944a34f239331d7}


Internal queues. 

\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!m\+\_\+quota@{m\+\_\+quota}}
\index{m\+\_\+quota@{m\+\_\+quota}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{m\+\_\+quota}{m_quota}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Queue\+Disc\+::m\+\_\+quota\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_a4f7e8c8503be408b6bbf82e0648c9fc8}{}\label{classns3_1_1QueueDisc_a4f7e8c8503be408b6bbf82e0648c9fc8}


Maximum number of packets dequeued in a qdisc run. 

\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!m\+\_\+requeued@{m\+\_\+requeued}}
\index{m\+\_\+requeued@{m\+\_\+requeued}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{m\+\_\+requeued}{m_requeued}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Queue\+Disc\+Item}$>$ ns3\+::\+Queue\+Disc\+::m\+\_\+requeued\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_a43cae3d282e28914b1b5e1b782c7e854}{}\label{classns3_1_1QueueDisc_a43cae3d282e28914b1b5e1b782c7e854}


The last packet that failed to be transmitted. 

\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!m\+\_\+running@{m\+\_\+running}}
\index{m\+\_\+running@{m\+\_\+running}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{m\+\_\+running}{m_running}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Queue\+Disc\+::m\+\_\+running\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_a6d00230b60de29bd32d0a2488290380f}{}\label{classns3_1_1QueueDisc_a6d00230b60de29bd32d0a2488290380f}


The queue disc is performing multiple dequeue operations. 

\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!m\+\_\+trace\+Dequeue@{m\+\_\+trace\+Dequeue}}
\index{m\+\_\+trace\+Dequeue@{m\+\_\+trace\+Dequeue}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{m\+\_\+trace\+Dequeue}{m_traceDequeue}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Queue\+Disc\+Item}$>$ $>$ ns3\+::\+Queue\+Disc\+::m\+\_\+trace\+Dequeue\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_a1be3a308037b0feb28ae284b9be04bfc}{}\label{classns3_1_1QueueDisc_a1be3a308037b0feb28ae284b9be04bfc}


Traced callback\+: fired when a packet is dequeued. 

\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!m\+\_\+trace\+Drop@{m\+\_\+trace\+Drop}}
\index{m\+\_\+trace\+Drop@{m\+\_\+trace\+Drop}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{m\+\_\+trace\+Drop}{m_traceDrop}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Queue\+Disc\+Item}$>$ $>$ ns3\+::\+Queue\+Disc\+::m\+\_\+trace\+Drop\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_a4d59074e7f6aa601eee90f5cd87d423f}{}\label{classns3_1_1QueueDisc_a4d59074e7f6aa601eee90f5cd87d423f}


Traced callback\+: fired when a packet is dropped. 

\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!m\+\_\+trace\+Enqueue@{m\+\_\+trace\+Enqueue}}
\index{m\+\_\+trace\+Enqueue@{m\+\_\+trace\+Enqueue}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{m\+\_\+trace\+Enqueue}{m_traceEnqueue}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Queue\+Disc\+Item}$>$ $>$ ns3\+::\+Queue\+Disc\+::m\+\_\+trace\+Enqueue\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_a7614788f662bc6df8c98a646f494dd61}{}\label{classns3_1_1QueueDisc_a7614788f662bc6df8c98a646f494dd61}


Traced callback\+: fired when a packet is enqueued. 

\index{ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}!m\+\_\+trace\+Requeue@{m\+\_\+trace\+Requeue}}
\index{m\+\_\+trace\+Requeue@{m\+\_\+trace\+Requeue}!ns3\+::\+Queue\+Disc@{ns3\+::\+Queue\+Disc}}
\subsubsection[{\texorpdfstring{m\+\_\+trace\+Requeue}{m_traceRequeue}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Queue\+Disc\+Item}$>$ $>$ ns3\+::\+Queue\+Disc\+::m\+\_\+trace\+Requeue\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDisc_a599ba8331f01a8b7ff1d690a8c52dedc}{}\label{classns3_1_1QueueDisc_a599ba8331f01a8b7ff1d690a8c52dedc}


Traced callback\+: fired when a packet is requeued. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
traffic-\/control/model/\hyperlink{queue-disc_8h}{queue-\/disc.\+h}\item 
traffic-\/control/model/\hyperlink{queue-disc_8cc}{queue-\/disc.\+cc}\end{DoxyCompactItemize}
