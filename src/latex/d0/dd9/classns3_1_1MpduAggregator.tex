\hypertarget{classns3_1_1MpduAggregator}{}\section{ns3\+:\+:Mpdu\+Aggregator Class Reference}
\label{classns3_1_1MpduAggregator}\index{ns3\+::\+Mpdu\+Aggregator@{ns3\+::\+Mpdu\+Aggregator}}


Abstract class that concrete mpdu aggregators have to implement.  




{\ttfamily \#include $<$mpdu-\/aggregator.\+h$>$}



Inheritance diagram for ns3\+:\+:Mpdu\+Aggregator\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Mpdu\+Aggregator\+:
% FIG 1
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ std\+::pair$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$, \hyperlink{classns3_1_1AmpduSubframeHeader}{Ampdu\+Subframe\+Header} $>$ $>$ \hyperlink{classns3_1_1MpduAggregator_a09f3b03cb988045c381fad4ba4dce371}{Deaggregated\+Mpdus}
\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ std\+::pair$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$, \hyperlink{classns3_1_1AmpduSubframeHeader}{Ampdu\+Subframe\+Header} $>$ $>$\+::const\+\_\+iterator \hyperlink{classns3_1_1MpduAggregator_a14d8750e18f3104d3c87930f3bcb10a3}{Deaggregated\+Mpdus\+CI}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1MpduAggregator_a00344d9ef60b8ad4368769b31761f55d}{Set\+Max\+Ampdu\+Size} (uint32\+\_\+t max\+Size)=0
\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1MpduAggregator_a781ed153a388bbc8a5ac231cfd9218c8}{Get\+Max\+Ampdu\+Size} (void) const =0
\item 
virtual bool \hyperlink{classns3_1_1MpduAggregator_a8452ad0dca5d5a0fef52991c4f4cf610}{Aggregate} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ aggregated\+Packet) const =0
\item 
virtual void \hyperlink{classns3_1_1MpduAggregator_a41a0e95112386fd7b7e33c1c12dc6bb0}{Aggregate\+Single\+Mpdu} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ aggregated\+Packet) const =0
\item 
virtual void \hyperlink{classns3_1_1MpduAggregator_afdac5a63ad17349e7454d5947938f923}{Add\+Header\+And\+Pad} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, bool last, bool is\+Single\+Mpdu) const =0
\item 
virtual bool \hyperlink{classns3_1_1MpduAggregator_a3b9a3eb957da16bb9e01e619b23df10a}{Can\+Be\+Aggregated} (uint32\+\_\+t packet\+Size, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ aggregated\+Packet, uint8\+\_\+t block\+Ack\+Size) const =0
\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1MpduAggregator_aef376d087d3039318f6ae8fa01181879}{Calculate\+Padding} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet) const =0
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1MpduAggregator_a5b9097a5ff858ae68a735446c2b3544e}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\item 
static \hyperlink{classns3_1_1MpduAggregator_a09f3b03cb988045c381fad4ba4dce371}{Deaggregated\+Mpdus} \hyperlink{classns3_1_1MpduAggregator_a4c5daf1c185ea5e4b82ea028327ba202}{Deaggregate} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ aggregated\+Packet)
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Abstract class that concrete mpdu aggregators have to implement. 

\subsection{Member Typedef Documentation}
\index{ns3\+::\+Mpdu\+Aggregator@{ns3\+::\+Mpdu\+Aggregator}!Deaggregated\+Mpdus@{Deaggregated\+Mpdus}}
\index{Deaggregated\+Mpdus@{Deaggregated\+Mpdus}!ns3\+::\+Mpdu\+Aggregator@{ns3\+::\+Mpdu\+Aggregator}}
\subsubsection[{\texorpdfstring{Deaggregated\+Mpdus}{DeaggregatedMpdus}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<$std\+::pair$<${\bf Ptr}$<${\bf Packet}$>$, {\bf Ampdu\+Subframe\+Header}$>$ $>$ {\bf ns3\+::\+Mpdu\+Aggregator\+::\+Deaggregated\+Mpdus}}\hypertarget{classns3_1_1MpduAggregator_a09f3b03cb988045c381fad4ba4dce371}{}\label{classns3_1_1MpduAggregator_a09f3b03cb988045c381fad4ba4dce371}
A list of deaggregated packets and their A-\/\+M\+P\+DU subframe headers. \index{ns3\+::\+Mpdu\+Aggregator@{ns3\+::\+Mpdu\+Aggregator}!Deaggregated\+Mpdus\+CI@{Deaggregated\+Mpdus\+CI}}
\index{Deaggregated\+Mpdus\+CI@{Deaggregated\+Mpdus\+CI}!ns3\+::\+Mpdu\+Aggregator@{ns3\+::\+Mpdu\+Aggregator}}
\subsubsection[{\texorpdfstring{Deaggregated\+Mpdus\+CI}{DeaggregatedMpdusCI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<$std\+::pair$<${\bf Ptr}$<${\bf Packet}$>$, {\bf Ampdu\+Subframe\+Header}$>$ $>$\+::const\+\_\+iterator {\bf ns3\+::\+Mpdu\+Aggregator\+::\+Deaggregated\+Mpdus\+CI}}\hypertarget{classns3_1_1MpduAggregator_a14d8750e18f3104d3c87930f3bcb10a3}{}\label{classns3_1_1MpduAggregator_a14d8750e18f3104d3c87930f3bcb10a3}
A constant iterator for a list of deaggregated packets and their A-\/\+M\+P\+DU subframe headers. 

\subsection{Member Function Documentation}
\index{ns3\+::\+Mpdu\+Aggregator@{ns3\+::\+Mpdu\+Aggregator}!Add\+Header\+And\+Pad@{Add\+Header\+And\+Pad}}
\index{Add\+Header\+And\+Pad@{Add\+Header\+And\+Pad}!ns3\+::\+Mpdu\+Aggregator@{ns3\+::\+Mpdu\+Aggregator}}
\subsubsection[{\texorpdfstring{Add\+Header\+And\+Pad(\+Ptr$<$ Packet $>$ packet, bool last, bool is\+Single\+Mpdu) const =0}{AddHeaderAndPad(Ptr< Packet > packet, bool last, bool isSingleMpdu) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Mpdu\+Aggregator\+::\+Add\+Header\+And\+Pad (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{bool}]{last, }
\item[{bool}]{is\+Single\+Mpdu}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1MpduAggregator_afdac5a63ad17349e7454d5947938f923}{}\label{classns3_1_1MpduAggregator_afdac5a63ad17349e7454d5947938f923}
Adds A-\/\+M\+P\+DU subframe header and padding to each M\+P\+DU that is part of an A-\/\+M\+P\+DU before it is sent. 

Implemented in \hyperlink{classns3_1_1MpduStandardAggregator_a20f9b233d444b85d4ed22b622dbc3bcd}{ns3\+::\+Mpdu\+Standard\+Aggregator}.

\index{ns3\+::\+Mpdu\+Aggregator@{ns3\+::\+Mpdu\+Aggregator}!Aggregate@{Aggregate}}
\index{Aggregate@{Aggregate}!ns3\+::\+Mpdu\+Aggregator@{ns3\+::\+Mpdu\+Aggregator}}
\subsubsection[{\texorpdfstring{Aggregate(\+Ptr$<$ const Packet $>$ packet, Ptr$<$ Packet $>$ aggregated\+Packet) const =0}{Aggregate(Ptr< const Packet > packet, Ptr< Packet > aggregatedPacket) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool ns3\+::\+Mpdu\+Aggregator\+::\+Aggregate (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{packet, }
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{aggregated\+Packet}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1MpduAggregator_a8452ad0dca5d5a0fef52991c4f4cf610}{}\label{classns3_1_1MpduAggregator_a8452ad0dca5d5a0fef52991c4f4cf610}

\begin{DoxyParams}{Parameters}
{\em packet} & \hyperlink{classns3_1_1Packet}{Packet} we have to insert into {\itshape aggregated\+Packet}. \\
\hline
{\em aggregated\+Packet} & \hyperlink{classns3_1_1Packet}{Packet} that will contain {\itshape packet}, if aggregation is possible.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if {\itshape packet} can be aggregated to {\itshape aggregated\+Packet}, false otherwise.
\end{DoxyReturn}
Adds {\itshape packet} to {\itshape aggregated\+Packet}. In concrete aggregator\textquotesingle{}s implementation is specified how and if {\itshape packet} can be added to {\itshape aggregated\+Packet}. 

Implemented in \hyperlink{classns3_1_1MpduStandardAggregator_ae8df5366479ace23f603e772a32721dc}{ns3\+::\+Mpdu\+Standard\+Aggregator}.

\index{ns3\+::\+Mpdu\+Aggregator@{ns3\+::\+Mpdu\+Aggregator}!Aggregate\+Single\+Mpdu@{Aggregate\+Single\+Mpdu}}
\index{Aggregate\+Single\+Mpdu@{Aggregate\+Single\+Mpdu}!ns3\+::\+Mpdu\+Aggregator@{ns3\+::\+Mpdu\+Aggregator}}
\subsubsection[{\texorpdfstring{Aggregate\+Single\+Mpdu(\+Ptr$<$ const Packet $>$ packet, Ptr$<$ Packet $>$ aggregated\+Packet) const =0}{AggregateSingleMpdu(Ptr< const Packet > packet, Ptr< Packet > aggregatedPacket) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Mpdu\+Aggregator\+::\+Aggregate\+Single\+Mpdu (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{packet, }
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{aggregated\+Packet}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1MpduAggregator_a41a0e95112386fd7b7e33c1c12dc6bb0}{}\label{classns3_1_1MpduAggregator_a41a0e95112386fd7b7e33c1c12dc6bb0}
This method performs a V\+H\+T/\+HE single M\+P\+DU aggregation. 

Implemented in \hyperlink{classns3_1_1MpduStandardAggregator_a8ae46f2c643b8b39b31c28875db10372}{ns3\+::\+Mpdu\+Standard\+Aggregator}.

\index{ns3\+::\+Mpdu\+Aggregator@{ns3\+::\+Mpdu\+Aggregator}!Calculate\+Padding@{Calculate\+Padding}}
\index{Calculate\+Padding@{Calculate\+Padding}!ns3\+::\+Mpdu\+Aggregator@{ns3\+::\+Mpdu\+Aggregator}}
\subsubsection[{\texorpdfstring{Calculate\+Padding(\+Ptr$<$ const Packet $>$ packet) const =0}{CalculatePadding(Ptr< const Packet > packet) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual uint32\+\_\+t ns3\+::\+Mpdu\+Aggregator\+::\+Calculate\+Padding (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{packet}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1MpduAggregator_aef376d087d3039318f6ae8fa01181879}{}\label{classns3_1_1MpduAggregator_aef376d087d3039318f6ae8fa01181879}

\begin{DoxyParams}{Parameters}
{\em packet} & the \hyperlink{classns3_1_1Packet}{Packet} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
padding that must be added to the end of an aggregated packet
\end{DoxyReturn}
Calculates how much padding must be added to the end of an aggregated packet, after that a new packet is added. Each A-\/\+M\+P\+DU subframe is padded so that its length is multiple of 4 octets. 

Implemented in \hyperlink{classns3_1_1MpduStandardAggregator_af00b3fee23a51d256dc0c2df6f488a93}{ns3\+::\+Mpdu\+Standard\+Aggregator}.

\index{ns3\+::\+Mpdu\+Aggregator@{ns3\+::\+Mpdu\+Aggregator}!Can\+Be\+Aggregated@{Can\+Be\+Aggregated}}
\index{Can\+Be\+Aggregated@{Can\+Be\+Aggregated}!ns3\+::\+Mpdu\+Aggregator@{ns3\+::\+Mpdu\+Aggregator}}
\subsubsection[{\texorpdfstring{Can\+Be\+Aggregated(uint32\+\_\+t packet\+Size, Ptr$<$ Packet $>$ aggregated\+Packet, uint8\+\_\+t block\+Ack\+Size) const =0}{CanBeAggregated(uint32_t packetSize, Ptr< Packet > aggregatedPacket, uint8_t blockAckSize) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool ns3\+::\+Mpdu\+Aggregator\+::\+Can\+Be\+Aggregated (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{packet\+Size, }
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{aggregated\+Packet, }
\item[{uint8\+\_\+t}]{block\+Ack\+Size}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1MpduAggregator_a3b9a3eb957da16bb9e01e619b23df10a}{}\label{classns3_1_1MpduAggregator_a3b9a3eb957da16bb9e01e619b23df10a}

\begin{DoxyParams}{Parameters}
{\em packet\+Size} & size of the packet we want to insert into {\itshape aggregated\+Packet}. \\
\hline
{\em aggregated\+Packet} & packet that will contain the packet of size {\itshape packet\+Size}, if aggregation is possible. \\
\hline
{\em block\+Ack\+Size} & size of the piggybacked block ack request\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the packet of size {\itshape packet\+Size} can be aggregated to {\itshape aggregated\+Packet}, false otherwise.
\end{DoxyReturn}
This method is used to determine if a packet could be aggregated to an A-\/\+M\+P\+DU without exceeding the maximum packet size. 

Implemented in \hyperlink{classns3_1_1MpduStandardAggregator_afe782faf74fce1ae60b4e59182eea462}{ns3\+::\+Mpdu\+Standard\+Aggregator}.

\index{ns3\+::\+Mpdu\+Aggregator@{ns3\+::\+Mpdu\+Aggregator}!Deaggregate@{Deaggregate}}
\index{Deaggregate@{Deaggregate}!ns3\+::\+Mpdu\+Aggregator@{ns3\+::\+Mpdu\+Aggregator}}
\subsubsection[{\texorpdfstring{Deaggregate(\+Ptr$<$ Packet $>$ aggregated\+Packet)}{Deaggregate(Ptr< Packet > aggregatedPacket)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Mpdu\+Aggregator\+::\+Deaggregated\+Mpdus} ns3\+::\+Mpdu\+Aggregator\+::\+Deaggregate (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{aggregated\+Packet}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1MpduAggregator_a4c5daf1c185ea5e4b82ea028327ba202}{}\label{classns3_1_1MpduAggregator_a4c5daf1c185ea5e4b82ea028327ba202}
Deaggregates an A-\/\+M\+P\+DU by removing the A-\/\+M\+P\+DU subframe header and padding.


\begin{DoxyParams}{Parameters}
{\em aggregated\+Packet} & the aggregated packet \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
list of deaggragted packets and their A-\/\+M\+P\+DU subframe headers 
\end{DoxyReturn}

\begin{DoxyCode}
43 \{
44   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
45   \hyperlink{classns3_1_1MpduAggregator_a09f3b03cb988045c381fad4ba4dce371}{DeaggregatedMpdus} \textcolor{keyword}{set};
46 
47   AmpduSubframeHeader hdr;
48   Ptr<Packet> extractedMpdu = Create<Packet> ();
49   uint32\_t maxSize = aggregatedPacket->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ();
50   uint16\_t extractedLength;
51   uint32\_t padding;
52   uint32\_t deserialized = 0;
53 
54   \textcolor{keywordflow}{while} (deserialized < maxSize)
55     \{
56       deserialized += aggregatedPacket->\hyperlink{classns3_1_1Packet_a0961eccf975d75f902d40956c93ba63e}{RemoveHeader} (hdr);
57       extractedLength = hdr.GetLength ();
58       extractedMpdu = aggregatedPacket->\hyperlink{classns3_1_1Packet_a16f6113606b355b2b346e2245fa2a3d0}{CreateFragment} (0, static\_cast<uint32\_t> (
      extractedLength));
59       aggregatedPacket->\hyperlink{classns3_1_1Packet_a78aa207e7921dd2f9f7e0d0b7a1c730a}{RemoveAtStart} (extractedLength);
60       deserialized += extractedLength;
61 
62       padding = (4 - (extractedLength % 4 )) % 4;
63 
64       \textcolor{keywordflow}{if} (padding > 0 && deserialized < maxSize)
65         \{
66           aggregatedPacket->\hyperlink{classns3_1_1Packet_a78aa207e7921dd2f9f7e0d0b7a1c730a}{RemoveAtStart} (padding);
67           deserialized += padding;
68         \}
69 
70       std::pair<Ptr<Packet>, AmpduSubframeHeader> packetHdr (extractedMpdu, hdr);
71       \textcolor{keyword}{set}.push\_back (packetHdr);
72     \}
73   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Deaggreated A-MPDU: extracted "} << \textcolor{keyword}{set}.size () << \textcolor{stringliteral}{" MPDUs"});
74   \textcolor{keywordflow}{return} \textcolor{keyword}{set};
75 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2




Here is the caller graph for this function\+:
% FIG 3


\index{ns3\+::\+Mpdu\+Aggregator@{ns3\+::\+Mpdu\+Aggregator}!Get\+Max\+Ampdu\+Size@{Get\+Max\+Ampdu\+Size}}
\index{Get\+Max\+Ampdu\+Size@{Get\+Max\+Ampdu\+Size}!ns3\+::\+Mpdu\+Aggregator@{ns3\+::\+Mpdu\+Aggregator}}
\subsubsection[{\texorpdfstring{Get\+Max\+Ampdu\+Size(void) const =0}{GetMaxAmpduSize(void) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual uint32\+\_\+t ns3\+::\+Mpdu\+Aggregator\+::\+Get\+Max\+Ampdu\+Size (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1MpduAggregator_a781ed153a388bbc8a5ac231cfd9218c8}{}\label{classns3_1_1MpduAggregator_a781ed153a388bbc8a5ac231cfd9218c8}
Returns the maximum A-\/\+M\+P\+DU size in bytes. Value 0 means that M\+P\+DU aggregation is disabled.

\begin{DoxyReturn}{Returns}
the maximum A-\/\+M\+P\+DU size in bytes. 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1MpduStandardAggregator_adea8b7a94c26a41f893297f59978e4b7}{ns3\+::\+Mpdu\+Standard\+Aggregator}.



Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::\+Mpdu\+Aggregator@{ns3\+::\+Mpdu\+Aggregator}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Mpdu\+Aggregator@{ns3\+::\+Mpdu\+Aggregator}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Mpdu\+Aggregator\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1MpduAggregator_a5b9097a5ff858ae68a735446c2b3544e}{}\label{classns3_1_1MpduAggregator_a5b9097a5ff858ae68a735446c2b3544e}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
32 \{
33   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::MpduAggregator"})
34     .SetParent<\hyperlink{classns3_1_1Object_a40860402e64d8008fb42329df7097cdb}{Object}> ()
35     .SetGroupName (\textcolor{stringliteral}{"Wifi"})
36     \textcolor{comment}{//No AddConstructor because this is an abstract class.}
37   ;
38   \textcolor{keywordflow}{return} tid;
39 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5


\index{ns3\+::\+Mpdu\+Aggregator@{ns3\+::\+Mpdu\+Aggregator}!Set\+Max\+Ampdu\+Size@{Set\+Max\+Ampdu\+Size}}
\index{Set\+Max\+Ampdu\+Size@{Set\+Max\+Ampdu\+Size}!ns3\+::\+Mpdu\+Aggregator@{ns3\+::\+Mpdu\+Aggregator}}
\subsubsection[{\texorpdfstring{Set\+Max\+Ampdu\+Size(uint32\+\_\+t max\+Size)=0}{SetMaxAmpduSize(uint32_t maxSize)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Mpdu\+Aggregator\+::\+Set\+Max\+Ampdu\+Size (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{max\+Size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1MpduAggregator_a00344d9ef60b8ad4368769b31761f55d}{}\label{classns3_1_1MpduAggregator_a00344d9ef60b8ad4368769b31761f55d}
Sets the maximum A-\/\+M\+P\+DU size in bytes. Value 0 means that M\+P\+DU aggregation is disabled.


\begin{DoxyParams}{Parameters}
{\em max\+Size} & the maximum A-\/\+M\+P\+DU size in bytes. \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classns3_1_1MpduStandardAggregator_aa180c7dbeca04fa473f79e6ca107584d}{ns3\+::\+Mpdu\+Standard\+Aggregator}.



Here is the caller graph for this function\+:
% FIG 6




The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
wifi/model/\hyperlink{mpdu-aggregator_8h}{mpdu-\/aggregator.\+h}\item 
wifi/model/\hyperlink{mpdu-aggregator_8cc}{mpdu-\/aggregator.\+cc}\end{DoxyCompactItemize}
