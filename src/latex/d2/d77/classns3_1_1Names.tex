\hypertarget{classns3_1_1Names}{}\section{ns3\+:\+:Names Class Reference}
\label{classns3_1_1Names}\index{ns3\+::\+Names@{ns3\+::\+Names}}


A directory of name and Ptr$<$\+Object$>$ associations that allows us to give any \hyperlink{namespacens3}{ns3} \hyperlink{classns3_1_1Object}{Object} a name.  




{\ttfamily \#include $<$names.\+h$>$}



Collaboration diagram for ns3\+:\+:Names\+:
% FIG 0
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static void \hyperlink{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}{Add} (std\+::string \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name}, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Object}{Object} $>$ object)
\begin{DoxyCompactList}\small\item\em Add the association between the string \char`\"{}name\char`\"{} and the Ptr$<$\+Object$>$ obj. \end{DoxyCompactList}\item 
static void \hyperlink{classns3_1_1Names_a1a251b61a3a52abf2c138c7bddcc0024}{Add} (std\+::string path, std\+::string \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name}, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Object}{Object} $>$ object)
\begin{DoxyCompactList}\small\item\em An intermediate form of \hyperlink{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}{Names\+::\+Add} allowing you to provide a path to the parent object (under which you want this name to be defined) in the form of a name path string. \end{DoxyCompactList}\item 
static void \hyperlink{classns3_1_1Names_a93e958166cb8296bc0fa035668d83040}{Add} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Object}{Object} $>$ context, std\+::string \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name}, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Object}{Object} $>$ object)
\begin{DoxyCompactList}\small\item\em A low-\/level form of \hyperlink{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}{Names\+::\+Add} allowing you to specify the path to the parent object (under which you want this name to be defined) in the form of a previously named object. \end{DoxyCompactList}\item 
static void \hyperlink{classns3_1_1Names_a0ed4aa6358357bef3930cd19ba306373}{Rename} (std\+::string oldpath, std\+::string newname)
\begin{DoxyCompactList}\small\item\em Rename a previously associated name. \end{DoxyCompactList}\item 
static void \hyperlink{classns3_1_1Names_a8e7b8a3e5e9423ef8c61d6ad216ca81c}{Rename} (std\+::string path, std\+::string oldname, std\+::string newname)
\begin{DoxyCompactList}\small\item\em An intermediate form of \hyperlink{classns3_1_1Names_a0ed4aa6358357bef3930cd19ba306373}{Names\+::\+Rename} allowing you to provide a path to the parent object (under which you want this name to be changed) in the form of a name path string. \end{DoxyCompactList}\item 
static void \hyperlink{classns3_1_1Names_ad6474f8c16e99575397c5c243a3f9aa4}{Rename} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Object}{Object} $>$ context, std\+::string oldname, std\+::string newname)
\begin{DoxyCompactList}\small\item\em A low-\/level form of \hyperlink{classns3_1_1Names_a0ed4aa6358357bef3930cd19ba306373}{Names\+::\+Rename} allowing you to specify the path to the parent object (under which you want this name to be changed) in the form of a previously named object. \end{DoxyCompactList}\item 
static std\+::string \hyperlink{classns3_1_1Names_ab9664faf23569aaae64a2d1f65265045}{Find\+Name} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Object}{Object} $>$ object)
\begin{DoxyCompactList}\small\item\em Given a pointer to an object, look to see if that object has a name associated with it and, if so, return the name of the object otherwise return an empty string. \end{DoxyCompactList}\item 
static std\+::string \hyperlink{classns3_1_1Names_af72bee5ceb8c2592ef37063311501498}{Find\+Path} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Object}{Object} $>$ object)
\begin{DoxyCompactList}\small\item\em Given a pointer to an object, look to see if that object has a name associated with it and return the fully qualified name path of the object otherwise return an empty string. \end{DoxyCompactList}\item 
static void \hyperlink{classns3_1_1Names_abda77642452c3e4a4ad8a76491dd2538}{Clear} (void)
\begin{DoxyCompactList}\small\item\em Clear the list of objects associated with names. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\static \hyperlink{classns3_1_1Ptr}{Ptr}$<$ T $>$ \hyperlink{classns3_1_1Names_a9d07094fb3d716d08733af05c1593555}{Find} (std\+::string path)
\begin{DoxyCompactList}\small\item\em Given a name path string, look to see if there\textquotesingle{}s an object in the system with that associated to it. If there is, do a Get\+Object on the resulting object to convert it to the requested typename and return it. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\static \hyperlink{classns3_1_1Ptr}{Ptr}$<$ T $>$ \hyperlink{classns3_1_1Names_a5d9baba3c4fe189b9e2c493df9e70697}{Find} (std\+::string path, std\+::string \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name})
\begin{DoxyCompactList}\small\item\em Given a path to an object and an object name, look through the names defined under the path to see if there\textquotesingle{}s an object there with the given name. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\static \hyperlink{classns3_1_1Ptr}{Ptr}$<$ T $>$ \hyperlink{classns3_1_1Names_a7d2851cf2c04306722f838f37430d93f}{Find} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Object}{Object} $>$ context, std\+::string \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name})
\begin{DoxyCompactList}\small\item\em Given a path to an object and an object name, look through the names defined under the path to see if there\textquotesingle{}s an object there with the given name. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Private Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Object}{Object} $>$ \hyperlink{classns3_1_1Names_a1d022d5483c79de459ce17e89d98d3f4}{Find\+Internal} (std\+::string path)
\begin{DoxyCompactList}\small\item\em Non-\/templated internal version of \hyperlink{classns3_1_1Names_a9d07094fb3d716d08733af05c1593555}{Names\+::\+Find}. \end{DoxyCompactList}\item 
static \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Object}{Object} $>$ \hyperlink{classns3_1_1Names_a429d750ca5b03823d6dea2ed3476b3ab}{Find\+Internal} (std\+::string path, std\+::string \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name})
\begin{DoxyCompactList}\small\item\em Non-\/templated internal version of \hyperlink{classns3_1_1Names_a9d07094fb3d716d08733af05c1593555}{Names\+::\+Find}. \end{DoxyCompactList}\item 
static \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Object}{Object} $>$ \hyperlink{classns3_1_1Names_ad261506a54c7a4f7db29a856d8a9d6d2}{Find\+Internal} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Object}{Object} $>$ context, std\+::string \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name})
\begin{DoxyCompactList}\small\item\em Non-\/templated internal version of \hyperlink{classns3_1_1Names_a9d07094fb3d716d08733af05c1593555}{Names\+::\+Find}. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
A directory of name and Ptr$<$\+Object$>$ associations that allows us to give any \hyperlink{namespacens3}{ns3} \hyperlink{classns3_1_1Object}{Object} a name. 

\subsection{Member Function Documentation}
\index{ns3\+::\+Names@{ns3\+::\+Names}!Add@{Add}}
\index{Add@{Add}!ns3\+::\+Names@{ns3\+::\+Names}}
\subsubsection[{\texorpdfstring{Add(std\+::string name, Ptr$<$ Object $>$ object)}{Add(std::string name, Ptr< Object > object)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Names\+::\+Add (
\begin{DoxyParamCaption}
\item[{std\+::string}]{name, }
\item[{{\bf Ptr}$<$ {\bf Object} $>$}]{object}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}{}\label{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}


Add the association between the string \char`\"{}name\char`\"{} and the Ptr$<$\+Object$>$ obj. 

The name may begin either with \char`\"{}/\+Names\char`\"{} to explicitly call out the fact that the name provided is installed under the root of the name space, or it may begin with the name of the first object in the path. For example, \hyperlink{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}{Names\+::\+Add} (\char`\"{}/\+Names/client\char`\"{}, obj) and \hyperlink{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}{Names\+::\+Add} (\char`\"{}client\char`\"{}, obj) accomplish exactly the same thing. A name at a given level in the name space path must be unique. In the case of the example above, it would be illegal to try and associate a different object with the same name\+: \char`\"{}client\char`\"{} at the same level (\char`\"{}/\+Names\char`\"{}) in the path.

As well as specifying a name at the root of the \char`\"{}/\+Names\char`\"{} namespace, the name parameter can contain a path that fully qualifies the name to be added. For example, if you previously have named an object \char`\"{}client\char`\"{} in the root namespace as above, you could name an object \char`\"{}under\char`\"{} that name by making a call like \hyperlink{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}{Names\+::\+Add} (\char`\"{}/\+Names/client/eth0\char`\"{}, obj). This will define the name \char`\"{}eth0\char`\"{} and make it reachable using the path specified. Note that \hyperlink{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}{Names\+::\+Add} (\char`\"{}client/eth0\char`\"{}, obj) would accomplish exactly the same thing.

Duplicate names are not allowed at the same level in a path, however you may associate similar names with different paths. For example, if you define \char`\"{}/\+Names/\+Client\char`\"{}, you may not define another \char`\"{}/\+Names/\+Client\char`\"{} just as you may not have two files with the same name in a classical filesystem. However, you may have \char`\"{}/\+Names/\+Client/eth0\char`\"{} and \char`\"{}/\+Names/\+Server/eth0\char`\"{} defined at the same time just as you might have different files of the same name under different directories.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em name} & The name of the object you want to associate; which may be prepended with a path to that object. \\
\hline
\mbox{\tt in}  & {\em object} & A smart pointer to the object itself. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
695 \{
696   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name} << \textcolor{keywordtype}{object});
697   \textcolor{keywordtype}{bool} result = \hyperlink{classns3_1_1Singleton_a80a2cd3c25a27ea72add7a9f7a141ffa}{NamesPriv::Get} ()->\hyperlink{classns3_1_1NamesPriv_a1d9bc7794dedbcb88c7f875c084761bb}{Add} (\hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name}, \textcolor{keywordtype}{object});
698   \hyperlink{group__fatal_ga0bd3f62c55e7347ff814572f3aaa3864}{NS\_ABORT\_MSG\_UNLESS} (result, \textcolor{stringliteral}{"Names::Add(): Error adding name "} << 
      \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name});
699 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 1




Here is the caller graph for this function\+:
% FIG 2


\index{ns3\+::\+Names@{ns3\+::\+Names}!Add@{Add}}
\index{Add@{Add}!ns3\+::\+Names@{ns3\+::\+Names}}
\subsubsection[{\texorpdfstring{Add(std\+::string path, std\+::string name, Ptr$<$ Object $>$ object)}{Add(std::string path, std::string name, Ptr< Object > object)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Names\+::\+Add (
\begin{DoxyParamCaption}
\item[{std\+::string}]{path, }
\item[{std\+::string}]{name, }
\item[{{\bf Ptr}$<$ {\bf Object} $>$}]{object}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Names_a1a251b61a3a52abf2c138c7bddcc0024}{}\label{classns3_1_1Names_a1a251b61a3a52abf2c138c7bddcc0024}


An intermediate form of \hyperlink{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}{Names\+::\+Add} allowing you to provide a path to the parent object (under which you want this name to be defined) in the form of a name path string. 

In some cases, it is desirable to break up the path used to describe an item in the names namespace into a path and a name. This is analogous to a file system operation in which you provide a directory name and a file name.

For example, consider a situation where you have previously named an object \char`\"{}/\+Names/server\char`\"{}. If you further want to create an association for between a Ptr$<$\+Object$>$ object that you want to live \char`\"{}under\char`\"{} the server in the name space -- perhaps \char`\"{}eth0\char`\"{} -- you could do this in two ways, depending on which was more convenient\+: \hyperlink{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}{Names\+::\+Add} (\char`\"{}/\+Names/server/eth0\char`\"{}, object) or, using the split path and name approach, \hyperlink{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}{Names\+::\+Add} (\char`\"{}/\+Names/server\char`\"{}, \char`\"{}eth0\char`\"{}, object).

Duplicate names are not allowed at the same level in a path, however you may associate similar names with different paths. For example, if you define \char`\"{}/\+Names/\+Client\char`\"{}, you may not define another \char`\"{}/\+Names/\+Client\char`\"{} just as you may not have two files with the same name in a classical filesystem. However, you may have \char`\"{}/\+Names/\+Client/eth0\char`\"{} and \char`\"{}/\+Names/\+Server/eth0\char`\"{} defined at the same time just as you might have different files of the same name under different directories.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path} & A path name describing a previously named object under which you want this new name to be defined. \\
\hline
\mbox{\tt in}  & {\em name} & The name of the object you want to associate. \\
\hline
\mbox{\tt in}  & {\em object} & A smart pointer to the object itself.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}{Names\+::\+Add} (Ptr$<$\+Object$>$,std\+::string,Ptr$<$\+Object$>$); 
\end{DoxySeeAlso}

\begin{DoxyCode}
711 \{
712   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (path << \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name} << \textcolor{keywordtype}{object});
713   \textcolor{keywordtype}{bool} result = \hyperlink{classns3_1_1Singleton_a80a2cd3c25a27ea72add7a9f7a141ffa}{NamesPriv::Get} ()->\hyperlink{classns3_1_1NamesPriv_a1d9bc7794dedbcb88c7f875c084761bb}{Add} (path, \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name}, \textcolor{keywordtype}{object});
714   \hyperlink{group__fatal_ga0bd3f62c55e7347ff814572f3aaa3864}{NS\_ABORT\_MSG\_UNLESS} (result, \textcolor{stringliteral}{"Names::Add(): Error adding "} << path << \textcolor{stringliteral}{" "} << 
      \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name});
715 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::\+Names@{ns3\+::\+Names}!Add@{Add}}
\index{Add@{Add}!ns3\+::\+Names@{ns3\+::\+Names}}
\subsubsection[{\texorpdfstring{Add(\+Ptr$<$ Object $>$ context, std\+::string name, Ptr$<$ Object $>$ object)}{Add(Ptr< Object > context, std::string name, Ptr< Object > object)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Names\+::\+Add (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Object} $>$}]{context, }
\item[{std\+::string}]{name, }
\item[{{\bf Ptr}$<$ {\bf Object} $>$}]{object}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Names_a93e958166cb8296bc0fa035668d83040}{}\label{classns3_1_1Names_a93e958166cb8296bc0fa035668d83040}


A low-\/level form of \hyperlink{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}{Names\+::\+Add} allowing you to specify the path to the parent object (under which you want this name to be defined) in the form of a previously named object. 

In some use cases, it is desirable to break up the path in the names name space into a path and a name. This is analogous to a file system operation in which you provide a directory name and a file name. Recall that the path string actually refers to a previously named object, \char`\"{}under\char`\"{} which you want to accomplish some naming action.

However, the path is sometimes not available, and you only have the object that is represented by the path in the names name space. To support this use-\/case in a reasonably high-\/performance way, the path string is can be replaced by the object pointer to which that path would refer. In the spirit of the \hyperlink{namespacens3_1_1Config}{Config} code where this use-\/case is most prominent, we refer to this object as the \char`\"{}context\char`\"{} for the names operation.

You can think of the context roughly as the inode number of a directory file in Unix. The inode number can be used to look up the directory file which contains the list of file names defined at that directory level. Similarly the context is used to look up an internal name service entry which contains the names defined for that context.

For example, consider a situation where you have previously named an object \char`\"{}/\+Names/server\char`\"{}. If you further want to create an association for between a Ptr$<$\+Object$>$ object that you want to live \char`\"{}under\char`\"{} the server in the name space -- perhaps \char`\"{}eth0\char`\"{} -- you could do this by providing a complete path to the new name\+: \hyperlink{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}{Names\+::\+Add} (\char`\"{}/\+Names/server/eth0\char`\"{}, object). If, however, somewhere in your code you only had a pointer to the server, say \hyperlink{classns3_1_1Ptr}{Ptr$<$\+Node$>$} node, and not a handy path string, you could also accomplish this by \hyperlink{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}{Names\+::\+Add} (node, \char`\"{}eth0\char`\"{}, object).

Duplicate names are not allowed at the same level in a path. In the case of this method, the context object gives the same information as a path string. You may associate similar names with different paths. For example, if you define\char`\"{}/\+Names/\+Client\char`\"{}, you may not define another \char`\"{}/\+Names/\+Client\char`\"{} just as you may not have two files with the same name in a classical filesystem. However, you may have \char`\"{}/\+Names/\+Client/eth0\char`\"{} and \char`\"{}/\+Names/\+Server/eth0\char`\"{} defined at the same time just as you might have different files of the same name under different directories.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em context} & A smart pointer to an object that is used in place of the path under which you want this new name to be defined. \\
\hline
\mbox{\tt in}  & {\em name} & The name of the object you want to associate. \\
\hline
\mbox{\tt in}  & {\em object} & A smart pointer to the object itself. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
727 \{
728   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (context << \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name} << \textcolor{keywordtype}{object});
729   \textcolor{keywordtype}{bool} result = \hyperlink{classns3_1_1Singleton_a80a2cd3c25a27ea72add7a9f7a141ffa}{NamesPriv::Get} ()->\hyperlink{classns3_1_1NamesPriv_a1d9bc7794dedbcb88c7f875c084761bb}{Add} (context, \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name}, \textcolor{keywordtype}{object});
730   \hyperlink{group__fatal_ga0bd3f62c55e7347ff814572f3aaa3864}{NS\_ABORT\_MSG\_UNLESS} (result, \textcolor{stringliteral}{"Names::Add(): Error adding name "} << 
      \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name} << \textcolor{stringliteral}{" under context "} << &context);
731 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4


\index{ns3\+::\+Names@{ns3\+::\+Names}!Clear@{Clear}}
\index{Clear@{Clear}!ns3\+::\+Names@{ns3\+::\+Names}}
\subsubsection[{\texorpdfstring{Clear(void)}{Clear(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Names\+::\+Clear (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Names_abda77642452c3e4a4ad8a76491dd2538}{}\label{classns3_1_1Names_abda77642452c3e4a4ad8a76491dd2538}


Clear the list of objects associated with names. 


\begin{DoxyCode}
758 \{
759   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
760   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Singleton_a80a2cd3c25a27ea72add7a9f7a141ffa}{NamesPriv::Get} ()->\hyperlink{classns3_1_1NamesPriv_a7830244fafff9d2221a830e9b247b57a}{Clear} ();
761 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5




Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::\+Names@{ns3\+::\+Names}!Find@{Find}}
\index{Find@{Find}!ns3\+::\+Names@{ns3\+::\+Names}}
\subsubsection[{\texorpdfstring{Find(std\+::string path)}{Find(std::string path)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ {\bf Ptr}$<$ T $>$ ns3\+::\+Names\+::\+Find (
\begin{DoxyParamCaption}
\item[{std\+::string}]{path}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Names_a9d07094fb3d716d08733af05c1593555}{}\label{classns3_1_1Names_a9d07094fb3d716d08733af05c1593555}


Given a name path string, look to see if there\textquotesingle{}s an object in the system with that associated to it. If there is, do a Get\+Object on the resulting object to convert it to the requested typename and return it. 

An object can be referred to in two ways. Either you can talk about it using its fully qualified path name, for example, \char`\"{}/\+Names/client/eth0\char`\"{} or you can refer to it by its name, in this case \char`\"{}eth0\char`\"{}.

This method requires that the name path of the object be provided, e.\+g., \char`\"{}\+Names/client/eth0\char`\"{}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path} & A string containing a name space path used to locate the object.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A smart pointer to the named object converted to the requested type. 
\end{DoxyReturn}

\begin{DoxyCode}
457 \{
458   Ptr<Object> obj = \hyperlink{classns3_1_1Names_a1d022d5483c79de459ce17e89d98d3f4}{FindInternal} (path);
459   \textcolor{keywordflow}{if} (obj)
460     \{
461       \textcolor{keywordflow}{return} obj->GetObject<T> ();
462     \}
463   \textcolor{keywordflow}{else}
464     \{
465       \textcolor{keywordflow}{return} 0;
466     \}
467 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7


\index{ns3\+::\+Names@{ns3\+::\+Names}!Find@{Find}}
\index{Find@{Find}!ns3\+::\+Names@{ns3\+::\+Names}}
\subsubsection[{\texorpdfstring{Find(std\+::string path, std\+::string name)}{Find(std::string path, std::string name)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ {\bf Ptr}$<$ T $>$ ns3\+::\+Names\+::\+Find (
\begin{DoxyParamCaption}
\item[{std\+::string}]{path, }
\item[{std\+::string}]{name}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Names_a5d9baba3c4fe189b9e2c493df9e70697}{}\label{classns3_1_1Names_a5d9baba3c4fe189b9e2c493df9e70697}


Given a path to an object and an object name, look through the names defined under the path to see if there\textquotesingle{}s an object there with the given name. 

In some cases, it is desirable to break up the path used to describe an item in the names namespace into a path and a name. This is analogous to a file system operation in which you provide a directory name and a file name.

For example, consider a situation where you have previously named an object \char`\"{}/\+Names/server/eth0\char`\"{}. If you want to discover the object which you associated with this path, you could do this in two ways, depending on which was more convenient\+: \hyperlink{classns3_1_1Names_a9d07094fb3d716d08733af05c1593555}{Names\+::\+Find} (\char`\"{}/\+Names/server/eth0\char`\"{}) or, using the split path and name approach, \hyperlink{classns3_1_1Names_a9d07094fb3d716d08733af05c1593555}{Names\+::\+Find} (\char`\"{}/\+Names/server\char`\"{}, \char`\"{}eth0\char`\"{}).


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path} & A path name describing a previously named object under which you want to look for the specified name. \\
\hline
\mbox{\tt in}  & {\em name} & A string containing a name to search for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A smart pointer to the named object converted to the requested type. 
\end{DoxyReturn}

\begin{DoxyCode}
473 \{
474   Ptr<Object> obj = \hyperlink{classns3_1_1Names_a1d022d5483c79de459ce17e89d98d3f4}{FindInternal} (path, \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name});
475   \textcolor{keywordflow}{if} (obj)
476     \{
477       \textcolor{keywordflow}{return} obj->GetObject<T> ();
478     \}
479   \textcolor{keywordflow}{else}
480     \{
481       \textcolor{keywordflow}{return} 0;
482     \}
483 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8


\index{ns3\+::\+Names@{ns3\+::\+Names}!Find@{Find}}
\index{Find@{Find}!ns3\+::\+Names@{ns3\+::\+Names}}
\subsubsection[{\texorpdfstring{Find(\+Ptr$<$ Object $>$ context, std\+::string name)}{Find(Ptr< Object > context, std::string name)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ {\bf Ptr}$<$ T $>$ ns3\+::\+Names\+::\+Find (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Object} $>$}]{context, }
\item[{std\+::string}]{name}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Names_a7d2851cf2c04306722f838f37430d93f}{}\label{classns3_1_1Names_a7d2851cf2c04306722f838f37430d93f}


Given a path to an object and an object name, look through the names defined under the path to see if there\textquotesingle{}s an object there with the given name. 

In some cases, it is desirable to break up the path used to describe an item in the names namespace into a path and a name. This is analogous to a file system operation in which you provide a directory name and a file name.

For example, consider a situation where you have previously named an object \char`\"{}/\+Names/server/eth0\char`\"{}. If you want to discover the object which you associated with this path, you could do this in two ways, depending on which was more convenient\+: \hyperlink{classns3_1_1Names_a9d07094fb3d716d08733af05c1593555}{Names\+::\+Find} (\char`\"{}/\+Names/server/eth0\char`\"{}) or, using the split path and name approach, \hyperlink{classns3_1_1Names_a9d07094fb3d716d08733af05c1593555}{Names\+::\+Find} (\char`\"{}/\+Names/server\char`\"{}, \char`\"{}eth0\char`\"{}).

However, the path is sometimes not available, and you only have the object that is represented by the path in the names name space. To support this use-\/case in a reasonably high-\/performance way, the path string is can be replaced by the object pointer to which that path would refer. In the spirit of the \hyperlink{namespacens3_1_1Config}{Config} code where this use-\/case is most prominent, we refer to this object as the \char`\"{}context\char`\"{} for the names operation.

You can think of the context roughly as the inode number of a directory file in Unix. The inode number can be used to look up the directory file which contains the list of file names defined at that directory level. Similarly the context is used to look up an internal name service entry which contains the names defined for that context.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em context} & A smart pointer to an object that is used in place of the path under which you want this new name to be defined. \\
\hline
\mbox{\tt in}  & {\em name} & A string containing a name to search for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A smart pointer to the named object converted to the requested type. 
\end{DoxyReturn}

\begin{DoxyCode}
489 \{
490   Ptr<Object> obj = \hyperlink{classns3_1_1Names_a1d022d5483c79de459ce17e89d98d3f4}{FindInternal} (context, \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name});
491   \textcolor{keywordflow}{if} (obj)
492     \{
493       \textcolor{keywordflow}{return} obj->GetObject<T> ();
494     \}
495   \textcolor{keywordflow}{else}
496     \{
497       \textcolor{keywordflow}{return} 0;
498     \}
499 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9


\index{ns3\+::\+Names@{ns3\+::\+Names}!Find\+Internal@{Find\+Internal}}
\index{Find\+Internal@{Find\+Internal}!ns3\+::\+Names@{ns3\+::\+Names}}
\subsubsection[{\texorpdfstring{Find\+Internal(std\+::string path)}{FindInternal(std::string path)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Object} $>$ ns3\+::\+Names\+::\+Find\+Internal (
\begin{DoxyParamCaption}
\item[{std\+::string}]{path}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\hypertarget{classns3_1_1Names_a1d022d5483c79de459ce17e89d98d3f4}{}\label{classns3_1_1Names_a1d022d5483c79de459ce17e89d98d3f4}


Non-\/templated internal version of \hyperlink{classns3_1_1Names_a9d07094fb3d716d08733af05c1593555}{Names\+::\+Find}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path} & A string containing the path of the object to look for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A smart pointer to the named object. 
\end{DoxyReturn}

\begin{DoxyCode}
765 \{
766   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name});
767   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Singleton_a80a2cd3c25a27ea72add7a9f7a141ffa}{NamesPriv::Get} ()->\hyperlink{classns3_1_1NamesPriv_aeb1553e055f77ec72919f4ed41e4aec2}{Find} (\hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name});
768 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10




Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::\+Names@{ns3\+::\+Names}!Find\+Internal@{Find\+Internal}}
\index{Find\+Internal@{Find\+Internal}!ns3\+::\+Names@{ns3\+::\+Names}}
\subsubsection[{\texorpdfstring{Find\+Internal(std\+::string path, std\+::string name)}{FindInternal(std::string path, std::string name)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Object} $>$ ns3\+::\+Names\+::\+Find\+Internal (
\begin{DoxyParamCaption}
\item[{std\+::string}]{path, }
\item[{std\+::string}]{name}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\hypertarget{classns3_1_1Names_a429d750ca5b03823d6dea2ed3476b3ab}{}\label{classns3_1_1Names_a429d750ca5b03823d6dea2ed3476b3ab}


Non-\/templated internal version of \hyperlink{classns3_1_1Names_a9d07094fb3d716d08733af05c1593555}{Names\+::\+Find}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path} & A string containing the path to search for the object in. \\
\hline
\mbox{\tt in}  & {\em name} & A string containing the name of the object to look for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A smart pointer to the named object. 
\end{DoxyReturn}

\begin{DoxyCode}
772 \{
773   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (path << \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name});
774   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Singleton_a80a2cd3c25a27ea72add7a9f7a141ffa}{NamesPriv::Get} ()->\hyperlink{classns3_1_1NamesPriv_aeb1553e055f77ec72919f4ed41e4aec2}{Find} (path, \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name});
775 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12


\index{ns3\+::\+Names@{ns3\+::\+Names}!Find\+Internal@{Find\+Internal}}
\index{Find\+Internal@{Find\+Internal}!ns3\+::\+Names@{ns3\+::\+Names}}
\subsubsection[{\texorpdfstring{Find\+Internal(\+Ptr$<$ Object $>$ context, std\+::string name)}{FindInternal(Ptr< Object > context, std::string name)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Object} $>$ ns3\+::\+Names\+::\+Find\+Internal (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Object} $>$}]{context, }
\item[{std\+::string}]{name}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\hypertarget{classns3_1_1Names_ad261506a54c7a4f7db29a856d8a9d6d2}{}\label{classns3_1_1Names_ad261506a54c7a4f7db29a856d8a9d6d2}


Non-\/templated internal version of \hyperlink{classns3_1_1Names_a9d07094fb3d716d08733af05c1593555}{Names\+::\+Find}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em context} & A smart pointer to an object under which you want to look for the provided name. \\
\hline
\mbox{\tt in}  & {\em name} & A string containing the name to look for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A smart pointer to the named object. 
\end{DoxyReturn}

\begin{DoxyCode}
779 \{
780   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (context << \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name});
781   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Singleton_a80a2cd3c25a27ea72add7a9f7a141ffa}{NamesPriv::Get} ()->\hyperlink{classns3_1_1NamesPriv_aeb1553e055f77ec72919f4ed41e4aec2}{Find} (context, \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name});
782 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13


\index{ns3\+::\+Names@{ns3\+::\+Names}!Find\+Name@{Find\+Name}}
\index{Find\+Name@{Find\+Name}!ns3\+::\+Names@{ns3\+::\+Names}}
\subsubsection[{\texorpdfstring{Find\+Name(\+Ptr$<$ Object $>$ object)}{FindName(Ptr< Object > object)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string ns3\+::\+Names\+::\+Find\+Name (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Object} $>$}]{object}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Names_ab9664faf23569aaae64a2d1f65265045}{}\label{classns3_1_1Names_ab9664faf23569aaae64a2d1f65265045}


Given a pointer to an object, look to see if that object has a name associated with it and, if so, return the name of the object otherwise return an empty string. 

An object can be referred to in two ways. Either you can talk about it using its fully qualified path name, for example, \char`\"{}/\+Names/client/eth0\char`\"{} or you can refer to it by its name, in this case \char`\"{}eth0\char`\"{}.

This method returns the name of the object, e.\+g., \char`\"{}eth0\char`\"{}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em object} & A smart pointer to an object for which you want to find its name.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A string containing the name of the object if found, otherwise the empty string. 
\end{DoxyReturn}

\begin{DoxyCode}
744 \{
745   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keywordtype}{object});
746   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Singleton_a80a2cd3c25a27ea72add7a9f7a141ffa}{NamesPriv::Get} ()->\hyperlink{classns3_1_1NamesPriv_a7fbc3ac7b8924c08d86ddc79d96385fa}{FindName} (\textcolor{keywordtype}{object});
747 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 14




Here is the caller graph for this function\+:
% FIG 15


\index{ns3\+::\+Names@{ns3\+::\+Names}!Find\+Path@{Find\+Path}}
\index{Find\+Path@{Find\+Path}!ns3\+::\+Names@{ns3\+::\+Names}}
\subsubsection[{\texorpdfstring{Find\+Path(\+Ptr$<$ Object $>$ object)}{FindPath(Ptr< Object > object)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string ns3\+::\+Names\+::\+Find\+Path (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Object} $>$}]{object}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Names_af72bee5ceb8c2592ef37063311501498}{}\label{classns3_1_1Names_af72bee5ceb8c2592ef37063311501498}


Given a pointer to an object, look to see if that object has a name associated with it and return the fully qualified name path of the object otherwise return an empty string. 

An object can be referred to in two ways. Either you can talk about it using its fully qualified path name, for example, \char`\"{}/\+Names/client/eth0\char`\"{} or you can refer to it by its name, in this case \char`\"{}eth0\char`\"{}.

This method returns the name path of the object, e.\+g., \char`\"{}\+Names/client/eth0\char`\"{}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em object} & A smart pointer to an object for which you want to find its fullname.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A string containing the name path of the object, otherwise the empty string. 
\end{DoxyReturn}

\begin{DoxyCode}
751 \{
752   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keywordtype}{object});
753   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Singleton_a80a2cd3c25a27ea72add7a9f7a141ffa}{NamesPriv::Get} ()->\hyperlink{classns3_1_1NamesPriv_a4a2421dd19968986051239ce2615485f}{FindPath} (\textcolor{keywordtype}{object});
754 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 16




Here is the caller graph for this function\+:
% FIG 17


\index{ns3\+::\+Names@{ns3\+::\+Names}!Rename@{Rename}}
\index{Rename@{Rename}!ns3\+::\+Names@{ns3\+::\+Names}}
\subsubsection[{\texorpdfstring{Rename(std\+::string oldpath, std\+::string newname)}{Rename(std::string oldpath, std::string newname)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Names\+::\+Rename (
\begin{DoxyParamCaption}
\item[{std\+::string}]{oldpath, }
\item[{std\+::string}]{newname}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Names_a0ed4aa6358357bef3930cd19ba306373}{}\label{classns3_1_1Names_a0ed4aa6358357bef3930cd19ba306373}


Rename a previously associated name. 

The name may begin either with \char`\"{}/\+Names\char`\"{} to explicitly call out the fact that the name provided is installed under the root of the name space, or it may begin with the name of the first object in the path. For example, \hyperlink{classns3_1_1Names_a0ed4aa6358357bef3930cd19ba306373}{Names\+::\+Rename} (\char`\"{}/\+Names/client\char`\"{}, \char`\"{}server\char`\"{}) and \hyperlink{classns3_1_1Names_a0ed4aa6358357bef3930cd19ba306373}{Names\+::\+Rename} (\char`\"{}client\char`\"{}, \char`\"{}server\char`\"{}) accomplish exactly the same thing. \hyperlink{classns3_1_1Names}{Names} at a given level in the name space path must be unique. In the case of the example above, it would be illegal to try and rename a different object to the same name\+: \char`\"{}server\char`\"{} at the same level (\char`\"{}/\+Names\char`\"{}) in the path.

As well as specifying a name at the root of the \char`\"{}/\+Names\char`\"{} namespace, the name parameter can contain a path that fully qualifies the name to be changed. For example, if you previously have (re)named an object \char`\"{}server\char`\"{} in the root namespace as above, you could then rename an object \char`\"{}under\char`\"{} that name by making a call like \hyperlink{classns3_1_1Names_a0ed4aa6358357bef3930cd19ba306373}{Names\+::\+Rename} (\char`\"{}/\+Names/server/csma\char`\"{}, \char`\"{}eth0\char`\"{}). This will rename the object previously associated with \char`\"{}/\+Names/server/csma\char`\"{} to \char`\"{}eth0\char`\"{} and make leave it reachable using the path \char`\"{}/\+Names/server/eth0\char`\"{}. Note that \hyperlink{classns3_1_1Names_a0ed4aa6358357bef3930cd19ba306373}{Names\+::\+Rename} (\char`\"{}server/csma\char`\"{}, \char`\"{}eth0\char`\"{}) would accomplish exactly the same thing.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em oldpath} & The current path name to the object you want to change. \\
\hline
\mbox{\tt in}  & {\em newname} & The new name of the object you want to change.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}{Names\+::\+Add} (std\+::string \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name}, Ptr$<$\+Object$>$ obj) 
\end{DoxySeeAlso}

\begin{DoxyCode}
703 \{
704   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (oldpath << newname);
705   \textcolor{keywordtype}{bool} result = \hyperlink{classns3_1_1Singleton_a80a2cd3c25a27ea72add7a9f7a141ffa}{NamesPriv::Get} ()->\hyperlink{classns3_1_1NamesPriv_a51f6ec455739940fa02c6b46d1ea273a}{Rename} (oldpath, newname);
706   \hyperlink{group__fatal_ga0bd3f62c55e7347ff814572f3aaa3864}{NS\_ABORT\_MSG\_UNLESS} (result, \textcolor{stringliteral}{"Names::Rename(): Error renaming "} << oldpath << \textcolor{stringliteral}{" to "} 
      << newname);
707 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 18


\index{ns3\+::\+Names@{ns3\+::\+Names}!Rename@{Rename}}
\index{Rename@{Rename}!ns3\+::\+Names@{ns3\+::\+Names}}
\subsubsection[{\texorpdfstring{Rename(std\+::string path, std\+::string oldname, std\+::string newname)}{Rename(std::string path, std::string oldname, std::string newname)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Names\+::\+Rename (
\begin{DoxyParamCaption}
\item[{std\+::string}]{path, }
\item[{std\+::string}]{oldname, }
\item[{std\+::string}]{newname}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Names_a8e7b8a3e5e9423ef8c61d6ad216ca81c}{}\label{classns3_1_1Names_a8e7b8a3e5e9423ef8c61d6ad216ca81c}


An intermediate form of \hyperlink{classns3_1_1Names_a0ed4aa6358357bef3930cd19ba306373}{Names\+::\+Rename} allowing you to provide a path to the parent object (under which you want this name to be changed) in the form of a name path string. 

In some cases, it is desirable to break up the path used to describe an item in the names namespace into a path and a name. This is analogous to a file system operation in which you provide a directory name and a file name.

For example, consider a situation where you have previously named an object \char`\"{}/\+Names/server/csma\char`\"{}. If you want to change the name \char`\"{}csma\char`\"{} to \char`\"{}eth0\char`\"{}, you could do this in two ways, depending on which was more convenient\+: \hyperlink{classns3_1_1Names_a0ed4aa6358357bef3930cd19ba306373}{Names\+::\+Rename} (\char`\"{}/\+Names/server/csma\char`\"{}, \char`\"{}eth0\char`\"{}) or, using the split path and name approach, \hyperlink{classns3_1_1Names_a0ed4aa6358357bef3930cd19ba306373}{Names\+::\+Rename} (\char`\"{}/\+Names/server\char`\"{}, \char`\"{}csma\char`\"{}, \char`\"{}eth0\char`\"{}).


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path} & A path name describing a previously named object under which you want this name change to occur (cf. directory). \\
\hline
\mbox{\tt in}  & {\em oldname} & The currently defined name of the object. \\
\hline
\mbox{\tt in}  & {\em newname} & The new name you want the object to have. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
719 \{
720   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (path << oldname << newname);
721   \textcolor{keywordtype}{bool} result = \hyperlink{classns3_1_1Singleton_a80a2cd3c25a27ea72add7a9f7a141ffa}{NamesPriv::Get} ()->\hyperlink{classns3_1_1NamesPriv_a51f6ec455739940fa02c6b46d1ea273a}{Rename} (path, oldname, newname);
722   \hyperlink{group__fatal_ga0bd3f62c55e7347ff814572f3aaa3864}{NS\_ABORT\_MSG\_UNLESS} (result, \textcolor{stringliteral}{"Names::Rename (): Error renaming "} << path << \textcolor{stringliteral}{" "} << 
      oldname << \textcolor{stringliteral}{" to "} << newname);
723 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 19


\index{ns3\+::\+Names@{ns3\+::\+Names}!Rename@{Rename}}
\index{Rename@{Rename}!ns3\+::\+Names@{ns3\+::\+Names}}
\subsubsection[{\texorpdfstring{Rename(\+Ptr$<$ Object $>$ context, std\+::string oldname, std\+::string newname)}{Rename(Ptr< Object > context, std::string oldname, std::string newname)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Names\+::\+Rename (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Object} $>$}]{context, }
\item[{std\+::string}]{oldname, }
\item[{std\+::string}]{newname}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Names_ad6474f8c16e99575397c5c243a3f9aa4}{}\label{classns3_1_1Names_ad6474f8c16e99575397c5c243a3f9aa4}


A low-\/level form of \hyperlink{classns3_1_1Names_a0ed4aa6358357bef3930cd19ba306373}{Names\+::\+Rename} allowing you to specify the path to the parent object (under which you want this name to be changed) in the form of a previously named object. 

In some use cases, it is desirable to break up the path in the names name space into a path and a name. This is analogous to a file system operation in which you provide a directory name and a file name. Recall that the path string actually refers to a previously named object, \char`\"{}under\char`\"{} which you want to accomplish some naming action.

However, the path is sometimes not available, and you only have the object that is represented by the path in the names name space. To support this use-\/case in a reasonably high-\/performance way, the path string is can be replaced by the object pointer to which that path would refer. In the spirit of the \hyperlink{namespacens3_1_1Config}{Config} code where this use-\/case is most prominent, we refer to this object as the \char`\"{}context\char`\"{} for the names operation.

You can think of the context roughly as the inode number of a directory file in Unix. The inode number can be used to look up the directory file which contains the list of file names defined at that directory level. Similarly the context is used to look up an internal name service entry which contains the names defined for that context.

For example, consider a situation where you have previously named an object \char`\"{}/\+Names/server/csma\char`\"{}. If you later decide to rename the csma object to say \char`\"{}eth0\char`\"{} -- you could do this by providing a complete path as in \hyperlink{classns3_1_1Names_a0ed4aa6358357bef3930cd19ba306373}{Names\+::\+Rename} (\char`\"{}/\+Names/server/csma\char`\"{}, \char`\"{}eth0\char`\"{}). If, however, somewhere in your code you only had a pointer to the server, and not a handy path string, say \hyperlink{classns3_1_1Ptr}{Ptr$<$\+Node$>$} node, you could also accomplish this by \hyperlink{classns3_1_1Names_a0ed4aa6358357bef3930cd19ba306373}{Names\+::\+Rename} (node, \char`\"{}csma\char`\"{}, \char`\"{}eth0\char`\"{}).


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em context} & A smart pointer to an object that is used in place of the path under which you want this new name to be defined. \\
\hline
\mbox{\tt in}  & {\em oldname} & The current shortname of the object you want to change. \\
\hline
\mbox{\tt in}  & {\em newname} & The new shortname of the object you want to change. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
735 \{
736   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (context << oldname << newname);
737   \textcolor{keywordtype}{bool} result = \hyperlink{classns3_1_1Singleton_a80a2cd3c25a27ea72add7a9f7a141ffa}{NamesPriv::Get} ()->\hyperlink{classns3_1_1NamesPriv_a51f6ec455739940fa02c6b46d1ea273a}{Rename} (context, oldname, newname);
738   \hyperlink{group__fatal_ga0bd3f62c55e7347ff814572f3aaa3864}{NS\_ABORT\_MSG\_UNLESS} (result, \textcolor{stringliteral}{"Names::Rename (): Error renaming "} << oldname << \textcolor{stringliteral}{" to "} 
      << newname << \textcolor{stringliteral}{" under context "} <<
739                        &context);
740 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 20




The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
core/model/\hyperlink{names_8h}{names.\+h}\item 
core/model/\hyperlink{names_8cc}{names.\+cc}\end{DoxyCompactItemize}
