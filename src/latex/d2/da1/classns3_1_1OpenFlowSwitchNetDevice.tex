\hypertarget{classns3_1_1OpenFlowSwitchNetDevice}{}\section{ns3\+:\+:Open\+Flow\+Switch\+Net\+Device Class Reference}
\label{classns3_1_1OpenFlowSwitchNetDevice}\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}


A net device that switches multiple L\+AN segments via an Open\+Flow-\/compatible flow table.  




{\ttfamily \#include $<$openflow-\/switch-\/net-\/device.\+h$>$}



Inheritance diagram for ns3\+:\+:Open\+Flow\+Switch\+Net\+Device\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Open\+Flow\+Switch\+Net\+Device\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a11e21c621ed1fc60bf76a592cb680d3f}{Open\+Flow\+Switch\+Net\+Device} ()
\item 
virtual \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_afea7b099a698e5ff80d2ac177cae69bf}{$\sim$\+Open\+Flow\+Switch\+Net\+Device} ()
\item 
void \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a97be3cb2eeab82c224f82b7ffc63beb4}{Set\+Controller} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1ofi_1_1Controller}{ofi\+::\+Controller} $>$ \hyperlink{mmwave_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c})
\begin{DoxyCompactList}\small\item\em Set up the Switch\textquotesingle{}s controller connection. \end{DoxyCompactList}\item 
int \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a917303759eded2d67d5d7807551d3d3a}{Add\+Switch\+Port} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ switch\+Port)
\begin{DoxyCompactList}\small\item\em Add a \textquotesingle{}port\textquotesingle{} to a switch device. \end{DoxyCompactList}\item 
int \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_ad080768a6e246533386d1703e86d38e6}{Add\+V\+Port} (const ofp\+\_\+vport\+\_\+mod $\ast$ovpm)
\begin{DoxyCompactList}\small\item\em Add a virtual port to a switch device. \end{DoxyCompactList}\item 
int \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_aa1e672674ec0878d2bbece811450691a}{Stats\+Dump} (\hyperlink{structns3_1_1ofi_1_1StatsDumpCallback}{ofi\+::\+Stats\+Dump\+Callback} $\ast$cb\+\_\+)
\begin{DoxyCompactList}\small\item\em Stats callback is ready for a dump. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a8a4905d4cbb354ff27d89ecedd9cff5f}{Stats\+Done} (\hyperlink{structns3_1_1ofi_1_1StatsDumpCallback}{ofi\+::\+Stats\+Dump\+Callback} $\ast$cb\+\_\+)
\begin{DoxyCompactList}\small\item\em Stats callback is done. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a32ddf4836b4975a83cbf5e556a890c48}{Do\+Output} (uint32\+\_\+t packet\+\_\+uid, int in\+\_\+port, size\+\_\+t max\+\_\+len, int out\+\_\+port, bool ignore\+\_\+no\+\_\+fwd)
\begin{DoxyCompactList}\small\item\em Called from the Open\+Flow Interface to output the \hyperlink{classns3_1_1Packet}{Packet} on either a Port or the Controller. \end{DoxyCompactList}\item 
int \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a5442bdd0d556024442b1c4af38a41df8}{Forward\+Control\+Input} (const void $\ast$msg, size\+\_\+t length)
\begin{DoxyCompactList}\small\item\em The registered controller calls this method when sending a message to the switch. \end{DoxyCompactList}\item 
sw\+\_\+chain $\ast$ \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a27901b0defa5457880dc4106826997e7}{Get\+Chain} ()
\item 
uint32\+\_\+t \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a60a99198a982f9c0a75d21ba468d9c42}{Get\+N\+Switch\+Ports} (void) const 
\item 
int \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_afc0283b966814417b89981940f3c5b51}{Get\+Switch\+Port\+Index} (\hyperlink{structns3_1_1ofi_1_1Port}{ofi\+::\+Port} \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p})
\item 
\hyperlink{structns3_1_1ofi_1_1Port}{ofi\+::\+Port} \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_aa797150f34f80e22a2443043bf930728}{Get\+Switch\+Port} (uint32\+\_\+t \hyperlink{lte__link__budget__x2__handover__measures_8m_abdb05bc5a064cf642a06c83b3392f148}{n}) const 
\item 
vport\+\_\+table\+\_\+t \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a87ba400a91415ed84d9a1f82b08fff43}{Get\+V\+Port\+Table} ()
\item 
virtual void \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a7cfbd893f5fb6b11f5c474996bfe5af0}{Set\+If\+Index} (const uint32\+\_\+t index)
\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_aaf611feb833d73a226d3028345a70bc2}{Get\+If\+Index} (void) const 
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Channel}{Channel} $>$ \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a552c53c7d29d80cb0469df8a7c546eb2}{Get\+Channel} (void) const 
\item 
virtual void \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a3d005621ffcc3cc4dc43559598a17e1a}{Set\+Address} (\hyperlink{classns3_1_1Address}{Address} address)
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a9ace12c079dd551ea876bc503599c4b4}{Get\+Address} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a23992b30d089b76aa2e41bef4c3d46e4}{Set\+Mtu} (const uint16\+\_\+t mtu)
\item 
virtual uint16\+\_\+t \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a2e153f7ee4b6d93661f90784edf44116}{Get\+Mtu} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_aa96fe55aa7b2bea65974cbb5cd51161c}{Is\+Link\+Up} (void) const 
\item 
virtual void \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a3628df1997b920ab5542130c234f9108}{Add\+Link\+Change\+Callback} (\hyperlink{classns3_1_1Callback}{Callback}$<$ void $>$ callback)
\item 
virtual bool \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_af5e13232837763f5978b2ff93697b7fe}{Is\+Broadcast} (void) const 
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_ac537d6ccd1e8a4083f846d669170ea79}{Get\+Broadcast} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_aed07e20f6dede271e91c1eb727bb583e}{Is\+Multicast} (void) const 
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a4eea48f6fa1c3a9720ded005f757a4cd}{Get\+Multicast} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} multicast\+Group) const 
\begin{DoxyCompactList}\small\item\em Make and return a M\+AC multicast address using the provided multicast group. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a467062edd9bb5b1f0c7a766596003c62}{Is\+Point\+To\+Point} (void) const 
\begin{DoxyCompactList}\small\item\em Return true if the net device is on a point-\/to-\/point link. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a4428541239b21fd0ecf7e589d7f4790e}{Is\+Bridge} (void) const 
\begin{DoxyCompactList}\small\item\em Return true if the net device is acting as a bridge. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_ada683f14699af3f11ce3658f51269668}{Send} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, const \hyperlink{classns3_1_1Address}{Address} \&dest, uint16\+\_\+t protocol\+Number)
\item 
virtual bool \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_ad696726590d7076bdc25969146a980cd}{Send\+From} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, const \hyperlink{classns3_1_1Address}{Address} \&source, const \hyperlink{classns3_1_1Address}{Address} \&dest, uint16\+\_\+t protocol\+Number)
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a5d75e13faa3c9372a9327afa26fc033b}{Get\+Node} (void) const 
\item 
virtual void \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a620ee1fbb3418d31d780c8f3b4ed1c48}{Set\+Node} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node)
\item 
virtual bool \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a6dd45426f632383955f5fa0dfec1a236}{Needs\+Arp} (void) const 
\item 
virtual void \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a16cb2bab4a182be8edc3654423df3a4a}{Set\+Receive\+Callback} (\hyperlink{classns3_1_1NetDevice_ad5e5e1ca187472bc2ba99575d8def568}{Net\+Device\+::\+Receive\+Callback} cb)
\item 
virtual void \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_aa478c75ffe8f6e20bc50187aa7c584cd}{Set\+Promisc\+Receive\+Callback} (\hyperlink{classns3_1_1NetDevice_a427225795919f26c414bee2ea3f31ed2}{Net\+Device\+::\+Promisc\+Receive\+Callback} cb)
\item 
virtual bool \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_abfebbe48743d45631308dc11d45bb6f4}{Supports\+Send\+From} () const 
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a716719d59dbef8d0c1d67e24f566e97d}{Get\+Multicast} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} addr) const 
\begin{DoxyCompactList}\small\item\em Get the M\+AC multicast address corresponding to the I\+Pv6 address provided. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a8ff59624a100b3e8ed151abd5608eae3}{Get\+Type\+Id} (void)
\end{DoxyCompactItemize}
\begin{Indent}{\bf Descriptive Data}\par
{\em \hyperlink{classns3_1_1OpenFlowSwitchNetDevice}{Open\+Flow\+Switch\+Net\+Device} Description Data

These four data describe the \hyperlink{classns3_1_1OpenFlowSwitchNetDevice}{Open\+Flow\+Switch\+Net\+Device} as if it were a real Open\+Flow switch.

There is a type of stats request that Open\+Flow switches are supposed to handle that returns the description of the Open\+Flow switch. Currently manufactured by \char`\"{}\+The ns-\/3 team\char`\"{}, software description is \char`\"{}\+Simulated
\+Open\+Flow Switch\char`\"{}, and the other two are \char`\"{}\+N/\+A\char`\"{}. }\begin{DoxyCompactItemize}
\item 
static const char $\ast$ \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a638da8e6857627b2c0906a7deca75898}{Get\+Manufacturer\+Description} ()
\item 
static const char $\ast$ \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a7dabcd6f04c8c075e24d29035b212495}{Get\+Hardware\+Description} ()
\item 
static const char $\ast$ \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a5ab9d00840f1d3eef81df4b6dce3e04c}{Get\+Software\+Description} ()
\item 
static const char $\ast$ \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a34af530cb2bc951796dcb3c586685538}{Get\+Serial\+Number} ()
\end{DoxyCompactItemize}
\end{Indent}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a7507624a03f7c74b5b7989892fe11113}{Do\+Dispose} (void)
\item 
void \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a3f48603d679c0f7c1ffe43bf4140fce2}{Receive\+From\+Device} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ netdev, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, uint16\+\_\+t protocol, const \hyperlink{classns3_1_1Address}{Address} \&src, const \hyperlink{classns3_1_1Address}{Address} \&dst, \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2}{Packet\+Type} packet\+Type)
\item 
ofpbuf $\ast$ \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a48ab0d1c8b3ae135f012ebe6b4d935a4}{Buffer\+From\+Packet} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Address}{Address} src, \hyperlink{classns3_1_1Address}{Address} dst, int mtu, uint16\+\_\+t protocol)
\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
typedef std\+::map$<$ uint32\+\_\+t, \hyperlink{structns3_1_1ofi_1_1SwitchPacketMetadata}{ofi\+::\+Switch\+Packet\+Metadata} $>$ \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_aa060d5a2f51e59a59ca58bbc08c0d524}{Packet\+Data\+\_\+t}
\item 
typedef std\+::vector$<$ \hyperlink{structns3_1_1ofi_1_1Port}{ofi\+::\+Port} $>$ \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_ae1b61b1f99b795b70b1bdf2f8d51d99e}{Ports\+\_\+t}
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_aabaef64af287627f43101399e05f6c88}{Add\+Flow} (const ofp\+\_\+flow\+\_\+mod $\ast$ofm)
\item 
int \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a43202e5e95605e3cf8002fdeb5533dd6}{Mod\+Flow} (const ofp\+\_\+flow\+\_\+mod $\ast$ofm)
\item 
int \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_acdb8beff0a4c62b1bf9367adf8fbcd22}{Output\+All} (uint32\+\_\+t packet\+\_\+uid, int in\+\_\+port, bool flood)
\item 
void \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a8c1bc70a75d5e0552a6102d3d03ad7d0}{Output\+Packet} (uint32\+\_\+t packet\+\_\+uid, int out\+\_\+port)
\item 
void \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a8a28ed9cc94a54077fa3e23c55d975c7}{Output\+Port} (uint32\+\_\+t packet\+\_\+uid, int in\+\_\+port, int out\+\_\+port, bool ignore\+\_\+no\+\_\+fwd)
\item 
void \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a00821a76c4a946368ac4a6053cc538e2}{Output\+Control} (uint32\+\_\+t packet\+\_\+uid, int in\+\_\+port, size\+\_\+t max\+\_\+len, int reason)
\item 
void \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a8a511cf5cf8b5f00dea8ac2d7f14f091}{Send\+Error\+Msg} (uint16\+\_\+t \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type}, uint16\+\_\+t code, const void $\ast$\hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data}, size\+\_\+t len)
\item 
void \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a4f85126d582b80926f755d70f328a254}{Send\+Features\+Reply} ()
\item 
void \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a3af4a49e4a3897b107b7bac09cb1ae16}{Send\+Flow\+Expired} (sw\+\_\+flow $\ast$flow, enum ofp\+\_\+flow\+\_\+expired\+\_\+reason reason)
\item 
void \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a3111ef7ec072cf59ddabe3a7c3e89e67}{Send\+Port\+Status} (\hyperlink{structns3_1_1ofi_1_1Port}{ofi\+::\+Port} \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, uint8\+\_\+t status)
\item 
void \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a51d89daf86d957758b761811e26a677a}{Send\+V\+Port\+Table\+Features} ()
\item 
int \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a966a9b3636b35bf55372ee1f77e2ab89}{Send\+Openflow\+Buffer} (ofpbuf $\ast$buffer)
\item 
void \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a3855859a3625d566e4e1f9297d3350a8}{Run\+Through\+Flow\+Table} (uint32\+\_\+t packet\+\_\+uid, int \hyperlink{visualizer-ideas_8txt_a21ff1c530daf8435e00048b7fc2c58e3}{port}, bool send\+\_\+to\+\_\+controller=true)
\item 
int \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_ab8f468f2c29abacad719a6703cf0169c}{Run\+Through\+V\+Port\+Table} (uint32\+\_\+t packet\+\_\+uid, int \hyperlink{visualizer-ideas_8txt_a21ff1c530daf8435e00048b7fc2c58e3}{port}, uint32\+\_\+t vport)
\item 
void \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a679df5c2648b42921feee537d08b99c6}{Flow\+Table\+Lookup} (sw\+\_\+flow\+\_\+key key, ofpbuf $\ast$buffer, uint32\+\_\+t packet\+\_\+uid, int \hyperlink{visualizer-ideas_8txt_a21ff1c530daf8435e00048b7fc2c58e3}{port}, bool send\+\_\+to\+\_\+controller)
\item 
int \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a58d57963f1369e1fa389c6b4ae940033}{Update\+Port\+Status} (\hyperlink{structns3_1_1ofi_1_1Port}{ofi\+::\+Port} \&\hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p})
\item 
void \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_ae37ac2efa897a24c2217a611a9a4f2c6}{Fill\+Port\+Desc} (\hyperlink{structns3_1_1ofi_1_1Port}{ofi\+::\+Port} \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, ofp\+\_\+phy\+\_\+port $\ast$desc)
\item 
void $\ast$ \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a558a8205a94a7eebaf8961b667443d52}{Make\+Openflow\+Reply} (size\+\_\+t openflow\+\_\+len, uint8\+\_\+t \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type}, ofpbuf $\ast$$\ast$bufferp)
\end{DoxyCompactItemize}
\begin{Indent}{\bf Receive Methods}\par
{\em Actions to do when a specific Open\+Flow message/packet is received }\begin{DoxyCompactItemize}
\item 
int \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a09ba9303265d1aacfae6e24013f77462}{Receive\+Features\+Request} (const void $\ast$msg)
\item 
int \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a0d8c5564925fad43196827cb27dc9321}{Receive\+Get\+Config\+Request} (const void $\ast$msg)
\item 
int \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a2adbeaea746d9f030ac533e379eabac6}{Receive\+Set\+Config} (const void $\ast$msg)
\item 
int \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a73352d19efcef02dfda83fa6f0c933ac}{Receive\+Packet\+Out} (const void $\ast$msg)
\item 
int \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_af25cefacfa323041ac1900c7abb06785}{Receive\+Flow} (const void $\ast$msg)
\item 
int \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a745d4c09c59eef1a76f78ee46d7b7b6a}{Receive\+Port\+Mod} (const void $\ast$msg)
\item 
int \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a2927985da87ca33b12ba1a106678aaf0}{Receive\+Stats\+Request} (const void $\ast$oh)
\item 
int \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_aaef615440698c5163df4a4d05346c3e7}{Receive\+Echo\+Request} (const void $\ast$oh)
\item 
int \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_ae67bb4a4cafb05ac74fe99f0b7348f05}{Receive\+Echo\+Reply} (const void $\ast$oh)
\item 
int \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a26b0f3db2e65e2af075ec345b41c79d4}{Receive\+V\+Port\+Mod} (const void $\ast$msg)
\item 
int \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_ae7deaf7a63dd1445422d11e39aaeb18c}{Receive\+V\+Port\+Table\+Features\+Request} (const void $\ast$msg)
\end{DoxyCompactItemize}
\end{Indent}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1NetDevice_ad5e5e1ca187472bc2ba99575d8def568}{Net\+Device\+::\+Receive\+Callback} \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_ac6ed70a909dccd5edd66088d4560b89a}{m\+\_\+rx\+Callback}
\begin{DoxyCompactList}\small\item\em Callbacks. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1NetDevice_a427225795919f26c414bee2ea3f31ed2}{Net\+Device\+::\+Promisc\+Receive\+Callback} \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a9acb89d5f22b5e5c9114db32a0bbcbc5}{m\+\_\+promisc\+Rx\+Callback}
\item 
\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a0278390fb81f277dac19d25482ad1bef}{m\+\_\+address}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Address}{Address} of this device. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a0a4333cc4bfb15852c2d9f87e801cbd8}{m\+\_\+node}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Node}{Node} this device is installed on. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1BridgeChannel}{Bridge\+Channel} $>$ \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a2544f1285545cf8e45878277be7b6778}{m\+\_\+channel}
\begin{DoxyCompactList}\small\item\em Collection of port channels into the Switch \hyperlink{classns3_1_1Channel}{Channel}. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_ad8be8954209401de3b29c6e4da106b89}{m\+\_\+if\+Index}
\begin{DoxyCompactList}\small\item\em Interface Index. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a32d177d10cd1c5a266db9f4014cd7384}{m\+\_\+mtu}
\begin{DoxyCompactList}\small\item\em Maximum Transmission Unit. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1OpenFlowSwitchNetDevice_aa060d5a2f51e59a59ca58bbc08c0d524}{Packet\+Data\+\_\+t} \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a7e0e79f1cdc4d37c13fc53c2ff8506b3}{m\+\_\+packet\+Data}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Packet}{Packet} data. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1OpenFlowSwitchNetDevice_ae1b61b1f99b795b70b1bdf2f8d51d99e}{Ports\+\_\+t} \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a5262a28722c2342816dfda05744dcfd2}{m\+\_\+ports}
\begin{DoxyCompactList}\small\item\em Switch\textquotesingle{}s ports. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1ofi_1_1Controller}{ofi\+::\+Controller} $>$ \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_adbded8b966a707ca33bb225b33809e49}{m\+\_\+controller}
\begin{DoxyCompactList}\small\item\em Connection to controller. \end{DoxyCompactList}\item 
uint64\+\_\+t \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a0af690c63ccd5d84b4abd671213086b2}{m\+\_\+id}
\begin{DoxyCompactList}\small\item\em Unique identifier for this switch, needed for Open\+Flow. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_aa408b593e982502e0939dba57aa4c907}{m\+\_\+lookup\+Delay}
\begin{DoxyCompactList}\small\item\em Flow Table Lookup Delay \mbox{[}overhead\mbox{]}. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a53db2fcee324af42c9d7364c76708423}{m\+\_\+last\+Execute}
\begin{DoxyCompactList}\small\item\em Last time the periodic execution occurred. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a5bce0e985237e957abf794d3dd6416be}{m\+\_\+flags}
\begin{DoxyCompactList}\small\item\em Flags; configurable by the controller. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a7437e1b44dc68e7f7f2efc1fabae7fdd}{m\+\_\+miss\+Send\+Len}
\begin{DoxyCompactList}\small\item\em Flow Table Miss Send Length; configurable by the controller. \end{DoxyCompactList}\item 
sw\+\_\+chain $\ast$ \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_aebd93d8b1a9c5c52077e02487953cfe4}{m\+\_\+chain}
\begin{DoxyCompactList}\small\item\em Flow Table; forwarding rules. \end{DoxyCompactList}\item 
vport\+\_\+table\+\_\+t \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a454c503adcde4d4636a36bbd2ee37855}{m\+\_\+vport\+Table}
\begin{DoxyCompactList}\small\item\em Virtual Port Table. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
A net device that switches multiple L\+AN segments via an Open\+Flow-\/compatible flow table. 

The \hyperlink{classns3_1_1OpenFlowSwitchNetDevice}{Open\+Flow\+Switch\+Net\+Device} object aggregates multiple netdevices as ports and acts like a switch. It implements Open\+Flow-\/compatibility, according to the Open\+Flow Switch Specification v0.\+8.\+9 $<$www.\+openflowswitch.\+org/documents/openflow-\/spec-\/v0.8.\+9.\+pdf$>$. It implements a flow table that all received packets are run through. It implements a connection to a controller via a subclass of the Controller class, which can send messages to manipulate the flow table, thereby manipulating how the Open\+Flow switch behaves.

There are two controllers available in the original package. Drop\+Controller builds a flow for each received packet to drop all packets it matches (this demonstrates the flow table\textquotesingle{}s basic implementation), and the Learning\+Controller implements a \char`\"{}learning switch\char`\"{} algorithm (see 802.\+1D), where incoming unicast frames from one port may occasionally be forwarded throughout all other ports, but usually they are forwarded only to a single correct output port.

\begin{DoxyAttention}{Attention}
The Spanning Tree Protocol part of 802.\+1D is not implemented. Therefore, you have to be careful not to create bridging loops, or else the network will collapse.

Each \hyperlink{classns3_1_1NetDevice}{Net\+Device} used must only be assigned a Mac \hyperlink{classns3_1_1Address}{Address}, adding it to an \hyperlink{classns3_1_1Ipv4}{Ipv4} or \hyperlink{classns3_1_1Ipv6}{Ipv6} layer will cause an error. It also must support a Send\+From call.
\end{DoxyAttention}
A net device that switches multiple L\+AN segments via an Open\+Flow-\/compatible flow table 

\subsection{Member Typedef Documentation}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Packet\+Data\+\_\+t@{Packet\+Data\+\_\+t}}
\index{Packet\+Data\+\_\+t@{Packet\+Data\+\_\+t}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Packet\+Data\+\_\+t}{PacketData_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::map$<$uint32\+\_\+t,{\bf ofi\+::\+Switch\+Packet\+Metadata}$>$ {\bf ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Packet\+Data\+\_\+t}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_aa060d5a2f51e59a59ca58bbc08c0d524}{}\label{classns3_1_1OpenFlowSwitchNetDevice_aa060d5a2f51e59a59ca58bbc08c0d524}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Ports\+\_\+t@{Ports\+\_\+t}}
\index{Ports\+\_\+t@{Ports\+\_\+t}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Ports\+\_\+t}{Ports_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::vector$<${\bf ofi\+::\+Port}$>$ {\bf ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Ports\+\_\+t}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_ae1b61b1f99b795b70b1bdf2f8d51d99e}{}\label{classns3_1_1OpenFlowSwitchNetDevice_ae1b61b1f99b795b70b1bdf2f8d51d99e}


\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Open\+Flow\+Switch\+Net\+Device@{Open\+Flow\+Switch\+Net\+Device}}
\index{Open\+Flow\+Switch\+Net\+Device@{Open\+Flow\+Switch\+Net\+Device}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Open\+Flow\+Switch\+Net\+Device()}{OpenFlowSwitchNetDevice()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Open\+Flow\+Switch\+Net\+Device (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a11e21c621ed1fc60bf76a592cb680d3f}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a11e21c621ed1fc60bf76a592cb680d3f}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!````~Open\+Flow\+Switch\+Net\+Device@{$\sim$\+Open\+Flow\+Switch\+Net\+Device}}
\index{````~Open\+Flow\+Switch\+Net\+Device@{$\sim$\+Open\+Flow\+Switch\+Net\+Device}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{$\sim$\+Open\+Flow\+Switch\+Net\+Device()}{~OpenFlowSwitchNetDevice()}}]{\setlength{\rightskip}{0pt plus 5cm}virtual ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::$\sim$\+Open\+Flow\+Switch\+Net\+Device (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_afea7b099a698e5ff80d2ac177cae69bf}{}\label{classns3_1_1OpenFlowSwitchNetDevice_afea7b099a698e5ff80d2ac177cae69bf}


\subsection{Member Function Documentation}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Add\+Flow@{Add\+Flow}}
\index{Add\+Flow@{Add\+Flow}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Add\+Flow(const ofp\+\_\+flow\+\_\+mod $\ast$ofm)}{AddFlow(const ofp_flow_mod *ofm)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Add\+Flow (
\begin{DoxyParamCaption}
\item[{const ofp\+\_\+flow\+\_\+mod $\ast$}]{ofm}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_aabaef64af287627f43101399e05f6c88}{}\label{classns3_1_1OpenFlowSwitchNetDevice_aabaef64af287627f43101399e05f6c88}
Add a flow.

\begin{DoxySeeAlso}{See also}
\#\+E\+N\+O\+M\+EM, \#\+E\+N\+O\+B\+U\+FS, \#\+E\+S\+R\+CH
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em ofm} & The flow data to add. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if everything\textquotesingle{}s ok, otherwise an error number. 
\end{DoxyReturn}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Add\+Link\+Change\+Callback@{Add\+Link\+Change\+Callback}}
\index{Add\+Link\+Change\+Callback@{Add\+Link\+Change\+Callback}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Add\+Link\+Change\+Callback(\+Callback$<$ void $>$ callback)}{AddLinkChangeCallback(Callback< void > callback)}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Add\+Link\+Change\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Callback}$<$ void $>$}]{callback}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a3628df1997b920ab5542130c234f9108}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a3628df1997b920ab5542130c234f9108}

\begin{DoxyParams}{Parameters}
{\em callback} & the callback to invoke\\
\hline
\end{DoxyParams}
Add a callback invoked whenever the link status changes to UP. This callback is typically used by the I\+P/\+A\+RP layer to flush the A\+RP cache and by I\+Pv6 stack to flush N\+D\+I\+SC cache whenever the link goes up. 

Implements \hyperlink{classns3_1_1NetDevice_aafb1bf869d38ef7a7112d11fab0163a3}{ns3\+::\+Net\+Device}.

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Add\+Switch\+Port@{Add\+Switch\+Port}}
\index{Add\+Switch\+Port@{Add\+Switch\+Port}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Add\+Switch\+Port(\+Ptr$<$ Net\+Device $>$ switch\+Port)}{AddSwitchPort(Ptr< NetDevice > switchPort)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Add\+Switch\+Port (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{switch\+Port}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a917303759eded2d67d5d7807551d3d3a}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a917303759eded2d67d5d7807551d3d3a}


Add a \textquotesingle{}port\textquotesingle{} to a switch device. 

This method adds a new switch port to a \hyperlink{classns3_1_1OpenFlowSwitchNetDevice}{Open\+Flow\+Switch\+Net\+Device}, so that the new switch port \hyperlink{classns3_1_1NetDevice}{Net\+Device} becomes part of the switch and L2 frames start being forwarded to/from this \hyperlink{classns3_1_1NetDevice}{Net\+Device}.

\begin{DoxyNote}{Note}
The netdevice that is being added as switch port must {\itshape not} have an IP address. In order to add IP connectivity to a bridging node you must enable IP on the \hyperlink{classns3_1_1OpenFlowSwitchNetDevice}{Open\+Flow\+Switch\+Net\+Device} itself, never on its port netdevices.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em switch\+Port} & The port to add. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if everything\textquotesingle{}s ok, otherwise an error number. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\#\+E\+X\+F\+U\+LL 
\end{DoxySeeAlso}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Add\+V\+Port@{Add\+V\+Port}}
\index{Add\+V\+Port@{Add\+V\+Port}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Add\+V\+Port(const ofp\+\_\+vport\+\_\+mod $\ast$ovpm)}{AddVPort(const ofp_vport_mod *ovpm)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Add\+V\+Port (
\begin{DoxyParamCaption}
\item[{const ofp\+\_\+vport\+\_\+mod $\ast$}]{ovpm}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_ad080768a6e246533386d1703e86d38e6}{}\label{classns3_1_1OpenFlowSwitchNetDevice_ad080768a6e246533386d1703e86d38e6}


Add a virtual port to a switch device. 

The Ericsson O\+F\+S\+ID has the concept of virtual ports and virtual port tables. These are implemented in the \hyperlink{classns3_1_1OpenFlowSwitchNetDevice}{Open\+Flow\+Switch\+Net\+Device}, but don\textquotesingle{}t have an understood use \mbox{[}perhaps it may have to do with M\+P\+LS integration\mbox{]}.

\begin{DoxySeeAlso}{See also}
\#\+E\+I\+N\+V\+AL
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em ovpm} & The data for adding a virtual port. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if everything\textquotesingle{}s ok, otherwise an error number. 
\end{DoxyReturn}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Buffer\+From\+Packet@{Buffer\+From\+Packet}}
\index{Buffer\+From\+Packet@{Buffer\+From\+Packet}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Buffer\+From\+Packet(\+Ptr$<$ const Packet $>$ packet, Address src, Address dst, int mtu, uint16\+\_\+t protocol)}{BufferFromPacket(Ptr< const Packet > packet, Address src, Address dst, int mtu, uint16_t protocol)}}]{\setlength{\rightskip}{0pt plus 5cm}ofpbuf$\ast$ ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Buffer\+From\+Packet (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{packet, }
\item[{{\bf Address}}]{src, }
\item[{{\bf Address}}]{dst, }
\item[{int}]{mtu, }
\item[{uint16\+\_\+t}]{protocol}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a48ab0d1c8b3ae135f012ebe6b4d935a4}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a48ab0d1c8b3ae135f012ebe6b4d935a4}
Takes a packet and generates an Open\+Flow buffer from it, loading the packet data as well as its headers.


\begin{DoxyParams}{Parameters}
{\em packet} & The packet. \\
\hline
{\em src} & The source address. \\
\hline
{\em dst} & The destination address. \\
\hline
{\em mtu} & The Maximum Transmission Unit. \\
\hline
{\em protocol} & The protocol defining the packet. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Open\+Flow \hyperlink{classns3_1_1Buffer}{Buffer} created from the packet. 
\end{DoxyReturn}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Do\+Dispose(void)}{DoDispose(void)}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a7507624a03f7c74b5b7989892fe11113}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a7507624a03f7c74b5b7989892fe11113}
Destructor implementation.

This method is called by \hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose()} or by the \hyperlink{classns3_1_1Object}{Object}\textquotesingle{}s destructor, whichever comes first.

Subclasses are expected to implement their real destruction code in an overriden version of this method and chain up to their parent\textquotesingle{}s implementation once they are done. {\itshape i.\+e}, for simplicity, the destructor of every subclass should be empty and its content should be moved to the associated \hyperlink{classns3_1_1OpenFlowSwitchNetDevice_a7507624a03f7c74b5b7989892fe11113}{Do\+Dispose()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Do\+Output@{Do\+Output}}
\index{Do\+Output@{Do\+Output}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Do\+Output(uint32\+\_\+t packet\+\_\+uid, int in\+\_\+port, size\+\_\+t max\+\_\+len, int out\+\_\+port, bool ignore\+\_\+no\+\_\+fwd)}{DoOutput(uint32_t packet_uid, int in_port, size_t max_len, int out_port, bool ignore_no_fwd)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Do\+Output (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{packet\+\_\+uid, }
\item[{int}]{in\+\_\+port, }
\item[{size\+\_\+t}]{max\+\_\+len, }
\item[{int}]{out\+\_\+port, }
\item[{bool}]{ignore\+\_\+no\+\_\+fwd}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a32ddf4836b4975a83cbf5e556a890c48}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a32ddf4836b4975a83cbf5e556a890c48}


Called from the Open\+Flow Interface to output the \hyperlink{classns3_1_1Packet}{Packet} on either a Port or the Controller. 


\begin{DoxyParams}{Parameters}
{\em packet\+\_\+uid} & \hyperlink{classns3_1_1Packet}{Packet} U\+ID; used to fetch the packet and its metadata. \\
\hline
{\em in\+\_\+port} & The index of the port the \hyperlink{classns3_1_1Packet}{Packet} was initially received on. \\
\hline
{\em max\+\_\+len} & The maximum number of bytes the caller wants to be sent; a value of 0 indicates the entire packet should be sent. Used when outputting to controller. \\
\hline
{\em out\+\_\+port} & The port we want to output on. \\
\hline
{\em ignore\+\_\+no\+\_\+fwd} & If true, Ports that are set to not forward are forced to forward. \\
\hline
\end{DoxyParams}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Fill\+Port\+Desc@{Fill\+Port\+Desc}}
\index{Fill\+Port\+Desc@{Fill\+Port\+Desc}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Fill\+Port\+Desc(ofi\+::\+Port p, ofp\+\_\+phy\+\_\+port $\ast$desc)}{FillPortDesc(ofi::Port p, ofp_phy_port *desc)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Fill\+Port\+Desc (
\begin{DoxyParamCaption}
\item[{{\bf ofi\+::\+Port}}]{p, }
\item[{ofp\+\_\+phy\+\_\+port $\ast$}]{desc}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_ae37ac2efa897a24c2217a611a9a4f2c6}{}\label{classns3_1_1OpenFlowSwitchNetDevice_ae37ac2efa897a24c2217a611a9a4f2c6}
Fill out a description of the switch port.


\begin{DoxyParams}{Parameters}
{\em p} & The port to get the description from. \\
\hline
{\em desc} & A pointer to the description message; used to fill the description message with the data from the port. \\
\hline
\end{DoxyParams}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Flow\+Table\+Lookup@{Flow\+Table\+Lookup}}
\index{Flow\+Table\+Lookup@{Flow\+Table\+Lookup}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Flow\+Table\+Lookup(sw\+\_\+flow\+\_\+key key, ofpbuf $\ast$buffer, uint32\+\_\+t packet\+\_\+uid, int port, bool send\+\_\+to\+\_\+controller)}{FlowTableLookup(sw_flow_key key, ofpbuf *buffer, uint32_t packet_uid, int port, bool send_to_controller)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Flow\+Table\+Lookup (
\begin{DoxyParamCaption}
\item[{sw\+\_\+flow\+\_\+key}]{key, }
\item[{ofpbuf $\ast$}]{buffer, }
\item[{uint32\+\_\+t}]{packet\+\_\+uid, }
\item[{int}]{port, }
\item[{bool}]{send\+\_\+to\+\_\+controller}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a679df5c2648b42921feee537d08b99c6}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a679df5c2648b42921feee537d08b99c6}
Called by Run\+Through\+Flow\+Table on a scheduled delay to account for the flow table lookup overhead.


\begin{DoxyParams}{Parameters}
{\em key} & Matching key to look up in the flow table. \\
\hline
{\em buffer} & \hyperlink{classns3_1_1Buffer}{Buffer} of the packet received. \\
\hline
{\em packet\+\_\+uid} & \hyperlink{classns3_1_1Packet}{Packet} U\+ID; used to fetch the packet and its metadata. \\
\hline
{\em port} & The port the packet was received over. \\
\hline
{\em send\+\_\+to\+\_\+controller} & \\
\hline
\end{DoxyParams}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Forward\+Control\+Input@{Forward\+Control\+Input}}
\index{Forward\+Control\+Input@{Forward\+Control\+Input}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Forward\+Control\+Input(const void $\ast$msg, size\+\_\+t length)}{ForwardControlInput(const void *msg, size_t length)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Forward\+Control\+Input (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{msg, }
\item[{size\+\_\+t}]{length}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a5442bdd0d556024442b1c4af38a41df8}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a5442bdd0d556024442b1c4af38a41df8}


The registered controller calls this method when sending a message to the switch. 


\begin{DoxyParams}{Parameters}
{\em msg} & The message received from the controller. \\
\hline
{\em length} & Length of the message. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if everything\textquotesingle{}s ok, otherwise an error number. 
\end{DoxyReturn}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Get\+Address@{Get\+Address}}
\index{Get\+Address@{Get\+Address}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Address(void) const }{GetAddress(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Address} ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Get\+Address (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a9ace12c079dd551ea876bc503599c4b4}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a9ace12c079dd551ea876bc503599c4b4}
\begin{DoxyReturn}{Returns}
the current \hyperlink{classns3_1_1Address}{Address} of this interface. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a671f99de496d6f09ae343bb715301fb2}{ns3\+::\+Net\+Device}.

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Get\+Broadcast@{Get\+Broadcast}}
\index{Get\+Broadcast@{Get\+Broadcast}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Broadcast(void) const }{GetBroadcast(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Address} ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Get\+Broadcast (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_ac537d6ccd1e8a4083f846d669170ea79}{}\label{classns3_1_1OpenFlowSwitchNetDevice_ac537d6ccd1e8a4083f846d669170ea79}
\begin{DoxyReturn}{Returns}
the broadcast address supported by this netdevice.
\end{DoxyReturn}
Calling this method is invalid if Is\+Broadcast returns not true. 

Implements \hyperlink{classns3_1_1NetDevice_a4724e03bc548dd8e967cc4a7356197bd}{ns3\+::\+Net\+Device}.

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Get\+Chain@{Get\+Chain}}
\index{Get\+Chain@{Get\+Chain}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Chain()}{GetChain()}}]{\setlength{\rightskip}{0pt plus 5cm}sw\+\_\+chain$\ast$ ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Get\+Chain (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a27901b0defa5457880dc4106826997e7}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a27901b0defa5457880dc4106826997e7}
\begin{DoxyReturn}{Returns}
The flow table chain. 
\end{DoxyReturn}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Get\+Channel@{Get\+Channel}}
\index{Get\+Channel@{Get\+Channel}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Channel(void) const }{GetChannel(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Ptr}$<${\bf Channel}$>$ ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Get\+Channel (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a552c53c7d29d80cb0469df8a7c546eb2}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a552c53c7d29d80cb0469df8a7c546eb2}
\begin{DoxyReturn}{Returns}
the channel this \hyperlink{classns3_1_1NetDevice}{Net\+Device} is connected to. The value returned can be zero if the \hyperlink{classns3_1_1NetDevice}{Net\+Device} is not yet connected to any channel or if the underlying \hyperlink{classns3_1_1NetDevice}{Net\+Device} has no concept of a channel. i.\+e., callers {\itshape must} check for zero and be ready to handle it. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a3d810bd2738634e2e851661271828565}{ns3\+::\+Net\+Device}.

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Get\+Hardware\+Description@{Get\+Hardware\+Description}}
\index{Get\+Hardware\+Description@{Get\+Hardware\+Description}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Hardware\+Description()}{GetHardwareDescription()}}]{\setlength{\rightskip}{0pt plus 5cm}static const char$\ast$ ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Get\+Hardware\+Description (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a7dabcd6f04c8c075e24d29035b212495}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a7dabcd6f04c8c075e24d29035b212495}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Get\+If\+Index@{Get\+If\+Index}}
\index{Get\+If\+Index@{Get\+If\+Index}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+If\+Index(void) const }{GetIfIndex(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}virtual uint32\+\_\+t ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Get\+If\+Index (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_aaf611feb833d73a226d3028345a70bc2}{}\label{classns3_1_1OpenFlowSwitchNetDevice_aaf611feb833d73a226d3028345a70bc2}
\begin{DoxyReturn}{Returns}
index if\+Index of the device 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a8c1ae2ec8eadc4524dfc1e425bfa0850}{ns3\+::\+Net\+Device}.

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Get\+Manufacturer\+Description@{Get\+Manufacturer\+Description}}
\index{Get\+Manufacturer\+Description@{Get\+Manufacturer\+Description}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Manufacturer\+Description()}{GetManufacturerDescription()}}]{\setlength{\rightskip}{0pt plus 5cm}static const char$\ast$ ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Get\+Manufacturer\+Description (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a638da8e6857627b2c0906a7deca75898}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a638da8e6857627b2c0906a7deca75898}
\begin{DoxyReturn}{Returns}
The descriptive string. 
\end{DoxyReturn}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Get\+Mtu@{Get\+Mtu}}
\index{Get\+Mtu@{Get\+Mtu}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Mtu(void) const }{GetMtu(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}virtual uint16\+\_\+t ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Get\+Mtu (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a2e153f7ee4b6d93661f90784edf44116}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a2e153f7ee4b6d93661f90784edf44116}
\begin{DoxyReturn}{Returns}
the link-\/level M\+TU in bytes for this interface.
\end{DoxyReturn}
This value is typically used by the IP layer to perform IP fragmentation when needed. 

Implements \hyperlink{classns3_1_1NetDevice_a91f4f5d01bc2d567c1e0a69b63a4cf14}{ns3\+::\+Net\+Device}.

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Get\+Multicast@{Get\+Multicast}}
\index{Get\+Multicast@{Get\+Multicast}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Multicast(\+Ipv4\+Address multicast\+Group) const }{GetMulticast(Ipv4Address multicastGroup) const }}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Address} ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Get\+Multicast (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{multicast\+Group}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a4eea48f6fa1c3a9720ded005f757a4cd}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a4eea48f6fa1c3a9720ded005f757a4cd}


Make and return a M\+AC multicast address using the provided multicast group. 

\{1112\} says that an \hyperlink{classns3_1_1Ipv4}{Ipv4} host group address is mapped to an Ethernet multicast address by placing the low-\/order 23-\/bits of the IP address into the low-\/order 23 bits of the Ethernet multicast address 01-\/00-\/5\+E-\/00-\/00-\/00 (hex). Similar R\+F\+Cs exist for \hyperlink{classns3_1_1Ipv6}{Ipv6} and Eui64 mappings. This method performs the multicast address creation function appropriate to the underlying M\+AC address of the device. This M\+AC address is encapsulated in an abstract \hyperlink{classns3_1_1Address}{Address} to avoid dependencies on the exact M\+AC address format.

In the case of net devices that do not support multicast, clients are expected to test \hyperlink{classns3_1_1NetDevice_a1afb4848a9226540f1ff51f9b31ae95e}{Net\+Device\+::\+Is\+Multicast} and avoid attempting to map multicast packets. Subclasses of \hyperlink{classns3_1_1NetDevice}{Net\+Device} that do support multicasting are expected to override this method and provide an implementation appropriate to the particular device.


\begin{DoxyParams}{Parameters}
{\em multicast\+Group} & The IP address for the multicast group destination of the packet. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The M\+AC multicast \hyperlink{classns3_1_1Address}{Address} used to send packets to the provided multicast group.
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Calling this method is invalid if Is\+Multicast returns not true. 
\end{DoxyWarning}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1OpenFlowSwitchNetDevice_aed07e20f6dede271e91c1eb727bb583e}{Is\+Multicast()} 
\end{DoxySeeAlso}


Implements \hyperlink{classns3_1_1NetDevice_a98aa4852df367b6a393c8cc1d88af0d9}{ns3\+::\+Net\+Device}.

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Get\+Multicast@{Get\+Multicast}}
\index{Get\+Multicast@{Get\+Multicast}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Multicast(\+Ipv6\+Address addr) const }{GetMulticast(Ipv6Address addr) const }}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Address} ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Get\+Multicast (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{addr}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a716719d59dbef8d0c1d67e24f566e97d}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a716719d59dbef8d0c1d67e24f566e97d}


Get the M\+AC multicast address corresponding to the I\+Pv6 address provided. 


\begin{DoxyParams}{Parameters}
{\em addr} & I\+Pv6 address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the M\+AC multicast address 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Calling this method is invalid if Is\+Multicast returns not true. 
\end{DoxyWarning}


Implements \hyperlink{classns3_1_1NetDevice_a46479a2c0101c6f9da9251ed4d7575bd}{ns3\+::\+Net\+Device}.

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Get\+Node@{Get\+Node}}
\index{Get\+Node@{Get\+Node}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Node(void) const }{GetNode(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Ptr}$<${\bf Node}$>$ ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Get\+Node (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a5d75e13faa3c9372a9327afa26fc033b}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a5d75e13faa3c9372a9327afa26fc033b}
\begin{DoxyReturn}{Returns}
the node base class which contains this network interface.
\end{DoxyReturn}
When a subclass needs to get access to the underlying node base class to print the nodeid for example, it can invoke this method. 

Implements \hyperlink{classns3_1_1NetDevice_a098b6cc4339ac00c62e75cfa48c8aeac}{ns3\+::\+Net\+Device}.

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Get\+N\+Switch\+Ports@{Get\+N\+Switch\+Ports}}
\index{Get\+N\+Switch\+Ports@{Get\+N\+Switch\+Ports}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+N\+Switch\+Ports(void) const }{GetNSwitchPorts(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Get\+N\+Switch\+Ports (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a60a99198a982f9c0a75d21ba468d9c42}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a60a99198a982f9c0a75d21ba468d9c42}
\begin{DoxyReturn}{Returns}
Number of switch ports attached to this switch. 
\end{DoxyReturn}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Get\+Serial\+Number@{Get\+Serial\+Number}}
\index{Get\+Serial\+Number@{Get\+Serial\+Number}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Serial\+Number()}{GetSerialNumber()}}]{\setlength{\rightskip}{0pt plus 5cm}static const char$\ast$ ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Get\+Serial\+Number (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a34af530cb2bc951796dcb3c586685538}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a34af530cb2bc951796dcb3c586685538}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Get\+Software\+Description@{Get\+Software\+Description}}
\index{Get\+Software\+Description@{Get\+Software\+Description}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Software\+Description()}{GetSoftwareDescription()}}]{\setlength{\rightskip}{0pt plus 5cm}static const char$\ast$ ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Get\+Software\+Description (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a5ab9d00840f1d3eef81df4b6dce3e04c}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a5ab9d00840f1d3eef81df4b6dce3e04c}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Get\+Switch\+Port@{Get\+Switch\+Port}}
\index{Get\+Switch\+Port@{Get\+Switch\+Port}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Switch\+Port(uint32\+\_\+t n) const }{GetSwitchPort(uint32_t n) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ofi\+::\+Port} ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Get\+Switch\+Port (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{n}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_aa797150f34f80e22a2443043bf930728}{}\label{classns3_1_1OpenFlowSwitchNetDevice_aa797150f34f80e22a2443043bf930728}

\begin{DoxyParams}{Parameters}
{\em n} & index of the Port. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Port. 
\end{DoxyReturn}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Get\+Switch\+Port\+Index@{Get\+Switch\+Port\+Index}}
\index{Get\+Switch\+Port\+Index@{Get\+Switch\+Port\+Index}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Switch\+Port\+Index(ofi\+::\+Port p)}{GetSwitchPortIndex(ofi::Port p)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Get\+Switch\+Port\+Index (
\begin{DoxyParamCaption}
\item[{{\bf ofi\+::\+Port}}]{p}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_afc0283b966814417b89981940f3c5b51}{}\label{classns3_1_1OpenFlowSwitchNetDevice_afc0283b966814417b89981940f3c5b51}

\begin{DoxyParams}{Parameters}
{\em p} & The Port to get the index of. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The index of the provided Port. 
\end{DoxyReturn}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf Type\+Id} ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a8ff59624a100b3e8ed151abd5608eae3}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a8ff59624a100b3e8ed151abd5608eae3}
Register this type. \begin{DoxyReturn}{Returns}
The \hyperlink{classns3_1_1TypeId}{Type\+Id}. 
\end{DoxyReturn}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Get\+V\+Port\+Table@{Get\+V\+Port\+Table}}
\index{Get\+V\+Port\+Table@{Get\+V\+Port\+Table}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+V\+Port\+Table()}{GetVPortTable()}}]{\setlength{\rightskip}{0pt plus 5cm}vport\+\_\+table\+\_\+t ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Get\+V\+Port\+Table (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a87ba400a91415ed84d9a1f82b08fff43}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a87ba400a91415ed84d9a1f82b08fff43}
\begin{DoxyReturn}{Returns}
The virtual port table. 
\end{DoxyReturn}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Is\+Bridge@{Is\+Bridge}}
\index{Is\+Bridge@{Is\+Bridge}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Bridge(void) const }{IsBridge(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Is\+Bridge (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a4428541239b21fd0ecf7e589d7f4790e}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a4428541239b21fd0ecf7e589d7f4790e}


Return true if the net device is acting as a bridge. 

\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Bridge flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a9d34556a1c83a69dacb08698ca4a1d94}{ns3\+::\+Net\+Device}.

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Is\+Broadcast@{Is\+Broadcast}}
\index{Is\+Broadcast@{Is\+Broadcast}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Broadcast(void) const }{IsBroadcast(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Is\+Broadcast (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_af5e13232837763f5978b2ff93697b7fe}{}\label{classns3_1_1OpenFlowSwitchNetDevice_af5e13232837763f5978b2ff93697b7fe}
\begin{DoxyReturn}{Returns}
true if this interface supports a broadcast address, false otherwise. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a67f992b20858cd7b397d8fba2feff141}{ns3\+::\+Net\+Device}.

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Is\+Link\+Up@{Is\+Link\+Up}}
\index{Is\+Link\+Up@{Is\+Link\+Up}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Link\+Up(void) const }{IsLinkUp(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Is\+Link\+Up (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_aa96fe55aa7b2bea65974cbb5cd51161c}{}\label{classns3_1_1OpenFlowSwitchNetDevice_aa96fe55aa7b2bea65974cbb5cd51161c}
\begin{DoxyReturn}{Returns}
true if link is up; false otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_afe1822b79e19a05ab95f693c8fb64fc7}{ns3\+::\+Net\+Device}.

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Is\+Multicast@{Is\+Multicast}}
\index{Is\+Multicast@{Is\+Multicast}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Multicast(void) const }{IsMulticast(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Is\+Multicast (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_aed07e20f6dede271e91c1eb727bb583e}{}\label{classns3_1_1OpenFlowSwitchNetDevice_aed07e20f6dede271e91c1eb727bb583e}
\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Multicast flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a1afb4848a9226540f1ff51f9b31ae95e}{ns3\+::\+Net\+Device}.

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Is\+Point\+To\+Point@{Is\+Point\+To\+Point}}
\index{Is\+Point\+To\+Point@{Is\+Point\+To\+Point}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Point\+To\+Point(void) const }{IsPointToPoint(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Is\+Point\+To\+Point (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a467062edd9bb5b1f0c7a766596003c62}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a467062edd9bb5b1f0c7a766596003c62}


Return true if the net device is on a point-\/to-\/point link. 

\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Point\+To\+Point flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a718177f25efeaf2dbf8a18fcab87224d}{ns3\+::\+Net\+Device}.

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Make\+Openflow\+Reply@{Make\+Openflow\+Reply}}
\index{Make\+Openflow\+Reply@{Make\+Openflow\+Reply}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Make\+Openflow\+Reply(size\+\_\+t openflow\+\_\+len, uint8\+\_\+t type, ofpbuf $\ast$$\ast$bufferp)}{MakeOpenflowReply(size_t openflow_len, uint8_t type, ofpbuf **bufferp)}}]{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Make\+Openflow\+Reply (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{openflow\+\_\+len, }
\item[{uint8\+\_\+t}]{type, }
\item[{ofpbuf $\ast$$\ast$}]{bufferp}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a558a8205a94a7eebaf8961b667443d52}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a558a8205a94a7eebaf8961b667443d52}
Generates an Open\+Flow reply message based on the type.


\begin{DoxyParams}{Parameters}
{\em openflow\+\_\+len} & Length of the reply to make. \\
\hline
{\em type} & Type of reply message to make. \\
\hline
{\em bufferp} & Message buffer; used to make the reply. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Open\+Flow reply message. 
\end{DoxyReturn}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Mod\+Flow@{Mod\+Flow}}
\index{Mod\+Flow@{Mod\+Flow}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Mod\+Flow(const ofp\+\_\+flow\+\_\+mod $\ast$ofm)}{ModFlow(const ofp_flow_mod *ofm)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Mod\+Flow (
\begin{DoxyParamCaption}
\item[{const ofp\+\_\+flow\+\_\+mod $\ast$}]{ofm}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a43202e5e95605e3cf8002fdeb5533dd6}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a43202e5e95605e3cf8002fdeb5533dd6}
Modify a flow.


\begin{DoxyParams}{Parameters}
{\em ofm} & The flow data to modify. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if everything\textquotesingle{}s ok, otherwise an error number. 
\end{DoxyReturn}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Needs\+Arp@{Needs\+Arp}}
\index{Needs\+Arp@{Needs\+Arp}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Needs\+Arp(void) const }{NeedsArp(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Needs\+Arp (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a6dd45426f632383955f5fa0dfec1a236}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a6dd45426f632383955f5fa0dfec1a236}
\begin{DoxyReturn}{Returns}
true if A\+RP is needed, false otherwise.
\end{DoxyReturn}
Called by higher-\/layers to check if this \hyperlink{classns3_1_1NetDevice}{Net\+Device} requires A\+RP to be used. 

Implements \hyperlink{classns3_1_1NetDevice_ab1a133696310cad3dc2c3d1a4993f310}{ns3\+::\+Net\+Device}.

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Output\+All@{Output\+All}}
\index{Output\+All@{Output\+All}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Output\+All(uint32\+\_\+t packet\+\_\+uid, int in\+\_\+port, bool flood)}{OutputAll(uint32_t packet_uid, int in_port, bool flood)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Output\+All (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{packet\+\_\+uid, }
\item[{int}]{in\+\_\+port, }
\item[{bool}]{flood}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_acdb8beff0a4c62b1bf9367adf8fbcd22}{}\label{classns3_1_1OpenFlowSwitchNetDevice_acdb8beff0a4c62b1bf9367adf8fbcd22}
Send packets out all the ports except the originating one


\begin{DoxyParams}{Parameters}
{\em packet\+\_\+uid} & \hyperlink{classns3_1_1Packet}{Packet} U\+ID; used to fetch the packet and its metadata. \\
\hline
{\em in\+\_\+port} & The index of the port the \hyperlink{classns3_1_1Packet}{Packet} was initially received on. This port doesn\textquotesingle{}t forward when flooding. \\
\hline
{\em flood} & If true, don\textquotesingle{}t send out on the ports with flooding disabled. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if everything\textquotesingle{}s ok, otherwise an error number. 
\end{DoxyReturn}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Output\+Control@{Output\+Control}}
\index{Output\+Control@{Output\+Control}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Output\+Control(uint32\+\_\+t packet\+\_\+uid, int in\+\_\+port, size\+\_\+t max\+\_\+len, int reason)}{OutputControl(uint32_t packet_uid, int in_port, size_t max_len, int reason)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Output\+Control (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{packet\+\_\+uid, }
\item[{int}]{in\+\_\+port, }
\item[{size\+\_\+t}]{max\+\_\+len, }
\item[{int}]{reason}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a00821a76c4a946368ac4a6053cc538e2}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a00821a76c4a946368ac4a6053cc538e2}
Sends a copy of the \hyperlink{classns3_1_1Packet}{Packet} to the controller. If the packet can be saved in an Open\+Flow buffer, then only the first \textquotesingle{}max\+\_\+len\textquotesingle{} bytes of the packet are sent; otherwise, all of the packet is sent.


\begin{DoxyParams}{Parameters}
{\em packet\+\_\+uid} & \hyperlink{classns3_1_1Packet}{Packet} U\+ID; used to fetch the packet and its metadata. \\
\hline
{\em in\+\_\+port} & The index of the port the \hyperlink{classns3_1_1Packet}{Packet} was initially received on. \\
\hline
{\em max\+\_\+len} & The maximum number of bytes that the caller wants to be sent; a value of 0 indicates the entire packet should be sent. \\
\hline
{\em reason} & Why the packet is being sent. \\
\hline
\end{DoxyParams}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Output\+Packet@{Output\+Packet}}
\index{Output\+Packet@{Output\+Packet}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Output\+Packet(uint32\+\_\+t packet\+\_\+uid, int out\+\_\+port)}{OutputPacket(uint32_t packet_uid, int out_port)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Output\+Packet (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{packet\+\_\+uid, }
\item[{int}]{out\+\_\+port}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a8c1bc70a75d5e0552a6102d3d03ad7d0}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a8c1bc70a75d5e0552a6102d3d03ad7d0}
Sends a copy of the \hyperlink{classns3_1_1Packet}{Packet} over the provided output port


\begin{DoxyParams}{Parameters}
{\em packet\+\_\+uid} & \hyperlink{classns3_1_1Packet}{Packet} U\+ID; used to fetch the packet and its metadata. \\
\hline
\end{DoxyParams}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Output\+Port@{Output\+Port}}
\index{Output\+Port@{Output\+Port}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Output\+Port(uint32\+\_\+t packet\+\_\+uid, int in\+\_\+port, int out\+\_\+port, bool ignore\+\_\+no\+\_\+fwd)}{OutputPort(uint32_t packet_uid, int in_port, int out_port, bool ignore_no_fwd)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Output\+Port (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{packet\+\_\+uid, }
\item[{int}]{in\+\_\+port, }
\item[{int}]{out\+\_\+port, }
\item[{bool}]{ignore\+\_\+no\+\_\+fwd}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a8a28ed9cc94a54077fa3e23c55d975c7}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a8a28ed9cc94a54077fa3e23c55d975c7}
Seeks to send out a \hyperlink{classns3_1_1Packet}{Packet} over the provided output port. This is called generically when we may or may not know the specific port we\textquotesingle{}re outputting on. There are many pre-\/set types of port options besides a Port that\textquotesingle{}s hooked to our \hyperlink{classns3_1_1OpenFlowSwitchNetDevice}{Open\+Flow\+Switch\+Net\+Device}. For example, it could be outputting as a flood, or seeking to output to the controller.


\begin{DoxyParams}{Parameters}
{\em packet\+\_\+uid} & \hyperlink{classns3_1_1Packet}{Packet} U\+ID; used to fetch the packet and its metadata. \\
\hline
{\em in\+\_\+port} & The index of the port the \hyperlink{classns3_1_1Packet}{Packet} was initially received on. \\
\hline
{\em out\+\_\+port} & The port we want to output on. \\
\hline
{\em ignore\+\_\+no\+\_\+fwd} & If true, Ports that are set to not forward are forced to forward. \\
\hline
\end{DoxyParams}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Receive\+Echo\+Reply@{Receive\+Echo\+Reply}}
\index{Receive\+Echo\+Reply@{Receive\+Echo\+Reply}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Receive\+Echo\+Reply(const void $\ast$oh)}{ReceiveEchoReply(const void *oh)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Receive\+Echo\+Reply (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{oh}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_ae67bb4a4cafb05ac74fe99f0b7348f05}{}\label{classns3_1_1OpenFlowSwitchNetDevice_ae67bb4a4cafb05ac74fe99f0b7348f05}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Receive\+Echo\+Request@{Receive\+Echo\+Request}}
\index{Receive\+Echo\+Request@{Receive\+Echo\+Request}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Receive\+Echo\+Request(const void $\ast$oh)}{ReceiveEchoRequest(const void *oh)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Receive\+Echo\+Request (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{oh}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_aaef615440698c5163df4a4d05346c3e7}{}\label{classns3_1_1OpenFlowSwitchNetDevice_aaef615440698c5163df4a4d05346c3e7}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Receive\+Features\+Request@{Receive\+Features\+Request}}
\index{Receive\+Features\+Request@{Receive\+Features\+Request}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Receive\+Features\+Request(const void $\ast$msg)}{ReceiveFeaturesRequest(const void *msg)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Receive\+Features\+Request (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{msg}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a09ba9303265d1aacfae6e24013f77462}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a09ba9303265d1aacfae6e24013f77462}

\begin{DoxyParams}{Parameters}
{\em msg} & The Open\+Flow message received. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if everything\textquotesingle{}s ok, otherwise an error number. 
\end{DoxyReturn}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Receive\+Flow@{Receive\+Flow}}
\index{Receive\+Flow@{Receive\+Flow}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Receive\+Flow(const void $\ast$msg)}{ReceiveFlow(const void *msg)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Receive\+Flow (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{msg}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_af25cefacfa323041ac1900c7abb06785}{}\label{classns3_1_1OpenFlowSwitchNetDevice_af25cefacfa323041ac1900c7abb06785}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Receive\+From\+Device@{Receive\+From\+Device}}
\index{Receive\+From\+Device@{Receive\+From\+Device}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Receive\+From\+Device(\+Ptr$<$ Net\+Device $>$ netdev, Ptr$<$ const Packet $>$ packet, uint16\+\_\+t protocol, const Address \&src, const Address \&dst, Packet\+Type packet\+Type)}{ReceiveFromDevice(Ptr< NetDevice > netdev, Ptr< const Packet > packet, uint16_t protocol, const Address &src, const Address &dst, PacketType packetType)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Receive\+From\+Device (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{netdev, }
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{packet, }
\item[{uint16\+\_\+t}]{protocol, }
\item[{const {\bf Address} \&}]{src, }
\item[{const {\bf Address} \&}]{dst, }
\item[{{\bf Packet\+Type}}]{packet\+Type}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a3f48603d679c0f7c1ffe43bf4140fce2}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a3f48603d679c0f7c1ffe43bf4140fce2}
Called when a packet is received on one of the switch\textquotesingle{}s ports.


\begin{DoxyParams}{Parameters}
{\em netdev} & The port the packet was received on. \\
\hline
{\em packet} & The \hyperlink{classns3_1_1Packet}{Packet} itself. \\
\hline
{\em protocol} & The protocol defining the \hyperlink{classns3_1_1Packet}{Packet}. \\
\hline
{\em src} & The source address of the \hyperlink{classns3_1_1Packet}{Packet}. \\
\hline
{\em dst} & The destination address of the \hyperlink{classns3_1_1Packet}{Packet}. \\
\hline
{\em Packet\+Type} & Type of the packet. \\
\hline
\end{DoxyParams}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Receive\+Get\+Config\+Request@{Receive\+Get\+Config\+Request}}
\index{Receive\+Get\+Config\+Request@{Receive\+Get\+Config\+Request}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Receive\+Get\+Config\+Request(const void $\ast$msg)}{ReceiveGetConfigRequest(const void *msg)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Receive\+Get\+Config\+Request (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{msg}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a0d8c5564925fad43196827cb27dc9321}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a0d8c5564925fad43196827cb27dc9321}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Receive\+Packet\+Out@{Receive\+Packet\+Out}}
\index{Receive\+Packet\+Out@{Receive\+Packet\+Out}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Receive\+Packet\+Out(const void $\ast$msg)}{ReceivePacketOut(const void *msg)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Receive\+Packet\+Out (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{msg}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a73352d19efcef02dfda83fa6f0c933ac}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a73352d19efcef02dfda83fa6f0c933ac}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Receive\+Port\+Mod@{Receive\+Port\+Mod}}
\index{Receive\+Port\+Mod@{Receive\+Port\+Mod}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Receive\+Port\+Mod(const void $\ast$msg)}{ReceivePortMod(const void *msg)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Receive\+Port\+Mod (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{msg}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a745d4c09c59eef1a76f78ee46d7b7b6a}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a745d4c09c59eef1a76f78ee46d7b7b6a}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Receive\+Set\+Config@{Receive\+Set\+Config}}
\index{Receive\+Set\+Config@{Receive\+Set\+Config}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Receive\+Set\+Config(const void $\ast$msg)}{ReceiveSetConfig(const void *msg)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Receive\+Set\+Config (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{msg}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a2adbeaea746d9f030ac533e379eabac6}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a2adbeaea746d9f030ac533e379eabac6}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Receive\+Stats\+Request@{Receive\+Stats\+Request}}
\index{Receive\+Stats\+Request@{Receive\+Stats\+Request}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Receive\+Stats\+Request(const void $\ast$oh)}{ReceiveStatsRequest(const void *oh)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Receive\+Stats\+Request (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{oh}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a2927985da87ca33b12ba1a106678aaf0}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a2927985da87ca33b12ba1a106678aaf0}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Receive\+V\+Port\+Mod@{Receive\+V\+Port\+Mod}}
\index{Receive\+V\+Port\+Mod@{Receive\+V\+Port\+Mod}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Receive\+V\+Port\+Mod(const void $\ast$msg)}{ReceiveVPortMod(const void *msg)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Receive\+V\+Port\+Mod (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{msg}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a26b0f3db2e65e2af075ec345b41c79d4}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a26b0f3db2e65e2af075ec345b41c79d4}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Receive\+V\+Port\+Table\+Features\+Request@{Receive\+V\+Port\+Table\+Features\+Request}}
\index{Receive\+V\+Port\+Table\+Features\+Request@{Receive\+V\+Port\+Table\+Features\+Request}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Receive\+V\+Port\+Table\+Features\+Request(const void $\ast$msg)}{ReceiveVPortTableFeaturesRequest(const void *msg)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Receive\+V\+Port\+Table\+Features\+Request (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{msg}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_ae7deaf7a63dd1445422d11e39aaeb18c}{}\label{classns3_1_1OpenFlowSwitchNetDevice_ae7deaf7a63dd1445422d11e39aaeb18c}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Run\+Through\+Flow\+Table@{Run\+Through\+Flow\+Table}}
\index{Run\+Through\+Flow\+Table@{Run\+Through\+Flow\+Table}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Run\+Through\+Flow\+Table(uint32\+\_\+t packet\+\_\+uid, int port, bool send\+\_\+to\+\_\+controller=true)}{RunThroughFlowTable(uint32_t packet_uid, int port, bool send_to_controller=true)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Run\+Through\+Flow\+Table (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{packet\+\_\+uid, }
\item[{int}]{port, }
\item[{bool}]{send\+\_\+to\+\_\+controller = {\ttfamily true}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a3855859a3625d566e4e1f9297d3350a8}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a3855859a3625d566e4e1f9297d3350a8}
Run the packet through the flow table. Looks up in the flow table for a match. If it doesn\textquotesingle{}t match, it forwards the packet to the registered controller, if the flag is set.


\begin{DoxyParams}{Parameters}
{\em packet\+\_\+uid} & \hyperlink{classns3_1_1Packet}{Packet} U\+ID; used to fetch the packet and its metadata. \\
\hline
{\em port} & The port this packet was received over. \\
\hline
{\em send\+\_\+to\+\_\+controller} & If set, sends to the controller if the packet isn\textquotesingle{}t matched. \\
\hline
\end{DoxyParams}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Run\+Through\+V\+Port\+Table@{Run\+Through\+V\+Port\+Table}}
\index{Run\+Through\+V\+Port\+Table@{Run\+Through\+V\+Port\+Table}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Run\+Through\+V\+Port\+Table(uint32\+\_\+t packet\+\_\+uid, int port, uint32\+\_\+t vport)}{RunThroughVPortTable(uint32_t packet_uid, int port, uint32_t vport)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Run\+Through\+V\+Port\+Table (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{packet\+\_\+uid, }
\item[{int}]{port, }
\item[{uint32\+\_\+t}]{vport}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_ab8f468f2c29abacad719a6703cf0169c}{}\label{classns3_1_1OpenFlowSwitchNetDevice_ab8f468f2c29abacad719a6703cf0169c}
Run the packet through the vport table. As with Add\+V\+Port, this doesn\textquotesingle{}t have an understood use yet.


\begin{DoxyParams}{Parameters}
{\em packet\+\_\+uid} & \hyperlink{classns3_1_1Packet}{Packet} U\+ID; used to fetch the packet and its metadata. \\
\hline
{\em port} & The port this packet was received over. \\
\hline
{\em vport} & The virtual port this packet identifies itself by. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if everything\textquotesingle{}s ok, otherwise an error number. 
\end{DoxyReturn}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Send@{Send}}
\index{Send@{Send}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Send(\+Ptr$<$ Packet $>$ packet, const Address \&dest, uint16\+\_\+t protocol\+Number)}{Send(Ptr< Packet > packet, const Address &dest, uint16_t protocolNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Send (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{const {\bf Address} \&}]{dest, }
\item[{uint16\+\_\+t}]{protocol\+Number}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_ada683f14699af3f11ce3658f51269668}{}\label{classns3_1_1OpenFlowSwitchNetDevice_ada683f14699af3f11ce3658f51269668}

\begin{DoxyParams}{Parameters}
{\em packet} & packet sent from above down to Network Device \\
\hline
{\em dest} & mac address of the destination (already resolved) \\
\hline
{\em protocol\+Number} & identifies the type of payload contained in this packet. Used to call the right L3\+Protocol when the packet is received.\\
\hline
\end{DoxyParams}
Called from higher layer to send packet into Network Device to the specified destination \hyperlink{classns3_1_1Address}{Address}

\begin{DoxyReturn}{Returns}
whether the Send operation succeeded 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a59f41afb0fe8951bb94d5739cbe6ee7d}{ns3\+::\+Net\+Device}.

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Send\+Error\+Msg@{Send\+Error\+Msg}}
\index{Send\+Error\+Msg@{Send\+Error\+Msg}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Send\+Error\+Msg(uint16\+\_\+t type, uint16\+\_\+t code, const void $\ast$data, size\+\_\+t len)}{SendErrorMsg(uint16_t type, uint16_t code, const void *data, size_t len)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Send\+Error\+Msg (
\begin{DoxyParamCaption}
\item[{uint16\+\_\+t}]{type, }
\item[{uint16\+\_\+t}]{code, }
\item[{const void $\ast$}]{data, }
\item[{size\+\_\+t}]{len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a8a511cf5cf8b5f00dea8ac2d7f14f091}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a8a511cf5cf8b5f00dea8ac2d7f14f091}
If an error message happened during the controller\textquotesingle{}s request, send it to the controller.


\begin{DoxyParams}{Parameters}
{\em type} & The type of error. \\
\hline
{\em code} & The error code. \\
\hline
{\em data} & The faulty data that lead to the error. \\
\hline
{\em len} & The length of the faulty data. \\
\hline
\end{DoxyParams}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Send\+Features\+Reply@{Send\+Features\+Reply}}
\index{Send\+Features\+Reply@{Send\+Features\+Reply}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Send\+Features\+Reply()}{SendFeaturesReply()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Send\+Features\+Reply (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a4f85126d582b80926f755d70f328a254}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a4f85126d582b80926f755d70f328a254}
Send a reply about this Open\+Flow switch\textquotesingle{}s features to the controller.

List of capabilities and actions to support are found in the specification $<$www.\+openflowswitch.\+org/documents/openflow-\/spec-\/v0.8.\+9.\+pdf$>$.

Supported capabilities and actions are defined in the openflow interface. To recap, flow status, flow table status, port status, virtual port table status can all be requested. It can also transmit over multiple physical interfaces.

It supports every action\+: outputting over a port, and all of the flow table manipulation actions\+: setting the 802.\+1q V\+L\+AN ID, the 802.\+1q priority, stripping the 802.\+1 header, setting the Ethernet source address and destination, setting the IP source address and destination, setting the T\+C\+P/\+U\+DP source address and destination, and setting the M\+P\+LS label and E\+XP bits.

\begin{DoxyAttention}{Attention}
Capabilities S\+TP (Spanning Tree Protocol) and IP packet reassembly are not currently supported. 
\end{DoxyAttention}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Send\+Flow\+Expired@{Send\+Flow\+Expired}}
\index{Send\+Flow\+Expired@{Send\+Flow\+Expired}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Send\+Flow\+Expired(sw\+\_\+flow $\ast$flow, enum ofp\+\_\+flow\+\_\+expired\+\_\+reason reason)}{SendFlowExpired(sw_flow *flow, enum ofp_flow_expired_reason reason)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Send\+Flow\+Expired (
\begin{DoxyParamCaption}
\item[{sw\+\_\+flow $\ast$}]{flow, }
\item[{enum ofp\+\_\+flow\+\_\+expired\+\_\+reason}]{reason}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a3af4a49e4a3897b107b7bac09cb1ae16}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a3af4a49e4a3897b107b7bac09cb1ae16}
Send a reply to the controller that a specific flow has expired.


\begin{DoxyParams}{Parameters}
{\em flow} & The flow that expired. \\
\hline
{\em reason} & The reason for sending this expiration notification. \\
\hline
\end{DoxyParams}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Send\+From@{Send\+From}}
\index{Send\+From@{Send\+From}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Send\+From(\+Ptr$<$ Packet $>$ packet, const Address \&source, const Address \&dest, uint16\+\_\+t protocol\+Number)}{SendFrom(Ptr< Packet > packet, const Address &source, const Address &dest, uint16_t protocolNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Send\+From (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{const {\bf Address} \&}]{source, }
\item[{const {\bf Address} \&}]{dest, }
\item[{uint16\+\_\+t}]{protocol\+Number}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_ad696726590d7076bdc25969146a980cd}{}\label{classns3_1_1OpenFlowSwitchNetDevice_ad696726590d7076bdc25969146a980cd}

\begin{DoxyParams}{Parameters}
{\em packet} & packet sent from above down to Network Device \\
\hline
{\em source} & source mac address (so called \char`\"{}\+M\+A\+C spoofing\char`\"{}) \\
\hline
{\em dest} & mac address of the destination (already resolved) \\
\hline
{\em protocol\+Number} & identifies the type of payload contained in this packet. Used to call the right L3\+Protocol when the packet is received.\\
\hline
\end{DoxyParams}
Called from higher layer to send packet into Network Device with the specified source and destination Addresses.

\begin{DoxyReturn}{Returns}
whether the Send operation succeeded 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a19d55a4746c1ae584bf7da69959a885b}{ns3\+::\+Net\+Device}.

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Send\+Openflow\+Buffer@{Send\+Openflow\+Buffer}}
\index{Send\+Openflow\+Buffer@{Send\+Openflow\+Buffer}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Send\+Openflow\+Buffer(ofpbuf $\ast$buffer)}{SendOpenflowBuffer(ofpbuf *buffer)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Send\+Openflow\+Buffer (
\begin{DoxyParamCaption}
\item[{ofpbuf $\ast$}]{buffer}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a966a9b3636b35bf55372ee1f77e2ab89}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a966a9b3636b35bf55372ee1f77e2ab89}
Send a message to the controller. This method is the key to communicating with the controller, it does the actual sending. The other Send methods call this one when they are ready to send a message.


\begin{DoxyParams}{Parameters}
{\em buffer} & \hyperlink{classns3_1_1Buffer}{Buffer} of the message to send out. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if successful, otherwise an error number. 
\end{DoxyReturn}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Send\+Port\+Status@{Send\+Port\+Status}}
\index{Send\+Port\+Status@{Send\+Port\+Status}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Send\+Port\+Status(ofi\+::\+Port p, uint8\+\_\+t status)}{SendPortStatus(ofi::Port p, uint8_t status)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Send\+Port\+Status (
\begin{DoxyParamCaption}
\item[{{\bf ofi\+::\+Port}}]{p, }
\item[{uint8\+\_\+t}]{status}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a3111ef7ec072cf59ddabe3a7c3e89e67}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a3111ef7ec072cf59ddabe3a7c3e89e67}
Send a reply about a Port\textquotesingle{}s status to the controller.


\begin{DoxyParams}{Parameters}
{\em p} & The port to get status from. \\
\hline
{\em status} & The reason for sending this reply. \\
\hline
\end{DoxyParams}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Send\+V\+Port\+Table\+Features@{Send\+V\+Port\+Table\+Features}}
\index{Send\+V\+Port\+Table\+Features@{Send\+V\+Port\+Table\+Features}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Send\+V\+Port\+Table\+Features()}{SendVPortTableFeatures()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Send\+V\+Port\+Table\+Features (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a51d89daf86d957758b761811e26a677a}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a51d89daf86d957758b761811e26a677a}
Send a reply about this Open\+Flow switch\textquotesingle{}s virtual port table features to the controller. \index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Set\+Address@{Set\+Address}}
\index{Set\+Address@{Set\+Address}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Address(\+Address address)}{SetAddress(Address address)}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Set\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a3d005621ffcc3cc4dc43559598a17e1a}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a3d005621ffcc3cc4dc43559598a17e1a}
Set the address of this interface 
\begin{DoxyParams}{Parameters}
{\em address} & address to set \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1NetDevice_ab56dc36bc0547471ab3210eda60ee76c}{ns3\+::\+Net\+Device}.

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Set\+Controller@{Set\+Controller}}
\index{Set\+Controller@{Set\+Controller}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Controller(\+Ptr$<$ ofi\+::\+Controller $>$ c)}{SetController(Ptr< ofi::Controller > c)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Set\+Controller (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf ofi\+::\+Controller} $>$}]{c}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a97be3cb2eeab82c224f82b7ffc63beb4}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a97be3cb2eeab82c224f82b7ffc63beb4}


Set up the Switch\textquotesingle{}s controller connection. 


\begin{DoxyParams}{Parameters}
{\em c} & Pointer to a Controller. \\
\hline
\end{DoxyParams}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Set\+If\+Index@{Set\+If\+Index}}
\index{Set\+If\+Index@{Set\+If\+Index}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+If\+Index(const uint32\+\_\+t index)}{SetIfIndex(const uint32_t index)}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Set\+If\+Index (
\begin{DoxyParamCaption}
\item[{const uint32\+\_\+t}]{index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a7cfbd893f5fb6b11f5c474996bfe5af0}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a7cfbd893f5fb6b11f5c474996bfe5af0}

\begin{DoxyParams}{Parameters}
{\em index} & if\+Index of the device \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1NetDevice_a2e1ac6c1189cd565420305d85a193fb8}{ns3\+::\+Net\+Device}.

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Set\+Mtu@{Set\+Mtu}}
\index{Set\+Mtu@{Set\+Mtu}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Mtu(const uint16\+\_\+t mtu)}{SetMtu(const uint16_t mtu)}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Set\+Mtu (
\begin{DoxyParamCaption}
\item[{const uint16\+\_\+t}]{mtu}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a23992b30d089b76aa2e41bef4c3d46e4}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a23992b30d089b76aa2e41bef4c3d46e4}

\begin{DoxyParams}{Parameters}
{\em mtu} & M\+TU value, in bytes, to set for the device \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether the M\+TU value was within legal bounds
\end{DoxyReturn}
Override for default M\+TU defined on a per-\/type basis. 

Implements \hyperlink{classns3_1_1NetDevice_a2ba4956d45cde68eab3cbdd6ede06df0}{ns3\+::\+Net\+Device}.

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Set\+Node@{Set\+Node}}
\index{Set\+Node@{Set\+Node}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Node(\+Ptr$<$ Node $>$ node)}{SetNode(Ptr< Node > node)}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Set\+Node (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a620ee1fbb3418d31d780c8f3b4ed1c48}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a620ee1fbb3418d31d780c8f3b4ed1c48}

\begin{DoxyParams}{Parameters}
{\em node} & the node associated to this netdevice.\\
\hline
\end{DoxyParams}
This method is called from \hyperlink{classns3_1_1Node_a42ff83ee1d5d1649c770d3f5b62375de}{ns3\+::\+Node\+::\+Add\+Device}. 

Implements \hyperlink{classns3_1_1NetDevice_a3ae520ae06e93b957f0f56f113319a08}{ns3\+::\+Net\+Device}.

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Set\+Promisc\+Receive\+Callback@{Set\+Promisc\+Receive\+Callback}}
\index{Set\+Promisc\+Receive\+Callback@{Set\+Promisc\+Receive\+Callback}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Promisc\+Receive\+Callback(\+Net\+Device\+::\+Promisc\+Receive\+Callback cb)}{SetPromiscReceiveCallback(NetDevice::PromiscReceiveCallback cb)}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Set\+Promisc\+Receive\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Net\+Device\+::\+Promisc\+Receive\+Callback}}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_aa478c75ffe8f6e20bc50187aa7c584cd}{}\label{classns3_1_1OpenFlowSwitchNetDevice_aa478c75ffe8f6e20bc50187aa7c584cd}

\begin{DoxyParams}{Parameters}
{\em cb} & callback to invoke whenever a packet has been received in promiscuous mode and must be forwarded to the higher layers.\\
\hline
\end{DoxyParams}
Enables netdevice promiscuous mode and sets the callback that will handle promiscuous mode packets. Note, promiscuous mode packets means {\itshape all} packets, including those packets that can be sensed by the netdevice but which are intended to be received by other hosts. 

Implements \hyperlink{classns3_1_1NetDevice_a3968946bdbb74d47d7b13612baad7d6d}{ns3\+::\+Net\+Device}.

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Set\+Receive\+Callback@{Set\+Receive\+Callback}}
\index{Set\+Receive\+Callback@{Set\+Receive\+Callback}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Receive\+Callback(\+Net\+Device\+::\+Receive\+Callback cb)}{SetReceiveCallback(NetDevice::ReceiveCallback cb)}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Set\+Receive\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Net\+Device\+::\+Receive\+Callback}}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a16cb2bab4a182be8edc3654423df3a4a}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a16cb2bab4a182be8edc3654423df3a4a}

\begin{DoxyParams}{Parameters}
{\em cb} & callback to invoke whenever a packet has been received and must be forwarded to the higher layers.\\
\hline
\end{DoxyParams}
Set the callback to be used to notify higher layers when a packet has been received. 

Implements \hyperlink{classns3_1_1NetDevice_ac63e4d5668e421fec4b5d37f32e7dd18}{ns3\+::\+Net\+Device}.

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Stats\+Done@{Stats\+Done}}
\index{Stats\+Done@{Stats\+Done}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Stats\+Done(ofi\+::\+Stats\+Dump\+Callback $\ast$cb\+\_\+)}{StatsDone(ofi::StatsDumpCallback *cb_)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Stats\+Done (
\begin{DoxyParamCaption}
\item[{{\bf ofi\+::\+Stats\+Dump\+Callback} $\ast$}]{cb\+\_\+}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a8a4905d4cbb354ff27d89ecedd9cff5f}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a8a4905d4cbb354ff27d89ecedd9cff5f}


Stats callback is done. 

Controllers have a callback system for status requests which calls this function.


\begin{DoxyParams}{Parameters}
{\em cb\+\_\+} & The callback data. \\
\hline
\end{DoxyParams}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Stats\+Dump@{Stats\+Dump}}
\index{Stats\+Dump@{Stats\+Dump}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Stats\+Dump(ofi\+::\+Stats\+Dump\+Callback $\ast$cb\+\_\+)}{StatsDump(ofi::StatsDumpCallback *cb_)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Stats\+Dump (
\begin{DoxyParamCaption}
\item[{{\bf ofi\+::\+Stats\+Dump\+Callback} $\ast$}]{cb\+\_\+}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_aa1e672674ec0878d2bbece811450691a}{}\label{classns3_1_1OpenFlowSwitchNetDevice_aa1e672674ec0878d2bbece811450691a}


Stats callback is ready for a dump. 

Controllers have a callback system for status requests which calls this function.


\begin{DoxyParams}{Parameters}
{\em cb\+\_\+} & The callback data. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if everything\textquotesingle{}s ok, otherwise an error number. 
\end{DoxyReturn}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Supports\+Send\+From@{Supports\+Send\+From}}
\index{Supports\+Send\+From@{Supports\+Send\+From}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Supports\+Send\+From() const }{SupportsSendFrom() const }}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Supports\+Send\+From (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_abfebbe48743d45631308dc11d45bb6f4}{}\label{classns3_1_1OpenFlowSwitchNetDevice_abfebbe48743d45631308dc11d45bb6f4}
\begin{DoxyReturn}{Returns}
true if this interface supports a bridging mode, false otherwise. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a04793d220b54c40e110ebf86dae5b25c}{ns3\+::\+Net\+Device}.

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!Update\+Port\+Status@{Update\+Port\+Status}}
\index{Update\+Port\+Status@{Update\+Port\+Status}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{Update\+Port\+Status(ofi\+::\+Port \&p)}{UpdatePortStatus(ofi::Port &p)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::\+Update\+Port\+Status (
\begin{DoxyParamCaption}
\item[{{\bf ofi\+::\+Port} \&}]{p}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a58d57963f1369e1fa389c6b4ae940033}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a58d57963f1369e1fa389c6b4ae940033}
Update the port status field of the switch port. A non-\/zero return value indicates some field has changed.


\begin{DoxyParams}{Parameters}
{\em p} & A reference to a Port; used to change its config and flag fields. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the status of the Port is changed, false if unchanged (was already the right status). 
\end{DoxyReturn}


\subsection{Member Data Documentation}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!m\+\_\+address@{m\+\_\+address}}
\index{m\+\_\+address@{m\+\_\+address}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+address}{m_address}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Mac48\+Address} ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::m\+\_\+address\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a0278390fb81f277dac19d25482ad1bef}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a0278390fb81f277dac19d25482ad1bef}


\hyperlink{classns3_1_1Address}{Address} of this device. 

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!m\+\_\+chain@{m\+\_\+chain}}
\index{m\+\_\+chain@{m\+\_\+chain}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+chain}{m_chain}}]{\setlength{\rightskip}{0pt plus 5cm}sw\+\_\+chain$\ast$ ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::m\+\_\+chain\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_aebd93d8b1a9c5c52077e02487953cfe4}{}\label{classns3_1_1OpenFlowSwitchNetDevice_aebd93d8b1a9c5c52077e02487953cfe4}


Flow Table; forwarding rules. 

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!m\+\_\+channel@{m\+\_\+channel}}
\index{m\+\_\+channel@{m\+\_\+channel}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+channel}{m_channel}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Bridge\+Channel}$>$ ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::m\+\_\+channel\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a2544f1285545cf8e45878277be7b6778}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a2544f1285545cf8e45878277be7b6778}


Collection of port channels into the Switch \hyperlink{classns3_1_1Channel}{Channel}. 

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!m\+\_\+controller@{m\+\_\+controller}}
\index{m\+\_\+controller@{m\+\_\+controller}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+controller}{m_controller}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf ofi\+::\+Controller}$>$ ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::m\+\_\+controller\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_adbded8b966a707ca33bb225b33809e49}{}\label{classns3_1_1OpenFlowSwitchNetDevice_adbded8b966a707ca33bb225b33809e49}


Connection to controller. 

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!m\+\_\+flags@{m\+\_\+flags}}
\index{m\+\_\+flags@{m\+\_\+flags}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+flags}{m_flags}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::m\+\_\+flags\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a5bce0e985237e957abf794d3dd6416be}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a5bce0e985237e957abf794d3dd6416be}


Flags; configurable by the controller. 

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!m\+\_\+id@{m\+\_\+id}}
\index{m\+\_\+id@{m\+\_\+id}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+id}{m_id}}]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::m\+\_\+id\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a0af690c63ccd5d84b4abd671213086b2}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a0af690c63ccd5d84b4abd671213086b2}


Unique identifier for this switch, needed for Open\+Flow. 

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!m\+\_\+if\+Index@{m\+\_\+if\+Index}}
\index{m\+\_\+if\+Index@{m\+\_\+if\+Index}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+if\+Index}{m_ifIndex}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::m\+\_\+if\+Index\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_ad8be8954209401de3b29c6e4da106b89}{}\label{classns3_1_1OpenFlowSwitchNetDevice_ad8be8954209401de3b29c6e4da106b89}


Interface Index. 

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!m\+\_\+last\+Execute@{m\+\_\+last\+Execute}}
\index{m\+\_\+last\+Execute@{m\+\_\+last\+Execute}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+last\+Execute}{m_lastExecute}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::m\+\_\+last\+Execute\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a53db2fcee324af42c9d7364c76708423}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a53db2fcee324af42c9d7364c76708423}


Last time the periodic execution occurred. 

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!m\+\_\+lookup\+Delay@{m\+\_\+lookup\+Delay}}
\index{m\+\_\+lookup\+Delay@{m\+\_\+lookup\+Delay}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+lookup\+Delay}{m_lookupDelay}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::m\+\_\+lookup\+Delay\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_aa408b593e982502e0939dba57aa4c907}{}\label{classns3_1_1OpenFlowSwitchNetDevice_aa408b593e982502e0939dba57aa4c907}


Flow Table Lookup Delay \mbox{[}overhead\mbox{]}. 

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!m\+\_\+miss\+Send\+Len@{m\+\_\+miss\+Send\+Len}}
\index{m\+\_\+miss\+Send\+Len@{m\+\_\+miss\+Send\+Len}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+miss\+Send\+Len}{m_missSendLen}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::m\+\_\+miss\+Send\+Len\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a7437e1b44dc68e7f7f2efc1fabae7fdd}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a7437e1b44dc68e7f7f2efc1fabae7fdd}


Flow Table Miss Send Length; configurable by the controller. 

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!m\+\_\+mtu@{m\+\_\+mtu}}
\index{m\+\_\+mtu@{m\+\_\+mtu}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+mtu}{m_mtu}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::m\+\_\+mtu\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a32d177d10cd1c5a266db9f4014cd7384}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a32d177d10cd1c5a266db9f4014cd7384}


Maximum Transmission Unit. 

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!m\+\_\+node@{m\+\_\+node}}
\index{m\+\_\+node@{m\+\_\+node}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+node}{m_node}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Node}$>$ ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::m\+\_\+node\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a0a4333cc4bfb15852c2d9f87e801cbd8}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a0a4333cc4bfb15852c2d9f87e801cbd8}


\hyperlink{classns3_1_1Node}{Node} this device is installed on. 

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!m\+\_\+packet\+Data@{m\+\_\+packet\+Data}}
\index{m\+\_\+packet\+Data@{m\+\_\+packet\+Data}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+packet\+Data}{m_packetData}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Packet\+Data\+\_\+t} ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::m\+\_\+packet\+Data\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a7e0e79f1cdc4d37c13fc53c2ff8506b3}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a7e0e79f1cdc4d37c13fc53c2ff8506b3}


\hyperlink{classns3_1_1Packet}{Packet} data. 

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!m\+\_\+ports@{m\+\_\+ports}}
\index{m\+\_\+ports@{m\+\_\+ports}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+ports}{m_ports}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ports\+\_\+t} ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::m\+\_\+ports\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a5262a28722c2342816dfda05744dcfd2}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a5262a28722c2342816dfda05744dcfd2}


Switch\textquotesingle{}s ports. 

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!m\+\_\+promisc\+Rx\+Callback@{m\+\_\+promisc\+Rx\+Callback}}
\index{m\+\_\+promisc\+Rx\+Callback@{m\+\_\+promisc\+Rx\+Callback}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+promisc\+Rx\+Callback}{m_promiscRxCallback}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Net\+Device\+::\+Promisc\+Receive\+Callback} ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::m\+\_\+promisc\+Rx\+Callback\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a9acb89d5f22b5e5c9114db32a0bbcbc5}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a9acb89d5f22b5e5c9114db32a0bbcbc5}
\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!m\+\_\+rx\+Callback@{m\+\_\+rx\+Callback}}
\index{m\+\_\+rx\+Callback@{m\+\_\+rx\+Callback}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+rx\+Callback}{m_rxCallback}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Net\+Device\+::\+Receive\+Callback} ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::m\+\_\+rx\+Callback\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_ac6ed70a909dccd5edd66088d4560b89a}{}\label{classns3_1_1OpenFlowSwitchNetDevice_ac6ed70a909dccd5edd66088d4560b89a}


Callbacks. 

\index{ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}!m\+\_\+vport\+Table@{m\+\_\+vport\+Table}}
\index{m\+\_\+vport\+Table@{m\+\_\+vport\+Table}!ns3\+::\+Open\+Flow\+Switch\+Net\+Device@{ns3\+::\+Open\+Flow\+Switch\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+vport\+Table}{m_vportTable}}]{\setlength{\rightskip}{0pt plus 5cm}vport\+\_\+table\+\_\+t ns3\+::\+Open\+Flow\+Switch\+Net\+Device\+::m\+\_\+vport\+Table\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1OpenFlowSwitchNetDevice_a454c503adcde4d4636a36bbd2ee37855}{}\label{classns3_1_1OpenFlowSwitchNetDevice_a454c503adcde4d4636a36bbd2ee37855}


Virtual Port Table. 



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
openflow/model/\hyperlink{openflow-switch-net-device_8h}{openflow-\/switch-\/net-\/device.\+h}\end{DoxyCompactItemize}
