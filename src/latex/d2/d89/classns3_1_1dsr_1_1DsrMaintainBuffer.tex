\hypertarget{classns3_1_1dsr_1_1DsrMaintainBuffer}{}\section{ns3\+:\+:dsr\+:\+:Dsr\+Maintain\+Buffer Class Reference}
\label{classns3_1_1dsr_1_1DsrMaintainBuffer}\index{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}}


D\+SR maintain buffer.  




{\ttfamily \#include $<$dsr-\/maintain-\/buff.\+h$>$}



Collaboration diagram for ns3\+:\+:dsr\+:\+:Dsr\+Maintain\+Buffer\+:
% FIG 0
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a89df4c4059c2290fd6f528bce2fa92e9}{Dsr\+Maintain\+Buffer} ()
\item 
bool \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a8ec30b5b9b0f6af36e61867327a47717}{Enqueue} (\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffEntry}{Dsr\+Maintain\+Buff\+Entry} \&entry)
\begin{DoxyCompactList}\small\item\em Push entry in queue, if there is no entry with the same packet and destination address in queue. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a0539c5c6c2b05e10f52372f5fdb93c06}{Dequeue} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} dst, \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffEntry}{Dsr\+Maintain\+Buff\+Entry} \&entry)
\begin{DoxyCompactList}\small\item\em Return first found (the earliest) entry for given destination. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a1a9e6b160691cf12dc785dbf91a2fc32}{Drop\+Packet\+With\+Next\+Hop} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} next\+Hop)
\begin{DoxyCompactList}\small\item\em Remove all packets with destination IP address dst. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a42eaded41fd2aeb05dbf0261a130281a}{Find} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} next\+Hop)
\begin{DoxyCompactList}\small\item\em Finds whether a packet with destination dst exists in the queue. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a7df015a7d740c8b442df20f4ab3895b7}{Get\+Size} ()
\begin{DoxyCompactList}\small\item\em Number of entries. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_abcac71bd02b5e93fc1ecfec42f081ec2}{Get\+Max\+Queue\+Len} () const 
\item 
void \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a1e52f7157e94aea3e44003e9da22e7ff}{Set\+Max\+Queue\+Len} (uint32\+\_\+t len)
\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a0b63c01fa386ed899deab52c28e67e8e}{Get\+Maintain\+Buffer\+Timeout} () const 
\item 
void \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a480bdf66ecdb34f06413d76dcacd77e9}{Set\+Maintain\+Buffer\+Timeout} (\hyperlink{classns3_1_1Time}{Time} t)
\item 
bool \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a2f553fb512d4aee9a538c799bc2d0f45}{All\+Equal} (\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffEntry}{Dsr\+Maintain\+Buff\+Entry} \&entry)
\begin{DoxyCompactList}\small\item\em Verify if all the elements in the maintainence buffer entry is the same. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a35cc9dcd004a3a860f03d61ffe9478ef}{Link\+Equal} (\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffEntry}{Dsr\+Maintain\+Buff\+Entry} \&entry)
\begin{DoxyCompactList}\small\item\em Verify if the maintain buffer entry is the same in every field for link ack. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a8eaf2b7c9d9bd778db1b25b6f8d19255}{Network\+Equal} (\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffEntry}{Dsr\+Maintain\+Buff\+Entry} \&entry)
\begin{DoxyCompactList}\small\item\em Verify if the maintain buffer entry is the same in every field for network ack. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a8968cfdf465293896b00fe4c11c4ba72}{Promisc\+Equal} (\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffEntry}{Dsr\+Maintain\+Buff\+Entry} \&entry)
\begin{DoxyCompactList}\small\item\em Verify if the maintain buffer entry is the same in every field for promiscuous ack. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_af12ee29b56abcaac29b60c0a544494b9}{Purge} ()
\begin{DoxyCompactList}\small\item\em Remove all expired entries. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Private Member Functions}
\begin{DoxyCompactItemize}
\item 
static bool \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a2b6701a0cc73fa909fb1e7ff154b8b2d}{Is\+Equal} (\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffEntry}{Dsr\+Maintain\+Buff\+Entry} en, const \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} next\+Hop)
\begin{DoxyCompactList}\small\item\em Verify if the maintain buffer is equal or not. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::vector$<$ \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffEntry}{Dsr\+Maintain\+Buff\+Entry} $>$ \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\+\_\+maintain\+Buffer}
\begin{DoxyCompactList}\small\item\em The vector of maintain buffer entries. \end{DoxyCompactList}\item 
std\+::vector$<$ \hyperlink{structns3_1_1dsr_1_1NetworkKey}{Network\+Key} $>$ \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a3ba935c313adf894d20e612dbab825a3}{m\+\_\+all\+Network\+Key}
\item 
uint32\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a497cea8ef3a7d5ee9db88e8cc0b8a365}{m\+\_\+max\+Len}
\begin{DoxyCompactList}\small\item\em The maximum number of packets that we allow a routing protocol to buffer. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a054cbdee77cd0a61520726c2fc72912c}{m\+\_\+maintain\+Buffer\+Timeout}
\begin{DoxyCompactList}\small\item\em The maximum period of time that a routing protocol is allowed to buffer a packet for, seconds. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
D\+SR maintain buffer. 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}!Dsr\+Maintain\+Buffer@{Dsr\+Maintain\+Buffer}}
\index{Dsr\+Maintain\+Buffer@{Dsr\+Maintain\+Buffer}!ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}}
\subsubsection[{\texorpdfstring{Dsr\+Maintain\+Buffer()}{DsrMaintainBuffer()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer\+::\+Dsr\+Maintain\+Buffer (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classns3_1_1dsr_1_1DsrMaintainBuffer_a89df4c4059c2290fd6f528bce2fa92e9}{}\label{classns3_1_1dsr_1_1DsrMaintainBuffer_a89df4c4059c2290fd6f528bce2fa92e9}
Default constructor 
\begin{DoxyCode}
257   \{
258   \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}!All\+Equal@{All\+Equal}}
\index{All\+Equal@{All\+Equal}!ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}}
\subsubsection[{\texorpdfstring{All\+Equal(\+Dsr\+Maintain\+Buff\+Entry \&entry)}{AllEqual(DsrMaintainBuffEntry &entry)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer\+::\+All\+Equal (
\begin{DoxyParamCaption}
\item[{{\bf Dsr\+Maintain\+Buff\+Entry} \&}]{entry}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrMaintainBuffer_a2f553fb512d4aee9a538c799bc2d0f45}{}\label{classns3_1_1dsr_1_1DsrMaintainBuffer_a2f553fb512d4aee9a538c799bc2d0f45}


Verify if all the elements in the maintainence buffer entry is the same. 


\begin{DoxyCode}
126 \{
127   \textcolor{keywordflow}{for} (std::vector<DsrMaintainBuffEntry>::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.begin (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}
128        != \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
129     \{
130 \textcolor{comment}{//      NS\_LOG\_DEBUG ("nexthop " << i->GetNextHop () << " " << entry.GetNextHop () << " our address " <<
       i->GetOurAdd () << " " << entry.GetOurAdd ()}
131 \textcolor{comment}{//                               << " src " << i->GetSrc () << " " << entry.GetSrc () << " dst " <<
       i->GetDst () << " " << entry.GetDst ()}
132 \textcolor{comment}{//                               << " ackId " << i->GetAckId () << " " << entry.GetAckId ());}
133 
134       \textcolor{keywordflow}{if} ((\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetOurAdd () == entry.GetOurAdd ()) && (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetNextHop () == entry.GetNextHop ())
135           && (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetSrc () == entry.GetSrc ()) && (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetDst () == entry.GetDst ())
136           && (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetAckId () == entry.GetAckId ()) && (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetSegsLeft () == entry.GetSegsLeft ()))
137         \{
138           \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.erase (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});   \textcolor{comment}{// Erase the same maintain buffer entry for
       the received packet}
139           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
140         \}
141     \}
142   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
143 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 1




Here is the caller graph for this function\+:
% FIG 2


\index{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}!Dequeue@{Dequeue}}
\index{Dequeue@{Dequeue}!ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}}
\subsubsection[{\texorpdfstring{Dequeue(\+Ipv4\+Address dst, Dsr\+Maintain\+Buff\+Entry \&entry)}{Dequeue(Ipv4Address dst, DsrMaintainBuffEntry &entry)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer\+::\+Dequeue (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{dst, }
\item[{{\bf Dsr\+Maintain\+Buff\+Entry} \&}]{entry}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrMaintainBuffer_a0539c5c6c2b05e10f52372f5fdb93c06}{}\label{classns3_1_1dsr_1_1DsrMaintainBuffer_a0539c5c6c2b05e10f52372f5fdb93c06}


Return first found (the earliest) entry for given destination. 


\begin{DoxyCode}
94 \{
95   \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_af12ee29b56abcaac29b60c0a544494b9}{Purge} ();
96   \textcolor{keywordflow}{for} (std::vector<DsrMaintainBuffEntry>::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.begin (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
97     \{
98       \textcolor{keywordflow}{if} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetNextHop () == nextHop)
99         \{
100           entry = *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
101           \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.erase (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
102           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Packet size while dequeuing "} << entry.GetPacket ()->GetSize ());
103           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
104         \}
105     \}
106   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
107 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3




Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}!Drop\+Packet\+With\+Next\+Hop@{Drop\+Packet\+With\+Next\+Hop}}
\index{Drop\+Packet\+With\+Next\+Hop@{Drop\+Packet\+With\+Next\+Hop}!ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}}
\subsubsection[{\texorpdfstring{Drop\+Packet\+With\+Next\+Hop(\+Ipv4\+Address next\+Hop)}{DropPacketWithNextHop(Ipv4Address nextHop)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer\+::\+Drop\+Packet\+With\+Next\+Hop (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{next\+Hop}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrMaintainBuffer_a1a9e6b160691cf12dc785dbf91a2fc32}{}\label{classns3_1_1dsr_1_1DsrMaintainBuffer_a1a9e6b160691cf12dc785dbf91a2fc32}


Remove all packets with destination IP address dst. 


\begin{DoxyCode}
84 \{
85   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << nextHop);
86   \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_af12ee29b56abcaac29b60c0a544494b9}{Purge} ();
87   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Drop Packet With next hop "} << nextHop);
88   \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.erase (std::remove\_if (\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.begin (), 
      \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.end (),
89                                           std::bind2nd (std::ptr\_fun (
      \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a2b6701a0cc73fa909fb1e7ff154b8b2d}{DsrMaintainBuffer::IsEqual}), nextHop)), 
      \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.end ());
90 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5


\index{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}!Enqueue@{Enqueue}}
\index{Enqueue@{Enqueue}!ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}}
\subsubsection[{\texorpdfstring{Enqueue(\+Dsr\+Maintain\+Buff\+Entry \&entry)}{Enqueue(DsrMaintainBuffEntry &entry)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer\+::\+Enqueue (
\begin{DoxyParamCaption}
\item[{{\bf Dsr\+Maintain\+Buff\+Entry} \&}]{entry}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrMaintainBuffer_a8ec30b5b9b0f6af36e61867327a47717}{}\label{classns3_1_1dsr_1_1DsrMaintainBuffer_a8ec30b5b9b0f6af36e61867327a47717}


Push entry in queue, if there is no entry with the same packet and destination address in queue. 


\begin{DoxyCode}
54 \{
55   \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_af12ee29b56abcaac29b60c0a544494b9}{Purge} ();
56   \textcolor{keywordflow}{for} (std::vector<DsrMaintainBuffEntry>::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.begin (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}
57        != \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
58     \{
59 \textcolor{comment}{//      NS\_LOG\_INFO ("nexthop " << i->GetNextHop () << " " << entry.GetNextHop () << " our add " <<
       i->GetOurAdd () << " " << entry.GetOurAdd ()}
60 \textcolor{comment}{//                              << " src " << i->GetSrc () << " " << entry.GetSrc () << " dst " <<
       i->GetDst () << " " << entry.GetDst ()}
61 \textcolor{comment}{//                              << " ackId " << i->GetAckId () << " " << entry.GetAckId () << " SegsLeft "
       << (uint32\_t)i->GetSegsLeft () << " " << (uint32\_t)entry.GetSegsLeft ()}
62 \textcolor{comment}{//                   );}
63 
64       \textcolor{keywordflow}{if} ((\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetNextHop () == entry.GetNextHop ()) && (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetOurAdd () == entry.GetOurAdd ()) && (
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetSrc () == entry.GetSrc ())
65           && (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetDst () == entry.GetDst ()) && (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetAckId () == entry.GetAckId ()) && (
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetSegsLeft () == entry.GetSegsLeft ()))
66         \{
67           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Same maintenance entry found"});
68           \textcolor{keywordflow}{return} \textcolor{keyword}{false};
69         \}
70     \}
71 
72   entry.SetExpireTime (\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a054cbdee77cd0a61520726c2fc72912c}{m\_maintainBufferTimeout});
73   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.size () >= \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a497cea8ef3a7d5ee9db88e8cc0b8a365}{m\_maxLen})
74     \{
75       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Drop the most aged packet"});
76       \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.erase (\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.begin ());        \textcolor{comment}{// Drop
       the most aged packet}
77     \}
78   \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.push\_back (entry);
79   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
80 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6




Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}!Find@{Find}}
\index{Find@{Find}!ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}}
\subsubsection[{\texorpdfstring{Find(\+Ipv4\+Address next\+Hop)}{Find(Ipv4Address nextHop)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer\+::\+Find (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{next\+Hop}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrMaintainBuffer_a42eaded41fd2aeb05dbf0261a130281a}{}\label{classns3_1_1dsr_1_1DsrMaintainBuffer_a42eaded41fd2aeb05dbf0261a130281a}


Finds whether a packet with destination dst exists in the queue. 


\begin{DoxyCode}
111 \{
112   \textcolor{keywordflow}{for} (std::vector<DsrMaintainBuffEntry>::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.begin (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}
113        != \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
114     \{
115       \textcolor{keywordflow}{if} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetNextHop () == nextHop)
116         \{
117           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Found the packet in maintenance buffer"});
118           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
119         \}
120     \}
121   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
122 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}!Get\+Maintain\+Buffer\+Timeout@{Get\+Maintain\+Buffer\+Timeout}}
\index{Get\+Maintain\+Buffer\+Timeout@{Get\+Maintain\+Buffer\+Timeout}!ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}}
\subsubsection[{\texorpdfstring{Get\+Maintain\+Buffer\+Timeout() const }{GetMaintainBufferTimeout() const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer\+::\+Get\+Maintain\+Buffer\+Timeout (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classns3_1_1dsr_1_1DsrMaintainBuffer_a0b63c01fa386ed899deab52c28e67e8e}{}\label{classns3_1_1dsr_1_1DsrMaintainBuffer_a0b63c01fa386ed899deab52c28e67e8e}

\begin{DoxyCode}
280   \{
281     \textcolor{keywordflow}{return} \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a054cbdee77cd0a61520726c2fc72912c}{m\_maintainBufferTimeout};
282   \}
\end{DoxyCode}
\index{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}!Get\+Max\+Queue\+Len@{Get\+Max\+Queue\+Len}}
\index{Get\+Max\+Queue\+Len@{Get\+Max\+Queue\+Len}!ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}}
\subsubsection[{\texorpdfstring{Get\+Max\+Queue\+Len() const }{GetMaxQueueLen() const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer\+::\+Get\+Max\+Queue\+Len (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classns3_1_1dsr_1_1DsrMaintainBuffer_abcac71bd02b5e93fc1ecfec42f081ec2}{}\label{classns3_1_1dsr_1_1DsrMaintainBuffer_abcac71bd02b5e93fc1ecfec42f081ec2}

\begin{DoxyCode}
272   \{
273     \textcolor{keywordflow}{return} \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a497cea8ef3a7d5ee9db88e8cc0b8a365}{m\_maxLen};
274   \}
\end{DoxyCode}
\index{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}!Get\+Size@{Get\+Size}}
\index{Get\+Size@{Get\+Size}!ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}}
\subsubsection[{\texorpdfstring{Get\+Size()}{GetSize()}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer\+::\+Get\+Size (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrMaintainBuffer_a7df015a7d740c8b442df20f4ab3895b7}{}\label{classns3_1_1dsr_1_1DsrMaintainBuffer_a7df015a7d740c8b442df20f4ab3895b7}


Number of entries. 


\begin{DoxyCode}
47 \{
48   \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_af12ee29b56abcaac29b60c0a544494b9}{Purge} ();
49   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.size ();
50 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9




Here is the caller graph for this function\+:
% FIG 10


\index{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}!Is\+Equal@{Is\+Equal}}
\index{Is\+Equal@{Is\+Equal}!ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}}
\subsubsection[{\texorpdfstring{Is\+Equal(\+Dsr\+Maintain\+Buff\+Entry en, const Ipv4\+Address next\+Hop)}{IsEqual(DsrMaintainBuffEntry en, const Ipv4Address nextHop)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer\+::\+Is\+Equal (
\begin{DoxyParamCaption}
\item[{{\bf Dsr\+Maintain\+Buff\+Entry}}]{en, }
\item[{const {\bf Ipv4\+Address}}]{next\+Hop}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrMaintainBuffer_a2b6701a0cc73fa909fb1e7ff154b8b2d}{}\label{classns3_1_1dsr_1_1DsrMaintainBuffer_a2b6701a0cc73fa909fb1e7ff154b8b2d}


Verify if the maintain buffer is equal or not. 


\begin{DoxyCode}
308   \{
309     \textcolor{keywordflow}{return} (en.GetNextHop () == nextHop);
310   \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 11




Here is the caller graph for this function\+:
% FIG 12


\index{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}!Link\+Equal@{Link\+Equal}}
\index{Link\+Equal@{Link\+Equal}!ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}}
\subsubsection[{\texorpdfstring{Link\+Equal(\+Dsr\+Maintain\+Buff\+Entry \&entry)}{LinkEqual(DsrMaintainBuffEntry &entry)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer\+::\+Link\+Equal (
\begin{DoxyParamCaption}
\item[{{\bf Dsr\+Maintain\+Buff\+Entry} \&}]{entry}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrMaintainBuffer_a35cc9dcd004a3a860f03d61ffe9478ef}{}\label{classns3_1_1dsr_1_1DsrMaintainBuffer_a35cc9dcd004a3a860f03d61ffe9478ef}


Verify if the maintain buffer entry is the same in every field for link ack. 


\begin{DoxyCode}
191 \{
192   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The maintenance buffer size "} << \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.size ());
193   \textcolor{keywordflow}{for} (std::vector<DsrMaintainBuffEntry>::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.begin (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}
194        != \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
195     \{
196 \textcolor{comment}{//      NS\_LOG\_DEBUG ("src " << i->GetSrc () << " " << entry.GetSrc () << " dst " << i->GetDst () << " " <<
       entry.GetDst ()}
197 \textcolor{comment}{//                           << " OurAddress " << i->GetOurAdd () << " " << entry.GetOurAdd () << " next
       hop " << i->GetNextHop () << " "}
198 \textcolor{comment}{//                           << entry.GetNextHop ()}
199 \textcolor{comment}{//                    );}
200 
201       \textcolor{keywordflow}{if} ((\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetSrc () == entry.GetSrc ()) && (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetDst () == entry.GetDst ()) && (
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetOurAdd () == entry.GetOurAdd ())
202           && (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetNextHop () == entry.GetNextHop ())
203           )
204         \{
205           \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.erase (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});   \textcolor{comment}{// Erase the same maintain buffer entry for
       the promisc received packet}
206           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
207         \}
208     \}
209   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
210 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13




Here is the caller graph for this function\+:
% FIG 14


\index{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}!Network\+Equal@{Network\+Equal}}
\index{Network\+Equal@{Network\+Equal}!ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}}
\subsubsection[{\texorpdfstring{Network\+Equal(\+Dsr\+Maintain\+Buff\+Entry \&entry)}{NetworkEqual(DsrMaintainBuffEntry &entry)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer\+::\+Network\+Equal (
\begin{DoxyParamCaption}
\item[{{\bf Dsr\+Maintain\+Buff\+Entry} \&}]{entry}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrMaintainBuffer_a8eaf2b7c9d9bd778db1b25b6f8d19255}{}\label{classns3_1_1dsr_1_1DsrMaintainBuffer_a8eaf2b7c9d9bd778db1b25b6f8d19255}


Verify if the maintain buffer entry is the same in every field for network ack. 


\begin{DoxyCode}
147 \{
148   \textcolor{keywordflow}{for} (std::vector<DsrMaintainBuffEntry>::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.begin (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}
149        != \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
150     \{
151 \textcolor{comment}{//      NS\_LOG\_DEBUG ("nexthop " << i->GetNextHop () << " " << entry.GetNextHop () << " our address " <<
       i->GetOurAdd () << " " << entry.GetOurAdd ()}
152 \textcolor{comment}{//                               << " src " << i->GetSrc () << " " << entry.GetSrc () << " dst " <<
       i->GetDst () << " " << entry.GetDst ()}
153 \textcolor{comment}{//                               << " ackId " << i->GetAckId () << " " << entry.GetAckId ());}
154 
155       \textcolor{keywordflow}{if} ((\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetOurAdd () == entry.GetOurAdd ()) && (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetNextHop () == entry.GetNextHop ())
156           && (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetSrc () == entry.GetSrc ()) && (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetDst () == entry.GetDst ())
157           && (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetAckId () == entry.GetAckId ()))
158         \{
159           \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.erase (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});   \textcolor{comment}{// Erase the same maintain buffer entry for
       the received packet}
160           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
161         \}
162     \}
163   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
164 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 15




Here is the caller graph for this function\+:
% FIG 16


\index{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}!Promisc\+Equal@{Promisc\+Equal}}
\index{Promisc\+Equal@{Promisc\+Equal}!ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}}
\subsubsection[{\texorpdfstring{Promisc\+Equal(\+Dsr\+Maintain\+Buff\+Entry \&entry)}{PromiscEqual(DsrMaintainBuffEntry &entry)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer\+::\+Promisc\+Equal (
\begin{DoxyParamCaption}
\item[{{\bf Dsr\+Maintain\+Buff\+Entry} \&}]{entry}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrMaintainBuffer_a8968cfdf465293896b00fe4c11c4ba72}{}\label{classns3_1_1dsr_1_1DsrMaintainBuffer_a8968cfdf465293896b00fe4c11c4ba72}


Verify if the maintain buffer entry is the same in every field for promiscuous ack. 


\begin{DoxyCode}
168 \{
169   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The maintenance buffer size "} << \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.size ());
170   \textcolor{keywordflow}{for} (std::vector<DsrMaintainBuffEntry>::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.begin (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}
171        != \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
172     \{
173 \textcolor{comment}{//      NS\_LOG\_DEBUG ("src " << i->GetSrc () << " " << entry.GetSrc () << " dst " << i->GetDst () << " " <<
       entry.GetDst ()}
174 \textcolor{comment}{//                           << " SegsLeft " << (uint32\_t)i->GetSegsLeft () << " " <<
       (uint32\_t)entry.GetSegsLeft () << " ackId " << (uint32\_t)i->GetAckId () << " "}
175 \textcolor{comment}{//                           << (uint32\_t)entry.GetAckId ()}
176 \textcolor{comment}{//                    );}
177 
178       \textcolor{keywordflow}{if} ((\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetSrc () == entry.GetSrc ()) && (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetDst () == entry.GetDst ())
179           && (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetSegsLeft () == entry.GetSegsLeft ()) && (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetAckId () == entry.GetAckId ())
180           )
181         \{
182           \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.erase (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});   \textcolor{comment}{// Erase the same maintain buffer entry for
       the promisc received packet}
183           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
184         \}
185     \}
186   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
187 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 17




Here is the caller graph for this function\+:
% FIG 18


\index{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}!Purge@{Purge}}
\index{Purge@{Purge}!ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}}
\subsubsection[{\texorpdfstring{Purge()}{Purge()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer\+::\+Purge (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrMaintainBuffer_af12ee29b56abcaac29b60c0a544494b9}{}\label{classns3_1_1dsr_1_1DsrMaintainBuffer_af12ee29b56abcaac29b60c0a544494b9}


Remove all expired entries. 


\begin{DoxyCode}
224 \{
225   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Purging Maintenance Buffer"});
226   IsExpired pred;
227   \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.erase (std::remove\_if (\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.begin (), 
      \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.end (), pred),
228                           \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{m\_maintainBuffer}.end ());
229 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 19


\index{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}!Set\+Maintain\+Buffer\+Timeout@{Set\+Maintain\+Buffer\+Timeout}}
\index{Set\+Maintain\+Buffer\+Timeout@{Set\+Maintain\+Buffer\+Timeout}!ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}}
\subsubsection[{\texorpdfstring{Set\+Maintain\+Buffer\+Timeout(\+Time t)}{SetMaintainBufferTimeout(Time t)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer\+::\+Set\+Maintain\+Buffer\+Timeout (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{t}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classns3_1_1dsr_1_1DsrMaintainBuffer_a480bdf66ecdb34f06413d76dcacd77e9}{}\label{classns3_1_1dsr_1_1DsrMaintainBuffer_a480bdf66ecdb34f06413d76dcacd77e9}

\begin{DoxyCode}
284   \{
285     \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a054cbdee77cd0a61520726c2fc72912c}{m\_maintainBufferTimeout} = t;
286   \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 20


\index{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}!Set\+Max\+Queue\+Len@{Set\+Max\+Queue\+Len}}
\index{Set\+Max\+Queue\+Len@{Set\+Max\+Queue\+Len}!ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}}
\subsubsection[{\texorpdfstring{Set\+Max\+Queue\+Len(uint32\+\_\+t len)}{SetMaxQueueLen(uint32_t len)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer\+::\+Set\+Max\+Queue\+Len (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classns3_1_1dsr_1_1DsrMaintainBuffer_a1e52f7157e94aea3e44003e9da22e7ff}{}\label{classns3_1_1dsr_1_1DsrMaintainBuffer_a1e52f7157e94aea3e44003e9da22e7ff}

\begin{DoxyCode}
276   \{
277     \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a497cea8ef3a7d5ee9db88e8cc0b8a365}{m\_maxLen} = len;
278   \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 21




\subsection{Member Data Documentation}
\index{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}!m\+\_\+all\+Network\+Key@{m\+\_\+all\+Network\+Key}}
\index{m\+\_\+all\+Network\+Key@{m\+\_\+all\+Network\+Key}!ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}}
\subsubsection[{\texorpdfstring{m\+\_\+all\+Network\+Key}{m_allNetworkKey}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<${\bf Network\+Key}$>$ ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer\+::m\+\_\+all\+Network\+Key\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrMaintainBuffer_a3ba935c313adf894d20e612dbab825a3}{}\label{classns3_1_1dsr_1_1DsrMaintainBuffer_a3ba935c313adf894d20e612dbab825a3}
\index{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}!m\+\_\+maintain\+Buffer@{m\+\_\+maintain\+Buffer}}
\index{m\+\_\+maintain\+Buffer@{m\+\_\+maintain\+Buffer}!ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}}
\subsubsection[{\texorpdfstring{m\+\_\+maintain\+Buffer}{m_maintainBuffer}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<${\bf Dsr\+Maintain\+Buff\+Entry}$>$ ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer\+::m\+\_\+maintain\+Buffer\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}{}\label{classns3_1_1dsr_1_1DsrMaintainBuffer_a942fc86793c5a6f538a9f0bd69709ce9}


The vector of maintain buffer entries. 

\index{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}!m\+\_\+maintain\+Buffer\+Timeout@{m\+\_\+maintain\+Buffer\+Timeout}}
\index{m\+\_\+maintain\+Buffer\+Timeout@{m\+\_\+maintain\+Buffer\+Timeout}!ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}}
\subsubsection[{\texorpdfstring{m\+\_\+maintain\+Buffer\+Timeout}{m_maintainBufferTimeout}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer\+::m\+\_\+maintain\+Buffer\+Timeout\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrMaintainBuffer_a054cbdee77cd0a61520726c2fc72912c}{}\label{classns3_1_1dsr_1_1DsrMaintainBuffer_a054cbdee77cd0a61520726c2fc72912c}


The maximum period of time that a routing protocol is allowed to buffer a packet for, seconds. 

\index{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}!m\+\_\+max\+Len@{m\+\_\+max\+Len}}
\index{m\+\_\+max\+Len@{m\+\_\+max\+Len}!ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer@{ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Len}{m_maxLen}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::dsr\+::\+Dsr\+Maintain\+Buffer\+::m\+\_\+max\+Len\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrMaintainBuffer_a497cea8ef3a7d5ee9db88e8cc0b8a365}{}\label{classns3_1_1dsr_1_1DsrMaintainBuffer_a497cea8ef3a7d5ee9db88e8cc0b8a365}


The maximum number of packets that we allow a routing protocol to buffer. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
dsr/model/\hyperlink{dsr-maintain-buff_8h}{dsr-\/maintain-\/buff.\+h}\item 
dsr/model/\hyperlink{dsr-maintain-buff_8cc}{dsr-\/maintain-\/buff.\+cc}\end{DoxyCompactItemize}
