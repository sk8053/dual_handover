\hypertarget{classns3_1_1SimpleNetDevice}{}\section{ns3\+:\+:Simple\+Net\+Device Class Reference}
\label{classns3_1_1SimpleNetDevice}\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}


simple net device for simple things and testing  




{\ttfamily \#include $<$simple-\/net-\/device.\+h$>$}



Inheritance diagram for ns3\+:\+:Simple\+Net\+Device\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Simple\+Net\+Device\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1SimpleNetDevice_ae329d675dae831a9e0534f02f415cf3e}{Simple\+Net\+Device} ()
\item 
void \hyperlink{classns3_1_1SimpleNetDevice_af603805c6f3145bde3e53c4c0d5108bc}{Receive} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, uint16\+\_\+t protocol, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} to, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} \hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from})
\item 
void \hyperlink{classns3_1_1SimpleNetDevice_af9e9828ad584b5ba538f18f645f162e0}{Set\+Channel} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1SimpleChannel}{Simple\+Channel} $>$ channel)
\item 
void \hyperlink{classns3_1_1SimpleNetDevice_a48c08632e053a5359157b9b3351099cc}{Set\+Queue} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Queue}{Queue}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ queue)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Queue}{Queue}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1SimpleNetDevice_ab37f84da2d0755a6d353993dfa2cdc26}{Get\+Queue} (void) const 
\item 
void \hyperlink{classns3_1_1SimpleNetDevice_a8674cbc75fa8504bbf6c27b2ca1f5129}{Set\+Receive\+Error\+Model} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1ErrorModel}{Error\+Model} $>$ em)
\item 
virtual void \hyperlink{classns3_1_1SimpleNetDevice_abff4bf773c14b7ca7839f9347213604c}{Set\+If\+Index} (const uint32\+\_\+t index)
\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1SimpleNetDevice_ad49c077636c82c11b3d76dcb12dfa203}{Get\+If\+Index} (void) const 
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Channel}{Channel} $>$ \hyperlink{classns3_1_1SimpleNetDevice_a4748d625a099333fed4fc1df2a4f0a09}{Get\+Channel} (void) const 
\item 
virtual void \hyperlink{classns3_1_1SimpleNetDevice_a968ef3e7318bac29d5f1d7d977029af4}{Set\+Address} (\hyperlink{classns3_1_1Address}{Address} address)
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1SimpleNetDevice_a813ed60e4386e8f46493a575f636606a}{Get\+Address} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1SimpleNetDevice_ab41676e626a91832291bcfbd55ee454a}{Set\+Mtu} (const uint16\+\_\+t mtu)
\item 
virtual uint16\+\_\+t \hyperlink{classns3_1_1SimpleNetDevice_a6bb1552655bbede11e48a9b434121bab}{Get\+Mtu} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1SimpleNetDevice_a61cee25d8d343244b62e394eedb526af}{Is\+Link\+Up} (void) const 
\item 
virtual void \hyperlink{classns3_1_1SimpleNetDevice_a85b4dd806dece39ff9c3902ed3456b04}{Add\+Link\+Change\+Callback} (\hyperlink{classns3_1_1Callback}{Callback}$<$ void $>$ callback)
\item 
virtual bool \hyperlink{classns3_1_1SimpleNetDevice_a53d2af47f16c3b172be6435f7e2d4976}{Is\+Broadcast} (void) const 
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1SimpleNetDevice_a50a2dbd27be1d33af97d703908a3ba57}{Get\+Broadcast} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1SimpleNetDevice_a49e6930a1e47be195f99367758ca3537}{Is\+Multicast} (void) const 
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1SimpleNetDevice_acac0807d0647b4593ae30693ddd16d33}{Get\+Multicast} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} multicast\+Group) const 
\begin{DoxyCompactList}\small\item\em Make and return a M\+AC multicast address using the provided multicast group. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1SimpleNetDevice_a2549fed286122c09101730c1a9b2b68a}{Is\+Point\+To\+Point} (void) const 
\begin{DoxyCompactList}\small\item\em Return true if the net device is on a point-\/to-\/point link. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1SimpleNetDevice_ab163b11dc02f9b8561ea279bd27915b9}{Is\+Bridge} (void) const 
\begin{DoxyCompactList}\small\item\em Return true if the net device is acting as a bridge. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1SimpleNetDevice_a06e3ace212b01f6c1fd6ea7ec50ea805}{Send} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, const \hyperlink{classns3_1_1Address}{Address} \&dest, uint16\+\_\+t protocol\+Number)
\item 
virtual bool \hyperlink{classns3_1_1SimpleNetDevice_a82e090821f8f289e4f226153b6443b57}{Send\+From} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, const \hyperlink{classns3_1_1Address}{Address} \&source, const \hyperlink{classns3_1_1Address}{Address} \&dest, uint16\+\_\+t protocol\+Number)
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1SimpleNetDevice_a606cb9d610593669b03efe0f52ff97f1}{Get\+Node} (void) const 
\item 
virtual void \hyperlink{classns3_1_1SimpleNetDevice_a7b0e64c1e4ee9841de0a892db96ddd68}{Set\+Node} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node)
\item 
virtual bool \hyperlink{classns3_1_1SimpleNetDevice_ae21a0688a1aa4145b006754ca38fe3ca}{Needs\+Arp} (void) const 
\item 
virtual void \hyperlink{classns3_1_1SimpleNetDevice_a76c5853338b7adac83c6388a4c0f0258}{Set\+Receive\+Callback} (\hyperlink{classns3_1_1NetDevice_ad5e5e1ca187472bc2ba99575d8def568}{Net\+Device\+::\+Receive\+Callback} cb)
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1SimpleNetDevice_aa68f34d64eb2bb2c134cc78e8e4fc78e}{Get\+Multicast} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} addr) const 
\begin{DoxyCompactList}\small\item\em Get the M\+AC multicast address corresponding to the I\+Pv6 address provided. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1SimpleNetDevice_a8a2bb1be033ff108e148582ff0ec6472}{Set\+Promisc\+Receive\+Callback} (\hyperlink{classns3_1_1NetDevice_a427225795919f26c414bee2ea3f31ed2}{Promisc\+Receive\+Callback} cb)
\item 
virtual bool \hyperlink{classns3_1_1SimpleNetDevice_a9a2542634b341889f91c3d1dd35493c4}{Supports\+Send\+From} (void) const 
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1SimpleNetDevice_a7408afc44fb59d120b5510882eb70339}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1SimpleNetDevice_ae58a759464c2ceb52247b08a6a8ea5c6}{Do\+Dispose} (void)
\item 
virtual void \hyperlink{classns3_1_1SimpleNetDevice_ab8f09c559877b0568e793755b176a83c}{Do\+Initialize} (void)
\item 
virtual void \hyperlink{classns3_1_1SimpleNetDevice_a956746ef9cede86e9fda72fa85770dd2}{Notify\+New\+Aggregate} (void)
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classns3_1_1SimpleNetDevice_aa889ff3b3b3d94d9784f4984309bca4c}{Transmit\+Complete} (void)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1SimpleChannel}{Simple\+Channel} $>$ \hyperlink{classns3_1_1SimpleNetDevice_aac80c92fff8c2a189c1186d8d41a4808}{m\+\_\+channel}
\begin{DoxyCompactList}\small\item\em the channel the device is connected to \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1NetDevice_ad5e5e1ca187472bc2ba99575d8def568}{Net\+Device\+::\+Receive\+Callback} \hyperlink{classns3_1_1SimpleNetDevice_a4e05eb44dc92b79880d7b2f9d7080afb}{m\+\_\+rx\+Callback}
\begin{DoxyCompactList}\small\item\em Receive callback. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1NetDevice_a427225795919f26c414bee2ea3f31ed2}{Net\+Device\+::\+Promisc\+Receive\+Callback} \hyperlink{classns3_1_1SimpleNetDevice_ad791745401d21961805c25572ccd7458}{m\+\_\+promisc\+Callback}
\begin{DoxyCompactList}\small\item\em Promiscuous receive callback. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1SimpleNetDevice_abf59768bbf6b40baef7d8dd6ed6028be}{m\+\_\+node}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Node}{Node} this net\+Device is associated to. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDeviceQueueInterface}{Net\+Device\+Queue\+Interface} $>$ \hyperlink{classns3_1_1SimpleNetDevice_a35bd6983512fe87988362fa02f6425e7}{m\+\_\+queue\+Interface}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1NetDevice}{Net\+Device} queue interface. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1SimpleNetDevice_aab2aea73b33a02c23f8d417214a0d2a0}{m\+\_\+mtu}
\begin{DoxyCompactList}\small\item\em M\+TU. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1SimpleNetDevice_ac2deeed77b8fcf06389ca7c1b56ac01f}{m\+\_\+if\+Index}
\begin{DoxyCompactList}\small\item\em Interface index. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} \hyperlink{classns3_1_1SimpleNetDevice_ac3dda22026d7c5fbbba243db41e0e2dd}{m\+\_\+address}
\begin{DoxyCompactList}\small\item\em M\+AC address. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1ErrorModel}{Error\+Model} $>$ \hyperlink{classns3_1_1SimpleNetDevice_aabf566ae9e1c8351769da712e7da1177}{m\+\_\+receive\+Error\+Model}
\begin{DoxyCompactList}\small\item\em Receive error model. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1SimpleNetDevice_a1ff8de95910e13b1fe6c9b5c07a6f721}{m\+\_\+phy\+Rx\+Drop\+Trace}
\item 
bool \hyperlink{classns3_1_1SimpleNetDevice_a923c93f1baab5ab677054a569eb88c53}{m\+\_\+link\+Up}
\begin{DoxyCompactList}\small\item\em Flag indicating whether or not the link is up. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1SimpleNetDevice_a9e0e98464addc8f65a1e95a405b7119c}{m\+\_\+point\+To\+Point\+Mode}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Queue}{Queue}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1SimpleNetDevice_a72e1e606223c7e4683f64259d14ef065}{m\+\_\+queue}
\begin{DoxyCompactList}\small\item\em The \hyperlink{classns3_1_1Queue}{Queue} for outgoing packets. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1DataRate}{Data\+Rate} \hyperlink{classns3_1_1SimpleNetDevice_a6655e469fb351d5c541abf96c2928daa}{m\+\_\+bps}
\begin{DoxyCompactList}\small\item\em The device nominal Data rate. Zero means infinite. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1EventId}{Event\+Id} \hyperlink{classns3_1_1SimpleNetDevice_ad6fa5b2d21a557883c8c6d615ee6f066}{Transmit\+Complete\+Event}
\begin{DoxyCompactList}\small\item\em the Tx Complete event \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback} \hyperlink{classns3_1_1SimpleNetDevice_a209f4157e8168195227cc6271b6f77f8}{m\+\_\+link\+Change\+Callbacks}
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
simple net device for simple things and testing 

This device assumes 48-\/bit mac addressing; there is also the possibility to add an \hyperlink{classns3_1_1ErrorModel}{Error\+Model} if you want to force losses on the device.

The device can be installed on a node through the \hyperlink{classns3_1_1SimpleNetDeviceHelper}{Simple\+Net\+Device\+Helper}. In case of manual creation, the user is responsible for assigning an unique address to the device.

By default the device is in Broadcast mode, with infinite bandwidth. 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Simple\+Net\+Device@{Simple\+Net\+Device}}
\index{Simple\+Net\+Device@{Simple\+Net\+Device}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Simple\+Net\+Device()}{SimpleNetDevice()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Simple\+Net\+Device\+::\+Simple\+Net\+Device (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1SimpleNetDevice_ae329d675dae831a9e0534f02f415cf3e}{}\label{classns3_1_1SimpleNetDevice_ae329d675dae831a9e0534f02f415cf3e}

\begin{DoxyCode}
223   : \hyperlink{classns3_1_1SimpleNetDevice_aac80c92fff8c2a189c1186d8d41a4808}{m\_channel} (0),
224     \hyperlink{classns3_1_1SimpleNetDevice_abf59768bbf6b40baef7d8dd6ed6028be}{m\_node} (0),
225     \hyperlink{classns3_1_1SimpleNetDevice_aab2aea73b33a02c23f8d417214a0d2a0}{m\_mtu} (0xffff),
226     \hyperlink{classns3_1_1SimpleNetDevice_ac2deeed77b8fcf06389ca7c1b56ac01f}{m\_ifIndex} (0),
227     \hyperlink{classns3_1_1SimpleNetDevice_a923c93f1baab5ab677054a569eb88c53}{m\_linkUp} (\textcolor{keyword}{false})
228 \{
229   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
230 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Add\+Link\+Change\+Callback@{Add\+Link\+Change\+Callback}}
\index{Add\+Link\+Change\+Callback@{Add\+Link\+Change\+Callback}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Add\+Link\+Change\+Callback(\+Callback$<$ void $>$ callback)}{AddLinkChangeCallback(Callback< void > callback)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Simple\+Net\+Device\+::\+Add\+Link\+Change\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Callback}$<$ void $>$}]{callback}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1SimpleNetDevice_a85b4dd806dece39ff9c3902ed3456b04}{}\label{classns3_1_1SimpleNetDevice_a85b4dd806dece39ff9c3902ed3456b04}

\begin{DoxyParams}{Parameters}
{\em callback} & the callback to invoke\\
\hline
\end{DoxyParams}
Add a callback invoked whenever the link status changes to UP. This callback is typically used by the I\+P/\+A\+RP layer to flush the A\+RP cache and by I\+Pv6 stack to flush N\+D\+I\+SC cache whenever the link goes up. 

Implements \hyperlink{classns3_1_1NetDevice_aafb1bf869d38ef7a7112d11fab0163a3}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
392 \{
393  \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << &callback);
394  \hyperlink{classns3_1_1SimpleNetDevice_a209f4157e8168195227cc6271b6f77f8}{m\_linkChangeCallbacks}.\hyperlink{classns3_1_1TracedCallback_aacc251bf4e302e7d034e9f0e25a15980}{ConnectWithoutContext} (callback);
395 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Do\+Dispose(void)}{DoDispose(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Simple\+Net\+Device\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1SimpleNetDevice_ae58a759464c2ceb52247b08a6a8ea5c6}{}\label{classns3_1_1SimpleNetDevice_ae58a759464c2ceb52247b08a6a8ea5c6}
Destructor implementation.

This method is called by \hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose()} or by the \hyperlink{classns3_1_1Object}{Object}\textquotesingle{}s destructor, whichever comes first.

Subclasses are expected to implement their real destruction code in an overriden version of this method and chain up to their parent\textquotesingle{}s implementation once they are done. {\itshape i.\+e}, for simplicity, the destructor of every subclass should be empty and its content should be moved to the associated \hyperlink{classns3_1_1SimpleNetDevice_ae58a759464c2ceb52247b08a6a8ea5c6}{Do\+Dispose()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.



Reimplemented in \hyperlink{classns3_1_1LteSimpleNetDevice_a17aab870134e5a6c8a8bca6f9767c559}{ns3\+::\+Lte\+Simple\+Net\+Device}.


\begin{DoxyCode}
569 \{
570   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
571   \hyperlink{classns3_1_1SimpleNetDevice_aac80c92fff8c2a189c1186d8d41a4808}{m\_channel} = 0;
572   \hyperlink{classns3_1_1SimpleNetDevice_abf59768bbf6b40baef7d8dd6ed6028be}{m\_node} = 0;
573   \hyperlink{classns3_1_1SimpleNetDevice_aabf566ae9e1c8351769da712e7da1177}{m\_receiveErrorModel} = 0;
574   \hyperlink{classns3_1_1SimpleNetDevice_a72e1e606223c7e4683f64259d14ef065}{m\_queue}->Flush ();
575   \hyperlink{classns3_1_1SimpleNetDevice_a35bd6983512fe87988362fa02f6425e7}{m\_queueInterface} = 0;
576   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1SimpleNetDevice_ad6fa5b2d21a557883c8c6d615ee6f066}{TransmitCompleteEvent}.\hyperlink{classns3_1_1EventId_aabf8476d1a080c199ea0c6aa9ccea372}{IsRunning} ())
577     \{
578       \hyperlink{classns3_1_1SimpleNetDevice_ad6fa5b2d21a557883c8c6d615ee6f066}{TransmitCompleteEvent}.\hyperlink{classns3_1_1EventId_a993ae94e48e014e1afd47edb16db7a11}{Cancel} ();
579     \}
580   \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{NetDevice::DoDispose} ();
581 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3




Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Do\+Initialize@{Do\+Initialize}}
\index{Do\+Initialize@{Do\+Initialize}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Do\+Initialize(void)}{DoInitialize(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Simple\+Net\+Device\+::\+Do\+Initialize (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1SimpleNetDevice_ab8f09c559877b0568e793755b176a83c}{}\label{classns3_1_1SimpleNetDevice_ab8f09c559877b0568e793755b176a83c}
\hyperlink{classns3_1_1Object_af4411cb29971772fcd09203474a95078}{Initialize()} implementation.

This method is called only once by \hyperlink{classns3_1_1Object_af4411cb29971772fcd09203474a95078}{Initialize()}. If the user calls \hyperlink{classns3_1_1Object_af4411cb29971772fcd09203474a95078}{Initialize()} multiple times, \hyperlink{classns3_1_1SimpleNetDevice_ab8f09c559877b0568e793755b176a83c}{Do\+Initialize()} is called only the first time.

Subclasses are expected to override this method and chain up to their parent\textquotesingle{}s implementation once they are done. It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} and \hyperlink{classns3_1_1Object_a79dd435d300f3deca814553f561a2922}{Aggregate\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_af8482a521433409fb5c7f749398c9dbe}{ns3\+::\+Object}.



Reimplemented in \hyperlink{classns3_1_1LteSimpleNetDevice_a284ce8bd7312c98107e4cf584c4fd8b1}{ns3\+::\+Lte\+Simple\+Net\+Device}.


\begin{DoxyCode}
234 \{
235   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1SimpleNetDevice_a35bd6983512fe87988362fa02f6425e7}{m\_queueInterface})
236     \{
237       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\hyperlink{classns3_1_1SimpleNetDevice_a72e1e606223c7e4683f64259d14ef065}{m\_queue} != 0, \textcolor{stringliteral}{"A Queue object has not been attached to the device"}
      );
238 
239       \textcolor{comment}{// connect the traced callbacks of m\_queue to the static methods provided by}
240       \textcolor{comment}{// the NetDeviceQueue class to support flow control and dynamic queue limits.}
241       \textcolor{comment}{// This could not be done in NotifyNewAggregate because at that time we are}
242       \textcolor{comment}{// not guaranteed that a queue has been attached to the netdevice}
243       \hyperlink{classns3_1_1SimpleNetDevice_a35bd6983512fe87988362fa02f6425e7}{m\_queueInterface}->ConnectQueueTraces (\hyperlink{classns3_1_1SimpleNetDevice_a72e1e606223c7e4683f64259d14ef065}{m\_queue}, 0);
244     \}
245 
246   \hyperlink{classns3_1_1Object_af8482a521433409fb5c7f749398c9dbe}{NetDevice::DoInitialize} ();
247 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5


\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Get\+Address@{Get\+Address}}
\index{Get\+Address@{Get\+Address}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Address(void) const }{GetAddress(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Simple\+Net\+Device\+::\+Get\+Address (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1SimpleNetDevice_a813ed60e4386e8f46493a575f636606a}{}\label{classns3_1_1SimpleNetDevice_a813ed60e4386e8f46493a575f636606a}
\begin{DoxyReturn}{Returns}
the current \hyperlink{classns3_1_1Address}{Address} of this interface. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a671f99de496d6f09ae343bb715301fb2}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
364 \{
365   \textcolor{comment}{//}
366   \textcolor{comment}{// Implicit conversion from Mac48Address to Address}
367   \textcolor{comment}{//}
368   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
369   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1SimpleNetDevice_ac3dda22026d7c5fbbba243db41e0e2dd}{m\_address};
370 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Get\+Broadcast@{Get\+Broadcast}}
\index{Get\+Broadcast@{Get\+Broadcast}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Broadcast(void) const }{GetBroadcast(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Simple\+Net\+Device\+::\+Get\+Broadcast (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1SimpleNetDevice_a50a2dbd27be1d33af97d703908a3ba57}{}\label{classns3_1_1SimpleNetDevice_a50a2dbd27be1d33af97d703908a3ba57}
\begin{DoxyReturn}{Returns}
the broadcast address supported by this netdevice.
\end{DoxyReturn}
Calling this method is invalid if Is\+Broadcast returns not true. 

Implements \hyperlink{classns3_1_1NetDevice_a4724e03bc548dd8e967cc4a7356197bd}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
408 \{
409   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
410   \textcolor{keywordflow}{return} Mac48Address (\textcolor{stringliteral}{"ff:ff:ff:ff:ff:ff"});
411 \}
\end{DoxyCode}
\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Get\+Channel@{Get\+Channel}}
\index{Get\+Channel@{Get\+Channel}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Channel(void) const }{GetChannel(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Channel} $>$ ns3\+::\+Simple\+Net\+Device\+::\+Get\+Channel (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1SimpleNetDevice_a4748d625a099333fed4fc1df2a4f0a09}{}\label{classns3_1_1SimpleNetDevice_a4748d625a099333fed4fc1df2a4f0a09}
\begin{DoxyReturn}{Returns}
the channel this \hyperlink{classns3_1_1NetDevice}{Net\+Device} is connected to. The value returned can be zero if the \hyperlink{classns3_1_1NetDevice}{Net\+Device} is not yet connected to any channel or if the underlying \hyperlink{classns3_1_1NetDevice}{Net\+Device} has no concept of a channel. i.\+e., callers {\itshape must} check for zero and be ready to handle it. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a3d810bd2738634e2e851661271828565}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
352 \{
353   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
354   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1SimpleNetDevice_aac80c92fff8c2a189c1186d8d41a4808}{m\_channel};
355 \}
\end{DoxyCode}
\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Get\+If\+Index@{Get\+If\+Index}}
\index{Get\+If\+Index@{Get\+If\+Index}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+If\+Index(void) const }{GetIfIndex(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Simple\+Net\+Device\+::\+Get\+If\+Index (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1SimpleNetDevice_ad49c077636c82c11b3d76dcb12dfa203}{}\label{classns3_1_1SimpleNetDevice_ad49c077636c82c11b3d76dcb12dfa203}
\begin{DoxyReturn}{Returns}
index if\+Index of the device 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a8c1ae2ec8eadc4524dfc1e425bfa0850}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
346 \{
347   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
348   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1SimpleNetDevice_ac2deeed77b8fcf06389ca7c1b56ac01f}{m\_ifIndex};
349 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Get\+Mtu@{Get\+Mtu}}
\index{Get\+Mtu@{Get\+Mtu}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Mtu(void) const }{GetMtu(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Simple\+Net\+Device\+::\+Get\+Mtu (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1SimpleNetDevice_a6bb1552655bbede11e48a9b434121bab}{}\label{classns3_1_1SimpleNetDevice_a6bb1552655bbede11e48a9b434121bab}
\begin{DoxyReturn}{Returns}
the link-\/level M\+TU in bytes for this interface.
\end{DoxyReturn}
This value is typically used by the IP layer to perform IP fragmentation when needed. 

Implements \hyperlink{classns3_1_1NetDevice_a91f4f5d01bc2d567c1e0a69b63a4cf14}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
380 \{
381   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
382   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1SimpleNetDevice_aab2aea73b33a02c23f8d417214a0d2a0}{m\_mtu};
383 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Get\+Multicast@{Get\+Multicast}}
\index{Get\+Multicast@{Get\+Multicast}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Multicast(\+Ipv4\+Address multicast\+Group) const }{GetMulticast(Ipv4Address multicastGroup) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Simple\+Net\+Device\+::\+Get\+Multicast (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{multicast\+Group}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1SimpleNetDevice_acac0807d0647b4593ae30693ddd16d33}{}\label{classns3_1_1SimpleNetDevice_acac0807d0647b4593ae30693ddd16d33}


Make and return a M\+AC multicast address using the provided multicast group. 

\{1112\} says that an \hyperlink{classns3_1_1Ipv4}{Ipv4} host group address is mapped to an Ethernet multicast address by placing the low-\/order 23-\/bits of the IP address into the low-\/order 23 bits of the Ethernet multicast address 01-\/00-\/5\+E-\/00-\/00-\/00 (hex). Similar R\+F\+Cs exist for \hyperlink{classns3_1_1Ipv6}{Ipv6} and Eui64 mappings. This method performs the multicast address creation function appropriate to the underlying M\+AC address of the device. This M\+AC address is encapsulated in an abstract \hyperlink{classns3_1_1Address}{Address} to avoid dependencies on the exact M\+AC address format.

In the case of net devices that do not support multicast, clients are expected to test \hyperlink{classns3_1_1NetDevice_a1afb4848a9226540f1ff51f9b31ae95e}{Net\+Device\+::\+Is\+Multicast} and avoid attempting to map multicast packets. Subclasses of \hyperlink{classns3_1_1NetDevice}{Net\+Device} that do support multicasting are expected to override this method and provide an implementation appropriate to the particular device.


\begin{DoxyParams}{Parameters}
{\em multicast\+Group} & The IP address for the multicast group destination of the packet. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The M\+AC multicast \hyperlink{classns3_1_1Address}{Address} used to send packets to the provided multicast group.
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Calling this method is invalid if Is\+Multicast returns not true. 
\end{DoxyWarning}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1SimpleNetDevice_a49e6930a1e47be195f99367758ca3537}{Is\+Multicast()} 
\end{DoxySeeAlso}


Implements \hyperlink{classns3_1_1NetDevice_a98aa4852df367b6a393c8cc1d88af0d9}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
424 \{
425   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << multicastGroup);
426   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Mac48Address_a23d170f8c7a7d90a8110425620285819}{Mac48Address::GetMulticast} (multicastGroup);
427 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9


\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Get\+Multicast@{Get\+Multicast}}
\index{Get\+Multicast@{Get\+Multicast}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Multicast(\+Ipv6\+Address addr) const }{GetMulticast(Ipv6Address addr) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Simple\+Net\+Device\+::\+Get\+Multicast (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{addr}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1SimpleNetDevice_aa68f34d64eb2bb2c134cc78e8e4fc78e}{}\label{classns3_1_1SimpleNetDevice_aa68f34d64eb2bb2c134cc78e8e4fc78e}


Get the M\+AC multicast address corresponding to the I\+Pv6 address provided. 


\begin{DoxyParams}{Parameters}
{\em addr} & I\+Pv6 address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the M\+AC multicast address 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Calling this method is invalid if Is\+Multicast returns not true. 
\end{DoxyWarning}


Implements \hyperlink{classns3_1_1NetDevice_a46479a2c0101c6f9da9251ed4d7575bd}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
430 \{
431   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << addr);
432   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Mac48Address_a23d170f8c7a7d90a8110425620285819}{Mac48Address::GetMulticast} (addr);
433 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10


\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Get\+Node@{Get\+Node}}
\index{Get\+Node@{Get\+Node}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Node(void) const }{GetNode(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Node} $>$ ns3\+::\+Simple\+Net\+Device\+::\+Get\+Node (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1SimpleNetDevice_a606cb9d610593669b03efe0f52ff97f1}{}\label{classns3_1_1SimpleNetDevice_a606cb9d610593669b03efe0f52ff97f1}
\begin{DoxyReturn}{Returns}
the node base class which contains this network interface.
\end{DoxyReturn}
When a subclass needs to get access to the underlying node base class to print the nodeid for example, it can invoke this method. 

Implements \hyperlink{classns3_1_1NetDevice_a098b6cc4339ac00c62e75cfa48c8aeac}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
540 \{
541   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
542   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1SimpleNetDevice_abf59768bbf6b40baef7d8dd6ed6028be}{m\_node};
543 \}
\end{DoxyCode}
\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Get\+Queue@{Get\+Queue}}
\index{Get\+Queue@{Get\+Queue}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Queue(void) const }{GetQueue(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Queue}$<$ {\bf Packet} $>$ $>$ ns3\+::\+Simple\+Net\+Device\+::\+Get\+Queue (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1SimpleNetDevice_ab37f84da2d0755a6d353993dfa2cdc26}{}\label{classns3_1_1SimpleNetDevice_ab37f84da2d0755a6d353993dfa2cdc26}
Get a copy of the attached \hyperlink{classns3_1_1Queue}{Queue}.

\begin{DoxyReturn}{Returns}
\hyperlink{classns3_1_1Ptr}{Ptr} to the queue. 
\end{DoxyReturn}

\begin{DoxyCode}
319 \{
320   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
321   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1SimpleNetDevice_a72e1e606223c7e4683f64259d14ef065}{m\_queue};
322 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Simple\+Net\+Device\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1SimpleNetDevice_a7408afc44fb59d120b5510882eb70339}{}\label{classns3_1_1SimpleNetDevice_a7408afc44fb59d120b5510882eb70339}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
188 \{
189   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::SimpleNetDevice"})
190     .SetParent<NetDevice> ()
191     .SetGroupName(\textcolor{stringliteral}{"Network"}) 
192     .AddConstructor<\hyperlink{classns3_1_1SimpleNetDevice_ae329d675dae831a9e0534f02f415cf3e}{SimpleNetDevice}> ()
193     .AddAttribute (\textcolor{stringliteral}{"ReceiveErrorModel"},
194                    \textcolor{stringliteral}{"The receiver error model used to simulate packet loss"},
195                    PointerValue (),
196                    MakePointerAccessor (&\hyperlink{classns3_1_1SimpleNetDevice_aabf566ae9e1c8351769da712e7da1177}{SimpleNetDevice::m\_receiveErrorModel}
      ),
197                    MakePointerChecker<ErrorModel> ())
198     .AddAttribute (\textcolor{stringliteral}{"PointToPointMode"},
199                    \textcolor{stringliteral}{"The device is configured in Point to Point mode"},
200                    BooleanValue (\textcolor{keyword}{false}),
201                    MakeBooleanAccessor (&\hyperlink{classns3_1_1SimpleNetDevice_a9e0e98464addc8f65a1e95a405b7119c}{SimpleNetDevice::m\_pointToPointMode}
      ),
202                    MakeBooleanChecker ())
203     .AddAttribute (\textcolor{stringliteral}{"TxQueue"},
204                    \textcolor{stringliteral}{"A queue to use as the transmit queue in the device."},
205                    StringValue (\textcolor{stringliteral}{"ns3::DropTailQueue<Packet>"}),
206                    MakePointerAccessor (&\hyperlink{classns3_1_1SimpleNetDevice_a72e1e606223c7e4683f64259d14ef065}{SimpleNetDevice::m\_queue}),
207                    \hyperlink{namespacens3_a8cd81c2f226bc23ad44a259717e6da15}{MakePointerChecker}<Queue<Packet> > ())
208     .AddAttribute (\textcolor{stringliteral}{"DataRate"},
209                    \textcolor{stringliteral}{"The default data rate for point to point links. Zero means infinite"},
210                    DataRateValue (DataRate (\textcolor{stringliteral}{"0b/s"})),
211                    MakeDataRateAccessor (&\hyperlink{classns3_1_1SimpleNetDevice_a6655e469fb351d5c541abf96c2928daa}{SimpleNetDevice::m\_bps}),
212                    MakeDataRateChecker ())
213     .AddTraceSource (\textcolor{stringliteral}{"PhyRxDrop"},
214                      \textcolor{stringliteral}{"Trace source indicating a packet has been dropped "}
215                      \textcolor{stringliteral}{"by the device during reception"},
216                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1SimpleNetDevice_a1ff8de95910e13b1fe6c9b5c07a6f721}{SimpleNetDevice::m\_phyRxDropTrace}),
217                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
218   ;
219   \textcolor{keywordflow}{return} tid;
220 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12


\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Is\+Bridge@{Is\+Bridge}}
\index{Is\+Bridge@{Is\+Bridge}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Bridge(void) const }{IsBridge(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Simple\+Net\+Device\+::\+Is\+Bridge (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1SimpleNetDevice_ab163b11dc02f9b8561ea279bd27915b9}{}\label{classns3_1_1SimpleNetDevice_ab163b11dc02f9b8561ea279bd27915b9}


Return true if the net device is acting as a bridge. 

\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Bridge flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a9d34556a1c83a69dacb08698ca4a1d94}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
448 \{
449   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
450   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
451 \}
\end{DoxyCode}
\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Is\+Broadcast@{Is\+Broadcast}}
\index{Is\+Broadcast@{Is\+Broadcast}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Broadcast(void) const }{IsBroadcast(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Simple\+Net\+Device\+::\+Is\+Broadcast (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1SimpleNetDevice_a53d2af47f16c3b172be6435f7e2d4976}{}\label{classns3_1_1SimpleNetDevice_a53d2af47f16c3b172be6435f7e2d4976}
\begin{DoxyReturn}{Returns}
true if this interface supports a broadcast address, false otherwise. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a67f992b20858cd7b397d8fba2feff141}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
398 \{
399   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
400   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1SimpleNetDevice_a9e0e98464addc8f65a1e95a405b7119c}{m\_pointToPointMode})
401     \{
402       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
403     \}
404   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
405 \}
\end{DoxyCode}
\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Is\+Link\+Up@{Is\+Link\+Up}}
\index{Is\+Link\+Up@{Is\+Link\+Up}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Link\+Up(void) const }{IsLinkUp(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Simple\+Net\+Device\+::\+Is\+Link\+Up (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1SimpleNetDevice_a61cee25d8d343244b62e394eedb526af}{}\label{classns3_1_1SimpleNetDevice_a61cee25d8d343244b62e394eedb526af}
\begin{DoxyReturn}{Returns}
true if link is up; false otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_afe1822b79e19a05ab95f693c8fb64fc7}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
386 \{
387   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
388   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1SimpleNetDevice_a923c93f1baab5ab677054a569eb88c53}{m\_linkUp};
389 \}
\end{DoxyCode}
\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Is\+Multicast@{Is\+Multicast}}
\index{Is\+Multicast@{Is\+Multicast}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Multicast(void) const }{IsMulticast(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Simple\+Net\+Device\+::\+Is\+Multicast (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1SimpleNetDevice_a49e6930a1e47be195f99367758ca3537}{}\label{classns3_1_1SimpleNetDevice_a49e6930a1e47be195f99367758ca3537}
\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Multicast flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a1afb4848a9226540f1ff51f9b31ae95e}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
414 \{
415   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
416   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1SimpleNetDevice_a9e0e98464addc8f65a1e95a405b7119c}{m\_pointToPointMode})
417     \{
418       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
419     \}
420   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
421 \}
\end{DoxyCode}
\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Is\+Point\+To\+Point@{Is\+Point\+To\+Point}}
\index{Is\+Point\+To\+Point@{Is\+Point\+To\+Point}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Point\+To\+Point(void) const }{IsPointToPoint(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Simple\+Net\+Device\+::\+Is\+Point\+To\+Point (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1SimpleNetDevice_a2549fed286122c09101730c1a9b2b68a}{}\label{classns3_1_1SimpleNetDevice_a2549fed286122c09101730c1a9b2b68a}


Return true if the net device is on a point-\/to-\/point link. 

\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Point\+To\+Point flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a718177f25efeaf2dbf8a18fcab87224d}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
437 \{
438   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
439   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1SimpleNetDevice_a9e0e98464addc8f65a1e95a405b7119c}{m\_pointToPointMode})
440     \{
441       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
442     \}
443   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
444 \}
\end{DoxyCode}
\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Needs\+Arp@{Needs\+Arp}}
\index{Needs\+Arp@{Needs\+Arp}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Needs\+Arp(void) const }{NeedsArp(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Simple\+Net\+Device\+::\+Needs\+Arp (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1SimpleNetDevice_ae21a0688a1aa4145b006754ca38fe3ca}{}\label{classns3_1_1SimpleNetDevice_ae21a0688a1aa4145b006754ca38fe3ca}
\begin{DoxyReturn}{Returns}
true if A\+RP is needed, false otherwise.
\end{DoxyReturn}
Called by higher-\/layers to check if this \hyperlink{classns3_1_1NetDevice}{Net\+Device} requires A\+RP to be used. 

Implements \hyperlink{classns3_1_1NetDevice_ab1a133696310cad3dc2c3d1a4993f310}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
552 \{
553   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
554   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1SimpleNetDevice_a9e0e98464addc8f65a1e95a405b7119c}{m\_pointToPointMode})
555     \{
556       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
557     \}
558   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
559 \}
\end{DoxyCode}
\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Notify\+New\+Aggregate@{Notify\+New\+Aggregate}}
\index{Notify\+New\+Aggregate@{Notify\+New\+Aggregate}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Notify\+New\+Aggregate(void)}{NotifyNewAggregate(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Simple\+Net\+Device\+::\+Notify\+New\+Aggregate (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1SimpleNetDevice_a956746ef9cede86e9fda72fa85770dd2}{}\label{classns3_1_1SimpleNetDevice_a956746ef9cede86e9fda72fa85770dd2}
Notify all Objects aggregated to this one of a new \hyperlink{classns3_1_1Object}{Object} being aggregated.

This method is invoked whenever two sets of Objects are aggregated together. It is invoked exactly once for each \hyperlink{classns3_1_1Object}{Object} in both sets. This method can be overriden by subclasses who wish to be notified of aggregation events. These subclasses must chain up to their base class \hyperlink{classns3_1_1SimpleNetDevice_a956746ef9cede86e9fda72fa85770dd2}{Notify\+New\+Aggregate()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} and \hyperlink{classns3_1_1Object_a79dd435d300f3deca814553f561a2922}{Aggregate\+Object()} from within this method.

This function must be implemented in the stack that needs to notify other stacks connected to the node of their presence in the node. 

Reimplemented from \hyperlink{classns3_1_1Object_a1bd7211125185a6cd511c35fea4e500f}{ns3\+::\+Object}.


\begin{DoxyCode}
251 \{
252   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
253   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1SimpleNetDevice_a35bd6983512fe87988362fa02f6425e7}{m\_queueInterface} == 0)
254     \{
255       Ptr<NetDeviceQueueInterface> ndqi = this->GetObject<NetDeviceQueueInterface> ();
256       \textcolor{comment}{//verify that it's a valid netdevice queue interface and that}
257       \textcolor{comment}{//the netdevice queue interface was not set before}
258       \textcolor{keywordflow}{if} (ndqi != 0)
259         \{
260           \hyperlink{classns3_1_1SimpleNetDevice_a35bd6983512fe87988362fa02f6425e7}{m\_queueInterface} = ndqi;
261         \}
262     \}
263   \hyperlink{classns3_1_1Object_a1bd7211125185a6cd511c35fea4e500f}{NetDevice::NotifyNewAggregate} ();
264 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13


\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Receive@{Receive}}
\index{Receive@{Receive}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Receive(\+Ptr$<$ Packet $>$ packet, uint16\+\_\+t protocol, Mac48\+Address to, Mac48\+Address from)}{Receive(Ptr< Packet > packet, uint16_t protocol, Mac48Address to, Mac48Address from)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Simple\+Net\+Device\+::\+Receive (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{uint16\+\_\+t}]{protocol, }
\item[{{\bf Mac48\+Address}}]{to, }
\item[{{\bf Mac48\+Address}}]{from}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1SimpleNetDevice_af603805c6f3145bde3e53c4c0d5108bc}{}\label{classns3_1_1SimpleNetDevice_af603805c6f3145bde3e53c4c0d5108bc}
Receive a packet from a connected \hyperlink{classns3_1_1SimpleChannel}{Simple\+Channel}. The \hyperlink{classns3_1_1SimpleNetDevice}{Simple\+Net\+Device} receives packets from its connected channel and then forwards them by calling its rx callback method


\begin{DoxyParams}{Parameters}
{\em packet} & \hyperlink{classns3_1_1Packet}{Packet} received on the channel \\
\hline
{\em protocol} & protocol number \\
\hline
{\em to} & address packet should be sent to \\
\hline
{\em from} & address packet was sent from \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
269 \{
270   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << protocol << to << \hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from});
271   \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2}{NetDevice::PacketType} packetType;
272 
273   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1SimpleNetDevice_aabf566ae9e1c8351769da712e7da1177}{m\_receiveErrorModel} && \hyperlink{classns3_1_1SimpleNetDevice_aabf566ae9e1c8351769da712e7da1177}{m\_receiveErrorModel}->IsCorrupt (packet) 
      )
274     \{
275       \hyperlink{classns3_1_1SimpleNetDevice_a1ff8de95910e13b1fe6c9b5c07a6f721}{m\_phyRxDropTrace} (packet);
276       \textcolor{keywordflow}{return};
277     \}
278 
279   \textcolor{keywordflow}{if} (to == \hyperlink{classns3_1_1SimpleNetDevice_ac3dda22026d7c5fbbba243db41e0e2dd}{m\_address})
280     \{
281       packetType = \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2a60835731aced24ac0c712ba61e62462e}{NetDevice::PACKET\_HOST};
282     \}
283   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (to.IsBroadcast ())
284     \{
285       packetType = \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2adfeb6a2929cee183836a32fe293ce205}{NetDevice::PACKET\_BROADCAST};
286     \}
287   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (to.IsGroup ())
288     \{
289       packetType = \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2ae3ffb88d364e97f06f662f5d7ba53bbe}{NetDevice::PACKET\_MULTICAST};
290     \}
291   \textcolor{keywordflow}{else} 
292     \{
293       packetType = \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2a60c00fab4286dd2903e2b197a9f8c6c8}{NetDevice::PACKET\_OTHERHOST};
294     \}
295 
296   \textcolor{keywordflow}{if} (packetType != \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2a60c00fab4286dd2903e2b197a9f8c6c8}{NetDevice::PACKET\_OTHERHOST})
297     \{
298       \hyperlink{classns3_1_1SimpleNetDevice_a4e05eb44dc92b79880d7b2f9d7080afb}{m\_rxCallback} (\textcolor{keyword}{this}, packet, protocol, \hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from});
299     \}
300 
301   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1SimpleNetDevice_ad791745401d21961805c25572ccd7458}{m\_promiscCallback}.\hyperlink{classns3_1_1Callback_aa8e27826badbf37f84763f36f70d9b54}{IsNull} ())
302     \{
303       \hyperlink{classns3_1_1SimpleNetDevice_ad791745401d21961805c25572ccd7458}{m\_promiscCallback} (\textcolor{keyword}{this}, packet, protocol, \hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from}, to, packetType);
304     \}
305 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 14




Here is the caller graph for this function\+:
% FIG 15


\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Send@{Send}}
\index{Send@{Send}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Send(\+Ptr$<$ Packet $>$ packet, const Address \&dest, uint16\+\_\+t protocol\+Number)}{Send(Ptr< Packet > packet, const Address &dest, uint16_t protocolNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Simple\+Net\+Device\+::\+Send (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{const {\bf Address} \&}]{dest, }
\item[{uint16\+\_\+t}]{protocol\+Number}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1SimpleNetDevice_a06e3ace212b01f6c1fd6ea7ec50ea805}{}\label{classns3_1_1SimpleNetDevice_a06e3ace212b01f6c1fd6ea7ec50ea805}

\begin{DoxyParams}{Parameters}
{\em packet} & packet sent from above down to Network Device \\
\hline
{\em dest} & mac address of the destination (already resolved) \\
\hline
{\em protocol\+Number} & identifies the type of payload contained in this packet. Used to call the right L3\+Protocol when the packet is received.\\
\hline
\end{DoxyParams}
Called from higher layer to send packet into Network Device to the specified destination \hyperlink{classns3_1_1Address}{Address}

\begin{DoxyReturn}{Returns}
whether the Send operation succeeded 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a59f41afb0fe8951bb94d5739cbe6ee7d}{ns3\+::\+Net\+Device}.



Reimplemented in \hyperlink{classns3_1_1LteSimpleNetDevice_a457313c324927ada27a18bf6ead9082c}{ns3\+::\+Lte\+Simple\+Net\+Device}.


\begin{DoxyCode}
455 \{
456   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << dest << protocolNumber);
457 
458   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1SimpleNetDevice_a82e090821f8f289e4f226153b6443b57}{SendFrom} (packet, \hyperlink{classns3_1_1SimpleNetDevice_ac3dda22026d7c5fbbba243db41e0e2dd}{m\_address}, dest, protocolNumber);
459 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 16




Here is the caller graph for this function\+:
% FIG 17


\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Send\+From@{Send\+From}}
\index{Send\+From@{Send\+From}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Send\+From(\+Ptr$<$ Packet $>$ packet, const Address \&source, const Address \&dest, uint16\+\_\+t protocol\+Number)}{SendFrom(Ptr< Packet > packet, const Address &source, const Address &dest, uint16_t protocolNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Simple\+Net\+Device\+::\+Send\+From (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{const {\bf Address} \&}]{source, }
\item[{const {\bf Address} \&}]{dest, }
\item[{uint16\+\_\+t}]{protocol\+Number}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1SimpleNetDevice_a82e090821f8f289e4f226153b6443b57}{}\label{classns3_1_1SimpleNetDevice_a82e090821f8f289e4f226153b6443b57}

\begin{DoxyParams}{Parameters}
{\em packet} & packet sent from above down to Network Device \\
\hline
{\em source} & source mac address (so called \char`\"{}\+M\+A\+C spoofing\char`\"{}) \\
\hline
{\em dest} & mac address of the destination (already resolved) \\
\hline
{\em protocol\+Number} & identifies the type of payload contained in this packet. Used to call the right L3\+Protocol when the packet is received.\\
\hline
\end{DoxyParams}
Called from higher layer to send packet into Network Device with the specified source and destination Addresses.

\begin{DoxyReturn}{Returns}
whether the Send operation succeeded 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a19d55a4746c1ae584bf7da69959a885b}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
463 \{
464   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} << source << dest << protocolNumber);
465   \textcolor{keywordflow}{if} (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->GetSize () > \hyperlink{classns3_1_1SimpleNetDevice_a6bb1552655bbede11e48a9b434121bab}{GetMtu} ())
466     \{
467       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
468     \}
469   Ptr<Packet> packet = \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->Copy ();
470 
471   Mac48Address to = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (dest);
472   Mac48Address \hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from} = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (source);
473 
474   SimpleTag tag;
475   tag.SetSrc (from);
476   tag.SetDst (to);
477   tag.SetProto (protocolNumber);
478 
479   \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->AddPacketTag (tag);
480 
481   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1SimpleNetDevice_a72e1e606223c7e4683f64259d14ef065}{m\_queue}->Enqueue (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}))
482     \{
483       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1SimpleNetDevice_a72e1e606223c7e4683f64259d14ef065}{m\_queue}->GetNPackets () == 1 && !\hyperlink{classns3_1_1SimpleNetDevice_ad6fa5b2d21a557883c8c6d615ee6f066}{TransmitCompleteEvent}.
      \hyperlink{classns3_1_1EventId_aabf8476d1a080c199ea0c6aa9ccea372}{IsRunning} ())
484         \{
485           \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = \hyperlink{classns3_1_1SimpleNetDevice_a72e1e606223c7e4683f64259d14ef065}{m\_queue}->Dequeue ();
486           \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->RemovePacketTag (tag);
487           \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} txTime = \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (0);
488           \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1SimpleNetDevice_a6655e469fb351d5c541abf96c2928daa}{m\_bps} > DataRate (0))
489             \{
490               txTime = \hyperlink{classns3_1_1SimpleNetDevice_a6655e469fb351d5c541abf96c2928daa}{m\_bps}.\hyperlink{classns3_1_1DataRate_a5daa3d3b37b7df8bb75d94a6540fd17e}{CalculateBytesTxTime} (packet->GetSize ());
491             \}
492           \hyperlink{classns3_1_1SimpleNetDevice_aac80c92fff8c2a189c1186d8d41a4808}{m\_channel}->Send (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, protocolNumber, to, from, \textcolor{keyword}{this});
493           \hyperlink{classns3_1_1SimpleNetDevice_ad6fa5b2d21a557883c8c6d615ee6f066}{TransmitCompleteEvent} = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (txTime, &
      \hyperlink{classns3_1_1SimpleNetDevice_aa889ff3b3b3d94d9784f4984309bca4c}{SimpleNetDevice::TransmitComplete}, \textcolor{keyword}{this});
494         \}
495       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
496     \}
497 
498 
499   \hyperlink{classns3_1_1SimpleNetDevice_aac80c92fff8c2a189c1186d8d41a4808}{m\_channel}->Send (packet, protocolNumber, to, from, \textcolor{keyword}{this});
500   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
501 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 18




Here is the caller graph for this function\+:
% FIG 19


\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Set\+Address@{Set\+Address}}
\index{Set\+Address@{Set\+Address}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Address(\+Address address)}{SetAddress(Address address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Simple\+Net\+Device\+::\+Set\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1SimpleNetDevice_a968ef3e7318bac29d5f1d7d977029af4}{}\label{classns3_1_1SimpleNetDevice_a968ef3e7318bac29d5f1d7d977029af4}
Set the address of this interface 
\begin{DoxyParams}{Parameters}
{\em address} & address to set \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1NetDevice_ab56dc36bc0547471ab3210eda60ee76c}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
358 \{
359   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << address);
360   \hyperlink{classns3_1_1SimpleNetDevice_ac3dda22026d7c5fbbba243db41e0e2dd}{m\_address} = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (address);
361 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 20




Here is the caller graph for this function\+:
% FIG 21


\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Set\+Channel@{Set\+Channel}}
\index{Set\+Channel@{Set\+Channel}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Channel(\+Ptr$<$ Simple\+Channel $>$ channel)}{SetChannel(Ptr< SimpleChannel > channel)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Simple\+Net\+Device\+::\+Set\+Channel (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Simple\+Channel} $>$}]{channel}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1SimpleNetDevice_af9e9828ad584b5ba538f18f645f162e0}{}\label{classns3_1_1SimpleNetDevice_af9e9828ad584b5ba538f18f645f162e0}
Attach a channel to this net device. This will be the channel the net device sends on


\begin{DoxyParams}{Parameters}
{\em channel} & channel to assign to this net device \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
309 \{
310   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << channel);
311   \hyperlink{classns3_1_1SimpleNetDevice_aac80c92fff8c2a189c1186d8d41a4808}{m\_channel} = channel;
312   \hyperlink{classns3_1_1SimpleNetDevice_aac80c92fff8c2a189c1186d8d41a4808}{m\_channel}->Add (\textcolor{keyword}{this});
313   \hyperlink{classns3_1_1SimpleNetDevice_a923c93f1baab5ab677054a569eb88c53}{m\_linkUp} = \textcolor{keyword}{true};
314   \hyperlink{classns3_1_1SimpleNetDevice_a209f4157e8168195227cc6271b6f77f8}{m\_linkChangeCallbacks} ();
315 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 22


\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Set\+If\+Index@{Set\+If\+Index}}
\index{Set\+If\+Index@{Set\+If\+Index}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+If\+Index(const uint32\+\_\+t index)}{SetIfIndex(const uint32_t index)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Simple\+Net\+Device\+::\+Set\+If\+Index (
\begin{DoxyParamCaption}
\item[{const uint32\+\_\+t}]{index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1SimpleNetDevice_abff4bf773c14b7ca7839f9347213604c}{}\label{classns3_1_1SimpleNetDevice_abff4bf773c14b7ca7839f9347213604c}

\begin{DoxyParams}{Parameters}
{\em index} & if\+Index of the device \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1NetDevice_a2e1ac6c1189cd565420305d85a193fb8}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
340 \{
341   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << index);
342   \hyperlink{classns3_1_1SimpleNetDevice_ac2deeed77b8fcf06389ca7c1b56ac01f}{m\_ifIndex} = index;
343 \}
\end{DoxyCode}
\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Set\+Mtu@{Set\+Mtu}}
\index{Set\+Mtu@{Set\+Mtu}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Mtu(const uint16\+\_\+t mtu)}{SetMtu(const uint16_t mtu)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Simple\+Net\+Device\+::\+Set\+Mtu (
\begin{DoxyParamCaption}
\item[{const uint16\+\_\+t}]{mtu}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1SimpleNetDevice_ab41676e626a91832291bcfbd55ee454a}{}\label{classns3_1_1SimpleNetDevice_ab41676e626a91832291bcfbd55ee454a}

\begin{DoxyParams}{Parameters}
{\em mtu} & M\+TU value, in bytes, to set for the device \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether the M\+TU value was within legal bounds
\end{DoxyReturn}
Override for default M\+TU defined on a per-\/type basis. 

Implements \hyperlink{classns3_1_1NetDevice_a2ba4956d45cde68eab3cbdd6ede06df0}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
373 \{
374   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << mtu);
375   \hyperlink{classns3_1_1SimpleNetDevice_aab2aea73b33a02c23f8d417214a0d2a0}{m\_mtu} = mtu;
376   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
377 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 23


\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Set\+Node@{Set\+Node}}
\index{Set\+Node@{Set\+Node}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Node(\+Ptr$<$ Node $>$ node)}{SetNode(Ptr< Node > node)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Simple\+Net\+Device\+::\+Set\+Node (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1SimpleNetDevice_a7b0e64c1e4ee9841de0a892db96ddd68}{}\label{classns3_1_1SimpleNetDevice_a7b0e64c1e4ee9841de0a892db96ddd68}

\begin{DoxyParams}{Parameters}
{\em node} & the node associated to this netdevice.\\
\hline
\end{DoxyParams}
This method is called from \hyperlink{classns3_1_1Node_a42ff83ee1d5d1649c770d3f5b62375de}{ns3\+::\+Node\+::\+Add\+Device}. 

Implements \hyperlink{classns3_1_1NetDevice_a3ae520ae06e93b957f0f56f113319a08}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
546 \{
547   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << node);
548   \hyperlink{classns3_1_1SimpleNetDevice_abf59768bbf6b40baef7d8dd6ed6028be}{m\_node} = node;
549 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 24


\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Set\+Promisc\+Receive\+Callback@{Set\+Promisc\+Receive\+Callback}}
\index{Set\+Promisc\+Receive\+Callback@{Set\+Promisc\+Receive\+Callback}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Promisc\+Receive\+Callback(\+Promisc\+Receive\+Callback cb)}{SetPromiscReceiveCallback(PromiscReceiveCallback cb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Simple\+Net\+Device\+::\+Set\+Promisc\+Receive\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Promisc\+Receive\+Callback}}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1SimpleNetDevice_a8a2bb1be033ff108e148582ff0ec6472}{}\label{classns3_1_1SimpleNetDevice_a8a2bb1be033ff108e148582ff0ec6472}

\begin{DoxyParams}{Parameters}
{\em cb} & callback to invoke whenever a packet has been received in promiscuous mode and must be forwarded to the higher layers.\\
\hline
\end{DoxyParams}
Enables netdevice promiscuous mode and sets the callback that will handle promiscuous mode packets. Note, promiscuous mode packets means {\itshape all} packets, including those packets that can be sensed by the netdevice but which are intended to be received by other hosts. 

Implements \hyperlink{classns3_1_1NetDevice_a3968946bdbb74d47d7b13612baad7d6d}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
586 \{
587   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << &cb);
588   \hyperlink{classns3_1_1SimpleNetDevice_ad791745401d21961805c25572ccd7458}{m\_promiscCallback} = cb;
589 \}
\end{DoxyCode}
\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Set\+Queue@{Set\+Queue}}
\index{Set\+Queue@{Set\+Queue}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Queue(\+Ptr$<$ Queue$<$ Packet $>$ $>$ queue)}{SetQueue(Ptr< Queue< Packet > > queue)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Simple\+Net\+Device\+::\+Set\+Queue (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Queue}$<$ {\bf Packet} $>$ $>$}]{queue}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1SimpleNetDevice_a48c08632e053a5359157b9b3351099cc}{}\label{classns3_1_1SimpleNetDevice_a48c08632e053a5359157b9b3351099cc}
Attach a queue to the \hyperlink{classns3_1_1SimpleNetDevice}{Simple\+Net\+Device}.


\begin{DoxyParams}{Parameters}
{\em queue} & \hyperlink{classns3_1_1Ptr}{Ptr} to the new queue. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
326 \{
327   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << q);
328   \hyperlink{classns3_1_1SimpleNetDevice_a72e1e606223c7e4683f64259d14ef065}{m\_queue} = q;
329 \}
\end{DoxyCode}
\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Set\+Receive\+Callback@{Set\+Receive\+Callback}}
\index{Set\+Receive\+Callback@{Set\+Receive\+Callback}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Receive\+Callback(\+Net\+Device\+::\+Receive\+Callback cb)}{SetReceiveCallback(NetDevice::ReceiveCallback cb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Simple\+Net\+Device\+::\+Set\+Receive\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Net\+Device\+::\+Receive\+Callback}}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1SimpleNetDevice_a76c5853338b7adac83c6388a4c0f0258}{}\label{classns3_1_1SimpleNetDevice_a76c5853338b7adac83c6388a4c0f0258}

\begin{DoxyParams}{Parameters}
{\em cb} & callback to invoke whenever a packet has been received and must be forwarded to the higher layers.\\
\hline
\end{DoxyParams}
Set the callback to be used to notify higher layers when a packet has been received. 

Implements \hyperlink{classns3_1_1NetDevice_ac63e4d5668e421fec4b5d37f32e7dd18}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
562 \{
563   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << &cb);
564   \hyperlink{classns3_1_1SimpleNetDevice_a4e05eb44dc92b79880d7b2f9d7080afb}{m\_rxCallback} = cb;
565 \}
\end{DoxyCode}
\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Set\+Receive\+Error\+Model@{Set\+Receive\+Error\+Model}}
\index{Set\+Receive\+Error\+Model@{Set\+Receive\+Error\+Model}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Receive\+Error\+Model(\+Ptr$<$ Error\+Model $>$ em)}{SetReceiveErrorModel(Ptr< ErrorModel > em)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Simple\+Net\+Device\+::\+Set\+Receive\+Error\+Model (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Error\+Model} $>$}]{em}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1SimpleNetDevice_a8674cbc75fa8504bbf6c27b2ca1f5129}{}\label{classns3_1_1SimpleNetDevice_a8674cbc75fa8504bbf6c27b2ca1f5129}
Attach a receive \hyperlink{classns3_1_1ErrorModel}{Error\+Model} to the \hyperlink{classns3_1_1SimpleNetDevice}{Simple\+Net\+Device}.

The \hyperlink{classns3_1_1SimpleNetDevice}{Simple\+Net\+Device} may optionally include an \hyperlink{classns3_1_1ErrorModel}{Error\+Model} in the packet receive chain.

\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1ErrorModel}{Error\+Model} 
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em em} & \hyperlink{classns3_1_1Ptr}{Ptr} to the \hyperlink{classns3_1_1ErrorModel}{Error\+Model}. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
333 \{
334   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << em);
335   \hyperlink{classns3_1_1SimpleNetDevice_aabf566ae9e1c8351769da712e7da1177}{m\_receiveErrorModel} = em;
336 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 25


\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Supports\+Send\+From@{Supports\+Send\+From}}
\index{Supports\+Send\+From@{Supports\+Send\+From}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Supports\+Send\+From(void) const }{SupportsSendFrom(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Simple\+Net\+Device\+::\+Supports\+Send\+From (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1SimpleNetDevice_a9a2542634b341889f91c3d1dd35493c4}{}\label{classns3_1_1SimpleNetDevice_a9a2542634b341889f91c3d1dd35493c4}
\begin{DoxyReturn}{Returns}
true if this interface supports a bridging mode, false otherwise. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a04793d220b54c40e110ebf86dae5b25c}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
593 \{
594   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
595   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
596 \}
\end{DoxyCode}
\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Transmit\+Complete@{Transmit\+Complete}}
\index{Transmit\+Complete@{Transmit\+Complete}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Transmit\+Complete(void)}{TransmitComplete(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Simple\+Net\+Device\+::\+Transmit\+Complete (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1SimpleNetDevice_aa889ff3b3b3d94d9784f4984309bca4c}{}\label{classns3_1_1SimpleNetDevice_aa889ff3b3b3d94d9784f4984309bca4c}
The Transmit\+Complete method is used internally to finish the process of sending a packet out on the channel. 
\begin{DoxyCode}
506 \{
507   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
508 
509   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1SimpleNetDevice_a72e1e606223c7e4683f64259d14ef065}{m\_queue}->GetNPackets () == 0)
510     \{
511       \textcolor{keywordflow}{return};
512     \}
513 
514   Ptr<Packet> packet = \hyperlink{classns3_1_1SimpleNetDevice_a72e1e606223c7e4683f64259d14ef065}{m\_queue}->Dequeue ();
515 
516   SimpleTag tag;
517   packet->RemovePacketTag (tag);
518 
519   Mac48Address src = tag.GetSrc ();
520   Mac48Address dst = tag.GetDst ();
521   uint16\_t proto = tag.GetProto ();
522 
523   \hyperlink{classns3_1_1SimpleNetDevice_aac80c92fff8c2a189c1186d8d41a4808}{m\_channel}->Send (packet, proto, dst, src, \textcolor{keyword}{this});
524 
525   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1SimpleNetDevice_a72e1e606223c7e4683f64259d14ef065}{m\_queue}->GetNPackets ())
526     \{
527       \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} txTime = \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (0);
528       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1SimpleNetDevice_a6655e469fb351d5c541abf96c2928daa}{m\_bps} > DataRate (0))
529         \{
530           txTime = \hyperlink{classns3_1_1SimpleNetDevice_a6655e469fb351d5c541abf96c2928daa}{m\_bps}.\hyperlink{classns3_1_1DataRate_a5daa3d3b37b7df8bb75d94a6540fd17e}{CalculateBytesTxTime} (packet->GetSize ());
531         \}
532       \hyperlink{classns3_1_1SimpleNetDevice_ad6fa5b2d21a557883c8c6d615ee6f066}{TransmitCompleteEvent} = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (txTime, &
      \hyperlink{classns3_1_1SimpleNetDevice_aa889ff3b3b3d94d9784f4984309bca4c}{SimpleNetDevice::TransmitComplete}, \textcolor{keyword}{this});
533     \}
534 
535   \textcolor{keywordflow}{return};
536 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 26




Here is the caller graph for this function\+:
% FIG 27




\subsection{Member Data Documentation}
\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!m\+\_\+address@{m\+\_\+address}}
\index{m\+\_\+address@{m\+\_\+address}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+address}{m_address}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Mac48\+Address} ns3\+::\+Simple\+Net\+Device\+::m\+\_\+address\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1SimpleNetDevice_ac3dda22026d7c5fbbba243db41e0e2dd}{}\label{classns3_1_1SimpleNetDevice_ac3dda22026d7c5fbbba243db41e0e2dd}


M\+AC address. 

\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!m\+\_\+bps@{m\+\_\+bps}}
\index{m\+\_\+bps@{m\+\_\+bps}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+bps}{m_bps}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Data\+Rate} ns3\+::\+Simple\+Net\+Device\+::m\+\_\+bps\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1SimpleNetDevice_a6655e469fb351d5c541abf96c2928daa}{}\label{classns3_1_1SimpleNetDevice_a6655e469fb351d5c541abf96c2928daa}


The device nominal Data rate. Zero means infinite. 

\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!m\+\_\+channel@{m\+\_\+channel}}
\index{m\+\_\+channel@{m\+\_\+channel}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+channel}{m_channel}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Simple\+Channel}$>$ ns3\+::\+Simple\+Net\+Device\+::m\+\_\+channel\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1SimpleNetDevice_aac80c92fff8c2a189c1186d8d41a4808}{}\label{classns3_1_1SimpleNetDevice_aac80c92fff8c2a189c1186d8d41a4808}


the channel the device is connected to 

\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!m\+\_\+if\+Index@{m\+\_\+if\+Index}}
\index{m\+\_\+if\+Index@{m\+\_\+if\+Index}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+if\+Index}{m_ifIndex}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Simple\+Net\+Device\+::m\+\_\+if\+Index\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1SimpleNetDevice_ac2deeed77b8fcf06389ca7c1b56ac01f}{}\label{classns3_1_1SimpleNetDevice_ac2deeed77b8fcf06389ca7c1b56ac01f}


Interface index. 

\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!m\+\_\+link\+Change\+Callbacks@{m\+\_\+link\+Change\+Callbacks}}
\index{m\+\_\+link\+Change\+Callbacks@{m\+\_\+link\+Change\+Callbacks}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+link\+Change\+Callbacks}{m_linkChangeCallbacks}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback} ns3\+::\+Simple\+Net\+Device\+::m\+\_\+link\+Change\+Callbacks\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1SimpleNetDevice_a209f4157e8168195227cc6271b6f77f8}{}\label{classns3_1_1SimpleNetDevice_a209f4157e8168195227cc6271b6f77f8}
List of callbacks to fire if the link changes state (up or down). \index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!m\+\_\+link\+Up@{m\+\_\+link\+Up}}
\index{m\+\_\+link\+Up@{m\+\_\+link\+Up}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+link\+Up}{m_linkUp}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Simple\+Net\+Device\+::m\+\_\+link\+Up\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1SimpleNetDevice_a923c93f1baab5ab677054a569eb88c53}{}\label{classns3_1_1SimpleNetDevice_a923c93f1baab5ab677054a569eb88c53}


Flag indicating whether or not the link is up. 

\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!m\+\_\+mtu@{m\+\_\+mtu}}
\index{m\+\_\+mtu@{m\+\_\+mtu}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+mtu}{m_mtu}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Simple\+Net\+Device\+::m\+\_\+mtu\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1SimpleNetDevice_aab2aea73b33a02c23f8d417214a0d2a0}{}\label{classns3_1_1SimpleNetDevice_aab2aea73b33a02c23f8d417214a0d2a0}


M\+TU. 

\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!m\+\_\+node@{m\+\_\+node}}
\index{m\+\_\+node@{m\+\_\+node}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+node}{m_node}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Node}$>$ ns3\+::\+Simple\+Net\+Device\+::m\+\_\+node\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1SimpleNetDevice_abf59768bbf6b40baef7d8dd6ed6028be}{}\label{classns3_1_1SimpleNetDevice_abf59768bbf6b40baef7d8dd6ed6028be}


\hyperlink{classns3_1_1Node}{Node} this net\+Device is associated to. 

\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!m\+\_\+phy\+Rx\+Drop\+Trace@{m\+\_\+phy\+Rx\+Drop\+Trace}}
\index{m\+\_\+phy\+Rx\+Drop\+Trace@{m\+\_\+phy\+Rx\+Drop\+Trace}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+phy\+Rx\+Drop\+Trace}{m_phyRxDropTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Simple\+Net\+Device\+::m\+\_\+phy\+Rx\+Drop\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1SimpleNetDevice_a1ff8de95910e13b1fe6c9b5c07a6f721}{}\label{classns3_1_1SimpleNetDevice_a1ff8de95910e13b1fe6c9b5c07a6f721}
The trace source fired when the phy layer drops a packet it has received due to the error model being active. Although \hyperlink{classns3_1_1SimpleNetDevice}{Simple\+Net\+Device} doesn\textquotesingle{}t really have a Phy model, we choose this trace source name for alignment with other trace sources.

\begin{DoxySeeAlso}{See also}
class Call\+Back\+Trace\+Source 
\end{DoxySeeAlso}
\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!m\+\_\+point\+To\+Point\+Mode@{m\+\_\+point\+To\+Point\+Mode}}
\index{m\+\_\+point\+To\+Point\+Mode@{m\+\_\+point\+To\+Point\+Mode}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+point\+To\+Point\+Mode}{m_pointToPointMode}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Simple\+Net\+Device\+::m\+\_\+point\+To\+Point\+Mode\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1SimpleNetDevice_a9e0e98464addc8f65a1e95a405b7119c}{}\label{classns3_1_1SimpleNetDevice_a9e0e98464addc8f65a1e95a405b7119c}
Flag indicating whether or not the \hyperlink{classns3_1_1NetDevice}{Net\+Device} is a Point to Point model. Enabling this will disable Broadcast and Arp. \index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!m\+\_\+promisc\+Callback@{m\+\_\+promisc\+Callback}}
\index{m\+\_\+promisc\+Callback@{m\+\_\+promisc\+Callback}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+promisc\+Callback}{m_promiscCallback}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Net\+Device\+::\+Promisc\+Receive\+Callback} ns3\+::\+Simple\+Net\+Device\+::m\+\_\+promisc\+Callback\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1SimpleNetDevice_ad791745401d21961805c25572ccd7458}{}\label{classns3_1_1SimpleNetDevice_ad791745401d21961805c25572ccd7458}


Promiscuous receive callback. 

\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!m\+\_\+queue@{m\+\_\+queue}}
\index{m\+\_\+queue@{m\+\_\+queue}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+queue}{m_queue}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Queue}$<${\bf Packet}$>$ $>$ ns3\+::\+Simple\+Net\+Device\+::m\+\_\+queue\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1SimpleNetDevice_a72e1e606223c7e4683f64259d14ef065}{}\label{classns3_1_1SimpleNetDevice_a72e1e606223c7e4683f64259d14ef065}


The \hyperlink{classns3_1_1Queue}{Queue} for outgoing packets. 

\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!m\+\_\+queue\+Interface@{m\+\_\+queue\+Interface}}
\index{m\+\_\+queue\+Interface@{m\+\_\+queue\+Interface}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+queue\+Interface}{m_queueInterface}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Net\+Device\+Queue\+Interface}$>$ ns3\+::\+Simple\+Net\+Device\+::m\+\_\+queue\+Interface\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1SimpleNetDevice_a35bd6983512fe87988362fa02f6425e7}{}\label{classns3_1_1SimpleNetDevice_a35bd6983512fe87988362fa02f6425e7}


\hyperlink{classns3_1_1NetDevice}{Net\+Device} queue interface. 

\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!m\+\_\+receive\+Error\+Model@{m\+\_\+receive\+Error\+Model}}
\index{m\+\_\+receive\+Error\+Model@{m\+\_\+receive\+Error\+Model}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+receive\+Error\+Model}{m_receiveErrorModel}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Error\+Model}$>$ ns3\+::\+Simple\+Net\+Device\+::m\+\_\+receive\+Error\+Model\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1SimpleNetDevice_aabf566ae9e1c8351769da712e7da1177}{}\label{classns3_1_1SimpleNetDevice_aabf566ae9e1c8351769da712e7da1177}


Receive error model. 

\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!m\+\_\+rx\+Callback@{m\+\_\+rx\+Callback}}
\index{m\+\_\+rx\+Callback@{m\+\_\+rx\+Callback}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+rx\+Callback}{m_rxCallback}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Net\+Device\+::\+Receive\+Callback} ns3\+::\+Simple\+Net\+Device\+::m\+\_\+rx\+Callback\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1SimpleNetDevice_a4e05eb44dc92b79880d7b2f9d7080afb}{}\label{classns3_1_1SimpleNetDevice_a4e05eb44dc92b79880d7b2f9d7080afb}


Receive callback. 

\index{ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}!Transmit\+Complete\+Event@{Transmit\+Complete\+Event}}
\index{Transmit\+Complete\+Event@{Transmit\+Complete\+Event}!ns3\+::\+Simple\+Net\+Device@{ns3\+::\+Simple\+Net\+Device}}
\subsubsection[{\texorpdfstring{Transmit\+Complete\+Event}{TransmitCompleteEvent}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Event\+Id} ns3\+::\+Simple\+Net\+Device\+::\+Transmit\+Complete\+Event\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1SimpleNetDevice_ad6fa5b2d21a557883c8c6d615ee6f066}{}\label{classns3_1_1SimpleNetDevice_ad6fa5b2d21a557883c8c6d615ee6f066}


the Tx Complete event 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
network/utils/\hyperlink{simple-net-device_8h}{simple-\/net-\/device.\+h}\item 
network/utils/\hyperlink{simple-net-device_8cc}{simple-\/net-\/device.\+cc}\end{DoxyCompactItemize}
