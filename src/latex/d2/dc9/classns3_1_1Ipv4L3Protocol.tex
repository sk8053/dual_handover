\hypertarget{classns3_1_1Ipv4L3Protocol}{}\section{ns3\+:\+:Ipv4\+L3\+Protocol Class Reference}
\label{classns3_1_1Ipv4L3Protocol}\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}


Implement the I\+Pv4 layer.  




{\ttfamily \#include $<$ipv4-\/l3-\/protocol.\+h$>$}



Inheritance diagram for ns3\+:\+:Ipv4\+L3\+Protocol\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Ipv4\+L3\+Protocol\+:
% FIG 1
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classns3_1_1Ipv4L3Protocol_1_1Fragments}{Fragments}
\begin{DoxyCompactList}\small\item\em A Set of Fragment belonging to the same packet (src, dst, identification and proto) \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1}{Drop\+Reason} \{ \\*
\hyperlink{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1a95ecb5b7c1affd7ca7a6d3d34c38cd40}{D\+R\+O\+P\+\_\+\+T\+T\+L\+\_\+\+E\+X\+P\+I\+R\+ED} = 1, 
\hyperlink{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1a6934d63c397ae1ec077fdfcdeb90eb40}{D\+R\+O\+P\+\_\+\+N\+O\+\_\+\+R\+O\+U\+TE}, 
\hyperlink{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1a14938788d12f864657e5a3aa5d3e26fd}{D\+R\+O\+P\+\_\+\+B\+A\+D\+\_\+\+C\+H\+E\+C\+K\+S\+UM}, 
\hyperlink{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1a8f40f145dce3e9f21e1218ce125a048d}{D\+R\+O\+P\+\_\+\+I\+N\+T\+E\+R\+F\+A\+C\+E\+\_\+\+D\+O\+WN}, 
\\*
\hyperlink{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1aeb35be325e705553daacbf36f035c8f5}{D\+R\+O\+P\+\_\+\+R\+O\+U\+T\+E\+\_\+\+E\+R\+R\+OR}, 
\hyperlink{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1afaf46ea7a6354ebb1e66e891123a9fbb}{D\+R\+O\+P\+\_\+\+F\+R\+A\+G\+M\+E\+N\+T\+\_\+\+T\+I\+M\+E\+O\+UT}
 \}\begin{DoxyCompactList}\small\item\em Reason why a packet has been dropped. \end{DoxyCompactList}
\item 
typedef void($\ast$ \hyperlink{classns3_1_1Ipv4L3Protocol_acc7bcfb12c40722923247fc853e47f73}{Sent\+Traced\+Callback}) (const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, uint32\+\_\+t interface)
\item 
typedef void($\ast$ \hyperlink{classns3_1_1Ipv4L3Protocol_a7da7189506cc53d778ccc2b6cba88e2d}{Tx\+Rx\+Traced\+Callback}) (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$ ipv4, uint32\+\_\+t interface)
\item 
typedef void($\ast$ \hyperlink{classns3_1_1Ipv4L3Protocol_a50425a8bb439831d9134fc6061481c53}{Drop\+Traced\+Callback}) (const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1}{Drop\+Reason} reason, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$ ipv4, uint32\+\_\+t interface)
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ipv4L3Protocol_a994880814b636138a70977fa8fb51047}{Ipv4\+L3\+Protocol} ()
\item 
virtual \hyperlink{classns3_1_1Ipv4L3Protocol_a6396c85e2562a15ba495efcf32a63786}{$\sim$\+Ipv4\+L3\+Protocol} ()
\item 
void \hyperlink{classns3_1_1Ipv4L3Protocol_a82ef37914ea8bab699575fea23586bc7}{Set\+Node} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node)
\begin{DoxyCompactList}\small\item\em Set node associated with this stack. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4L3Protocol_a7e7d286dc2c782ea931d12a95203fc29}{Set\+Routing\+Protocol} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} $>$ routing\+Protocol)
\begin{DoxyCompactList}\small\item\em Register a new routing protocol to be used by this \hyperlink{classns3_1_1Ipv4}{Ipv4} stack. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} $>$ \hyperlink{classns3_1_1Ipv4L3Protocol_aa1e4efbf4978299e47406895c3f4b41d}{Get\+Routing\+Protocol} (void) const 
\begin{DoxyCompactList}\small\item\em Get the routing protocol to be used by this \hyperlink{classns3_1_1Ipv4}{Ipv4} stack. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$ \hyperlink{classns3_1_1Ipv4L3Protocol_abc060605c64f9dc7c56f5d8124fbaec2}{Create\+Raw\+Socket} (void)
\begin{DoxyCompactList}\small\item\em Creates a raw socket. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4L3Protocol_a170d2d386421ff92c45c2e7dd3f79a5e}{Delete\+Raw\+Socket} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$ socket)
\begin{DoxyCompactList}\small\item\em Deletes a particular raw socket. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv4L3Protocol_adcca82f024e576d06b4687ec3519ed8b}{Insert} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} $>$ protocol)
\item 
virtual void \hyperlink{classns3_1_1Ipv4L3Protocol_a2c8c7ce0f9c6e8ca5825d9abc5554f1c}{Insert} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} $>$ protocol, uint32\+\_\+t interface\+Index)
\begin{DoxyCompactList}\small\item\em Add a L4 protocol to a specific interface. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv4L3Protocol_a718acab47b00b50f77c9acb05efbf220}{Remove} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} $>$ protocol)
\item 
virtual void \hyperlink{classns3_1_1Ipv4L3Protocol_abb4d0e17bda74dd318b3ff2cb3db58ee}{Remove} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} $>$ protocol, uint32\+\_\+t interface\+Index)
\begin{DoxyCompactList}\small\item\em Remove a L4 protocol from a specific interface. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} $>$ \hyperlink{classns3_1_1Ipv4L3Protocol_acbe71267a0b2bca4569cf574148d3361}{Get\+Protocol} (int protocol\+Number) const 
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} $>$ \hyperlink{classns3_1_1Ipv4L3Protocol_a4c12ae9366588d171aac8cebb74931dc}{Get\+Protocol} (int protocol\+Number, int32\+\_\+t interface\+Index) const 
\begin{DoxyCompactList}\small\item\em Get L4 protocol by protocol number for the specified interface. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \hyperlink{classns3_1_1Ipv4L3Protocol_a60f11e28019741497dd8730f53294b4f}{Source\+Address\+Selection} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} dest)
\begin{DoxyCompactList}\small\item\em Choose the source address to use with destination address. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4L3Protocol_ae8e813f03f1d862bd18cede2b12d346f}{Set\+Default\+Ttl} (uint8\+\_\+t ttl)
\item 
void \hyperlink{classns3_1_1Ipv4L3Protocol_a2f27fb0a3f698ffb34a654323b063c94}{Receive} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, uint16\+\_\+t protocol, const \hyperlink{classns3_1_1Address}{Address} \&\hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from}, const \hyperlink{classns3_1_1Address}{Address} \&to, \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2}{Net\+Device\+::\+Packet\+Type} packet\+Type)
\item 
void \hyperlink{classns3_1_1Ipv4L3Protocol_abe8cf785815f3fbb32b0e21d629be641}{Send} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} source, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} destination, uint8\+\_\+t protocol, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ route)
\item 
void \hyperlink{classns3_1_1Ipv4L3Protocol_a9305010252cee1e4e97766227ca58ba4}{Send\+With\+Header} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} ip\+Header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ route)
\item 
uint32\+\_\+t \hyperlink{classns3_1_1Ipv4L3Protocol_ac6855eb39254f74fa30e7f23a7b100db}{Add\+Interface} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} $>$ \hyperlink{classns3_1_1Ipv4L3Protocol_ad58abef6f890f3cc2cf291159a3b8588}{Get\+Interface} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) const 
\begin{DoxyCompactList}\small\item\em Get an interface. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1Ipv4L3Protocol_a6ab2be11c0df97f2d1170bbc737c9628}{Get\+N\+Interfaces} (void) const 
\item 
int32\+\_\+t \hyperlink{classns3_1_1Ipv4L3Protocol_a8aac475db90ce304c53b23c2d470f6eb}{Get\+Interface\+For\+Address} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} addr) const 
\begin{DoxyCompactList}\small\item\em Return the interface number of the interface that has been assigned the specified IP address. \end{DoxyCompactList}\item 
int32\+\_\+t \hyperlink{classns3_1_1Ipv4L3Protocol_aedf0ed801978ecf18b1e8ae0d0039a42}{Get\+Interface\+For\+Prefix} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} addr, \hyperlink{classns3_1_1Ipv4Mask}{Ipv4\+Mask} mask) const 
\begin{DoxyCompactList}\small\item\em Return the interface number of first interface found that has an \hyperlink{classns3_1_1Ipv4}{Ipv4} address within the prefix specified by the input address and mask parameters. \end{DoxyCompactList}\item 
int32\+\_\+t \hyperlink{classns3_1_1Ipv4L3Protocol_a4640baab6b3879020a4146f17e293321}{Get\+Interface\+For\+Device} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device) const 
\item 
bool \hyperlink{classns3_1_1Ipv4L3Protocol_a2d76dcdc0c915346d9177afda3b4e388}{Is\+Destination\+Address} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} address, uint32\+\_\+t iif) const 
\begin{DoxyCompactList}\small\item\em Determine whether address and interface corresponding to received packet can be accepted for local delivery. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Ipv4L3Protocol_a6392fb16c03883eb3e21c9ac4216967d}{Add\+Address} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} address)
\item 
\hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} \hyperlink{classns3_1_1Ipv4L3Protocol_a85fa4287313a773dee29aa73fa74a7e0}{Get\+Address} (uint32\+\_\+t interface\+Index, uint32\+\_\+t address\+Index) const 
\item 
uint32\+\_\+t \hyperlink{classns3_1_1Ipv4L3Protocol_ab816ec1b5f680117bc1363b3d9649b22}{Get\+N\+Addresses} (uint32\+\_\+t interface) const 
\item 
bool \hyperlink{classns3_1_1Ipv4L3Protocol_a143bb06864cd386728afe563b9f554dc}{Remove\+Address} (uint32\+\_\+t interface\+Index, uint32\+\_\+t address\+Index)
\item 
bool \hyperlink{classns3_1_1Ipv4L3Protocol_a30338b1132156b86a8bbf5e6d17c6266}{Remove\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} address)
\begin{DoxyCompactList}\small\item\em Remove the given address on named \hyperlink{classns3_1_1Ipv4}{Ipv4} interface. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \hyperlink{classns3_1_1Ipv4L3Protocol_aa7a0d27e88ef21b5e83b36c0e602b6c2}{Select\+Source\+Address} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} dst, \hyperlink{classns3_1_1Ipv4InterfaceAddress_a329cea433e74f717c26c9e51c4fcd3d8}{Ipv4\+Interface\+Address\+::\+Interface\+Address\+Scope\+\_\+e} scope)
\begin{DoxyCompactList}\small\item\em Return the first primary source address with scope less than or equal to the requested scope, to use in sending a packet to destination dst out of the specified device. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4L3Protocol_acdb26739ce815d86b85767edca3f0068}{Set\+Metric} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, uint16\+\_\+t metric)
\item 
uint16\+\_\+t \hyperlink{classns3_1_1Ipv4L3Protocol_af8445efaa4cb715717f0152d37b4ed34}{Get\+Metric} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) const 
\item 
uint16\+\_\+t \hyperlink{classns3_1_1Ipv4L3Protocol_ad5ec856c17f917cc47a10552ccdd9767}{Get\+Mtu} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) const 
\item 
bool \hyperlink{classns3_1_1Ipv4L3Protocol_a8f30b837b325a3e332e25d0da91cfbf4}{Is\+Up} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) const 
\item 
void \hyperlink{classns3_1_1Ipv4L3Protocol_a9c4d254d735b420b7fb6e0a56a90f221}{Set\+Up} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
\item 
void \hyperlink{classns3_1_1Ipv4L3Protocol_aad57377d10edd4f3de417533d7f07917}{Set\+Down} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
\item 
bool \hyperlink{classns3_1_1Ipv4L3Protocol_a7edb82af155c25e7325d1c91df7d83de}{Is\+Forwarding} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) const 
\item 
void \hyperlink{classns3_1_1Ipv4L3Protocol_a4150655165d81cc01cb4ac4883de5c08}{Set\+Forwarding} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, bool val)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ \hyperlink{classns3_1_1Ipv4L3Protocol_a783709154b6f41b3a800b3e67369d501}{Get\+Net\+Device} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
\item 
bool \hyperlink{classns3_1_1Ipv4L3Protocol_a344bf4a2d96c51fc4ff355bb9bd56b30}{Is\+Unicast} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} ad) const 
\begin{DoxyCompactList}\small\item\em Check if an I\+Pv4 address is unicast according to the node. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1Ipv4L3Protocol_a6ba2da2443b09b292b75aad2a52ecc4b}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const uint16\+\_\+t \hyperlink{classns3_1_1Ipv4L3Protocol_a0146bc84815b7b73adb9c62cdafc9442}{P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER} = 0x0800
\begin{DoxyCompactList}\small\item\em Protocol number (0x0800) \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1Ipv4L3Protocol_ac8a748f7de27c60d87bbda8b10377f53}{Do\+Dispose} (void)
\item 
virtual void \hyperlink{classns3_1_1Ipv4L3Protocol_a41c7e4fc5a8dba55e9708df7cef9b9c7}{Notify\+New\+Aggregate} ()
\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
typedef std\+::pair$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$, \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} $>$ \hyperlink{classns3_1_1Ipv4L3Protocol_a2bf61de1f7739b9ce8b1dac10fb14b31}{Ipv4\+Payload\+Header\+Pair}
\begin{DoxyCompactList}\small\item\em Pair of a packet and an \hyperlink{classns3_1_1Ipv4}{Ipv4} header. \end{DoxyCompactList}\item 
typedef std\+::vector$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} $>$ $>$ \hyperlink{classns3_1_1Ipv4L3Protocol_ada31b7e1708bfe1fb99a44f5c4f3271f}{Ipv4\+Interface\+List}
\begin{DoxyCompactList}\small\item\em Container of the I\+Pv4 Interfaces. \end{DoxyCompactList}\item 
typedef std\+::map$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$, uint32\+\_\+t $>$ \hyperlink{classns3_1_1Ipv4L3Protocol_a6fdb18e99c2052467dcb9079673f9764}{Ipv4\+Interface\+Reverse\+Container}
\begin{DoxyCompactList}\small\item\em Container of Net\+Devices registered to I\+Pv4 and their interface indexes. \end{DoxyCompactList}\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4RawSocketImpl}{Ipv4\+Raw\+Socket\+Impl} $>$ $>$ \hyperlink{classns3_1_1Ipv4L3Protocol_a3dd6ac663f7c8ccd87886bc864892dda}{Socket\+List}
\begin{DoxyCompactList}\small\item\em Container of the I\+Pv4 Raw Sockets. \end{DoxyCompactList}\item 
typedef std\+::pair$<$ int, int32\+\_\+t $>$ \hyperlink{classns3_1_1Ipv4L3Protocol_af8c2f6a17623a26e68c785ab1676d91c}{L4\+List\+Key\+\_\+t}
\begin{DoxyCompactList}\small\item\em Container of the I\+Pv4 L4 keys\+: protocol number, interface index. \end{DoxyCompactList}\item 
typedef std\+::map$<$ \hyperlink{classns3_1_1Ipv4L3Protocol_af8c2f6a17623a26e68c785ab1676d91c}{L4\+List\+Key\+\_\+t}, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} $>$ $>$ \hyperlink{classns3_1_1Ipv4L3Protocol_aca93327d3f9e0fdce61d3e72927bd018}{L4\+List\+\_\+t}
\begin{DoxyCompactList}\small\item\em Container of the I\+Pv4 L4 instances. \end{DoxyCompactList}\item 
typedef std\+::map$<$ std\+::pair$<$ uint64\+\_\+t, uint32\+\_\+t $>$, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4L3Protocol_1_1Fragments}{Fragments} $>$ $>$ \hyperlink{classns3_1_1Ipv4L3Protocol_ac2b81caa9436d6a015bbbb68b6282481}{Map\+Fragments\+\_\+t}
\begin{DoxyCompactList}\small\item\em Container of fragments, stored as pairs(src+dst addr, src+dst port) / fragment. \end{DoxyCompactList}\item 
typedef std\+::map$<$ std\+::pair$<$ uint64\+\_\+t, uint32\+\_\+t $>$, \hyperlink{classns3_1_1EventId}{Event\+Id} $>$ \hyperlink{classns3_1_1Ipv4L3Protocol_acce90cf84f9acda8706768a1c266bfc8}{Map\+Fragments\+Timers\+\_\+t}
\begin{DoxyCompactList}\small\item\em Container of fragment timeout event, stored as pairs(src+dst addr, src+dst port) / \hyperlink{classns3_1_1EventId}{Event\+Id}. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ipv4L3Protocol_a81b92d7401aee401daea5360d478fb60}{Ipv4\+L3\+Protocol} (const \hyperlink{classns3_1_1Ipv4L3Protocol}{Ipv4\+L3\+Protocol} \&)
\begin{DoxyCompactList}\small\item\em Copy constructor. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4L3Protocol}{Ipv4\+L3\+Protocol} \& \hyperlink{classns3_1_1Ipv4L3Protocol_a24c97a3fdb0aa3363e4968c6fb48186f}{operator=} (const \hyperlink{classns3_1_1Ipv4L3Protocol}{Ipv4\+L3\+Protocol} \&)
\begin{DoxyCompactList}\small\item\em Copy constructor. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv4L3Protocol_a455a909e3bdcb5651e0ffd3eadf850d8}{Set\+Ip\+Forward} (bool forward)
\begin{DoxyCompactList}\small\item\em Set or unset the IP forwarding state. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1Ipv4L3Protocol_acbc9196c4f23691e6dde9890f24c5285}{Get\+Ip\+Forward} (void) const 
\begin{DoxyCompactList}\small\item\em Get the IP forwarding state. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv4L3Protocol_a45e538d92668de5fa759de6141751702}{Set\+Weak\+Es\+Model} (bool model)
\begin{DoxyCompactList}\small\item\em Set or unset the Weak Es Model. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1Ipv4L3Protocol_ad6249ba16ffc906ac0041ce89bdc2cac}{Get\+Weak\+Es\+Model} (void) const 
\begin{DoxyCompactList}\small\item\em Get the Weak Es Model status. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \hyperlink{classns3_1_1Ipv4L3Protocol_a3737569960c655fe5441b21a5ef829d3}{Build\+Header} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} source, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} destination, uint8\+\_\+t protocol, uint16\+\_\+t payload\+Size, uint8\+\_\+t ttl, uint8\+\_\+t tos, bool may\+Fragment)
\begin{DoxyCompactList}\small\item\em Construct an I\+Pv4 header. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4L3Protocol_ac1baf310b12bbc564d0766061ecca323}{Send\+Real\+Out} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ route, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} const \&ip\+Header)
\begin{DoxyCompactList}\small\item\em Send packet with route. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4L3Protocol_ae00b4ef6c6907a602898800ee5dcbc57}{Ip\+Forward} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ rtentry, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&header)
\begin{DoxyCompactList}\small\item\em Forward a packet. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4L3Protocol_a85ad438d9b2c50d55d1b674b9fd1e8f7}{Ip\+Multicast\+Forward} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4MulticastRoute}{Ipv4\+Multicast\+Route} $>$ mrtentry, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&header)
\begin{DoxyCompactList}\small\item\em Forward a multicast packet. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4L3Protocol_aa64669f000ce115efafd5e086995b4ff}{Local\+Deliver} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} const \&ip, uint32\+\_\+t iif)
\begin{DoxyCompactList}\small\item\em Deliver a packet. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4L3Protocol_a39611a6da4b2d975e3eae9cebf6da6eb}{Route\+Input\+Error} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&ip\+Header, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket\+::\+Socket\+Errno} sock\+Errno)
\begin{DoxyCompactList}\small\item\em Fallback when no route is found. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1Ipv4L3Protocol_afd3f97720c2d1af22f05038fcdb6e089}{Add\+Ipv4\+Interface} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} $>$ interface)
\begin{DoxyCompactList}\small\item\em Add an I\+Pv4 interface to the stack. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4L3Protocol_aa37b950d26063e4e7ee659e599c83bde}{Setup\+Loopback} (void)
\begin{DoxyCompactList}\small\item\em Setup loopback interface. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Icmpv4L4Protocol}{Icmpv4\+L4\+Protocol} $>$ \hyperlink{classns3_1_1Ipv4L3Protocol_a4dd2b3a24817ed50e7a6f41a5657551c}{Get\+Icmp} (void) const 
\begin{DoxyCompactList}\small\item\em Get I\+C\+M\+Pv4 protocol. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Ipv4L3Protocol_a533891c3db9bb974dba7dc4b530b12ab}{Is\+Unicast} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} ad, \hyperlink{classns3_1_1Ipv4Mask}{Ipv4\+Mask} interface\+Mask) const 
\begin{DoxyCompactList}\small\item\em Check if an I\+Pv4 address is unicast. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4L3Protocol_a5ea602dc1447746c0c3bd90e36ec3888}{Do\+Fragmentation} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&ipv4\+Header, uint32\+\_\+t out\+Iface\+Mtu, \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ipv4L3Protocol_a2bf61de1f7739b9ce8b1dac10fb14b31}{Ipv4\+Payload\+Header\+Pair} $>$ \&list\+Fragments)
\begin{DoxyCompactList}\small\item\em Fragment a packet. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Ipv4L3Protocol_a981e183413dccdf40f91d1de4f728f63}{Process\+Fragment} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \&packet, \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&ip\+Header, uint32\+\_\+t iif)
\begin{DoxyCompactList}\small\item\em Process a packet fragment. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4L3Protocol_a387d96062b7810153592f3a6f257de74}{Handle\+Fragments\+Timeout} (std\+::pair$<$ uint64\+\_\+t, uint32\+\_\+t $>$ key, \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&ip\+Header, uint32\+\_\+t iif)
\begin{DoxyCompactList}\small\item\em Process the timeout for packet fragments. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4L3Protocol_a04cbb7540c6f22a2870f118715b6a703}{Call\+Tx\+Trace} (const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&ip\+Header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$ ipv4, uint32\+\_\+t interface)
\begin{DoxyCompactList}\small\item\em Make a copy of the packet, add the header and invoke the TX trace callback. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classns3_1_1Ipv4L3Protocol_a2dc4e9e459bb2ee5eab3af65df316a15}{m\+\_\+ip\+Forward}
\begin{DoxyCompactList}\small\item\em Forwarding packets (i.\+e. router mode) state. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Ipv4L3Protocol_acbe9c4ed9ec7e33a55fa5b7c687e62f3}{m\+\_\+weak\+Es\+Model}
\begin{DoxyCompactList}\small\item\em Weak ES model state. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4L3Protocol_aca93327d3f9e0fdce61d3e72927bd018}{L4\+List\+\_\+t} \hyperlink{classns3_1_1Ipv4L3Protocol_ab1c0a7a1a453db3c2ca3e47d7e65ff54}{m\+\_\+protocols}
\begin{DoxyCompactList}\small\item\em List of transport protocol. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4L3Protocol_ada31b7e1708bfe1fb99a44f5c4f3271f}{Ipv4\+Interface\+List} \hyperlink{classns3_1_1Ipv4L3Protocol_a0b0f15b24a02f2c9a5d576f633aa2770}{m\+\_\+interfaces}
\begin{DoxyCompactList}\small\item\em List of I\+Pv4 interfaces. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4L3Protocol_a6fdb18e99c2052467dcb9079673f9764}{Ipv4\+Interface\+Reverse\+Container} \hyperlink{classns3_1_1Ipv4L3Protocol_aa222dd0d50b6a835033b4cec1d63c096}{m\+\_\+reverse\+Interfaces\+Container}
\begin{DoxyCompactList}\small\item\em Container of \hyperlink{classns3_1_1NetDevice}{Net\+Device} / Interface index associations. \end{DoxyCompactList}\item 
uint8\+\_\+t \hyperlink{classns3_1_1Ipv4L3Protocol_aca3ce2700f8f7334464866ab2a76e427}{m\+\_\+default\+Ttl}
\begin{DoxyCompactList}\small\item\em Default T\+TL. \end{DoxyCompactList}\item 
std\+::map$<$ std\+::pair$<$ uint64\+\_\+t, uint8\+\_\+t $>$, uint16\+\_\+t $>$ \hyperlink{classns3_1_1Ipv4L3Protocol_a64746ae9a15d32cd8d0b4467d6b66949}{m\+\_\+identification}
\begin{DoxyCompactList}\small\item\em Identification (for each \{src, dst, proto\} tuple) \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\+\_\+node}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Node}{Node} attached to stack. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$, uint32\+\_\+t $>$ \hyperlink{classns3_1_1Ipv4L3Protocol_a909297aa7ca87db2b7c91daefa2ed40a}{m\+\_\+send\+Outgoing\+Trace}
\begin{DoxyCompactList}\small\item\em Trace of sent packets. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$, uint32\+\_\+t $>$ \hyperlink{classns3_1_1Ipv4L3Protocol_acc97efd317fd7e0c1a65c6247fa6537a}{m\+\_\+unicast\+Forward\+Trace}
\begin{DoxyCompactList}\small\item\em Trace of unicast forwarded packets. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$, uint32\+\_\+t $>$ \hyperlink{classns3_1_1Ipv4L3Protocol_a70adc805da9b70e8fb6f2a998f4df446}{m\+\_\+local\+Deliver\+Trace}
\begin{DoxyCompactList}\small\item\em Trace of locally delivered packets. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$, uint32\+\_\+t $>$ \hyperlink{classns3_1_1Ipv4L3Protocol_a91a19b062bd7e55da11615385e0e2788}{m\+\_\+tx\+Trace}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$, uint32\+\_\+t $>$ \hyperlink{classns3_1_1Ipv4L3Protocol_a8a973a63eb239c315d630c9ff300823a}{m\+\_\+rx\+Trace}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$, \hyperlink{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1}{Drop\+Reason}, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$, uint32\+\_\+t $>$ \hyperlink{classns3_1_1Ipv4L3Protocol_a80984e2de6a2562b04195b975014cb1b}{m\+\_\+drop\+Trace}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} $>$ \hyperlink{classns3_1_1Ipv4L3Protocol_abc52052cbf9c4104be407221397c7a55}{m\+\_\+routing\+Protocol}
\begin{DoxyCompactList}\small\item\em Routing protocol associated with the stack. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4L3Protocol_a3dd6ac663f7c8ccd87886bc864892dda}{Socket\+List} \hyperlink{classns3_1_1Ipv4L3Protocol_a5f3749c4a9bc9ee5a75f73c33f64aa7c}{m\+\_\+sockets}
\begin{DoxyCompactList}\small\item\em List of I\+Pv4 raw sockets. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4L3Protocol_ac2b81caa9436d6a015bbbb68b6282481}{Map\+Fragments\+\_\+t} \hyperlink{classns3_1_1Ipv4L3Protocol_a0eb853df4608f63e9447d8a33d427ccf}{m\+\_\+fragments}
\begin{DoxyCompactList}\small\item\em Fragmented packets. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1Ipv4L3Protocol_a6ad1c5e5d4bde4a903aadab94c6ec164}{m\+\_\+fragment\+Expiration\+Timeout}
\begin{DoxyCompactList}\small\item\em Expiration timeout. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4L3Protocol_acce90cf84f9acda8706768a1c266bfc8}{Map\+Fragments\+Timers\+\_\+t} \hyperlink{classns3_1_1Ipv4L3Protocol_a3233e1de6e8f43299a353107adafbed2}{m\+\_\+fragments\+Timers}
\begin{DoxyCompactList}\small\item\em Expiration events. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classns3_1_1Ipv4L3Protocol_a1c97ab904d8fa88c56c79a0d235325e9}{\+::\+Ipv4\+L3\+Protocol\+Test\+Case}
\begin{DoxyCompactList}\small\item\em \hyperlink{classIpv4L3ProtocolTestCase}{Ipv4\+L3\+Protocol\+Test\+Case} test case. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Implement the I\+Pv4 layer. 

This is the actual implementation of IP. It contains A\+P\+Is to send and receive packets at the IP layer, as well as A\+P\+Is for IP routing.

This class contains two distinct groups of trace sources. The trace sources \textquotesingle{}Rx\textquotesingle{} and \textquotesingle{}Tx\textquotesingle{} are called, respectively, immediately after receiving from the \hyperlink{classns3_1_1NetDevice}{Net\+Device} and immediately before sending to a \hyperlink{classns3_1_1NetDevice}{Net\+Device} for transmitting a packet. These are low level trace sources that include the \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} already serialized into the packet. In contrast, the Drop, Send\+Outgoing, Unicast\+Forward, and Local\+Deliver trace sources are slightly higher-\/level and pass around the \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} as an explicit parameter and not as part of the packet.

IP fragmentation and reassembly is handled at this level. At the moment the fragmentation does not handle IP option headers, and in particular the ones that shall not be fragmented. Moreover, the actual implementation does not mimic exactly the Linux kernel. Hence it is not possible, for instance, to test a fragmentation attack. 

\subsection{Member Typedef Documentation}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Drop\+Traced\+Callback@{Drop\+Traced\+Callback}}
\index{Drop\+Traced\+Callback@{Drop\+Traced\+Callback}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Drop\+Traced\+Callback}{DropTracedCallback}}]{\setlength{\rightskip}{0pt plus 5cm}typedef void($\ast$  ns3\+::\+Ipv4\+L3\+Protocol\+::\+Drop\+Traced\+Callback) (const {\bf Ipv4\+Header} \&header, {\bf Ptr}$<$ const {\bf Packet} $>$ packet, {\bf Drop\+Reason} reason, {\bf Ptr}$<$ {\bf Ipv4} $>$ ipv4, uint32\+\_\+t interface)}\hypertarget{classns3_1_1Ipv4L3Protocol_a50425a8bb439831d9134fc6061481c53}{}\label{classns3_1_1Ipv4L3Protocol_a50425a8bb439831d9134fc6061481c53}
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback} signature for packet drop events.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em header} & The \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header}. \\
\hline
\mbox{\tt in}  & {\em packet} & The packet. \\
\hline
\mbox{\tt in}  & {\em reason} & The reason the packet was dropped. \\
\hline
\mbox{\tt in}  & {\em ipv4} & \\
\hline
\mbox{\tt in}  & {\em interface} & \\
\hline
\end{DoxyParams}
\begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000007}{Deprecated}]The non-\/const {\ttfamily Ptr$<$\+Ipv4$>$} argument is deprecated and will be changed to {\ttfamily Ptr$<$const Ipv4$>$} in a future release. \end{DoxyRefDesc}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Ipv4\+Interface\+List@{Ipv4\+Interface\+List}}
\index{Ipv4\+Interface\+List@{Ipv4\+Interface\+List}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Ipv4\+Interface\+List}{Ipv4InterfaceList}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::vector$<${\bf Ptr}$<${\bf Ipv4\+Interface}$>$ $>$ {\bf ns3\+::\+Ipv4\+L3\+Protocol\+::\+Ipv4\+Interface\+List}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_ada31b7e1708bfe1fb99a44f5c4f3271f}{}\label{classns3_1_1Ipv4L3Protocol_ada31b7e1708bfe1fb99a44f5c4f3271f}


Container of the I\+Pv4 Interfaces. 

\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Ipv4\+Interface\+Reverse\+Container@{Ipv4\+Interface\+Reverse\+Container}}
\index{Ipv4\+Interface\+Reverse\+Container@{Ipv4\+Interface\+Reverse\+Container}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Ipv4\+Interface\+Reverse\+Container}{Ipv4InterfaceReverseContainer}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::map$<${\bf Ptr}$<$const {\bf Net\+Device}$>$, uint32\+\_\+t $>$ {\bf ns3\+::\+Ipv4\+L3\+Protocol\+::\+Ipv4\+Interface\+Reverse\+Container}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a6fdb18e99c2052467dcb9079673f9764}{}\label{classns3_1_1Ipv4L3Protocol_a6fdb18e99c2052467dcb9079673f9764}


Container of Net\+Devices registered to I\+Pv4 and their interface indexes. 

\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Ipv4\+Payload\+Header\+Pair@{Ipv4\+Payload\+Header\+Pair}}
\index{Ipv4\+Payload\+Header\+Pair@{Ipv4\+Payload\+Header\+Pair}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Ipv4\+Payload\+Header\+Pair}{Ipv4PayloadHeaderPair}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::pair$<${\bf Ptr}$<${\bf Packet}$>$, {\bf Ipv4\+Header}$>$ {\bf ns3\+::\+Ipv4\+L3\+Protocol\+::\+Ipv4\+Payload\+Header\+Pair}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a2bf61de1f7739b9ce8b1dac10fb14b31}{}\label{classns3_1_1Ipv4L3Protocol_a2bf61de1f7739b9ce8b1dac10fb14b31}


Pair of a packet and an \hyperlink{classns3_1_1Ipv4}{Ipv4} header. 

\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!L4\+List\+\_\+t@{L4\+List\+\_\+t}}
\index{L4\+List\+\_\+t@{L4\+List\+\_\+t}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{L4\+List\+\_\+t}{L4List_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::map$<${\bf L4\+List\+Key\+\_\+t}, {\bf Ptr}$<${\bf Ip\+L4\+Protocol}$>$ $>$ {\bf ns3\+::\+Ipv4\+L3\+Protocol\+::\+L4\+List\+\_\+t}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_aca93327d3f9e0fdce61d3e72927bd018}{}\label{classns3_1_1Ipv4L3Protocol_aca93327d3f9e0fdce61d3e72927bd018}


Container of the I\+Pv4 L4 instances. 

\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!L4\+List\+Key\+\_\+t@{L4\+List\+Key\+\_\+t}}
\index{L4\+List\+Key\+\_\+t@{L4\+List\+Key\+\_\+t}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{L4\+List\+Key\+\_\+t}{L4ListKey_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::pair$<$int, int32\+\_\+t$>$ {\bf ns3\+::\+Ipv4\+L3\+Protocol\+::\+L4\+List\+Key\+\_\+t}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_af8c2f6a17623a26e68c785ab1676d91c}{}\label{classns3_1_1Ipv4L3Protocol_af8c2f6a17623a26e68c785ab1676d91c}


Container of the I\+Pv4 L4 keys\+: protocol number, interface index. 

\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Map\+Fragments\+\_\+t@{Map\+Fragments\+\_\+t}}
\index{Map\+Fragments\+\_\+t@{Map\+Fragments\+\_\+t}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Map\+Fragments\+\_\+t}{MapFragments_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::map$<$ std\+::pair$<$uint64\+\_\+t, uint32\+\_\+t$>$, {\bf Ptr}$<${\bf Fragments}$>$ $>$ {\bf ns3\+::\+Ipv4\+L3\+Protocol\+::\+Map\+Fragments\+\_\+t}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_ac2b81caa9436d6a015bbbb68b6282481}{}\label{classns3_1_1Ipv4L3Protocol_ac2b81caa9436d6a015bbbb68b6282481}


Container of fragments, stored as pairs(src+dst addr, src+dst port) / fragment. 

\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Map\+Fragments\+Timers\+\_\+t@{Map\+Fragments\+Timers\+\_\+t}}
\index{Map\+Fragments\+Timers\+\_\+t@{Map\+Fragments\+Timers\+\_\+t}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Map\+Fragments\+Timers\+\_\+t}{MapFragmentsTimers_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::map$<$ std\+::pair$<$uint64\+\_\+t, uint32\+\_\+t$>$, {\bf Event\+Id} $>$ {\bf ns3\+::\+Ipv4\+L3\+Protocol\+::\+Map\+Fragments\+Timers\+\_\+t}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_acce90cf84f9acda8706768a1c266bfc8}{}\label{classns3_1_1Ipv4L3Protocol_acce90cf84f9acda8706768a1c266bfc8}


Container of fragment timeout event, stored as pairs(src+dst addr, src+dst port) / \hyperlink{classns3_1_1EventId}{Event\+Id}. 

\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Sent\+Traced\+Callback@{Sent\+Traced\+Callback}}
\index{Sent\+Traced\+Callback@{Sent\+Traced\+Callback}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Sent\+Traced\+Callback}{SentTracedCallback}}]{\setlength{\rightskip}{0pt plus 5cm}typedef void($\ast$  ns3\+::\+Ipv4\+L3\+Protocol\+::\+Sent\+Traced\+Callback) (const {\bf Ipv4\+Header} \&header, {\bf Ptr}$<$ const {\bf Packet} $>$ packet, uint32\+\_\+t interface)}\hypertarget{classns3_1_1Ipv4L3Protocol_acc7bcfb12c40722923247fc853e47f73}{}\label{classns3_1_1Ipv4L3Protocol_acc7bcfb12c40722923247fc853e47f73}
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback} signature for packet send, forward, or local deliver events.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em header} & The \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header}. \\
\hline
\mbox{\tt in}  & {\em packet} & The packet. \\
\hline
\mbox{\tt in}  & {\em interface} & \\
\hline
\end{DoxyParams}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Socket\+List@{Socket\+List}}
\index{Socket\+List@{Socket\+List}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Socket\+List}{SocketList}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Ptr}$<${\bf Ipv4\+Raw\+Socket\+Impl}$>$ $>$ {\bf ns3\+::\+Ipv4\+L3\+Protocol\+::\+Socket\+List}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a3dd6ac663f7c8ccd87886bc864892dda}{}\label{classns3_1_1Ipv4L3Protocol_a3dd6ac663f7c8ccd87886bc864892dda}


Container of the I\+Pv4 Raw Sockets. 

\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Tx\+Rx\+Traced\+Callback@{Tx\+Rx\+Traced\+Callback}}
\index{Tx\+Rx\+Traced\+Callback@{Tx\+Rx\+Traced\+Callback}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Tx\+Rx\+Traced\+Callback}{TxRxTracedCallback}}]{\setlength{\rightskip}{0pt plus 5cm}typedef void($\ast$  ns3\+::\+Ipv4\+L3\+Protocol\+::\+Tx\+Rx\+Traced\+Callback) ({\bf Ptr}$<$ const {\bf Packet} $>$ packet, {\bf Ptr}$<$ {\bf Ipv4} $>$ ipv4, uint32\+\_\+t interface)}\hypertarget{classns3_1_1Ipv4L3Protocol_a7da7189506cc53d778ccc2b6cba88e2d}{}\label{classns3_1_1Ipv4L3Protocol_a7da7189506cc53d778ccc2b6cba88e2d}
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback} signature for packet transmission or reception events.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em header} & The \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header}. \\
\hline
\mbox{\tt in}  & {\em packet} & The packet. \\
\hline
\mbox{\tt in}  & {\em ipv4} & \\
\hline
\mbox{\tt in}  & {\em interface} & \\
\hline
\end{DoxyParams}
\begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000006}{Deprecated}]The non-\/const {\ttfamily Ptr$<$\+Ipv4$>$} argument is deprecated and will be changed to {\ttfamily Ptr$<$const Ipv4$>$} in a future release. \end{DoxyRefDesc}


\subsection{Member Enumeration Documentation}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Drop\+Reason@{Drop\+Reason}}
\index{Drop\+Reason@{Drop\+Reason}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Drop\+Reason}{DropReason}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf ns3\+::\+Ipv4\+L3\+Protocol\+::\+Drop\+Reason}}\hypertarget{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1}{}\label{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1}


Reason why a packet has been dropped. 

\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{D\+R\+O\+P\+\_\+\+T\+T\+L\+\_\+\+E\+X\+P\+I\+R\+ED@{D\+R\+O\+P\+\_\+\+T\+T\+L\+\_\+\+E\+X\+P\+I\+R\+ED}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!D\+R\+O\+P\+\_\+\+T\+T\+L\+\_\+\+E\+X\+P\+I\+R\+ED@{D\+R\+O\+P\+\_\+\+T\+T\+L\+\_\+\+E\+X\+P\+I\+R\+ED}}\item[{\em 
D\+R\+O\+P\+\_\+\+T\+T\+L\+\_\+\+E\+X\+P\+I\+R\+ED\hypertarget{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1a95ecb5b7c1affd7ca7a6d3d34c38cd40}{}\label{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1a95ecb5b7c1affd7ca7a6d3d34c38cd40}
}]\hyperlink{classns3_1_1Packet}{Packet} T\+TL has expired \index{D\+R\+O\+P\+\_\+\+N\+O\+\_\+\+R\+O\+U\+TE@{D\+R\+O\+P\+\_\+\+N\+O\+\_\+\+R\+O\+U\+TE}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!D\+R\+O\+P\+\_\+\+N\+O\+\_\+\+R\+O\+U\+TE@{D\+R\+O\+P\+\_\+\+N\+O\+\_\+\+R\+O\+U\+TE}}\item[{\em 
D\+R\+O\+P\+\_\+\+N\+O\+\_\+\+R\+O\+U\+TE\hypertarget{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1a6934d63c397ae1ec077fdfcdeb90eb40}{}\label{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1a6934d63c397ae1ec077fdfcdeb90eb40}
}]No route to host \index{D\+R\+O\+P\+\_\+\+B\+A\+D\+\_\+\+C\+H\+E\+C\+K\+S\+UM@{D\+R\+O\+P\+\_\+\+B\+A\+D\+\_\+\+C\+H\+E\+C\+K\+S\+UM}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!D\+R\+O\+P\+\_\+\+B\+A\+D\+\_\+\+C\+H\+E\+C\+K\+S\+UM@{D\+R\+O\+P\+\_\+\+B\+A\+D\+\_\+\+C\+H\+E\+C\+K\+S\+UM}}\item[{\em 
D\+R\+O\+P\+\_\+\+B\+A\+D\+\_\+\+C\+H\+E\+C\+K\+S\+UM\hypertarget{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1a14938788d12f864657e5a3aa5d3e26fd}{}\label{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1a14938788d12f864657e5a3aa5d3e26fd}
}]Bad checksum \index{D\+R\+O\+P\+\_\+\+I\+N\+T\+E\+R\+F\+A\+C\+E\+\_\+\+D\+O\+WN@{D\+R\+O\+P\+\_\+\+I\+N\+T\+E\+R\+F\+A\+C\+E\+\_\+\+D\+O\+WN}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!D\+R\+O\+P\+\_\+\+I\+N\+T\+E\+R\+F\+A\+C\+E\+\_\+\+D\+O\+WN@{D\+R\+O\+P\+\_\+\+I\+N\+T\+E\+R\+F\+A\+C\+E\+\_\+\+D\+O\+WN}}\item[{\em 
D\+R\+O\+P\+\_\+\+I\+N\+T\+E\+R\+F\+A\+C\+E\+\_\+\+D\+O\+WN\hypertarget{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1a8f40f145dce3e9f21e1218ce125a048d}{}\label{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1a8f40f145dce3e9f21e1218ce125a048d}
}]Interface is down so can not send packet \index{D\+R\+O\+P\+\_\+\+R\+O\+U\+T\+E\+\_\+\+E\+R\+R\+OR@{D\+R\+O\+P\+\_\+\+R\+O\+U\+T\+E\+\_\+\+E\+R\+R\+OR}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!D\+R\+O\+P\+\_\+\+R\+O\+U\+T\+E\+\_\+\+E\+R\+R\+OR@{D\+R\+O\+P\+\_\+\+R\+O\+U\+T\+E\+\_\+\+E\+R\+R\+OR}}\item[{\em 
D\+R\+O\+P\+\_\+\+R\+O\+U\+T\+E\+\_\+\+E\+R\+R\+OR\hypertarget{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1aeb35be325e705553daacbf36f035c8f5}{}\label{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1aeb35be325e705553daacbf36f035c8f5}
}]Route error \index{D\+R\+O\+P\+\_\+\+F\+R\+A\+G\+M\+E\+N\+T\+\_\+\+T\+I\+M\+E\+O\+UT@{D\+R\+O\+P\+\_\+\+F\+R\+A\+G\+M\+E\+N\+T\+\_\+\+T\+I\+M\+E\+O\+UT}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!D\+R\+O\+P\+\_\+\+F\+R\+A\+G\+M\+E\+N\+T\+\_\+\+T\+I\+M\+E\+O\+UT@{D\+R\+O\+P\+\_\+\+F\+R\+A\+G\+M\+E\+N\+T\+\_\+\+T\+I\+M\+E\+O\+UT}}\item[{\em 
D\+R\+O\+P\+\_\+\+F\+R\+A\+G\+M\+E\+N\+T\+\_\+\+T\+I\+M\+E\+O\+UT\hypertarget{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1afaf46ea7a6354ebb1e66e891123a9fbb}{}\label{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1afaf46ea7a6354ebb1e66e891123a9fbb}
}]Fragment timeout exceeded \end{description}
\end{Desc}

\begin{DoxyCode}
98   \{
99     \hyperlink{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1a95ecb5b7c1affd7ca7a6d3d34c38cd40}{DROP\_TTL\_EXPIRED} = 1,   
100     \hyperlink{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1a6934d63c397ae1ec077fdfcdeb90eb40}{DROP\_NO\_ROUTE},   
101     \hyperlink{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1a14938788d12f864657e5a3aa5d3e26fd}{DROP\_BAD\_CHECKSUM},   
102     \hyperlink{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1a8f40f145dce3e9f21e1218ce125a048d}{DROP\_INTERFACE\_DOWN},   
103     \hyperlink{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1aeb35be325e705553daacbf36f035c8f5}{DROP\_ROUTE\_ERROR},   
104     \hyperlink{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1afaf46ea7a6354ebb1e66e891123a9fbb}{DROP\_FRAGMENT\_TIMEOUT} 
105   \};
\end{DoxyCode}


\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Ipv4\+L3\+Protocol@{Ipv4\+L3\+Protocol}}
\index{Ipv4\+L3\+Protocol@{Ipv4\+L3\+Protocol}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Ipv4\+L3\+Protocol()}{Ipv4L3Protocol()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv4\+L3\+Protocol\+::\+Ipv4\+L3\+Protocol (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4L3Protocol_a994880814b636138a70977fa8fb51047}{}\label{classns3_1_1Ipv4L3Protocol_a994880814b636138a70977fa8fb51047}

\begin{DoxyCode}
111 \{
112   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
113 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!````~Ipv4\+L3\+Protocol@{$\sim$\+Ipv4\+L3\+Protocol}}
\index{````~Ipv4\+L3\+Protocol@{$\sim$\+Ipv4\+L3\+Protocol}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{$\sim$\+Ipv4\+L3\+Protocol()}{~Ipv4L3Protocol()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv4\+L3\+Protocol\+::$\sim$\+Ipv4\+L3\+Protocol (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a6396c85e2562a15ba495efcf32a63786}{}\label{classns3_1_1Ipv4L3Protocol_a6396c85e2562a15ba495efcf32a63786}

\begin{DoxyCode}
116 \{
117   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
118 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Ipv4\+L3\+Protocol@{Ipv4\+L3\+Protocol}}
\index{Ipv4\+L3\+Protocol@{Ipv4\+L3\+Protocol}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Ipv4\+L3\+Protocol(const Ipv4\+L3\+Protocol \&)}{Ipv4L3Protocol(const Ipv4L3Protocol &)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv4\+L3\+Protocol\+::\+Ipv4\+L3\+Protocol (
\begin{DoxyParamCaption}
\item[{const {\bf Ipv4\+L3\+Protocol} \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a81b92d7401aee401daea5360d478fb60}{}\label{classns3_1_1Ipv4L3Protocol_a81b92d7401aee401daea5360d478fb60}


Copy constructor. 

Defined but not implemented to avoid misuse 

\subsection{Member Function Documentation}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Add\+Address@{Add\+Address}}
\index{Add\+Address@{Add\+Address}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Add\+Address(uint32\+\_\+t i, Ipv4\+Interface\+Address address)}{AddAddress(uint32_t i, Ipv4InterfaceAddress address)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv4\+L3\+Protocol\+::\+Add\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv4\+Interface\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a6392fb16c03883eb3e21c9ac4216967d}{}\label{classns3_1_1Ipv4L3Protocol_a6392fb16c03883eb3e21c9ac4216967d}

\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of an \hyperlink{classns3_1_1Ipv4}{Ipv4} interface \\
\hline
{\em address} & \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} address to associate with the underlying \hyperlink{classns3_1_1Ipv4}{Ipv4} interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the operation succeeded 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4_ad203526cae6a4b86f1bb89e44d2b62f7}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
1125 \{
1126   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} << address);
1127   Ptr<Ipv4Interface> \textcolor{keyword}{interface }= GetInterface (i);
1128   \textcolor{keywordtype}{bool} retVal = interface->AddAddress (address);
1129   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4L3Protocol_abc52052cbf9c4104be407221397c7a55}{m\_routingProtocol} != 0)
1130     \{
1131       \hyperlink{classns3_1_1Ipv4L3Protocol_abc52052cbf9c4104be407221397c7a55}{m\_routingProtocol}->NotifyAddAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, address);
1132     \}
1133   \textcolor{keywordflow}{return} retVal;
1134 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Add\+Interface@{Add\+Interface}}
\index{Add\+Interface@{Add\+Interface}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Add\+Interface(\+Ptr$<$ Net\+Device $>$ device)}{AddInterface(Ptr< NetDevice > device)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Ipv4\+L3\+Protocol\+::\+Add\+Interface (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{device}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_ac6855eb39254f74fa30e7f23a7b100db}{}\label{classns3_1_1Ipv4L3Protocol_ac6855eb39254f74fa30e7f23a7b100db}

\begin{DoxyParams}{Parameters}
{\em device} & device to add to the list of \hyperlink{classns3_1_1Ipv4}{Ipv4} interfaces which can be used as output interfaces during packet forwarding. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the index of the \hyperlink{classns3_1_1Ipv4}{Ipv4} interface added.
\end{DoxyReturn}
Once a device has been added, it can never be removed\+: if you want to disable it, you can invoke \hyperlink{classns3_1_1Ipv4_ac148839884b1ce11f9237ddc523f5cd2}{Ipv4\+::\+Set\+Down} which will make sure that it is never used during packet forwarding. 

Implements \hyperlink{classns3_1_1Ipv4_a637354128b71bc587ea5a6eeaef42469}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
368 \{
369   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << device);
370   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node} != 0);
371 
372   Ptr<TrafficControlLayer> tc = \hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<TrafficControlLayer> ();
373 
374   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (tc != 0);
375 
376   \hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node}->\hyperlink{classns3_1_1Node_af713f0e7ea5c49b4fa0b3613405c45fa}{RegisterProtocolHandler} (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1TrafficControlLayer_ac8d6ccbab480b6b288aa155b8485e178}{TrafficControlLayer::Receive}, tc),
377                                    \hyperlink{classns3_1_1Ipv4L3Protocol_a0146bc84815b7b73adb9c62cdafc9442}{Ipv4L3Protocol::PROT\_NUMBER}, device);
378   \hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node}->\hyperlink{classns3_1_1Node_af713f0e7ea5c49b4fa0b3613405c45fa}{RegisterProtocolHandler} (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1TrafficControlLayer_ac8d6ccbab480b6b288aa155b8485e178}{TrafficControlLayer::Receive}, tc),
379                                    \hyperlink{classns3_1_1ArpL3Protocol_a836aec5bc5e5a8ea1d7f46609dc9cc2c}{ArpL3Protocol::PROT\_NUMBER}, device);
380 
381   tc->RegisterProtocolHandler (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1Ipv4L3Protocol_a2f27fb0a3f698ffb34a654323b063c94}{Ipv4L3Protocol::Receive}, \textcolor{keyword}{this}),
382                                \hyperlink{classns3_1_1Ipv4L3Protocol_a0146bc84815b7b73adb9c62cdafc9442}{Ipv4L3Protocol::PROT\_NUMBER}, device);
383   tc->RegisterProtocolHandler (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&\hyperlink{classns3_1_1ArpL3Protocol_a277509da885e127fb384f296f3858fef}{ArpL3Protocol::Receive}, 
      \hyperlink{namespacens3_af2a7557fe9afdd98d8f6f8f6e412cf5a}{PeekPointer} (GetObject<ArpL3Protocol> ())),
384                                \hyperlink{classns3_1_1ArpL3Protocol_a836aec5bc5e5a8ea1d7f46609dc9cc2c}{ArpL3Protocol::PROT\_NUMBER}, device);
385 
386   Ptr<Ipv4Interface> \textcolor{keyword}{interface }= \hyperlink{group__object_gad1d36559be10afa72c3656fd8598c1e2}{CreateObject}<Ipv4Interface> ();
387   interface->SetNode (\hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node});
388   interface->SetDevice (device);
389   interface->SetTrafficControl (tc);
390   interface->SetForwarding (\hyperlink{classns3_1_1Ipv4L3Protocol_a2dc4e9e459bb2ee5eab3af65df316a15}{m\_ipForward});
391   tc->SetupDevice (device);
392   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv4L3Protocol_afd3f97720c2d1af22f05038fcdb6e089}{AddIpv4Interface} (interface);
393 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Add\+Ipv4\+Interface@{Add\+Ipv4\+Interface}}
\index{Add\+Ipv4\+Interface@{Add\+Ipv4\+Interface}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Add\+Ipv4\+Interface(\+Ptr$<$ Ipv4\+Interface $>$ interface)}{AddIpv4Interface(Ptr< Ipv4Interface > interface)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Ipv4\+L3\+Protocol\+::\+Add\+Ipv4\+Interface (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv4\+Interface} $>$}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_afd3f97720c2d1af22f05038fcdb6e089}{}\label{classns3_1_1Ipv4L3Protocol_afd3f97720c2d1af22f05038fcdb6e089}


Add an I\+Pv4 interface to the stack. 


\begin{DoxyParams}{Parameters}
{\em interface} & interface to add \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
index of newly added interface 
\end{DoxyReturn}

\begin{DoxyCode}
397 \{
398   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << interface);
399   uint32\_t index = \hyperlink{classns3_1_1Ipv4L3Protocol_a0b0f15b24a02f2c9a5d576f633aa2770}{m\_interfaces}.size ();
400   \hyperlink{classns3_1_1Ipv4L3Protocol_a0b0f15b24a02f2c9a5d576f633aa2770}{m\_interfaces}.push\_back (interface);
401   \hyperlink{classns3_1_1Ipv4L3Protocol_aa222dd0d50b6a835033b4cec1d63c096}{m\_reverseInterfacesContainer}[interface->GetDevice ()] = index;
402   \textcolor{keywordflow}{return} index;
403 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 3


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Build\+Header@{Build\+Header}}
\index{Build\+Header@{Build\+Header}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Build\+Header(\+Ipv4\+Address source, Ipv4\+Address destination, uint8\+\_\+t protocol, uint16\+\_\+t payload\+Size, uint8\+\_\+t ttl, uint8\+\_\+t tos, bool may\+Fragment)}{BuildHeader(Ipv4Address source, Ipv4Address destination, uint8_t protocol, uint16_t payloadSize, uint8_t ttl, uint8_t tos, bool mayFragment)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Header} ns3\+::\+Ipv4\+L3\+Protocol\+::\+Build\+Header (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{source, }
\item[{{\bf Ipv4\+Address}}]{destination, }
\item[{uint8\+\_\+t}]{protocol, }
\item[{uint16\+\_\+t}]{payload\+Size, }
\item[{uint8\+\_\+t}]{ttl, }
\item[{uint8\+\_\+t}]{tos, }
\item[{bool}]{may\+Fragment}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a3737569960c655fe5441b21a5ef829d3}{}\label{classns3_1_1Ipv4L3Protocol_a3737569960c655fe5441b21a5ef829d3}


Construct an I\+Pv4 header. 


\begin{DoxyParams}{Parameters}
{\em source} & source I\+Pv4 address \\
\hline
{\em destination} & destination I\+Pv4 address \\
\hline
{\em protocol} & L4 protocol \\
\hline
{\em payload\+Size} & payload size \\
\hline
{\em ttl} & \hyperlink{classns3_1_1Time}{Time} to Live \\
\hline
{\em tos} & Type of Service \\
\hline
{\em may\+Fragment} & true if the packet can be fragmented \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
newly created I\+Pv4 header 
\end{DoxyReturn}

\begin{DoxyCode}
872 \{
873   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << source << destination << (uint16\_t)protocol << payloadSize << (
      uint16\_t)ttl << (uint16\_t)tos << mayFragment);
874   Ipv4Header ipHeader;
875   ipHeader.SetSource (source);
876   ipHeader.SetDestination (destination);
877   ipHeader.SetProtocol (protocol);
878   ipHeader.SetPayloadSize (payloadSize);
879   ipHeader.SetTtl (ttl);
880   ipHeader.SetTos (tos);
881 
882   uint64\_t src = source.Get ();
883   uint64\_t dst = destination.Get ();
884   uint64\_t srcDst = dst | (src << 32);
885   std::pair<uint64\_t, uint8\_t> key = std::make\_pair (srcDst, protocol);
886 
887   \textcolor{keywordflow}{if} (mayFragment == \textcolor{keyword}{true})
888     \{
889       ipHeader.SetMayFragment ();
890       ipHeader.SetIdentification (\hyperlink{classns3_1_1Ipv4L3Protocol_a64746ae9a15d32cd8d0b4467d6b66949}{m\_identification}[key]);
891       \hyperlink{classns3_1_1Ipv4L3Protocol_a64746ae9a15d32cd8d0b4467d6b66949}{m\_identification}[key]++;
892     \}
893   \textcolor{keywordflow}{else}
894     \{
895       ipHeader.SetDontFragment ();
896       \textcolor{comment}{// RFC 6864 does not state anything about atomic datagrams}
897       \textcolor{comment}{// identification requirement:}
898       \textcolor{comment}{// >> Originating sources MAY set the IPv4 ID field of atomic datagrams}
899       \textcolor{comment}{//    to any value.}
900       ipHeader.SetIdentification (\hyperlink{classns3_1_1Ipv4L3Protocol_a64746ae9a15d32cd8d0b4467d6b66949}{m\_identification}[key]);
901       \hyperlink{classns3_1_1Ipv4L3Protocol_a64746ae9a15d32cd8d0b4467d6b66949}{m\_identification}[key]++;
902     \}
903   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Node_a0515bfe9a3aeb6605d657ba855699815}{Node::ChecksumEnabled} ())
904     \{
905       ipHeader.EnableChecksum ();
906     \}
907   \textcolor{keywordflow}{return} ipHeader;
908 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4




Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Call\+Tx\+Trace@{Call\+Tx\+Trace}}
\index{Call\+Tx\+Trace@{Call\+Tx\+Trace}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Call\+Tx\+Trace(const Ipv4\+Header \&ip\+Header, Ptr$<$ Packet $>$ packet, Ptr$<$ Ipv4 $>$ ipv4, uint32\+\_\+t interface)}{CallTxTrace(const Ipv4Header &ipHeader, Ptr< Packet > packet, Ptr< Ipv4 > ipv4, uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+L3\+Protocol\+::\+Call\+Tx\+Trace (
\begin{DoxyParamCaption}
\item[{const {\bf Ipv4\+Header} \&}]{ip\+Header, }
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Ptr}$<$ {\bf Ipv4} $>$}]{ipv4, }
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a04cbb7540c6f22a2870f118715b6a703}{}\label{classns3_1_1Ipv4L3Protocol_a04cbb7540c6f22a2870f118715b6a703}


Make a copy of the packet, add the header and invoke the TX trace callback. 


\begin{DoxyParams}{Parameters}
{\em ip\+Header} & the IP header that will be added to the packet \\
\hline
{\em packet} & the packet \\
\hline
{\em ipv4} & the \hyperlink{classns3_1_1Ipv4}{Ipv4} protocol \\
\hline
{\em interface} & the interface index\\
\hline
\end{DoxyParams}
Note\+: If the \hyperlink{classns3_1_1TracedCallback}{Traced\+Callback} A\+PI ever is extended, we could consider to check for connected functions before adding the header 
\begin{DoxyCode}
713 \{
714   Ptr<Packet> packetCopy = packet->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} ();
715   packetCopy->\hyperlink{classns3_1_1Packet_a465108c595a0bc592095cbcab1832ed8}{AddHeader} (ipHeader);
716   \hyperlink{classns3_1_1Ipv4L3Protocol_a91a19b062bd7e55da11615385e0e2788}{m\_txTrace} (packetCopy, ipv4, interface);
717 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6




Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Create\+Raw\+Socket@{Create\+Raw\+Socket}}
\index{Create\+Raw\+Socket@{Create\+Raw\+Socket}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Create\+Raw\+Socket(void)}{CreateRawSocket(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Socket} $>$ ns3\+::\+Ipv4\+L3\+Protocol\+::\+Create\+Raw\+Socket (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_abc060605c64f9dc7c56f5d8124fbaec2}{}\label{classns3_1_1Ipv4L3Protocol_abc060605c64f9dc7c56f5d8124fbaec2}


Creates a raw socket. 

\begin{DoxyReturn}{Returns}
a smart pointer to the instantiated raw socket 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4_a1356d5645420ef3270bf27e839605f76}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
226 \{
227   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
228   Ptr<Ipv4RawSocketImpl> socket = CreateObject<Ipv4RawSocketImpl> ();
229   socket->SetNode (\hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node});
230   \hyperlink{classns3_1_1Ipv4L3Protocol_a5f3749c4a9bc9ee5a75f73c33f64aa7c}{m\_sockets}.push\_back (socket);
231   \textcolor{keywordflow}{return} socket;
232 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Delete\+Raw\+Socket@{Delete\+Raw\+Socket}}
\index{Delete\+Raw\+Socket@{Delete\+Raw\+Socket}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Delete\+Raw\+Socket(\+Ptr$<$ Socket $>$ socket)}{DeleteRawSocket(Ptr< Socket > socket)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+L3\+Protocol\+::\+Delete\+Raw\+Socket (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Socket} $>$}]{socket}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a170d2d386421ff92c45c2e7dd3f79a5e}{}\label{classns3_1_1Ipv4L3Protocol_a170d2d386421ff92c45c2e7dd3f79a5e}


Deletes a particular raw socket. 


\begin{DoxyParams}{Parameters}
{\em socket} & Smart pointer to the raw socket to be deleted \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv4_a1fb3d05138c4767db2c8c1c524ca3db3}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
235 \{
236   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << socket);
237   \textcolor{keywordflow}{for} (SocketList::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Ipv4L3Protocol_a5f3749c4a9bc9ee5a75f73c33f64aa7c}{m\_sockets}.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1Ipv4L3Protocol_a5f3749c4a9bc9ee5a75f73c33f64aa7c}{m\_sockets}.end (); ++
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
238     \{
239       \textcolor{keywordflow}{if} ((*\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) == socket)
240         \{
241           \hyperlink{classns3_1_1Ipv4L3Protocol_a5f3749c4a9bc9ee5a75f73c33f64aa7c}{m\_sockets}.erase (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
242           \textcolor{keywordflow}{return};
243         \}
244     \}
245   \textcolor{keywordflow}{return};
246 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Do\+Dispose(void)}{DoDispose(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+L3\+Protocol\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_ac8a748f7de27c60d87bbda8b10377f53}{}\label{classns3_1_1Ipv4L3Protocol_ac8a748f7de27c60d87bbda8b10377f53}
Destructor implementation.

This method is called by \hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose()} or by the \hyperlink{classns3_1_1Object}{Object}\textquotesingle{}s destructor, whichever comes first.

Subclasses are expected to implement their real destruction code in an overriden version of this method and chain up to their parent\textquotesingle{}s implementation once they are done. {\itshape i.\+e}, for simplicity, the destructor of every subclass should be empty and its content should be moved to the associated \hyperlink{classns3_1_1Ipv4L3Protocol_ac8a748f7de27c60d87bbda8b10377f53}{Do\+Dispose()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.


\begin{DoxyCode}
286 \{
287   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
288   \textcolor{keywordflow}{for} (L4List\_t::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Ipv4L3Protocol_ab1c0a7a1a453db3c2ca3e47d7e65ff54}{m\_protocols}.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != 
      \hyperlink{classns3_1_1Ipv4L3Protocol_ab1c0a7a1a453db3c2ca3e47d7e65ff54}{m\_protocols}.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
289     \{
290       \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second = 0;
291     \}
292   \hyperlink{classns3_1_1Ipv4L3Protocol_ab1c0a7a1a453db3c2ca3e47d7e65ff54}{m\_protocols}.clear ();
293 
294   \textcolor{keywordflow}{for} (Ipv4InterfaceList::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Ipv4L3Protocol_a0b0f15b24a02f2c9a5d576f633aa2770}{m\_interfaces}.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != 
      \hyperlink{classns3_1_1Ipv4L3Protocol_a0b0f15b24a02f2c9a5d576f633aa2770}{m\_interfaces}.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
295     \{
296       *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0;
297     \}
298   \hyperlink{classns3_1_1Ipv4L3Protocol_a0b0f15b24a02f2c9a5d576f633aa2770}{m\_interfaces}.clear ();
299   \hyperlink{classns3_1_1Ipv4L3Protocol_aa222dd0d50b6a835033b4cec1d63c096}{m\_reverseInterfacesContainer}.clear ();
300 
301   \hyperlink{classns3_1_1Ipv4L3Protocol_a5f3749c4a9bc9ee5a75f73c33f64aa7c}{m\_sockets}.clear ();
302   \hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node} = 0;
303   \hyperlink{classns3_1_1Ipv4L3Protocol_abc52052cbf9c4104be407221397c7a55}{m\_routingProtocol} = 0;
304 
305   \textcolor{keywordflow}{for} (MapFragments\_t::iterator it = \hyperlink{classns3_1_1Ipv4L3Protocol_a0eb853df4608f63e9447d8a33d427ccf}{m\_fragments}.begin (); it != 
      \hyperlink{classns3_1_1Ipv4L3Protocol_a0eb853df4608f63e9447d8a33d427ccf}{m\_fragments}.end (); it++)
306     \{
307       it->second = 0;
308     \}
309 
310   \textcolor{keywordflow}{for} (MapFragmentsTimers\_t::iterator it = \hyperlink{classns3_1_1Ipv4L3Protocol_a3233e1de6e8f43299a353107adafbed2}{m\_fragmentsTimers}.begin (); it != 
      \hyperlink{classns3_1_1Ipv4L3Protocol_a3233e1de6e8f43299a353107adafbed2}{m\_fragmentsTimers}.end (); it++)
311     \{
312       \textcolor{keywordflow}{if} (it->second.IsRunning ())
313         \{
314           it->second.Cancel ();
315         \}
316     \}
317 
318   \hyperlink{classns3_1_1Ipv4L3Protocol_a0eb853df4608f63e9447d8a33d427ccf}{m\_fragments}.clear ();
319   \hyperlink{classns3_1_1Ipv4L3Protocol_a3233e1de6e8f43299a353107adafbed2}{m\_fragmentsTimers}.clear ();
320 
321   \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{Object::DoDispose} ();
322 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Do\+Fragmentation@{Do\+Fragmentation}}
\index{Do\+Fragmentation@{Do\+Fragmentation}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Do\+Fragmentation(\+Ptr$<$ Packet $>$ packet, const Ipv4\+Header \&ipv4\+Header, uint32\+\_\+t out\+Iface\+Mtu, std\+::list$<$ Ipv4\+Payload\+Header\+Pair $>$ \&list\+Fragments)}{DoFragmentation(Ptr< Packet > packet, const Ipv4Header &ipv4Header, uint32_t outIfaceMtu, std::list< Ipv4PayloadHeaderPair > &listFragments)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+L3\+Protocol\+::\+Do\+Fragmentation (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{const {\bf Ipv4\+Header} \&}]{ipv4\+Header, }
\item[{uint32\+\_\+t}]{out\+Iface\+Mtu, }
\item[{{\bf std\+::list}$<$ {\bf Ipv4\+Payload\+Header\+Pair} $>$ \&}]{list\+Fragments}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a5ea602dc1447746c0c3bd90e36ec3888}{}\label{classns3_1_1Ipv4L3Protocol_a5ea602dc1447746c0c3bd90e36ec3888}


Fragment a packet. 


\begin{DoxyParams}{Parameters}
{\em packet} & the packet \\
\hline
{\em ipv4\+Header} & the I\+Pv4 header \\
\hline
{\em out\+Iface\+Mtu} & the M\+TU of the interface \\
\hline
{\em list\+Fragments} & the list of fragments \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1410 \{
1411   \textcolor{comment}{// BEWARE: here we do assume that the header options are not present.}
1412   \textcolor{comment}{// a much more complex handling is necessary in case there are options.}
1413   \textcolor{comment}{// If (when) IPv4 option headers will be implemented, the following code shall be changed.}
1414   \textcolor{comment}{// Of course also the reassemby code shall be changed as well.}
1415 
1416   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << *packet << outIfaceMtu << &listFragments);
1417 
1418   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = packet->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} ();
1419 
1420   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG}( (ipv4Header.GetSerializedSize() == 5*4),
1421                  \textcolor{stringliteral}{"IPv4 fragmentation implementation only works without option headers."} );
1422 
1423   uint16\_t offset = 0;
1424   \textcolor{keywordtype}{bool} moreFragment = \textcolor{keyword}{true};
1425   uint16\_t originalOffset = 0;
1426   \textcolor{keywordtype}{bool} alreadyFragmented = \textcolor{keyword}{false};
1427   uint32\_t currentFragmentablePartSize = 0;
1428 
1429   \textcolor{keywordflow}{if} (!ipv4Header.IsLastFragment())
1430     \{
1431       alreadyFragmented = \textcolor{keyword}{true};
1432       originalOffset = ipv4Header.GetFragmentOffset();
1433     \}
1434 
1435   \textcolor{comment}{// IPv4 fragments are all 8 bytes aligned but the last.}
1436   \textcolor{comment}{// The IP payload size is:}
1437   \textcolor{comment}{// floor( ( outIfaceMtu - ipv4Header.GetSerializedSize() ) /8 ) *8}
1438   uint32\_t fragmentSize = (outIfaceMtu - ipv4Header.GetSerializedSize () ) & ~uint32\_t (0x7);
1439 
1440   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Fragmenting - Target Size: "} << fragmentSize );
1441 
1442   \textcolor{keywordflow}{do}
1443     \{
1444       Ipv4Header fragmentHeader = ipv4Header;
1445 
1446       \textcolor{keywordflow}{if} (p->GetSize () > offset + fragmentSize )
1447         \{
1448           moreFragment = \textcolor{keyword}{true};
1449           currentFragmentablePartSize = fragmentSize;
1450           fragmentHeader.SetMoreFragments ();
1451         \}
1452       \textcolor{keywordflow}{else}
1453         \{
1454           moreFragment = \textcolor{keyword}{false};
1455           currentFragmentablePartSize = p->GetSize () - offset;
1456           \textcolor{keywordflow}{if} (alreadyFragmented)
1457             \{
1458               fragmentHeader.SetMoreFragments ();
1459             \}
1460           \textcolor{keywordflow}{else}
1461             \{
1462               fragmentHeader.SetLastFragment ();
1463             \}
1464         \}
1465 
1466       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Fragment creation - "} << offset << \textcolor{stringliteral}{", "} << currentFragmentablePartSize  );
1467       Ptr<Packet> fragment = p->CreateFragment (offset, currentFragmentablePartSize);
1468       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Fragment created - "} << offset << \textcolor{stringliteral}{", "} << fragment->GetSize ()  );
1469 
1470       fragmentHeader.SetFragmentOffset (offset+originalOffset);
1471       fragmentHeader.SetPayloadSize (currentFragmentablePartSize);
1472 
1473       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Node_a0515bfe9a3aeb6605d657ba855699815}{Node::ChecksumEnabled} ())
1474         \{
1475           fragmentHeader.EnableChecksum ();
1476         \}
1477 
1478       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Fragment check - "} << fragmentHeader.GetFragmentOffset ()  );
1479 
1480       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"New fragment Header "} << fragmentHeader);
1481 
1482       std::ostringstream oss;
1483       oss << fragmentHeader;
1484       fragment->Print (oss);
1485 
1486       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"New fragment "} << *fragment);
1487 
1488       listFragments.push\_back (\hyperlink{classns3_1_1Ipv4L3Protocol_a2bf61de1f7739b9ce8b1dac10fb14b31}{Ipv4PayloadHeaderPair} (fragment, fragmentHeader));
1489 
1490       offset += currentFragmentablePartSize;
1491 
1492     \}
1493   \textcolor{keywordflow}{while} (moreFragment);
1494 
1495   \textcolor{keywordflow}{return};
1496 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9




Here is the caller graph for this function\+:
% FIG 10


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Get\+Address@{Get\+Address}}
\index{Get\+Address@{Get\+Address}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Address(uint32\+\_\+t interface\+Index, uint32\+\_\+t address\+Index) const }{GetAddress(uint32_t interfaceIndex, uint32_t addressIndex) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Interface\+Address} ns3\+::\+Ipv4\+L3\+Protocol\+::\+Get\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{uint32\+\_\+t}]{address\+Index}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a85fa4287313a773dee29aa73fa74a7e0}{}\label{classns3_1_1Ipv4L3Protocol_a85fa4287313a773dee29aa73fa74a7e0}
Because addresses can be removed, the address\+Index is not guaranteed to be static across calls to this method.


\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of an \hyperlink{classns3_1_1Ipv4}{Ipv4} interface \\
\hline
{\em address\+Index} & index of \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} associated to the interface and address\+Index 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4_a5aa7213c1365083840b2311a3cb5b24b}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
1138 \{
1139   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << interfaceIndex << addressIndex);
1140   Ptr<Ipv4Interface> \textcolor{keyword}{interface }= GetInterface (interfaceIndex);
1141   \textcolor{keywordflow}{return} interface->GetAddress (addressIndex);
1142 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Get\+Icmp@{Get\+Icmp}}
\index{Get\+Icmp@{Get\+Icmp}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Icmp(void) const }{GetIcmp(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Icmpv4\+L4\+Protocol} $>$ ns3\+::\+Ipv4\+L3\+Protocol\+::\+Get\+Icmp (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a4dd2b3a24817ed50e7a6f41a5657551c}{}\label{classns3_1_1Ipv4L3Protocol_a4dd2b3a24817ed50e7a6f41a5657551c}


Get I\+C\+M\+Pv4 protocol. 

\begin{DoxyReturn}{Returns}
\hyperlink{classns3_1_1Icmpv4L4Protocol}{Icmpv4\+L4\+Protocol} pointer 
\end{DoxyReturn}

\begin{DoxyCode}
648 \{
649   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
650   Ptr<IpL4Protocol> prot = \hyperlink{classns3_1_1Ipv4L3Protocol_acbe71267a0b2bca4569cf574148d3361}{GetProtocol} (
      \hyperlink{classns3_1_1Icmpv4L4Protocol_a87663e583585956c7833fd188612c238}{Icmpv4L4Protocol::GetStaticProtocolNumber} ());
651   \textcolor{keywordflow}{if} (prot != 0)
652     \{
653       \textcolor{keywordflow}{return} prot->GetObject<Icmpv4L4Protocol> ();
654     \}
655   \textcolor{keywordflow}{else}
656     \{
657       \textcolor{keywordflow}{return} 0;
658     \}
659 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12




Here is the caller graph for this function\+:
% FIG 13


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Get\+Interface@{Get\+Interface}}
\index{Get\+Interface@{Get\+Interface}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Interface(uint32\+\_\+t i) const }{GetInterface(uint32_t i) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv4\+Interface} $>$ ns3\+::\+Ipv4\+L3\+Protocol\+::\+Get\+Interface (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv4L3Protocol_ad58abef6f890f3cc2cf291159a3b8588}{}\label{classns3_1_1Ipv4L3Protocol_ad58abef6f890f3cc2cf291159a3b8588}


Get an interface. 


\begin{DoxyParams}{Parameters}
{\em i} & interface index \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
I\+Pv4 interface pointer 
\end{DoxyReturn}

\begin{DoxyCode}
407 \{
408   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << index);
409   \textcolor{keywordflow}{if} (index < \hyperlink{classns3_1_1Ipv4L3Protocol_a0b0f15b24a02f2c9a5d576f633aa2770}{m\_interfaces}.size ())
410     \{
411       \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv4L3Protocol_a0b0f15b24a02f2c9a5d576f633aa2770}{m\_interfaces}[index];
412     \}
413   \textcolor{keywordflow}{return} 0;
414 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 14


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Get\+Interface\+For\+Address@{Get\+Interface\+For\+Address}}
\index{Get\+Interface\+For\+Address@{Get\+Interface\+For\+Address}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Interface\+For\+Address(\+Ipv4\+Address addr) const }{GetInterfaceForAddress(Ipv4Address addr) const }}]{\setlength{\rightskip}{0pt plus 5cm}int32\+\_\+t ns3\+::\+Ipv4\+L3\+Protocol\+::\+Get\+Interface\+For\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{address}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a8aac475db90ce304c53b23c2d470f6eb}{}\label{classns3_1_1Ipv4L3Protocol_a8aac475db90ce304c53b23c2d470f6eb}


Return the interface number of the interface that has been assigned the specified IP address. 


\begin{DoxyParams}{Parameters}
{\em address} & The IP address being searched for \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The interface number of the \hyperlink{classns3_1_1Ipv4}{Ipv4} interface with the given address or -\/1 if not found.
\end{DoxyReturn}
Each IP interface has one or more IP addresses associated with it. This method searches the list of interfaces for one that holds a particular address. This call takes an IP address as a parameter and returns the interface number of the first interface that has been assigned that address, or -\/1 if not found. There must be an exact match; this method will not match broadcast or multicast addresses. 

Implements \hyperlink{classns3_1_1Ipv4_a001797776dd13d907b9cf0c3c474fa57}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
426 \{
427   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << address);
428   int32\_t \textcolor{keyword}{interface }= 0;
429   \textcolor{keywordflow}{for} (Ipv4InterfaceList::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Ipv4L3Protocol_a0b0f15b24a02f2c9a5d576f633aa2770}{m\_interfaces}.begin (); 
430        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1Ipv4L3Protocol_a0b0f15b24a02f2c9a5d576f633aa2770}{m\_interfaces}.end (); 
431        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++, interface++)
432     \{
433       \textcolor{keywordflow}{for} (uint32\_t j = 0; j < (*i)->GetNAddresses (); j++)
434         \{
435           \textcolor{keywordflow}{if} ((*i)->GetAddress (j).GetLocal () == address)
436             \{
437               \textcolor{keywordflow}{return} interface;
438             \}
439         \}
440     \}
441 
442   \textcolor{keywordflow}{return} -1;
443 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Get\+Interface\+For\+Device@{Get\+Interface\+For\+Device}}
\index{Get\+Interface\+For\+Device@{Get\+Interface\+For\+Device}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Interface\+For\+Device(\+Ptr$<$ const Net\+Device $>$ device) const }{GetInterfaceForDevice(Ptr< const NetDevice > device) const }}]{\setlength{\rightskip}{0pt plus 5cm}int32\+\_\+t ns3\+::\+Ipv4\+L3\+Protocol\+::\+Get\+Interface\+For\+Device (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Net\+Device} $>$}]{device}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a4640baab6b3879020a4146f17e293321}{}\label{classns3_1_1Ipv4L3Protocol_a4640baab6b3879020a4146f17e293321}

\begin{DoxyParams}{Parameters}
{\em device} & The \hyperlink{classns3_1_1NetDevice}{Net\+Device} for an \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The interface number of an \hyperlink{classns3_1_1Ipv4}{Ipv4} interface or -\/1 if not found. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4_ab3ff69819c27af58b02ee4791c94abf7}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
471 \{
472   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << device);
473 
474   Ipv4InterfaceReverseContainer::const\_iterator iter = 
      \hyperlink{classns3_1_1Ipv4L3Protocol_aa222dd0d50b6a835033b4cec1d63c096}{m\_reverseInterfacesContainer}.find (device);
475   \textcolor{keywordflow}{if} (iter != \hyperlink{classns3_1_1Ipv4L3Protocol_aa222dd0d50b6a835033b4cec1d63c096}{m\_reverseInterfacesContainer}.end ())
476     \{
477       \textcolor{keywordflow}{return} (*iter).second;
478     \}
479 
480   \textcolor{keywordflow}{return} -1;
481 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 15


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Get\+Interface\+For\+Prefix@{Get\+Interface\+For\+Prefix}}
\index{Get\+Interface\+For\+Prefix@{Get\+Interface\+For\+Prefix}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Interface\+For\+Prefix(\+Ipv4\+Address addr, Ipv4\+Mask mask) const }{GetInterfaceForPrefix(Ipv4Address addr, Ipv4Mask mask) const }}]{\setlength{\rightskip}{0pt plus 5cm}int32\+\_\+t ns3\+::\+Ipv4\+L3\+Protocol\+::\+Get\+Interface\+For\+Prefix (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{address, }
\item[{{\bf Ipv4\+Mask}}]{mask}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_aedf0ed801978ecf18b1e8ae0d0039a42}{}\label{classns3_1_1Ipv4L3Protocol_aedf0ed801978ecf18b1e8ae0d0039a42}


Return the interface number of first interface found that has an \hyperlink{classns3_1_1Ipv4}{Ipv4} address within the prefix specified by the input address and mask parameters. 


\begin{DoxyParams}{Parameters}
{\em address} & The IP address assigned to the interface of interest. \\
\hline
{\em mask} & The IP prefix to use in the mask \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The interface number of the \hyperlink{classns3_1_1Ipv4}{Ipv4} interface with the given address or -\/1 if not found.
\end{DoxyReturn}
Each IP interface has one or more IP addresses associated with it. This method searches the list of interfaces for the first one found that holds an address that is included within the prefix formed by the input address and mask parameters. The value -\/1 is returned if no match is found. 

Implements \hyperlink{classns3_1_1Ipv4_ac0ac95059f33e44ba2e848749489682b}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
449 \{
450   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << address << mask);
451   int32\_t \textcolor{keyword}{interface }= 0;
452   \textcolor{keywordflow}{for} (Ipv4InterfaceList::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Ipv4L3Protocol_a0b0f15b24a02f2c9a5d576f633aa2770}{m\_interfaces}.begin (); 
453        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1Ipv4L3Protocol_a0b0f15b24a02f2c9a5d576f633aa2770}{m\_interfaces}.end (); 
454        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++, interface++)
455     \{
456       \textcolor{keywordflow}{for} (uint32\_t j = 0; j < (*i)->GetNAddresses (); j++)
457         \{
458           \textcolor{keywordflow}{if} ((*i)->GetAddress (j).GetLocal ().CombineMask (mask) == address.CombineMask (mask))
459             \{
460               \textcolor{keywordflow}{return} interface;
461             \}
462         \}
463     \}
464 
465   \textcolor{keywordflow}{return} -1;
466 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 16


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Get\+Ip\+Forward@{Get\+Ip\+Forward}}
\index{Get\+Ip\+Forward@{Get\+Ip\+Forward}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Ip\+Forward(void) const }{GetIpForward(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv4\+L3\+Protocol\+::\+Get\+Ip\+Forward (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_acbc9196c4f23691e6dde9890f24c5285}{}\label{classns3_1_1Ipv4L3Protocol_acbc9196c4f23691e6dde9890f24c5285}


Get the IP forwarding state. 

\begin{DoxyReturn}{Returns}
true if IP is in forwarding state 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4_ac6803a68ed412d4aae3108afc2afd890}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
1379 \{
1380   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1381   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv4L3Protocol_a2dc4e9e459bb2ee5eab3af65df316a15}{m\_ipForward};
1382 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Get\+Metric@{Get\+Metric}}
\index{Get\+Metric@{Get\+Metric}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Metric(uint32\+\_\+t i) const }{GetMetric(uint32_t i) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Ipv4\+L3\+Protocol\+::\+Get\+Metric (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_af8445efaa4cb715717f0152d37b4ed34}{}\label{classns3_1_1Ipv4L3Protocol_af8445efaa4cb715717f0152d37b4ed34}

\begin{DoxyParams}{Parameters}
{\em interface} & The interface number of an \hyperlink{classns3_1_1Ipv4}{Ipv4} interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
routing metric (cost) associated to the underlying \hyperlink{classns3_1_1Ipv4}{Ipv4} interface 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4_ace48f3304b9da2e15cda01fc8c11efd9}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
1282 \{
1283   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
1284   Ptr<Ipv4Interface> \textcolor{keyword}{interface }= GetInterface (i);
1285   \textcolor{keywordflow}{return} interface->GetMetric ();
1286 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Get\+Mtu@{Get\+Mtu}}
\index{Get\+Mtu@{Get\+Mtu}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Mtu(uint32\+\_\+t i) const }{GetMtu(uint32_t i) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Ipv4\+L3\+Protocol\+::\+Get\+Mtu (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_ad5ec856c17f917cc47a10552ccdd9767}{}\label{classns3_1_1Ipv4L3Protocol_ad5ec856c17f917cc47a10552ccdd9767}

\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of \hyperlink{classns3_1_1Ipv4}{Ipv4} interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the Maximum Transmission Unit (in bytes) associated to the underlying \hyperlink{classns3_1_1Ipv4}{Ipv4} interface 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4_a58545a760ba30f653d2be2adaed0651c}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
1290 \{
1291   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
1292   Ptr<Ipv4Interface> \textcolor{keyword}{interface }= GetInterface (i);
1293   \textcolor{keywordflow}{return} interface->GetDevice ()->GetMtu ();
1294 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Get\+N\+Addresses@{Get\+N\+Addresses}}
\index{Get\+N\+Addresses@{Get\+N\+Addresses}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+N\+Addresses(uint32\+\_\+t interface) const }{GetNAddresses(uint32_t interface) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Ipv4\+L3\+Protocol\+::\+Get\+N\+Addresses (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_ab816ec1b5f680117bc1363b3d9649b22}{}\label{classns3_1_1Ipv4L3Protocol_ab816ec1b5f680117bc1363b3d9649b22}

\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of an \hyperlink{classns3_1_1Ipv4}{Ipv4} interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} entries for the interface. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4_a4de4613f0d5e34eeddd84e81c25768ca}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
1146 \{
1147   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << interface);
1148   Ptr<Ipv4Interface> iface = \hyperlink{classns3_1_1Ipv4L3Protocol_ad58abef6f890f3cc2cf291159a3b8588}{GetInterface} (interface);
1149   \textcolor{keywordflow}{return} iface->GetNAddresses ();
1150 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 17




Here is the caller graph for this function\+:
% FIG 18


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Get\+Net\+Device@{Get\+Net\+Device}}
\index{Get\+Net\+Device@{Get\+Net\+Device}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Net\+Device(uint32\+\_\+t i)}{GetNetDevice(uint32_t i)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Net\+Device} $>$ ns3\+::\+Ipv4\+L3\+Protocol\+::\+Get\+Net\+Device (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a783709154b6f41b3a800b3e67369d501}{}\label{classns3_1_1Ipv4L3Protocol_a783709154b6f41b3a800b3e67369d501}

\begin{DoxyParams}{Parameters}
{\em interface} & The interface number of an \hyperlink{classns3_1_1Ipv4}{Ipv4} interface. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The \hyperlink{classns3_1_1NetDevice}{Net\+Device} associated with the \hyperlink{classns3_1_1Ipv4}{Ipv4} interface number. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4_a3dc128ddb3012e2b27c005d88bc9f695}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
1361 \{
1362   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
1363   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv4L3Protocol_ad58abef6f890f3cc2cf291159a3b8588}{GetInterface} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})->GetDevice ();
1364 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 19




Here is the caller graph for this function\+:
% FIG 20


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Get\+N\+Interfaces@{Get\+N\+Interfaces}}
\index{Get\+N\+Interfaces@{Get\+N\+Interfaces}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+N\+Interfaces(void) const }{GetNInterfaces(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Ipv4\+L3\+Protocol\+::\+Get\+N\+Interfaces (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a6ab2be11c0df97f2d1170bbc737c9628}{}\label{classns3_1_1Ipv4L3Protocol_a6ab2be11c0df97f2d1170bbc737c9628}
\begin{DoxyReturn}{Returns}
the number of interfaces added by the user. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4_ae761207b8bb5414a47e9d5954ca1f1ed}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
418 \{
419   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
420   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv4L3Protocol_a0b0f15b24a02f2c9a5d576f633aa2770}{m\_interfaces}.size ();
421 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 21


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Get\+Protocol@{Get\+Protocol}}
\index{Get\+Protocol@{Get\+Protocol}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Protocol(int protocol\+Number) const }{GetProtocol(int protocolNumber) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ip\+L4\+Protocol} $>$ ns3\+::\+Ipv4\+L3\+Protocol\+::\+Get\+Protocol (
\begin{DoxyParamCaption}
\item[{int}]{protocol\+Number}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_acbe71267a0b2bca4569cf574148d3361}{}\label{classns3_1_1Ipv4L3Protocol_acbe71267a0b2bca4569cf574148d3361}

\begin{DoxyParams}{Parameters}
{\em protocol\+Number} & number of protocol to lookup in this L4 Demux \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a matching L4 Protocol
\end{DoxyReturn}
This method is typically called by lower layers to forward packets up the stack to the right protocol. 

Implements \hyperlink{classns3_1_1Ipv4_acc65667e029c46ec184685674933d956}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
181 \{
182   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << protocolNumber);
183 
184   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv4L3Protocol_acbe71267a0b2bca4569cf574148d3361}{GetProtocol} (protocolNumber, -1);
185 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 22


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Get\+Protocol@{Get\+Protocol}}
\index{Get\+Protocol@{Get\+Protocol}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Protocol(int protocol\+Number, int32\+\_\+t interface\+Index) const }{GetProtocol(int protocolNumber, int32_t interfaceIndex) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ip\+L4\+Protocol} $>$ ns3\+::\+Ipv4\+L3\+Protocol\+::\+Get\+Protocol (
\begin{DoxyParamCaption}
\item[{int}]{protocol\+Number, }
\item[{int32\+\_\+t}]{interface\+Index}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a4c12ae9366588d171aac8cebb74931dc}{}\label{classns3_1_1Ipv4L3Protocol_a4c12ae9366588d171aac8cebb74931dc}


Get L4 protocol by protocol number for the specified interface. 


\begin{DoxyParams}{Parameters}
{\em protocol\+Number} & protocol number \\
\hline
{\em interface\+Index} & interface index, -\/1 means \char`\"{}any\char`\"{} interface. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
corresponding \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} or 0 if not found 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4_a15733f7419f27fb3bee959b1ee256d30}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
189 \{
190   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << protocolNumber << interfaceIndex);
191 
192   \hyperlink{classns3_1_1Ipv4L3Protocol_af8c2f6a17623a26e68c785ab1676d91c}{L4ListKey\_t} key;
193   L4List\_t::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
194   \textcolor{keywordflow}{if} (interfaceIndex >= 0)
195     \{
196       \textcolor{comment}{// try the interface-specific protocol.}
197       key = std::make\_pair (protocolNumber, interfaceIndex);
198       i = \hyperlink{classns3_1_1Ipv4L3Protocol_ab1c0a7a1a453db3c2ca3e47d7e65ff54}{m\_protocols}.find (key);
199       \textcolor{keywordflow}{if} (i != \hyperlink{classns3_1_1Ipv4L3Protocol_ab1c0a7a1a453db3c2ca3e47d7e65ff54}{m\_protocols}.end ())
200         \{
201           \textcolor{keywordflow}{return} i->second;
202         \}
203     \}
204   \textcolor{comment}{// try the generic protocol.}
205   key = std::make\_pair (protocolNumber, -1);
206   i = \hyperlink{classns3_1_1Ipv4L3Protocol_ab1c0a7a1a453db3c2ca3e47d7e65ff54}{m\_protocols}.find (key);
207   \textcolor{keywordflow}{if} (i != \hyperlink{classns3_1_1Ipv4L3Protocol_ab1c0a7a1a453db3c2ca3e47d7e65ff54}{m\_protocols}.end ())
208     \{
209       \textcolor{keywordflow}{return} i->second;
210     \}
211 
212   \textcolor{keywordflow}{return} 0;
213 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Get\+Routing\+Protocol@{Get\+Routing\+Protocol}}
\index{Get\+Routing\+Protocol@{Get\+Routing\+Protocol}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Routing\+Protocol(void) const }{GetRoutingProtocol(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv4\+Routing\+Protocol} $>$ ns3\+::\+Ipv4\+L3\+Protocol\+::\+Get\+Routing\+Protocol (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_aa1e4efbf4978299e47406895c3f4b41d}{}\label{classns3_1_1Ipv4L3Protocol_aa1e4efbf4978299e47406895c3f4b41d}


Get the routing protocol to be used by this \hyperlink{classns3_1_1Ipv4}{Ipv4} stack. 

\begin{DoxyReturn}{Returns}
smart pointer to \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} object, or null pointer if none 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4_a62b179607cbea43b510447c422186da1}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
279 \{
280   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
281   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv4L3Protocol_abc52052cbf9c4104be407221397c7a55}{m\_routingProtocol};
282 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 23


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Ipv4\+L3\+Protocol\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a6ba2da2443b09b292b75aad2a52ecc4b}{}\label{classns3_1_1Ipv4L3Protocol_a6ba2da2443b09b292b75aad2a52ecc4b}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
55 \{
56   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::Ipv4L3Protocol"})
57     .SetParent<\hyperlink{classns3_1_1Ipv4_a1c15284fe630c76e0c9c75a97f1ff234}{Ipv4}> ()
58     .SetGroupName (\textcolor{stringliteral}{"Internet"})
59     .AddConstructor<\hyperlink{classns3_1_1Ipv4L3Protocol_a994880814b636138a70977fa8fb51047}{Ipv4L3Protocol}> ()
60     .AddAttribute (\textcolor{stringliteral}{"DefaultTtl"},
61                    \textcolor{stringliteral}{"The TTL value set by default on "}
62                    \textcolor{stringliteral}{"all outgoing packets generated on this node."},
63                    UintegerValue (64),
64                    MakeUintegerAccessor (&\hyperlink{classns3_1_1Ipv4L3Protocol_aca3ce2700f8f7334464866ab2a76e427}{Ipv4L3Protocol::m\_defaultTtl}),
65                    MakeUintegerChecker<uint8\_t> ())
66     .AddAttribute (\textcolor{stringliteral}{"FragmentExpirationTimeout"},
67                    \textcolor{stringliteral}{"When this timeout expires, the fragments "}
68                    \textcolor{stringliteral}{"will be cleared from the buffer."},
69                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (30)),
70                    MakeTimeAccessor (&
      \hyperlink{classns3_1_1Ipv4L3Protocol_a6ad1c5e5d4bde4a903aadab94c6ec164}{Ipv4L3Protocol::m\_fragmentExpirationTimeout}),
71                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
72     .AddTraceSource (\textcolor{stringliteral}{"Tx"},
73                      \textcolor{stringliteral}{"Send ipv4 packet to outgoing interface."},
74                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1Ipv4L3Protocol_a91a19b062bd7e55da11615385e0e2788}{Ipv4L3Protocol::m\_txTrace}),
75                      \textcolor{stringliteral}{"ns3::Ipv4L3Protocol::TxRxTracedCallback"})
76     .AddTraceSource (\textcolor{stringliteral}{"Rx"},
77                      \textcolor{stringliteral}{"Receive ipv4 packet from incoming interface."},
78                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1Ipv4L3Protocol_a8a973a63eb239c315d630c9ff300823a}{Ipv4L3Protocol::m\_rxTrace}),
79                      \textcolor{stringliteral}{"ns3::Ipv4L3Protocol::TxRxTracedCallback"})
80     .AddTraceSource (\textcolor{stringliteral}{"Drop"},
81                      \textcolor{stringliteral}{"Drop ipv4 packet"},
82                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1Ipv4L3Protocol_a80984e2de6a2562b04195b975014cb1b}{Ipv4L3Protocol::m\_dropTrace}),
83                      \textcolor{stringliteral}{"ns3::Ipv4L3Protocol::DropTracedCallback"})
84     .AddAttribute (\textcolor{stringliteral}{"InterfaceList"},
85                    \textcolor{stringliteral}{"The set of Ipv4 interfaces associated to this Ipv4 stack."},
86                    \hyperlink{namespacens3_a5de726d8bcea7a51fd68ce5167a66713}{ObjectVectorValue} (),
87                    \hyperlink{namespacens3_a6ad5b3621a5dc72b7030cbb07c73adf6}{MakeObjectVectorAccessor} (&
      \hyperlink{classns3_1_1Ipv4L3Protocol_a0b0f15b24a02f2c9a5d576f633aa2770}{Ipv4L3Protocol::m\_interfaces}),
88                    MakeObjectVectorChecker<Ipv4Interface> ())
89 
90     .AddTraceSource (\textcolor{stringliteral}{"SendOutgoing"},
91                      \textcolor{stringliteral}{"A newly-generated packet by this node is "}
92                      \textcolor{stringliteral}{"about to be queued for transmission"},
93                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1Ipv4L3Protocol_a909297aa7ca87db2b7c91daefa2ed40a}{Ipv4L3Protocol::m\_sendOutgoingTrace}),
94                      \textcolor{stringliteral}{"ns3::Ipv4L3Protocol::SentTracedCallback"})
95     .AddTraceSource (\textcolor{stringliteral}{"UnicastForward"},
96                      \textcolor{stringliteral}{"A unicast IPv4 packet was received by this node "}
97                      \textcolor{stringliteral}{"and is being forwarded to another node"},
98                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1Ipv4L3Protocol_acc97efd317fd7e0c1a65c6247fa6537a}{Ipv4L3Protocol::m\_unicastForwardTrace}),
99                      \textcolor{stringliteral}{"ns3::Ipv4L3Protocol::SentTracedCallback"})
100     .AddTraceSource (\textcolor{stringliteral}{"LocalDeliver"},
101                      \textcolor{stringliteral}{"An IPv4 packet was received by/for this node, "}
102                      \textcolor{stringliteral}{"and it is being forward up the stack"},
103                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1Ipv4L3Protocol_a70adc805da9b70e8fb6f2a998f4df446}{Ipv4L3Protocol::m\_localDeliverTrace}),
104                      \textcolor{stringliteral}{"ns3::Ipv4L3Protocol::SentTracedCallback"})
105 
106   ;
107   \textcolor{keywordflow}{return} tid;
108 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 24


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Get\+Weak\+Es\+Model@{Get\+Weak\+Es\+Model}}
\index{Get\+Weak\+Es\+Model@{Get\+Weak\+Es\+Model}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Weak\+Es\+Model(void) const }{GetWeakEsModel(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv4\+L3\+Protocol\+::\+Get\+Weak\+Es\+Model (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_ad6249ba16ffc906ac0041ce89bdc2cac}{}\label{classns3_1_1Ipv4L3Protocol_ad6249ba16ffc906ac0041ce89bdc2cac}


Get the Weak Es Model status. 

R\+F\+C1122 term for whether host accepts datagram with a dest. address on another interface \begin{DoxyReturn}{Returns}
true for Weak Es Model activated 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4_a3d9882e80ef4e0e2375d89037f3ab5e1}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
1393 \{
1394   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1395   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv4L3Protocol_acbe9c4ed9ec7e33a55fa5b7c687e62f3}{m\_weakEsModel};
1396 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 25


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Handle\+Fragments\+Timeout@{Handle\+Fragments\+Timeout}}
\index{Handle\+Fragments\+Timeout@{Handle\+Fragments\+Timeout}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Handle\+Fragments\+Timeout(std\+::pair$<$ uint64\+\_\+t, uint32\+\_\+t $>$ key, Ipv4\+Header \&ip\+Header, uint32\+\_\+t iif)}{HandleFragmentsTimeout(std::pair< uint64_t, uint32_t > key, Ipv4Header &ipHeader, uint32_t iif)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+L3\+Protocol\+::\+Handle\+Fragments\+Timeout (
\begin{DoxyParamCaption}
\item[{std\+::pair$<$ uint64\+\_\+t, uint32\+\_\+t $>$}]{key, }
\item[{{\bf Ipv4\+Header} \&}]{ip\+Header, }
\item[{uint32\+\_\+t}]{iif}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a387d96062b7810153592f3a6f257de74}{}\label{classns3_1_1Ipv4L3Protocol_a387d96062b7810153592f3a6f257de74}


Process the timeout for packet fragments. 


\begin{DoxyParams}{Parameters}
{\em key} & representing the packet fragments \\
\hline
{\em ip\+Header} & the IP header of the original packet \\
\hline
{\em iif} & Input Interface \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1688 \{
1689   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << &key << &ipHeader << iif);
1690 
1691   MapFragments\_t::iterator it = \hyperlink{classns3_1_1Ipv4L3Protocol_a0eb853df4608f63e9447d8a33d427ccf}{m\_fragments}.find (key);
1692   Ptr<Packet> packet = it->second->GetPartialPacket ();
1693 
1694   \textcolor{comment}{// if we have at least 8 bytes, we can send an ICMP.}
1695   \textcolor{keywordflow}{if} ( packet->GetSize () > 8 )
1696     \{
1697       Ptr<Icmpv4L4Protocol> icmp = \hyperlink{classns3_1_1Ipv4L3Protocol_a4dd2b3a24817ed50e7a6f41a5657551c}{GetIcmp} ();
1698       icmp->SendTimeExceededTtl (ipHeader, packet);
1699     \}
1700   \hyperlink{classns3_1_1Ipv4L3Protocol_a80984e2de6a2562b04195b975014cb1b}{m\_dropTrace} (ipHeader, packet, \hyperlink{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1afaf46ea7a6354ebb1e66e891123a9fbb}{DROP\_FRAGMENT\_TIMEOUT}, 
      \hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<\hyperlink{classns3_1_1Ipv4_a1c15284fe630c76e0c9c75a97f1ff234}{Ipv4}> (), iif);
1701 
1702   \textcolor{comment}{// clear the buffers}
1703   it->second = 0;
1704 
1705   \hyperlink{classns3_1_1Ipv4L3Protocol_a0eb853df4608f63e9447d8a33d427ccf}{m\_fragments}.erase (key);
1706   \hyperlink{classns3_1_1Ipv4L3Protocol_a3233e1de6e8f43299a353107adafbed2}{m\_fragmentsTimers}.erase (key);
1707 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 26




Here is the caller graph for this function\+:
% FIG 27


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Insert@{Insert}}
\index{Insert@{Insert}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Insert(\+Ptr$<$ Ip\+L4\+Protocol $>$ protocol)}{Insert(Ptr< IpL4Protocol > protocol)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+L3\+Protocol\+::\+Insert (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ip\+L4\+Protocol} $>$}]{protocol}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_adcca82f024e576d06b4687ec3519ed8b}{}\label{classns3_1_1Ipv4L3Protocol_adcca82f024e576d06b4687ec3519ed8b}

\begin{DoxyParams}{Parameters}
{\em protocol} & a template for the protocol to add to this L4 Demux. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the L4\+Protocol effectively added.
\end{DoxyReturn}
Invoke Copy on the input template to get a copy of the input protocol which can be used on the \hyperlink{classns3_1_1Node}{Node} on which this L4 Demux is running. The new L4\+Protocol is registered internally as a working L4 Protocol and returned from this method. The caller does not get ownership of the returned pointer. 

Implements \hyperlink{classns3_1_1Ipv4_a4a3a2344ac44ff2126feb034f172671d}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
122 \{
123   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << protocol);
124   \hyperlink{classns3_1_1Ipv4L3Protocol_af8c2f6a17623a26e68c785ab1676d91c}{L4ListKey\_t} key = std::make\_pair (protocol->GetProtocolNumber (), -1);
125   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4L3Protocol_ab1c0a7a1a453db3c2ca3e47d7e65ff54}{m\_protocols}.find (key) != \hyperlink{classns3_1_1Ipv4L3Protocol_ab1c0a7a1a453db3c2ca3e47d7e65ff54}{m\_protocols}.end ())
126     \{
127       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Overwriting default protocol "} << \textcolor{keywordtype}{int}(protocol->GetProtocolNumber ()));
128     \}
129   \hyperlink{classns3_1_1Ipv4L3Protocol_ab1c0a7a1a453db3c2ca3e47d7e65ff54}{m\_protocols}[key] = protocol;
130 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Insert@{Insert}}
\index{Insert@{Insert}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Insert(\+Ptr$<$ Ip\+L4\+Protocol $>$ protocol, uint32\+\_\+t interface\+Index)}{Insert(Ptr< IpL4Protocol > protocol, uint32_t interfaceIndex)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+L3\+Protocol\+::\+Insert (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ip\+L4\+Protocol} $>$}]{protocol, }
\item[{uint32\+\_\+t}]{interface\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a2c8c7ce0f9c6e8ca5825d9abc5554f1c}{}\label{classns3_1_1Ipv4L3Protocol_a2c8c7ce0f9c6e8ca5825d9abc5554f1c}


Add a L4 protocol to a specific interface. 

This may be called multiple times for multiple interfaces for the same protocol. To insert for all interfaces, use the separate Insert (Ptr$<$\+Ip\+L4\+Protocol$>$ protocol) method.

Setting a protocol on a specific interface will overwrite the previously bound protocol.


\begin{DoxyParams}{Parameters}
{\em protocol} & L4 protocol. \\
\hline
{\em interface\+Index} & interface index. \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv4_a8bfa5664c5dfd59f7e12e4cd59f28f00}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
134 \{
135   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << protocol << interfaceIndex);
136 
137   \hyperlink{classns3_1_1Ipv4L3Protocol_af8c2f6a17623a26e68c785ab1676d91c}{L4ListKey\_t} key = std::make\_pair (protocol->GetProtocolNumber (), interfaceIndex);
138   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4L3Protocol_ab1c0a7a1a453db3c2ca3e47d7e65ff54}{m\_protocols}.find (key) != \hyperlink{classns3_1_1Ipv4L3Protocol_ab1c0a7a1a453db3c2ca3e47d7e65ff54}{m\_protocols}.end ())
139     \{
140       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Overwriting protocol "} << \textcolor{keywordtype}{int}(protocol->GetProtocolNumber ()) << \textcolor{stringliteral}{" on
       interface "} << \textcolor{keywordtype}{int}(interfaceIndex));
141     \}
142   \hyperlink{classns3_1_1Ipv4L3Protocol_ab1c0a7a1a453db3c2ca3e47d7e65ff54}{m\_protocols}[key] = protocol;
143 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Ip\+Forward@{Ip\+Forward}}
\index{Ip\+Forward@{Ip\+Forward}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Ip\+Forward(\+Ptr$<$ Ipv4\+Route $>$ rtentry, Ptr$<$ const Packet $>$ p, const Ipv4\+Header \&header)}{IpForward(Ptr< Ipv4Route > rtentry, Ptr< const Packet > p, const Ipv4Header &header)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+L3\+Protocol\+::\+Ip\+Forward (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv4\+Route} $>$}]{rtentry, }
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv4\+Header} \&}]{header}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_ae00b4ef6c6907a602898800ee5dcbc57}{}\label{classns3_1_1Ipv4L3Protocol_ae00b4ef6c6907a602898800ee5dcbc57}


Forward a packet. 


\begin{DoxyParams}{Parameters}
{\em rtentry} & route \\
\hline
{\em p} & packet to forward \\
\hline
{\em header} & I\+Pv4 header to add to the packet \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1023 \{
1024   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << rtentry << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} << header);
1025   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Forwarding logic for node: "} << \hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node}->\hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} ());
1026   \textcolor{comment}{// Forwarding}
1027   Ipv4Header ipHeader = header;
1028   Ptr<Packet> packet = \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->Copy ();
1029   int32\_t \textcolor{keyword}{interface }= \hyperlink{classns3_1_1Ipv4L3Protocol_a4640baab6b3879020a4146f17e293321}{GetInterfaceForDevice} (rtentry->GetOutputDevice ());
1030   ipHeader.SetTtl (ipHeader.GetTtl () - 1);
1031   \textcolor{keywordflow}{if} (ipHeader.GetTtl () == 0)
1032     \{
1033       \textcolor{comment}{// Do not reply to ICMP or to multicast/broadcast IP address }
1034       \textcolor{keywordflow}{if} (ipHeader.GetProtocol () != \hyperlink{classns3_1_1Icmpv4L4Protocol_a3419e4f8f36662059a64fcb29c3384ad}{Icmpv4L4Protocol::PROT\_NUMBER} && 
1035           ipHeader.GetDestination ().IsBroadcast () == \textcolor{keyword}{false} &&
1036           ipHeader.GetDestination ().IsMulticast () == \textcolor{keyword}{false})
1037         \{
1038           Ptr<Icmpv4L4Protocol> icmp = \hyperlink{classns3_1_1Ipv4L3Protocol_a4dd2b3a24817ed50e7a6f41a5657551c}{GetIcmp} ();
1039           icmp->SendTimeExceededTtl (ipHeader, packet);
1040         \}
1041       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"TTL exceeded.  Drop."});
1042       \hyperlink{classns3_1_1Ipv4L3Protocol_a80984e2de6a2562b04195b975014cb1b}{m\_dropTrace} (header, packet, \hyperlink{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1a95ecb5b7c1affd7ca7a6d3d34c38cd40}{DROP\_TTL\_EXPIRED}, 
      \hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<\hyperlink{classns3_1_1Ipv4_a1c15284fe630c76e0c9c75a97f1ff234}{Ipv4}> (), interface);
1043       \textcolor{keywordflow}{return};
1044     \}
1045   \textcolor{comment}{// in case the packet still has a priority tag attached, remove it}
1046   SocketPriorityTag priorityTag;
1047   packet->RemovePacketTag (priorityTag);
1048   uint8\_t priority = \hyperlink{classns3_1_1Socket_a81564620cc94d291f1dc5d79b2f13b4a}{Socket::IpTos2Priority} (ipHeader.GetTos ());
1049   \textcolor{comment}{// add a priority tag if the priority is not null}
1050   \textcolor{keywordflow}{if} (priority)
1051     \{
1052       priorityTag.SetPriority (priority);
1053       packet->AddPacketTag (priorityTag);
1054     \}
1055 
1056   \hyperlink{classns3_1_1Ipv4L3Protocol_acc97efd317fd7e0c1a65c6247fa6537a}{m\_unicastForwardTrace} (ipHeader, packet, interface);
1057   \hyperlink{classns3_1_1Ipv4L3Protocol_ac1baf310b12bbc564d0766061ecca323}{SendRealOut} (rtentry, packet, ipHeader);
1058 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 28




Here is the caller graph for this function\+:
% FIG 29


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Ip\+Multicast\+Forward@{Ip\+Multicast\+Forward}}
\index{Ip\+Multicast\+Forward@{Ip\+Multicast\+Forward}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Ip\+Multicast\+Forward(\+Ptr$<$ Ipv4\+Multicast\+Route $>$ mrtentry, Ptr$<$ const Packet $>$ p, const Ipv4\+Header \&header)}{IpMulticastForward(Ptr< Ipv4MulticastRoute > mrtentry, Ptr< const Packet > p, const Ipv4Header &header)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+L3\+Protocol\+::\+Ip\+Multicast\+Forward (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv4\+Multicast\+Route} $>$}]{mrtentry, }
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv4\+Header} \&}]{header}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a85ad438d9b2c50d55d1b674b9fd1e8f7}{}\label{classns3_1_1Ipv4L3Protocol_a85ad438d9b2c50d55d1b674b9fd1e8f7}


Forward a multicast packet. 


\begin{DoxyParams}{Parameters}
{\em mrtentry} & route \\
\hline
{\em p} & packet to forward \\
\hline
{\em header} & I\+Pv4 header to add to the packet \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
988 \{
989   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << mrtentry << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} << header);
990   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Multicast forwarding logic for node: "} << \hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node}->
      \hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} ());
991 
992   std::map<uint32\_t, uint32\_t> ttlMap = mrtentry->GetOutputTtlMap ();
993   std::map<uint32\_t, uint32\_t>::iterator mapIter;
994 
995   \textcolor{keywordflow}{for} (mapIter = ttlMap.begin (); mapIter != ttlMap.end (); mapIter++)
996     \{
997       uint32\_t interfaceId = mapIter->first;
998       \textcolor{comment}{//uint32\_t outputTtl = mapIter->second;  // Unused for now}
999 
1000       Ptr<Packet> packet = \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->Copy ();
1001       Ipv4Header h = header;
1002       h.SetTtl (header.GetTtl () - 1);
1003       \textcolor{keywordflow}{if} (h.GetTtl () == 0)
1004         \{
1005           \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"TTL exceeded.  Drop."});
1006           \hyperlink{classns3_1_1Ipv4L3Protocol_a80984e2de6a2562b04195b975014cb1b}{m\_dropTrace} (header, packet, \hyperlink{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1a95ecb5b7c1affd7ca7a6d3d34c38cd40}{DROP\_TTL\_EXPIRED}, 
      \hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<\hyperlink{classns3_1_1Ipv4_a1c15284fe630c76e0c9c75a97f1ff234}{Ipv4}> (), interfaceId);
1007           \textcolor{keywordflow}{return};
1008         \}
1009       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Forward multicast via interface "} << interfaceId);
1010       Ptr<Ipv4Route> rtentry = Create<Ipv4Route> ();
1011       rtentry->SetSource (h.GetSource ());
1012       rtentry->SetDestination (h.GetDestination ());
1013       rtentry->SetGateway (\hyperlink{classns3_1_1Ipv4Address_a7a39b330c8e701183a411d5779fca1a4}{Ipv4Address::GetAny} ());
1014       rtentry->SetOutputDevice (\hyperlink{classns3_1_1Ipv4L3Protocol_a783709154b6f41b3a800b3e67369d501}{GetNetDevice} (interfaceId));
1015       \hyperlink{classns3_1_1Ipv4L3Protocol_ac1baf310b12bbc564d0766061ecca323}{SendRealOut} (rtentry, packet, h);
1016       \textcolor{keywordflow}{continue};
1017     \}
1018 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 30




Here is the caller graph for this function\+:
% FIG 31


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Is\+Destination\+Address@{Is\+Destination\+Address}}
\index{Is\+Destination\+Address@{Is\+Destination\+Address}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Is\+Destination\+Address(\+Ipv4\+Address address, uint32\+\_\+t iif) const }{IsDestinationAddress(Ipv4Address address, uint32_t iif) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv4\+L3\+Protocol\+::\+Is\+Destination\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{address, }
\item[{uint32\+\_\+t}]{iif}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a2d76dcdc0c915346d9177afda3b4e388}{}\label{classns3_1_1Ipv4L3Protocol_a2d76dcdc0c915346d9177afda3b4e388}


Determine whether address and interface corresponding to received packet can be accepted for local delivery. 


\begin{DoxyParams}{Parameters}
{\em address} & The IP address being considered \\
\hline
{\em iif} & The incoming \hyperlink{classns3_1_1Ipv4}{Ipv4} interface index \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the address is associated with the interface index
\end{DoxyReturn}
This method can be used to determine whether a received packet has an acceptable address for local delivery on the host. The address may be a unicast, multicast, or broadcast address. This method will return true if address is an exact match of a unicast address on one of the host\textquotesingle{}s interfaces (see below), if address corresponds to a multicast group that the host has joined (and the incoming device is acceptable), or if address corresponds to a broadcast address.

If the \hyperlink{classns3_1_1Ipv4}{Ipv4} attribute Weak\+Es\+Model is true, the unicast address may match any of the \hyperlink{classns3_1_1Ipv4}{Ipv4} addresses on any interface. If the attribute is false, the address must match one assigned to the incoming device. 

Implements \hyperlink{classns3_1_1Ipv4_a82691b73bb7f96ca9932f5545b3d4d9c}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
485 \{
486   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << address << iif);
487   \textcolor{comment}{// First check the incoming interface for a unicast address match}
488   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1Ipv4L3Protocol_ab816ec1b5f680117bc1363b3d9649b22}{GetNAddresses} (iif); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
489     \{
490       Ipv4InterfaceAddress iaddr = \hyperlink{classns3_1_1Ipv4L3Protocol_a85fa4287313a773dee29aa73fa74a7e0}{GetAddress} (iif, \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
491       \textcolor{keywordflow}{if} (address == iaddr.GetLocal ())
492         \{
493           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"For me (destination "} << address << \textcolor{stringliteral}{" match)"});
494           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
495         \}
496       \textcolor{keywordflow}{if} (address == iaddr.GetBroadcast ())
497         \{
498           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"For me (interface broadcast address)"});
499           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
500         \}
501     \}
502 
503   \textcolor{keywordflow}{if} (address.IsMulticast ())
504     \{
505 \textcolor{preprocessor}{#ifdef NOTYET}
506       \textcolor{keywordflow}{if} (MulticastCheckGroup (iif, address ))
507 #endif
508       \textcolor{keywordflow}{if} (\textcolor{keyword}{true})
509         \{
510           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"For me (Ipv4Addr multicast address"});
511           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
512         \}
513     \}
514 
515   \textcolor{keywordflow}{if} (address.IsBroadcast ())
516     \{
517       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"For me (Ipv4Addr broadcast address)"});
518       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
519     \}
520 
521   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4L3Protocol_ad6249ba16ffc906ac0041ce89bdc2cac}{GetWeakEsModel} ())  \textcolor{comment}{// Check other interfaces}
522     \{ 
523       \textcolor{keywordflow}{for} (uint32\_t j = 0; j < \hyperlink{classns3_1_1Ipv4L3Protocol_a6ab2be11c0df97f2d1170bbc737c9628}{GetNInterfaces} (); j++)
524         \{
525           \textcolor{keywordflow}{if} (j == uint32\_t (iif)) \textcolor{keywordflow}{continue};
526           \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1Ipv4L3Protocol_ab816ec1b5f680117bc1363b3d9649b22}{GetNAddresses} (j); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
527             \{
528               Ipv4InterfaceAddress iaddr = \hyperlink{classns3_1_1Ipv4L3Protocol_a85fa4287313a773dee29aa73fa74a7e0}{GetAddress} (j, \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
529               \textcolor{keywordflow}{if} (address == iaddr.GetLocal ())
530                 \{
531                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"For me (destination "} << address << \textcolor{stringliteral}{" match) on another
       interface"});
532                   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
533                 \}
534               \textcolor{comment}{//  This is a small corner case:  match another interface's broadcast address}
535               \textcolor{keywordflow}{if} (address == iaddr.GetBroadcast ())
536                 \{
537                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"For me (interface broadcast address on another interface)"});
538                   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
539                 \}
540             \}
541         \}
542     \}
543   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
544 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 32


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Is\+Forwarding@{Is\+Forwarding}}
\index{Is\+Forwarding@{Is\+Forwarding}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Is\+Forwarding(uint32\+\_\+t i) const }{IsForwarding(uint32_t i) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv4\+L3\+Protocol\+::\+Is\+Forwarding (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a7edb82af155c25e7325d1c91df7d83de}{}\label{classns3_1_1Ipv4L3Protocol_a7edb82af155c25e7325d1c91df7d83de}

\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of \hyperlink{classns3_1_1Ipv4}{Ipv4} interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if IP forwarding enabled for input datagrams on this device 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4_a241bb02749cefd690671a4cbc52a8dae}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
1344 \{
1345   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
1346   Ptr<Ipv4Interface> \textcolor{keyword}{interface }= GetInterface (i);
1347   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Forwarding state: "} << interface->IsForwarding ());
1348   \textcolor{keywordflow}{return} interface->IsForwarding ();
1349 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Is\+Unicast@{Is\+Unicast}}
\index{Is\+Unicast@{Is\+Unicast}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Is\+Unicast(\+Ipv4\+Address ad) const }{IsUnicast(Ipv4Address ad) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv4\+L3\+Protocol\+::\+Is\+Unicast (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{ad}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv4L3Protocol_a344bf4a2d96c51fc4ff355bb9bd56b30}{}\label{classns3_1_1Ipv4L3Protocol_a344bf4a2d96c51fc4ff355bb9bd56b30}


Check if an I\+Pv4 address is unicast according to the node. 

This function checks all the node\textquotesingle{}s interfaces and the respective subnet masks. An address is considered unicast if it\textquotesingle{}s not broadcast, subnet-\/broadcast or multicast.


\begin{DoxyParams}{Parameters}
{\em ad} & address\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the address is unicast 
\end{DoxyReturn}

\begin{DoxyCode}
663 \{
664   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << ad);
665 
666   \textcolor{keywordflow}{if} (ad.IsBroadcast () || ad.IsMulticast ())
667     \{
668       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
669     \}
670   \textcolor{keywordflow}{else}
671     \{
672       \textcolor{comment}{// check for subnet-broadcast}
673       \textcolor{keywordflow}{for} (uint32\_t ifaceIndex = 0; ifaceIndex < \hyperlink{classns3_1_1Ipv4L3Protocol_a6ab2be11c0df97f2d1170bbc737c9628}{GetNInterfaces} (); ifaceIndex++)
674         \{
675           \textcolor{keywordflow}{for} (uint32\_t j = 0; j < \hyperlink{classns3_1_1Ipv4L3Protocol_ab816ec1b5f680117bc1363b3d9649b22}{GetNAddresses} (ifaceIndex); j++)
676             \{
677               Ipv4InterfaceAddress ifAddr = \hyperlink{classns3_1_1Ipv4L3Protocol_a85fa4287313a773dee29aa73fa74a7e0}{GetAddress} (ifaceIndex, j);
678               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Testing address "} << ad << \textcolor{stringliteral}{" with subnet-directed broadcast "} << 
      ifAddr.GetBroadcast () );
679               \textcolor{keywordflow}{if} (ad == ifAddr.GetBroadcast () )
680                 \{
681                   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
682                 \}
683             \}
684         \}
685     \}
686 
687   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
688 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 33


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Is\+Unicast@{Is\+Unicast}}
\index{Is\+Unicast@{Is\+Unicast}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Is\+Unicast(\+Ipv4\+Address ad, Ipv4\+Mask interface\+Mask) const }{IsUnicast(Ipv4Address ad, Ipv4Mask interfaceMask) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv4\+L3\+Protocol\+::\+Is\+Unicast (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{ad, }
\item[{{\bf Ipv4\+Mask}}]{interface\+Mask}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a533891c3db9bb974dba7dc4b530b12ab}{}\label{classns3_1_1Ipv4L3Protocol_a533891c3db9bb974dba7dc4b530b12ab}


Check if an I\+Pv4 address is unicast. 


\begin{DoxyParams}{Parameters}
{\em ad} & address \\
\hline
{\em interface\+Mask} & the network mask \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the address is unicast 
\end{DoxyReturn}

\begin{DoxyCode}
692 \{
693   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << ad << interfaceMask);
694   \textcolor{keywordflow}{return} !ad.IsMulticast () && !ad.IsSubnetDirectedBroadcast (interfaceMask);
695 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 34


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Is\+Up@{Is\+Up}}
\index{Is\+Up@{Is\+Up}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Is\+Up(uint32\+\_\+t i) const }{IsUp(uint32_t i) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv4\+L3\+Protocol\+::\+Is\+Up (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a8f30b837b325a3e332e25d0da91cfbf4}{}\label{classns3_1_1Ipv4L3Protocol_a8f30b837b325a3e332e25d0da91cfbf4}

\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of \hyperlink{classns3_1_1Ipv4}{Ipv4} interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the underlying interface is in the \char`\"{}up\char`\"{} state, false otherwise. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4_af5cc0afb0373b1c3c2014c974aa269ba}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
1298 \{
1299   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
1300   Ptr<Ipv4Interface> \textcolor{keyword}{interface }= GetInterface (i);
1301   \textcolor{keywordflow}{return} interface->IsUp ();
1302 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Local\+Deliver@{Local\+Deliver}}
\index{Local\+Deliver@{Local\+Deliver}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Local\+Deliver(\+Ptr$<$ const Packet $>$ p, Ipv4\+Header const \&ip, uint32\+\_\+t iif)}{LocalDeliver(Ptr< const Packet > p, Ipv4Header const &ip, uint32_t iif)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+L3\+Protocol\+::\+Local\+Deliver (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p, }
\item[{{\bf Ipv4\+Header} const \&}]{ip, }
\item[{uint32\+\_\+t}]{iif}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_aa64669f000ce115efafd5e086995b4ff}{}\label{classns3_1_1Ipv4L3Protocol_aa64669f000ce115efafd5e086995b4ff}


Deliver a packet. 


\begin{DoxyParams}{Parameters}
{\em p} & packet delivered \\
\hline
{\em ip} & I\+Pv4 header \\
\hline
{\em iif} & input interface packet was received \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1062 \{
1063   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << &ip << iif);
1064   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = packet->Copy (); \textcolor{comment}{// need to pass a non-const packet up}
1065   Ipv4Header ipHeader = ip;
1066 
1067   \textcolor{keywordflow}{if} ( !ipHeader.IsLastFragment () || ipHeader.GetFragmentOffset () != 0 )
1068     \{
1069       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Received a fragment, processing "} << *p );
1070       \textcolor{keywordtype}{bool} isPacketComplete;
1071       isPacketComplete = \hyperlink{classns3_1_1Ipv4L3Protocol_a981e183413dccdf40f91d1de4f728f63}{ProcessFragment} (p, ipHeader, iif);
1072       \textcolor{keywordflow}{if} ( isPacketComplete == \textcolor{keyword}{false})
1073         \{
1074           \textcolor{keywordflow}{return};
1075         \}
1076       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Got last fragment, Packet is complete "} << *p );
1077       ipHeader.SetFragmentOffset (0);
1078       ipHeader.SetPayloadSize (p->GetSize ());
1079     \}
1080 
1081   \hyperlink{classns3_1_1Ipv4L3Protocol_a70adc805da9b70e8fb6f2a998f4df446}{m\_localDeliverTrace} (ipHeader, p, iif);
1082 
1083   Ptr<IpL4Protocol> protocol = \hyperlink{classns3_1_1Ipv4L3Protocol_acbe71267a0b2bca4569cf574148d3361}{GetProtocol} (ipHeader.GetProtocol (), iif);
1084   \textcolor{keywordflow}{if} (protocol != 0)
1085     \{
1086       \textcolor{comment}{// we need to make a copy in the unlikely event we hit the}
1087       \textcolor{comment}{// RX\_ENDPOINT\_UNREACH codepath}
1088       Ptr<Packet> copy = p->Copy ();
1089       \textcolor{keyword}{enum} \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80e}{IpL4Protocol::RxStatus} status = 
1090         protocol->Receive (p, ipHeader, \hyperlink{classns3_1_1Ipv4L3Protocol_ad58abef6f890f3cc2cf291159a3b8588}{GetInterface} (iif));
1091       \textcolor{keywordflow}{switch} (status) \{
1092         \textcolor{keywordflow}{case} \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80eabd979bce2f3b22521c81c4115c66317e}{IpL4Protocol::RX\_OK}:
1093         \textcolor{comment}{// fall through}
1094         \textcolor{keywordflow}{case} \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80eac7f4577d3ab1a219d6cb2b6964c49afd}{IpL4Protocol::RX\_ENDPOINT\_CLOSED}:
1095         \textcolor{comment}{// fall through}
1096         \textcolor{keywordflow}{case} \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80eaba0111c02656760e18ca30479e297b07}{IpL4Protocol::RX\_CSUM\_FAILED}:
1097           \textcolor{keywordflow}{break};
1098         \textcolor{keywordflow}{case} \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80ea00e3d2a534b8bd353395254c0735948b}{IpL4Protocol::RX\_ENDPOINT\_UNREACH}:
1099           \textcolor{keywordflow}{if} (ipHeader.GetDestination ().IsBroadcast () == \textcolor{keyword}{true} ||
1100               ipHeader.GetDestination ().IsMulticast () == \textcolor{keyword}{true})
1101             \{
1102               \textcolor{keywordflow}{break}; \textcolor{comment}{// Do not reply to broadcast or multicast}
1103             \}
1104           \textcolor{comment}{// Another case to suppress ICMP is a subnet-directed broadcast}
1105           \textcolor{keywordtype}{bool} subnetDirected = \textcolor{keyword}{false};
1106           \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1Ipv4L3Protocol_ab816ec1b5f680117bc1363b3d9649b22}{GetNAddresses} (iif); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
1107             \{
1108               Ipv4InterfaceAddress addr = \hyperlink{classns3_1_1Ipv4L3Protocol_a85fa4287313a773dee29aa73fa74a7e0}{GetAddress} (iif, \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
1109               \textcolor{keywordflow}{if} (addr.GetLocal ().CombineMask (addr.GetMask ()) == ipHeader.GetDestination ().CombineMask 
      (addr.GetMask ()) &&
1110                   ipHeader.GetDestination ().IsSubnetDirectedBroadcast (addr.GetMask ()))
1111                 \{
1112                   subnetDirected = \textcolor{keyword}{true};
1113                 \}
1114             \}
1115           \textcolor{keywordflow}{if} (subnetDirected == \textcolor{keyword}{false})
1116             \{
1117               \hyperlink{classns3_1_1Ipv4L3Protocol_a4dd2b3a24817ed50e7a6f41a5657551c}{GetIcmp} ()->SendDestUnreachPort (ipHeader, copy);
1118             \}
1119         \}
1120     \}
1121 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 35




Here is the caller graph for this function\+:
% FIG 36


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Notify\+New\+Aggregate@{Notify\+New\+Aggregate}}
\index{Notify\+New\+Aggregate@{Notify\+New\+Aggregate}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Notify\+New\+Aggregate()}{NotifyNewAggregate()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+L3\+Protocol\+::\+Notify\+New\+Aggregate (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a41c7e4fc5a8dba55e9708df7cef9b9c7}{}\label{classns3_1_1Ipv4L3Protocol_a41c7e4fc5a8dba55e9708df7cef9b9c7}
This function will notify other components connected to the node that a new stack member is now connected This will be used to notify Layer 3 protocol of layer 4 protocol stack to connect them together. 

Reimplemented from \hyperlink{classns3_1_1Object_a1bd7211125185a6cd511c35fea4e500f}{ns3\+::\+Object}.


\begin{DoxyCode}
253 \{
254   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
255   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node} == 0)
256     \{
257       Ptr<Node>node = this->GetObject<Node>();
258       \textcolor{comment}{// verify that it's a valid node and that}
259       \textcolor{comment}{// the node has not been set before}
260       \textcolor{keywordflow}{if} (node != 0)
261         \{
262           this->\hyperlink{classns3_1_1Ipv4L3Protocol_a82ef37914ea8bab699575fea23586bc7}{SetNode} (node);
263         \}
264     \}
265   \hyperlink{classns3_1_1Object_a1bd7211125185a6cd511c35fea4e500f}{Ipv4::NotifyNewAggregate} ();
266 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 37


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!operator=@{operator=}}
\index{operator=@{operator=}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{operator=(const Ipv4\+L3\+Protocol \&)}{operator=(const Ipv4L3Protocol &)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+L3\+Protocol}\& ns3\+::\+Ipv4\+L3\+Protocol\+::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf Ipv4\+L3\+Protocol} \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a24c97a3fdb0aa3363e4968c6fb48186f}{}\label{classns3_1_1Ipv4L3Protocol_a24c97a3fdb0aa3363e4968c6fb48186f}


Copy constructor. 

Defined but not implemented to avoid misuse \begin{DoxyReturn}{Returns}
the copied object 
\end{DoxyReturn}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Process\+Fragment@{Process\+Fragment}}
\index{Process\+Fragment@{Process\+Fragment}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Process\+Fragment(\+Ptr$<$ Packet $>$ \&packet, Ipv4\+Header \&ip\+Header, uint32\+\_\+t iif)}{ProcessFragment(Ptr< Packet > &packet, Ipv4Header &ipHeader, uint32_t iif)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv4\+L3\+Protocol\+::\+Process\+Fragment (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$ \&}]{packet, }
\item[{{\bf Ipv4\+Header} \&}]{ip\+Header, }
\item[{uint32\+\_\+t}]{iif}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a981e183413dccdf40f91d1de4f728f63}{}\label{classns3_1_1Ipv4L3Protocol_a981e183413dccdf40f91d1de4f728f63}


Process a packet fragment. 


\begin{DoxyParams}{Parameters}
{\em packet} & the packet \\
\hline
{\em ip\+Header} & the IP header \\
\hline
{\em iif} & Input Interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true is the fragment completed the packet 
\end{DoxyReturn}

\begin{DoxyCode}
1500 \{
1501   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << ipHeader << iif);
1502 
1503   uint64\_t addressCombination = uint64\_t (ipHeader.GetSource ().Get ()) << 32 | uint64\_t (ipHeader.
      GetDestination ().Get ());
1504   uint32\_t idProto = uint32\_t (ipHeader.GetIdentification ()) << 16 | uint32\_t (ipHeader.GetProtocol ());
1505   std::pair<uint64\_t, uint32\_t> key;
1506   \textcolor{keywordtype}{bool} ret = \textcolor{keyword}{false};
1507   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = packet->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} ();
1508 
1509   key.first = addressCombination;
1510   key.second = idProto;
1511 
1512   Ptr<Fragments> fragments;
1513 
1514   MapFragments\_t::iterator it = \hyperlink{classns3_1_1Ipv4L3Protocol_a0eb853df4608f63e9447d8a33d427ccf}{m\_fragments}.find (key);
1515   \textcolor{keywordflow}{if} (it == \hyperlink{classns3_1_1Ipv4L3Protocol_a0eb853df4608f63e9447d8a33d427ccf}{m\_fragments}.end ())
1516     \{
1517       fragments = Create<Fragments> ();
1518       \hyperlink{classns3_1_1Ipv4L3Protocol_a0eb853df4608f63e9447d8a33d427ccf}{m\_fragments}.insert (std::make\_pair (key, fragments));
1519       \hyperlink{classns3_1_1Ipv4L3Protocol_a3233e1de6e8f43299a353107adafbed2}{m\_fragmentsTimers}[key] = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (
      \hyperlink{classns3_1_1Ipv4L3Protocol_a6ad1c5e5d4bde4a903aadab94c6ec164}{m\_fragmentExpirationTimeout},
1520                                                     &
      \hyperlink{classns3_1_1Ipv4L3Protocol_a387d96062b7810153592f3a6f257de74}{Ipv4L3Protocol::HandleFragmentsTimeout}, \textcolor{keyword}{this},
1521                                                     key, ipHeader, iif);
1522     \}
1523   \textcolor{keywordflow}{else}
1524     \{
1525       fragments = it->second;
1526     \}
1527 
1528   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Adding fragment - Size: "} << packet->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ( ) << \textcolor{stringliteral}{" - Offset: "} << (
      ipHeader.GetFragmentOffset ()) );
1529 
1530   fragments->AddFragment (p, ipHeader.GetFragmentOffset (), !ipHeader.IsLastFragment () );
1531 
1532   \textcolor{keywordflow}{if} ( fragments->IsEntire () )
1533     \{
1534       packet = fragments->GetPacket ();
1535       fragments = 0;
1536       \hyperlink{classns3_1_1Ipv4L3Protocol_a0eb853df4608f63e9447d8a33d427ccf}{m\_fragments}.erase (key);
1537       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4L3Protocol_a3233e1de6e8f43299a353107adafbed2}{m\_fragmentsTimers}[key].IsRunning ())
1538         \{
1539           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Stopping WaitFragmentsTimer at "} << 
      \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds () << \textcolor{stringliteral}{" due to complete packet"});
1540           \hyperlink{classns3_1_1Ipv4L3Protocol_a3233e1de6e8f43299a353107adafbed2}{m\_fragmentsTimers}[key].Cancel ();
1541         \}
1542       \hyperlink{classns3_1_1Ipv4L3Protocol_a3233e1de6e8f43299a353107adafbed2}{m\_fragmentsTimers}.erase (key);
1543       ret = \textcolor{keyword}{true};
1544     \}
1545 
1546   \textcolor{keywordflow}{return} ret;
1547 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 38




Here is the caller graph for this function\+:
% FIG 39


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Receive@{Receive}}
\index{Receive@{Receive}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Receive(\+Ptr$<$ Net\+Device $>$ device, Ptr$<$ const Packet $>$ p, uint16\+\_\+t protocol, const Address \&from, const Address \&to, Net\+Device\+::\+Packet\+Type packet\+Type)}{Receive(Ptr< NetDevice > device, Ptr< const Packet > p, uint16_t protocol, const Address &from, const Address &to, NetDevice::PacketType packetType)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+L3\+Protocol\+::\+Receive (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{device, }
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p, }
\item[{uint16\+\_\+t}]{protocol, }
\item[{const {\bf Address} \&}]{from, }
\item[{const {\bf Address} \&}]{to, }
\item[{{\bf Net\+Device\+::\+Packet\+Type}}]{packet\+Type}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4L3Protocol_a2f27fb0a3f698ffb34a654323b063c94}{}\label{classns3_1_1Ipv4L3Protocol_a2f27fb0a3f698ffb34a654323b063c94}
Lower layer calls this method after calling L3\+Demux\+::\+Lookup The A\+RP subclass needs to know from which \hyperlink{classns3_1_1NetDevice}{Net\+Device} this packet is coming to\+:
\begin{DoxyItemize}
\item implement a per-\/\+Net\+Device A\+RP cache
\item send back arp replies on the right device 
\begin{DoxyParams}{Parameters}
{\em device} & network device \\
\hline
{\em p} & the packet \\
\hline
{\em protocol} & protocol value \\
\hline
{\em from} & address of the correspondent \\
\hline
{\em to} & address of the destination \\
\hline
{\em packet\+Type} & type of the packet \\
\hline
\end{DoxyParams}

\end{DoxyItemize}
\begin{DoxyCode}
549 \{
550   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << device << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} << protocol << \hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from} << to << packetType);
551 
552   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Packet from "} << \hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from} << \textcolor{stringliteral}{" received on node "} << 
553                 \hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node}->\hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} ());
554 
555 
556   int32\_t \textcolor{keyword}{interface }= GetInterfaceForDevice(device);
557   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (interface != -1, \textcolor{stringliteral}{"Received a packet from an interface that is not known to
       IPv4"});
558 
559   Ptr<Packet> packet = \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->Copy ();
560 
561   Ptr<Ipv4Interface> ipv4Interface = \hyperlink{classns3_1_1Ipv4L3Protocol_a0b0f15b24a02f2c9a5d576f633aa2770}{m\_interfaces}[interface];
562 
563   \textcolor{keywordflow}{if} (ipv4Interface->IsUp ())
564     \{
565       \hyperlink{classns3_1_1Ipv4L3Protocol_a8a973a63eb239c315d630c9ff300823a}{m\_rxTrace} (packet, \hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<\hyperlink{classns3_1_1Ipv4_a1c15284fe630c76e0c9c75a97f1ff234}{Ipv4}> (), interface);
566     \}
567   \textcolor{keywordflow}{else}
568     \{
569       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Dropping received packet -- interface is down"});
570       Ipv4Header ipHeader;
571       packet->RemoveHeader (ipHeader);
572       \hyperlink{classns3_1_1Ipv4L3Protocol_a80984e2de6a2562b04195b975014cb1b}{m\_dropTrace} (ipHeader, packet, \hyperlink{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1a8f40f145dce3e9f21e1218ce125a048d}{DROP\_INTERFACE\_DOWN}, 
      \hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<\hyperlink{classns3_1_1Ipv4_a1c15284fe630c76e0c9c75a97f1ff234}{Ipv4}> (), interface);
573       \textcolor{keywordflow}{return};
574     \}
575 
576   Ipv4Header ipHeader;
577   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Node_a0515bfe9a3aeb6605d657ba855699815}{Node::ChecksumEnabled} ())
578     \{
579       ipHeader.EnableChecksum ();
580     \}
581   packet->RemoveHeader (ipHeader);
582 
583   \textcolor{comment}{// Trim any residual frame padding from underlying devices}
584   \textcolor{keywordflow}{if} (ipHeader.GetPayloadSize () < packet->GetSize ())
585     \{
586       packet->RemoveAtEnd (packet->GetSize () - ipHeader.GetPayloadSize ());
587     \}
588 
589   \textcolor{keywordflow}{if} (!ipHeader.IsChecksumOk ()) 
590     \{
591       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Dropping received packet -- checksum not ok"});
592       \hyperlink{classns3_1_1Ipv4L3Protocol_a80984e2de6a2562b04195b975014cb1b}{m\_dropTrace} (ipHeader, packet, \hyperlink{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1a14938788d12f864657e5a3aa5d3e26fd}{DROP\_BAD\_CHECKSUM}, 
      \hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<\hyperlink{classns3_1_1Ipv4_a1c15284fe630c76e0c9c75a97f1ff234}{Ipv4}> (), interface);
593       \textcolor{keywordflow}{return};
594     \}
595 
596   \textcolor{comment}{// the packet is valid, we update the ARP cache entry (if present)}
597   Ptr<ArpCache> arpCache = ipv4Interface->GetArpCache ();
598   \textcolor{keywordflow}{if} (arpCache)
599     \{
600       \textcolor{comment}{// case one, it's a a direct routing.}
601       ArpCache::Entry *entry = arpCache->Lookup (ipHeader.GetSource ());
602       \textcolor{keywordflow}{if} (entry)
603         \{
604           \textcolor{keywordflow}{if} (entry->IsAlive ())
605             \{
606               entry->UpdateSeen ();
607             \}
608         \}
609       \textcolor{keywordflow}{else}
610         \{
611           \textcolor{comment}{// It's not in the direct routing, so it's the router, and it could have multiple IP addresses.}
612           \textcolor{comment}{// In doubt, update all of them.}
613           \textcolor{comment}{// Note: it's a confirmed behavior for Linux routers.}
614           std::list<ArpCache::Entry *> entryList = arpCache->LookupInverse (\hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from});
615           std::list<ArpCache::Entry *>::iterator iter;
616           \textcolor{keywordflow}{for} (iter = entryList.begin (); iter != entryList.end (); iter ++)
617             \{
618               \textcolor{keywordflow}{if} ((*iter)->IsAlive ())
619                 \{
620                   (*iter)->UpdateSeen ();
621                 \}
622             \}
623         \}
624     \}
625 
626   \textcolor{keywordflow}{for} (SocketList::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Ipv4L3Protocol_a5f3749c4a9bc9ee5a75f73c33f64aa7c}{m\_sockets}.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1Ipv4L3Protocol_a5f3749c4a9bc9ee5a75f73c33f64aa7c}{m\_sockets}.end (); ++
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
627     \{
628       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Forwarding to raw socket"}); 
629       Ptr<Ipv4RawSocketImpl> socket = *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
630       socket->ForwardUp (packet, ipHeader, ipv4Interface);
631     \}
632 
633   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\hyperlink{classns3_1_1Ipv4L3Protocol_abc52052cbf9c4104be407221397c7a55}{m\_routingProtocol} != 0, \textcolor{stringliteral}{"Need a routing protocol object to
       process packets"});
634   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1Ipv4L3Protocol_abc52052cbf9c4104be407221397c7a55}{m\_routingProtocol}->RouteInput (packet, ipHeader, device,
635                                       \hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1Ipv4L3Protocol_ae00b4ef6c6907a602898800ee5dcbc57}{Ipv4L3Protocol::IpForward}, \textcolor{keyword}{this}),
636                                       \hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1Ipv4L3Protocol_a85ad438d9b2c50d55d1b674b9fd1e8f7}{Ipv4L3Protocol::IpMulticastForward}, \textcolor{keyword}{this}),
637                                       \hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1Ipv4L3Protocol_aa64669f000ce115efafd5e086995b4ff}{Ipv4L3Protocol::LocalDeliver}, \textcolor{keyword}{this}),
638                                       \hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1Ipv4L3Protocol_a39611a6da4b2d975e3eae9cebf6da6eb}{Ipv4L3Protocol::RouteInputError}, \textcolor{keyword}{this})
639                                       ))
640     \{
641       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"No route found for forwarding packet.  Drop."});
642       \hyperlink{classns3_1_1Ipv4L3Protocol_a80984e2de6a2562b04195b975014cb1b}{m\_dropTrace} (ipHeader, packet, \hyperlink{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1a6934d63c397ae1ec077fdfcdeb90eb40}{DROP\_NO\_ROUTE}, 
      \hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<\hyperlink{classns3_1_1Ipv4_a1c15284fe630c76e0c9c75a97f1ff234}{Ipv4}> (), interface);
643     \}
644 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 40




Here is the caller graph for this function\+:
% FIG 41


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Remove@{Remove}}
\index{Remove@{Remove}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Remove(\+Ptr$<$ Ip\+L4\+Protocol $>$ protocol)}{Remove(Ptr< IpL4Protocol > protocol)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+L3\+Protocol\+::\+Remove (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ip\+L4\+Protocol} $>$}]{protocol}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a718acab47b00b50f77c9acb05efbf220}{}\label{classns3_1_1Ipv4L3Protocol_a718acab47b00b50f77c9acb05efbf220}

\begin{DoxyParams}{Parameters}
{\em protocol} & protocol to remove from this demux.\\
\hline
\end{DoxyParams}
The input value to this method should be the value returned from the Ipv4\+L4\+Protocol\+::\+Insert method. 

Implements \hyperlink{classns3_1_1Ipv4_a53bdb693f9688a3cf51ef8c9d290fdd1}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
147 \{
148   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << protocol);
149 
150   \hyperlink{classns3_1_1Ipv4L3Protocol_af8c2f6a17623a26e68c785ab1676d91c}{L4ListKey\_t} key = std::make\_pair (protocol->GetProtocolNumber (), -1);
151   L4List\_t::iterator iter = \hyperlink{classns3_1_1Ipv4L3Protocol_ab1c0a7a1a453db3c2ca3e47d7e65ff54}{m\_protocols}.find (key);
152   \textcolor{keywordflow}{if} (iter == \hyperlink{classns3_1_1Ipv4L3Protocol_ab1c0a7a1a453db3c2ca3e47d7e65ff54}{m\_protocols}.end ())
153     \{
154       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Trying to remove an non-existent default protocol "} << \textcolor{keywordtype}{int}(protocol->
      GetProtocolNumber ()));
155     \}
156   \textcolor{keywordflow}{else}
157     \{
158       \hyperlink{classns3_1_1Ipv4L3Protocol_ab1c0a7a1a453db3c2ca3e47d7e65ff54}{m\_protocols}.erase (key);
159     \}
160 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Remove@{Remove}}
\index{Remove@{Remove}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Remove(\+Ptr$<$ Ip\+L4\+Protocol $>$ protocol, uint32\+\_\+t interface\+Index)}{Remove(Ptr< IpL4Protocol > protocol, uint32_t interfaceIndex)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+L3\+Protocol\+::\+Remove (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ip\+L4\+Protocol} $>$}]{protocol, }
\item[{uint32\+\_\+t}]{interface\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_abb4d0e17bda74dd318b3ff2cb3db58ee}{}\label{classns3_1_1Ipv4L3Protocol_abb4d0e17bda74dd318b3ff2cb3db58ee}


Remove a L4 protocol from a specific interface. 


\begin{DoxyParams}{Parameters}
{\em protocol} & L4 protocol to remove. \\
\hline
{\em interface\+Index} & interface index. \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv4_ae9b1e38c3c9461ab1344eb1dc8444f63}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
164 \{
165   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << protocol << interfaceIndex);
166 
167   \hyperlink{classns3_1_1Ipv4L3Protocol_af8c2f6a17623a26e68c785ab1676d91c}{L4ListKey\_t} key = std::make\_pair (protocol->GetProtocolNumber (), interfaceIndex);
168   L4List\_t::iterator iter = \hyperlink{classns3_1_1Ipv4L3Protocol_ab1c0a7a1a453db3c2ca3e47d7e65ff54}{m\_protocols}.find (key);
169   \textcolor{keywordflow}{if} (iter == \hyperlink{classns3_1_1Ipv4L3Protocol_ab1c0a7a1a453db3c2ca3e47d7e65ff54}{m\_protocols}.end ())
170     \{
171       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Trying to remove an non-existent protocol "} << \textcolor{keywordtype}{int}(protocol->
      GetProtocolNumber ()) << \textcolor{stringliteral}{" on interface "} << \textcolor{keywordtype}{int}(interfaceIndex));
172     \}
173   \textcolor{keywordflow}{else}
174     \{
175       \hyperlink{classns3_1_1Ipv4L3Protocol_ab1c0a7a1a453db3c2ca3e47d7e65ff54}{m\_protocols}.erase (key);
176     \}
177 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Remove\+Address@{Remove\+Address}}
\index{Remove\+Address@{Remove\+Address}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Remove\+Address(uint32\+\_\+t interface\+Index, uint32\+\_\+t address\+Index)}{RemoveAddress(uint32_t interfaceIndex, uint32_t addressIndex)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv4\+L3\+Protocol\+::\+Remove\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{uint32\+\_\+t}]{address\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a143bb06864cd386728afe563b9f554dc}{}\label{classns3_1_1Ipv4L3Protocol_a143bb06864cd386728afe563b9f554dc}
Remove the address at address\+Index on named interface. The address\+Index for all higher indices will decrement by one after this method is called; so, for example, to remove 5 addresses from an interface i, one could call Remove\+Address (i, 0); 5 times.


\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of an \hyperlink{classns3_1_1Ipv4}{Ipv4} interface \\
\hline
{\em address\+Index} & index of \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} to remove \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the operation succeeded 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4_acc40c575c9eda827a041c5f99fe63401}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
1154 \{
1155   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} << addressIndex);
1156   Ptr<Ipv4Interface> \textcolor{keyword}{interface }= GetInterface (i);
1157   Ipv4InterfaceAddress address = interface->RemoveAddress (addressIndex);
1158   \textcolor{keywordflow}{if} (address != Ipv4InterfaceAddress ())
1159     \{
1160       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4L3Protocol_abc52052cbf9c4104be407221397c7a55}{m\_routingProtocol} != 0)
1161         \{
1162           \hyperlink{classns3_1_1Ipv4L3Protocol_abc52052cbf9c4104be407221397c7a55}{m\_routingProtocol}->NotifyRemoveAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, address);
1163         \}
1164       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1165     \}
1166   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1167 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Remove\+Address@{Remove\+Address}}
\index{Remove\+Address@{Remove\+Address}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Remove\+Address(uint32\+\_\+t interface, Ipv4\+Address address)}{RemoveAddress(uint32_t interface, Ipv4Address address)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv4\+L3\+Protocol\+::\+Remove\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv4\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a30338b1132156b86a8bbf5e6d17c6266}{}\label{classns3_1_1Ipv4L3Protocol_a30338b1132156b86a8bbf5e6d17c6266}


Remove the given address on named \hyperlink{classns3_1_1Ipv4}{Ipv4} interface. 


\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of an \hyperlink{classns3_1_1Ipv4}{Ipv4} interface \\
\hline
{\em address} & The address to remove \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the operation succeeded 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4_a5570da6ab4231f74efcb8c101c2346a0}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
1171 \{
1172   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} << address);
1173 
1174   \textcolor{keywordflow}{if} (address == \hyperlink{classns3_1_1Ipv4Address_a583a93499e0d947439794d7bd0c6366d}{Ipv4Address::GetLoopback}())
1175     \{
1176       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Cannot remove loopback address."});
1177       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1178     \}
1179   Ptr<Ipv4Interface> \textcolor{keyword}{interface }= GetInterface (i);
1180   Ipv4InterfaceAddress ifAddr = interface->RemoveAddress (address);
1181   \textcolor{keywordflow}{if} (ifAddr != Ipv4InterfaceAddress ())
1182     \{
1183       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4L3Protocol_abc52052cbf9c4104be407221397c7a55}{m\_routingProtocol} != 0)
1184         \{
1185           \hyperlink{classns3_1_1Ipv4L3Protocol_abc52052cbf9c4104be407221397c7a55}{m\_routingProtocol}->NotifyRemoveAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, ifAddr);
1186         \}
1187       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1188     \}
1189   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1190 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 42


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Route\+Input\+Error@{Route\+Input\+Error}}
\index{Route\+Input\+Error@{Route\+Input\+Error}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Route\+Input\+Error(\+Ptr$<$ const Packet $>$ p, const Ipv4\+Header \&ip\+Header, Socket\+::\+Socket\+Errno sock\+Errno)}{RouteInputError(Ptr< const Packet > p, const Ipv4Header &ipHeader, Socket::SocketErrno sockErrno)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+L3\+Protocol\+::\+Route\+Input\+Error (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv4\+Header} \&}]{ip\+Header, }
\item[{{\bf Socket\+::\+Socket\+Errno}}]{sock\+Errno}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a39611a6da4b2d975e3eae9cebf6da6eb}{}\label{classns3_1_1Ipv4L3Protocol_a39611a6da4b2d975e3eae9cebf6da6eb}


Fallback when no route is found. 


\begin{DoxyParams}{Parameters}
{\em p} & packet \\
\hline
{\em ip\+Header} & I\+Pv4 header \\
\hline
{\em sock\+Errno} & error number \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1400 \{
1401   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} << ipHeader << sockErrno);
1402   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Route input failure-- dropping packet to "} << ipHeader << \textcolor{stringliteral}{" with errno "} << 
      sockErrno); 
1403   \hyperlink{classns3_1_1Ipv4L3Protocol_a80984e2de6a2562b04195b975014cb1b}{m\_dropTrace} (ipHeader, \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1aeb35be325e705553daacbf36f035c8f5}{DROP\_ROUTE\_ERROR}, \hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node}->
      \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<\hyperlink{classns3_1_1Ipv4_a1c15284fe630c76e0c9c75a97f1ff234}{Ipv4}> (), 0);
1404 
1405   \textcolor{comment}{// \(\backslash\)todo Send an ICMP no route.}
1406 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 43




Here is the caller graph for this function\+:
% FIG 44


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Select\+Source\+Address@{Select\+Source\+Address}}
\index{Select\+Source\+Address@{Select\+Source\+Address}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Select\+Source\+Address(\+Ptr$<$ const Net\+Device $>$ device, Ipv4\+Address dst, Ipv4\+Interface\+Address\+::\+Interface\+Address\+Scope\+\_\+e scope)}{SelectSourceAddress(Ptr< const NetDevice > device, Ipv4Address dst, Ipv4InterfaceAddress::InterfaceAddressScope_e scope)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Address} ns3\+::\+Ipv4\+L3\+Protocol\+::\+Select\+Source\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Net\+Device} $>$}]{device, }
\item[{{\bf Ipv4\+Address}}]{dst, }
\item[{{\bf Ipv4\+Interface\+Address\+::\+Interface\+Address\+Scope\+\_\+e}}]{scope}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_aa7a0d27e88ef21b5e83b36c0e602b6c2}{}\label{classns3_1_1Ipv4L3Protocol_aa7a0d27e88ef21b5e83b36c0e602b6c2}


Return the first primary source address with scope less than or equal to the requested scope, to use in sending a packet to destination dst out of the specified device. 

This method mirrors the behavior of Linux inet\+\_\+select\+\_\+addr() and is provided because interfaces may have multiple IP addresses configured on them with different scopes, and with a primary and secondary status. Secondary addresses are never returned. \begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address}
\end{DoxySeeAlso}
If a non-\/zero device pointer is provided, the method first tries to return a primary address that is configured on that device, and whose subnet matches that of dst and whose scope is less than or equal to the requested scope. If a primary address does not match the subnet of dst but otherwise matches the scope, it is returned. If no such address on the device is found, the other devices are searched in order of their interface index, but not considering dst as a factor in the search. Because a loopback interface is typically the first one configured on a node, it will be the first alternate device to be tried. Addresses scoped at L\+I\+NK scope are not returned in this phase.

If no device pointer is provided, the same logic as above applies, only that there is no preferred device that is consulted first. This means that if the device pointer is null, input parameter dst will be ignored.

If there are no possible addresses to return, a warning log message is issued and the all-\/zeroes address is returned.


\begin{DoxyParams}{Parameters}
{\em device} & output \hyperlink{classns3_1_1NetDevice}{Net\+Device} (optionally provided, only to constrain the search) \\
\hline
{\em dst} & Destination address to match, if device is provided \\
\hline
{\em scope} & Scope of returned address must be less than or equal to this \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the first primary \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} that meets the search criteria 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4_a78f954ad686942a98d456a3dd5d418e5}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
1222 \{
1223   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << device << dst << scope);
1224   Ipv4Address addr (\textcolor{stringliteral}{"0.0.0.0"});
1225   Ipv4InterfaceAddress iaddr; 
1226   \textcolor{keywordtype}{bool} found = \textcolor{keyword}{false};
1227 
1228   \textcolor{keywordflow}{if} (device != 0)
1229     \{
1230       int32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Ipv4L3Protocol_a4640baab6b3879020a4146f17e293321}{GetInterfaceForDevice} (device);
1231       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (i >= 0, \textcolor{stringliteral}{"No device found on node"});
1232       \textcolor{keywordflow}{for} (uint32\_t j = 0; j < \hyperlink{classns3_1_1Ipv4L3Protocol_ab816ec1b5f680117bc1363b3d9649b22}{GetNAddresses} (i); j++)
1233         \{
1234           iaddr = \hyperlink{classns3_1_1Ipv4L3Protocol_a85fa4287313a773dee29aa73fa74a7e0}{GetAddress} (i, j);
1235           \textcolor{keywordflow}{if} (iaddr.IsSecondary ()) \textcolor{keywordflow}{continue};
1236           \textcolor{keywordflow}{if} (iaddr.GetScope () > scope) \textcolor{keywordflow}{continue}; 
1237           \textcolor{keywordflow}{if} (dst.CombineMask (iaddr.GetMask ())  == iaddr.GetLocal ().CombineMask (iaddr.GetMask ()) )
1238             \{
1239               \textcolor{keywordflow}{return} iaddr.GetLocal ();
1240             \}
1241           \textcolor{keywordflow}{if} (!found)
1242             \{
1243               addr = iaddr.GetLocal ();
1244               found = \textcolor{keyword}{true};
1245             \}
1246         \}
1247     \}
1248   \textcolor{keywordflow}{if} (found)
1249     \{
1250       \textcolor{keywordflow}{return} addr;
1251     \}
1252 
1253   \textcolor{comment}{// Iterate among all interfaces}
1254   \textcolor{keywordflow}{for} (uint32\_t i = 0; i < \hyperlink{classns3_1_1Ipv4L3Protocol_a6ab2be11c0df97f2d1170bbc737c9628}{GetNInterfaces} (); i++)
1255     \{
1256       \textcolor{keywordflow}{for} (uint32\_t j = 0; j < \hyperlink{classns3_1_1Ipv4L3Protocol_ab816ec1b5f680117bc1363b3d9649b22}{GetNAddresses} (i); j++)
1257         \{
1258           iaddr = \hyperlink{classns3_1_1Ipv4L3Protocol_a85fa4287313a773dee29aa73fa74a7e0}{GetAddress} (i, j);
1259           \textcolor{keywordflow}{if} (iaddr.IsSecondary ()) \textcolor{keywordflow}{continue};
1260           \textcolor{keywordflow}{if} (iaddr.GetScope () != \hyperlink{classns3_1_1Ipv4InterfaceAddress_a329cea433e74f717c26c9e51c4fcd3d8a0608c8dc6260f682341cb3a1629237ec}{Ipv4InterfaceAddress::LINK} 
1261               && iaddr.GetScope () <= scope) 
1262             \{
1263               \textcolor{keywordflow}{return} iaddr.GetLocal ();
1264             \}
1265         \}
1266     \}
1267   \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Could not find source address for "} << dst << \textcolor{stringliteral}{" and scope "} 
1268                                                     << scope << \textcolor{stringliteral}{", returning 0"});
1269   \textcolor{keywordflow}{return} addr;
1270 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 45


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Send@{Send}}
\index{Send@{Send}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Send(\+Ptr$<$ Packet $>$ packet, Ipv4\+Address source, Ipv4\+Address destination, uint8\+\_\+t protocol, Ptr$<$ Ipv4\+Route $>$ route)}{Send(Ptr< Packet > packet, Ipv4Address source, Ipv4Address destination, uint8_t protocol, Ptr< Ipv4Route > route)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+L3\+Protocol\+::\+Send (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Ipv4\+Address}}]{source, }
\item[{{\bf Ipv4\+Address}}]{destination, }
\item[{uint8\+\_\+t}]{protocol, }
\item[{{\bf Ptr}$<$ {\bf Ipv4\+Route} $>$}]{route}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_abe8cf785815f3fbb32b0e21d629be641}{}\label{classns3_1_1Ipv4L3Protocol_abe8cf785815f3fbb32b0e21d629be641}

\begin{DoxyParams}{Parameters}
{\em packet} & packet to send \\
\hline
{\em source} & source address of packet \\
\hline
{\em destination} & address of packet \\
\hline
{\em protocol} & number of packet \\
\hline
{\em route} & route entry\\
\hline
\end{DoxyParams}
Higher-\/level layers call this method to send a packet down the stack to the M\+AC and P\+HY layers. 

Implements \hyperlink{classns3_1_1Ipv4_a81f6cbb774cdc255e3e49490e0960539}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
725 \{
726   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << source << destination << uint32\_t (protocol) << route);
727 
728   Ipv4Header ipHeader;
729   \textcolor{keywordtype}{bool} mayFragment = \textcolor{keyword}{true};
730   uint8\_t ttl = \hyperlink{classns3_1_1Ipv4L3Protocol_aca3ce2700f8f7334464866ab2a76e427}{m\_defaultTtl};
731   SocketIpTtlTag tag;
732   \textcolor{keywordtype}{bool} found = packet->\hyperlink{classns3_1_1Packet_a078fe922d976a417ab25ba2f3c2fd667}{RemovePacketTag} (tag);
733   \textcolor{keywordflow}{if} (found)
734     \{
735       ttl = tag.GetTtl ();
736     \}
737 
738   uint8\_t tos = 0;
739   SocketIpTosTag ipTosTag;
740   found = packet->\hyperlink{classns3_1_1Packet_a078fe922d976a417ab25ba2f3c2fd667}{RemovePacketTag} (ipTosTag);
741   \textcolor{keywordflow}{if} (found)
742     \{
743       tos = ipTosTag.GetTos ();
744     \}
745 
746   \textcolor{comment}{// Handle a few cases:}
747   \textcolor{comment}{// 1) packet is destined to limited broadcast address}
748   \textcolor{comment}{// 2) packet is destined to a subnet-directed broadcast address}
749   \textcolor{comment}{// 3) packet is not broadcast, and is passed in with a route entry}
750   \textcolor{comment}{// 4) packet is not broadcast, and is passed in with a route entry but route->GetGateway is not set
       (e.g., on-demand)}
751   \textcolor{comment}{// 5) packet is not broadcast, and route is NULL (e.g., a raw socket call, or ICMP)}
752 
753   \textcolor{comment}{// 1) packet is destined to limited broadcast address or link-local multicast address}
754   \textcolor{keywordflow}{if} (destination.IsBroadcast () || destination.IsLocalMulticast ())
755     \{
756       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Ipv4L3Protocol::Send case 1:  limited broadcast"});
757       ipHeader = \hyperlink{classns3_1_1Ipv4L3Protocol_a3737569960c655fe5441b21a5ef829d3}{BuildHeader} (source, destination, protocol, packet->
      \hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} (), ttl, tos, mayFragment);
758       uint32\_t ifaceIndex = 0;
759       \textcolor{keywordflow}{for} (Ipv4InterfaceList::iterator ifaceIter = \hyperlink{classns3_1_1Ipv4L3Protocol_a0b0f15b24a02f2c9a5d576f633aa2770}{m\_interfaces}.begin ();
760            ifaceIter != \hyperlink{classns3_1_1Ipv4L3Protocol_a0b0f15b24a02f2c9a5d576f633aa2770}{m\_interfaces}.end (); ifaceIter++, ifaceIndex++)
761         \{
762           Ptr<Ipv4Interface> outInterface = *ifaceIter;
763           \textcolor{keywordtype}{bool} sendIt = \textcolor{keyword}{false};
764           \textcolor{keywordflow}{if} (source == \hyperlink{classns3_1_1Ipv4Address_a7a39b330c8e701183a411d5779fca1a4}{Ipv4Address::GetAny} ())
765             \{
766               sendIt = \textcolor{keyword}{true};
767             \}
768           \textcolor{keywordflow}{for} (uint32\_t index = 0; index < outInterface->GetNAddresses (); index++)
769             \{
770               \textcolor{keywordflow}{if} (outInterface->GetAddress (index).GetLocal () == source)
771                 \{
772                   sendIt = \textcolor{keyword}{true};
773                 \}
774             \}
775           \textcolor{keywordflow}{if} (sendIt)
776             \{
777               Ptr<Packet> packetCopy = packet->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} ();
778 
779               \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (packetCopy->GetSize () <= outInterface->GetDevice ()->GetMtu ());
780 
781               \hyperlink{classns3_1_1Ipv4L3Protocol_a909297aa7ca87db2b7c91daefa2ed40a}{m\_sendOutgoingTrace} (ipHeader, packetCopy, ifaceIndex);
782               \hyperlink{classns3_1_1Ipv4L3Protocol_a04cbb7540c6f22a2870f118715b6a703}{CallTxTrace} (ipHeader, packetCopy, \hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node}->
      \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<\hyperlink{classns3_1_1Ipv4_a1c15284fe630c76e0c9c75a97f1ff234}{Ipv4}> (), ifaceIndex);
783               outInterface->Send (packetCopy, ipHeader, destination);
784             \}
785         \}
786       \textcolor{keywordflow}{return};
787     \}
788 
789   \textcolor{comment}{// 2) check: packet is destined to a subnet-directed broadcast address}
790   uint32\_t ifaceIndex = 0;
791   \textcolor{keywordflow}{for} (Ipv4InterfaceList::iterator ifaceIter = \hyperlink{classns3_1_1Ipv4L3Protocol_a0b0f15b24a02f2c9a5d576f633aa2770}{m\_interfaces}.begin ();
792        ifaceIter != \hyperlink{classns3_1_1Ipv4L3Protocol_a0b0f15b24a02f2c9a5d576f633aa2770}{m\_interfaces}.end (); ifaceIter++, ifaceIndex++)
793     \{
794       Ptr<Ipv4Interface> outInterface = *ifaceIter;
795       \textcolor{keywordflow}{for} (uint32\_t j = 0; j < \hyperlink{classns3_1_1Ipv4L3Protocol_ab816ec1b5f680117bc1363b3d9649b22}{GetNAddresses} (ifaceIndex); j++)
796         \{
797           Ipv4InterfaceAddress ifAddr = \hyperlink{classns3_1_1Ipv4L3Protocol_a85fa4287313a773dee29aa73fa74a7e0}{GetAddress} (ifaceIndex, j);
798           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Testing address "} << ifAddr.GetLocal () << \textcolor{stringliteral}{" with mask "} << ifAddr.
      GetMask ());
799           \textcolor{keywordflow}{if} (destination.IsSubnetDirectedBroadcast (ifAddr.GetMask ()) && 
800               destination.CombineMask (ifAddr.GetMask ()) == ifAddr.GetLocal ().CombineMask (ifAddr.GetMask
       ())   )
801             \{
802               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Ipv4L3Protocol::Send case 2:  subnet directed bcast to "} << ifAddr
      .GetLocal ());
803               ipHeader = \hyperlink{classns3_1_1Ipv4L3Protocol_a3737569960c655fe5441b21a5ef829d3}{BuildHeader} (source, destination, protocol, packet->
      \hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} (), ttl, tos, mayFragment);
804               Ptr<Packet> packetCopy = packet->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} ();
805               \hyperlink{classns3_1_1Ipv4L3Protocol_a909297aa7ca87db2b7c91daefa2ed40a}{m\_sendOutgoingTrace} (ipHeader, packetCopy, ifaceIndex);
806               \hyperlink{classns3_1_1Ipv4L3Protocol_a04cbb7540c6f22a2870f118715b6a703}{CallTxTrace} (ipHeader, packetCopy, \hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node}->
      \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<\hyperlink{classns3_1_1Ipv4_a1c15284fe630c76e0c9c75a97f1ff234}{Ipv4}> (), ifaceIndex);
807               outInterface->Send (packetCopy, ipHeader, destination);
808               \textcolor{keywordflow}{return};
809             \}
810         \}
811     \}
812 
813   \textcolor{comment}{// 3) packet is not broadcast, and is passed in with a route entry}
814   \textcolor{comment}{//    with a valid Ipv4Address as the gateway}
815   \textcolor{keywordflow}{if} (route && route->GetGateway () != Ipv4Address ())
816     \{
817       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Ipv4L3Protocol::Send case 3:  passed in with route"});
818       ipHeader = \hyperlink{classns3_1_1Ipv4L3Protocol_a3737569960c655fe5441b21a5ef829d3}{BuildHeader} (source, destination, protocol, packet->
      \hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} (), ttl, tos, mayFragment);
819       int32\_t \textcolor{keyword}{interface }= \hyperlink{classns3_1_1Ipv4L3Protocol_a4640baab6b3879020a4146f17e293321}{GetInterfaceForDevice} (route->GetOutputDevice ());
820       \hyperlink{classns3_1_1Ipv4L3Protocol_a909297aa7ca87db2b7c91daefa2ed40a}{m\_sendOutgoingTrace} (ipHeader, packet, interface);
821       \hyperlink{classns3_1_1Ipv4L3Protocol_ac1baf310b12bbc564d0766061ecca323}{SendRealOut} (route, packet->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} (), ipHeader);
822       \textcolor{keywordflow}{return}; 
823     \} 
824   \textcolor{comment}{// 4) packet is not broadcast, and is passed in with a route entry but route->GetGateway is not set
       (e.g., on-demand)}
825   \textcolor{keywordflow}{if} (route && route->GetGateway () == Ipv4Address ())
826     \{
827       \textcolor{comment}{// This could arise because the synchronous RouteOutput() call}
828       \textcolor{comment}{// returned to the transport protocol with a source address but}
829       \textcolor{comment}{// there was no next hop available yet (since a route may need}
830       \textcolor{comment}{// to be queried).}
831       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Ipv4L3Protocol::Send case 4: This case not yet implemented"});
832     \}
833   \textcolor{comment}{// 5) packet is not broadcast, and route is NULL (e.g., a raw socket call)}
834   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Ipv4L3Protocol::Send case 5:  passed in with no route "} << destination);
835   \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket::SocketErrno} errno\_; 
836   Ptr<NetDevice> oif (0); \textcolor{comment}{// unused for now}
837   ipHeader = \hyperlink{classns3_1_1Ipv4L3Protocol_a3737569960c655fe5441b21a5ef829d3}{BuildHeader} (source, destination, protocol, packet->
      \hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} (), ttl, tos, mayFragment);
838   Ptr<Ipv4Route> newRoute;
839   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4L3Protocol_abc52052cbf9c4104be407221397c7a55}{m\_routingProtocol} != 0)
840     \{
841       newRoute = \hyperlink{classns3_1_1Ipv4L3Protocol_abc52052cbf9c4104be407221397c7a55}{m\_routingProtocol}->RouteOutput (packet, ipHeader, oif, errno\_);
842     \}
843   \textcolor{keywordflow}{else}
844     \{
845       \hyperlink{group__logging_ga0261a8db1d4ac5f79417d117634fd455}{NS\_LOG\_ERROR} (\textcolor{stringliteral}{"Ipv4L3Protocol::Send: m\_routingProtocol == 0"});
846     \}
847   \textcolor{keywordflow}{if} (newRoute)
848     \{
849       int32\_t \textcolor{keyword}{interface }= \hyperlink{classns3_1_1Ipv4L3Protocol_a4640baab6b3879020a4146f17e293321}{GetInterfaceForDevice} (newRoute->GetOutputDevice ());
850       \hyperlink{classns3_1_1Ipv4L3Protocol_a909297aa7ca87db2b7c91daefa2ed40a}{m\_sendOutgoingTrace} (ipHeader, packet, interface);
851       \hyperlink{classns3_1_1Ipv4L3Protocol_ac1baf310b12bbc564d0766061ecca323}{SendRealOut} (newRoute, packet->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} (), ipHeader);
852     \}
853   \textcolor{keywordflow}{else}
854     \{
855       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"No route to host.  Drop."});
856       \hyperlink{classns3_1_1Ipv4L3Protocol_a80984e2de6a2562b04195b975014cb1b}{m\_dropTrace} (ipHeader, packet, \hyperlink{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1a6934d63c397ae1ec077fdfcdeb90eb40}{DROP\_NO\_ROUTE}, 
      \hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<\hyperlink{classns3_1_1Ipv4_a1c15284fe630c76e0c9c75a97f1ff234}{Ipv4}> (), 0);
857     \}
858 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 46




Here is the caller graph for this function\+:
% FIG 47


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Send\+Real\+Out@{Send\+Real\+Out}}
\index{Send\+Real\+Out@{Send\+Real\+Out}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Real\+Out(\+Ptr$<$ Ipv4\+Route $>$ route, Ptr$<$ Packet $>$ packet, Ipv4\+Header const \&ip\+Header)}{SendRealOut(Ptr< Ipv4Route > route, Ptr< Packet > packet, Ipv4Header const &ipHeader)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+L3\+Protocol\+::\+Send\+Real\+Out (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv4\+Route} $>$}]{route, }
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Ipv4\+Header} const \&}]{ip\+Header}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_ac1baf310b12bbc564d0766061ecca323}{}\label{classns3_1_1Ipv4L3Protocol_ac1baf310b12bbc564d0766061ecca323}


Send packet with route. 


\begin{DoxyParams}{Parameters}
{\em route} & route \\
\hline
{\em packet} & packet to send \\
\hline
{\em ip\+Header} & I\+Pv4 header to add to the packet \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
914 \{
915   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << route << packet << &ipHeader);
916   \textcolor{keywordflow}{if} (route == 0)
917     \{
918       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"No route to host.  Drop."});
919       \hyperlink{classns3_1_1Ipv4L3Protocol_a80984e2de6a2562b04195b975014cb1b}{m\_dropTrace} (ipHeader, packet, \hyperlink{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1a6934d63c397ae1ec077fdfcdeb90eb40}{DROP\_NO\_ROUTE}, 
      \hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<\hyperlink{classns3_1_1Ipv4_a1c15284fe630c76e0c9c75a97f1ff234}{Ipv4}> (), 0);
920       \textcolor{keywordflow}{return};
921     \}
922   Ptr<NetDevice> outDev = route->GetOutputDevice ();
923   int32\_t \textcolor{keyword}{interface }= GetInterfaceForDevice (outDev);
924   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (interface >= 0);
925   Ptr<Ipv4Interface> outInterface = \hyperlink{classns3_1_1Ipv4L3Protocol_ad58abef6f890f3cc2cf291159a3b8588}{GetInterface} (interface);
926   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Send via NetDevice ifIndex "} << outDev->GetIfIndex () << \textcolor{stringliteral}{" ipv4InterfaceIndex 
      "} << interface);
927 
928   \textcolor{keywordflow}{if} (!route->GetGateway ().IsEqual (Ipv4Address (\textcolor{stringliteral}{"0.0.0.0"})))
929     \{
930       \textcolor{keywordflow}{if} (outInterface->IsUp ())
931         \{
932           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Send to gateway "} << route->GetGateway ());
933           \textcolor{keywordflow}{if} ( packet->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} () + ipHeader.GetSerializedSize () > outInterface->GetDevice ()->
      GetMtu () )
934             \{
935               std::list<Ipv4PayloadHeaderPair> listFragments;
936               \hyperlink{classns3_1_1Ipv4L3Protocol_a5ea602dc1447746c0c3bd90e36ec3888}{DoFragmentation} (packet, ipHeader, outInterface->GetDevice ()->GetMtu (), 
      listFragments);
937               \textcolor{keywordflow}{for} ( std::list<Ipv4PayloadHeaderPair>::iterator it = listFragments.begin (); it != 
      listFragments.end (); it++ )
938                 \{
939                   \hyperlink{classns3_1_1Ipv4L3Protocol_a04cbb7540c6f22a2870f118715b6a703}{CallTxTrace} (it->second, it->first, \hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node}->
      \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<\hyperlink{classns3_1_1Ipv4_a1c15284fe630c76e0c9c75a97f1ff234}{Ipv4}> (), interface);
940                   outInterface->Send (it->first, it->second, route->GetGateway ());
941                 \}
942             \}
943           \textcolor{keywordflow}{else}
944             \{
945               \hyperlink{classns3_1_1Ipv4L3Protocol_a04cbb7540c6f22a2870f118715b6a703}{CallTxTrace} (ipHeader, packet, \hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<
      \hyperlink{classns3_1_1Ipv4_a1c15284fe630c76e0c9c75a97f1ff234}{Ipv4}> (), interface);
946               outInterface->Send (packet, ipHeader, route->GetGateway ());
947             \}
948         \}
949       \textcolor{keywordflow}{else}
950         \{
951           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Dropping -- outgoing interface is down: "} << route->GetGateway ());
952           \hyperlink{classns3_1_1Ipv4L3Protocol_a80984e2de6a2562b04195b975014cb1b}{m\_dropTrace} (ipHeader, packet, \hyperlink{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1a8f40f145dce3e9f21e1218ce125a048d}{DROP\_INTERFACE\_DOWN}, 
      \hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<\hyperlink{classns3_1_1Ipv4_a1c15284fe630c76e0c9c75a97f1ff234}{Ipv4}> (), interface);
953         \}
954     \} 
955   \textcolor{keywordflow}{else} 
956     \{
957       \textcolor{keywordflow}{if} (outInterface->IsUp ())
958         \{
959           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Send to destination "} << ipHeader.GetDestination ());
960           \textcolor{keywordflow}{if} ( packet->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} () + ipHeader.GetSerializedSize () > outInterface->GetDevice ()->
      GetMtu () )
961             \{
962               std::list<Ipv4PayloadHeaderPair> listFragments;
963               \hyperlink{classns3_1_1Ipv4L3Protocol_a5ea602dc1447746c0c3bd90e36ec3888}{DoFragmentation} (packet, ipHeader, outInterface->GetDevice ()->GetMtu (), 
      listFragments);
964               \textcolor{keywordflow}{for} ( std::list<Ipv4PayloadHeaderPair>::iterator it = listFragments.begin (); it != 
      listFragments.end (); it++ )
965                 \{
966                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Sending fragment "} << *(it->first) );
967                   \hyperlink{classns3_1_1Ipv4L3Protocol_a04cbb7540c6f22a2870f118715b6a703}{CallTxTrace} (it->second, it->first, \hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node}->
      \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<\hyperlink{classns3_1_1Ipv4_a1c15284fe630c76e0c9c75a97f1ff234}{Ipv4}> (), interface);
968                   outInterface->Send (it->first, it->second, ipHeader.GetDestination ());
969                 \}
970             \}
971           \textcolor{keywordflow}{else}
972             \{
973               \hyperlink{classns3_1_1Ipv4L3Protocol_a04cbb7540c6f22a2870f118715b6a703}{CallTxTrace} (ipHeader, packet, \hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<
      \hyperlink{classns3_1_1Ipv4_a1c15284fe630c76e0c9c75a97f1ff234}{Ipv4}> (), interface);
974               outInterface->Send (packet, ipHeader, ipHeader.GetDestination ());
975             \}
976         \}
977       \textcolor{keywordflow}{else}
978         \{
979           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Dropping -- outgoing interface is down: "} << ipHeader.GetDestination (
      ));
980           \hyperlink{classns3_1_1Ipv4L3Protocol_a80984e2de6a2562b04195b975014cb1b}{m\_dropTrace} (ipHeader, packet, \hyperlink{classns3_1_1Ipv4L3Protocol_a05e7403d60c79529257c4cffdd994da1a8f40f145dce3e9f21e1218ce125a048d}{DROP\_INTERFACE\_DOWN}, 
      \hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<\hyperlink{classns3_1_1Ipv4_a1c15284fe630c76e0c9c75a97f1ff234}{Ipv4}> (), interface);
981         \}
982     \}
983 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 48




Here is the caller graph for this function\+:
% FIG 49


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Send\+With\+Header@{Send\+With\+Header}}
\index{Send\+With\+Header@{Send\+With\+Header}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+With\+Header(\+Ptr$<$ Packet $>$ packet, Ipv4\+Header ip\+Header, Ptr$<$ Ipv4\+Route $>$ route)}{SendWithHeader(Ptr< Packet > packet, Ipv4Header ipHeader, Ptr< Ipv4Route > route)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+L3\+Protocol\+::\+Send\+With\+Header (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Ipv4\+Header}}]{ip\+Header, }
\item[{{\bf Ptr}$<$ {\bf Ipv4\+Route} $>$}]{route}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a9305010252cee1e4e97766227ca58ba4}{}\label{classns3_1_1Ipv4L3Protocol_a9305010252cee1e4e97766227ca58ba4}

\begin{DoxyParams}{Parameters}
{\em packet} & packet to send \\
\hline
{\em ip\+Header} & IP \hyperlink{classns3_1_1Header}{Header} \\
\hline
{\em route} & route entry\\
\hline
\end{DoxyParams}
Higher-\/level layers call this method to send a packet with I\+Pv4 \hyperlink{classns3_1_1Header}{Header} (Intend to be used with Ip\+Header\+Include attribute.) 

Implements \hyperlink{classns3_1_1Ipv4_a6d6b3f031557d3fccc195df342f8598a}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
701 \{
702   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << ipHeader << route);
703   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Node_a0515bfe9a3aeb6605d657ba855699815}{Node::ChecksumEnabled} ())
704     \{
705       ipHeader.EnableChecksum ();
706     \}
707   \hyperlink{classns3_1_1Ipv4L3Protocol_ac1baf310b12bbc564d0766061ecca323}{SendRealOut} (route, packet, ipHeader);
708 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 50


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Set\+Default\+Ttl@{Set\+Default\+Ttl}}
\index{Set\+Default\+Ttl@{Set\+Default\+Ttl}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Default\+Ttl(uint8\+\_\+t ttl)}{SetDefaultTtl(uint8_t ttl)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+L3\+Protocol\+::\+Set\+Default\+Ttl (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{ttl}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4L3Protocol_ae8e813f03f1d862bd18cede2b12d346f}{}\label{classns3_1_1Ipv4L3Protocol_ae8e813f03f1d862bd18cede2b12d346f}

\begin{DoxyParams}{Parameters}
{\em ttl} & default ttl to use\\
\hline
\end{DoxyParams}
When we need to send an ipv4 packet, we use this default ttl value. 
\begin{DoxyCode}
361 \{
362   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << static\_cast<uint32\_t> (ttl));
363   \hyperlink{classns3_1_1Ipv4L3Protocol_aca3ce2700f8f7334464866ab2a76e427}{m\_defaultTtl} = ttl;
364 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Set\+Down@{Set\+Down}}
\index{Set\+Down@{Set\+Down}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Down(uint32\+\_\+t i)}{SetDown(uint32_t i)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+L3\+Protocol\+::\+Set\+Down (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_aad57377d10edd4f3de417533d7f07917}{}\label{classns3_1_1Ipv4L3Protocol_aad57377d10edd4f3de417533d7f07917}

\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of \hyperlink{classns3_1_1Ipv4}{Ipv4} interface\\
\hline
\end{DoxyParams}
Set the interface into the \char`\"{}down\char`\"{} state. In this state, it is ignored during \hyperlink{classns3_1_1Ipv4}{Ipv4} forwarding. 

Implements \hyperlink{classns3_1_1Ipv4_ac148839884b1ce11f9237ddc523f5cd2}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
1331 \{
1332   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << ifaceIndex);
1333   Ptr<Ipv4Interface> \textcolor{keyword}{interface }= GetInterface (ifaceIndex);
1334   interface->SetDown ();
1335 
1336   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4L3Protocol_abc52052cbf9c4104be407221397c7a55}{m\_routingProtocol} != 0)
1337     \{
1338       \hyperlink{classns3_1_1Ipv4L3Protocol_abc52052cbf9c4104be407221397c7a55}{m\_routingProtocol}->NotifyInterfaceDown (ifaceIndex);
1339     \}
1340 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Set\+Forwarding@{Set\+Forwarding}}
\index{Set\+Forwarding@{Set\+Forwarding}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Forwarding(uint32\+\_\+t i, bool val)}{SetForwarding(uint32_t i, bool val)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+L3\+Protocol\+::\+Set\+Forwarding (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{bool}]{val}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a4150655165d81cc01cb4ac4883de5c08}{}\label{classns3_1_1Ipv4L3Protocol_a4150655165d81cc01cb4ac4883de5c08}

\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of \hyperlink{classns3_1_1Ipv4}{Ipv4} interface \\
\hline
{\em val} & Value to set the forwarding flag\\
\hline
\end{DoxyParams}
If set to true, IP forwarding is enabled for input datagrams on this device 

Implements \hyperlink{classns3_1_1Ipv4_aee95b3b96994698f5629f8b9e617b587}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
1353 \{
1354   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
1355   Ptr<Ipv4Interface> \textcolor{keyword}{interface }= GetInterface (i);
1356   interface->SetForwarding (val);
1357 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Set\+Ip\+Forward@{Set\+Ip\+Forward}}
\index{Set\+Ip\+Forward@{Set\+Ip\+Forward}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Ip\+Forward(bool forward)}{SetIpForward(bool forward)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+L3\+Protocol\+::\+Set\+Ip\+Forward (
\begin{DoxyParamCaption}
\item[{bool}]{forward}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a455a909e3bdcb5651e0ffd3eadf850d8}{}\label{classns3_1_1Ipv4L3Protocol_a455a909e3bdcb5651e0ffd3eadf850d8}


Set or unset the IP forwarding state. 


\begin{DoxyParams}{Parameters}
{\em forward} & the forwarding state \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv4_a12decc8332283f56ba59b0aacb3498ca}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
1368 \{
1369   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << forward);
1370   \hyperlink{classns3_1_1Ipv4L3Protocol_a2dc4e9e459bb2ee5eab3af65df316a15}{m\_ipForward} = forward;
1371   \textcolor{keywordflow}{for} (Ipv4InterfaceList::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Ipv4L3Protocol_a0b0f15b24a02f2c9a5d576f633aa2770}{m\_interfaces}.begin (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1Ipv4L3Protocol_a0b0f15b24a02f2c9a5d576f633aa2770}{m\_interfaces}.end (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
1372     \{
1373       (*i)->SetForwarding (forward);
1374     \}
1375 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Set\+Metric@{Set\+Metric}}
\index{Set\+Metric@{Set\+Metric}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Metric(uint32\+\_\+t i, uint16\+\_\+t metric)}{SetMetric(uint32_t i, uint16_t metric)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+L3\+Protocol\+::\+Set\+Metric (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{uint16\+\_\+t}]{metric}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_acdb26739ce815d86b85767edca3f0068}{}\label{classns3_1_1Ipv4L3Protocol_acdb26739ce815d86b85767edca3f0068}

\begin{DoxyParams}{Parameters}
{\em interface} & The interface number of an \hyperlink{classns3_1_1Ipv4}{Ipv4} interface \\
\hline
{\em metric} & routing metric (cost) associated to the underlying \hyperlink{classns3_1_1Ipv4}{Ipv4} interface \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv4_a2b5632573b67957fabe2dfea248a57a3}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
1274 \{
1275   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} << metric);
1276   Ptr<Ipv4Interface> \textcolor{keyword}{interface }= GetInterface (i);
1277   interface->SetMetric (metric);
1278 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Set\+Node@{Set\+Node}}
\index{Set\+Node@{Set\+Node}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Node(\+Ptr$<$ Node $>$ node)}{SetNode(Ptr< Node > node)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+L3\+Protocol\+::\+Set\+Node (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4L3Protocol_a82ef37914ea8bab699575fea23586bc7}{}\label{classns3_1_1Ipv4L3Protocol_a82ef37914ea8bab699575fea23586bc7}


Set node associated with this stack. 


\begin{DoxyParams}{Parameters}
{\em node} & node to set \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
217 \{
218   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << node);
219   \hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node} = node;
220   \textcolor{comment}{// Add a LoopbackNetDevice if needed, and an Ipv4Interface on top of it}
221   \hyperlink{classns3_1_1Ipv4L3Protocol_aa37b950d26063e4e7ee659e599c83bde}{SetupLoopback} ();
222 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 51




Here is the caller graph for this function\+:
% FIG 52


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Set\+Routing\+Protocol@{Set\+Routing\+Protocol}}
\index{Set\+Routing\+Protocol@{Set\+Routing\+Protocol}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Routing\+Protocol(\+Ptr$<$ Ipv4\+Routing\+Protocol $>$ routing\+Protocol)}{SetRoutingProtocol(Ptr< Ipv4RoutingProtocol > routingProtocol)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+L3\+Protocol\+::\+Set\+Routing\+Protocol (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv4\+Routing\+Protocol} $>$}]{routing\+Protocol}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a7e7d286dc2c782ea931d12a95203fc29}{}\label{classns3_1_1Ipv4L3Protocol_a7e7d286dc2c782ea931d12a95203fc29}


Register a new routing protocol to be used by this \hyperlink{classns3_1_1Ipv4}{Ipv4} stack. 

This call will replace any routing protocol that has been previously registered. If you want to add multiple routing protocols, you must add them to a Ipv4\+List\+Routing\+Protocol directly.


\begin{DoxyParams}{Parameters}
{\em routing\+Protocol} & smart pointer to \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} object \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv4_a2d165c3bafd4ca580f02a03536db80d3}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
270 \{
271   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << routingProtocol);
272   \hyperlink{classns3_1_1Ipv4L3Protocol_abc52052cbf9c4104be407221397c7a55}{m\_routingProtocol} = routingProtocol;
273   \hyperlink{classns3_1_1Ipv4L3Protocol_abc52052cbf9c4104be407221397c7a55}{m\_routingProtocol}->SetIpv4 (\textcolor{keyword}{this});
274 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 53


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Set\+Up@{Set\+Up}}
\index{Set\+Up@{Set\+Up}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Up(uint32\+\_\+t i)}{SetUp(uint32_t i)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+L3\+Protocol\+::\+Set\+Up (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a9c4d254d735b420b7fb6e0a56a90f221}{}\label{classns3_1_1Ipv4L3Protocol_a9c4d254d735b420b7fb6e0a56a90f221}

\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of \hyperlink{classns3_1_1Ipv4}{Ipv4} interface\\
\hline
\end{DoxyParams}
Set the interface into the \char`\"{}up\char`\"{} state. In this state, it is considered valid during \hyperlink{classns3_1_1Ipv4}{Ipv4} forwarding. 

Implements \hyperlink{classns3_1_1Ipv4_a71b2f8acca4923aef907b50b3196bf23}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
1306 \{
1307   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
1308   Ptr<Ipv4Interface> \textcolor{keyword}{interface }= GetInterface (i);
1309 
1310   \textcolor{comment}{// RFC 791, pg.25:}
1311   \textcolor{comment}{//  Every internet module must be able to forward a datagram of 68}
1312   \textcolor{comment}{//  octets without further fragmentation.  This is because an internet}
1313   \textcolor{comment}{//  header may be up to 60 octets, and the minimum fragment is 8 octets.}
1314   \textcolor{keywordflow}{if} (interface->GetDevice ()->GetMtu () >= 68)
1315     \{
1316       interface->SetUp ();
1317 
1318       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4L3Protocol_abc52052cbf9c4104be407221397c7a55}{m\_routingProtocol} != 0)
1319         \{
1320           \hyperlink{classns3_1_1Ipv4L3Protocol_abc52052cbf9c4104be407221397c7a55}{m\_routingProtocol}->NotifyInterfaceUp (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
1321         \}
1322     \}
1323   \textcolor{keywordflow}{else}
1324     \{
1325       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Interface "} << \textcolor{keywordtype}{int}(\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) << \textcolor{stringliteral}{" is set to be down for IPv4. Reason: not
       respecting minimum IPv4 MTU (68 octects)"});
1326     \}
1327 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Setup\+Loopback@{Setup\+Loopback}}
\index{Setup\+Loopback@{Setup\+Loopback}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Setup\+Loopback(void)}{SetupLoopback(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+L3\+Protocol\+::\+Setup\+Loopback (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_aa37b950d26063e4e7ee659e599c83bde}{}\label{classns3_1_1Ipv4L3Protocol_aa37b950d26063e4e7ee659e599c83bde}


Setup loopback interface. 


\begin{DoxyCode}
326 \{
327   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
328 
329   Ptr<Ipv4Interface> \textcolor{keyword}{interface }= \hyperlink{group__object_gad1d36559be10afa72c3656fd8598c1e2}{CreateObject}<Ipv4Interface> ();
330   Ptr<LoopbackNetDevice> device = 0;
331   \textcolor{comment}{// First check whether an existing LoopbackNetDevice exists on the node}
332   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node}->\hyperlink{classns3_1_1Node_a531554d2241ba4fa1cd74e3360be6bce}{GetNDevices} (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
333     \{
334       \textcolor{keywordflow}{if} ((device = DynamicCast<LoopbackNetDevice> (\hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node}->\hyperlink{classns3_1_1Node_a5918dfd24ef632efc9a83a5f6561c76e}{GetDevice} (
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}))))
335         \{
336           \textcolor{keywordflow}{break};
337         \}
338     \}
339   \textcolor{keywordflow}{if} (device == 0)
340     \{
341       device = CreateObject<LoopbackNetDevice> (); 
342       \hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node}->\hyperlink{classns3_1_1Node_a42ff83ee1d5d1649c770d3f5b62375de}{AddDevice} (device);
343     \}
344   interface->SetDevice (device);
345   interface->SetNode (\hyperlink{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{m\_node});
346   Ipv4InterfaceAddress ifaceAddr = Ipv4InterfaceAddress (
      \hyperlink{classns3_1_1Ipv4Address_a583a93499e0d947439794d7bd0c6366d}{Ipv4Address::GetLoopback} (), \hyperlink{classns3_1_1Ipv4Mask_a7842be570f11b3ffcf3a50b0639bcf2d}{Ipv4Mask::GetLoopback} ());
347   interface->AddAddress (ifaceAddr);
348   uint32\_t index = \hyperlink{classns3_1_1Ipv4L3Protocol_afd3f97720c2d1af22f05038fcdb6e089}{AddIpv4Interface} (interface);
349   Ptr<Node> node = GetObject<Node> ();
350   node->RegisterProtocolHandler (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1Ipv4L3Protocol_a2f27fb0a3f698ffb34a654323b063c94}{Ipv4L3Protocol::Receive}, \textcolor{keyword}{this}), 
351                                  \hyperlink{classns3_1_1Ipv4L3Protocol_a0146bc84815b7b73adb9c62cdafc9442}{Ipv4L3Protocol::PROT\_NUMBER}, device);
352   interface->SetUp ();
353   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4L3Protocol_abc52052cbf9c4104be407221397c7a55}{m\_routingProtocol} != 0)
354     \{
355       \hyperlink{classns3_1_1Ipv4L3Protocol_abc52052cbf9c4104be407221397c7a55}{m\_routingProtocol}->NotifyInterfaceUp (index);
356     \}
357 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 54




Here is the caller graph for this function\+:
% FIG 55


\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Set\+Weak\+Es\+Model@{Set\+Weak\+Es\+Model}}
\index{Set\+Weak\+Es\+Model@{Set\+Weak\+Es\+Model}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Weak\+Es\+Model(bool model)}{SetWeakEsModel(bool model)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+L3\+Protocol\+::\+Set\+Weak\+Es\+Model (
\begin{DoxyParamCaption}
\item[{bool}]{model}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a45e538d92668de5fa759de6141751702}{}\label{classns3_1_1Ipv4L3Protocol_a45e538d92668de5fa759de6141751702}


Set or unset the Weak Es Model. 

R\+F\+C1122 term for whether host accepts datagram with a dest. address on another interface 
\begin{DoxyParams}{Parameters}
{\em model} & true for Weak Es Model \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv4_a3bdaf12fbfaca276c1a60a3a7cd9b68c}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
1386 \{
1387   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << model);
1388   \hyperlink{classns3_1_1Ipv4L3Protocol_acbe9c4ed9ec7e33a55fa5b7c687e62f3}{m\_weakEsModel} = model;
1389 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!Source\+Address\+Selection@{Source\+Address\+Selection}}
\index{Source\+Address\+Selection@{Source\+Address\+Selection}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Source\+Address\+Selection(uint32\+\_\+t interface, Ipv4\+Address dest)}{SourceAddressSelection(uint32_t interface, Ipv4Address dest)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Address} ns3\+::\+Ipv4\+L3\+Protocol\+::\+Source\+Address\+Selection (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv4\+Address}}]{dest}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a60f11e28019741497dd8730f53294b4f}{}\label{classns3_1_1Ipv4L3Protocol_a60f11e28019741497dd8730f53294b4f}


Choose the source address to use with destination address. 


\begin{DoxyParams}{Parameters}
{\em interface} & interface index \\
\hline
{\em dest} & I\+Pv4 destination address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
I\+Pv4 source address to use 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4_ac7a49d14371de95cd1cc8f6563266edd}{ns3\+::\+Ipv4}.


\begin{DoxyCode}
1194 \{
1195   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << interfaceIdx << \textcolor{stringliteral}{" "} << dest);
1196   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4L3Protocol_ab816ec1b5f680117bc1363b3d9649b22}{GetNAddresses} (interfaceIdx) == 1)  \textcolor{comment}{// common case}
1197     \{
1198       \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv4L3Protocol_a85fa4287313a773dee29aa73fa74a7e0}{GetAddress} (interfaceIdx, 0).\hyperlink{classns3_1_1Ipv4InterfaceAddress_a716a425049f48b9fe6e38868b1f413f6}{GetLocal} ();
1199     \}
1200   \textcolor{comment}{// no way to determine the scope of the destination, so adopt the}
1201   \textcolor{comment}{// following rule:  pick the first available address (index 0) unless}
1202   \textcolor{comment}{// a subsequent address is on link (in which case, pick the primary}
1203   \textcolor{comment}{// address if there are multiple)}
1204   Ipv4Address candidate = \hyperlink{classns3_1_1Ipv4L3Protocol_a85fa4287313a773dee29aa73fa74a7e0}{GetAddress} (interfaceIdx, 0).\hyperlink{classns3_1_1Ipv4InterfaceAddress_a716a425049f48b9fe6e38868b1f413f6}{GetLocal} ();
1205   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1Ipv4L3Protocol_ab816ec1b5f680117bc1363b3d9649b22}{GetNAddresses} (interfaceIdx); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
1206     \{
1207       Ipv4InterfaceAddress \hyperlink{main-test-sync_8cc_a708a4c1a4d0c4acc4c447310dd4db27f}{test} = \hyperlink{classns3_1_1Ipv4L3Protocol_a85fa4287313a773dee29aa73fa74a7e0}{GetAddress} (interfaceIdx, \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
1208       \textcolor{keywordflow}{if} (test.GetLocal ().CombineMask (test.GetMask ()) == dest.CombineMask (test.GetMask ()))
1209         \{
1210           \textcolor{keywordflow}{if} (test.IsSecondary () == \textcolor{keyword}{false})
1211             \{
1212               \textcolor{keywordflow}{return} test.GetLocal ();
1213             \}
1214         \}
1215     \}
1216   \textcolor{keywordflow}{return} candidate;
1217 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 56




\subsection{Friends And Related Function Documentation}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!\+::\+Ipv4\+L3\+Protocol\+Test\+Case@{\+::\+Ipv4\+L3\+Protocol\+Test\+Case}}
\index{\+::\+Ipv4\+L3\+Protocol\+Test\+Case@{\+::\+Ipv4\+L3\+Protocol\+Test\+Case}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{\+::\+Ipv4\+L3\+Protocol\+Test\+Case}{::Ipv4L3ProtocolTestCase}}]{\setlength{\rightskip}{0pt plus 5cm}friend class \+::{\bf Ipv4\+L3\+Protocol\+Test\+Case}\hspace{0.3cm}{\ttfamily [friend]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a1c97ab904d8fa88c56c79a0d235325e9}{}\label{classns3_1_1Ipv4L3Protocol_a1c97ab904d8fa88c56c79a0d235325e9}


\hyperlink{classIpv4L3ProtocolTestCase}{Ipv4\+L3\+Protocol\+Test\+Case} test case. 



\subsection{Member Data Documentation}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!m\+\_\+default\+Ttl@{m\+\_\+default\+Ttl}}
\index{m\+\_\+default\+Ttl@{m\+\_\+default\+Ttl}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+default\+Ttl}{m_defaultTtl}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::\+Ipv4\+L3\+Protocol\+::m\+\_\+default\+Ttl\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_aca3ce2700f8f7334464866ab2a76e427}{}\label{classns3_1_1Ipv4L3Protocol_aca3ce2700f8f7334464866ab2a76e427}


Default T\+TL. 

\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!m\+\_\+drop\+Trace@{m\+\_\+drop\+Trace}}
\index{m\+\_\+drop\+Trace@{m\+\_\+drop\+Trace}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+drop\+Trace}{m_dropTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<$const {\bf Ipv4\+Header} \&, {\bf Ptr}$<$const {\bf Packet}$>$, {\bf Drop\+Reason}, {\bf Ptr}$<${\bf Ipv4}$>$, uint32\+\_\+t$>$ ns3\+::\+Ipv4\+L3\+Protocol\+::m\+\_\+drop\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a80984e2de6a2562b04195b975014cb1b}{}\label{classns3_1_1Ipv4L3Protocol_a80984e2de6a2562b04195b975014cb1b}
Trace of dropped packets \begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000010}{Deprecated}]The non-\/const {\ttfamily Ptr$<$\+Ipv4$>$} argument is deprecated and will be changed to {\ttfamily Ptr$<$const Ipv4$>$} in a future release. \end{DoxyRefDesc}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!m\+\_\+fragment\+Expiration\+Timeout@{m\+\_\+fragment\+Expiration\+Timeout}}
\index{m\+\_\+fragment\+Expiration\+Timeout@{m\+\_\+fragment\+Expiration\+Timeout}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+fragment\+Expiration\+Timeout}{m_fragmentExpirationTimeout}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Ipv4\+L3\+Protocol\+::m\+\_\+fragment\+Expiration\+Timeout\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a6ad1c5e5d4bde4a903aadab94c6ec164}{}\label{classns3_1_1Ipv4L3Protocol_a6ad1c5e5d4bde4a903aadab94c6ec164}


Expiration timeout. 

\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!m\+\_\+fragments@{m\+\_\+fragments}}
\index{m\+\_\+fragments@{m\+\_\+fragments}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+fragments}{m_fragments}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Map\+Fragments\+\_\+t} ns3\+::\+Ipv4\+L3\+Protocol\+::m\+\_\+fragments\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a0eb853df4608f63e9447d8a33d427ccf}{}\label{classns3_1_1Ipv4L3Protocol_a0eb853df4608f63e9447d8a33d427ccf}


Fragmented packets. 

\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!m\+\_\+fragments\+Timers@{m\+\_\+fragments\+Timers}}
\index{m\+\_\+fragments\+Timers@{m\+\_\+fragments\+Timers}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+fragments\+Timers}{m_fragmentsTimers}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Map\+Fragments\+Timers\+\_\+t} ns3\+::\+Ipv4\+L3\+Protocol\+::m\+\_\+fragments\+Timers\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a3233e1de6e8f43299a353107adafbed2}{}\label{classns3_1_1Ipv4L3Protocol_a3233e1de6e8f43299a353107adafbed2}


Expiration events. 

\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!m\+\_\+identification@{m\+\_\+identification}}
\index{m\+\_\+identification@{m\+\_\+identification}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+identification}{m_identification}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<$std\+::pair$<$uint64\+\_\+t, uint8\+\_\+t$>$, uint16\+\_\+t$>$ ns3\+::\+Ipv4\+L3\+Protocol\+::m\+\_\+identification\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a64746ae9a15d32cd8d0b4467d6b66949}{}\label{classns3_1_1Ipv4L3Protocol_a64746ae9a15d32cd8d0b4467d6b66949}


Identification (for each \{src, dst, proto\} tuple) 

\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!m\+\_\+interfaces@{m\+\_\+interfaces}}
\index{m\+\_\+interfaces@{m\+\_\+interfaces}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+interfaces}{m_interfaces}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Interface\+List} ns3\+::\+Ipv4\+L3\+Protocol\+::m\+\_\+interfaces\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a0b0f15b24a02f2c9a5d576f633aa2770}{}\label{classns3_1_1Ipv4L3Protocol_a0b0f15b24a02f2c9a5d576f633aa2770}


List of I\+Pv4 interfaces. 

\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!m\+\_\+ip\+Forward@{m\+\_\+ip\+Forward}}
\index{m\+\_\+ip\+Forward@{m\+\_\+ip\+Forward}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+ip\+Forward}{m_ipForward}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv4\+L3\+Protocol\+::m\+\_\+ip\+Forward\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a2dc4e9e459bb2ee5eab3af65df316a15}{}\label{classns3_1_1Ipv4L3Protocol_a2dc4e9e459bb2ee5eab3af65df316a15}


Forwarding packets (i.\+e. router mode) state. 

\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!m\+\_\+local\+Deliver\+Trace@{m\+\_\+local\+Deliver\+Trace}}
\index{m\+\_\+local\+Deliver\+Trace@{m\+\_\+local\+Deliver\+Trace}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+local\+Deliver\+Trace}{m_localDeliverTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<$const {\bf Ipv4\+Header} \&, {\bf Ptr}$<$const {\bf Packet}$>$, uint32\+\_\+t$>$ ns3\+::\+Ipv4\+L3\+Protocol\+::m\+\_\+local\+Deliver\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a70adc805da9b70e8fb6f2a998f4df446}{}\label{classns3_1_1Ipv4L3Protocol_a70adc805da9b70e8fb6f2a998f4df446}


Trace of locally delivered packets. 

\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!m\+\_\+node@{m\+\_\+node}}
\index{m\+\_\+node@{m\+\_\+node}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+node}{m_node}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Node}$>$ ns3\+::\+Ipv4\+L3\+Protocol\+::m\+\_\+node\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}{}\label{classns3_1_1Ipv4L3Protocol_ad2cc5076c247724f1e99b398edc1965a}


\hyperlink{classns3_1_1Node}{Node} attached to stack. 

\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!m\+\_\+protocols@{m\+\_\+protocols}}
\index{m\+\_\+protocols@{m\+\_\+protocols}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+protocols}{m_protocols}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf L4\+List\+\_\+t} ns3\+::\+Ipv4\+L3\+Protocol\+::m\+\_\+protocols\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_ab1c0a7a1a453db3c2ca3e47d7e65ff54}{}\label{classns3_1_1Ipv4L3Protocol_ab1c0a7a1a453db3c2ca3e47d7e65ff54}


List of transport protocol. 

\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!m\+\_\+reverse\+Interfaces\+Container@{m\+\_\+reverse\+Interfaces\+Container}}
\index{m\+\_\+reverse\+Interfaces\+Container@{m\+\_\+reverse\+Interfaces\+Container}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+reverse\+Interfaces\+Container}{m_reverseInterfacesContainer}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Interface\+Reverse\+Container} ns3\+::\+Ipv4\+L3\+Protocol\+::m\+\_\+reverse\+Interfaces\+Container\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_aa222dd0d50b6a835033b4cec1d63c096}{}\label{classns3_1_1Ipv4L3Protocol_aa222dd0d50b6a835033b4cec1d63c096}


Container of \hyperlink{classns3_1_1NetDevice}{Net\+Device} / Interface index associations. 

\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!m\+\_\+routing\+Protocol@{m\+\_\+routing\+Protocol}}
\index{m\+\_\+routing\+Protocol@{m\+\_\+routing\+Protocol}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+routing\+Protocol}{m_routingProtocol}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Ipv4\+Routing\+Protocol}$>$ ns3\+::\+Ipv4\+L3\+Protocol\+::m\+\_\+routing\+Protocol\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_abc52052cbf9c4104be407221397c7a55}{}\label{classns3_1_1Ipv4L3Protocol_abc52052cbf9c4104be407221397c7a55}


Routing protocol associated with the stack. 

\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!m\+\_\+rx\+Trace@{m\+\_\+rx\+Trace}}
\index{m\+\_\+rx\+Trace@{m\+\_\+rx\+Trace}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+rx\+Trace}{m_rxTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$, {\bf Ptr}$<${\bf Ipv4}$>$, uint32\+\_\+t$>$ ns3\+::\+Ipv4\+L3\+Protocol\+::m\+\_\+rx\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a8a973a63eb239c315d630c9ff300823a}{}\label{classns3_1_1Ipv4L3Protocol_a8a973a63eb239c315d630c9ff300823a}
Trace of received packets \begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000009}{Deprecated}]The non-\/const {\ttfamily Ptr$<$\+Ipv4$>$} argument is deprecated and will be changed to {\ttfamily Ptr$<$const Ipv4$>$} in a future release. \end{DoxyRefDesc}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!m\+\_\+send\+Outgoing\+Trace@{m\+\_\+send\+Outgoing\+Trace}}
\index{m\+\_\+send\+Outgoing\+Trace@{m\+\_\+send\+Outgoing\+Trace}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+send\+Outgoing\+Trace}{m_sendOutgoingTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<$const {\bf Ipv4\+Header} \&, {\bf Ptr}$<$const {\bf Packet}$>$, uint32\+\_\+t$>$ ns3\+::\+Ipv4\+L3\+Protocol\+::m\+\_\+send\+Outgoing\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a909297aa7ca87db2b7c91daefa2ed40a}{}\label{classns3_1_1Ipv4L3Protocol_a909297aa7ca87db2b7c91daefa2ed40a}


Trace of sent packets. 

\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!m\+\_\+sockets@{m\+\_\+sockets}}
\index{m\+\_\+sockets@{m\+\_\+sockets}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+sockets}{m_sockets}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Socket\+List} ns3\+::\+Ipv4\+L3\+Protocol\+::m\+\_\+sockets\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a5f3749c4a9bc9ee5a75f73c33f64aa7c}{}\label{classns3_1_1Ipv4L3Protocol_a5f3749c4a9bc9ee5a75f73c33f64aa7c}


List of I\+Pv4 raw sockets. 

\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!m\+\_\+tx\+Trace@{m\+\_\+tx\+Trace}}
\index{m\+\_\+tx\+Trace@{m\+\_\+tx\+Trace}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+tx\+Trace}{m_txTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$, {\bf Ptr}$<${\bf Ipv4}$>$, uint32\+\_\+t$>$ ns3\+::\+Ipv4\+L3\+Protocol\+::m\+\_\+tx\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a91a19b062bd7e55da11615385e0e2788}{}\label{classns3_1_1Ipv4L3Protocol_a91a19b062bd7e55da11615385e0e2788}
Trace of transmitted packets \begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000008}{Deprecated}]The non-\/const {\ttfamily Ptr$<$\+Ipv4$>$} argument is deprecated and will be changed to {\ttfamily Ptr$<$const Ipv4$>$} in a future release. \end{DoxyRefDesc}
\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!m\+\_\+unicast\+Forward\+Trace@{m\+\_\+unicast\+Forward\+Trace}}
\index{m\+\_\+unicast\+Forward\+Trace@{m\+\_\+unicast\+Forward\+Trace}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+unicast\+Forward\+Trace}{m_unicastForwardTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<$const {\bf Ipv4\+Header} \&, {\bf Ptr}$<$const {\bf Packet}$>$, uint32\+\_\+t$>$ ns3\+::\+Ipv4\+L3\+Protocol\+::m\+\_\+unicast\+Forward\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_acc97efd317fd7e0c1a65c6247fa6537a}{}\label{classns3_1_1Ipv4L3Protocol_acc97efd317fd7e0c1a65c6247fa6537a}


Trace of unicast forwarded packets. 

\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!m\+\_\+weak\+Es\+Model@{m\+\_\+weak\+Es\+Model}}
\index{m\+\_\+weak\+Es\+Model@{m\+\_\+weak\+Es\+Model}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+weak\+Es\+Model}{m_weakEsModel}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv4\+L3\+Protocol\+::m\+\_\+weak\+Es\+Model\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4L3Protocol_acbe9c4ed9ec7e33a55fa5b7c687e62f3}{}\label{classns3_1_1Ipv4L3Protocol_acbe9c4ed9ec7e33a55fa5b7c687e62f3}


Weak ES model state. 

\index{ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}!P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER@{P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER}}
\index{P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER@{P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER}!ns3\+::\+Ipv4\+L3\+Protocol@{ns3\+::\+Ipv4\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER}{PROT_NUMBER}}]{\setlength{\rightskip}{0pt plus 5cm}const uint16\+\_\+t ns3\+::\+Ipv4\+L3\+Protocol\+::\+P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER = 0x0800\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv4L3Protocol_a0146bc84815b7b73adb9c62cdafc9442}{}\label{classns3_1_1Ipv4L3Protocol_a0146bc84815b7b73adb9c62cdafc9442}


Protocol number (0x0800) 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/model/\hyperlink{ipv4-l3-protocol_8h}{ipv4-\/l3-\/protocol.\+h}\item 
internet/model/\hyperlink{ipv4-l3-protocol_8cc}{ipv4-\/l3-\/protocol.\+cc}\end{DoxyCompactItemize}
