\hypertarget{classns3_1_1UplinkSchedulerMBQoS}{}\section{ns3\+:\+:Uplink\+Scheduler\+M\+B\+QoS Class Reference}
\label{classns3_1_1UplinkSchedulerMBQoS}\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}


This class implements a Migration-\/based Quality of Service uplink scheduler(\+M\+B\+Qo\+S).  




{\ttfamily \#include $<$bs-\/uplink-\/scheduler-\/mbqos.\+h$>$}



Inheritance diagram for ns3\+:\+:Uplink\+Scheduler\+M\+B\+QoS\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Uplink\+Scheduler\+M\+B\+QoS\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1UplinkSchedulerMBQoS_aa8db7610198e6bbc698b42b5f580624a}{Uplink\+Scheduler\+M\+B\+QoS} ()
\item 
\hyperlink{classns3_1_1UplinkSchedulerMBQoS_addafca8b699155f0160e45c8f4f5d807}{Uplink\+Scheduler\+M\+B\+QoS} (\hyperlink{classns3_1_1Time}{Time} time)
\item 
\hyperlink{classns3_1_1UplinkSchedulerMBQoS_a859988f74ef9331a784178c7ea538e24}{$\sim$\+Uplink\+Scheduler\+M\+B\+QoS} (void)
\item 
\hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1OfdmUlMapIe}{Ofdm\+Ul\+Map\+Ie} $>$ \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a09725afc94899e4aacf646abe0ab1f04}{Get\+Uplink\+Allocations} (void) const 
\item 
void \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a623029436fb0c8786de9d5ce1adf5978}{Get\+Channel\+Descriptors\+To\+Update} (bool \&update\+Dcd, bool \&update\+Ucd, bool \&send\+Dcd, bool \&send\+Ucd)
\item 
uint32\+\_\+t \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a3e3b4dc0dd31f8750cee914c18c6cd6e}{Calculate\+Allocation\+Start\+Time} (void)
\item 
void \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a23b74ad65ec3d22b55d25648addd7486}{Add\+Uplink\+Allocation} (\hyperlink{classns3_1_1OfdmUlMapIe}{Ofdm\+Ul\+Map\+Ie} \&ul\+Map\+Ie, const uint32\+\_\+t \&allocation\+Size, uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)
\item 
void \hyperlink{classns3_1_1UplinkSchedulerMBQoS_abd019c4994078b9b6e6c012af5e34ac5}{Schedule} (void)
\item 
void \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a3cbff7d3b7d31739806421f0eb2b1cc6}{Service\+Unsolicited\+Grants} (const \hyperlink{classns3_1_1SSRecord}{S\+S\+Record} $\ast$ss\+Record, enum \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235}{Service\+Flow\+::\+Scheduling\+Type} scheduling\+Type, \hyperlink{classns3_1_1OfdmUlMapIe}{Ofdm\+Ul\+Map\+Ie} \&ul\+Map\+Ie, const \hyperlink{classns3_1_1WimaxPhy_a044c5d8a48ca992c39c2a946f6e755fa}{Wimax\+Phy\+::\+Modulation\+Type} modulation\+Type, uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)
\item 
void \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a2405968bd60de182ce1e3d67ae416ba7}{Service\+Bandwidth\+Requests} (const \hyperlink{classns3_1_1SSRecord}{S\+S\+Record} $\ast$ss\+Record, enum \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235}{Service\+Flow\+::\+Scheduling\+Type} scheduling\+Type, \hyperlink{classns3_1_1OfdmUlMapIe}{Ofdm\+Ul\+Map\+Ie} \&ul\+Map\+Ie, const \hyperlink{classns3_1_1WimaxPhy_a044c5d8a48ca992c39c2a946f6e755fa}{Wimax\+Phy\+::\+Modulation\+Type} modulation\+Type, uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)
\item 
bool \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a366a69170776175fcf651cb29e46fdf4}{Service\+Bandwidth\+Requests} (\hyperlink{classns3_1_1ServiceFlow}{Service\+Flow} $\ast$service\+Flow, enum \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235}{Service\+Flow\+::\+Scheduling\+Type} scheduling\+Type, \hyperlink{classns3_1_1OfdmUlMapIe}{Ofdm\+Ul\+Map\+Ie} \&ul\+Map\+Ie, const \hyperlink{classns3_1_1WimaxPhy_a044c5d8a48ca992c39c2a946f6e755fa}{Wimax\+Phy\+::\+Modulation\+Type} modulation\+Type, uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)
\item 
void \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a6a9a487024bc6253cb5cada269994d24}{Allocate\+Initial\+Ranging\+Interval} (uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)
\item 
void \hyperlink{classns3_1_1UplinkSchedulerMBQoS_aef30b9e41f2b8da83b467c6a8121b34d}{Setup\+Service\+Flow} (\hyperlink{classns3_1_1SSRecord}{S\+S\+Record} $\ast$ss\+Record, \hyperlink{classns3_1_1ServiceFlow}{Service\+Flow} $\ast$service\+Flow)
\item 
void \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a3f8e2b0a22540ea61354cf4147187399}{Check\+Deadline} (uint32\+\_\+t \&available\+Symbols)
\begin{DoxyCompactList}\small\item\em Check deadline from jobs. Migrate requests if necessary. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1UplinkSchedulerMBQoS_ae25c9cfb244144f5f9e2b7393253d009}{Check\+Minimum\+Bandwidth} (uint32\+\_\+t \&available\+Symbols)
\begin{DoxyCompactList}\small\item\em Check if Minimum bandwidth is guarantee. Migrate requests if necessary. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a80733614c419c105ae666e830f1d5c1e}{Uplink\+Sched\+Window\+Timer} (void)
\begin{DoxyCompactList}\small\item\em Reset the current window. According to a configured time, reset the window. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1UplinkSchedulerMBQoS_ad18bfc130fac723e65ada63fc3719b44}{Enqueue\+Job} (\hyperlink{classns3_1_1UlJob_a6ae1d8e2e490a32ee1bc8aae661f4983}{Ul\+Job\+::\+Job\+Priority} priority, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UlJob}{Ul\+Job} $>$ job)
\begin{DoxyCompactList}\small\item\em Enqueue a job in a priority queue. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UlJob}{Ul\+Job} $>$ \hyperlink{classns3_1_1UplinkSchedulerMBQoS_ab5438ccd3382992a8c91dda3b408b4d0}{Dequeue\+Job} (\hyperlink{classns3_1_1UlJob_a6ae1d8e2e490a32ee1bc8aae661f4983}{Ul\+Job\+::\+Job\+Priority} priority)
\begin{DoxyCompactList}\small\item\em Dequeue a job from a priority queue. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a42c3d42e2972874f56b423b1c32e07b4}{Process\+Bandwidth\+Request} (const \hyperlink{classns3_1_1BandwidthRequestHeader}{Bandwidth\+Request\+Header} \&bw\+Request\+Hdr)
\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1UplinkSchedulerMBQoS_adadb381ed6d228290bae257e4344d84d}{Determine\+Deadline} (\hyperlink{classns3_1_1ServiceFlow}{Service\+Flow} $\ast$service\+Flow)
\begin{DoxyCompactList}\small\item\em Calculates deadline of a request. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1UplinkSchedulerMBQoS_aa0ce923b356285a9e28d90b698d17557}{Init\+Once} (void)
\item 
uint32\+\_\+t \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a31659c6f3996b4a820235a4359ab2a5e}{Count\+Symbols\+Queue} (\hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UlJob}{Ul\+Job} $>$ $>$ jobs)
\item 
uint32\+\_\+t \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a8b187198e3609de02b2179629485a6fa}{Count\+Symbols\+Jobs} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UlJob}{Ul\+Job} $>$ job)
\item 
void \hyperlink{classns3_1_1UplinkSchedulerMBQoS_ae3d25dea784092d453a60cb97364ac57}{On\+Set\+Requested\+Bandwidth} (\hyperlink{classns3_1_1ServiceFlowRecord}{Service\+Flow\+Record} $\ast$sfr)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UlJob}{Ul\+Job} $>$ \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a09c9fce5d8872eaf5cdf60209a556e21}{Create\+Ul\+Job} (\hyperlink{classns3_1_1SSRecord}{S\+S\+Record} $\ast$ss\+Record, enum \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235}{Service\+Flow\+::\+Scheduling\+Type} sched\+Type, \hyperlink{namespacens3_a534f9a14e4d9aeb5b400e61f152a73a2}{Req\+Type} req\+Type)
\item 
uint32\+\_\+t \hyperlink{classns3_1_1UplinkSchedulerMBQoS_acd81dfb3cabd98ee2f244df25e14558c}{Get\+Pending\+Size} (\hyperlink{classns3_1_1ServiceFlow}{Service\+Flow} $\ast$service\+Flow)
\item 
bool \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a9880f5e1bce7b93ddff11623f29d4865}{Service\+Bandwidth\+Requests\+Bytes} (\hyperlink{classns3_1_1ServiceFlow}{Service\+Flow} $\ast$service\+Flow, enum \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235}{Service\+Flow\+::\+Scheduling\+Type} scheduling\+Type, \hyperlink{classns3_1_1OfdmUlMapIe}{Ofdm\+Ul\+Map\+Ie} \&ul\+Map\+Ie, const \hyperlink{classns3_1_1WimaxPhy_a044c5d8a48ca992c39c2a946f6e755fa}{Wimax\+Phy\+::\+Modulation\+Type} modulation\+Type, uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols, uint32\+\_\+t allocation\+Size\+Bytes)
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a4c634147cc54a03736648d6f128826d6}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1OfdmUlMapIe}{Ofdm\+Ul\+Map\+Ie} $>$ \hyperlink{classns3_1_1UplinkSchedulerMBQoS_afdca0f835bd9f2b31ad19a7a2a2f4382}{m\+\_\+uplink\+Allocations}
\begin{DoxyCompactList}\small\item\em uplink allocations \end{DoxyCompactList}\item 
\hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UlJob}{Ul\+Job} $>$ $>$ \hyperlink{classns3_1_1UplinkSchedulerMBQoS_acb8b5539e366b4942381b08edccfba4b}{m\+\_\+uplink\+Jobs\+\_\+high}
\begin{DoxyCompactList}\small\item\em uplink jobs high priority \end{DoxyCompactList}\item 
\hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UlJob}{Ul\+Job} $>$ $>$ \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a70eef7c9cb6dad5e71a2105e07d1ec69}{m\+\_\+uplink\+Jobs\+\_\+inter}
\begin{DoxyCompactList}\small\item\em uplink jobs intermedite priority \end{DoxyCompactList}\item 
\hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UlJob}{Ul\+Job} $>$ $>$ \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a73b59113ed20a512685dc76e93cf1faa}{m\+\_\+uplink\+Jobs\+\_\+low}
\begin{DoxyCompactList}\small\item\em uplink jobs low priority \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1UplinkSchedulerMBQoS_aa3fb881e781d8cda4e7bb011c30d9f5d}{m\+\_\+window\+Interval}
\begin{DoxyCompactList}\small\item\em windows interval \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
This class implements a Migration-\/based Quality of Service uplink scheduler(\+M\+B\+Qo\+S). 

This uplink scheduler uses three queues, the low priority queue, the intermediate queue and the high priority queue. The scheduler serves the requests in strict priority order from the high priority queue to the low priority queue. The low priority queue stores the bandwidth requests of the BE service flow. The intermediate queue holds bandwidth requests sent by rt\+PS and by nrt\+PS connections. rt\+PS and nrt\+PS requests can migrate to the high priority queue to guarantee that their QoS requirements are met. Besides the requests migrated from the intermediate queue, the high priority queue stores periodic grants and unicast request opportunities that must be scheduled in the following frame. To guarantee the maximum delay requirement, the BS assigns a deadline to each rt\+PS bandwidth request in the intermediate queue. The minimum bandwidth requirement of both rt\+PS and nrt\+PS connections is guaranteed over a window of duration T . Implementation of uplink scheduler\+: Freitag, J.; da Fonseca, N.\+L.\+S., \char`\"{}\+Uplink Scheduling with Quality of Service in I\+E\+E\+E 802.\+16 Networks,\char`\"{} Global Telecommunications Conference, 2007. G\+L\+O\+B\+E\+C\+OM \textquotesingle{}07. I\+E\+EE , vol., no., pp.\+2503-\/2508, 26-\/30 Nov. 2007 U\+RL\+: \href{http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4411386&isnumber=4410910}{\tt http\+://ieeexplore.\+ieee.\+org/stamp/stamp.\+jsp?arnumber=4411386\&isnumber=4410910} 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!Uplink\+Scheduler\+M\+B\+QoS@{Uplink\+Scheduler\+M\+B\+QoS}}
\index{Uplink\+Scheduler\+M\+B\+QoS@{Uplink\+Scheduler\+M\+B\+QoS}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{Uplink\+Scheduler\+M\+B\+Qo\+S()}{UplinkSchedulerMBQoS()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::\+Uplink\+Scheduler\+M\+B\+QoS (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_aa8db7610198e6bbc698b42b5f580624a}{}\label{classns3_1_1UplinkSchedulerMBQoS_aa8db7610198e6bbc698b42b5f580624a}

\begin{DoxyCode}
39 \{
40 \}
\end{DoxyCode}
\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!Uplink\+Scheduler\+M\+B\+QoS@{Uplink\+Scheduler\+M\+B\+QoS}}
\index{Uplink\+Scheduler\+M\+B\+QoS@{Uplink\+Scheduler\+M\+B\+QoS}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{Uplink\+Scheduler\+M\+B\+Qo\+S(\+Time time)}{UplinkSchedulerMBQoS(Time time)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::\+Uplink\+Scheduler\+M\+B\+QoS (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{time}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_addafca8b699155f0160e45c8f4f5d807}{}\label{classns3_1_1UplinkSchedulerMBQoS_addafca8b699155f0160e45c8f4f5d807}
Constructor


\begin{DoxyParams}{Parameters}
{\em time} & the time \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
43   : \hyperlink{classns3_1_1UplinkSchedulerMBQoS_aa3fb881e781d8cda4e7bb011c30d9f5d}{m\_windowInterval} (time)
44 \{
45 
46 \}
\end{DoxyCode}
\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!````~Uplink\+Scheduler\+M\+B\+QoS@{$\sim$\+Uplink\+Scheduler\+M\+B\+QoS}}
\index{````~Uplink\+Scheduler\+M\+B\+QoS@{$\sim$\+Uplink\+Scheduler\+M\+B\+QoS}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{$\sim$\+Uplink\+Scheduler\+M\+B\+Qo\+S(void)}{~UplinkSchedulerMBQoS(void)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::$\sim$\+Uplink\+Scheduler\+M\+B\+QoS (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_a859988f74ef9331a784178c7ea538e24}{}\label{classns3_1_1UplinkSchedulerMBQoS_a859988f74ef9331a784178c7ea538e24}

\begin{DoxyCode}
49 \{
50   \hyperlink{classns3_1_1UplinkScheduler_a28a8d5aa6e61d4ea91388ac3c76e759f}{SetBs} (0);
51   \hyperlink{classns3_1_1UplinkSchedulerMBQoS_afdca0f835bd9f2b31ad19a7a2a2f4382}{m\_uplinkAllocations}.clear ();
52 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2




\subsection{Member Function Documentation}
\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!Add\+Uplink\+Allocation@{Add\+Uplink\+Allocation}}
\index{Add\+Uplink\+Allocation@{Add\+Uplink\+Allocation}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{Add\+Uplink\+Allocation(\+Ofdm\+Ul\+Map\+Ie \&ul\+Map\+Ie, const uint32\+\_\+t \&allocation\+Size, uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)}{AddUplinkAllocation(OfdmUlMapIe &ulMapIe, const uint32_t &allocationSize, uint32_t &symbolsToAllocation, uint32_t &availableSymbols)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::\+Add\+Uplink\+Allocation (
\begin{DoxyParamCaption}
\item[{{\bf Ofdm\+Ul\+Map\+Ie} \&}]{ul\+Map\+Ie, }
\item[{const uint32\+\_\+t \&}]{allocation\+Size, }
\item[{uint32\+\_\+t \&}]{symbols\+To\+Allocation, }
\item[{uint32\+\_\+t \&}]{available\+Symbols}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_a23b74ad65ec3d22b55d25648addd7486}{}\label{classns3_1_1UplinkSchedulerMBQoS_a23b74ad65ec3d22b55d25648addd7486}
Add uplink allocation 
\begin{DoxyParams}{Parameters}
{\em ul\+Map\+Ie} & the UL map IE \\
\hline
{\em allocation\+Size} & the allocation size \\
\hline
{\em symbols\+To\+Allocation} & the symbols to allocation \\
\hline
{\em available\+Symbols} & the available symbols \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1UplinkScheduler_a9bb05ef2a73f18c5004a812aefece8b6}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
153 \{
154   ulMapIe.SetDuration (allocationSize);
155   ulMapIe.SetStartTime (symbolsToAllocation);
156   \hyperlink{classns3_1_1UplinkSchedulerMBQoS_afdca0f835bd9f2b31ad19a7a2a2f4382}{m\_uplinkAllocations}.push\_back (ulMapIe);
157   symbolsToAllocation += allocationSize;
158   availableSymbols -= allocationSize;
159 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3




Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!Allocate\+Initial\+Ranging\+Interval@{Allocate\+Initial\+Ranging\+Interval}}
\index{Allocate\+Initial\+Ranging\+Interval@{Allocate\+Initial\+Ranging\+Interval}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{Allocate\+Initial\+Ranging\+Interval(uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)}{AllocateInitialRangingInterval(uint32_t &symbolsToAllocation, uint32_t &availableSymbols)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::\+Allocate\+Initial\+Ranging\+Interval (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t \&}]{symbols\+To\+Allocation, }
\item[{uint32\+\_\+t \&}]{available\+Symbols}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_a6a9a487024bc6253cb5cada269994d24}{}\label{classns3_1_1UplinkSchedulerMBQoS_a6a9a487024bc6253cb5cada269994d24}
Allocate initial ranging interval 
\begin{DoxyParams}{Parameters}
{\em symbols\+To\+Allocation} & the symbols to allocation \\
\hline
{\em available\+Symbols} & the available symbols \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1UplinkScheduler_ae6094447ffd6d3946a70723246faed42}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
969 \{
970   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} ssUlStartTime = \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (\hyperlink{classns3_1_1UplinkSchedulerMBQoS_a3e3b4dc0dd31f8750cee914c18c6cd6e}{CalculateAllocationStartTime} () * 
      \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPsDuration ().GetSeconds ());
971   \hyperlink{classns3_1_1UplinkScheduler_a19208ce138c5e13b1a7019a67adef892}{SetNrIrOppsAllocated} (\hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetLinkManager ()->
      CalculateRangingOppsToAllocate ());
972   uint32\_t allocationSize = \hyperlink{classns3_1_1UplinkScheduler_a9a2cbb04c1e84a028fc1545e8f054b80}{GetNrIrOppsAllocated} () * \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetRangReqOppSize 
      ();
973   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} timeSinceLastIrInterval = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} () - 
      \hyperlink{classns3_1_1UplinkScheduler_aa7516e5a55b513a7640035a9783369c7}{GetTimeStampIrInterval} ();
974 
975   \textcolor{comment}{// adding one frame because may be the time has not elapsed now but will elapse before the next frame is
       sent}
976   \textcolor{keywordflow}{if} (timeSinceLastIrInterval + \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetFrameDuration () > 
      \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetInitialRangingInterval ()
977       && availableSymbols >= allocationSize)
978     \{
979       \hyperlink{classns3_1_1UplinkScheduler_a3eee0d06486678eab4d352a274676d95}{SetIsIrIntrvlAllocated} (\textcolor{keyword}{true});
980       OfdmUlMapIe ulMapIeIr;
981       ulMapIeIr.SetCid ((\hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetBroadcastConnection ())->GetCid ());
982       ulMapIeIr.SetStartTime (symbolsToAllocation);
983       ulMapIeIr.SetUiuc (\hyperlink{classns3_1_1OfdmUlBurstProfile_ae528783c4b3c6700ff49dfd7a555cb3daaea7b6256d4bcd0125f0248c0560c94e}{OfdmUlBurstProfile::UIUC\_INITIAL\_RANGING});
984 
985       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"BS uplink scheduler, initial ranging allocation, size: "} << allocationSize
       << \textcolor{stringliteral}{" symbols"}
986                                                                               << \textcolor{stringliteral}{", modulation: BPSK 1/2"} )
      ;
987 
988       \textcolor{comment}{// marking start and end of each TO, only for debugging}
989       \textcolor{keywordflow}{for} (uint8\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1UplinkScheduler_a9a2cbb04c1e84a028fc1545e8f054b80}{GetNrIrOppsAllocated} (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
990         \{
991           \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->MarkRangingOppStart (ssUlStartTime + \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (symbolsToAllocation
992                                                                   * \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetSymbolDuration ().
      GetSeconds ()) + \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} * \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetRangReqOppSize ()
993                                                                                                            
                        * \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetSymbolDuration ().GetSeconds ()));
994         \}
995 
996       \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a23b74ad65ec3d22b55d25648addd7486}{AddUplinkAllocation} (ulMapIeIr, allocationSize, symbolsToAllocation, 
      availableSymbols);
997       \hyperlink{classns3_1_1UplinkScheduler_ad6e89aef6cf4a9d485762f8bd08ec24e}{SetTimeStampIrInterval} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ());
998     \}
999 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5




Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!Calculate\+Allocation\+Start\+Time@{Calculate\+Allocation\+Start\+Time}}
\index{Calculate\+Allocation\+Start\+Time@{Calculate\+Allocation\+Start\+Time}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{Calculate\+Allocation\+Start\+Time(void)}{CalculateAllocationStartTime(void)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::\+Calculate\+Allocation\+Start\+Time (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_a3e3b4dc0dd31f8750cee914c18c6cd6e}{}\label{classns3_1_1UplinkSchedulerMBQoS_a3e3b4dc0dd31f8750cee914c18c6cd6e}
Calculate allocation start time \begin{DoxyReturn}{Returns}
the allocation start time 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1UplinkScheduler_a10d8a099202072dee74f879d9ae2479b}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
144 \{
145   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetNrDlSymbols () * \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetPsPerSymbol () + 
      \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetTtg ();
146 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7




Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!Check\+Deadline@{Check\+Deadline}}
\index{Check\+Deadline@{Check\+Deadline}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{Check\+Deadline(uint32\+\_\+t \&available\+Symbols)}{CheckDeadline(uint32_t &availableSymbols)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::\+Check\+Deadline (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t \&}]{available\+Symbols}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_a3f8e2b0a22540ea61354cf4147187399}{}\label{classns3_1_1UplinkSchedulerMBQoS_a3f8e2b0a22540ea61354cf4147187399}


Check deadline from jobs. Migrate requests if necessary. 


\begin{DoxyParams}{Parameters}
{\em available\+Symbols} & available symbols in the uplink frame This method verifies for each rt\+PS request whether it should be migrated to the high priority queue or not. The conditions for migration are\+: request deadline expires in the frame following the next one, and the amount of bandwidth requested is less than or equal to the amount of available bytes in the next uplink frame. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
650 \{
651   \textcolor{comment}{// for each request in the imermediate queue}
652   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UplinkSchedulerMBQoS_a70eef7c9cb6dad5e71a2105e07d1ec69}{m\_uplinkJobs\_inter}.size () > 0)
653     \{
654       std::list<Ptr<UlJob> >::iterator iter = \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a70eef7c9cb6dad5e71a2105e07d1ec69}{m\_uplinkJobs\_inter}.begin ();
655 
656       \textcolor{keywordflow}{while} (iter != \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a70eef7c9cb6dad5e71a2105e07d1ec69}{m\_uplinkJobs\_inter}.end () && availableSymbols)
657         \{
658           Ptr<UlJob> job = *iter;
659 
660           \textcolor{comment}{// guarantee delay bound for rtps connections}
661           \textcolor{keywordflow}{if} (job->GetSchedulingType () == \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a0e98ff713b932a029acad7e5b24bbf55}{ServiceFlow::SF\_TYPE\_RTPS})
662             \{
663               \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} deadline = job->GetDeadline ();
664               \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} frame\_duration = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetFrameDuration ();
665 
666               int64\_t \hyperlink{namespacevisualizer_1_1higcontainer_a3a06b62552347e51aaf4765391802719}{frame} = (deadline - \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ()) / frame\_duration;
667 
668               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"At "} << \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds () << \textcolor{stringliteral}{"
       reserved traffic rate: "}
669                                   << job->GetServiceFlow ()->GetMinReservedTrafficRate ()
670                                   <<\textcolor{stringliteral}{" deadline: "}<<job->GetDeadline ().
      \hyperlink{classns3_1_1Time_a8f20d5c3b0902d7b4320982f340b57c8}{GetSeconds} () << \textcolor{stringliteral}{" frame start: "}<<\hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->m\_frameStartTime.GetSeconds ()
671                                   <<\textcolor{stringliteral}{" frame duration: "}<< frame\_duration );
672 
673               \textcolor{comment}{// should be schedule in this frame to max latency}
674               \textcolor{keywordflow}{if} (frame >= 3)
675                 \{
676 
677                   \textcolor{keywordflow}{if} (availableSymbols)
678                     \{
679                       uint32\_t availableBytes =  \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetNrBytes (availableSymbols,job
      ->GetSsRecord ()->GetModulationType ());
680                       uint32\_t allocationSize = job->GetSize ();
681                       \textcolor{keywordflow}{if} (allocationSize > availableBytes)
682                         \{
683                           allocationSize = availableBytes;
684                         \}
685 
686 
687                       \textcolor{keywordflow}{if} (allocationSize == 0)
688                         \{
689                           \textcolor{keywordflow}{continue};
690                         \}
691 
692                       uint32\_t symbolsToAllocate = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetNrSymbols (allocationSize, 
      job->GetSsRecord ()->GetModulationType ());
693                       \textcolor{keywordflow}{if} (symbolsToAllocate > availableSymbols)
694                         \{
695                           symbolsToAllocate = availableSymbols;
696                           allocationSize = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetNrBytes (symbolsToAllocate,job->
      GetSsRecord ()->GetModulationType ());
697                         \}
698 
699                       job->SetSize (job->GetSize () - allocationSize);
700 
701                       Ptr<UlJob> newJob =  CreateObject<UlJob> ();
702                       \textcolor{comment}{// Record data in job}
703                       newJob->SetSsRecord (job->GetSsRecord ());
704                       newJob->SetServiceFlow (job->GetServiceFlow ());
705                       newJob->SetSize (allocationSize);
706                       newJob->SetDeadline (job->GetDeadline ());
707                       newJob->SetReleaseTime (job->GetReleaseTime ());
708                       newJob->SetSchedulingType (job->GetSchedulingType ());
709                       newJob->SetPeriod (job->GetPeriod ());
710                       newJob->SetType (job->GetType ());
711 
712                       \hyperlink{classns3_1_1UplinkSchedulerMBQoS_ad18bfc130fac723e65ada63fc3719b44}{EnqueueJob} (\hyperlink{classns3_1_1UlJob_a6ae1d8e2e490a32ee1bc8aae661f4983a5094609e73e947663a497fd927ce562e}{UlJob::HIGH}, newJob);
713 
714                       \textcolor{comment}{// migrate request}
715                       iter++;
716                       \textcolor{keywordflow}{if} ((job->GetSize () - allocationSize) == 0)
717                         \{
718                           \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a70eef7c9cb6dad5e71a2105e07d1ec69}{m\_uplinkJobs\_inter}.remove (job);
719                         \}
720 
721                     \}
722                 \}
723               \textcolor{keywordflow}{else}
724                 \{
725                   iter++;
726                 \}
727             \}
728           \textcolor{keywordflow}{else}
729             \{
730               iter++;
731             \}
732         \}
733     \}
734 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9




Here is the caller graph for this function\+:
% FIG 10


\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!Check\+Minimum\+Bandwidth@{Check\+Minimum\+Bandwidth}}
\index{Check\+Minimum\+Bandwidth@{Check\+Minimum\+Bandwidth}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{Check\+Minimum\+Bandwidth(uint32\+\_\+t \&available\+Symbols)}{CheckMinimumBandwidth(uint32_t &availableSymbols)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::\+Check\+Minimum\+Bandwidth (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t \&}]{available\+Symbols}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_ae25c9cfb244144f5f9e2b7393253d009}{}\label{classns3_1_1UplinkSchedulerMBQoS_ae25c9cfb244144f5f9e2b7393253d009}


Check if Minimum bandwidth is guarantee. Migrate requests if necessary. 


\begin{DoxyParams}{Parameters}
{\em available\+Symbols} & available symbols in the uplink frame. This method first calculate a priority value for each request in the intermediate queue. Then, sorts the intermediate queue according to the priority values. Finally, while there is available bandwidth, the scheduler migrate the requests to the high priority queue. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
738 \{
739   std::list<Ptr<PriorityUlJob> > priorityUlJobs;
740 
741   \textcolor{comment}{// For each connection of type rtPS or nrtPS}
742   std::vector<SSRecord*> *ssRecords = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetSSManager ()->GetSSRecords ();
743   \textcolor{keywordflow}{for} (std::vector<SSRecord*>::iterator iter = ssRecords->begin (); iter != ssRecords->end (); ++iter)
744     \{
745       SSRecord *ssRecord = *iter;
746       std::vector<ServiceFlow*> serviceFlows = ssRecord->GetServiceFlows (
      \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235aaf7e58e43027cc9d351cd100a9d6dee3}{ServiceFlow::SF\_TYPE\_ALL});
747       \textcolor{keywordflow}{for} (std::vector<ServiceFlow*>::iterator iter2 = serviceFlows.begin (); iter2 != serviceFlows.end ();
       ++iter2)
748         \{
749           ServiceFlow *serviceFlow = *iter2;
750           \textcolor{keywordflow}{if} (serviceFlow->GetSchedulingType () == \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a0e98ff713b932a029acad7e5b24bbf55}{ServiceFlow::SF\_TYPE\_RTPS} || 
      serviceFlow->GetSchedulingType ()
751               == \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a7f8577f851a9f01d159442a3a3fcdf48}{ServiceFlow::SF\_TYPE\_NRTPS})
752             \{
753               serviceFlow->GetRecord ()->SetBackloggedTemp (serviceFlow->GetRecord ()->GetBacklogged ());
754               serviceFlow->GetRecord ()->SetGrantedBandwidthTemp (serviceFlow->GetRecord ()->
      GetBwSinceLastExpiry ());
755             \}
756         \}
757     \}
758 
759   \textcolor{comment}{// for each request in the imermediate queue}
760   \textcolor{keywordflow}{for} (\hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std::list}<Ptr<UlJob> >::const\_iterator iter = \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a70eef7c9cb6dad5e71a2105e07d1ec69}{m\_uplinkJobs\_inter}.begin ()
      ; iter != \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a70eef7c9cb6dad5e71a2105e07d1ec69}{m\_uplinkJobs\_inter}.end (); ++iter)
761     \{
762       Ptr<UlJob> job = *iter;
763       \textcolor{comment}{// SSRecord ssRecord = job->GetSsRecord();}
764       ServiceFlow *serviceFlow = job->GetServiceFlow ();
765       \textcolor{keywordflow}{if} ((job->GetSchedulingType () == \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a0e98ff713b932a029acad7e5b24bbf55}{ServiceFlow::SF\_TYPE\_RTPS} || job->
      GetSchedulingType ()
766            == \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a7f8577f851a9f01d159442a3a3fcdf48}{ServiceFlow::SF\_TYPE\_NRTPS}) && (serviceFlow->GetRecord ()->
      GetBacklogged () > 0))
767         \{
768           uint32\_t minReservedTrafficRate = serviceFlow->GetMinReservedTrafficRate ();
769           uint32\_t grantedBandwidth = serviceFlow->GetRecord ()->GetBwSinceLastExpiry ();
770 
771           Ptr<PriorityUlJob> priorityUlJob = CreateObject<PriorityUlJob> ();
772           priorityUlJob->SetUlJob (job);
773           \textcolor{comment}{// pri\_array}
774           \textcolor{keywordflow}{if} (minReservedTrafficRate <= grantedBandwidth)
775             \{
776               priorityUlJob->SetPriority (-10000);
777             \}
778           \textcolor{keywordflow}{else}
779             \{
780               uint32\_t allocationSize = serviceFlow->GetRecord ()->GetRequestedBandwidth ()
781                 - serviceFlow->GetRecord ()->GetGrantedBandwidth ();
782               uint32\_t sduSize = serviceFlow->GetSduSize ();
783 
784               \textcolor{keywordflow}{if} (allocationSize > 0)
785                 \{
786                   \textcolor{keywordflow}{if} (sduSize > 0)
787                     \{
788                       \textcolor{comment}{// if SDU size is mentioned, grant of that size}
789                       allocationSize = sduSize;
790                     \}
791                 \}
792               \textcolor{keywordtype}{int} priority = serviceFlow->GetRecord ()->GetBackloggedTemp ()
793                 - (serviceFlow->GetRecord ()->GetGrantedBandwidthTemp () - minReservedTrafficRate);
794               priorityUlJob->SetPriority (priority);
795               serviceFlow->GetRecord ()->SetGrantedBandwidthTemp (serviceFlow->GetRecord ()->
      GetGrantedBandwidthTemp ()
796                                                                   + allocationSize);
797               serviceFlow->GetRecord ()->SetBackloggedTemp (serviceFlow->GetRecord ()->GetBackloggedTemp ()
798                                                             - allocationSize);
799             \}
800 
801           priorityUlJobs.push\_back (priorityUlJob);
802         \}
803     \}
804 
805   priorityUlJobs.sort (SortProcessPtr ());
806 
807   \textcolor{keywordflow}{for} (\hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std::list}<Ptr<PriorityUlJob> >::const\_iterator iter = priorityUlJobs.begin (); iter != 
      priorityUlJobs.end (); ++iter)
808     \{
809       Ptr<PriorityUlJob> priorityUlJob = *iter;
810       Ptr<UlJob> job\_priority = priorityUlJob->GetUlJob ();
811       Ptr<UlJob> job = job\_priority;
812       \textcolor{keywordflow}{if} (availableSymbols)
813         \{
814           availableSymbols -= \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a8b187198e3609de02b2179629485a6fa}{CountSymbolsJobs} (job);
815           \textcolor{comment}{// migrate request}
816           \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a70eef7c9cb6dad5e71a2105e07d1ec69}{m\_uplinkJobs\_inter}.remove (job);
817           \hyperlink{classns3_1_1UplinkSchedulerMBQoS_ad18bfc130fac723e65ada63fc3719b44}{EnqueueJob} (\hyperlink{classns3_1_1UlJob_a6ae1d8e2e490a32ee1bc8aae661f4983a5094609e73e947663a497fd927ce562e}{UlJob::HIGH}, job);
818         \}
819     \}
820 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 11




Here is the caller graph for this function\+:
% FIG 12


\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!Count\+Symbols\+Jobs@{Count\+Symbols\+Jobs}}
\index{Count\+Symbols\+Jobs@{Count\+Symbols\+Jobs}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{Count\+Symbols\+Jobs(\+Ptr$<$ Ul\+Job $>$ job)}{CountSymbolsJobs(Ptr< UlJob > job)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::\+Count\+Symbols\+Jobs (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ul\+Job} $>$}]{job}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_a8b187198e3609de02b2179629485a6fa}{}\label{classns3_1_1UplinkSchedulerMBQoS_a8b187198e3609de02b2179629485a6fa}

\begin{DoxyParams}{Parameters}
{\em job} & job \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the symbols count
\end{DoxyReturn}
Count the amount of symbols of a job. 
\begin{DoxyCode}
572 \{
573   SSRecord *ssRecord = job->GetSsRecord ();
574   ServiceFlow *serviceFlow = job->GetServiceFlow ();
575   uint32\_t allocationSize = 0;
576 
577   \textcolor{keywordflow}{if} (job->GetType () == \hyperlink{namespacens3_a534f9a14e4d9aeb5b400e61f152a73a2ab774c9fb3410eec7ee3c8367c50ccbb3}{UNICAST\_POLLING})
578     \{
579       \textcolor{comment}{// if polling}
580       \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} currentTime = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ();
581       allocationSize = 0;
582       \textcolor{keywordflow}{if} ((currentTime - serviceFlow->GetRecord ()->GetGrantTimeStamp ()).GetMilliSeconds ()
583           >= serviceFlow->GetUnsolicitedPollingInterval ())
584         \{
585           allocationSize = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetBwReqOppSize ();
586         \}
587     \}
588   \textcolor{keywordflow}{else}
589     \{
590       \textcolor{comment}{// if data}
591       uint16\_t sduSize = serviceFlow->GetSduSize ();
592       ServiceFlowRecord *record = serviceFlow->GetRecord ();
593       uint32\_t requiredBandwidth = record->GetRequestedBandwidth () - record->GetGrantedBandwidth ();
594       \textcolor{keywordflow}{if} (requiredBandwidth > 0)
595         \{
596           \hyperlink{classns3_1_1WimaxPhy_a044c5d8a48ca992c39c2a946f6e755fa}{WimaxPhy::ModulationType} modulationType = ssRecord->GetModulationType ();
597           \textcolor{keywordflow}{if} (sduSize > 0)
598             \{
599               \textcolor{comment}{// if SDU size is mentioned, allocate grant of that size}
600               allocationSize = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetNrSymbols (sduSize, modulationType);
601             \}
602           \textcolor{keywordflow}{else}
603             \{
604               allocationSize = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetNrSymbols (requiredBandwidth, modulationType);
605             \}
606         \}
607     \}
608   \textcolor{keywordflow}{return} allocationSize;
609 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13




Here is the caller graph for this function\+:
% FIG 14


\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!Count\+Symbols\+Queue@{Count\+Symbols\+Queue}}
\index{Count\+Symbols\+Queue@{Count\+Symbols\+Queue}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{Count\+Symbols\+Queue(std\+::list$<$ Ptr$<$ Ul\+Job $>$ $>$ jobs)}{CountSymbolsQueue(std::list< Ptr< UlJob > > jobs)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::\+Count\+Symbols\+Queue (
\begin{DoxyParamCaption}
\item[{{\bf std\+::list}$<$ {\bf Ptr}$<$ {\bf Ul\+Job} $>$ $>$}]{jobs}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_a31659c6f3996b4a820235a4359ab2a5e}{}\label{classns3_1_1UplinkSchedulerMBQoS_a31659c6f3996b4a820235a4359ab2a5e}

\begin{DoxyParams}{Parameters}
{\em jobs} & List of jobs \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the symbols count
\end{DoxyReturn}
Sum the amount of symbols of each job of a queue 
\begin{DoxyCode}
547 \{
548   uint32\_t symbols = 0;
549   \textcolor{keywordflow}{for} (\hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std::list}<Ptr<UlJob> >::iterator iter = jobs.begin (); iter != jobs.end (); ++iter)
550     \{
551       Ptr<UlJob> job = *iter;
552 
553       \textcolor{comment}{// count symbols}
554       symbols += \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a8b187198e3609de02b2179629485a6fa}{CountSymbolsJobs} (job);
555     \}
556   \textcolor{keywordflow}{return} symbols;
557 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 15




Here is the caller graph for this function\+:
% FIG 16


\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!Create\+Ul\+Job@{Create\+Ul\+Job}}
\index{Create\+Ul\+Job@{Create\+Ul\+Job}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{Create\+Ul\+Job(\+S\+S\+Record $\ast$ss\+Record, enum Service\+Flow\+::\+Scheduling\+Type sched\+Type, Req\+Type req\+Type)}{CreateUlJob(SSRecord *ssRecord, enum ServiceFlow::SchedulingType schedType, ReqType reqType)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ul\+Job} $>$ ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::\+Create\+Ul\+Job (
\begin{DoxyParamCaption}
\item[{{\bf S\+S\+Record} $\ast$}]{ss\+Record, }
\item[{enum {\bf Service\+Flow\+::\+Scheduling\+Type}}]{sched\+Type, }
\item[{{\bf Req\+Type}}]{req\+Type}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_a09c9fce5d8872eaf5cdf60209a556e21}{}\label{classns3_1_1UplinkSchedulerMBQoS_a09c9fce5d8872eaf5cdf60209a556e21}

\begin{DoxyParams}{Parameters}
{\em ss\+Record} & Subscriber station record \\
\hline
{\em sched\+Type} & Service flow type \\
\hline
{\em req\+Type} & Type of packet \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Ptr$<$\+Ul\+Job$>$
\end{DoxyReturn}
Create and fill information of a job. 
\begin{DoxyCode}
561 \{
562   Ptr<UlJob> job = CreateObject <UlJob> ();
563   job->SetSsRecord (ssRecord);
564   job->SetSchedulingType (schedType);
565   job->SetServiceFlow (*(ssRecord->GetServiceFlows (schedType).begin ()));
566   job->SetType (reqType);
567   \textcolor{keywordflow}{return} job;
568 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 17




Here is the caller graph for this function\+:
% FIG 18


\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!Dequeue\+Job@{Dequeue\+Job}}
\index{Dequeue\+Job@{Dequeue\+Job}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{Dequeue\+Job(\+Ul\+Job\+::\+Job\+Priority priority)}{DequeueJob(UlJob::JobPriority priority)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ul\+Job} $>$ ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::\+Dequeue\+Job (
\begin{DoxyParamCaption}
\item[{{\bf Ul\+Job\+::\+Job\+Priority}}]{priority}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_ab5438ccd3382992a8c91dda3b408b4d0}{}\label{classns3_1_1UplinkSchedulerMBQoS_ab5438ccd3382992a8c91dda3b408b4d0}


Dequeue a job from a priority queue. 


\begin{DoxyParams}{Parameters}
{\em priority} & Priority of queue \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Ptr$<$\+Ul\+Job$>$ 
\end{DoxyReturn}

\begin{DoxyCode}
629 \{
630   Ptr<UlJob> job\_front;
631   \textcolor{keywordflow}{switch} (priority)
632     \{
633     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1UlJob_a6ae1d8e2e490a32ee1bc8aae661f4983a5094609e73e947663a497fd927ce562e}{UlJob::HIGH}:
634       job\_front = \hyperlink{classns3_1_1UplinkSchedulerMBQoS_acb8b5539e366b4942381b08edccfba4b}{m\_uplinkJobs\_high}.front ();
635       \hyperlink{classns3_1_1UplinkSchedulerMBQoS_acb8b5539e366b4942381b08edccfba4b}{m\_uplinkJobs\_high}.pop\_front ();
636       \textcolor{keywordflow}{break};
637     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1UlJob_a6ae1d8e2e490a32ee1bc8aae661f4983a3619db7d63201ac367a111b38e443eea}{UlJob::INTERMEDIATE}:
638       job\_front = \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a70eef7c9cb6dad5e71a2105e07d1ec69}{m\_uplinkJobs\_inter}.front ();
639       \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a70eef7c9cb6dad5e71a2105e07d1ec69}{m\_uplinkJobs\_inter}.pop\_front ();
640       \textcolor{keywordflow}{break};
641     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1UlJob_a6ae1d8e2e490a32ee1bc8aae661f4983a092c552c374d3aecff410695b003d49d}{UlJob::LOW}:
642       job\_front = \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a73b59113ed20a512685dc76e93cf1faa}{m\_uplinkJobs\_low}.front ();
643       \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a73b59113ed20a512685dc76e93cf1faa}{m\_uplinkJobs\_low}.pop\_front ();
644     \}
645   \textcolor{keywordflow}{return} job\_front;
646 \}
\end{DoxyCode}
\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!Determine\+Deadline@{Determine\+Deadline}}
\index{Determine\+Deadline@{Determine\+Deadline}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{Determine\+Deadline(\+Service\+Flow $\ast$service\+Flow)}{DetermineDeadline(ServiceFlow *serviceFlow)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::\+Determine\+Deadline (
\begin{DoxyParamCaption}
\item[{{\bf Service\+Flow} $\ast$}]{service\+Flow}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_adadb381ed6d228290bae257e4344d84d}{}\label{classns3_1_1UplinkSchedulerMBQoS_adadb381ed6d228290bae257e4344d84d}


Calculates deadline of a request. 


\begin{DoxyParams}{Parameters}
{\em service\+Flow} & Service flow of connection \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{classns3_1_1Time}{Time} 
\end{DoxyReturn}

\begin{DoxyCode}
1147 \{
1148   uint32\_t latency = serviceFlow->GetMaximumLatency ();
1149   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} lastGrantTime = serviceFlow->GetRecord ()->GetLastGrantTime ();
1150   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} deadline = \hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (latency) + lastGrantTime;
1151   \textcolor{keywordflow}{return} deadline;
1152 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 19




Here is the caller graph for this function\+:
% FIG 20


\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!Enqueue\+Job@{Enqueue\+Job}}
\index{Enqueue\+Job@{Enqueue\+Job}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{Enqueue\+Job(\+Ul\+Job\+::\+Job\+Priority priority, Ptr$<$ Ul\+Job $>$ job)}{EnqueueJob(UlJob::JobPriority priority, Ptr< UlJob > job)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::\+Enqueue\+Job (
\begin{DoxyParamCaption}
\item[{{\bf Ul\+Job\+::\+Job\+Priority}}]{priority, }
\item[{{\bf Ptr}$<$ {\bf Ul\+Job} $>$}]{job}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_ad18bfc130fac723e65ada63fc3719b44}{}\label{classns3_1_1UplinkSchedulerMBQoS_ad18bfc130fac723e65ada63fc3719b44}


Enqueue a job in a priority queue. 


\begin{DoxyParams}{Parameters}
{\em priority} & Priority of queue \\
\hline
{\em job} & job information \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
613 \{
614   \textcolor{keywordflow}{switch} (priority)
615     \{
616     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1UlJob_a6ae1d8e2e490a32ee1bc8aae661f4983a5094609e73e947663a497fd927ce562e}{UlJob::HIGH}:
617       \hyperlink{classns3_1_1UplinkSchedulerMBQoS_acb8b5539e366b4942381b08edccfba4b}{m\_uplinkJobs\_high}.push\_back (job);
618       \textcolor{keywordflow}{break};
619     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1UlJob_a6ae1d8e2e490a32ee1bc8aae661f4983a3619db7d63201ac367a111b38e443eea}{UlJob::INTERMEDIATE}:
620       \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a70eef7c9cb6dad5e71a2105e07d1ec69}{m\_uplinkJobs\_inter}.push\_back (job);
621       \textcolor{keywordflow}{break};
622     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1UlJob_a6ae1d8e2e490a32ee1bc8aae661f4983a092c552c374d3aecff410695b003d49d}{UlJob::LOW}:
623       \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a73b59113ed20a512685dc76e93cf1faa}{m\_uplinkJobs\_low}.push\_back (job);
624     \}
625 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 21


\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!Get\+Channel\+Descriptors\+To\+Update@{Get\+Channel\+Descriptors\+To\+Update}}
\index{Get\+Channel\+Descriptors\+To\+Update@{Get\+Channel\+Descriptors\+To\+Update}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{Get\+Channel\+Descriptors\+To\+Update(bool \&update\+Dcd, bool \&update\+Ucd, bool \&send\+Dcd, bool \&send\+Ucd)}{GetChannelDescriptorsToUpdate(bool &updateDcd, bool &updateUcd, bool &sendDcd, bool &sendUcd)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::\+Get\+Channel\+Descriptors\+To\+Update (
\begin{DoxyParamCaption}
\item[{bool \&}]{update\+Dcd, }
\item[{bool \&}]{update\+Ucd, }
\item[{bool \&}]{send\+Dcd, }
\item[{bool \&}]{send\+Ucd}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_a623029436fb0c8786de9d5ce1adf5978}{}\label{classns3_1_1UplinkSchedulerMBQoS_a623029436fb0c8786de9d5ce1adf5978}
Determines if channel descriptors sent in the current frame are required to be updated 
\begin{DoxyParams}{Parameters}
{\em update\+Dcd} & update D\+CD if true \\
\hline
{\em update\+Ucd} & update U\+CD if true \\
\hline
{\em send\+Dcd} & send D\+CD if true \\
\hline
{\em send\+Ucd} & send U\+CD if true \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1UplinkScheduler_ae500207af8583a3595da89edcc20b851}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
88 \{
89   \textcolor{comment}{/* DCD and UCD shall actually be updated when channel or burst profile definitions}
90 \textcolor{comment}{   change. burst profiles are updated based on number of SSs, network conditions and etc.}
91 \textcolor{comment}{   for now temporarily assuming DCD/UCD shall be updated everytime */}
92 
93   uint32\_t randNr = rand ();
94   \textcolor{keywordflow}{if} (randNr % 5 == 0 || \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetNrDcdSent () == 0)
95     \{
96       sendDcd = \textcolor{keyword}{true};
97     \}
98 
99   randNr = rand ();
100   \textcolor{keywordflow}{if} (randNr % 5 == 0 || \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetNrUcdSent () == 0)
101     \{
102       sendUcd = \textcolor{keyword}{true};
103     \}
104 
105   \textcolor{comment}{// -------------------------------------}
106   \textcolor{comment}{// additional, just to send more frequently}
107   \textcolor{keywordflow}{if} (!sendDcd)
108     \{
109       randNr = rand ();
110       \textcolor{keywordflow}{if} (randNr % 4 == 0)
111         \{
112           sendDcd = \textcolor{keyword}{true};
113         \}
114     \}
115 
116   \textcolor{keywordflow}{if} (!sendUcd)
117     \{
118       randNr = rand ();
119       \textcolor{keywordflow}{if} (randNr % 4 == 0)
120         \{
121           sendUcd = \textcolor{keyword}{true};
122         \}
123     \}
124   \textcolor{comment}{// -------------------------------------}
125 
126   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} timeSinceLastDcd = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} () - \hyperlink{classns3_1_1UplinkScheduler_a3db19e92a24c71af7d6aff5e94d488fe}{GetDcdTimeStamp} ();
127   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} timeSinceLastUcd = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} () - \hyperlink{classns3_1_1UplinkScheduler_a709e1a0e3c5ab174b0e1bc123dcfd676}{GetUcdTimeStamp} ();
128 
129   \textcolor{keywordflow}{if} (timeSinceLastDcd > \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetDcdInterval ())
130     \{
131       sendDcd = \textcolor{keyword}{true};
132       \hyperlink{classns3_1_1UplinkScheduler_a18ccfd91b3f58a55f7249bbafb858f5c}{SetDcdTimeStamp} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ());
133     \}
134 
135   \textcolor{keywordflow}{if} (timeSinceLastUcd > \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetUcdInterval ())
136     \{
137       sendUcd = \textcolor{keyword}{true};
138       \hyperlink{classns3_1_1UplinkScheduler_a0dff82b69865688622c0453a35bffe98}{SetUcdTimeStamp} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ());
139     \}
140 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 22


\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!Get\+Pending\+Size@{Get\+Pending\+Size}}
\index{Get\+Pending\+Size@{Get\+Pending\+Size}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{Get\+Pending\+Size(\+Service\+Flow $\ast$service\+Flow)}{GetPendingSize(ServiceFlow *serviceFlow)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::\+Get\+Pending\+Size (
\begin{DoxyParamCaption}
\item[{{\bf Service\+Flow} $\ast$}]{service\+Flow}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_acd81dfb3cabd98ee2f244df25e14558c}{}\label{classns3_1_1UplinkSchedulerMBQoS_acd81dfb3cabd98ee2f244df25e14558c}

\begin{DoxyParams}{Parameters}
{\em service\+Flow} & \hyperlink{classns3_1_1ServiceFlow}{Service\+Flow} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Ptr$<$\+Ul\+Job$>$
\end{DoxyReturn}
Get pending size. 
\begin{DoxyCode}
1060 \{
1061   uint32\_t size = 0;
1062   std::list<Ptr <PriorityUlJob> > priorityUlJobs;
1063 
1064   \textcolor{comment}{// for each request in the imermediate queue}
1065   \textcolor{keywordflow}{for} (\hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std::list}<Ptr<UlJob> >::const\_iterator iter = \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a70eef7c9cb6dad5e71a2105e07d1ec69}{m\_uplinkJobs\_inter}.begin ()
      ; iter
1066        != \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a70eef7c9cb6dad5e71a2105e07d1ec69}{m\_uplinkJobs\_inter}.end (); ++iter)
1067     \{
1068       Ptr<UlJob> job = *iter;
1069 
1070       ServiceFlow *serviceFlowJob = job->GetServiceFlow ();
1071 
1072       \textcolor{keywordflow}{if} (serviceFlowJob == serviceFlow)
1073         \{
1074           size += job->GetSize ();
1075         \}
1076     \}
1077   \textcolor{keywordflow}{return} size;
1078 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 23


\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_a4c634147cc54a03736648d6f128826d6}{}\label{classns3_1_1UplinkSchedulerMBQoS_a4c634147cc54a03736648d6f128826d6}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
56 \{
57   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::UplinkSchedulerMBQoS"})
58 
59     .SetParent<\hyperlink{classns3_1_1UplinkScheduler_a49c38d7e63903d62bb825c38ba3be0fa}{UplinkScheduler}> ()
60 
61     .SetGroupName(\textcolor{stringliteral}{"Wimax"})
62 
63     .AddAttribute (\textcolor{stringliteral}{"WindowInterval"},
64                    \textcolor{stringliteral}{"The time to wait to reset window"},
65                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (1.0)),
66                    MakeTimeAccessor (&\hyperlink{classns3_1_1UplinkSchedulerMBQoS_aa3fb881e781d8cda4e7bb011c30d9f5d}{UplinkSchedulerMBQoS::m\_windowInterval}
      ),
67                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ());
68   \textcolor{keywordflow}{return} tid;
69 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 24


\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!Get\+Uplink\+Allocations@{Get\+Uplink\+Allocations}}
\index{Get\+Uplink\+Allocations@{Get\+Uplink\+Allocations}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{Get\+Uplink\+Allocations(void) const }{GetUplinkAllocations(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std\+::list}$<$ {\bf Ofdm\+Ul\+Map\+Ie} $>$ ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::\+Get\+Uplink\+Allocations (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_a09725afc94899e4aacf646abe0ab1f04}{}\label{classns3_1_1UplinkSchedulerMBQoS_a09725afc94899e4aacf646abe0ab1f04}
Get uplink allocations \begin{DoxyReturn}{Returns}
std\+::list$<$\+Ofdm\+Ul\+Map\+Ie$>$ 
\end{DoxyReturn}


Reimplemented from \hyperlink{classns3_1_1UplinkScheduler_a7170d8d32d3af5c07febafc2c6712f8c}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
79 \{
80   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UplinkSchedulerMBQoS_afdca0f835bd9f2b31ad19a7a2a2f4382}{m\_uplinkAllocations};
81 \}
\end{DoxyCode}
\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!Init\+Once@{Init\+Once}}
\index{Init\+Once@{Init\+Once}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{Init\+Once(void)}{InitOnce(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::\+Init\+Once (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_aa0ce923b356285a9e28d90b698d17557}{}\label{classns3_1_1UplinkSchedulerMBQoS_aa0ce923b356285a9e28d90b698d17557}
This method is called once to initialize window. 

Implements \hyperlink{classns3_1_1UplinkScheduler_ae427e6144919f70a361c047ddcfd5c4c}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
73 \{
74   \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a80733614c419c105ae666e830f1d5c1e}{UplinkSchedWindowTimer} ();
75 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 25


\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!On\+Set\+Requested\+Bandwidth@{On\+Set\+Requested\+Bandwidth}}
\index{On\+Set\+Requested\+Bandwidth@{On\+Set\+Requested\+Bandwidth}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{On\+Set\+Requested\+Bandwidth(\+Service\+Flow\+Record $\ast$sfr)}{OnSetRequestedBandwidth(ServiceFlowRecord *sfr)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::\+On\+Set\+Requested\+Bandwidth (
\begin{DoxyParamCaption}
\item[{{\bf Service\+Flow\+Record} $\ast$}]{sfr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_ae3d25dea784092d453a60cb97364ac57}{}\label{classns3_1_1UplinkSchedulerMBQoS_ae3d25dea784092d453a60cb97364ac57}
Set requested bandwidth 

Implements \hyperlink{classns3_1_1UplinkScheduler_a7bd17c3434380b9a57f8dcae6f4f289c}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
1156 \{
1157   \textcolor{comment}{// virtual function on UplinkScheduler}
1158   \textcolor{comment}{// this is not necessary on this implementation}
1159 \}
\end{DoxyCode}
\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!Process\+Bandwidth\+Request@{Process\+Bandwidth\+Request}}
\index{Process\+Bandwidth\+Request@{Process\+Bandwidth\+Request}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{Process\+Bandwidth\+Request(const Bandwidth\+Request\+Header \&bw\+Request\+Hdr)}{ProcessBandwidthRequest(const BandwidthRequestHeader &bwRequestHdr)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::\+Process\+Bandwidth\+Request (
\begin{DoxyParamCaption}
\item[{const {\bf Bandwidth\+Request\+Header} \&}]{bw\+Request\+Hdr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_a42c3d42e2972874f56b423b1c32e07b4}{}\label{classns3_1_1UplinkSchedulerMBQoS_a42c3d42e2972874f56b423b1c32e07b4}
Process bandwidth request function 
\begin{DoxyParams}{Parameters}
{\em bw\+Request\+Hdr} & \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1UplinkScheduler_afca8bc8fcb079d7ee97c1d1f14a0ee2f}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
1082 \{
1083   \textcolor{comment}{// Enqueue requests for uplink scheduler.}
1084   Ptr<UlJob> job = CreateObject <UlJob> ();
1085   Ptr<WimaxConnection> connection = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetConnectionManager ()->GetConnection (bwRequestHdr.
      GetCid ());
1086   SSRecord *ssRecord = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetSSManager ()->GetSSRecord (connection->GetCid ());
1087   ServiceFlow *serviceFlow = connection->GetServiceFlow ();
1088 
1089   uint32\_t size = bwRequestHdr.GetBr ();
1090   uint32\_t pendingSize = \hyperlink{classns3_1_1UplinkSchedulerMBQoS_acd81dfb3cabd98ee2f244df25e14558c}{GetPendingSize} (serviceFlow);
1091 
1092   \textcolor{keywordflow}{if} (size > pendingSize)
1093     \{
1094       size -= pendingSize;
1095     \}
1096   \textcolor{keywordflow}{else}
1097     \{
1098       size = 0;
1099     \}
1100 
1101   \textcolor{keywordflow}{if} (size == 0)
1102     \{
1103       \textcolor{keywordflow}{return};
1104     \}
1105 
1106 
1107   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} deadline = \hyperlink{classns3_1_1UplinkSchedulerMBQoS_adadb381ed6d228290bae257e4344d84d}{DetermineDeadline} (serviceFlow);
1108   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} currentTime = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ();
1109   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae10c944bf9f3fba2686a5885ecc192d7}{period} = deadline; \textcolor{comment}{// So that deadline is properly updated..}
1110 
1111   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"At "}<<\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds ()<<\textcolor{stringliteral}{" at BS uplink scheduler,
       processing bandwidth request from."} <<
1112                 ssRecord->GetMacAddress () << \textcolor{stringliteral}{" and sf "} << serviceFlow->GetSchedulingType () <<\textcolor{stringliteral}{" with
       deadline in "} << deadline.\hyperlink{classns3_1_1Time_a8f20d5c3b0902d7b4320982f340b57c8}{GetSeconds} () << \textcolor{stringliteral}{" and size "} << size << \textcolor{stringliteral}{" aggreg size "} << bwRequestHdr.
      GetBr ());
1113 
1114   \textcolor{comment}{// Record data in job}
1115   job->SetSsRecord (ssRecord);
1116   job->SetServiceFlow (serviceFlow);
1117   job->SetSize (size);
1118   job->SetDeadline (deadline);
1119   job->SetReleaseTime (currentTime);
1120   job->SetSchedulingType (serviceFlow->GetSchedulingType ());
1121   job->SetPeriod (period);
1122   job->SetType (\hyperlink{namespacens3_a534f9a14e4d9aeb5b400e61f152a73a2ae87e0f8f47d5619e16355b1f8caca558}{DATA});
1123 
1124   \textcolor{comment}{// Enqueue job in Uplink Scheduler}
1125   \textcolor{keywordflow}{switch} (serviceFlow->GetSchedulingType ())
1126     \{
1127     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a0e98ff713b932a029acad7e5b24bbf55}{ServiceFlow::SF\_TYPE\_RTPS}:
1128       \hyperlink{classns3_1_1UplinkSchedulerMBQoS_ad18bfc130fac723e65ada63fc3719b44}{EnqueueJob} (\hyperlink{classns3_1_1UlJob_a6ae1d8e2e490a32ee1bc8aae661f4983a3619db7d63201ac367a111b38e443eea}{UlJob::INTERMEDIATE}, job);
1129       \textcolor{keywordflow}{break};
1130     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a7f8577f851a9f01d159442a3a3fcdf48}{ServiceFlow::SF\_TYPE\_NRTPS}:
1131       \hyperlink{classns3_1_1UplinkSchedulerMBQoS_ad18bfc130fac723e65ada63fc3719b44}{EnqueueJob} (\hyperlink{classns3_1_1UlJob_a6ae1d8e2e490a32ee1bc8aae661f4983a3619db7d63201ac367a111b38e443eea}{UlJob::INTERMEDIATE}, job);
1132       \textcolor{keywordflow}{break};
1133     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235af93a8bd8fce654e688f957f6f362e5c7}{ServiceFlow::SF\_TYPE\_BE}:
1134       \hyperlink{classns3_1_1UplinkSchedulerMBQoS_ad18bfc130fac723e65ada63fc3719b44}{EnqueueJob} (\hyperlink{classns3_1_1UlJob_a6ae1d8e2e490a32ee1bc8aae661f4983a092c552c374d3aecff410695b003d49d}{UlJob::LOW}, job);
1135       \textcolor{keywordflow}{break};
1136     \textcolor{keywordflow}{default}:
1137       \hyperlink{classns3_1_1UplinkSchedulerMBQoS_ad18bfc130fac723e65ada63fc3719b44}{EnqueueJob} (\hyperlink{classns3_1_1UlJob_a6ae1d8e2e490a32ee1bc8aae661f4983a092c552c374d3aecff410695b003d49d}{UlJob::LOW}, job);
1138       \textcolor{keywordflow}{break};
1139     \}
1140 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 26


\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!Schedule@{Schedule}}
\index{Schedule@{Schedule}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{Schedule(void)}{Schedule(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::\+Schedule (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_abd019c4994078b9b6e6c012af5e34ac5}{}\label{classns3_1_1UplinkSchedulerMBQoS_abd019c4994078b9b6e6c012af5e34ac5}
Schedule function 

Implements \hyperlink{classns3_1_1UplinkScheduler_a36fc5c58146f1fb828f21f109cb1634c}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
219 \{
220   \hyperlink{classns3_1_1UplinkSchedulerMBQoS_afdca0f835bd9f2b31ad19a7a2a2f4382}{m\_uplinkAllocations}.clear ();
221   \hyperlink{classns3_1_1UplinkScheduler_a3eee0d06486678eab4d352a274676d95}{SetIsIrIntrvlAllocated} (\textcolor{keyword}{false});
222   \hyperlink{classns3_1_1UplinkScheduler_a766e3b6c032052002929eb351934e42b}{SetIsInvIrIntrvlAllocated} (\textcolor{keyword}{false});
223   \textcolor{keywordtype}{bool} allocationForDsa = \textcolor{keyword}{false};
224 
225   uint32\_t symbolsToAllocation = 0;
226   uint32\_t allocationSize = 0; \textcolor{comment}{// size in symbols}
227   uint32\_t availableSymbols = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetNrUlSymbols ();
228 
229   \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a6a9a487024bc6253cb5cada269994d24}{AllocateInitialRangingInterval} (symbolsToAllocation, availableSymbols);
230 
231   std::vector<SSRecord*> *ssRecords = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetSSManager ()->GetSSRecords ();
232   \textcolor{keywordflow}{for} (std::vector<SSRecord*>::iterator iter = ssRecords->begin (); iter != ssRecords->end (); ++iter)
233     \{
234       SSRecord *ssRecord = *iter;
235 
236       \textcolor{keywordflow}{if} (ssRecord->GetIsBroadcastSS ())
237         \{
238           \textcolor{keywordflow}{continue};
239         \}
240       Cid cid = ssRecord->GetBasicCid ();
241       OfdmUlMapIe ulMapIe;
242       ulMapIe.SetCid (cid);
243 
244       \textcolor{keywordflow}{if} (ssRecord->GetPollForRanging () && ssRecord->GetRangingStatus () == 
      \hyperlink{classns3_1_1WimaxNetDevice_a2a74c0f01e51abc1851a630242e7b591ace0a03105b6d7cf2c6ec79e9789dc3a6}{WimaxNetDevice::RANGING\_STATUS\_CONTINUE})
245         \{
246           \textcolor{comment}{// SS's ranging is not yet complete}
247           \textcolor{comment}{// allocating invited initial ranging interval}
248           ulMapIe.SetUiuc (\hyperlink{classns3_1_1OfdmUlBurstProfile_ae528783c4b3c6700ff49dfd7a555cb3daaea7b6256d4bcd0125f0248c0560c94e}{OfdmUlBurstProfile::UIUC\_INITIAL\_RANGING}
      );
249           allocationSize = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetRangReqOppSize ();
250           \hyperlink{classns3_1_1UplinkScheduler_a766e3b6c032052002929eb351934e42b}{SetIsInvIrIntrvlAllocated} (\textcolor{keyword}{true});
251 
252           \textcolor{keywordflow}{if} (availableSymbols >= allocationSize)
253             \{
254               \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a23b74ad65ec3d22b55d25648addd7486}{AddUplinkAllocation} (ulMapIe, allocationSize, symbolsToAllocation, 
      availableSymbols);
255             \}
256           \textcolor{keywordflow}{else}
257             \{
258               \textcolor{keywordflow}{break};
259             \}
260         \}
261       \textcolor{keywordflow}{else}
262         \{
263           \hyperlink{classns3_1_1WimaxPhy_a044c5d8a48ca992c39c2a946f6e755fa}{WimaxPhy::ModulationType} modulationType = ssRecord->GetModulationType ();
264 
265           \textcolor{comment}{// need to update because modulation/FEC to UIUC mapping may vary over time}
266           ulMapIe.SetUiuc (\hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetBurstProfileManager ()->GetBurstProfile (modulationType,
267                                                                                  
      \hyperlink{classns3_1_1WimaxNetDevice_a194b6cf7eb59582328eb2531dc9ed884ad37a477621d1df190ff8d8fb933349cd}{WimaxNetDevice::DIRECTION\_UPLINK}));
268 
269           \textcolor{comment}{// establish service flows for SS}
270           \textcolor{keywordflow}{if} (ssRecord->GetRangingStatus () == 
      \hyperlink{classns3_1_1WimaxNetDevice_a2a74c0f01e51abc1851a630242e7b591a2a48f503c20971a1a5901af0b6d0746c}{WimaxNetDevice::RANGING\_STATUS\_SUCCESS}
271               && !ssRecord->GetAreServiceFlowsAllocated ())
272             \{
273 
274               \textcolor{comment}{// allocating grant (with arbitrary size) to allow SS to send DSA messages DSA-REQ and
       DSA-ACK}
275               \textcolor{comment}{// only one DSA allocation per frame}
276               \textcolor{keywordflow}{if} (!allocationForDsa)
277                 \{
278                   allocationSize = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetNrSymbols (\textcolor{keyword}{sizeof}(DsaReq), modulationType);
279 
280                   \textcolor{keywordflow}{if} (availableSymbols >= allocationSize)
281                     \{
282                       \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a23b74ad65ec3d22b55d25648addd7486}{AddUplinkAllocation} (ulMapIe, allocationSize, symbolsToAllocation,
       availableSymbols);
283                       allocationForDsa = \textcolor{keyword}{true};
284                     \}
285                   \textcolor{keywordflow}{else}
286                     \{
287                       \textcolor{keywordflow}{break};
288                     \}
289                 \}
290             \}
291           \textcolor{keywordflow}{else}
292             \{
293               \textcolor{comment}{// all service flows associated to SS are established now}
294 
295               \textcolor{comment}{/* Implementation of uplink scheduler}
296 \textcolor{comment}{               * [1] Freitag, J.; da Fonseca, N.L.S., "Uplink Scheduling with Quality of Service in IEEE
       802.16 Networks,"}
297 \textcolor{comment}{               * Global Telecommunications Conference, 2007. GLOBECOM '07. IEEE , vol., no., pp.2503-2508,
       26-30 Nov. 2007}
298 \textcolor{comment}{               * URL: http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4411386&isnumber=4410910 */}
299 
300               \textcolor{comment}{// Step 1}
301               \textcolor{keywordflow}{if} (availableSymbols)
302                 \{
303                   \textcolor{comment}{/*allocating grants for data transmission for UGS flows (Data Grant Burst Type IEs,
       6.3.7.4.3.3)}
304 \textcolor{comment}{                   (grant has been referred by different names e.g. transmission opportunity, slot,        
       uplink allocation, etc)*/}
305                   \textcolor{keywordflow}{if} (ssRecord->GetHasServiceFlowUgs ())
306                     \{
307                       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"At "} << \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds () << \textcolor{stringliteral}{"
       offering be unicast polling"});
308                       \textcolor{comment}{// Recover period interval information for UGS flow}
309                       \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} frame\_duration = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetFrameDuration ();
310                       \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time}
311                         timestamp =
312                         (*(ssRecord->GetServiceFlows (\hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a969e0b62fa12fef1dbb23913744ed594}{ServiceFlow::SF\_TYPE\_UGS}).
      begin ()))->GetRecord ()->GetLastGrantTime ()
313                         + \hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} ((*(ssRecord->GetServiceFlows (
      \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a969e0b62fa12fef1dbb23913744ed594}{ServiceFlow::SF\_TYPE\_UGS}).begin ()))->GetUnsolicitedGrantInterval ());
314 
315                       int64\_t \hyperlink{namespacevisualizer_1_1higcontainer_a3a06b62552347e51aaf4765391802719}{frame} = (timestamp - \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ()) / frame\_duration;
316 
317                       \textcolor{keywordflow}{if} (frame <= 1)
318                         \{
319                           \textcolor{comment}{// UGS Grants}
320                           \textcolor{comment}{// It is not necessary to enqueue UGS grants once it is periodically served}
321                           \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a3cbff7d3b7d31739806421f0eb2b1cc6}{ServiceUnsolicitedGrants} (ssRecord,
322                                                     \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a969e0b62fa12fef1dbb23913744ed594}{ServiceFlow::SF\_TYPE\_UGS},
323                                                     ulMapIe,
324                                                     modulationType,
325                                                     symbolsToAllocation,
326                                                     availableSymbols);
327                         \}
328                     \}
329 
330                   \textcolor{comment}{// enqueue allocate unicast polls for rtPS flows if bandwidth is available}
331                   \textcolor{keywordflow}{if} (ssRecord->GetHasServiceFlowRtps ())
332                     \{
333                       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"At "} << \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds () << \textcolor{stringliteral}{"
       offering rtps unicast polling"});
334                       Ptr<UlJob> jobRTPSPoll = \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a09c9fce5d8872eaf5cdf60209a556e21}{CreateUlJob} (ssRecord, 
      \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a0e98ff713b932a029acad7e5b24bbf55}{ServiceFlow::SF\_TYPE\_RTPS}, \hyperlink{namespacens3_a534f9a14e4d9aeb5b400e61f152a73a2ab774c9fb3410eec7ee3c8367c50ccbb3}{UNICAST\_POLLING});
335                       \hyperlink{classns3_1_1UplinkSchedulerMBQoS_ad18bfc130fac723e65ada63fc3719b44}{EnqueueJob} (\hyperlink{classns3_1_1UlJob_a6ae1d8e2e490a32ee1bc8aae661f4983a5094609e73e947663a497fd927ce562e}{UlJob::HIGH}, jobRTPSPoll);
336                     \}
337 
338                   \textcolor{keywordflow}{if} (ssRecord->GetHasServiceFlowNrtps ())
339                     \{
340                       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"At "} << \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds () << \textcolor{stringliteral}{"
       offering nrtps unicast polling"});
341                       \textcolor{comment}{// allocate unicast polls for nrtPS flows if bandwidth is available}
342                       Ptr<UlJob> jobNRTPSPoll = \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a09c9fce5d8872eaf5cdf60209a556e21}{CreateUlJob} (ssRecord, 
      \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a7f8577f851a9f01d159442a3a3fcdf48}{ServiceFlow::SF\_TYPE\_NRTPS}, \hyperlink{namespacens3_a534f9a14e4d9aeb5b400e61f152a73a2ab774c9fb3410eec7ee3c8367c50ccbb3}{UNICAST\_POLLING});
343                       \hyperlink{classns3_1_1UplinkSchedulerMBQoS_ad18bfc130fac723e65ada63fc3719b44}{EnqueueJob} (\hyperlink{classns3_1_1UlJob_a6ae1d8e2e490a32ee1bc8aae661f4983a5094609e73e947663a497fd927ce562e}{UlJob::HIGH}, jobNRTPSPoll);
344                     \}
345 
346                   \textcolor{keywordflow}{if} (ssRecord->GetHasServiceFlowBe ())
347                     \{
348                       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"At "} << \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds () << \textcolor{stringliteral}{"
       offering be unicast polling"});
349                       \textcolor{comment}{// finally allocate unicast polls for BE flows if bandwidth is available}
350                       Ptr<UlJob> jobBEPoll = \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a09c9fce5d8872eaf5cdf60209a556e21}{CreateUlJob} (ssRecord, 
      \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235af93a8bd8fce654e688f957f6f362e5c7}{ServiceFlow::SF\_TYPE\_BE}, \hyperlink{namespacens3_a534f9a14e4d9aeb5b400e61f152a73a2ab774c9fb3410eec7ee3c8367c50ccbb3}{UNICAST\_POLLING});
351                       \hyperlink{classns3_1_1UplinkSchedulerMBQoS_ad18bfc130fac723e65ada63fc3719b44}{EnqueueJob} (\hyperlink{classns3_1_1UlJob_a6ae1d8e2e490a32ee1bc8aae661f4983a5094609e73e947663a497fd927ce562e}{UlJob::HIGH}, jobBEPoll);
352                     \}
353                 \}
354             \}
355         \}
356     \}
357   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"At "} << \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds ()<< \textcolor{stringliteral}{" high queue has "} << 
      \hyperlink{classns3_1_1UplinkSchedulerMBQoS_acb8b5539e366b4942381b08edccfba4b}{m\_uplinkJobs\_high}.size ()<< \textcolor{stringliteral}{" jobs - after sched"});
358 
359   uint32\_t availableSymbolsAux = availableSymbols;
360   uint32\_t symbolsUsed = 0;
361 
362   symbolsUsed += \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a31659c6f3996b4a820235a4359ab2a5e}{CountSymbolsQueue} (\hyperlink{classns3_1_1UplinkSchedulerMBQoS_acb8b5539e366b4942381b08edccfba4b}{m\_uplinkJobs\_high});
363   availableSymbolsAux -= symbolsUsed;
364 
365   \textcolor{comment}{// Step 2 - Check Deadline - Migrate requests with deadline expiring}
366   \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a3f8e2b0a22540ea61354cf4147187399}{CheckDeadline} (availableSymbolsAux);
367 
368   \textcolor{comment}{// Step 3 - Check Minimum Bandwidth}
369   \hyperlink{classns3_1_1UplinkSchedulerMBQoS_ae25c9cfb244144f5f9e2b7393253d009}{CheckMinimumBandwidth} (availableSymbolsAux);
370 
371   \textcolor{comment}{// Scheduling high priority queue}
372   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"At "} << \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds ()<< \textcolor{stringliteral}{" high queue has "} << 
      \hyperlink{classns3_1_1UplinkSchedulerMBQoS_acb8b5539e366b4942381b08edccfba4b}{m\_uplinkJobs\_high}.size ()<< \textcolor{stringliteral}{" jobs"});
373   \textcolor{keywordflow}{while} ((availableSymbols) && (!\hyperlink{classns3_1_1UplinkSchedulerMBQoS_acb8b5539e366b4942381b08edccfba4b}{m\_uplinkJobs\_high}.empty ()))
374     \{
375 
376       Ptr<UlJob> job = \hyperlink{classns3_1_1UplinkSchedulerMBQoS_acb8b5539e366b4942381b08edccfba4b}{m\_uplinkJobs\_high}.front ();
377       OfdmUlMapIe ulMapIe;
378       SSRecord * ssRecord = job->GetSsRecord ();
379       \textcolor{keyword}{enum} \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235}{ServiceFlow::SchedulingType} schedulingType = job->GetSchedulingType (
      );
380 
381       Cid cid = ssRecord->GetBasicCid ();
382       ulMapIe.SetCid (cid);
383       \hyperlink{classns3_1_1WimaxPhy_a044c5d8a48ca992c39c2a946f6e755fa}{WimaxPhy::ModulationType} modulationType = ssRecord->GetModulationType ();
384       \textcolor{comment}{// need to update because modulation/FEC to UIUC mapping may vary over time}
385       ulMapIe.SetUiuc (\hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetBurstProfileManager ()->GetBurstProfile (modulationType,
386                                                                              
      \hyperlink{classns3_1_1WimaxNetDevice_a194b6cf7eb59582328eb2531dc9ed884ad37a477621d1df190ff8d8fb933349cd}{WimaxNetDevice::DIRECTION\_UPLINK}));
387 
388       \hyperlink{namespacens3_a534f9a14e4d9aeb5b400e61f152a73a2}{ReqType} reqType = job->GetType ();
389 
390       \textcolor{keywordflow}{if} (reqType == \hyperlink{namespacens3_a534f9a14e4d9aeb5b400e61f152a73a2ab774c9fb3410eec7ee3c8367c50ccbb3}{UNICAST\_POLLING})
391         \{
392           \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a3cbff7d3b7d31739806421f0eb2b1cc6}{ServiceUnsolicitedGrants} (ssRecord,
393                                     schedulingType,
394                                     ulMapIe,
395                                     modulationType,
396                                     symbolsToAllocation,
397                                     availableSymbols);
398         \}
399       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (reqType == \hyperlink{namespacens3_a534f9a14e4d9aeb5b400e61f152a73a2ae87e0f8f47d5619e16355b1f8caca558}{DATA})
400         \{
401           ServiceFlow *serviceFlow = job->GetServiceFlow ();
402           uint32\_t allocSizeBytes = job->GetSize ();
403           \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a9880f5e1bce7b93ddff11623f29d4865}{ServiceBandwidthRequestsBytes} (serviceFlow,
404                                          schedulingType,
405                                          ulMapIe,
406                                          modulationType,
407                                          symbolsToAllocation,
408                                          availableSymbols,
409                                          allocSizeBytes);
410         \}
411       \hyperlink{classns3_1_1UplinkSchedulerMBQoS_acb8b5539e366b4942381b08edccfba4b}{m\_uplinkJobs\_high}.pop\_front ();
412     \}
413 
414   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"At "} << \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds ()<< \textcolor{stringliteral}{" interqueue has "} << 
      \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a70eef7c9cb6dad5e71a2105e07d1ec69}{m\_uplinkJobs\_inter}.size ()<< \textcolor{stringliteral}{" jobs"});
415   \textcolor{comment}{/* Scheduling intermediate priority queue */}
416   \textcolor{keywordflow}{while} ((availableSymbols) && (!\hyperlink{classns3_1_1UplinkSchedulerMBQoS_a70eef7c9cb6dad5e71a2105e07d1ec69}{m\_uplinkJobs\_inter}.empty ()))
417     \{
418       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"At "} << \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds ()<< \textcolor{stringliteral}{" Scheduling
       interqueue"});
419       Ptr<UlJob> job = \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a70eef7c9cb6dad5e71a2105e07d1ec69}{m\_uplinkJobs\_inter}.front ();
420       OfdmUlMapIe ulMapIe;
421       SSRecord * ssRecord = job->GetSsRecord ();
422       \textcolor{keyword}{enum} \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235}{ServiceFlow::SchedulingType} schedulingType = job->GetSchedulingType (
      );
423 
424       Cid cid = ssRecord->GetBasicCid ();
425       ulMapIe.SetCid (cid);
426       \hyperlink{classns3_1_1WimaxPhy_a044c5d8a48ca992c39c2a946f6e755fa}{WimaxPhy::ModulationType} modulationType = ssRecord->GetModulationType ();
427       \textcolor{comment}{// need to update because modulation/FEC to UIUC mapping may vary over time}
428       ulMapIe.SetUiuc (\hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetBurstProfileManager ()->GetBurstProfile (modulationType,
429                                                                              
      \hyperlink{classns3_1_1WimaxNetDevice_a194b6cf7eb59582328eb2531dc9ed884ad37a477621d1df190ff8d8fb933349cd}{WimaxNetDevice::DIRECTION\_UPLINK}));
430 
431       \hyperlink{namespacens3_a534f9a14e4d9aeb5b400e61f152a73a2}{ReqType} reqType = job->GetType ();
432 
433       \textcolor{keywordflow}{if} (reqType == \hyperlink{namespacens3_a534f9a14e4d9aeb5b400e61f152a73a2ae87e0f8f47d5619e16355b1f8caca558}{DATA})
434         \{
435           \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a2405968bd60de182ce1e3d67ae416ba7}{ServiceBandwidthRequests} (ssRecord,
436                                     schedulingType,
437                                     ulMapIe,
438                                     modulationType,
439                                     symbolsToAllocation,
440                                     availableSymbols);
441         \}
442       \textcolor{keywordflow}{else}
443         \{
444           \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Intermediate priority queue only should enqueue data packets."});
445         \}
446       \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a70eef7c9cb6dad5e71a2105e07d1ec69}{m\_uplinkJobs\_inter}.pop\_front ();
447     \}
448 
449   \textcolor{comment}{/* Scheduling low priority queue */}
450   \textcolor{keywordflow}{while} ((availableSymbols) && (!\hyperlink{classns3_1_1UplinkSchedulerMBQoS_a73b59113ed20a512685dc76e93cf1faa}{m\_uplinkJobs\_low}.empty ()))
451     \{
452 
453       Ptr<UlJob> job = \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a73b59113ed20a512685dc76e93cf1faa}{m\_uplinkJobs\_low}.front ();
454       OfdmUlMapIe ulMapIe;
455       SSRecord * ssRecord = job->GetSsRecord ();
456       \textcolor{keyword}{enum} \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235}{ServiceFlow::SchedulingType} schedulingType = job->GetSchedulingType (
      );
457 
458       Cid cid = ssRecord->GetBasicCid ();
459       ulMapIe.SetCid (cid);
460       \hyperlink{classns3_1_1WimaxPhy_a044c5d8a48ca992c39c2a946f6e755fa}{WimaxPhy::ModulationType} modulationType = ssRecord->GetModulationType ();
461       \textcolor{comment}{// need to update because modulation/FEC to UIUC mapping may vary over time}
462       ulMapIe.SetUiuc (\hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetBurstProfileManager ()->GetBurstProfile (modulationType,
463                                                                              
      \hyperlink{classns3_1_1WimaxNetDevice_a194b6cf7eb59582328eb2531dc9ed884ad37a477621d1df190ff8d8fb933349cd}{WimaxNetDevice::DIRECTION\_UPLINK}));
464 
465       \hyperlink{namespacens3_a534f9a14e4d9aeb5b400e61f152a73a2}{ReqType} reqType = job->GetType ();
466 
467       \textcolor{keywordflow}{if} (reqType == \hyperlink{namespacens3_a534f9a14e4d9aeb5b400e61f152a73a2ae87e0f8f47d5619e16355b1f8caca558}{DATA})
468         \{
469           \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a2405968bd60de182ce1e3d67ae416ba7}{ServiceBandwidthRequests} (ssRecord,
470                                     schedulingType,
471                                     ulMapIe,
472                                     modulationType,
473                                     symbolsToAllocation,
474                                     availableSymbols);
475         \}
476       \textcolor{keywordflow}{else}
477         \{
478           \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Low priority queue only should enqueue data packets."});
479         \}
480       \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a73b59113ed20a512685dc76e93cf1faa}{m\_uplinkJobs\_low}.pop\_front ();
481     \}
482 
483   OfdmUlMapIe ulMapIeEnd;
484   ulMapIeEnd.SetCid (Cid (0));
485   ulMapIeEnd.SetStartTime (symbolsToAllocation);
486   ulMapIeEnd.SetUiuc (\hyperlink{classns3_1_1OfdmUlBurstProfile_ae528783c4b3c6700ff49dfd7a555cb3dabef491e8d426af16beba1541b947b7e9}{OfdmUlBurstProfile::UIUC\_END\_OF\_MAP});
487   ulMapIeEnd.SetDuration (0);
488   \hyperlink{classns3_1_1UplinkSchedulerMBQoS_afdca0f835bd9f2b31ad19a7a2a2f4382}{m\_uplinkAllocations}.push\_back (ulMapIeEnd);
489 
490   \textcolor{comment}{// setting DL/UL subframe allocation for the next frame}
491   \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetBandwidthManager ()->SetSubframeRatio ();
492 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 27


\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!Service\+Bandwidth\+Requests@{Service\+Bandwidth\+Requests}}
\index{Service\+Bandwidth\+Requests@{Service\+Bandwidth\+Requests}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{Service\+Bandwidth\+Requests(const S\+S\+Record $\ast$ss\+Record, enum Service\+Flow\+::\+Scheduling\+Type scheduling\+Type, Ofdm\+Ul\+Map\+Ie \&ul\+Map\+Ie, const Wimax\+Phy\+::\+Modulation\+Type modulation\+Type, uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)}{ServiceBandwidthRequests(const SSRecord *ssRecord, enum ServiceFlow::SchedulingType schedulingType, OfdmUlMapIe &ulMapIe, const WimaxPhy::ModulationType modulationType, uint32_t &symbolsToAllocation, uint32_t &availableSymbols)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::\+Service\+Bandwidth\+Requests (
\begin{DoxyParamCaption}
\item[{const {\bf S\+S\+Record} $\ast$}]{ss\+Record, }
\item[{enum {\bf Service\+Flow\+::\+Scheduling\+Type}}]{scheduling\+Type, }
\item[{{\bf Ofdm\+Ul\+Map\+Ie} \&}]{ul\+Map\+Ie, }
\item[{const {\bf Wimax\+Phy\+::\+Modulation\+Type}}]{modulation\+Type, }
\item[{uint32\+\_\+t \&}]{symbols\+To\+Allocation, }
\item[{uint32\+\_\+t \&}]{available\+Symbols}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_a2405968bd60de182ce1e3d67ae416ba7}{}\label{classns3_1_1UplinkSchedulerMBQoS_a2405968bd60de182ce1e3d67ae416ba7}
Service bandwidth requests 
\begin{DoxyParams}{Parameters}
{\em ss\+Record} & the SS record \\
\hline
{\em scheduling\+Type} & the scheduling type \\
\hline
{\em ul\+Map\+Ie} & the UL map IE \\
\hline
{\em modulation\+Type} & the modulation type \\
\hline
{\em symbols\+To\+Allocation} & the symbols to allocation \\
\hline
{\em available\+Symbols} & the available symbols \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1UplinkScheduler_ae6bbcbf3cae55770d0f100692e8af16b}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
888 \{
889   std::vector<ServiceFlow*> serviceFlows = ssRecord->GetServiceFlows (schedulingType);
890 
891   \textcolor{keywordflow}{for} (std::vector<ServiceFlow*>::iterator iter = serviceFlows.begin (); iter != serviceFlows.end (); ++
      iter)
892     \{
893       \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1UplinkSchedulerMBQoS_a2405968bd60de182ce1e3d67ae416ba7}{ServiceBandwidthRequests} (*iter,
894                                      schedulingType,
895                                      ulMapIe,
896                                      modulationType,
897                                      symbolsToAllocation,
898                                      availableSymbols))
899         \{
900           \textcolor{keywordflow}{break};
901         \}
902     \}
903 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 28




Here is the caller graph for this function\+:
% FIG 29


\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!Service\+Bandwidth\+Requests@{Service\+Bandwidth\+Requests}}
\index{Service\+Bandwidth\+Requests@{Service\+Bandwidth\+Requests}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{Service\+Bandwidth\+Requests(\+Service\+Flow $\ast$service\+Flow, enum Service\+Flow\+::\+Scheduling\+Type scheduling\+Type, Ofdm\+Ul\+Map\+Ie \&ul\+Map\+Ie, const Wimax\+Phy\+::\+Modulation\+Type modulation\+Type, uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)}{ServiceBandwidthRequests(ServiceFlow *serviceFlow, enum ServiceFlow::SchedulingType schedulingType, OfdmUlMapIe &ulMapIe, const WimaxPhy::ModulationType modulationType, uint32_t &symbolsToAllocation, uint32_t &availableSymbols)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::\+Service\+Bandwidth\+Requests (
\begin{DoxyParamCaption}
\item[{{\bf Service\+Flow} $\ast$}]{service\+Flow, }
\item[{enum {\bf Service\+Flow\+::\+Scheduling\+Type}}]{scheduling\+Type, }
\item[{{\bf Ofdm\+Ul\+Map\+Ie} \&}]{ul\+Map\+Ie, }
\item[{const {\bf Wimax\+Phy\+::\+Modulation\+Type}}]{modulation\+Type, }
\item[{uint32\+\_\+t \&}]{symbols\+To\+Allocation, }
\item[{uint32\+\_\+t \&}]{available\+Symbols}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_a366a69170776175fcf651cb29e46fdf4}{}\label{classns3_1_1UplinkSchedulerMBQoS_a366a69170776175fcf651cb29e46fdf4}
Service bandwidth requests 
\begin{DoxyParams}{Parameters}
{\em service\+Flow} & the service flow \\
\hline
{\em scheduling\+Type} & the scheduling type \\
\hline
{\em ul\+Map\+Ie} & the UL map IE \\
\hline
{\em modulation\+Type} & the modulation type \\
\hline
{\em symbols\+To\+Allocation} & the symbols to allocation \\
\hline
{\em available\+Symbols} & the available symbols \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if successful 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1UplinkScheduler_a6e702b7f0bdb490a762b5e2b9b13c362}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
912 \{
913   uint32\_t allocSizeBytes = 0;
914   uint32\_t allocSizeSymbols = 0;
915   uint16\_t sduSize = 0;
916 
917   ServiceFlowRecord *record = serviceFlow->GetRecord ();
918   sduSize = serviceFlow->GetSduSize ();
919 
920   uint32\_t requiredBandwidth = record->GetRequestedBandwidth () - record->GetGrantedBandwidth ();
921   \textcolor{keywordflow}{if} (requiredBandwidth > 0)
922     \{
923       \textcolor{keywordflow}{if} (sduSize > 0)
924         \{
925           \textcolor{comment}{// if SDU size is mentioned, allocate grant of that size}
926           allocSizeBytes = sduSize;
927           allocSizeSymbols = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetNrSymbols (sduSize, modulationType);
928 
929         \}
930       \textcolor{keywordflow}{else}
931         \{
932           allocSizeBytes = requiredBandwidth;
933           allocSizeSymbols = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetNrSymbols (requiredBandwidth, modulationType);
934         \}
935 
936       \textcolor{keywordflow}{if} (availableSymbols >= allocSizeSymbols)
937         \{
938           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"BS uplink scheduler, "} << serviceFlow->GetSchedulingTypeStr () << \textcolor{stringliteral}{"
       allocation, size: "}
939                                                 << allocSizeSymbols << \textcolor{stringliteral}{" symbols"} << \textcolor{stringliteral}{", CID: "} << 
      serviceFlow->GetConnection ()->GetCid () << \textcolor{stringliteral}{", SFID: "}
940                                                 << serviceFlow->GetSfid () << \textcolor{stringliteral}{", bw requested: "} << record
      ->GetRequestedBandwidth () << \textcolor{stringliteral}{", bw granted: "}
941                                                 << record->GetGrantedBandwidth ());
942 
943           record->UpdateGrantedBandwidth (allocSizeBytes);
944 
945           record->SetBwSinceLastExpiry (allocSizeBytes);
946 
947           \textcolor{keywordflow}{if} (serviceFlow->GetRecord ()->GetBacklogged () < allocSizeBytes)
948             \{
949               serviceFlow->GetRecord ()->SetBacklogged (0);
950             \}
951           \textcolor{keywordflow}{else}
952             \{
953               serviceFlow->GetRecord ()->IncreaseBacklogged (-allocSizeBytes);
954             \}
955           serviceFlow->GetRecord ()->SetLastGrantTime (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ());
956 
957           \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a23b74ad65ec3d22b55d25648addd7486}{AddUplinkAllocation} (ulMapIe, allocSizeSymbols, symbolsToAllocation, 
      availableSymbols);
958         \}
959       \textcolor{keywordflow}{else}
960         \{
961           \textcolor{keywordflow}{return} \textcolor{keyword}{false};
962         \}
963     \}
964   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
965 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 30


\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!Service\+Bandwidth\+Requests\+Bytes@{Service\+Bandwidth\+Requests\+Bytes}}
\index{Service\+Bandwidth\+Requests\+Bytes@{Service\+Bandwidth\+Requests\+Bytes}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{Service\+Bandwidth\+Requests\+Bytes(\+Service\+Flow $\ast$service\+Flow, enum Service\+Flow\+::\+Scheduling\+Type scheduling\+Type, Ofdm\+Ul\+Map\+Ie \&ul\+Map\+Ie, const Wimax\+Phy\+::\+Modulation\+Type modulation\+Type, uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols, uint32\+\_\+t allocation\+Size\+Bytes)}{ServiceBandwidthRequestsBytes(ServiceFlow *serviceFlow, enum ServiceFlow::SchedulingType schedulingType, OfdmUlMapIe &ulMapIe, const WimaxPhy::ModulationType modulationType, uint32_t &symbolsToAllocation, uint32_t &availableSymbols, uint32_t allocationSizeBytes)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::\+Service\+Bandwidth\+Requests\+Bytes (
\begin{DoxyParamCaption}
\item[{{\bf Service\+Flow} $\ast$}]{service\+Flow, }
\item[{enum {\bf Service\+Flow\+::\+Scheduling\+Type}}]{scheduling\+Type, }
\item[{{\bf Ofdm\+Ul\+Map\+Ie} \&}]{ul\+Map\+Ie, }
\item[{const {\bf Wimax\+Phy\+::\+Modulation\+Type}}]{modulation\+Type, }
\item[{uint32\+\_\+t \&}]{symbols\+To\+Allocation, }
\item[{uint32\+\_\+t \&}]{available\+Symbols, }
\item[{uint32\+\_\+t}]{allocation\+Size\+Bytes}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_a9880f5e1bce7b93ddff11623f29d4865}{}\label{classns3_1_1UplinkSchedulerMBQoS_a9880f5e1bce7b93ddff11623f29d4865}
Service bandwidth requests bytes. 
\begin{DoxyParams}{Parameters}
{\em service\+Flow} & the service flow \\
\hline
{\em scheduling\+Type} & the scheduling type \\
\hline
{\em ul\+Map\+Ie} & the UL map IE \\
\hline
{\em modulation\+Type} & the modulation type \\
\hline
{\em symbols\+To\+Allocation} & the symbols to allocation \\
\hline
{\em available\+Symbols} & the available symbols \\
\hline
{\em allocation\+Size\+Bytes} & the allocation size in bytes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if successful 
\end{DoxyReturn}

\begin{DoxyCode}
498 \{
499   uint32\_t allocSizeBytes = allocationSizeBytes;
500   uint32\_t allocSizeSymbols = 0;
501 
502   ServiceFlowRecord *record = serviceFlow->GetRecord ();
503 
504   uint32\_t requiredBandwidth = record->GetRequestedBandwidth ();
505 
506   \textcolor{keywordflow}{if} (requiredBandwidth > 0)
507     \{
508       allocSizeSymbols = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetNrSymbols (allocSizeBytes, modulationType);
509 
510       \textcolor{keywordflow}{if} (availableSymbols < allocSizeSymbols)
511         \{
512           allocSizeSymbols = availableSymbols;
513         \}
514 
515       \textcolor{keywordflow}{if} (availableSymbols >= allocSizeSymbols)
516         \{
517           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (
518             \textcolor{stringliteral}{"At "} << \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds ()<<\textcolor{stringliteral}{" BS uplink scheduler, "}
519                   << serviceFlow->GetSchedulingTypeStr ()
520                   << \textcolor{stringliteral}{" allocation, size: "} << allocSizeSymbols << \textcolor{stringliteral}{" symbols"}
521                   << \textcolor{stringliteral}{", CID: "}
522                   << serviceFlow->GetConnection ()->GetCid ()
523                   << \textcolor{stringliteral}{", SFID: "} << serviceFlow->GetSfid ()
524                   << \textcolor{stringliteral}{", bw requested: "} << record->GetRequestedBandwidth ()
525                   << \textcolor{stringliteral}{", bw granted: "} << allocSizeBytes
526                   << std::endl);
527 
528           record->UpdateGrantedBandwidthTemp (allocSizeBytes);
529           record->UpdateGrantedBandwidth (allocSizeBytes);
530           record->UpdateRequestedBandwidth (-allocSizeBytes);
531 
532           record->UpdateBwSinceLastExpiry (allocSizeBytes);
533 
534 
535           \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a23b74ad65ec3d22b55d25648addd7486}{AddUplinkAllocation} (ulMapIe, allocSizeSymbols, symbolsToAllocation,
536                                availableSymbols);
537         \} \textcolor{keywordflow}{else}
538         \{
539           \textcolor{keywordflow}{return} \textcolor{keyword}{false};
540         \}
541     \}
542   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
543 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 31




Here is the caller graph for this function\+:
% FIG 32


\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!Service\+Unsolicited\+Grants@{Service\+Unsolicited\+Grants}}
\index{Service\+Unsolicited\+Grants@{Service\+Unsolicited\+Grants}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{Service\+Unsolicited\+Grants(const S\+S\+Record $\ast$ss\+Record, enum Service\+Flow\+::\+Scheduling\+Type scheduling\+Type, Ofdm\+Ul\+Map\+Ie \&ul\+Map\+Ie, const Wimax\+Phy\+::\+Modulation\+Type modulation\+Type, uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)}{ServiceUnsolicitedGrants(const SSRecord *ssRecord, enum ServiceFlow::SchedulingType schedulingType, OfdmUlMapIe &ulMapIe, const WimaxPhy::ModulationType modulationType, uint32_t &symbolsToAllocation, uint32_t &availableSymbols)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::\+Service\+Unsolicited\+Grants (
\begin{DoxyParamCaption}
\item[{const {\bf S\+S\+Record} $\ast$}]{ss\+Record, }
\item[{enum {\bf Service\+Flow\+::\+Scheduling\+Type}}]{scheduling\+Type, }
\item[{{\bf Ofdm\+Ul\+Map\+Ie} \&}]{ul\+Map\+Ie, }
\item[{const {\bf Wimax\+Phy\+::\+Modulation\+Type}}]{modulation\+Type, }
\item[{uint32\+\_\+t \&}]{symbols\+To\+Allocation, }
\item[{uint32\+\_\+t \&}]{available\+Symbols}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_a3cbff7d3b7d31739806421f0eb2b1cc6}{}\label{classns3_1_1UplinkSchedulerMBQoS_a3cbff7d3b7d31739806421f0eb2b1cc6}
Service unsolicited grants 
\begin{DoxyParams}{Parameters}
{\em ss\+Record} & the SS record \\
\hline
{\em scheduling\+Type} & the scheduling type \\
\hline
{\em ul\+Map\+Ie} & the UL map IE \\
\hline
{\em modulation\+Type} & the modulation type \\
\hline
{\em symbols\+To\+Allocation} & the symbols to allocation \\
\hline
{\em available\+Symbols} & the available symbols \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1UplinkScheduler_ab0fb68e0b8923cbec983dbcffbe7a63f}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
829 \{
830   uint32\_t allocationSize = 0; \textcolor{comment}{// size in symbols}
831   uint8\_t uiuc = ulMapIe.GetUiuc (); \textcolor{comment}{// SS's burst profile}
832   std::vector<ServiceFlow*> serviceFlows = ssRecord->GetServiceFlows (schedulingType);
833 
834   \textcolor{keywordflow}{for} (std::vector<ServiceFlow*>::iterator iter = serviceFlows.begin (); iter != serviceFlows.end (); ++
      iter)
835     \{
836       ServiceFlow *serviceFlow = *iter;
837 
838       \textcolor{comment}{/* in case of rtPS, nrtPS and BE, allocating unicast polls for bandwidth requests (Request IEs,
       6.3.7.4.3.1).}
839 \textcolor{comment}{       in case of UGS, allocating grants for data transmission (Data Grant Burst Type IEs, 6.3.7.4.3.3)
       (grant has}
840 \textcolor{comment}{       been referred in this code by different names e.g. transmission opportunity, slot, allocation, etc) 
      */}
841 
842       allocationSize = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetBandwidthManager ()->CalculateAllocationSize (ssRecord, 
      serviceFlow);
843 
844       \textcolor{keywordflow}{if} (availableSymbols < allocationSize)
845         \{
846           \textcolor{keywordflow}{break};
847         \}
848 
849       \textcolor{keywordflow}{if} (allocationSize > 0)
850         \{
851           ulMapIe.SetStartTime (symbolsToAllocation);
852           \textcolor{keywordflow}{if} (serviceFlow->GetSchedulingType () != \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a969e0b62fa12fef1dbb23913744ed594}{ServiceFlow::SF\_TYPE\_UGS})
853             \{
854               \textcolor{comment}{// special burst profile with most robust modulation type is used for unicast polls (Request
       IEs)}
855               ulMapIe.SetUiuc (\hyperlink{classns3_1_1OfdmUlBurstProfile_ae528783c4b3c6700ff49dfd7a555cb3daae074d10caa7fe18da973227c7f9942f}{OfdmUlBurstProfile::UIUC\_REQ\_REGION\_FULL}
      );
856             \}
857         \}
858       \textcolor{keywordflow}{else}
859         \{
860           \textcolor{keywordflow}{continue};
861         \}
862 
863       \textcolor{keywordflow}{if} (serviceFlow->GetSchedulingType () == \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a969e0b62fa12fef1dbb23913744ed594}{ServiceFlow::SF\_TYPE\_UGS})
864         \{
865           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"BS uplink scheduler, UGS allocation, size: "} << allocationSize << \textcolor{stringliteral}{"
       symbols"});
866         \}
867       \textcolor{keywordflow}{else}
868         \{
869           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"BS uplink scheduler, "} << serviceFlow->GetSchedulingTypeStr () << \textcolor{stringliteral}{"
       unicast poll, size: "}
870                                                 << allocationSize << \textcolor{stringliteral}{" symbols"} << \textcolor{stringliteral}{", modulation: BPSK 1/2"}
      );
871         \}
872 
873       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{", CID: "} << serviceFlow->GetConnection ()->GetCid () << \textcolor{stringliteral}{", SFID: "} << 
      serviceFlow->GetSfid ());
874 
875       serviceFlow->GetRecord ()->SetLastGrantTime (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ());
876       \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a23b74ad65ec3d22b55d25648addd7486}{AddUplinkAllocation} (ulMapIe, allocationSize, symbolsToAllocation, 
      availableSymbols);
877       ulMapIe.SetUiuc (uiuc);
878     \}
879 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 33




Here is the caller graph for this function\+:
% FIG 34


\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!Setup\+Service\+Flow@{Setup\+Service\+Flow}}
\index{Setup\+Service\+Flow@{Setup\+Service\+Flow}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{Setup\+Service\+Flow(\+S\+S\+Record $\ast$ss\+Record, Service\+Flow $\ast$service\+Flow)}{SetupServiceFlow(SSRecord *ssRecord, ServiceFlow *serviceFlow)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::\+Setup\+Service\+Flow (
\begin{DoxyParamCaption}
\item[{{\bf S\+S\+Record} $\ast$}]{ss\+Record, }
\item[{{\bf Service\+Flow} $\ast$}]{service\+Flow}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_aef30b9e41f2b8da83b467c6a8121b34d}{}\label{classns3_1_1UplinkSchedulerMBQoS_aef30b9e41f2b8da83b467c6a8121b34d}
Setup service flow 
\begin{DoxyParams}{Parameters}
{\em ss\+Record} & the SS record \\
\hline
{\em service\+Flow} & the service flow \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1UplinkScheduler_a101bce0939ff2315db3d2e3b75b4fed6}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
1003 \{
1004   uint8\_t delayNrFrames = 1;
1005   uint32\_t bitsPerSecond = serviceFlow->GetMinReservedTrafficRate ();
1006   \hyperlink{classns3_1_1WimaxPhy_a044c5d8a48ca992c39c2a946f6e755fa}{WimaxPhy::ModulationType} modulation;
1007   uint32\_t bytesPerFrame =
1008     (uint32\_t ((\textcolor{keywordtype}{double})(bitsPerSecond) * \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetFrameDuration ().GetSeconds ())) / 8;
1009   uint32\_t frameDurationMSec = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetFrameDuration ().GetMilliSeconds ();
1010 
1011   \textcolor{keywordflow}{switch} (serviceFlow->GetSchedulingType ())
1012     \{
1013     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a969e0b62fa12fef1dbb23913744ed594}{ServiceFlow::SF\_TYPE\_UGS}:
1014       \{
1015         \textcolor{keywordflow}{if} (serviceFlow->GetIsMulticast () == \textcolor{keyword}{true})
1016           \{
1017             modulation = serviceFlow->GetModulation ();
1018           \}
1019         \textcolor{keywordflow}{else}
1020           \{
1021             modulation = ssRecord->GetModulationType ();
1022           \}
1023         uint32\_t grantSize = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetNrSymbols (bytesPerFrame, modulation);
1024         serviceFlow->GetRecord ()->SetGrantSize (grantSize);
1025 
1026         uint32\_t toleratedJitter = serviceFlow->GetToleratedJitter ();
1027 
1028         \textcolor{keywordflow}{if} (toleratedJitter > frameDurationMSec)
1029           \{
1030             delayNrFrames = (uint8\_t)(toleratedJitter / frameDurationMSec);
1031           \}
1032 
1033         uint16\_t interval = delayNrFrames * frameDurationMSec;
1034         serviceFlow->SetUnsolicitedGrantInterval (interval);
1035       \}
1036       \textcolor{keywordflow}{break};
1037     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a0e98ff713b932a029acad7e5b24bbf55}{ServiceFlow::SF\_TYPE\_RTPS}:
1038       \{
1039         serviceFlow->SetUnsolicitedPollingInterval (20);
1040       \}
1041       \textcolor{keywordflow}{break};
1042     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a7f8577f851a9f01d159442a3a3fcdf48}{ServiceFlow::SF\_TYPE\_NRTPS}:
1043       \{
1044         \textcolor{comment}{// no real-time guarantees are given to NRTPS, serviced based on available bandwidth}
1045         uint16\_t interval = 1000;
1046         serviceFlow->SetUnsolicitedPollingInterval (interval);
1047       \}
1048       \textcolor{keywordflow}{break};
1049     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235af93a8bd8fce654e688f957f6f362e5c7}{ServiceFlow::SF\_TYPE\_BE}:
1050       \{
1051         \textcolor{comment}{// no real-time guarantees are given to BE, serviced based on available bandwidth}
1052       \}
1053       \textcolor{keywordflow}{break};
1054     \textcolor{keywordflow}{default}:
1055       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Invalid scheduling type"});
1056     \}
1057 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 35


\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!Uplink\+Sched\+Window\+Timer@{Uplink\+Sched\+Window\+Timer}}
\index{Uplink\+Sched\+Window\+Timer@{Uplink\+Sched\+Window\+Timer}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{Uplink\+Sched\+Window\+Timer(void)}{UplinkSchedWindowTimer(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::\+Uplink\+Sched\+Window\+Timer (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_a80733614c419c105ae666e830f1d5c1e}{}\label{classns3_1_1UplinkSchedulerMBQoS_a80733614c419c105ae666e830f1d5c1e}


Reset the current window. According to a configured time, reset the window. 


\begin{DoxyCode}
163 \{
164 
165   \hyperlink{log-macros-disabled_8h_ab01b4392d98b06fb128e77c85129a477}{NS\_LOG} (\hyperlink{namespacens3_aa6464a4d69551a9cc968e17a65f39bdbae5a9fe44e2d62303656baa0cf1a687a0}{LOG\_DEBUG}, \textcolor{stringliteral}{"Window Reset at "} << (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ()).GetSeconds ());
166 
167   uint32\_t min\_bw = 0;
168 
169   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetSSManager ())
170     \{
171       \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{classns3_1_1UplinkSchedulerMBQoS_aa3fb881e781d8cda4e7bb011c30d9f5d}{m\_windowInterval}, &
      \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a80733614c419c105ae666e830f1d5c1e}{UplinkSchedulerMBQoS::UplinkSchedWindowTimer}, \textcolor{keyword}{this});
172       \textcolor{keywordflow}{return};
173     \}
174 
175   std::vector<SSRecord*> *ssRecords = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetSSManager ()->GetSSRecords ();
176 
177   \textcolor{comment}{// For each SS}
178   \textcolor{keywordflow}{for} (std::vector<SSRecord*>::iterator iter = ssRecords->begin (); iter != ssRecords->end (); ++iter)
179     \{
180       SSRecord *ssRecord = *iter;
181       std::vector<ServiceFlow*> serviceFlows = ssRecord->GetServiceFlows (
      \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235aaf7e58e43027cc9d351cd100a9d6dee3}{ServiceFlow::SF\_TYPE\_ALL});
182 
183       \textcolor{comment}{// For each flow}
184       \textcolor{keywordflow}{for} (std::vector<ServiceFlow*>::iterator iter2 = serviceFlows.begin (); iter2 != serviceFlows.end ();
       ++iter2)
185         \{
186           ServiceFlow *serviceFlow = *iter2;
187           \textcolor{keywordflow}{if} ((serviceFlow->GetSchedulingType () == \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a0e98ff713b932a029acad7e5b24bbf55}{ServiceFlow::SF\_TYPE\_RTPS}) || 
      (serviceFlow->GetSchedulingType ()
188                                                                                    == 
      \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a7f8577f851a9f01d159442a3a3fcdf48}{ServiceFlow::SF\_TYPE\_NRTPS}))
189             \{
190               min\_bw = (int) ceil (serviceFlow->GetMinReservedTrafficRate ());
191 
192               \textcolor{comment}{// This way we can compensate flows which did not get min\_bw in the previous window}
193               \textcolor{keywordflow}{if} ((serviceFlow->GetRecord ()->GetBacklogged () > 0)
194                   && (serviceFlow->GetRecord ()->GetBwSinceLastExpiry () < min\_bw))
195                 \{
196                   serviceFlow->GetRecord ()->UpdateBwSinceLastExpiry (-min\_bw);
197 
198                   \textcolor{comment}{// if backlogged < granted\_bw then we don't need to provide granted\_bw + min\_bw in next
       window, but backlogged + min\_bw}
199                   \textcolor{keywordflow}{if} (serviceFlow->GetRecord ()->GetBacklogged ()
200                       < (serviceFlow->GetRecord ()->GetBwSinceLastExpiry ()))
201                     \{
202                       serviceFlow->GetRecord ()->SetBwSinceLastExpiry (-serviceFlow->GetRecord ()->
      GetBacklogged ());
203                     \}
204                 \}
205               \textcolor{keywordflow}{else}
206                 \{
207                   serviceFlow->GetRecord ()->SetBwSinceLastExpiry (0);
208                 \}
209             \}
210         \}
211     \}
212 
213   \textcolor{comment}{// Periodically reset window}
214   \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{classns3_1_1UplinkSchedulerMBQoS_aa3fb881e781d8cda4e7bb011c30d9f5d}{m\_windowInterval}, &
      \hyperlink{classns3_1_1UplinkSchedulerMBQoS_a80733614c419c105ae666e830f1d5c1e}{UplinkSchedulerMBQoS::UplinkSchedWindowTimer}, \textcolor{keyword}{this});
215 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 36




Here is the caller graph for this function\+:
% FIG 37




\subsection{Member Data Documentation}
\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!m\+\_\+uplink\+Allocations@{m\+\_\+uplink\+Allocations}}
\index{m\+\_\+uplink\+Allocations@{m\+\_\+uplink\+Allocations}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{m\+\_\+uplink\+Allocations}{m_uplinkAllocations}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std\+::list}$<${\bf Ofdm\+Ul\+Map\+Ie}$>$ ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::m\+\_\+uplink\+Allocations\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_afdca0f835bd9f2b31ad19a7a2a2f4382}{}\label{classns3_1_1UplinkSchedulerMBQoS_afdca0f835bd9f2b31ad19a7a2a2f4382}


uplink allocations 

\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!m\+\_\+uplink\+Jobs\+\_\+high@{m\+\_\+uplink\+Jobs\+\_\+high}}
\index{m\+\_\+uplink\+Jobs\+\_\+high@{m\+\_\+uplink\+Jobs\+\_\+high}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{m\+\_\+uplink\+Jobs\+\_\+high}{m_uplinkJobs_high}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std\+::list}$<${\bf Ptr}$<${\bf Ul\+Job}$>$ $>$ ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::m\+\_\+uplink\+Jobs\+\_\+high\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_acb8b5539e366b4942381b08edccfba4b}{}\label{classns3_1_1UplinkSchedulerMBQoS_acb8b5539e366b4942381b08edccfba4b}


uplink jobs high priority 

\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!m\+\_\+uplink\+Jobs\+\_\+inter@{m\+\_\+uplink\+Jobs\+\_\+inter}}
\index{m\+\_\+uplink\+Jobs\+\_\+inter@{m\+\_\+uplink\+Jobs\+\_\+inter}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{m\+\_\+uplink\+Jobs\+\_\+inter}{m_uplinkJobs_inter}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std\+::list}$<${\bf Ptr}$<${\bf Ul\+Job}$>$ $>$ ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::m\+\_\+uplink\+Jobs\+\_\+inter\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_a70eef7c9cb6dad5e71a2105e07d1ec69}{}\label{classns3_1_1UplinkSchedulerMBQoS_a70eef7c9cb6dad5e71a2105e07d1ec69}


uplink jobs intermedite priority 

\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!m\+\_\+uplink\+Jobs\+\_\+low@{m\+\_\+uplink\+Jobs\+\_\+low}}
\index{m\+\_\+uplink\+Jobs\+\_\+low@{m\+\_\+uplink\+Jobs\+\_\+low}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{m\+\_\+uplink\+Jobs\+\_\+low}{m_uplinkJobs_low}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std\+::list}$<${\bf Ptr}$<${\bf Ul\+Job}$>$ $>$ ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::m\+\_\+uplink\+Jobs\+\_\+low\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_a73b59113ed20a512685dc76e93cf1faa}{}\label{classns3_1_1UplinkSchedulerMBQoS_a73b59113ed20a512685dc76e93cf1faa}


uplink jobs low priority 

\index{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}!m\+\_\+window\+Interval@{m\+\_\+window\+Interval}}
\index{m\+\_\+window\+Interval@{m\+\_\+window\+Interval}!ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS@{ns3\+::\+Uplink\+Scheduler\+M\+B\+QoS}}
\subsubsection[{\texorpdfstring{m\+\_\+window\+Interval}{m_windowInterval}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Uplink\+Scheduler\+M\+B\+Qo\+S\+::m\+\_\+window\+Interval\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UplinkSchedulerMBQoS_aa3fb881e781d8cda4e7bb011c30d9f5d}{}\label{classns3_1_1UplinkSchedulerMBQoS_aa3fb881e781d8cda4e7bb011c30d9f5d}


windows interval 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
wimax/model/\hyperlink{bs-uplink-scheduler-mbqos_8h}{bs-\/uplink-\/scheduler-\/mbqos.\+h}\item 
wimax/model/\hyperlink{bs-uplink-scheduler-mbqos_8cc}{bs-\/uplink-\/scheduler-\/mbqos.\+cc}\end{DoxyCompactItemize}
