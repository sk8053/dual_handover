\hypertarget{classSwitchFlowTableTestCase}{}\section{Switch\+Flow\+Table\+Test\+Case Class Reference}
\label{classSwitchFlowTableTestCase}\index{Switch\+Flow\+Table\+Test\+Case@{Switch\+Flow\+Table\+Test\+Case}}


Inheritance diagram for Switch\+Flow\+Table\+Test\+Case\+:
% FIG 0


Collaboration diagram for Switch\+Flow\+Table\+Test\+Case\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classSwitchFlowTableTestCase_a0ac785aa94c3482734aa54a11328a555}{Switch\+Flow\+Table\+Test\+Case} ()
\item 
virtual \hyperlink{classSwitchFlowTableTestCase_a74e1dd69e681f941d0237669b6643b99}{$\sim$\+Switch\+Flow\+Table\+Test\+Case} ()
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classSwitchFlowTableTestCase_a330a8bc3adb7737a3bf98beb7270d677}{Do\+Run} (void)
\begin{DoxyCompactList}\small\item\em Implementation to actually run this Test\+Case. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
sw\+\_\+chain $\ast$ \hyperlink{classSwitchFlowTableTestCase_a8f2e13cbf268c880500b1f2898b3558a}{m\+\_\+chain}
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Constructor \& Destructor Documentation}
\index{Switch\+Flow\+Table\+Test\+Case@{Switch\+Flow\+Table\+Test\+Case}!Switch\+Flow\+Table\+Test\+Case@{Switch\+Flow\+Table\+Test\+Case}}
\index{Switch\+Flow\+Table\+Test\+Case@{Switch\+Flow\+Table\+Test\+Case}!Switch\+Flow\+Table\+Test\+Case@{Switch\+Flow\+Table\+Test\+Case}}
\subsubsection[{\texorpdfstring{Switch\+Flow\+Table\+Test\+Case()}{SwitchFlowTableTestCase()}}]{\setlength{\rightskip}{0pt plus 5cm}Switch\+Flow\+Table\+Test\+Case\+::\+Switch\+Flow\+Table\+Test\+Case (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classSwitchFlowTableTestCase_a0ac785aa94c3482734aa54a11328a555}{}\label{classSwitchFlowTableTestCase_a0ac785aa94c3482734aa54a11328a555}

\begin{DoxyCode}
36                              : \hyperlink{classns3_1_1TestCase_a3b0b91a96aac1933e8d146e019b9e207}{TestCase} (\textcolor{stringliteral}{"Switch test case"})
37   \{
38     \hyperlink{classSwitchFlowTableTestCase_a8f2e13cbf268c880500b1f2898b3558a}{m\_chain} = chain\_create ();
39   \}
\end{DoxyCode}
\index{Switch\+Flow\+Table\+Test\+Case@{Switch\+Flow\+Table\+Test\+Case}!````~Switch\+Flow\+Table\+Test\+Case@{$\sim$\+Switch\+Flow\+Table\+Test\+Case}}
\index{````~Switch\+Flow\+Table\+Test\+Case@{$\sim$\+Switch\+Flow\+Table\+Test\+Case}!Switch\+Flow\+Table\+Test\+Case@{Switch\+Flow\+Table\+Test\+Case}}
\subsubsection[{\texorpdfstring{$\sim$\+Switch\+Flow\+Table\+Test\+Case()}{~SwitchFlowTableTestCase()}}]{\setlength{\rightskip}{0pt plus 5cm}virtual Switch\+Flow\+Table\+Test\+Case\+::$\sim$\+Switch\+Flow\+Table\+Test\+Case (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{classSwitchFlowTableTestCase_a74e1dd69e681f941d0237669b6643b99}{}\label{classSwitchFlowTableTestCase_a74e1dd69e681f941d0237669b6643b99}

\begin{DoxyCode}
42   \{
43     chain\_destroy (\hyperlink{classSwitchFlowTableTestCase_a8f2e13cbf268c880500b1f2898b3558a}{m\_chain});
44   \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{Switch\+Flow\+Table\+Test\+Case@{Switch\+Flow\+Table\+Test\+Case}!Do\+Run@{Do\+Run}}
\index{Do\+Run@{Do\+Run}!Switch\+Flow\+Table\+Test\+Case@{Switch\+Flow\+Table\+Test\+Case}}
\subsubsection[{\texorpdfstring{Do\+Run(void)}{DoRun(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void Switch\+Flow\+Table\+Test\+Case\+::\+Do\+Run (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classSwitchFlowTableTestCase_a330a8bc3adb7737a3bf98beb7270d677}{}\label{classSwitchFlowTableTestCase_a330a8bc3adb7737a3bf98beb7270d677}


Implementation to actually run this Test\+Case. 

Subclasses should override this method to conduct their tests. 

Implements \hyperlink{classns3_1_1TestCase_a8ff74680cf017ed42011e4be51917a24}{ns3\+::\+Test\+Case}.


\begin{DoxyCode}
54 \{
55   \textcolor{comment}{// Flow Table implementation is used by the OpenFlowSwitchNetDevice under the chain\_ methods}
56   \textcolor{comment}{// we should test its implementation to verify the flow table works.}
57 
58   \textcolor{comment}{// Initialization}
59   time\_init (); \textcolor{comment}{// OFSI requires this, otherwise we crash before we can do anything.}
60 
61   \textcolor{keywordtype}{size\_t} actions\_len = 0; \textcolor{comment}{// Flow is created with 0 actions.}
62   \textcolor{keywordtype}{int} output\_port = 0; \textcolor{comment}{// Flow will be modified later with an action to output on port 0.}
63 
64   \hyperlink{classns3_1_1Mac48Address}{Mac48Address} dl\_src (\textcolor{stringliteral}{"00:00:00:00:00:00"}), dl\_dst (\textcolor{stringliteral}{"00:00:00:00:00:01"});
65   \hyperlink{classns3_1_1Ipv4Address}{Ipv4Address} nw\_src (\textcolor{stringliteral}{"192.168.1.1"}), nw\_dst (\textcolor{stringliteral}{"192.168.1.2"});
66   \textcolor{keywordtype}{int} tp\_src = 5000, tp\_dst = 80;
67 
68   \textcolor{comment}{// Create an sw\_flow\_key; in actual usage this is generated from the received packet's headers.}
69   sw\_flow\_key key;
70   key.wildcards = 0;
71 
72   key.flow.in\_port = htons (0);
73 
74   key.flow.dl\_vlan = htons (OFP\_VLAN\_NONE);
75   key.flow.dl\_type = htons (ETH\_TYPE\_IP);
76   key.flow.nw\_proto = htons (IP\_TYPE\_UDP);
77 
78   key.flow.reserved = 0;
79   key.flow.mpls\_label1 = htonl (MPLS\_INVALID\_LABEL);
80   key.flow.mpls\_label2 = htonl (MPLS\_INVALID\_LABEL);
81 
82   \textcolor{comment}{// Set Mac Addresses}
83   dl\_src.CopyTo (key.flow.dl\_src);
84   dl\_dst.CopyTo (key.flow.dl\_dst);
85 
86   \textcolor{comment}{// Set IP Addresses}
87   key.flow.nw\_src = htonl (nw\_src.Get ());
88   key.flow.nw\_dst = htonl (nw\_dst.Get ());
89 
90   \textcolor{comment}{// Set TCP/UDP Ports}
91   key.flow.tp\_src = htonl (tp\_src);
92   key.flow.tp\_dst = htonl (tp\_dst);
93 
94   \textcolor{comment}{// Create flow}
95   ofp\_flow\_mod ofm;
96   ofm.header.version = OFP\_VERSION;
97   ofm.header.type = OFPT\_FLOW\_MOD;
98   ofm.header.length = htons (\textcolor{keyword}{sizeof} (ofp\_flow\_mod) + actions\_len);
99   ofm.command = htons (OFPFC\_ADD);
100   ofm.idle\_timeout = htons (OFP\_FLOW\_PERMANENT);
101   ofm.hard\_timeout = htons (OFP\_FLOW\_PERMANENT);
102   ofm.buffer\_id = htonl (-1);
103   ofm.priority = OFP\_DEFAULT\_PRIORITY;
104 
105   ofm.match.wildcards = key.wildcards;                                 \textcolor{comment}{// Wildcard fields}
106   ofm.match.in\_port = key.flow.in\_port;                                \textcolor{comment}{// Input switch port}
107   memcpy (ofm.match.dl\_src, key.flow.dl\_src, \textcolor{keyword}{sizeof} ofm.match.dl\_src); \textcolor{comment}{// Ethernet source address.}
108   memcpy (ofm.match.dl\_dst, key.flow.dl\_dst, \textcolor{keyword}{sizeof} ofm.match.dl\_dst); \textcolor{comment}{// Ethernet destination address.}
109   ofm.match.dl\_vlan = key.flow.dl\_vlan;                                \textcolor{comment}{// Input VLAN OFP\_VLAN\_NONE;}
110   ofm.match.dl\_type = key.flow.dl\_type;                                \textcolor{comment}{// Ethernet frame type ETH\_TYPE\_IP;}
111   ofm.match.nw\_proto = key.flow.nw\_proto;                              \textcolor{comment}{// IP Protocol}
112   ofm.match.nw\_src = key.flow.nw\_src;                                  \textcolor{comment}{// IP source address}
113   ofm.match.nw\_dst = key.flow.nw\_dst;                                  \textcolor{comment}{// IP destination address}
114   ofm.match.tp\_src = key.flow.tp\_src;                                  \textcolor{comment}{// TCP/UDP source port}
115   ofm.match.tp\_dst = key.flow.tp\_dst;                                  \textcolor{comment}{// TCP/UDP destination port}
116   ofm.match.mpls\_label1 = key.flow.mpls\_label1;                        \textcolor{comment}{// Top of label stack}
117   ofm.match.mpls\_label2 = key.flow.mpls\_label1;                        \textcolor{comment}{// Second label (if available)}
118 
119   \textcolor{comment}{// Build a sw\_flow from the ofp\_flow\_mod}
120   sw\_flow *flow = flow\_alloc (actions\_len);
121   \hyperlink{group__testing_ga73d66fb0050a5111453fd144e767b91a}{NS\_TEST\_ASSERT\_MSG\_NE} (flow, 0, \textcolor{stringliteral}{"Cannot allocate memory for the flow."});
122 
123   flow\_extract\_match (&flow->key, &ofm.match);
124 
125   \textcolor{comment}{// Fill out flow.}
126   flow->priority = flow->key.wildcards ? ntohs (ofm.priority) : -1;
127   flow->idle\_timeout = ntohs (ofm.idle\_timeout);
128   flow->hard\_timeout = ntohs (ofm.hard\_timeout);
129   flow->used = flow->created = time\_now ();
130   flow->sf\_acts->actions\_len = actions\_len;
131   flow->byte\_count = 0;
132   flow->packet\_count = 0;
133   memcpy (flow->sf\_acts->actions, ofm.actions, actions\_len);
134 
135   \textcolor{comment}{// Insert the flow into the Flow Table}
136   \hyperlink{group__testing_ga2a9d78cffb3db8e867c35fff0b698cf5}{NS\_TEST\_ASSERT\_MSG\_EQ} (chain\_insert (\hyperlink{classSwitchFlowTableTestCase_a8f2e13cbf268c880500b1f2898b3558a}{m\_chain}, flow), 0, \textcolor{stringliteral}{"Flow table failed to
       insert Flow."});
137 
138   \textcolor{comment}{// Use key to match the flow to verify we created it correctly.}
139   \hyperlink{group__testing_ga73d66fb0050a5111453fd144e767b91a}{NS\_TEST\_ASSERT\_MSG\_NE} (chain\_lookup (\hyperlink{classSwitchFlowTableTestCase_a8f2e13cbf268c880500b1f2898b3558a}{m\_chain}, &key), 0, \textcolor{stringliteral}{"Key provided doesn't
       match to the flow that was created from it."});
140 
141   \textcolor{comment}{// Modify key to make sure the flow doesn't match it.}
142   dl\_dst.CopyTo (key.flow.dl\_src);
143   dl\_src.CopyTo (key.flow.dl\_dst);
144   key.flow.nw\_src = htonl (nw\_dst.Get ());
145   key.flow.nw\_dst = htonl (nw\_src.Get ());
146   key.flow.tp\_src = htonl (tp\_dst);
147   key.flow.tp\_dst = htonl (tp\_src);
148 
149   \hyperlink{group__testing_ga2a9d78cffb3db8e867c35fff0b698cf5}{NS\_TEST\_ASSERT\_MSG\_EQ} (chain\_lookup (\hyperlink{classSwitchFlowTableTestCase_a8f2e13cbf268c880500b1f2898b3558a}{m\_chain}, &key), 0, \textcolor{stringliteral}{"Key provided
       shouldn't match the flow but it does."});
150 
151   \textcolor{comment}{// Modify key back to matching the flow so we can test flow modification.}
152   dl\_dst.CopyTo (key.flow.dl\_dst);
153   dl\_src.CopyTo (key.flow.dl\_src);
154   key.flow.nw\_src = htonl (nw\_src.Get ());
155   key.flow.nw\_dst = htonl (nw\_dst.Get ());
156   key.flow.tp\_src = htonl (tp\_src);
157   key.flow.tp\_dst = htonl (tp\_dst);
158 
159   \textcolor{comment}{// Testing Flow Modification; chain\_modify should return 1, for 1 flow modified.}
160   \textcolor{comment}{// Create output-to-port action}
161   ofp\_action\_output acts[1];
162   acts[0].type = htons (OFPAT\_OUTPUT);
163   acts[0].len = htons (\textcolor{keyword}{sizeof} (ofp\_action\_output));
164   acts[0].port = output\_port;
165 
166   uint16\_t priority = key.wildcards ? ntohs (ofm.priority) : -1;
167   \hyperlink{group__testing_ga2a9d78cffb3db8e867c35fff0b698cf5}{NS\_TEST\_ASSERT\_MSG\_EQ} (chain\_modify (\hyperlink{classSwitchFlowTableTestCase_a8f2e13cbf268c880500b1f2898b3558a}{m\_chain}, &key, priority, \textcolor{keyword}{false}, (\textcolor{keyword}{const} 
      ofp\_action\_header*)acts, \textcolor{keyword}{sizeof} (acts)), 1, \textcolor{stringliteral}{"Flow table failed to modify Flow."});
168 
169   \textcolor{comment}{// Testing Flow Deletion; chain\_delete should return 1, for 1 flow deleted.}
170   \textcolor{comment}{// Note: By providing chain\_delete with output\_port, the flow must have an action that outputs on that
       port in order to delete the flow.}
171   \textcolor{comment}{// This is how we verify that our action was truly added via the flow modification.}
172   \hyperlink{group__testing_ga2a9d78cffb3db8e867c35fff0b698cf5}{NS\_TEST\_ASSERT\_MSG\_EQ} (chain\_delete (\hyperlink{classSwitchFlowTableTestCase_a8f2e13cbf268c880500b1f2898b3558a}{m\_chain}, &key, output\_port, 0, 0), 1, \textcolor{stringliteral}{"
      Flow table failed to delete Flow."});
173   \hyperlink{group__testing_ga2a9d78cffb3db8e867c35fff0b698cf5}{NS\_TEST\_ASSERT\_MSG\_EQ} (chain\_lookup (\hyperlink{classSwitchFlowTableTestCase_a8f2e13cbf268c880500b1f2898b3558a}{m\_chain}, &key), 0, \textcolor{stringliteral}{"Key provided
       shouldn't match the flow but it does."});
174 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2




\subsection{Member Data Documentation}
\index{Switch\+Flow\+Table\+Test\+Case@{Switch\+Flow\+Table\+Test\+Case}!m\+\_\+chain@{m\+\_\+chain}}
\index{m\+\_\+chain@{m\+\_\+chain}!Switch\+Flow\+Table\+Test\+Case@{Switch\+Flow\+Table\+Test\+Case}}
\subsubsection[{\texorpdfstring{m\+\_\+chain}{m_chain}}]{\setlength{\rightskip}{0pt plus 5cm}sw\+\_\+chain$\ast$ Switch\+Flow\+Table\+Test\+Case\+::m\+\_\+chain\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classSwitchFlowTableTestCase_a8f2e13cbf268c880500b1f2898b3558a}{}\label{classSwitchFlowTableTestCase_a8f2e13cbf268c880500b1f2898b3558a}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
openflow/test/\hyperlink{openflow-switch-test-suite_8cc}{openflow-\/switch-\/test-\/suite.\+cc}\end{DoxyCompactItemize}
