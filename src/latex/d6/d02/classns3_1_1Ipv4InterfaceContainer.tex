\hypertarget{classns3_1_1Ipv4InterfaceContainer}{}\section{ns3\+:\+:Ipv4\+Interface\+Container Class Reference}
\label{classns3_1_1Ipv4InterfaceContainer}\index{ns3\+::\+Ipv4\+Interface\+Container@{ns3\+::\+Ipv4\+Interface\+Container}}


holds a vector of std\+::pair of Ptr$<$\+Ipv4$>$ and interface index.  




{\ttfamily \#include $<$ipv4-\/interface-\/container.\+h$>$}



Collaboration diagram for ns3\+:\+:Ipv4\+Interface\+Container\+:
% FIG 0
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef std\+::vector$<$ std\+::pair$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$, uint32\+\_\+t $>$ $>$\+::const\+\_\+iterator \hyperlink{classns3_1_1Ipv4InterfaceContainer_acedc286abfd3db405dfca5ddd73fd1d7}{Iterator}
\begin{DoxyCompactList}\small\item\em Container Const Iterator for pairs of \hyperlink{classns3_1_1Ipv4}{Ipv4} smart pointer / Interface Index. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ipv4InterfaceContainer_af501b5fa9d6e1cc316ba259609da608e}{Ipv4\+Interface\+Container} ()
\item 
void \hyperlink{classns3_1_1Ipv4InterfaceContainer_ae5e7881307c8d49c7606669ded6ac3d6}{Add} (const \hyperlink{classns3_1_1Ipv4InterfaceContainer}{Ipv4\+Interface\+Container} \&other)
\item 
\hyperlink{classns3_1_1Ipv4InterfaceContainer_acedc286abfd3db405dfca5ddd73fd1d7}{Iterator} \hyperlink{classns3_1_1Ipv4InterfaceContainer_a1f39f80de81e0b74362867a8f89264c9}{Begin} (void) const 
\begin{DoxyCompactList}\small\item\em Get an iterator which refers to the first pair in the container. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4InterfaceContainer_acedc286abfd3db405dfca5ddd73fd1d7}{Iterator} \hyperlink{classns3_1_1Ipv4InterfaceContainer_aa3173d4d097db7ebf17fc1cb84d06596}{End} (void) const 
\begin{DoxyCompactList}\small\item\em Get an iterator which indicates past-\/the-\/last \hyperlink{classns3_1_1Node}{Node} in the container. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1Ipv4InterfaceContainer_a8d565289d84cd90ef806d0f86e6235f9}{GetN} (void) const 
\item 
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \hyperlink{classns3_1_1Ipv4InterfaceContainer_ae63208dcd222be986822937ee4aa828c}{Get\+Address} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, uint32\+\_\+t j=0) const 
\item 
void \hyperlink{classns3_1_1Ipv4InterfaceContainer_a94248347eb8df7826f8576234fc2d1be}{Set\+Metric} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, uint16\+\_\+t metric)
\begin{DoxyCompactList}\small\item\em Set a metric for the given interface. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4InterfaceContainer_a9e52fccf4def47d4fcaa40d368a560c7}{Add} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$ ipv4, uint32\+\_\+t interface)
\item 
void \hyperlink{classns3_1_1Ipv4InterfaceContainer_ab19c6d1666a08c6804f4534a2f1d3343}{Add} (std\+::pair$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$, uint32\+\_\+t $>$ ip\+Interface\+Pair)
\item 
void \hyperlink{classns3_1_1Ipv4InterfaceContainer_a4102276d0f31b9ad4dd38a43cc88b5dc}{Add} (std\+::string ipv4\+Name, uint32\+\_\+t interface)
\item 
std\+::pair$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$, uint32\+\_\+t $>$ \hyperlink{classns3_1_1Ipv4InterfaceContainer_a6528d70874071a882a3f5068c12dd9ad}{Get} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) const 
\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
typedef std\+::vector$<$ std\+::pair$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$, uint32\+\_\+t $>$ $>$ \hyperlink{classns3_1_1Ipv4InterfaceContainer_aa8ccc14e1294bb6d73b9feb7546dc0bc}{Interface\+Vector}
\begin{DoxyCompactList}\small\item\em Container for pairs of \hyperlink{classns3_1_1Ipv4}{Ipv4} smart pointer / Interface Index. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ipv4InterfaceContainer_aa8ccc14e1294bb6d73b9feb7546dc0bc}{Interface\+Vector} \hyperlink{classns3_1_1Ipv4InterfaceContainer_ad24e1d0f593229265cf2a27a06c16329}{m\+\_\+interfaces}
\begin{DoxyCompactList}\small\item\em List of I\+Pv4 stack and interfaces index. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
holds a vector of std\+::pair of Ptr$<$\+Ipv4$>$ and interface index. 

Typically ns-\/3 Ipv4\+Interfaces are installed on devices using an \hyperlink{classns3_1_1Ipv4}{Ipv4} address helper. The helper\textquotesingle{}s Assign() method takes a \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} which holds some number of Ptr$<$\+Net\+Device$>$. For each of the Net\+Devices in the \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} the helper will find the associated \hyperlink{classns3_1_1Ptr}{Ptr$<$\+Node$>$} and Ptr$<$\+Ipv4$>$. It makes sure that an interface exists on the node for the device and then adds an \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} according to the address helper settings (incrementing the \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} somehow as it goes). The helper then converts the Ptr$<$\+Ipv4$>$ and the interface index to a std\+::pair and adds them to a container -- a container of this type.

The point is then to be able to implicitly associate an index into the original \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} (that identifies a particular net device) with an identical index into the \hyperlink{classns3_1_1Ipv4InterfaceContainer}{Ipv4\+Interface\+Container} that has a std\+::pair with the Ptr$<$\+Ipv4$>$ and interface index you need to play with the interface.

\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Ipv4AddressHelper}{Ipv4\+Address\+Helper} 

\hyperlink{classns3_1_1Ipv4}{Ipv4} 
\end{DoxySeeAlso}


\subsection{Member Typedef Documentation}
\index{ns3\+::\+Ipv4\+Interface\+Container@{ns3\+::\+Ipv4\+Interface\+Container}!Interface\+Vector@{Interface\+Vector}}
\index{Interface\+Vector@{Interface\+Vector}!ns3\+::\+Ipv4\+Interface\+Container@{ns3\+::\+Ipv4\+Interface\+Container}}
\subsubsection[{\texorpdfstring{Interface\+Vector}{InterfaceVector}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::vector$<$std\+::pair$<${\bf Ptr}$<${\bf Ipv4}$>$,uint32\+\_\+t$>$ $>$ {\bf ns3\+::\+Ipv4\+Interface\+Container\+::\+Interface\+Vector}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4InterfaceContainer_aa8ccc14e1294bb6d73b9feb7546dc0bc}{}\label{classns3_1_1Ipv4InterfaceContainer_aa8ccc14e1294bb6d73b9feb7546dc0bc}


Container for pairs of \hyperlink{classns3_1_1Ipv4}{Ipv4} smart pointer / Interface Index. 

\index{ns3\+::\+Ipv4\+Interface\+Container@{ns3\+::\+Ipv4\+Interface\+Container}!Iterator@{Iterator}}
\index{Iterator@{Iterator}!ns3\+::\+Ipv4\+Interface\+Container@{ns3\+::\+Ipv4\+Interface\+Container}}
\subsubsection[{\texorpdfstring{Iterator}{Iterator}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::vector$<$std\+::pair$<${\bf Ptr}$<${\bf Ipv4}$>$, uint32\+\_\+t$>$ $>$\+::const\+\_\+iterator {\bf ns3\+::\+Ipv4\+Interface\+Container\+::\+Iterator}}\hypertarget{classns3_1_1Ipv4InterfaceContainer_acedc286abfd3db405dfca5ddd73fd1d7}{}\label{classns3_1_1Ipv4InterfaceContainer_acedc286abfd3db405dfca5ddd73fd1d7}


Container Const Iterator for pairs of \hyperlink{classns3_1_1Ipv4}{Ipv4} smart pointer / Interface Index. 



\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Ipv4\+Interface\+Container@{ns3\+::\+Ipv4\+Interface\+Container}!Ipv4\+Interface\+Container@{Ipv4\+Interface\+Container}}
\index{Ipv4\+Interface\+Container@{Ipv4\+Interface\+Container}!ns3\+::\+Ipv4\+Interface\+Container@{ns3\+::\+Ipv4\+Interface\+Container}}
\subsubsection[{\texorpdfstring{Ipv4\+Interface\+Container()}{Ipv4InterfaceContainer()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv4\+Interface\+Container\+::\+Ipv4\+Interface\+Container (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4InterfaceContainer_af501b5fa9d6e1cc316ba259609da608e}{}\label{classns3_1_1Ipv4InterfaceContainer_af501b5fa9d6e1cc316ba259609da608e}
Create an empty \hyperlink{classns3_1_1Ipv4InterfaceContainer}{Ipv4\+Interface\+Container}. 
\begin{DoxyCode}
28 \{
29 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Ipv4\+Interface\+Container@{ns3\+::\+Ipv4\+Interface\+Container}!Add@{Add}}
\index{Add@{Add}!ns3\+::\+Ipv4\+Interface\+Container@{ns3\+::\+Ipv4\+Interface\+Container}}
\subsubsection[{\texorpdfstring{Add(const Ipv4\+Interface\+Container \&other)}{Add(const Ipv4InterfaceContainer &other)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Interface\+Container\+::\+Add (
\begin{DoxyParamCaption}
\item[{const {\bf Ipv4\+Interface\+Container} \&}]{other}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4InterfaceContainer_ae5e7881307c8d49c7606669ded6ac3d6}{}\label{classns3_1_1Ipv4InterfaceContainer_ae5e7881307c8d49c7606669ded6ac3d6}
Concatenate the entries in the other container with ours. 
\begin{DoxyParams}{Parameters}
{\em other} & container \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
33 \{
34   \textcolor{keywordflow}{for} (InterfaceVector::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = other.m\_interfaces.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != other.m\_interfaces.end (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
35     \{
36       \hyperlink{classns3_1_1Ipv4InterfaceContainer_ad24e1d0f593229265cf2a27a06c16329}{m\_interfaces}.push\_back (*\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
37     \}
38 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 1


\index{ns3\+::\+Ipv4\+Interface\+Container@{ns3\+::\+Ipv4\+Interface\+Container}!Add@{Add}}
\index{Add@{Add}!ns3\+::\+Ipv4\+Interface\+Container@{ns3\+::\+Ipv4\+Interface\+Container}}
\subsubsection[{\texorpdfstring{Add(\+Ptr$<$ Ipv4 $>$ ipv4, uint32\+\_\+t interface)}{Add(Ptr< Ipv4 > ipv4, uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Interface\+Container\+::\+Add (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv4} $>$}]{ipv4, }
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4InterfaceContainer_a9e52fccf4def47d4fcaa40d368a560c7}{}\label{classns3_1_1Ipv4InterfaceContainer_a9e52fccf4def47d4fcaa40d368a560c7}
Manually add an entry to the container consisting of the individual parts of an entry std\+::pair.


\begin{DoxyParams}{Parameters}
{\em ipv4} & pointer to \hyperlink{classns3_1_1Ipv4}{Ipv4} object \\
\hline
{\em interface} & interface index of the \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} to add to the container \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
75 \{
76   \hyperlink{classns3_1_1Ipv4InterfaceContainer_ad24e1d0f593229265cf2a27a06c16329}{m\_interfaces}.push\_back (std::make\_pair (ipv4, interface));
77 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Interface\+Container@{ns3\+::\+Ipv4\+Interface\+Container}!Add@{Add}}
\index{Add@{Add}!ns3\+::\+Ipv4\+Interface\+Container@{ns3\+::\+Ipv4\+Interface\+Container}}
\subsubsection[{\texorpdfstring{Add(std\+::pair$<$ Ptr$<$ Ipv4 $>$, uint32\+\_\+t $>$ ip\+Interface\+Pair)}{Add(std::pair< Ptr< Ipv4 >, uint32_t > ipInterfacePair)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Interface\+Container\+::\+Add (
\begin{DoxyParamCaption}
\item[{std\+::pair$<$ {\bf Ptr}$<$ {\bf Ipv4} $>$, uint32\+\_\+t $>$}]{ip\+Interface\+Pair}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4InterfaceContainer_ab19c6d1666a08c6804f4534a2f1d3343}{}\label{classns3_1_1Ipv4InterfaceContainer_ab19c6d1666a08c6804f4534a2f1d3343}
Manually add an entry to the container consisting of a previously composed entry std\+::pair.


\begin{DoxyParams}{Parameters}
{\em ip\+Interface\+Pair} & the pair of a pointer to \hyperlink{classns3_1_1Ipv4}{Ipv4} object and interface index of the \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} to add to the container \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
79 \{
80   \hyperlink{classns3_1_1Ipv4InterfaceContainer_ae5e7881307c8d49c7606669ded6ac3d6}{Add} (a.first, a.second);
81 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Ipv4\+Interface\+Container@{ns3\+::\+Ipv4\+Interface\+Container}!Add@{Add}}
\index{Add@{Add}!ns3\+::\+Ipv4\+Interface\+Container@{ns3\+::\+Ipv4\+Interface\+Container}}
\subsubsection[{\texorpdfstring{Add(std\+::string ipv4\+Name, uint32\+\_\+t interface)}{Add(std::string ipv4Name, uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Interface\+Container\+::\+Add (
\begin{DoxyParamCaption}
\item[{std\+::string}]{ipv4\+Name, }
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4InterfaceContainer_a4102276d0f31b9ad4dd38a43cc88b5dc}{}\label{classns3_1_1Ipv4InterfaceContainer_a4102276d0f31b9ad4dd38a43cc88b5dc}
Manually add an entry to the container consisting of the individual parts of an entry std\+::pair.


\begin{DoxyParams}{Parameters}
{\em ipv4\+Name} & std\+:string referring to the saved name of an \hyperlink{classns3_1_1Ipv4}{Ipv4} \hyperlink{classns3_1_1Object}{Object} that has been previously named using the \hyperlink{classns3_1_1Object}{Object} Name Service. \\
\hline
{\em interface} & interface index of the \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} to add to the container \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
84 \{
85   Ptr<Ipv4> ipv4 = Names::Find<Ipv4> (ipv4Name);
86   \hyperlink{classns3_1_1Ipv4InterfaceContainer_ad24e1d0f593229265cf2a27a06c16329}{m\_interfaces}.push\_back (std::make\_pair (ipv4, interface));
87 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Interface\+Container@{ns3\+::\+Ipv4\+Interface\+Container}!Begin@{Begin}}
\index{Begin@{Begin}!ns3\+::\+Ipv4\+Interface\+Container@{ns3\+::\+Ipv4\+Interface\+Container}}
\subsubsection[{\texorpdfstring{Begin(void) const }{Begin(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Interface\+Container\+::\+Iterator} ns3\+::\+Ipv4\+Interface\+Container\+::\+Begin (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv4InterfaceContainer_a1f39f80de81e0b74362867a8f89264c9}{}\label{classns3_1_1Ipv4InterfaceContainer_a1f39f80de81e0b74362867a8f89264c9}


Get an iterator which refers to the first pair in the container. 

Pairs can be retrieved from the container in two ways. First, directly by an index into the container, and second, using an iterator. This method is used in the iterator method and is typically used in a for-\/loop to run through the pairs


\begin{DoxyCode}
\hyperlink{classns3_1_1Ipv4InterfaceContainer_acedc286abfd3db405dfca5ddd73fd1d7}{Ipv4InterfaceContainer::Iterator} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
\textcolor{keywordflow}{for} (i = container.Begin (); i != container.End (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
  \{
    std::pair<Ptr<Ipv4>, uint32\_t> pair = *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
    method (pair.first, pair.second);  \textcolor{comment}{// use the pair}
  \}
\end{DoxyCode}


\begin{DoxyReturn}{Returns}
an iterator which refers to the first pair in the container. 
\end{DoxyReturn}

\begin{DoxyCode}
42 \{
43   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv4InterfaceContainer_ad24e1d0f593229265cf2a27a06c16329}{m\_interfaces}.begin ();
44 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 3


\index{ns3\+::\+Ipv4\+Interface\+Container@{ns3\+::\+Ipv4\+Interface\+Container}!End@{End}}
\index{End@{End}!ns3\+::\+Ipv4\+Interface\+Container@{ns3\+::\+Ipv4\+Interface\+Container}}
\subsubsection[{\texorpdfstring{End(void) const }{End(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Interface\+Container\+::\+Iterator} ns3\+::\+Ipv4\+Interface\+Container\+::\+End (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv4InterfaceContainer_aa3173d4d097db7ebf17fc1cb84d06596}{}\label{classns3_1_1Ipv4InterfaceContainer_aa3173d4d097db7ebf17fc1cb84d06596}


Get an iterator which indicates past-\/the-\/last \hyperlink{classns3_1_1Node}{Node} in the container. 

Nodes can be retrieved from the container in two ways. First, directly by an index into the container, and second, using an iterator. This method is used in the iterator method and is typically used in a for-\/loop to run through the Nodes


\begin{DoxyCode}
\hyperlink{classns3_1_1NodeContainer_aa1a9f2d2b09bfef7d066d3974bca2cc4}{NodeContainer::Iterator} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
\textcolor{keywordflow}{for} (i = container.Begin (); i != container.End (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
  \{
    std::pair<Ptr<Ipv4>, uint32\_t> pair = *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
    method (pair.first, pair.second);  \textcolor{comment}{// use the pair}
  \}
\end{DoxyCode}


\begin{DoxyReturn}{Returns}
an iterator which indicates an ending condition for a loop. 
\end{DoxyReturn}

\begin{DoxyCode}
48 \{
49   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv4InterfaceContainer_ad24e1d0f593229265cf2a27a06c16329}{m\_interfaces}.end ();
50 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::\+Ipv4\+Interface\+Container@{ns3\+::\+Ipv4\+Interface\+Container}!Get@{Get}}
\index{Get@{Get}!ns3\+::\+Ipv4\+Interface\+Container@{ns3\+::\+Ipv4\+Interface\+Container}}
\subsubsection[{\texorpdfstring{Get(uint32\+\_\+t i) const }{Get(uint32_t i) const }}]{\setlength{\rightskip}{0pt plus 5cm}std\+::pair$<$ {\bf Ptr}$<$ {\bf Ipv4} $>$, uint32\+\_\+t $>$ ns3\+::\+Ipv4\+Interface\+Container\+::\+Get (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv4InterfaceContainer_a6528d70874071a882a3f5068c12dd9ad}{}\label{classns3_1_1Ipv4InterfaceContainer_a6528d70874071a882a3f5068c12dd9ad}
Get the std\+::pair of an Ptr$<$\+Ipv4$>$ and interface stored at the location specified by the index.


\begin{DoxyParams}{Parameters}
{\em i} & the index of the container entry to retrieve. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the std\+::pair of a Ptr$<$\+Ipv4$>$ and an interface index
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The returned Ptr$<$\+Ipv4$>$ cannot be used directly to fetch the \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} using the returned index (the Get\+Interface () method is provided in class \hyperlink{classns3_1_1Ipv4L3Protocol}{Ipv4\+L3\+Protocol}, and not class \hyperlink{classns3_1_1Ipv4}{Ipv4}). An example usage is provided below.
\end{DoxyNote}

\begin{DoxyCode}
\hyperlink{classns3_1_1Ipv4InterfaceContainer_af501b5fa9d6e1cc316ba259609da608e}{Ipv4InterfaceContainer} \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c};
...
std::pair<Ptr<Ipv4>, uint32\_t> returnValue = c.Get (0);
Ptr<Ipv4> ipv4 = returnValue.first;
uint32\_t index = returnValue.second;
Ptr<Ipv4Interface> iface =  ipv4->GetObject<Ipv4L3Protocol> ()->GetInterface (index);
\end{DoxyCode}
 
\begin{DoxyCode}
91 \{
92   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv4InterfaceContainer_ad24e1d0f593229265cf2a27a06c16329}{m\_interfaces}[\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}];
93 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Ipv4\+Interface\+Container@{ns3\+::\+Ipv4\+Interface\+Container}!Get\+Address@{Get\+Address}}
\index{Get\+Address@{Get\+Address}!ns3\+::\+Ipv4\+Interface\+Container@{ns3\+::\+Ipv4\+Interface\+Container}}
\subsubsection[{\texorpdfstring{Get\+Address(uint32\+\_\+t i, uint32\+\_\+t j=0) const }{GetAddress(uint32_t i, uint32_t j=0) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Address} ns3\+::\+Ipv4\+Interface\+Container\+::\+Get\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i, }
\item[{uint32\+\_\+t}]{j = {\ttfamily 0}}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv4InterfaceContainer_ae63208dcd222be986822937ee4aa828c}{}\label{classns3_1_1Ipv4InterfaceContainer_ae63208dcd222be986822937ee4aa828c}

\begin{DoxyParams}{Parameters}
{\em i} & index of ip\+Interface\+Pair in container \\
\hline
{\em j} & interface address index (if interface has multiple addresses) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the I\+Pv4 address of the j\textquotesingle{}th address of the interface corresponding to index i.
\end{DoxyReturn}
If the second parameter is omitted, the zeroth indexed address of the interface is returned. Unless IP aliasing is being used on the interface, the second parameter may typically be omitted. 
\begin{DoxyCode}
60 \{
61   Ptr<Ipv4> ipv4 = \hyperlink{classns3_1_1Ipv4InterfaceContainer_ad24e1d0f593229265cf2a27a06c16329}{m\_interfaces}[\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}].first;
62   uint32\_t \textcolor{keyword}{interface }= \hyperlink{classns3_1_1Ipv4InterfaceContainer_ad24e1d0f593229265cf2a27a06c16329}{m\_interfaces}[\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}].second;
63   \textcolor{keywordflow}{return} ipv4->GetAddress (interface, j).GetLocal ();
64 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::\+Ipv4\+Interface\+Container@{ns3\+::\+Ipv4\+Interface\+Container}!GetN@{GetN}}
\index{GetN@{GetN}!ns3\+::\+Ipv4\+Interface\+Container@{ns3\+::\+Ipv4\+Interface\+Container}}
\subsubsection[{\texorpdfstring{Get\+N(void) const }{GetN(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Ipv4\+Interface\+Container\+::\+GetN (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv4InterfaceContainer_a8d565289d84cd90ef806d0f86e6235f9}{}\label{classns3_1_1Ipv4InterfaceContainer_a8d565289d84cd90ef806d0f86e6235f9}
\begin{DoxyReturn}{Returns}
the number of Ptr$<$\+Ipv4$>$ and interface pairs stored in this \hyperlink{classns3_1_1Ipv4InterfaceContainer}{Ipv4\+Interface\+Container}.
\end{DoxyReturn}
Pairs can be retrieved from the container in two ways. First, directly by an index into the container, and second, using an iterator. This method is used in the direct method and is typically used to define an ending condition in a for-\/loop that runs through the stored Nodes


\begin{DoxyCode}
uint32\_t nNodes = container.GetN ();
\textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0 \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < nNodes; ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
  \{
    std::pair<Ptr<Ipv4>, uint32\_t> pair = container.Get (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
    method (pair.first, pair.second);  \textcolor{comment}{// use the pair}
  \}
\end{DoxyCode}


\begin{DoxyReturn}{Returns}
the number of \hyperlink{classns3_1_1Ptr}{Ptr$<$\+Node$>$} stored in this container. 
\end{DoxyReturn}

\begin{DoxyCode}
54 \{
55   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv4InterfaceContainer_ad24e1d0f593229265cf2a27a06c16329}{m\_interfaces}.size ();
56 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Ipv4\+Interface\+Container@{ns3\+::\+Ipv4\+Interface\+Container}!Set\+Metric@{Set\+Metric}}
\index{Set\+Metric@{Set\+Metric}!ns3\+::\+Ipv4\+Interface\+Container@{ns3\+::\+Ipv4\+Interface\+Container}}
\subsubsection[{\texorpdfstring{Set\+Metric(uint32\+\_\+t i, uint16\+\_\+t metric)}{SetMetric(uint32_t i, uint16_t metric)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Interface\+Container\+::\+Set\+Metric (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i, }
\item[{uint16\+\_\+t}]{metric}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4InterfaceContainer_a94248347eb8df7826f8576234fc2d1be}{}\label{classns3_1_1Ipv4InterfaceContainer_a94248347eb8df7826f8576234fc2d1be}


Set a metric for the given interface. 


\begin{DoxyParams}{Parameters}
{\em i} & Interface index \\
\hline
{\em metric} & the interface metric \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
68 \{
69   Ptr<Ipv4> ipv4 = \hyperlink{classns3_1_1Ipv4InterfaceContainer_ad24e1d0f593229265cf2a27a06c16329}{m\_interfaces}[\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}].first;
70   uint32\_t \textcolor{keyword}{interface }= \hyperlink{classns3_1_1Ipv4InterfaceContainer_ad24e1d0f593229265cf2a27a06c16329}{m\_interfaces}[\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}].second;
71   ipv4->SetMetric (interface, metric);
72 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{ns3\+::\+Ipv4\+Interface\+Container@{ns3\+::\+Ipv4\+Interface\+Container}!m\+\_\+interfaces@{m\+\_\+interfaces}}
\index{m\+\_\+interfaces@{m\+\_\+interfaces}!ns3\+::\+Ipv4\+Interface\+Container@{ns3\+::\+Ipv4\+Interface\+Container}}
\subsubsection[{\texorpdfstring{m\+\_\+interfaces}{m_interfaces}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Interface\+Vector} ns3\+::\+Ipv4\+Interface\+Container\+::m\+\_\+interfaces\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4InterfaceContainer_ad24e1d0f593229265cf2a27a06c16329}{}\label{classns3_1_1Ipv4InterfaceContainer_ad24e1d0f593229265cf2a27a06c16329}


List of I\+Pv4 stack and interfaces index. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/helper/\hyperlink{ipv4-interface-container_8h}{ipv4-\/interface-\/container.\+h}\item 
internet/helper/\hyperlink{ipv4-interface-container_8cc}{ipv4-\/interface-\/container.\+cc}\end{DoxyCompactItemize}
