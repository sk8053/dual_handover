\hypertarget{classns3_1_1WimaxMacToMacHeader}{}\section{ns3\+:\+:Wimax\+Mac\+To\+Mac\+Header Class Reference}
\label{classns3_1_1WimaxMacToMacHeader}\index{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header@{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header}}


this class implements the mac to mac header needed to dump a wimax pcap file The header format was reverse-\/engineered by looking at existing live pcap traces which could be opened with wireshark i.\+e., we have no idea where this is coming from.  




{\ttfamily \#include $<$wimax-\/mac-\/to-\/mac-\/header.\+h$>$}



Inheritance diagram for ns3\+:\+:Wimax\+Mac\+To\+Mac\+Header\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Wimax\+Mac\+To\+Mac\+Header\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1WimaxMacToMacHeader_aad8f5f52f80eb3f656a171a0b92b4f94}{Wimax\+Mac\+To\+Mac\+Header} ()
\item 
\hyperlink{classns3_1_1WimaxMacToMacHeader_a5adf9a24a13e6c00af927c055c8c74e5}{$\sim$\+Wimax\+Mac\+To\+Mac\+Header} ()
\item 
\hyperlink{classns3_1_1WimaxMacToMacHeader_ac0add4d394a28e8558b59733df50b982}{Wimax\+Mac\+To\+Mac\+Header} (uint32\+\_\+t len)
\item 
virtual \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1WimaxMacToMacHeader_aa694f523db793ddf8ade34e3a3cdfdfb}{Get\+Instance\+Type\+Id} (void) const 
\item 
uint32\+\_\+t \hyperlink{classns3_1_1WimaxMacToMacHeader_a7a435e2e886d5d6fe2f4efebdf6c3ce8}{Get\+Serialized\+Size} (void) const 
\item 
void \hyperlink{classns3_1_1WimaxMacToMacHeader_a39eb561e07f3f3e1596bf7a985c16332}{Serialize} (\hyperlink{classns3_1_1Buffer_1_1Iterator}{Buffer\+::\+Iterator} start) const 
\item 
uint32\+\_\+t \hyperlink{classns3_1_1WimaxMacToMacHeader_a002bae0fe12f8363d3d06e286e802913}{Deserialize} (\hyperlink{classns3_1_1Buffer_1_1Iterator}{Buffer\+::\+Iterator} start)
\item 
uint8\+\_\+t \hyperlink{classns3_1_1WimaxMacToMacHeader_a1f3d74adc741d8e938b7c4a51ea3eb2b}{Get\+Size\+Of\+Len} (void) const 
\item 
virtual void \hyperlink{classns3_1_1WimaxMacToMacHeader_aa9e76b23c93710be1cba9f5a4777894a}{Print} (std\+::ostream \&os) const 
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1WimaxMacToMacHeader_ad605a91022955c77e062a52cd0509b75}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
uint32\+\_\+t \hyperlink{classns3_1_1WimaxMacToMacHeader_ae00de1c6c413ab383c21d1386799ab1c}{m\+\_\+len}
\begin{DoxyCompactList}\small\item\em length \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
this class implements the mac to mac header needed to dump a wimax pcap file The header format was reverse-\/engineered by looking at existing live pcap traces which could be opened with wireshark i.\+e., we have no idea where this is coming from. 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header@{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header}!Wimax\+Mac\+To\+Mac\+Header@{Wimax\+Mac\+To\+Mac\+Header}}
\index{Wimax\+Mac\+To\+Mac\+Header@{Wimax\+Mac\+To\+Mac\+Header}!ns3\+::\+Wimax\+Mac\+To\+Mac\+Header@{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header}}
\subsubsection[{\texorpdfstring{Wimax\+Mac\+To\+Mac\+Header()}{WimaxMacToMacHeader()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Wimax\+Mac\+To\+Mac\+Header\+::\+Wimax\+Mac\+To\+Mac\+Header (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WimaxMacToMacHeader_aad8f5f52f80eb3f656a171a0b92b4f94}{}\label{classns3_1_1WimaxMacToMacHeader_aad8f5f52f80eb3f656a171a0b92b4f94}

\begin{DoxyCode}
30   : \hyperlink{classns3_1_1WimaxMacToMacHeader_ae00de1c6c413ab383c21d1386799ab1c}{m\_len} (0)
31 \{
32 \}
\end{DoxyCode}
\index{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header@{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header}!````~Wimax\+Mac\+To\+Mac\+Header@{$\sim$\+Wimax\+Mac\+To\+Mac\+Header}}
\index{````~Wimax\+Mac\+To\+Mac\+Header@{$\sim$\+Wimax\+Mac\+To\+Mac\+Header}!ns3\+::\+Wimax\+Mac\+To\+Mac\+Header@{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header}}
\subsubsection[{\texorpdfstring{$\sim$\+Wimax\+Mac\+To\+Mac\+Header()}{~WimaxMacToMacHeader()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Wimax\+Mac\+To\+Mac\+Header\+::$\sim$\+Wimax\+Mac\+To\+Mac\+Header (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WimaxMacToMacHeader_a5adf9a24a13e6c00af927c055c8c74e5}{}\label{classns3_1_1WimaxMacToMacHeader_a5adf9a24a13e6c00af927c055c8c74e5}

\begin{DoxyCode}
40 \{
41 \}
\end{DoxyCode}
\index{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header@{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header}!Wimax\+Mac\+To\+Mac\+Header@{Wimax\+Mac\+To\+Mac\+Header}}
\index{Wimax\+Mac\+To\+Mac\+Header@{Wimax\+Mac\+To\+Mac\+Header}!ns3\+::\+Wimax\+Mac\+To\+Mac\+Header@{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header}}
\subsubsection[{\texorpdfstring{Wimax\+Mac\+To\+Mac\+Header(uint32\+\_\+t len)}{WimaxMacToMacHeader(uint32_t len)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Wimax\+Mac\+To\+Mac\+Header\+::\+Wimax\+Mac\+To\+Mac\+Header (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{len}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WimaxMacToMacHeader_ac0add4d394a28e8558b59733df50b982}{}\label{classns3_1_1WimaxMacToMacHeader_ac0add4d394a28e8558b59733df50b982}
Constructor


\begin{DoxyParams}{Parameters}
{\em len} & length \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
35   : \hyperlink{classns3_1_1WimaxMacToMacHeader_ae00de1c6c413ab383c21d1386799ab1c}{m\_len} (len)
36 \{
37 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header@{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header}!Deserialize@{Deserialize}}
\index{Deserialize@{Deserialize}!ns3\+::\+Wimax\+Mac\+To\+Mac\+Header@{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header}}
\subsubsection[{\texorpdfstring{Deserialize(\+Buffer\+::\+Iterator start)}{Deserialize(Buffer::Iterator start)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Wimax\+Mac\+To\+Mac\+Header\+::\+Deserialize (
\begin{DoxyParamCaption}
\item[{{\bf Buffer\+::\+Iterator}}]{start}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WimaxMacToMacHeader_a002bae0fe12f8363d3d06e286e802913}{}\label{classns3_1_1WimaxMacToMacHeader_a002bae0fe12f8363d3d06e286e802913}

\begin{DoxyParams}{Parameters}
{\em start} & an iterator which points to where the header should read from. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of bytes read.
\end{DoxyReturn}
This method is used by \hyperlink{classns3_1_1Packet_a0961eccf975d75f902d40956c93ba63e}{Packet\+::\+Remove\+Header} to re-\/create a header from the byte buffer of a packet. The data read is expected to match bit-\/for-\/bit the representation of this header in real networks.

Note that data is not actually removed from the buffer to which the iterator points. Both \hyperlink{classns3_1_1Packet_a0961eccf975d75f902d40956c93ba63e}{Packet\+::\+Remove\+Header()} and \hyperlink{classns3_1_1Packet_aadc63487bea70945c418f4c3e9b81964}{Packet\+::\+Peek\+Header()} call \hyperlink{classns3_1_1WimaxMacToMacHeader_a002bae0fe12f8363d3d06e286e802913}{Deserialize()}, but only the Remove\+Header() has additional statements to remove the header bytes from the underlying buffer and associated metadata. 

Implements \hyperlink{classns3_1_1Header_a78be9400bb66b2a8543606f395ef5396}{ns3\+::\+Header}.


\begin{DoxyCode}
141 \{
142   \textcolor{comment}{// not needed here}
143   \textcolor{keywordflow}{return} 20;
144 \}
\end{DoxyCode}
\index{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header@{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header}!Get\+Instance\+Type\+Id@{Get\+Instance\+Type\+Id}}
\index{Get\+Instance\+Type\+Id@{Get\+Instance\+Type\+Id}!ns3\+::\+Wimax\+Mac\+To\+Mac\+Header@{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header}}
\subsubsection[{\texorpdfstring{Get\+Instance\+Type\+Id(void) const }{GetInstanceTypeId(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Wimax\+Mac\+To\+Mac\+Header\+::\+Get\+Instance\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WimaxMacToMacHeader_aa694f523db793ddf8ade34e3a3cdfdfb}{}\label{classns3_1_1WimaxMacToMacHeader_aa694f523db793ddf8ade34e3a3cdfdfb}
Get the most derived \hyperlink{classns3_1_1TypeId}{Type\+Id} for this \hyperlink{classns3_1_1Object}{Object}.

This method is typically implemented by \hyperlink{classns3_1_1Object_a51e5994fa4b6eae32d719ad69f8fcbf5}{ns3\+::\+Object\+::\+Get\+Instance\+Type\+Id} but some classes which derive from \hyperlink{classns3_1_1ObjectBase}{ns3\+::\+Object\+Base} directly have to implement it themselves.

\begin{DoxyReturn}{Returns}
The \hyperlink{classns3_1_1TypeId}{Type\+Id} associated to the most-\/derived type of this instance. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1ObjectBase_abe5b43a6f5b99a92a4c3122db31f06fb}{ns3\+::\+Object\+Base}.


\begin{DoxyCode}
59 \{
60   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1WimaxMacToMacHeader_ad605a91022955c77e062a52cd0509b75}{GetTypeId} ();
61 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header@{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header}!Get\+Serialized\+Size@{Get\+Serialized\+Size}}
\index{Get\+Serialized\+Size@{Get\+Serialized\+Size}!ns3\+::\+Wimax\+Mac\+To\+Mac\+Header@{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header}}
\subsubsection[{\texorpdfstring{Get\+Serialized\+Size(void) const }{GetSerializedSize(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Wimax\+Mac\+To\+Mac\+Header\+::\+Get\+Serialized\+Size (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WimaxMacToMacHeader_a7a435e2e886d5d6fe2f4efebdf6c3ce8}{}\label{classns3_1_1WimaxMacToMacHeader_a7a435e2e886d5d6fe2f4efebdf6c3ce8}
\begin{DoxyReturn}{Returns}
the expected size of the header.
\end{DoxyReturn}
This method is used by \hyperlink{classns3_1_1Packet_a465108c595a0bc592095cbcab1832ed8}{Packet\+::\+Add\+Header} to store a header into the byte buffer of a packet. This method should return the number of bytes which are needed to store the full header data by Serialize. 

Implements \hyperlink{classns3_1_1Header_a6ef0497eabc1b1fb0ad42738eb73f934}{ns3\+::\+Header}.


\begin{DoxyCode}
83 \{
84   uint8\_t sizeOfLen = \hyperlink{classns3_1_1WimaxMacToMacHeader_a1f3d74adc741d8e938b7c4a51ea3eb2b}{GetSizeOfLen} ();
85   \textcolor{keywordflow}{if} (sizeOfLen==1)
86     \{
87       \textcolor{keywordflow}{return} 20;
88     \}
89   \textcolor{keywordflow}{else}
90     \{
91       \textcolor{keywordflow}{return} 20 + sizeOfLen -1;
92     \}
93   \textcolor{comment}{//return 19+sizeOfLen;}
94 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header@{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header}!Get\+Size\+Of\+Len@{Get\+Size\+Of\+Len}}
\index{Get\+Size\+Of\+Len@{Get\+Size\+Of\+Len}!ns3\+::\+Wimax\+Mac\+To\+Mac\+Header@{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header}}
\subsubsection[{\texorpdfstring{Get\+Size\+Of\+Len(void) const }{GetSizeOfLen(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::\+Wimax\+Mac\+To\+Mac\+Header\+::\+Get\+Size\+Of\+Len (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1WimaxMacToMacHeader_a1f3d74adc741d8e938b7c4a51ea3eb2b}{}\label{classns3_1_1WimaxMacToMacHeader_a1f3d74adc741d8e938b7c4a51ea3eb2b}
Get size of length field \begin{DoxyReturn}{Returns}
the size of length field 
\end{DoxyReturn}

\begin{DoxyCode}
65 \{
66   uint8\_t sizeOfLen = 1;
67 
68   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1WimaxMacToMacHeader_ae00de1c6c413ab383c21d1386799ab1c}{m\_len} > 127)
69     \{
70       sizeOfLen = 2;
71       uint64\_t testValue = 0xFF;
72       \textcolor{keywordflow}{while} (\hyperlink{classns3_1_1WimaxMacToMacHeader_ae00de1c6c413ab383c21d1386799ab1c}{m\_len} > testValue)
73         \{
74           sizeOfLen++;
75           testValue *= 0xFF;
76         \}
77     \}
78   \textcolor{keywordflow}{return} sizeOfLen;
79 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header@{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Wimax\+Mac\+To\+Mac\+Header@{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Wimax\+Mac\+To\+Mac\+Header\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1WimaxMacToMacHeader_ad605a91022955c77e062a52cd0509b75}{}\label{classns3_1_1WimaxMacToMacHeader_ad605a91022955c77e062a52cd0509b75}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
47 \{
48   \textcolor{keyword}{static} TypeId tid =
49     TypeId (\textcolor{stringliteral}{"ns3::WimaxMacToMacHeader"})
50     .SetParent<Header> ()
51     .SetGroupName(\textcolor{stringliteral}{"Wimax"})
52     .AddConstructor<\hyperlink{classns3_1_1WimaxMacToMacHeader_aad8f5f52f80eb3f656a171a0b92b4f94}{WimaxMacToMacHeader}> ()
53     ;
54   \textcolor{keywordflow}{return} tid;
55 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5




Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header@{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header}!Print@{Print}}
\index{Print@{Print}!ns3\+::\+Wimax\+Mac\+To\+Mac\+Header@{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header}}
\subsubsection[{\texorpdfstring{Print(std\+::ostream \&os) const }{Print(std::ostream &os) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Wimax\+Mac\+To\+Mac\+Header\+::\+Print (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WimaxMacToMacHeader_aa9e76b23c93710be1cba9f5a4777894a}{}\label{classns3_1_1WimaxMacToMacHeader_aa9e76b23c93710be1cba9f5a4777894a}

\begin{DoxyParams}{Parameters}
{\em os} & output stream This method is used by \hyperlink{classns3_1_1Packet_aa34058a5cdbf94673531f8c4001ab227}{Packet\+::\+Print} to print the content of a header as ascii data to a c++ output stream. Although the header is free to format its output as it wishes, it is recommended to follow a few rules to integrate with the packet pretty printer\+: start with flags, small field values located between a pair of parens. Values should be separated by whitespace. Follow the parens with the important fields, separated by whitespace. i.\+e.\+: (field1 val1 field2 val2 field3 val3) field4 val4 field5 val5 \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Header_a2ce1df7579b2ade7bc7302357feac77a}{ns3\+::\+Header}.


\begin{DoxyCode}
148 \{
149 \}
\end{DoxyCode}
\index{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header@{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header}!Serialize@{Serialize}}
\index{Serialize@{Serialize}!ns3\+::\+Wimax\+Mac\+To\+Mac\+Header@{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header}}
\subsubsection[{\texorpdfstring{Serialize(\+Buffer\+::\+Iterator start) const }{Serialize(Buffer::Iterator start) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Wimax\+Mac\+To\+Mac\+Header\+::\+Serialize (
\begin{DoxyParamCaption}
\item[{{\bf Buffer\+::\+Iterator}}]{start}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WimaxMacToMacHeader_a39eb561e07f3f3e1596bf7a985c16332}{}\label{classns3_1_1WimaxMacToMacHeader_a39eb561e07f3f3e1596bf7a985c16332}

\begin{DoxyParams}{Parameters}
{\em start} & an iterator which points to where the header should be written.\\
\hline
\end{DoxyParams}
This method is used by \hyperlink{classns3_1_1Packet_a465108c595a0bc592095cbcab1832ed8}{Packet\+::\+Add\+Header} to store a header into the byte buffer of a packet. The data written is expected to match bit-\/for-\/bit the representation of this header in a real network. 

Implements \hyperlink{classns3_1_1Header_afb61f1aac69ff8349a6bfe521fab5404}{ns3\+::\+Header}.


\begin{DoxyCode}
98 \{
99   \textcolor{comment}{// The following header encoding was reverse-engineered by looking}
100   \textcolor{comment}{// at existing live pcap traces which could be opened with wireshark}
101   \textcolor{comment}{// i.e., we have no idea where this is coming from.}
102   \textcolor{comment}{//}
103   \textcolor{comment}{// 6 zeros for mac destination}
104   \textcolor{comment}{// 6 zeros for mac source}
105   \textcolor{comment}{// 2 bytes for length/type: 0x08f0}
106   \textcolor{comment}{// 2 bytes for sequence number: 0x0001}
107   \textcolor{comment}{// 2 bytes for number of tlvs: 0x0001}
108   \textcolor{comment}{// 1 byte for type of first tlv: 0x09}
109   \textcolor{comment}{// 1 byte to indicate the length of the length field of the tlv : 0x80 | 0x04}
110   \textcolor{comment}{// n bytes to indicate the size of the packet (network order)}
111   \textcolor{comment}{// n bytes for the packet data}
112 
113   uint8\_t \hyperlink{data-calculator_8cc_a548c77babcdf18ce7b6b96e73fb912cd}{zero} = 0;
114 
115 
116   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < 12; j++)
117     \{
118       \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}.WriteU8 (zero);
119     \}
120   \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}.WriteU16 (0xf008); \textcolor{comment}{// eth length/type}
121   \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}.WriteU16 (0x0100); \textcolor{comment}{// sequence number}
122   \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}.WriteU16 (0x0100); \textcolor{comment}{// number of tlvs}
123   \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}.WriteU8 (0x09); \textcolor{comment}{// type of first tlv}
124   uint8\_t lenSize = \hyperlink{classns3_1_1WimaxMacToMacHeader_a1f3d74adc741d8e938b7c4a51ea3eb2b}{GetSizeOfLen} ();
125   \textcolor{keywordflow}{if} (lenSize == 1)
126     \{
127       \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}.WriteU8 (\hyperlink{classns3_1_1WimaxMacToMacHeader_ae00de1c6c413ab383c21d1386799ab1c}{m\_len});
128     \}
129   \textcolor{keywordflow}{else}
130     \{
131       \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}.WriteU8 ((lenSize-1) | 0x80);
132       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < lenSize - 1; j++)
133         \{
134           \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}.WriteU8 ((uint8\_t)(\hyperlink{classns3_1_1WimaxMacToMacHeader_ae00de1c6c413ab383c21d1386799ab1c}{m\_len} >> ((lenSize - 1 - 1 - j) * 8)));
135         \}
136     \}
137 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7




\subsection{Member Data Documentation}
\index{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header@{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header}!m\+\_\+len@{m\+\_\+len}}
\index{m\+\_\+len@{m\+\_\+len}!ns3\+::\+Wimax\+Mac\+To\+Mac\+Header@{ns3\+::\+Wimax\+Mac\+To\+Mac\+Header}}
\subsubsection[{\texorpdfstring{m\+\_\+len}{m_len}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Wimax\+Mac\+To\+Mac\+Header\+::m\+\_\+len\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WimaxMacToMacHeader_ae00de1c6c413ab383c21d1386799ab1c}{}\label{classns3_1_1WimaxMacToMacHeader_ae00de1c6c413ab383c21d1386799ab1c}


length 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
wimax/model/\hyperlink{wimax-mac-to-mac-header_8h}{wimax-\/mac-\/to-\/mac-\/header.\+h}\item 
wimax/model/\hyperlink{wimax-mac-to-mac-header_8cc}{wimax-\/mac-\/to-\/mac-\/header.\+cc}\end{DoxyCompactItemize}
