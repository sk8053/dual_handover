\hypertarget{classns3_1_1MeshPointDevice}{}\section{ns3\+:\+:Mesh\+Point\+Device Class Reference}
\label{classns3_1_1MeshPointDevice}\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}


Virtual net device modeling mesh point.  




{\ttfamily \#include $<$mesh-\/point-\/device.\+h$>$}



Inheritance diagram for ns3\+:\+:Mesh\+Point\+Device\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Mesh\+Point\+Device\+:
% FIG 1
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structns3_1_1MeshPointDevice_1_1Statistics}{Statistics}
\begin{DoxyCompactList}\small\item\em statistics counters \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1MeshPointDevice_a8f30cce92eb76c9caf89ca44c6fbad4b}{Mesh\+Point\+Device} ()
\begin{DoxyCompactList}\small\item\em C-\/tor create empty (without interfaces and protocols) mesh point. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1MeshPointDevice_a8f93896ef5c3a846905fa529534f7d68}{$\sim$\+Mesh\+Point\+Device} ()
\begin{DoxyCompactList}\small\item\em D-\/tor. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1MeshPointDevice_a5c488f7ac1f53721cc782840036fca5a}{Set\+If\+Index} (const uint32\+\_\+t index)
\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1MeshPointDevice_af9f6b14ebf81365ca9162712eb232a4c}{Get\+If\+Index} () const 
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Channel}{Channel} $>$ \hyperlink{classns3_1_1MeshPointDevice_a3a6b755ff27de635152d55191db0fa60}{Get\+Channel} () const 
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1MeshPointDevice_a4b81948cadc3648639b306149221a4c5}{Get\+Address} () const 
\item 
virtual void \hyperlink{classns3_1_1MeshPointDevice_ad15af2645cde05de3d91aaacd77849bd}{Set\+Address} (\hyperlink{classns3_1_1Address}{Address} a)
\item 
virtual bool \hyperlink{classns3_1_1MeshPointDevice_a55081bcaa93f7dabff588ab6602388c6}{Set\+Mtu} (const uint16\+\_\+t mtu)
\item 
virtual uint16\+\_\+t \hyperlink{classns3_1_1MeshPointDevice_a49c4b789a364ce823accd6a28e4b38be}{Get\+Mtu} () const 
\item 
virtual bool \hyperlink{classns3_1_1MeshPointDevice_a17b8bff37f427361a5f197601a65c0ef}{Is\+Link\+Up} () const 
\item 
virtual void \hyperlink{classns3_1_1MeshPointDevice_aee3bb56e67a9d6eaaba98400cf7b8bb3}{Add\+Link\+Change\+Callback} (\hyperlink{classns3_1_1Callback}{Callback}$<$ void $>$ callback)
\item 
virtual bool \hyperlink{classns3_1_1MeshPointDevice_a2a32c8d877db9e2f274737e953e2f98a}{Is\+Broadcast} () const 
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1MeshPointDevice_a08f693b1e5ff2a53aa492b5f43f92af0}{Get\+Broadcast} () const 
\item 
virtual bool \hyperlink{classns3_1_1MeshPointDevice_af2d877953e96024612cf665780a2422b}{Is\+Multicast} () const 
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1MeshPointDevice_a409a07386a7a32cd52c215df46abea1b}{Get\+Multicast} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} multicast\+Group) const 
\begin{DoxyCompactList}\small\item\em Make and return a M\+AC multicast address using the provided multicast group. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1MeshPointDevice_aea8b732f32d3dd61ffd355e8bc479159}{Is\+Point\+To\+Point} () const 
\begin{DoxyCompactList}\small\item\em Return true if the net device is on a point-\/to-\/point link. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1MeshPointDevice_a9c85129d18c5524c7a96ce33c13836e7}{Is\+Bridge} () const 
\begin{DoxyCompactList}\small\item\em Return true if the net device is acting as a bridge. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1MeshPointDevice_aecb87304750f0d4e639907326e6681f0}{Send} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, const \hyperlink{classns3_1_1Address}{Address} \&dest, uint16\+\_\+t protocol\+Number)
\item 
virtual bool \hyperlink{classns3_1_1MeshPointDevice_ac82744797c666f7f55edbcfd8dcf27fb}{Send\+From} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, const \hyperlink{classns3_1_1Address}{Address} \&source, const \hyperlink{classns3_1_1Address}{Address} \&dest, uint16\+\_\+t protocol\+Number)
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1MeshPointDevice_a77df4aa2db40d523b33037e8a00f7d70}{Get\+Node} () const 
\item 
virtual void \hyperlink{classns3_1_1MeshPointDevice_ac63e807b1f104982dee77f323f75e69a}{Set\+Node} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node)
\item 
virtual bool \hyperlink{classns3_1_1MeshPointDevice_afda6456377cc5a4215384a320f1304d7}{Needs\+Arp} () const 
\item 
virtual void \hyperlink{classns3_1_1MeshPointDevice_ab5fefff52512e73365f2ddb8f409cf3c}{Set\+Receive\+Callback} (\hyperlink{classns3_1_1NetDevice_ad5e5e1ca187472bc2ba99575d8def568}{Net\+Device\+::\+Receive\+Callback} cb)
\item 
virtual void \hyperlink{classns3_1_1MeshPointDevice_a3ca31894714a71736a7bfd041da60a95}{Set\+Promisc\+Receive\+Callback} (\hyperlink{classns3_1_1NetDevice_a427225795919f26c414bee2ea3f31ed2}{Net\+Device\+::\+Promisc\+Receive\+Callback} cb)
\item 
virtual bool \hyperlink{classns3_1_1MeshPointDevice_ade4673786f2f0eff1b0f1c11573f97e9}{Supports\+Send\+From} () const 
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1MeshPointDevice_a0aca6b73801fffd0ca00661a8dfbda7b}{Get\+Multicast} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} addr) const 
\begin{DoxyCompactList}\small\item\em Get the M\+AC multicast address corresponding to the I\+Pv6 address provided. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1MeshPointDevice_a6a5f293afb71ae4b58d523abccb3229b}{Do\+Dispose} ()
\end{DoxyCompactItemize}
\begin{Indent}{\bf Interfaces}\par
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classns3_1_1MeshPointDevice_a0001ebec0a10fc9cf05dd6da958a7e98}{Add\+Interface} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ \hyperlink{visualizer-ideas_8txt_a21ff1c530daf8435e00048b7fc2c58e3}{port})
\begin{DoxyCompactList}\small\item\em Attach new interface to the station. Interface must support 48-\/bit M\+AC address and Send\+From method. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1MeshPointDevice_ada5a23b0bdd27cbf6acfdc987d4195d3}{Get\+N\+Interfaces} () const 
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ \hyperlink{classns3_1_1MeshPointDevice_a713a8775a919a65821d588e22d3a69dd}{Get\+Interface} (uint32\+\_\+t id) const 
\item 
std\+::vector$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ $>$ \hyperlink{classns3_1_1MeshPointDevice_ab4c61357a8795c37dd042c560cd12b8f}{Get\+Interfaces} () const 
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf Protocols}\par
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classns3_1_1MeshPointDevice_a2f487dde5dd7b11b13ad8617c7172d16}{Set\+Routing\+Protocol} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1MeshL2RoutingProtocol}{Mesh\+L2\+Routing\+Protocol} $>$ protocol)
\begin{DoxyCompactList}\small\item\em Register routing protocol to be used. Protocol must be already installed on this mesh point. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1MeshL2RoutingProtocol}{Mesh\+L2\+Routing\+Protocol} $>$ \hyperlink{classns3_1_1MeshPointDevice_aefd9678ce885b9dbc7b1aa099e4ebdbe}{Get\+Routing\+Protocol} () const 
\begin{DoxyCompactList}\small\item\em Access current routing protocol. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf Statistics}\par
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classns3_1_1MeshPointDevice_a1abd3eaf68b1aa06a337dba8bc0bf4fa}{Report} (std\+::ostream \&os) const 
\begin{DoxyCompactList}\small\item\em Print statistics counters. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1MeshPointDevice_ae4dc4d2e337fb3a323dd708d184bbd7f}{Reset\+Stats} ()
\begin{DoxyCompactList}\small\item\em Reset statistics counters. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1MeshPointDevice_a9705d0ab147e330bb3eeafdfd844f65b}{Get\+Type\+Id} ()
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Object}{Object} type ID for N\+S3 object system. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classns3_1_1MeshPointDevice_a4d34699068f61ebcbb610c650b28af6b}{Receive\+From\+Device} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, uint16\+\_\+t protocol, \hyperlink{classns3_1_1Address}{Address} const \&source, \hyperlink{classns3_1_1Address}{Address} const \&destination, \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2}{Packet\+Type} packet\+Type)
\begin{DoxyCompactList}\small\item\em Receive packet from interface. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1MeshPointDevice_a8c13c74a516103913d7e852159e47d7d}{Forward} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ incoming\+Port, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, uint16\+\_\+t protocol, const \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} src, const \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} dst)
\begin{DoxyCompactList}\small\item\em Forward packet down to interfaces. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1MeshPointDevice_a01489a62c62337339cf7dc8654849964}{Do\+Send} (bool success, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} src, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} dst, uint16\+\_\+t protocol, uint32\+\_\+t iface)
\begin{DoxyCompactList}\small\item\em Response callback for L2 routing protocol. This will be executed when routing information is ready. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1NetDevice_ad5e5e1ca187472bc2ba99575d8def568}{Net\+Device\+::\+Receive\+Callback} \hyperlink{classns3_1_1MeshPointDevice_a7655ae549d9f2faf860b4051259c6509}{m\+\_\+rx\+Callback}
\begin{DoxyCompactList}\small\item\em Receive action. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1NetDevice_a427225795919f26c414bee2ea3f31ed2}{Net\+Device\+::\+Promisc\+Receive\+Callback} \hyperlink{classns3_1_1MeshPointDevice_a9d8b17d5fc37167fea51c64d21c4f7eb}{m\+\_\+promisc\+Rx\+Callback}
\begin{DoxyCompactList}\small\item\em Promisc receive action. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} \hyperlink{classns3_1_1MeshPointDevice_abdd42cdf967d3b75cc32e20f74e10c51}{m\+\_\+address}
\begin{DoxyCompactList}\small\item\em Mesh point M\+AC address, supposed to be the address of the first added interface. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1MeshPointDevice_a2da4f2175aa00207f0acd0712f815796}{m\+\_\+node}
\begin{DoxyCompactList}\small\item\em Parent node. \end{DoxyCompactList}\item 
std\+::vector$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ $>$ \hyperlink{classns3_1_1MeshPointDevice_a651ebd5660f380c261cd9a055a95805d}{m\+\_\+ifaces}
\begin{DoxyCompactList}\small\item\em List of interfaces. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1MeshPointDevice_a0d5bbbd2c3930407c50757ba70ef71a7}{m\+\_\+if\+Index}
\begin{DoxyCompactList}\small\item\em If index. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1MeshPointDevice_a27a3f3299a55f394947f9bf8dea628d4}{m\+\_\+mtu}
\begin{DoxyCompactList}\small\item\em M\+TU in bytes. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1BridgeChannel}{Bridge\+Channel} $>$ \hyperlink{classns3_1_1MeshPointDevice_a56185011f8d2654cf842a6273e9e398e}{m\+\_\+channel}
\begin{DoxyCompactList}\small\item\em Virtual channel for upper layers. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1MeshL2RoutingProtocol}{Mesh\+L2\+Routing\+Protocol} $>$ \hyperlink{classns3_1_1MeshPointDevice_ac704fc10d4ed26d009f8bbfe71049d45}{m\+\_\+routing\+Protocol}
\begin{DoxyCompactList}\small\item\em Current routing protocol, used mainly by Get\+Routing\+Protocol. \end{DoxyCompactList}\item 
\hyperlink{structns3_1_1MeshPointDevice_1_1Statistics}{Statistics} \hyperlink{classns3_1_1MeshPointDevice_aa10107ad81c4b24d391dcd8520152bf8}{m\+\_\+rx\+Stats}
\begin{DoxyCompactList}\small\item\em Counters. \end{DoxyCompactList}\item 
\hyperlink{structns3_1_1MeshPointDevice_1_1Statistics}{Statistics} \hyperlink{classns3_1_1MeshPointDevice_abbd06f2b215c772004661d6bdb156a31}{m\+\_\+tx\+Stats}
\begin{DoxyCompactList}\small\item\em transmit statistics \end{DoxyCompactList}\item 
\hyperlink{structns3_1_1MeshPointDevice_1_1Statistics}{Statistics} \hyperlink{classns3_1_1MeshPointDevice_a7e408ac2b047d923dffaf0945d28f80f}{m\+\_\+fwd\+Stats}
\begin{DoxyCompactList}\small\item\em forward statistics \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Virtual net device modeling mesh point. 

Mesh point is a virtual net device which is responsible for
\begin{DoxyItemize}
\item Aggregating and coordinating 1..$\ast$ real devices -- mesh interfaces, see Mesh\+Interface\+Device class.
\item Hosting all mesh-\/related level 2 protocols.
\end{DoxyItemize}

One of hosted L2 protocols must inplement L2\+Routing\+Protocol interface and is used for packets forwarding.

From the level 3 point of view \hyperlink{classns3_1_1MeshPointDevice}{Mesh\+Point\+Device} is similar to \hyperlink{classns3_1_1BridgeNetDevice}{Bridge\+Net\+Device}, but the packets, which going through may be changed (because L2 protocols may require their own headers or tags).

Attributes\+:\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000123}{Todo}]\end{DoxyRefDesc}


\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Mesh\+Point\+Device@{Mesh\+Point\+Device}}
\index{Mesh\+Point\+Device@{Mesh\+Point\+Device}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Mesh\+Point\+Device()}{MeshPointDevice()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Mesh\+Point\+Device\+::\+Mesh\+Point\+Device (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1MeshPointDevice_a8f30cce92eb76c9caf89ca44c6fbad4b}{}\label{classns3_1_1MeshPointDevice_a8f30cce92eb76c9caf89ca44c6fbad4b}


C-\/tor create empty (without interfaces and protocols) mesh point. 


\begin{DoxyCode}
58                                   :
59   \hyperlink{classns3_1_1MeshPointDevice_a0d5bbbd2c3930407c50757ba70ef71a7}{m\_ifIndex} (0)
60 \{
61   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
62   \hyperlink{classns3_1_1MeshPointDevice_a56185011f8d2654cf842a6273e9e398e}{m\_channel} = CreateObject<BridgeChannel> ();
63 \}
\end{DoxyCode}
\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!````~Mesh\+Point\+Device@{$\sim$\+Mesh\+Point\+Device}}
\index{````~Mesh\+Point\+Device@{$\sim$\+Mesh\+Point\+Device}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{$\sim$\+Mesh\+Point\+Device()}{~MeshPointDevice()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Mesh\+Point\+Device\+::$\sim$\+Mesh\+Point\+Device (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MeshPointDevice_a8f93896ef5c3a846905fa529534f7d68}{}\label{classns3_1_1MeshPointDevice_a8f93896ef5c3a846905fa529534f7d68}


D-\/tor. 


\begin{DoxyCode}
66 \{
67   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
68   \hyperlink{classns3_1_1MeshPointDevice_a2da4f2175aa00207f0acd0712f815796}{m\_node} = 0;
69   \hyperlink{classns3_1_1MeshPointDevice_a56185011f8d2654cf842a6273e9e398e}{m\_channel} = 0;
70   \hyperlink{classns3_1_1MeshPointDevice_ac704fc10d4ed26d009f8bbfe71049d45}{m\_routingProtocol} = 0;
71 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Add\+Interface@{Add\+Interface}}
\index{Add\+Interface@{Add\+Interface}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Add\+Interface(\+Ptr$<$ Net\+Device $>$ port)}{AddInterface(Ptr< NetDevice > port)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mesh\+Point\+Device\+::\+Add\+Interface (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{port}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1MeshPointDevice_a0001ebec0a10fc9cf05dd6da958a7e98}{}\label{classns3_1_1MeshPointDevice_a0001ebec0a10fc9cf05dd6da958a7e98}


Attach new interface to the station. Interface must support 48-\/bit M\+AC address and Send\+From method. 


\begin{DoxyParams}{Parameters}
{\em port} & the port used\\
\hline
\end{DoxyParams}
\begin{DoxyAttention}{Attention}
Only \hyperlink{classns3_1_1MeshPointDevice}{Mesh\+Point\+Device} can have IP address, but not individual interfaces. 
\end{DoxyAttention}

\begin{DoxyCode}
360 \{
361   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << iface);
362 
363   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (iface != \textcolor{keyword}{this});
364   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1Mac48Address_a55cc1e3c6aa63fd1a4f8f7d9be4ae182}{Mac48Address::IsMatchingType} (iface->GetAddress ()))
365     \{
366       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Device does not support eui 48 addresses: cannot be used as a mesh
       point interface."});
367     \}
368   \textcolor{keywordflow}{if} (!iface->SupportsSendFrom ())
369     \{
370       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Device does not support SendFrom: cannot be used as a mesh point
       interface."});
371     \}
372 
373   \textcolor{comment}{// Mesh point has MAC address of it's first interface}
374   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1MeshPointDevice_a651ebd5660f380c261cd9a055a95805d}{m\_ifaces}.empty ())
375     \{
376       \hyperlink{classns3_1_1MeshPointDevice_abdd42cdf967d3b75cc32e20f74e10c51}{m\_address} = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (iface->GetAddress ());
377     \}
378   Ptr<WifiNetDevice> wifiNetDev = iface->GetObject<WifiNetDevice> ();
379   \textcolor{keywordflow}{if} (wifiNetDev == 0)
380     \{
381       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Device is not a WiFi NIC: cannot be used as a mesh point interface."});
382     \}
383   Ptr<MeshWifiInterfaceMac> ifaceMac = wifiNetDev->GetMac ()->GetObject<MeshWifiInterfaceMac> ();
384   \textcolor{keywordflow}{if} (ifaceMac == 0)
385     \{
386       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (
387         \textcolor{stringliteral}{"WiFi device doesn't have correct MAC installed: cannot be used as a mesh point interface."});
388     \}
389   ifaceMac->SetMeshPointAddress (\hyperlink{classns3_1_1MeshPointDevice_abdd42cdf967d3b75cc32e20f74e10c51}{m\_address});
390 
391   \textcolor{comment}{// Receive frames from this interface}
392   \hyperlink{classns3_1_1MeshPointDevice_a2da4f2175aa00207f0acd0712f815796}{m\_node}->\hyperlink{classns3_1_1Node_af713f0e7ea5c49b4fa0b3613405c45fa}{RegisterProtocolHandler} (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1MeshPointDevice_a4d34699068f61ebcbb610c650b28af6b}{MeshPointDevice::ReceiveFromDevice}, \textcolor{keyword}{this}), 0, iface, \textcolor{comment}{/*promiscuous = */}
393                                    \textcolor{keyword}{true});
394   \hyperlink{classns3_1_1MeshPointDevice_a651ebd5660f380c261cd9a055a95805d}{m\_ifaces}.push\_back (iface);
395   \hyperlink{classns3_1_1MeshPointDevice_a56185011f8d2654cf842a6273e9e398e}{m\_channel}->AddChannel (iface->GetChannel ());
396 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Add\+Link\+Change\+Callback@{Add\+Link\+Change\+Callback}}
\index{Add\+Link\+Change\+Callback@{Add\+Link\+Change\+Callback}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Add\+Link\+Change\+Callback(\+Callback$<$ void $>$ callback)}{AddLinkChangeCallback(Callback< void > callback)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mesh\+Point\+Device\+::\+Add\+Link\+Change\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Callback}$<$ void $>$}]{callback}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MeshPointDevice_aee3bb56e67a9d6eaaba98400cf7b8bb3}{}\label{classns3_1_1MeshPointDevice_aee3bb56e67a9d6eaaba98400cf7b8bb3}

\begin{DoxyParams}{Parameters}
{\em callback} & the callback to invoke\\
\hline
\end{DoxyParams}
Add a callback invoked whenever the link status changes to UP. This callback is typically used by the I\+P/\+A\+RP layer to flush the A\+RP cache and by I\+Pv6 stack to flush N\+D\+I\+SC cache whenever the link goes up. 

Implements \hyperlink{classns3_1_1NetDevice_aafb1bf869d38ef7a7112d11fab0163a3}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
211 \{
212   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
213   \textcolor{comment}{// do nothing}
214   \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"AddLinkChangeCallback does nothing"});
215 \}
\end{DoxyCode}
\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Do\+Dispose()}{DoDispose()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mesh\+Point\+Device\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MeshPointDevice_a6a5f293afb71ae4b58d523abccb3229b}{}\label{classns3_1_1MeshPointDevice_a6a5f293afb71ae4b58d523abccb3229b}
Destructor implementation.

This method is called by \hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose()} or by the \hyperlink{classns3_1_1Object}{Object}\textquotesingle{}s destructor, whichever comes first.

Subclasses are expected to implement their real destruction code in an overriden version of this method and chain up to their parent\textquotesingle{}s implementation once they are done. {\itshape i.\+e}, for simplicity, the destructor of every subclass should be empty and its content should be moved to the associated \hyperlink{classns3_1_1MeshPointDevice_a6a5f293afb71ae4b58d523abccb3229b}{Do\+Dispose()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.


\begin{DoxyCode}
75 \{
76   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
77   \textcolor{keywordflow}{for} (std::vector<Ptr<NetDevice> >::iterator iter = \hyperlink{classns3_1_1MeshPointDevice_a651ebd5660f380c261cd9a055a95805d}{m\_ifaces}.begin (); iter != 
      \hyperlink{classns3_1_1MeshPointDevice_a651ebd5660f380c261cd9a055a95805d}{m\_ifaces}.end (); iter++)
78     \{
79       *iter = 0;
80     \}
81   \hyperlink{classns3_1_1MeshPointDevice_a651ebd5660f380c261cd9a055a95805d}{m\_ifaces}.clear ();
82   \hyperlink{classns3_1_1MeshPointDevice_a2da4f2175aa00207f0acd0712f815796}{m\_node} = 0;
83   \hyperlink{classns3_1_1MeshPointDevice_a56185011f8d2654cf842a6273e9e398e}{m\_channel} = 0;
84   \hyperlink{classns3_1_1MeshPointDevice_ac704fc10d4ed26d009f8bbfe71049d45}{m\_routingProtocol} = 0;
85   \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{NetDevice::DoDispose} ();
86 
87 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Do\+Send@{Do\+Send}}
\index{Do\+Send@{Do\+Send}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Do\+Send(bool success, Ptr$<$ Packet $>$ packet, Mac48\+Address src, Mac48\+Address dst, uint16\+\_\+t protocol, uint32\+\_\+t iface)}{DoSend(bool success, Ptr< Packet > packet, Mac48Address src, Mac48Address dst, uint16_t protocol, uint32_t iface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mesh\+Point\+Device\+::\+Do\+Send (
\begin{DoxyParamCaption}
\item[{bool}]{success, }
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Mac48\+Address}}]{src, }
\item[{{\bf Mac48\+Address}}]{dst, }
\item[{uint16\+\_\+t}]{protocol, }
\item[{uint32\+\_\+t}]{iface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MeshPointDevice_a01489a62c62337339cf7dc8654849964}{}\label{classns3_1_1MeshPointDevice_a01489a62c62337339cf7dc8654849964}


Response callback for L2 routing protocol. This will be executed when routing information is ready. 


\begin{DoxyParams}{Parameters}
{\em success} & True is route found. \\
\hline
{\em packet} & \hyperlink{classns3_1_1Packet}{Packet} to send \\
\hline
{\em src} & Source M\+AC address \\
\hline
{\em dst} & Destination M\+AC address \\
\hline
{\em protocol} & Protocol ID \\
\hline
{\em iface} & Interface to use (ID) for send (decided by routing protocol). All interfaces will be used if out\+Iface = 0xffffffff \\
\hline
\end{DoxyParams}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000124}{Todo}]diagnose routing errors \end{DoxyRefDesc}

\begin{DoxyCode}
421 \{
422   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << success << packet << src << dst << protocol << outIface);
423   \textcolor{keywordflow}{if} (!success)
424     \{
425       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Resolve failed"});
426       \textcolor{keywordflow}{return};
427     \}
428 
429   \textcolor{comment}{// Count statistics}
430   Statistics * stats = ((src == \hyperlink{classns3_1_1MeshPointDevice_abdd42cdf967d3b75cc32e20f74e10c51}{m\_address}) ? &\hyperlink{classns3_1_1MeshPointDevice_abbd06f2b215c772004661d6bdb156a31}{m\_txStats} : &
      \hyperlink{classns3_1_1MeshPointDevice_a7e408ac2b047d923dffaf0945d28f80f}{m\_fwdStats});
431 
432   \textcolor{keywordflow}{if} (dst.IsBroadcast ())
433     \{
434       stats->broadcastData++;
435       stats->broadcastDataBytes += packet->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ();
436     \}
437   \textcolor{keywordflow}{else}
438     \{
439       stats->unicastData++;
440       stats->unicastDataBytes += packet->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ();
441     \}
442 
443   \textcolor{comment}{// Send}
444   \textcolor{keywordflow}{if} (outIface != 0xffffffff)
445     \{
446       \hyperlink{classns3_1_1MeshPointDevice_a713a8775a919a65821d588e22d3a69dd}{GetInterface} (outIface)->SendFrom (packet, src, dst, protocol);
447     \}
448   \textcolor{keywordflow}{else}
449     \{
450       \textcolor{keywordflow}{for} (std::vector<Ptr<NetDevice> >::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1MeshPointDevice_a651ebd5660f380c261cd9a055a95805d}{m\_ifaces}.begin (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1MeshPointDevice_a651ebd5660f380c261cd9a055a95805d}{m\_ifaces}.end (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
451         \{
452           (*i)->SendFrom (packet->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} (), src, dst, protocol);
453         \}
454     \}
455 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4




Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Forward@{Forward}}
\index{Forward@{Forward}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Forward(\+Ptr$<$ Net\+Device $>$ incoming\+Port, Ptr$<$ const Packet $>$ packet, uint16\+\_\+t protocol, const Mac48\+Address src, const Mac48\+Address dst)}{Forward(Ptr< NetDevice > incomingPort, Ptr< const Packet > packet, uint16_t protocol, const Mac48Address src, const Mac48Address dst)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mesh\+Point\+Device\+::\+Forward (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{incoming\+Port, }
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{packet, }
\item[{uint16\+\_\+t}]{protocol, }
\item[{const {\bf Mac48\+Address}}]{src, }
\item[{const {\bf Mac48\+Address}}]{dst}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MeshPointDevice_a8c13c74a516103913d7e852159e47d7d}{}\label{classns3_1_1MeshPointDevice_a8c13c74a516103913d7e852159e47d7d}


Forward packet down to interfaces. 


\begin{DoxyCode}
139 \{
140   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << inport << packet << protocol << src << dst);
141   \textcolor{comment}{// pass through routing protocol}
142   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Forwarding from "} << src << \textcolor{stringliteral}{" to "} << dst << \textcolor{stringliteral}{" at "} << 
      \hyperlink{classns3_1_1MeshPointDevice_abdd42cdf967d3b75cc32e20f74e10c51}{m\_address});
143   \textcolor{keywordtype}{bool} result = \hyperlink{classns3_1_1MeshPointDevice_ac704fc10d4ed26d009f8bbfe71049d45}{m\_routingProtocol}->RequestRoute (inport->GetIfIndex (), src, dst, packet, 
      protocol, \hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (
144                                      &\hyperlink{classns3_1_1MeshPointDevice_a01489a62c62337339cf7dc8654849964}{MeshPointDevice::DoSend}, \textcolor{keyword}{this}));
145   \textcolor{keywordflow}{if} (result == \textcolor{keyword}{false})
146     \{
147       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Request to forward packet "} << packet << \textcolor{stringliteral}{" to destination "} << dst << \textcolor{stringliteral}{"
       failed; dropping packet"});
148     \}
149 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6




Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Get\+Address@{Get\+Address}}
\index{Get\+Address@{Get\+Address}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Get\+Address() const }{GetAddress() const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Mesh\+Point\+Device\+::\+Get\+Address (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MeshPointDevice_a4b81948cadc3648639b306149221a4c5}{}\label{classns3_1_1MeshPointDevice_a4b81948cadc3648639b306149221a4c5}
\begin{DoxyReturn}{Returns}
the current \hyperlink{classns3_1_1Address}{Address} of this interface. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a671f99de496d6f09ae343bb715301fb2}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
174 \{
175   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
176   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1MeshPointDevice_abdd42cdf967d3b75cc32e20f74e10c51}{m\_address};
177 \}
\end{DoxyCode}
\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Get\+Broadcast@{Get\+Broadcast}}
\index{Get\+Broadcast@{Get\+Broadcast}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Get\+Broadcast() const }{GetBroadcast() const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Mesh\+Point\+Device\+::\+Get\+Broadcast (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MeshPointDevice_a08f693b1e5ff2a53aa492b5f43f92af0}{}\label{classns3_1_1MeshPointDevice_a08f693b1e5ff2a53aa492b5f43f92af0}
\begin{DoxyReturn}{Returns}
the broadcast address supported by this netdevice.
\end{DoxyReturn}
Calling this method is invalid if Is\+Broadcast returns not true. 

Implements \hyperlink{classns3_1_1NetDevice_a4724e03bc548dd8e967cc4a7356197bd}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
226 \{
227   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
228   \textcolor{keywordflow}{return} Mac48Address (\textcolor{stringliteral}{"ff:ff:ff:ff:ff:ff"});
229 \}
\end{DoxyCode}
\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Get\+Channel@{Get\+Channel}}
\index{Get\+Channel@{Get\+Channel}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Get\+Channel() const }{GetChannel() const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Channel} $>$ ns3\+::\+Mesh\+Point\+Device\+::\+Get\+Channel (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MeshPointDevice_a3a6b755ff27de635152d55191db0fa60}{}\label{classns3_1_1MeshPointDevice_a3a6b755ff27de635152d55191db0fa60}
\begin{DoxyReturn}{Returns}
the channel this \hyperlink{classns3_1_1NetDevice}{Net\+Device} is connected to. The value returned can be zero if the \hyperlink{classns3_1_1NetDevice}{Net\+Device} is not yet connected to any channel or if the underlying \hyperlink{classns3_1_1NetDevice}{Net\+Device} has no concept of a channel. i.\+e., callers {\itshape must} check for zero and be ready to handle it. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a3d810bd2738634e2e851661271828565}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
167 \{
168   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
169   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1MeshPointDevice_a56185011f8d2654cf842a6273e9e398e}{m\_channel};
170 \}
\end{DoxyCode}
\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Get\+If\+Index@{Get\+If\+Index}}
\index{Get\+If\+Index@{Get\+If\+Index}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Get\+If\+Index() const }{GetIfIndex() const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Mesh\+Point\+Device\+::\+Get\+If\+Index (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MeshPointDevice_af9f6b14ebf81365ca9162712eb232a4c}{}\label{classns3_1_1MeshPointDevice_af9f6b14ebf81365ca9162712eb232a4c}
\begin{DoxyReturn}{Returns}
index if\+Index of the device 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a8c1ae2ec8eadc4524dfc1e425bfa0850}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
160 \{
161   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
162   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1MeshPointDevice_a0d5bbbd2c3930407c50757ba70ef71a7}{m\_ifIndex};
163 \}
\end{DoxyCode}
\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Get\+Interface@{Get\+Interface}}
\index{Get\+Interface@{Get\+Interface}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Get\+Interface(uint32\+\_\+t id) const }{GetInterface(uint32_t id) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Net\+Device} $>$ ns3\+::\+Mesh\+Point\+Device\+::\+Get\+Interface (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{id}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1MeshPointDevice_a713a8775a919a65821d588e22d3a69dd}{}\label{classns3_1_1MeshPointDevice_a713a8775a919a65821d588e22d3a69dd}
\begin{DoxyReturn}{Returns}
interface device by its index (aka ID) 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em id} & is interface id, 0 $<$= id $<$ Get\+N\+Interfaces \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
341 \{
342   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{namespacesample-rng-plot_aeb5ee5c431e338ef39b7ac5431242e1d}{n});
343   \textcolor{keywordflow}{for} (std::vector<Ptr<NetDevice> >::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1MeshPointDevice_a651ebd5660f380c261cd9a055a95805d}{m\_ifaces}.begin (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1MeshPointDevice_a651ebd5660f380c261cd9a055a95805d}{m\_ifaces}.end (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
344     \{
345       \textcolor{keywordflow}{if} ((*i)->GetIfIndex () == \hyperlink{namespacesample-rng-plot_aeb5ee5c431e338ef39b7ac5431242e1d}{n})
346         \{
347           \textcolor{keywordflow}{return} (*\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
348         \}
349     \}
350   \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Mesh point interface is not found by index"});
351   \textcolor{keywordflow}{return} 0;
352 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Get\+Interfaces@{Get\+Interfaces}}
\index{Get\+Interfaces@{Get\+Interfaces}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Get\+Interfaces() const }{GetInterfaces() const }}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<$ {\bf Ptr}$<$ {\bf Net\+Device} $>$ $>$ ns3\+::\+Mesh\+Point\+Device\+::\+Get\+Interfaces (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1MeshPointDevice_ab4c61357a8795c37dd042c560cd12b8f}{}\label{classns3_1_1MeshPointDevice_ab4c61357a8795c37dd042c560cd12b8f}
\begin{DoxyReturn}{Returns}
vector of interfaces 
\end{DoxyReturn}

\begin{DoxyCode}
355 \{
356   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1MeshPointDevice_a651ebd5660f380c261cd9a055a95805d}{m\_ifaces};
357 \}
\end{DoxyCode}
\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Get\+Mtu@{Get\+Mtu}}
\index{Get\+Mtu@{Get\+Mtu}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Get\+Mtu() const }{GetMtu() const }}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Mesh\+Point\+Device\+::\+Get\+Mtu (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MeshPointDevice_a49c4b789a364ce823accd6a28e4b38be}{}\label{classns3_1_1MeshPointDevice_a49c4b789a364ce823accd6a28e4b38be}
\begin{DoxyReturn}{Returns}
the link-\/level M\+TU in bytes for this interface.
\end{DoxyReturn}
This value is typically used by the IP layer to perform IP fragmentation when needed. 

Implements \hyperlink{classns3_1_1NetDevice_a91f4f5d01bc2d567c1e0a69b63a4cf14}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
197 \{
198   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
199   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1MeshPointDevice_a27a3f3299a55f394947f9bf8dea628d4}{m\_mtu};
200 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 9


\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Get\+Multicast@{Get\+Multicast}}
\index{Get\+Multicast@{Get\+Multicast}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Get\+Multicast(\+Ipv4\+Address multicast\+Group) const }{GetMulticast(Ipv4Address multicastGroup) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Mesh\+Point\+Device\+::\+Get\+Multicast (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{multicast\+Group}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MeshPointDevice_a409a07386a7a32cd52c215df46abea1b}{}\label{classns3_1_1MeshPointDevice_a409a07386a7a32cd52c215df46abea1b}


Make and return a M\+AC multicast address using the provided multicast group. 

\{1112\} says that an \hyperlink{classns3_1_1Ipv4}{Ipv4} host group address is mapped to an Ethernet multicast address by placing the low-\/order 23-\/bits of the IP address into the low-\/order 23 bits of the Ethernet multicast address 01-\/00-\/5\+E-\/00-\/00-\/00 (hex). Similar R\+F\+Cs exist for \hyperlink{classns3_1_1Ipv6}{Ipv6} and Eui64 mappings. This method performs the multicast address creation function appropriate to the underlying M\+AC address of the device. This M\+AC address is encapsulated in an abstract \hyperlink{classns3_1_1Address}{Address} to avoid dependencies on the exact M\+AC address format.

In the case of net devices that do not support multicast, clients are expected to test \hyperlink{classns3_1_1NetDevice_a1afb4848a9226540f1ff51f9b31ae95e}{Net\+Device\+::\+Is\+Multicast} and avoid attempting to map multicast packets. Subclasses of \hyperlink{classns3_1_1NetDevice}{Net\+Device} that do support multicasting are expected to override this method and provide an implementation appropriate to the particular device.


\begin{DoxyParams}{Parameters}
{\em multicast\+Group} & The IP address for the multicast group destination of the packet. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The M\+AC multicast \hyperlink{classns3_1_1Address}{Address} used to send packets to the provided multicast group.
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Calling this method is invalid if Is\+Multicast returns not true. 
\end{DoxyWarning}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1MeshPointDevice_af2d877953e96024612cf665780a2422b}{Is\+Multicast()} 
\end{DoxySeeAlso}


Implements \hyperlink{classns3_1_1NetDevice_a98aa4852df367b6a393c8cc1d88af0d9}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
240 \{
241   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << multicastGroup);
242   Mac48Address multicast = \hyperlink{classns3_1_1Mac48Address_a23d170f8c7a7d90a8110425620285819}{Mac48Address::GetMulticast} (multicastGroup);
243   \textcolor{keywordflow}{return} multicast;
244 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10


\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Get\+Multicast@{Get\+Multicast}}
\index{Get\+Multicast@{Get\+Multicast}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Get\+Multicast(\+Ipv6\+Address addr) const }{GetMulticast(Ipv6Address addr) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Mesh\+Point\+Device\+::\+Get\+Multicast (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{addr}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MeshPointDevice_a0aca6b73801fffd0ca00661a8dfbda7b}{}\label{classns3_1_1MeshPointDevice_a0aca6b73801fffd0ca00661a8dfbda7b}


Get the M\+AC multicast address corresponding to the I\+Pv6 address provided. 


\begin{DoxyParams}{Parameters}
{\em addr} & I\+Pv6 address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the M\+AC multicast address 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Calling this method is invalid if Is\+Multicast returns not true. 
\end{DoxyWarning}


Implements \hyperlink{classns3_1_1NetDevice_a46479a2c0101c6f9da9251ed4d7575bd}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
324 \{
325   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << addr);
326   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Mac48Address_a23d170f8c7a7d90a8110425620285819}{Mac48Address::GetMulticast} (addr);
327 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 11


\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Get\+N\+Interfaces@{Get\+N\+Interfaces}}
\index{Get\+N\+Interfaces@{Get\+N\+Interfaces}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Get\+N\+Interfaces() const }{GetNInterfaces() const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Mesh\+Point\+Device\+::\+Get\+N\+Interfaces (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1MeshPointDevice_ada5a23b0bdd27cbf6acfdc987d4195d3}{}\label{classns3_1_1MeshPointDevice_ada5a23b0bdd27cbf6acfdc987d4195d3}
\begin{DoxyReturn}{Returns}
number of interfaces 
\end{DoxyReturn}

\begin{DoxyCode}
334 \{
335   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
336   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1MeshPointDevice_a651ebd5660f380c261cd9a055a95805d}{m\_ifaces}.size ();
337 \}
\end{DoxyCode}
\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Get\+Node@{Get\+Node}}
\index{Get\+Node@{Get\+Node}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Get\+Node() const }{GetNode() const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Node} $>$ ns3\+::\+Mesh\+Point\+Device\+::\+Get\+Node (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MeshPointDevice_a77df4aa2db40d523b33037e8a00f7d70}{}\label{classns3_1_1MeshPointDevice_a77df4aa2db40d523b33037e8a00f7d70}
\begin{DoxyReturn}{Returns}
the node base class which contains this network interface.
\end{DoxyReturn}
When a subclass needs to get access to the underlying node base class to print the nodeid for example, it can invoke this method. 

Implements \hyperlink{classns3_1_1NetDevice_a098b6cc4339ac00c62e75cfa48c8aeac}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
282 \{
283   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
284   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1MeshPointDevice_a2da4f2175aa00207f0acd0712f815796}{m\_node};
285 \}
\end{DoxyCode}
\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Get\+Routing\+Protocol@{Get\+Routing\+Protocol}}
\index{Get\+Routing\+Protocol@{Get\+Routing\+Protocol}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Get\+Routing\+Protocol() const }{GetRoutingProtocol() const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Mesh\+L2\+Routing\+Protocol} $>$ ns3\+::\+Mesh\+Point\+Device\+::\+Get\+Routing\+Protocol (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1MeshPointDevice_aefd9678ce885b9dbc7b1aa099e4ebdbe}{}\label{classns3_1_1MeshPointDevice_aefd9678ce885b9dbc7b1aa099e4ebdbe}


Access current routing protocol. 


\begin{DoxyCode}
413 \{
414   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
415   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1MeshPointDevice_ac704fc10d4ed26d009f8bbfe71049d45}{m\_routingProtocol};
416 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 12


\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id()}{GetTypeId()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Mesh\+Point\+Device\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1MeshPointDevice_a9705d0ab147e330bb3eeafdfd844f65b}{}\label{classns3_1_1MeshPointDevice_a9705d0ab147e330bb3eeafdfd844f65b}


\hyperlink{classns3_1_1Object}{Object} type ID for N\+S3 object system. 


\begin{DoxyCode}
38 \{
39   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::MeshPointDevice"})
40     .SetParent<NetDevice> ()
41     .SetGroupName (\textcolor{stringliteral}{"Mesh"})
42     .AddConstructor<\hyperlink{classns3_1_1MeshPointDevice_a8f30cce92eb76c9caf89ca44c6fbad4b}{MeshPointDevice}> ()
43     .AddAttribute (\textcolor{stringliteral}{"Mtu"}, \textcolor{stringliteral}{"The MAC-level Maximum Transmission Unit"},
44                    UintegerValue (0xffff),
45                    MakeUintegerAccessor (&\hyperlink{classns3_1_1MeshPointDevice_a55081bcaa93f7dabff588ab6602388c6}{MeshPointDevice::SetMtu},
46                                          &\hyperlink{classns3_1_1MeshPointDevice_a49c4b789a364ce823accd6a28e4b38be}{MeshPointDevice::GetMtu}),
47                    MakeUintegerChecker<uint16\_t> ())
48     .AddAttribute ( \textcolor{stringliteral}{"RoutingProtocol"},
49                     \textcolor{stringliteral}{"The mesh routing protocol used by this mesh point."},
50                     PointerValue (),
51                     MakePointerAccessor (
52                       &\hyperlink{classns3_1_1MeshPointDevice_aefd9678ce885b9dbc7b1aa099e4ebdbe}{MeshPointDevice::GetRoutingProtocol}, &
      \hyperlink{classns3_1_1MeshPointDevice_a2f487dde5dd7b11b13ad8617c7172d16}{MeshPointDevice::SetRoutingProtocol}),
53                     \hyperlink{namespacens3_a8cd81c2f226bc23ad44a259717e6da15}{MakePointerChecker}<
54                       MeshL2RoutingProtocol> ());
55   \textcolor{keywordflow}{return} tid;
56 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13


\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Is\+Bridge@{Is\+Bridge}}
\index{Is\+Bridge@{Is\+Bridge}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Is\+Bridge() const }{IsBridge() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Mesh\+Point\+Device\+::\+Is\+Bridge (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MeshPointDevice_a9c85129d18c5524c7a96ce33c13836e7}{}\label{classns3_1_1MeshPointDevice_a9c85129d18c5524c7a96ce33c13836e7}


Return true if the net device is acting as a bridge. 

\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Bridge flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a9d34556a1c83a69dacb08698ca4a1d94}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
255 \{
256   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
257   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
258 \}
\end{DoxyCode}
\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Is\+Broadcast@{Is\+Broadcast}}
\index{Is\+Broadcast@{Is\+Broadcast}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Is\+Broadcast() const }{IsBroadcast() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Mesh\+Point\+Device\+::\+Is\+Broadcast (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MeshPointDevice_a2a32c8d877db9e2f274737e953e2f98a}{}\label{classns3_1_1MeshPointDevice_a2a32c8d877db9e2f274737e953e2f98a}
\begin{DoxyReturn}{Returns}
true if this interface supports a broadcast address, false otherwise. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a67f992b20858cd7b397d8fba2feff141}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
219 \{
220   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
221   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
222 \}
\end{DoxyCode}
\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Is\+Link\+Up@{Is\+Link\+Up}}
\index{Is\+Link\+Up@{Is\+Link\+Up}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Is\+Link\+Up() const }{IsLinkUp() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Mesh\+Point\+Device\+::\+Is\+Link\+Up (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MeshPointDevice_a17b8bff37f427361a5f197601a65c0ef}{}\label{classns3_1_1MeshPointDevice_a17b8bff37f427361a5f197601a65c0ef}
\begin{DoxyReturn}{Returns}
true if link is up; false otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_afe1822b79e19a05ab95f693c8fb64fc7}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
204 \{
205   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
206   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
207 \}
\end{DoxyCode}
\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Is\+Multicast@{Is\+Multicast}}
\index{Is\+Multicast@{Is\+Multicast}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Is\+Multicast() const }{IsMulticast() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Mesh\+Point\+Device\+::\+Is\+Multicast (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MeshPointDevice_af2d877953e96024612cf665780a2422b}{}\label{classns3_1_1MeshPointDevice_af2d877953e96024612cf665780a2422b}
\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Multicast flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a1afb4848a9226540f1ff51f9b31ae95e}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
233 \{
234   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
235   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
236 \}
\end{DoxyCode}
\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Is\+Point\+To\+Point@{Is\+Point\+To\+Point}}
\index{Is\+Point\+To\+Point@{Is\+Point\+To\+Point}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Is\+Point\+To\+Point() const }{IsPointToPoint() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Mesh\+Point\+Device\+::\+Is\+Point\+To\+Point (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MeshPointDevice_aea8b732f32d3dd61ffd355e8bc479159}{}\label{classns3_1_1MeshPointDevice_aea8b732f32d3dd61ffd355e8bc479159}


Return true if the net device is on a point-\/to-\/point link. 

\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Point\+To\+Point flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a718177f25efeaf2dbf8a18fcab87224d}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
248 \{
249   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
250   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
251 \}
\end{DoxyCode}
\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Needs\+Arp@{Needs\+Arp}}
\index{Needs\+Arp@{Needs\+Arp}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Needs\+Arp() const }{NeedsArp() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Mesh\+Point\+Device\+::\+Needs\+Arp (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MeshPointDevice_afda6456377cc5a4215384a320f1304d7}{}\label{classns3_1_1MeshPointDevice_afda6456377cc5a4215384a320f1304d7}
\begin{DoxyReturn}{Returns}
true if A\+RP is needed, false otherwise.
\end{DoxyReturn}
Called by higher-\/layers to check if this \hyperlink{classns3_1_1NetDevice}{Net\+Device} requires A\+RP to be used. 

Implements \hyperlink{classns3_1_1NetDevice_ab1a133696310cad3dc2c3d1a4993f310}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
296 \{
297   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
298   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
299 \}
\end{DoxyCode}
\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Receive\+From\+Device@{Receive\+From\+Device}}
\index{Receive\+From\+Device@{Receive\+From\+Device}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Receive\+From\+Device(\+Ptr$<$ Net\+Device $>$ device, Ptr$<$ const Packet $>$ packet, uint16\+\_\+t protocol, Address const \&source, Address const \&destination, Packet\+Type packet\+Type)}{ReceiveFromDevice(Ptr< NetDevice > device, Ptr< const Packet > packet, uint16_t protocol, Address const &source, Address const &destination, PacketType packetType)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mesh\+Point\+Device\+::\+Receive\+From\+Device (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{device, }
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{packet, }
\item[{uint16\+\_\+t}]{protocol, }
\item[{{\bf Address} const \&}]{source, }
\item[{{\bf Address} const \&}]{destination, }
\item[{{\bf Packet\+Type}}]{packet\+Type}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MeshPointDevice_a4d34699068f61ebcbb610c650b28af6b}{}\label{classns3_1_1MeshPointDevice_a4d34699068f61ebcbb610c650b28af6b}


Receive packet from interface. 


\begin{DoxyCode}
96 \{
97   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << incomingPort << packet);
98   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"UID is "} << packet->GetUid ());
99   \textcolor{keyword}{const} Mac48Address src48 = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (src);
100   \textcolor{keyword}{const} Mac48Address dst48 = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (dst);
101   uint16\_t& realProtocol = protocol;
102   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"SRC="} << src48 << \textcolor{stringliteral}{", DST = "} << dst48 << \textcolor{stringliteral}{", I am: "} << 
      \hyperlink{classns3_1_1MeshPointDevice_abdd42cdf967d3b75cc32e20f74e10c51}{m\_address});
103   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1MeshPointDevice_a9d8b17d5fc37167fea51c64d21c4f7eb}{m\_promiscRxCallback}.\hyperlink{classns3_1_1Callback_aa8e27826badbf37f84763f36f70d9b54}{IsNull} ())
104     \{
105       \hyperlink{classns3_1_1MeshPointDevice_a9d8b17d5fc37167fea51c64d21c4f7eb}{m\_promiscRxCallback} (\textcolor{keyword}{this}, packet, protocol, src, dst, packetType);
106     \}
107   \textcolor{keywordflow}{if} (dst48.IsGroup ())
108     \{
109       Ptr<Packet> packet\_copy = packet->Copy ();
110       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1MeshPointDevice_ac704fc10d4ed26d009f8bbfe71049d45}{m\_routingProtocol}->RemoveRoutingStuff (incomingPort->GetIfIndex (), src48, dst48
      , packet\_copy, realProtocol))
111         \{
112           \hyperlink{classns3_1_1MeshPointDevice_a7655ae549d9f2faf860b4051259c6509}{m\_rxCallback} (\textcolor{keyword}{this}, packet\_copy, realProtocol, src);
113           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Forwarding from "} << src48 << \textcolor{stringliteral}{" to "} << dst48 << \textcolor{stringliteral}{" at "} << 
      \hyperlink{classns3_1_1MeshPointDevice_abdd42cdf967d3b75cc32e20f74e10c51}{m\_address});
114           \hyperlink{classns3_1_1MeshPointDevice_a8c13c74a516103913d7e852159e47d7d}{Forward} (incomingPort, packet, protocol, src48, dst48);
115 
116           \hyperlink{classns3_1_1MeshPointDevice_aa10107ad81c4b24d391dcd8520152bf8}{m\_rxStats}.\hyperlink{structns3_1_1MeshPointDevice_1_1Statistics_a63f262171b72e2841c8d8020962aebbe}{broadcastData}++;
117           \hyperlink{classns3_1_1MeshPointDevice_aa10107ad81c4b24d391dcd8520152bf8}{m\_rxStats}.\hyperlink{structns3_1_1MeshPointDevice_1_1Statistics_ae43272e72d10a3ff03be29fb86ed1969}{broadcastDataBytes} += packet->GetSize ();
118         \}
119       \textcolor{keywordflow}{return};
120     \}
121   \textcolor{keywordflow}{if} (dst48 == \hyperlink{classns3_1_1MeshPointDevice_abdd42cdf967d3b75cc32e20f74e10c51}{m\_address})
122     \{
123       Ptr<Packet> packet\_copy = packet->Copy ();
124       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1MeshPointDevice_ac704fc10d4ed26d009f8bbfe71049d45}{m\_routingProtocol}->RemoveRoutingStuff (incomingPort->GetIfIndex (), src48, dst48
      , packet\_copy, realProtocol))
125         \{
126           \hyperlink{classns3_1_1MeshPointDevice_a7655ae549d9f2faf860b4051259c6509}{m\_rxCallback} (\textcolor{keyword}{this}, packet\_copy, realProtocol, src);
127           \hyperlink{classns3_1_1MeshPointDevice_aa10107ad81c4b24d391dcd8520152bf8}{m\_rxStats}.\hyperlink{structns3_1_1MeshPointDevice_1_1Statistics_a756dc2e1a805c69edad8e6cf70dcc821}{unicastData}++;
128           \hyperlink{classns3_1_1MeshPointDevice_aa10107ad81c4b24d391dcd8520152bf8}{m\_rxStats}.\hyperlink{structns3_1_1MeshPointDevice_1_1Statistics_aac39836264b8ec7bf45143814b21aef8}{unicastDataBytes} += packet->GetSize ();
129         \}
130       \textcolor{keywordflow}{return};
131     \}
132   \textcolor{keywordflow}{else}
133     \hyperlink{classns3_1_1MeshPointDevice_a8c13c74a516103913d7e852159e47d7d}{Forward} (incomingPort, packet->Copy (), protocol, src48, dst48);
134 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 14




Here is the caller graph for this function\+:
% FIG 15


\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Report@{Report}}
\index{Report@{Report}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Report(std\+::ostream \&os) const }{Report(std::ostream &os) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mesh\+Point\+Device\+::\+Report (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1MeshPointDevice_a1abd3eaf68b1aa06a337dba8bc0bf4fa}{}\label{classns3_1_1MeshPointDevice_a1abd3eaf68b1aa06a337dba8bc0bf4fa}


Print statistics counters. 


\begin{DoxyCode}
464 \{
465   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
466   os << \textcolor{stringliteral}{"<Statistics"} << std::endl <<
467   \textcolor{stringliteral}{"txUnicastData=\(\backslash\)""} << \hyperlink{classns3_1_1MeshPointDevice_abbd06f2b215c772004661d6bdb156a31}{m\_txStats}.\hyperlink{structns3_1_1MeshPointDevice_1_1Statistics_a756dc2e1a805c69edad8e6cf70dcc821}{unicastData} << \textcolor{stringliteral}{"\(\backslash\)""} << std::endl <<
468   \textcolor{stringliteral}{"txUnicastDataBytes=\(\backslash\)""} << \hyperlink{classns3_1_1MeshPointDevice_abbd06f2b215c772004661d6bdb156a31}{m\_txStats}.\hyperlink{structns3_1_1MeshPointDevice_1_1Statistics_aac39836264b8ec7bf45143814b21aef8}{unicastDataBytes} << \textcolor{stringliteral}{"\(\backslash\)""} << std::endl <<
469   \textcolor{stringliteral}{"txBroadcastData=\(\backslash\)""} << \hyperlink{classns3_1_1MeshPointDevice_abbd06f2b215c772004661d6bdb156a31}{m\_txStats}.\hyperlink{structns3_1_1MeshPointDevice_1_1Statistics_a63f262171b72e2841c8d8020962aebbe}{broadcastData} << \textcolor{stringliteral}{"\(\backslash\)""} << std::endl <<
470   \textcolor{stringliteral}{"txBroadcastDataBytes=\(\backslash\)""} << \hyperlink{classns3_1_1MeshPointDevice_abbd06f2b215c772004661d6bdb156a31}{m\_txStats}.\hyperlink{structns3_1_1MeshPointDevice_1_1Statistics_ae43272e72d10a3ff03be29fb86ed1969}{broadcastDataBytes} << \textcolor{stringliteral}{"\(\backslash\)""} << std::endl
       <<
471   \textcolor{stringliteral}{"rxUnicastData=\(\backslash\)""} << \hyperlink{classns3_1_1MeshPointDevice_aa10107ad81c4b24d391dcd8520152bf8}{m\_rxStats}.\hyperlink{structns3_1_1MeshPointDevice_1_1Statistics_a756dc2e1a805c69edad8e6cf70dcc821}{unicastData} << \textcolor{stringliteral}{"\(\backslash\)""} << std::endl <<
472   \textcolor{stringliteral}{"rxUnicastDataBytes=\(\backslash\)""} << \hyperlink{classns3_1_1MeshPointDevice_aa10107ad81c4b24d391dcd8520152bf8}{m\_rxStats}.\hyperlink{structns3_1_1MeshPointDevice_1_1Statistics_aac39836264b8ec7bf45143814b21aef8}{unicastDataBytes} << \textcolor{stringliteral}{"\(\backslash\)""} << std::endl <<
473   \textcolor{stringliteral}{"rxBroadcastData=\(\backslash\)""} << \hyperlink{classns3_1_1MeshPointDevice_aa10107ad81c4b24d391dcd8520152bf8}{m\_rxStats}.\hyperlink{structns3_1_1MeshPointDevice_1_1Statistics_a63f262171b72e2841c8d8020962aebbe}{broadcastData} << \textcolor{stringliteral}{"\(\backslash\)""} << std::endl <<
474   \textcolor{stringliteral}{"rxBroadcastDataBytes=\(\backslash\)""} << \hyperlink{classns3_1_1MeshPointDevice_aa10107ad81c4b24d391dcd8520152bf8}{m\_rxStats}.\hyperlink{structns3_1_1MeshPointDevice_1_1Statistics_ae43272e72d10a3ff03be29fb86ed1969}{broadcastDataBytes} << \textcolor{stringliteral}{"\(\backslash\)""} << std::endl
       <<
475   \textcolor{stringliteral}{"fwdUnicastData=\(\backslash\)""} << \hyperlink{classns3_1_1MeshPointDevice_a7e408ac2b047d923dffaf0945d28f80f}{m\_fwdStats}.\hyperlink{structns3_1_1MeshPointDevice_1_1Statistics_a756dc2e1a805c69edad8e6cf70dcc821}{unicastData} << \textcolor{stringliteral}{"\(\backslash\)""} << std::endl <<
476   \textcolor{stringliteral}{"fwdUnicastDataBytes=\(\backslash\)""} << \hyperlink{classns3_1_1MeshPointDevice_a7e408ac2b047d923dffaf0945d28f80f}{m\_fwdStats}.\hyperlink{structns3_1_1MeshPointDevice_1_1Statistics_aac39836264b8ec7bf45143814b21aef8}{unicastDataBytes} << \textcolor{stringliteral}{"\(\backslash\)""} << std::endl <<
477   \textcolor{stringliteral}{"fwdBroadcastData=\(\backslash\)""} << \hyperlink{classns3_1_1MeshPointDevice_a7e408ac2b047d923dffaf0945d28f80f}{m\_fwdStats}.\hyperlink{structns3_1_1MeshPointDevice_1_1Statistics_a63f262171b72e2841c8d8020962aebbe}{broadcastData} << \textcolor{stringliteral}{"\(\backslash\)""} << std::endl <<
478   \textcolor{stringliteral}{"fwdBroadcastDataBytes=\(\backslash\)""} << \hyperlink{classns3_1_1MeshPointDevice_a7e408ac2b047d923dffaf0945d28f80f}{m\_fwdStats}.\hyperlink{structns3_1_1MeshPointDevice_1_1Statistics_ae43272e72d10a3ff03be29fb86ed1969}{broadcastDataBytes} << \textcolor{stringliteral}{"\(\backslash\)""} << 
      std::endl <<
479   \textcolor{stringliteral}{"/>"} << std::endl;
480 \}
\end{DoxyCode}
\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Reset\+Stats@{Reset\+Stats}}
\index{Reset\+Stats@{Reset\+Stats}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Reset\+Stats()}{ResetStats()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mesh\+Point\+Device\+::\+Reset\+Stats (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1MeshPointDevice_ae4dc4d2e337fb3a323dd708d184bbd7f}{}\label{classns3_1_1MeshPointDevice_ae4dc4d2e337fb3a323dd708d184bbd7f}


Reset statistics counters. 


\begin{DoxyCode}
484 \{
485   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
486   \hyperlink{classns3_1_1MeshPointDevice_aa10107ad81c4b24d391dcd8520152bf8}{m\_rxStats} = Statistics ();
487   \hyperlink{classns3_1_1MeshPointDevice_abbd06f2b215c772004661d6bdb156a31}{m\_txStats} = Statistics ();
488   \hyperlink{classns3_1_1MeshPointDevice_a7e408ac2b047d923dffaf0945d28f80f}{m\_fwdStats} = Statistics ();
489 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 16


\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Send@{Send}}
\index{Send@{Send}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Send(\+Ptr$<$ Packet $>$ packet, const Address \&dest, uint16\+\_\+t protocol\+Number)}{Send(Ptr< Packet > packet, const Address &dest, uint16_t protocolNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Mesh\+Point\+Device\+::\+Send (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{const {\bf Address} \&}]{dest, }
\item[{uint16\+\_\+t}]{protocol\+Number}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MeshPointDevice_aecb87304750f0d4e639907326e6681f0}{}\label{classns3_1_1MeshPointDevice_aecb87304750f0d4e639907326e6681f0}

\begin{DoxyParams}{Parameters}
{\em packet} & packet sent from above down to Network Device \\
\hline
{\em dest} & mac address of the destination (already resolved) \\
\hline
{\em protocol\+Number} & identifies the type of payload contained in this packet. Used to call the right L3\+Protocol when the packet is received.\\
\hline
\end{DoxyParams}
Called from higher layer to send packet into Network Device to the specified destination \hyperlink{classns3_1_1Address}{Address}

\begin{DoxyReturn}{Returns}
whether the Send operation succeeded 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a59f41afb0fe8951bb94d5739cbe6ee7d}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
262 \{
263   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
264   \textcolor{keyword}{const} Mac48Address dst48 = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (dest);
265   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1MeshPointDevice_ac704fc10d4ed26d009f8bbfe71049d45}{m\_routingProtocol}->RequestRoute (\hyperlink{classns3_1_1MeshPointDevice_a0d5bbbd2c3930407c50757ba70ef71a7}{m\_ifIndex}, 
      \hyperlink{classns3_1_1MeshPointDevice_abdd42cdf967d3b75cc32e20f74e10c51}{m\_address}, dst48, packet, protocolNumber, \hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (
266                                             &\hyperlink{classns3_1_1MeshPointDevice_a01489a62c62337339cf7dc8654849964}{MeshPointDevice::DoSend}, \textcolor{keyword}{this}));
267 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 17


\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Send\+From@{Send\+From}}
\index{Send\+From@{Send\+From}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Send\+From(\+Ptr$<$ Packet $>$ packet, const Address \&source, const Address \&dest, uint16\+\_\+t protocol\+Number)}{SendFrom(Ptr< Packet > packet, const Address &source, const Address &dest, uint16_t protocolNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Mesh\+Point\+Device\+::\+Send\+From (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{const {\bf Address} \&}]{source, }
\item[{const {\bf Address} \&}]{dest, }
\item[{uint16\+\_\+t}]{protocol\+Number}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MeshPointDevice_ac82744797c666f7f55edbcfd8dcf27fb}{}\label{classns3_1_1MeshPointDevice_ac82744797c666f7f55edbcfd8dcf27fb}

\begin{DoxyParams}{Parameters}
{\em packet} & packet sent from above down to Network Device \\
\hline
{\em source} & source mac address (so called \char`\"{}\+M\+A\+C spoofing\char`\"{}) \\
\hline
{\em dest} & mac address of the destination (already resolved) \\
\hline
{\em protocol\+Number} & identifies the type of payload contained in this packet. Used to call the right L3\+Protocol when the packet is received.\\
\hline
\end{DoxyParams}
Called from higher layer to send packet into Network Device with the specified source and destination Addresses.

\begin{DoxyReturn}{Returns}
whether the Send operation succeeded 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a19d55a4746c1ae584bf7da69959a885b}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
272 \{
273   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
274   \textcolor{keyword}{const} Mac48Address src48 = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (src);
275   \textcolor{keyword}{const} Mac48Address dst48 = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (dest);
276   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1MeshPointDevice_ac704fc10d4ed26d009f8bbfe71049d45}{m\_routingProtocol}->RequestRoute (\hyperlink{classns3_1_1MeshPointDevice_a0d5bbbd2c3930407c50757ba70ef71a7}{m\_ifIndex}, src48, dst48, packet, 
      protocolNumber, \hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (
277                                             &\hyperlink{classns3_1_1MeshPointDevice_a01489a62c62337339cf7dc8654849964}{MeshPointDevice::DoSend}, \textcolor{keyword}{this}));
278 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 18


\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Set\+Address@{Set\+Address}}
\index{Set\+Address@{Set\+Address}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Set\+Address(\+Address a)}{SetAddress(Address a)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mesh\+Point\+Device\+::\+Set\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MeshPointDevice_ad15af2645cde05de3d91aaacd77849bd}{}\label{classns3_1_1MeshPointDevice_ad15af2645cde05de3d91aaacd77849bd}
Set the address of this interface 
\begin{DoxyParams}{Parameters}
{\em address} & address to set \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1NetDevice_ab56dc36bc0547471ab3210eda60ee76c}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
181 \{
182   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
183   \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Manual changing mesh point address can cause routing errors."});
184   \hyperlink{classns3_1_1MeshPointDevice_abdd42cdf967d3b75cc32e20f74e10c51}{m\_address} = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (a);
185 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 19


\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Set\+If\+Index@{Set\+If\+Index}}
\index{Set\+If\+Index@{Set\+If\+Index}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Set\+If\+Index(const uint32\+\_\+t index)}{SetIfIndex(const uint32_t index)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mesh\+Point\+Device\+::\+Set\+If\+Index (
\begin{DoxyParamCaption}
\item[{const uint32\+\_\+t}]{index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MeshPointDevice_a5c488f7ac1f53721cc782840036fca5a}{}\label{classns3_1_1MeshPointDevice_a5c488f7ac1f53721cc782840036fca5a}

\begin{DoxyParams}{Parameters}
{\em index} & if\+Index of the device \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1NetDevice_a2e1ac6c1189cd565420305d85a193fb8}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
153 \{
154   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
155   \hyperlink{classns3_1_1MeshPointDevice_a0d5bbbd2c3930407c50757ba70ef71a7}{m\_ifIndex} = index;
156 \}
\end{DoxyCode}
\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Set\+Mtu@{Set\+Mtu}}
\index{Set\+Mtu@{Set\+Mtu}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Set\+Mtu(const uint16\+\_\+t mtu)}{SetMtu(const uint16_t mtu)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Mesh\+Point\+Device\+::\+Set\+Mtu (
\begin{DoxyParamCaption}
\item[{const uint16\+\_\+t}]{mtu}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MeshPointDevice_a55081bcaa93f7dabff588ab6602388c6}{}\label{classns3_1_1MeshPointDevice_a55081bcaa93f7dabff588ab6602388c6}

\begin{DoxyParams}{Parameters}
{\em mtu} & M\+TU value, in bytes, to set for the device \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether the M\+TU value was within legal bounds
\end{DoxyReturn}
Override for default M\+TU defined on a per-\/type basis. 

Implements \hyperlink{classns3_1_1NetDevice_a2ba4956d45cde68eab3cbdd6ede06df0}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
189 \{
190   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
191   \hyperlink{classns3_1_1MeshPointDevice_a27a3f3299a55f394947f9bf8dea628d4}{m\_mtu} = mtu;
192   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
193 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 20


\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Set\+Node@{Set\+Node}}
\index{Set\+Node@{Set\+Node}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Set\+Node(\+Ptr$<$ Node $>$ node)}{SetNode(Ptr< Node > node)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mesh\+Point\+Device\+::\+Set\+Node (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MeshPointDevice_ac63e807b1f104982dee77f323f75e69a}{}\label{classns3_1_1MeshPointDevice_ac63e807b1f104982dee77f323f75e69a}

\begin{DoxyParams}{Parameters}
{\em node} & the node associated to this netdevice.\\
\hline
\end{DoxyParams}
This method is called from \hyperlink{classns3_1_1Node_a42ff83ee1d5d1649c770d3f5b62375de}{ns3\+::\+Node\+::\+Add\+Device}. 

Implements \hyperlink{classns3_1_1NetDevice_a3ae520ae06e93b957f0f56f113319a08}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
289 \{
290   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
291   \hyperlink{classns3_1_1MeshPointDevice_a2da4f2175aa00207f0acd0712f815796}{m\_node} = node;
292 \}
\end{DoxyCode}
\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Set\+Promisc\+Receive\+Callback@{Set\+Promisc\+Receive\+Callback}}
\index{Set\+Promisc\+Receive\+Callback@{Set\+Promisc\+Receive\+Callback}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Set\+Promisc\+Receive\+Callback(\+Net\+Device\+::\+Promisc\+Receive\+Callback cb)}{SetPromiscReceiveCallback(NetDevice::PromiscReceiveCallback cb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mesh\+Point\+Device\+::\+Set\+Promisc\+Receive\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Net\+Device\+::\+Promisc\+Receive\+Callback}}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MeshPointDevice_a3ca31894714a71736a7bfd041da60a95}{}\label{classns3_1_1MeshPointDevice_a3ca31894714a71736a7bfd041da60a95}

\begin{DoxyParams}{Parameters}
{\em cb} & callback to invoke whenever a packet has been received in promiscuous mode and must be forwarded to the higher layers.\\
\hline
\end{DoxyParams}
Enables netdevice promiscuous mode and sets the callback that will handle promiscuous mode packets. Note, promiscuous mode packets means {\itshape all} packets, including those packets that can be sensed by the netdevice but which are intended to be received by other hosts. 

Implements \hyperlink{classns3_1_1NetDevice_a3968946bdbb74d47d7b13612baad7d6d}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
310 \{
311   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
312   \hyperlink{classns3_1_1MeshPointDevice_a9d8b17d5fc37167fea51c64d21c4f7eb}{m\_promiscRxCallback} = cb;
313 \}
\end{DoxyCode}
\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Set\+Receive\+Callback@{Set\+Receive\+Callback}}
\index{Set\+Receive\+Callback@{Set\+Receive\+Callback}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Set\+Receive\+Callback(\+Net\+Device\+::\+Receive\+Callback cb)}{SetReceiveCallback(NetDevice::ReceiveCallback cb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mesh\+Point\+Device\+::\+Set\+Receive\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Net\+Device\+::\+Receive\+Callback}}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MeshPointDevice_ab5fefff52512e73365f2ddb8f409cf3c}{}\label{classns3_1_1MeshPointDevice_ab5fefff52512e73365f2ddb8f409cf3c}

\begin{DoxyParams}{Parameters}
{\em cb} & callback to invoke whenever a packet has been received and must be forwarded to the higher layers.\\
\hline
\end{DoxyParams}
Set the callback to be used to notify higher layers when a packet has been received. 

Implements \hyperlink{classns3_1_1NetDevice_ac63e4d5668e421fec4b5d37f32e7dd18}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
303 \{
304   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
305   \hyperlink{classns3_1_1MeshPointDevice_a7655ae549d9f2faf860b4051259c6509}{m\_rxCallback} = cb;
306 \}
\end{DoxyCode}
\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Set\+Routing\+Protocol@{Set\+Routing\+Protocol}}
\index{Set\+Routing\+Protocol@{Set\+Routing\+Protocol}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Set\+Routing\+Protocol(\+Ptr$<$ Mesh\+L2\+Routing\+Protocol $>$ protocol)}{SetRoutingProtocol(Ptr< MeshL2RoutingProtocol > protocol)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mesh\+Point\+Device\+::\+Set\+Routing\+Protocol (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Mesh\+L2\+Routing\+Protocol} $>$}]{protocol}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1MeshPointDevice_a2f487dde5dd7b11b13ad8617c7172d16}{}\label{classns3_1_1MeshPointDevice_a2f487dde5dd7b11b13ad8617c7172d16}


Register routing protocol to be used. Protocol must be already installed on this mesh point. 


\begin{DoxyCode}
404 \{
405   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << protocol);
406   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\hyperlink{namespacens3_af2a7557fe9afdd98d8f6f8f6e412cf5a}{PeekPointer} (protocol->GetMeshPoint ()) == \textcolor{keyword}{this},
407                  \textcolor{stringliteral}{"Routing protocol must be installed on mesh point to be useful."});
408   \hyperlink{classns3_1_1MeshPointDevice_ac704fc10d4ed26d009f8bbfe71049d45}{m\_routingProtocol} = protocol;
409 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 21




Here is the caller graph for this function\+:
% FIG 22


\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!Supports\+Send\+From@{Supports\+Send\+From}}
\index{Supports\+Send\+From@{Supports\+Send\+From}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{Supports\+Send\+From() const }{SupportsSendFrom() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Mesh\+Point\+Device\+::\+Supports\+Send\+From (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MeshPointDevice_ade4673786f2f0eff1b0f1c11573f97e9}{}\label{classns3_1_1MeshPointDevice_ade4673786f2f0eff1b0f1c11573f97e9}
\begin{DoxyReturn}{Returns}
true if this interface supports a bridging mode, false otherwise. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a04793d220b54c40e110ebf86dae5b25c}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
317 \{
318   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
319   \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \textcolor{comment}{// don't allow to bridge mesh network with something else.}
320 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!m\+\_\+address@{m\+\_\+address}}
\index{m\+\_\+address@{m\+\_\+address}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+address}{m_address}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Mac48\+Address} ns3\+::\+Mesh\+Point\+Device\+::m\+\_\+address\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MeshPointDevice_abdd42cdf967d3b75cc32e20f74e10c51}{}\label{classns3_1_1MeshPointDevice_abdd42cdf967d3b75cc32e20f74e10c51}


Mesh point M\+AC address, supposed to be the address of the first added interface. 

\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!m\+\_\+channel@{m\+\_\+channel}}
\index{m\+\_\+channel@{m\+\_\+channel}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+channel}{m_channel}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Bridge\+Channel}$>$ ns3\+::\+Mesh\+Point\+Device\+::m\+\_\+channel\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MeshPointDevice_a56185011f8d2654cf842a6273e9e398e}{}\label{classns3_1_1MeshPointDevice_a56185011f8d2654cf842a6273e9e398e}


Virtual channel for upper layers. 

\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!m\+\_\+fwd\+Stats@{m\+\_\+fwd\+Stats}}
\index{m\+\_\+fwd\+Stats@{m\+\_\+fwd\+Stats}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+fwd\+Stats}{m_fwdStats}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Statistics} ns3\+::\+Mesh\+Point\+Device\+::m\+\_\+fwd\+Stats\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MeshPointDevice_a7e408ac2b047d923dffaf0945d28f80f}{}\label{classns3_1_1MeshPointDevice_a7e408ac2b047d923dffaf0945d28f80f}


forward statistics 

\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!m\+\_\+ifaces@{m\+\_\+ifaces}}
\index{m\+\_\+ifaces@{m\+\_\+ifaces}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+ifaces}{m_ifaces}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<$ {\bf Ptr}$<${\bf Net\+Device}$>$ $>$ ns3\+::\+Mesh\+Point\+Device\+::m\+\_\+ifaces\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MeshPointDevice_a651ebd5660f380c261cd9a055a95805d}{}\label{classns3_1_1MeshPointDevice_a651ebd5660f380c261cd9a055a95805d}


List of interfaces. 

\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!m\+\_\+if\+Index@{m\+\_\+if\+Index}}
\index{m\+\_\+if\+Index@{m\+\_\+if\+Index}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+if\+Index}{m_ifIndex}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Mesh\+Point\+Device\+::m\+\_\+if\+Index\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MeshPointDevice_a0d5bbbd2c3930407c50757ba70ef71a7}{}\label{classns3_1_1MeshPointDevice_a0d5bbbd2c3930407c50757ba70ef71a7}


If index. 

\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!m\+\_\+mtu@{m\+\_\+mtu}}
\index{m\+\_\+mtu@{m\+\_\+mtu}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+mtu}{m_mtu}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Mesh\+Point\+Device\+::m\+\_\+mtu\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MeshPointDevice_a27a3f3299a55f394947f9bf8dea628d4}{}\label{classns3_1_1MeshPointDevice_a27a3f3299a55f394947f9bf8dea628d4}


M\+TU in bytes. 

\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!m\+\_\+node@{m\+\_\+node}}
\index{m\+\_\+node@{m\+\_\+node}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+node}{m_node}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Node}$>$ ns3\+::\+Mesh\+Point\+Device\+::m\+\_\+node\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MeshPointDevice_a2da4f2175aa00207f0acd0712f815796}{}\label{classns3_1_1MeshPointDevice_a2da4f2175aa00207f0acd0712f815796}


Parent node. 

\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!m\+\_\+promisc\+Rx\+Callback@{m\+\_\+promisc\+Rx\+Callback}}
\index{m\+\_\+promisc\+Rx\+Callback@{m\+\_\+promisc\+Rx\+Callback}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+promisc\+Rx\+Callback}{m_promiscRxCallback}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Net\+Device\+::\+Promisc\+Receive\+Callback} ns3\+::\+Mesh\+Point\+Device\+::m\+\_\+promisc\+Rx\+Callback\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MeshPointDevice_a9d8b17d5fc37167fea51c64d21c4f7eb}{}\label{classns3_1_1MeshPointDevice_a9d8b17d5fc37167fea51c64d21c4f7eb}


Promisc receive action. 

\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!m\+\_\+routing\+Protocol@{m\+\_\+routing\+Protocol}}
\index{m\+\_\+routing\+Protocol@{m\+\_\+routing\+Protocol}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+routing\+Protocol}{m_routingProtocol}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Mesh\+L2\+Routing\+Protocol}$>$ ns3\+::\+Mesh\+Point\+Device\+::m\+\_\+routing\+Protocol\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MeshPointDevice_ac704fc10d4ed26d009f8bbfe71049d45}{}\label{classns3_1_1MeshPointDevice_ac704fc10d4ed26d009f8bbfe71049d45}


Current routing protocol, used mainly by Get\+Routing\+Protocol. 

\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!m\+\_\+rx\+Callback@{m\+\_\+rx\+Callback}}
\index{m\+\_\+rx\+Callback@{m\+\_\+rx\+Callback}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+rx\+Callback}{m_rxCallback}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Net\+Device\+::\+Receive\+Callback} ns3\+::\+Mesh\+Point\+Device\+::m\+\_\+rx\+Callback\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MeshPointDevice_a7655ae549d9f2faf860b4051259c6509}{}\label{classns3_1_1MeshPointDevice_a7655ae549d9f2faf860b4051259c6509}


Receive action. 

\index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!m\+\_\+rx\+Stats@{m\+\_\+rx\+Stats}}
\index{m\+\_\+rx\+Stats@{m\+\_\+rx\+Stats}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+rx\+Stats}{m_rxStats}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Statistics} ns3\+::\+Mesh\+Point\+Device\+::m\+\_\+rx\+Stats\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MeshPointDevice_aa10107ad81c4b24d391dcd8520152bf8}{}\label{classns3_1_1MeshPointDevice_aa10107ad81c4b24d391dcd8520152bf8}


Counters. 

receive statistics \index{ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}!m\+\_\+tx\+Stats@{m\+\_\+tx\+Stats}}
\index{m\+\_\+tx\+Stats@{m\+\_\+tx\+Stats}!ns3\+::\+Mesh\+Point\+Device@{ns3\+::\+Mesh\+Point\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+tx\+Stats}{m_txStats}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Statistics} ns3\+::\+Mesh\+Point\+Device\+::m\+\_\+tx\+Stats\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MeshPointDevice_abbd06f2b215c772004661d6bdb156a31}{}\label{classns3_1_1MeshPointDevice_abbd06f2b215c772004661d6bdb156a31}


transmit statistics 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
mesh/model/\hyperlink{mesh-point-device_8h}{mesh-\/point-\/device.\+h}\item 
mesh/model/\hyperlink{mesh-point-device_8cc}{mesh-\/point-\/device.\+cc}\end{DoxyCompactItemize}
