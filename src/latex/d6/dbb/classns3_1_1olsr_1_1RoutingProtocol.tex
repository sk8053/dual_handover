\hypertarget{classns3_1_1olsr_1_1RoutingProtocol}{}\section{ns3\+:\+:olsr\+:\+:Routing\+Protocol Class Reference}
\label{classns3_1_1olsr_1_1RoutingProtocol}\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}


O\+L\+SR routing protocol for I\+Pv4.  




{\ttfamily \#include $<$olsr-\/routing-\/protocol.\+h$>$}



Inheritance diagram for ns3\+:\+:olsr\+:\+:Routing\+Protocol\+:
% FIG 0


Collaboration diagram for ns3\+:\+:olsr\+:\+:Routing\+Protocol\+:
% FIG 1
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef void($\ast$ \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a64c1999631417f35bf80c92689289378}{Packet\+Tx\+Rx\+Traced\+Callback}) (const \hyperlink{classns3_1_1olsr_1_1PacketHeader}{Packet\+Header} \&header, const \hyperlink{namespacens3_1_1olsr_af17c710718a5637d01f37804a0a53e78}{Message\+List} \&messages)
\item 
typedef void($\ast$ \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a3a82409b9429c015aa41b68848c40cd5}{Table\+Change\+Traced\+Callback}) (uint32\+\_\+t size)
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a3415aee30083fbfc432e985ec1e68125}{Routing\+Protocol} ()
\item 
virtual \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ac1b31c560c42e7b29fb6fee30df1c9bd}{$\sim$\+Routing\+Protocol} ()
\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a688aa2a34930b4132f500d9d6c253f0e}{Set\+Main\+Interface} (uint32\+\_\+t interface)
\begin{DoxyCompactList}\small\item\em Set the O\+L\+SR main address to the first address on the indicated interface. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ac4958795cfe7a164514c3e1a09e159ab}{Dump} (void)
\item 
std\+::vector$<$ \hyperlink{structns3_1_1olsr_1_1RoutingTableEntry}{Routing\+Table\+Entry} $>$ \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a81a605ea088a3508a27414a263a725af}{Get\+Routing\+Table\+Entries} () const 
\item 
int64\+\_\+t \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_aa4c678c146b32eafc73ae404a3a8103f}{Assign\+Streams} (int64\+\_\+t stream)
\item 
std\+::set$<$ uint32\+\_\+t $>$ \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_af49d8e372249668ec53cf329a4cf2253}{Get\+Interface\+Exclusions} () const 
\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ac835a5b09eceb7c7168a953b640cac5c}{Set\+Interface\+Exclusions} (std\+::set$<$ uint32\+\_\+t $>$ exceptions)
\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a330fa7cafeb6258b6ef816e5b54e0327}{Add\+Host\+Network\+Association} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} network\+Addr, \hyperlink{classns3_1_1Ipv4Mask}{Ipv4\+Mask} netmask)
\begin{DoxyCompactList}\small\item\em Injects the specified (network\+Addr, netmask) tuple in the list of local H\+NA associations to be sent by the node via H\+NA messages. If this tuple already exists, nothing is done. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a06c4bb2917ebc46ab608d4c9c3c4cbaa}{Remove\+Host\+Network\+Association} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} network\+Addr, \hyperlink{classns3_1_1Ipv4Mask}{Ipv4\+Mask} netmask)
\begin{DoxyCompactList}\small\item\em Removes the specified (network\+Addr, netmask) tuple from the list of local H\+NA associations to be sent by the node via H\+NA messages. If this tuple does not exist, nothing is done (see \char`\"{}\+Olsr\+State\+::\+Erase\+Association()\char`\"{}). \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a54e6ae3299f2f4e6390792801fe01ae3}{Set\+Routing\+Table\+Association} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4StaticRouting}{Ipv4\+Static\+Routing} $>$ routing\+Table)
\begin{DoxyCompactList}\small\item\em Associates the specified \hyperlink{classns3_1_1Ipv4StaticRouting}{Ipv4\+Static\+Routing} routing table to the O\+L\+SR routing protocol. Entries from this associated routing table that use non-\/olsr outgoing interfaces are added to the list of local H\+NA associations so that they are included in H\+NA messages sent by the node. If this method is called more than once, entries from the old association are deleted before entries from the new one are added. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Ipv4StaticRouting}{Ipv4\+Static\+Routing} $>$ \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a3fe8efac9decd461ef713cf4451121dd}{Get\+Routing\+Table\+Association} () const 
\begin{DoxyCompactList}\small\item\em Returns the internal H\+NA table. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a8c75d345a2a52bc56919f469d3e09849}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afe5419799e8d38ee32d82615de55ef22}{Do\+Initialize} (void)
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a91a0babaefcd493c649fceb4fb1a2e60}{Clear} ()
\begin{DoxyCompactList}\small\item\em Clears the routing table and frees the memory assigned to each one of its entries. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afbbc663c6c3e814b0a71aa4b44312abb}{Get\+Size} () const 
\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a9a1bd13a5259f062ede82512067545c1}{Remove\+Entry} (const \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \&dest)
\begin{DoxyCompactList}\small\item\em Deletes the entry whose destination address is given. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a6ddb7dd3a6584b7d88dc5a41a61b1494}{Add\+Entry} (const \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \&dest, const \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \&next, uint32\+\_\+t interface, uint32\+\_\+t distance)
\begin{DoxyCompactList}\small\item\em Adds a new entry into the routing table. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a7f5674689d4265d024379f9c7650ea07}{Add\+Entry} (const \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \&dest, const \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \&next, const \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \&interface\+Address, uint32\+\_\+t distance)
\begin{DoxyCompactList}\small\item\em Adds a new entry into the routing table. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a514bf401454b233af509476fc3fd5d6b}{Lookup} (const \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \&dest, \hyperlink{structns3_1_1olsr_1_1RoutingTableEntry}{Routing\+Table\+Entry} \&out\+Entry) const 
\begin{DoxyCompactList}\small\item\em Looks up an entry for the specified destination address. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a15394858cdfb821d54f8661ed712083c}{Find\+Send\+Entry} (const \hyperlink{structns3_1_1olsr_1_1RoutingTableEntry}{Routing\+Table\+Entry} \&entry, \hyperlink{structns3_1_1olsr_1_1RoutingTableEntry}{Routing\+Table\+Entry} \&out\+Entry) const 
\begin{DoxyCompactList}\small\item\em Finds the appropriate entry which must be used in order to forward a data packet to a next hop (given a destination). \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a4b0f79333d7f1f1a68ff057e8f00512d}{Route\+Output} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ oif, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket\+::\+Socket\+Errno} \&sockerr)
\begin{DoxyCompactList}\small\item\em Query routing cache for an existing route, for an outbound packet. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_aa0291ccccb5e4e0d42e8b5da4167a5ab}{Route\+Input} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ idev, \hyperlink{classns3_1_1Ipv4RoutingProtocol_a3453a85764cbbb1e704da7e919aa5d19}{Unicast\+Forward\+Callback} ucb, \hyperlink{classns3_1_1Ipv4RoutingProtocol_a26e76f7a555462e6c08fceda64a99d58}{Multicast\+Forward\+Callback} mcb, \hyperlink{classns3_1_1Ipv4RoutingProtocol_aa6ffa0159cb143daa3c46d2ba69bb1b9}{Local\+Deliver\+Callback} lcb, \hyperlink{classns3_1_1Ipv4RoutingProtocol_a0348285418c30d5021b08f7a68af21ea}{Error\+Callback} ecb)
\begin{DoxyCompactList}\small\item\em Route an input packet (to be forwarded or locally delivered) \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a389d83b05f1110042dfb4fc77666c5d3}{Notify\+Interface\+Up} (uint32\+\_\+t interface)
\item 
virtual void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a8fc8faa57ffe549d56b5db197dcd17e4}{Notify\+Interface\+Down} (uint32\+\_\+t interface)
\item 
virtual void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a054b550049839fe54a67e73c4d492a21}{Notify\+Add\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} address)
\item 
virtual void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ab21c8e08be88e0e03d9327731a3b52da}{Notify\+Remove\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} address)
\item 
virtual void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ab0e32a7ea7f5198133eaacca3b4c12da}{Set\+Ipv4} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$ ipv4)
\item 
virtual void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a8b7d440d2ff617159fbf48c93e2ca895}{Print\+Routing\+Table} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream, \hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295a}{Time\+::\+Unit} unit=\hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295aade8622b06524a328cd3a59db6ccf76af}{Time\+::S}) const 
\begin{DoxyCompactList}\small\item\em Print the Routing Table entries. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a4f4847a879139dc41e184b8233573143}{Do\+Dispose} ()
\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a31a103b24f235d7a7719258993363fc9}{Send\+Packet} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, const \hyperlink{namespacens3_1_1olsr_af17c710718a5637d01f37804a0a53e78}{Message\+List} \&contained\+Messages)
\item 
uint16\+\_\+t \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ab7cac75ba09d451d4cc12acb2030fbee}{Get\+Packet\+Sequence\+Number} ()
\item 
uint16\+\_\+t \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_af8656b873ecc22d25d5e5795f936d61a}{Get\+Message\+Sequence\+Number} ()
\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afa449e39488b5c03609960e66553490e}{Recv\+Olsr} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$ socket)
\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a947ab35f39d191ed51d3fbb7c1cc282c}{Mpr\+Computation} ()
\begin{DoxyCompactList}\small\item\em Computates M\+PR set of a node following \{3626\} hints. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a69fcd3b690fbf6e2b46735145cecfe3e}{Routing\+Table\+Computation} ()
\begin{DoxyCompactList}\small\item\em Creates the routing table of the node following \{3626\} hints. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae01451170fb389d322b33ed6d954f460}{Get\+Main\+Address} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} iface\+\_\+addr) const 
\begin{DoxyCompactList}\small\item\em Gets the main address associated with a given interface address. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae4f144aababb20e17a8cfc7c0823bb89}{Uses\+Non\+Olsr\+Outgoing\+Interface} (const \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} \&route)
\begin{DoxyCompactList}\small\item\em Tests whether or not the specified route uses a non-\/\+O\+L\+SR outgoing interface. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a5f10703d9d0e82e48466ab69838c7b2b}{Hello\+Timer\+Expire} ()
\begin{DoxyCompactList}\small\item\em Sends a H\+E\+L\+LO message and reschedules the H\+E\+L\+LO timer. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ad9443857cbc18e1fe48848106c40c96f}{Tc\+Timer\+Expire} ()
\begin{DoxyCompactList}\small\item\em Sends a TC message (if there exists any M\+PR selector) and reschedules the TC timer. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_adb532d5890ea3954e8ab73a625d53e66}{Mid\+Timer\+Expire} ()
\begin{DoxyCompactList}\small\item\em Sends a M\+ID message (if the node has more than one interface) and resets the M\+ID timer. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a6ef2a79ac872935b84a3f1d54316456d}{Hna\+Timer\+Expire} ()
\begin{DoxyCompactList}\small\item\em Sends an H\+NA message (if the node has associated hosts/networks) and reschedules the H\+NA timer. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a78f4aad4a5597ab60fa913e917eabbec}{Dup\+Tuple\+Timer\+Expire} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} address, uint16\+\_\+t sequence\+Number)
\begin{DoxyCompactList}\small\item\em Removes tuple if expired. Else timer is rescheduled to expire at tuple.\+expiration\+Time. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a468cf0d2f46d44f105dff8dffdabcb67}{Link\+Tuple\+Timer\+Expire} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} neighbor\+Iface\+Addr)
\begin{DoxyCompactList}\small\item\em Removes tuple\+\_\+ if expired. Else if symmetric time has expired then it is assumed a neighbor loss and agent\+\_\+-\/$>$nb\+\_\+loss() is called. In this case the timer is rescheduled to expire at tuple\+\_\+-\/$>$time(). Otherwise the timer is rescheduled to expire at the minimum between tuple\+\_\+-\/$>$time() and tuple\+\_\+-\/$>$sym\+\_\+time(). \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a5e71d702e1b560c4645139912da27002}{Nb2hop\+Tuple\+Timer\+Expire} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} neighbor\+Main\+Addr, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} two\+Hop\+Neighbor\+Addr)
\begin{DoxyCompactList}\small\item\em Removes 2\+\_\+hop neighbor tuple\+\_\+ if expired. Else the timer is rescheduled to expire at tuple\+\_\+-\/$>$time(). \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a47272f0889e3c50e4fe26f1f4d9fb3fe}{Mpr\+Sel\+Tuple\+Timer\+Expire} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} main\+Addr)
\begin{DoxyCompactList}\small\item\em Removes M\+PR selector tuple\+\_\+ if expired. Else the timer is rescheduled to expire at tuple\+\_\+-\/$>$time(). \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a9200f9b5d45ca2eacf92027ca0355182}{Topology\+Tuple\+Timer\+Expire} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} dest\+Addr, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} last\+Addr)
\begin{DoxyCompactList}\small\item\em Removes topology tuple\+\_\+ if expired. Else the timer is rescheduled to expire at tuple\+\_\+-\/$>$time(). \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_af93aa9d349c1be0aef8401d2e4189d4c}{Iface\+Assoc\+Tuple\+Timer\+Expire} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} iface\+Addr)
\begin{DoxyCompactList}\small\item\em Removes interface association tuple\+\_\+ if expired. Else the timer is rescheduled to expire at tuple\+\_\+-\/$>$time(). \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a60b5814cf05807e207ac9ebe1f6d90b6}{Association\+Tuple\+Timer\+Expire} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} gateway\+Addr, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} network\+Addr, \hyperlink{classns3_1_1Ipv4Mask}{Ipv4\+Mask} netmask)
\begin{DoxyCompactList}\small\item\em Removes association tuple\+\_\+ if expired. Else timer is rescheduled to expire at tuple\+\_\+-\/$>$time(). \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ac1cfaea5b2ba8a3b32e39256b0221774}{Increment\+Ansn} ()
\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ac918fb6674847bee76fedaf16e15ba44}{Forward\+Default} (\hyperlink{classns3_1_1olsr_1_1MessageHeader}{olsr\+::\+Message\+Header} olsr\+Message, \hyperlink{structns3_1_1olsr_1_1DuplicateTuple}{Duplicate\+Tuple} $\ast$duplicated, const \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \&local\+Iface, const \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \&sender\+Address)
\begin{DoxyCompactList}\small\item\em O\+L\+SR\textquotesingle{}s default forwarding algorithm. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a206c7c0bba382cba1ac50d11a7df88f3}{Queue\+Message} (const \hyperlink{classns3_1_1olsr_1_1MessageHeader}{olsr\+::\+Message\+Header} \&message, \hyperlink{classns3_1_1Time}{Time} \hyperlink{mmwave_2model_2fading-traces_2fading__trace__generator_8m_a7964e6aa8f61a9d28973c8267a606ad8}{delay})
\begin{DoxyCompactList}\small\item\em Enques an O\+L\+SR message which will be sent with a delay of (0, delay\mbox{]}. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a0ee7494c6ac857210f7f12d40d39e349}{Send\+Queued\+Messages} ()
\begin{DoxyCompactList}\small\item\em Creates as many O\+L\+SR packets as needed in order to send all buffered O\+L\+SR messages. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a3b24f29bfb5d4bfa60e0ca1eb28a8b13}{Send\+Hello} ()
\begin{DoxyCompactList}\small\item\em Creates a new O\+L\+SR H\+E\+L\+LO message which is buffered for being sent later on. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a78a41697a6d747bde67d5cb2cd13a4bd}{Send\+Tc} ()
\begin{DoxyCompactList}\small\item\em Creates a new O\+L\+SR TC message which is buffered for being sent later on. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a6da315bbcafcdda3dc11acfea3b33d28}{Send\+Mid} ()
\begin{DoxyCompactList}\small\item\em Creates a new O\+L\+SR M\+ID message which is buffered for being sent later on. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a02fe3cc6e62962d002818651fc6988df}{Send\+Hna} ()
\begin{DoxyCompactList}\small\item\em Creates a new O\+L\+SR H\+NA message which is buffered for being sent later on. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afe342f9ee1d563e0691e12143f47233d}{Neighbor\+Loss} (const \hyperlink{structns3_1_1olsr_1_1LinkTuple}{Link\+Tuple} \&tuple)
\begin{DoxyCompactList}\small\item\em Performs all actions needed when a neighbor loss occurs. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ad863ed4e771bfe7ee021892ddacd2691}{Add\+Duplicate\+Tuple} (const \hyperlink{structns3_1_1olsr_1_1DuplicateTuple}{Duplicate\+Tuple} \&tuple)
\begin{DoxyCompactList}\small\item\em Adds a duplicate tuple to the Duplicate Set. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a72a3220cc44a4fadc7156bfc2603e547}{Remove\+Duplicate\+Tuple} (const \hyperlink{structns3_1_1olsr_1_1DuplicateTuple}{Duplicate\+Tuple} \&tuple)
\begin{DoxyCompactList}\small\item\em Removes a duplicate tuple from the Duplicate Set. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a49feb372260a7d855e02c789e584d5db}{Link\+Tuple\+Added} (const \hyperlink{structns3_1_1olsr_1_1LinkTuple}{Link\+Tuple} \&tuple, uint8\+\_\+t willingness)
\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a1386148ca4a591a3409b54008b7ecae0}{Remove\+Link\+Tuple} (const \hyperlink{structns3_1_1olsr_1_1LinkTuple}{Link\+Tuple} \&tuple)
\begin{DoxyCompactList}\small\item\em Removes a link tuple from the Link Set. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a00df90e72ca9f8de10b6f7859fb730eb}{Link\+Tuple\+Updated} (const \hyperlink{structns3_1_1olsr_1_1LinkTuple}{Link\+Tuple} \&tuple, uint8\+\_\+t willingness)
\begin{DoxyCompactList}\small\item\em This function is invoked when a link tuple is updated. Its aim is to also update the corresponding neighbor tuple if it is needed. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a2378ff630c93a17fd040b61e8a9c1fb4}{Add\+Neighbor\+Tuple} (const \hyperlink{structns3_1_1olsr_1_1NeighborTuple}{Neighbor\+Tuple} \&tuple)
\begin{DoxyCompactList}\small\item\em Adds a neighbor tuple to the Neighbor Set. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_af91353f674fb4f529921fb654203ab74}{Remove\+Neighbor\+Tuple} (const \hyperlink{structns3_1_1olsr_1_1NeighborTuple}{Neighbor\+Tuple} \&tuple)
\begin{DoxyCompactList}\small\item\em Removes a neighbor tuple from the Neighbor Set. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a0ba9661c0d7b61bb0785f3c10af566d5}{Add\+Two\+Hop\+Neighbor\+Tuple} (const \hyperlink{structns3_1_1olsr_1_1TwoHopNeighborTuple}{Two\+Hop\+Neighbor\+Tuple} \&tuple)
\begin{DoxyCompactList}\small\item\em Adds a 2-\/hop neighbor tuple to the 2-\/hop Neighbor Set. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_adc613a8eb47ccb94878d8e9f61e9d11a}{Remove\+Two\+Hop\+Neighbor\+Tuple} (const \hyperlink{structns3_1_1olsr_1_1TwoHopNeighborTuple}{Two\+Hop\+Neighbor\+Tuple} \&tuple)
\begin{DoxyCompactList}\small\item\em Removes a 2-\/hop neighbor tuple from the 2-\/hop Neighbor Set. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_aff14042e35d2343b080522580f3d5b24}{Add\+Mpr\+Selector\+Tuple} (const \hyperlink{structns3_1_1olsr_1_1MprSelectorTuple}{Mpr\+Selector\+Tuple} \&tuple)
\begin{DoxyCompactList}\small\item\em Adds an M\+PR selector tuple to the M\+PR Selector Set. Advertised Neighbor Sequence Number (A\+N\+SN) is also updated. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ab3455ede71dab3092016964ef8577521}{Remove\+Mpr\+Selector\+Tuple} (const \hyperlink{structns3_1_1olsr_1_1MprSelectorTuple}{Mpr\+Selector\+Tuple} \&tuple)
\begin{DoxyCompactList}\small\item\em Removes an M\+PR selector tuple from the M\+PR Selector Set. Advertised Neighbor Sequence Number (A\+N\+SN) is also updated. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a4c151dc96f3b7208d03be261a2ada627}{Add\+Topology\+Tuple} (const \hyperlink{structns3_1_1olsr_1_1TopologyTuple}{Topology\+Tuple} \&tuple)
\begin{DoxyCompactList}\small\item\em Adds a topology tuple to the Topology Set. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a496a7619f3c2de003aebd7554eba2e6e}{Remove\+Topology\+Tuple} (const \hyperlink{structns3_1_1olsr_1_1TopologyTuple}{Topology\+Tuple} \&tuple)
\begin{DoxyCompactList}\small\item\em Removes a topology tuple to the Topology Set. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a727294984dac11244bf1e92baa141934}{Add\+Iface\+Assoc\+Tuple} (const \hyperlink{structns3_1_1olsr_1_1IfaceAssocTuple}{Iface\+Assoc\+Tuple} \&tuple)
\begin{DoxyCompactList}\small\item\em Adds an interface association tuple to the Interface \hyperlink{structns3_1_1olsr_1_1Association}{Association} Set. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a8ecb5343f7e51de7be585b06dbb1b721}{Remove\+Iface\+Assoc\+Tuple} (const \hyperlink{structns3_1_1olsr_1_1IfaceAssocTuple}{Iface\+Assoc\+Tuple} \&tuple)
\begin{DoxyCompactList}\small\item\em Removed an interface association tuple to the Interface \hyperlink{structns3_1_1olsr_1_1Association}{Association} Set. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ad6e926e46d787847b63433a0b9072553}{Add\+Association\+Tuple} (const \hyperlink{structns3_1_1olsr_1_1AssociationTuple}{Association\+Tuple} \&tuple)
\begin{DoxyCompactList}\small\item\em Adds a host network association tuple to the \hyperlink{structns3_1_1olsr_1_1Association}{Association} Set. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_adde5e8973ecbb7a4cbe0c8585e5c2237}{Remove\+Association\+Tuple} (const \hyperlink{structns3_1_1olsr_1_1AssociationTuple}{Association\+Tuple} \&tuple)
\begin{DoxyCompactList}\small\item\em Removes a host network association tuple to the \hyperlink{structns3_1_1olsr_1_1Association}{Association} Set. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a9518c29e8994234ead40d408498237ce}{Process\+Hello} (const \hyperlink{classns3_1_1olsr_1_1MessageHeader}{olsr\+::\+Message\+Header} \&msg, const \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \&receiver\+Iface, const \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \&sender\+Iface)
\begin{DoxyCompactList}\small\item\em Processes a H\+E\+L\+LO message following \{3626\} specification. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a5087b5cbf87313f1073341aebc9ced27}{Process\+Tc} (const \hyperlink{classns3_1_1olsr_1_1MessageHeader}{olsr\+::\+Message\+Header} \&msg, const \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \&sender\+Iface)
\begin{DoxyCompactList}\small\item\em Processes a TC message following \{3626\} specification. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a88dd2a9e226e50034c548787d9d529f3}{Process\+Mid} (const \hyperlink{classns3_1_1olsr_1_1MessageHeader}{olsr\+::\+Message\+Header} \&msg, const \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \&sender\+Iface)
\begin{DoxyCompactList}\small\item\em Processes a M\+ID message following \{3626\} specification. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ab384b31d2faae5b64952052a7eb4eed2}{Process\+Hna} (const \hyperlink{classns3_1_1olsr_1_1MessageHeader}{olsr\+::\+Message\+Header} \&msg, const \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \&sender\+Iface)
\begin{DoxyCompactList}\small\item\em Processes a H\+NA message following \{3626\} specification. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a2a23a0fd6fa714fef6613afd3f5bc1d2}{Link\+Sensing} (const \hyperlink{classns3_1_1olsr_1_1MessageHeader}{olsr\+::\+Message\+Header} \&msg, const \hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Hello}{olsr\+::\+Message\+Header\+::\+Hello} \&hello, const \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \&receiver\+Iface, const \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \&sender\+Iface)
\begin{DoxyCompactList}\small\item\em Updates Link Set according to a new received H\+E\+L\+LO message (following \{3626\} specification). Neighbor Set is also updated if needed. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a9a9cccf9682782a0b95539862b4e6b53}{Populate\+Neighbor\+Set} (const \hyperlink{classns3_1_1olsr_1_1MessageHeader}{olsr\+::\+Message\+Header} \&msg, const \hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Hello}{olsr\+::\+Message\+Header\+::\+Hello} \&hello)
\begin{DoxyCompactList}\small\item\em Updates the Neighbor Set according to the information contained in a new received H\+E\+L\+LO message (following \{3626\}). \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a4a8eb48c32cebfa630bb7168882faa26}{Populate\+Two\+Hop\+Neighbor\+Set} (const \hyperlink{classns3_1_1olsr_1_1MessageHeader}{olsr\+::\+Message\+Header} \&msg, const \hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Hello}{olsr\+::\+Message\+Header\+::\+Hello} \&hello)
\begin{DoxyCompactList}\small\item\em Updates the 2-\/hop Neighbor Set according to the information contained in a new received H\+E\+L\+LO message (following \{3626\}). \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a56bce0e7794315308e10e5fd1343cfaf}{Populate\+Mpr\+Selector\+Set} (const \hyperlink{classns3_1_1olsr_1_1MessageHeader}{olsr\+::\+Message\+Header} \&msg, const \hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Hello}{olsr\+::\+Message\+Header\+::\+Hello} \&hello)
\begin{DoxyCompactList}\small\item\em Updates the M\+PR Selector Set according to the information contained in a new received H\+E\+L\+LO message (following \{3626\}). \end{DoxyCompactList}\item 
int \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_af4806875b065d6fe5704ce65824dc1a7}{Degree} (\hyperlink{structns3_1_1olsr_1_1NeighborTuple}{Neighbor\+Tuple} const \&tuple)
\begin{DoxyCompactList}\small\item\em This auxiliary function (defined in \{3626\}) is used for calculating the M\+PR Set. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a651b14b759452a21133cde6ef0f2f873}{Is\+My\+Own\+Address} (const \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \&a) const 
\begin{DoxyCompactList}\small\item\em Check that address is one of my interfaces. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::set$<$ uint32\+\_\+t $>$ \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afa7fdc171732e31fb92298d62f6340e6}{m\+\_\+interface\+Exclusions}
\begin{DoxyCompactList}\small\item\em Set of interfaces excluded by O\+S\+LR. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4StaticRouting}{Ipv4\+Static\+Routing} $>$ \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae631ae3941f563718274166203d3b178}{m\+\_\+routing\+Table\+Association}
\begin{DoxyCompactList}\small\item\em Associations from an \hyperlink{classns3_1_1Ipv4StaticRouting}{Ipv4\+Static\+Routing} instance. \end{DoxyCompactList}\item 
std\+::map$<$ \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address}, \hyperlink{structns3_1_1olsr_1_1RoutingTableEntry}{Routing\+Table\+Entry} $>$ \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a9703fb92cc9a864c0e2874387ead3aa3}{m\+\_\+table}
\begin{DoxyCompactList}\small\item\em Data structure for the routing table. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4StaticRouting}{Ipv4\+Static\+Routing} $>$ \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a398799911ae136e0b247b4bbd608c336}{m\+\_\+hna\+Routing\+Table}
\begin{DoxyCompactList}\small\item\em Routing table for H\+NA routes. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1EventGarbageCollector}{Event\+Garbage\+Collector} \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a80368d3da46150cf3fc9139c40f33d53}{m\+\_\+events}
\begin{DoxyCompactList}\small\item\em Running events. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_aa5051691fb81c7109b9e2b6c54b43b7f}{m\+\_\+packet\+Sequence\+Number}
\begin{DoxyCompactList}\small\item\em Packets sequence number counter. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a0f6d3f3ae8a78fbf2e2522d9f21e23ca}{m\+\_\+message\+Sequence\+Number}
\begin{DoxyCompactList}\small\item\em Messages sequence number counter. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a8c7b6d3b6eab86260e8ac9848e6f2621}{m\+\_\+ansn}
\begin{DoxyCompactList}\small\item\em Advertised Neighbor Set sequence number. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ac973c86cbf21168c11cd7f16acc1ae4c}{m\+\_\+hello\+Interval}
\begin{DoxyCompactList}\small\item\em H\+E\+L\+LO messages\textquotesingle{} emission interval. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae282dcb4112be0b4f2ac8f413b022fa9}{m\+\_\+tc\+Interval}
\begin{DoxyCompactList}\small\item\em TC messages\textquotesingle{} emission interval. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a9109a692ebfe241e01a68a584a4961b9}{m\+\_\+mid\+Interval}
\begin{DoxyCompactList}\small\item\em M\+ID messages\textquotesingle{} emission interval. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a0d117664d5991c4b405b9ef14c33ea23}{m\+\_\+hna\+Interval}
\begin{DoxyCompactList}\small\item\em H\+NA messages\textquotesingle{} emission interval. \end{DoxyCompactList}\item 
uint8\+\_\+t \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a2e94c2954ffa92d1c7d3b627087c9430}{m\+\_\+willingness}
\begin{DoxyCompactList}\small\item\em Willingness for forwarding packets on behalf of other nodes. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1olsr_1_1OlsrState}{Olsr\+State} \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\+\_\+state}
\begin{DoxyCompactList}\small\item\em Internal state with all needed data structs. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$ \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\+\_\+ipv4}
\begin{DoxyCompactList}\small\item\em I\+Pv4 object the routing is linked to. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Timer}{Timer} \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_aa739535b4dfd71566cb385c9c58f59c9}{m\+\_\+hello\+Timer}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Timer}{Timer} for the H\+E\+L\+LO message. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Timer}{Timer} \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a31e8b4356d659f7ec1c82b86365a179d}{m\+\_\+tc\+Timer}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Timer}{Timer} for the TC message. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Timer}{Timer} \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a7d525e1847150003ef21cd962a66c759}{m\+\_\+mid\+Timer}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Timer}{Timer} for the M\+ID message. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Timer}{Timer} \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_acaf11a25b83098c640a063a094148374}{m\+\_\+hna\+Timer}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Timer}{Timer} for the H\+NA message. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae6557d76350cf59d34d2aae8e9c79831}{m\+\_\+link\+Tuple\+Timer\+First\+Time}
\begin{DoxyCompactList}\small\item\em Flag to indicate if it is the first time the Link\+Tuple\+Timer fires. \end{DoxyCompactList}\item 
\hyperlink{namespacens3_1_1olsr_af17c710718a5637d01f37804a0a53e78}{olsr\+::\+Message\+List} \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a1366596191a80005da6f45af00585d1d}{m\+\_\+queued\+Messages}
\begin{DoxyCompactList}\small\item\em A list of pending messages which are buffered awaiting for being sent. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Timer}{Timer} \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a8b54985da7787840baa68ce4781e5d76}{m\+\_\+queued\+Messages\+Timer}
\begin{DoxyCompactList}\small\item\em timer for throttling outgoing messages \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\+\_\+main\+Address}
\begin{DoxyCompactList}\small\item\em the node main address. \end{DoxyCompactList}\item 
std\+::map$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$, \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} $>$ \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae590f1f394f2ebc0fac434a6866d7c75}{m\+\_\+socket\+Addresses}
\begin{DoxyCompactList}\small\item\em Container of sockets and the interfaces they are opened onto. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ const \hyperlink{classns3_1_1olsr_1_1PacketHeader}{Packet\+Header} \&, const \hyperlink{namespacens3_1_1olsr_af17c710718a5637d01f37804a0a53e78}{Message\+List} \& $>$ \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a861b1d2ce370ab0137e67c5a1102a937}{m\+\_\+rx\+Packet\+Trace}
\begin{DoxyCompactList}\small\item\em Rx packet trace. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ const \hyperlink{classns3_1_1olsr_1_1PacketHeader}{Packet\+Header} \&, const \hyperlink{namespacens3_1_1olsr_af17c710718a5637d01f37804a0a53e78}{Message\+List} \& $>$ \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_aadd8d4fea9a32b185bf23d787004de9d}{m\+\_\+tx\+Packet\+Trace}
\begin{DoxyCompactList}\small\item\em Tx packet trace. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ uint32\+\_\+t $>$ \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a1cbaa4bdf90462b6d8e0ddc90eaa4130}{m\+\_\+routing\+Table\+Changed}
\begin{DoxyCompactList}\small\item\em Routing table chanes challback. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UniformRandomVariable}{Uniform\+Random\+Variable} $>$ \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a5aacf6e47c25a9cedfb2998d09e05193}{m\+\_\+uniform\+Random\+Variable}
\begin{DoxyCompactList}\small\item\em Provides uniform random variables. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a207c4dff8592b10a0fa2924d05c40380}{\+::\+Olsr\+Mpr\+Test\+Case}
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
O\+L\+SR routing protocol for I\+Pv4. 

\subsection{Member Typedef Documentation}
\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Packet\+Tx\+Rx\+Traced\+Callback@{Packet\+Tx\+Rx\+Traced\+Callback}}
\index{Packet\+Tx\+Rx\+Traced\+Callback@{Packet\+Tx\+Rx\+Traced\+Callback}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Packet\+Tx\+Rx\+Traced\+Callback}{PacketTxRxTracedCallback}}]{\setlength{\rightskip}{0pt plus 5cm}typedef void($\ast$  ns3\+::olsr\+::\+Routing\+Protocol\+::\+Packet\+Tx\+Rx\+Traced\+Callback) (const {\bf Packet\+Header} \&header, const {\bf Message\+List} \&messages)}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a64c1999631417f35bf80c92689289378}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a64c1999631417f35bf80c92689289378}
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback} signature for \hyperlink{classns3_1_1Packet}{Packet} transmit and receive events.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em header} & \\
\hline
\mbox{\tt in}  & {\em messages} & \\
\hline
\end{DoxyParams}
\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Table\+Change\+Traced\+Callback@{Table\+Change\+Traced\+Callback}}
\index{Table\+Change\+Traced\+Callback@{Table\+Change\+Traced\+Callback}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Table\+Change\+Traced\+Callback}{TableChangeTracedCallback}}]{\setlength{\rightskip}{0pt plus 5cm}typedef void($\ast$  ns3\+::olsr\+::\+Routing\+Protocol\+::\+Table\+Change\+Traced\+Callback) (uint32\+\_\+t size)}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a3a82409b9429c015aa41b68848c40cd5}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a3a82409b9429c015aa41b68848c40cd5}
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback} signature for routing table computation.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em size} & Final routing table size. \\
\hline
\end{DoxyParams}


\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Routing\+Protocol@{Routing\+Protocol}}
\index{Routing\+Protocol@{Routing\+Protocol}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Routing\+Protocol()}{RoutingProtocol()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::olsr\+::\+Routing\+Protocol\+::\+Routing\+Protocol (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a3415aee30083fbfc432e985ec1e68125}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a3415aee30083fbfc432e985ec1e68125}

\begin{DoxyCode}
197   : \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae631ae3941f563718274166203d3b178}{m\_routingTableAssociation} (0),
198   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4} (0),
199   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_aa739535b4dfd71566cb385c9c58f59c9}{m\_helloTimer} (\hyperlink{classns3_1_1Timer_a816309b83cd2a35bea47d9bbc6bbf721a07a9dd5063b32fb6cf1f813c6ee7e28e}{Timer::CANCEL\_ON\_DESTROY}),
200   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a31e8b4356d659f7ec1c82b86365a179d}{m\_tcTimer} (\hyperlink{classns3_1_1Timer_a816309b83cd2a35bea47d9bbc6bbf721a07a9dd5063b32fb6cf1f813c6ee7e28e}{Timer::CANCEL\_ON\_DESTROY}),
201   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a7d525e1847150003ef21cd962a66c759}{m\_midTimer} (\hyperlink{classns3_1_1Timer_a816309b83cd2a35bea47d9bbc6bbf721a07a9dd5063b32fb6cf1f813c6ee7e28e}{Timer::CANCEL\_ON\_DESTROY}),
202   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_acaf11a25b83098c640a063a094148374}{m\_hnaTimer} (\hyperlink{classns3_1_1Timer_a816309b83cd2a35bea47d9bbc6bbf721a07a9dd5063b32fb6cf1f813c6ee7e28e}{Timer::CANCEL\_ON\_DESTROY}),
203   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a8b54985da7787840baa68ce4781e5d76}{m\_queuedMessagesTimer} (\hyperlink{classns3_1_1Timer_a816309b83cd2a35bea47d9bbc6bbf721a07a9dd5063b32fb6cf1f813c6ee7e28e}{Timer::CANCEL\_ON\_DESTROY})
204 \{
205   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a5aacf6e47c25a9cedfb2998d09e05193}{m\_uniformRandomVariable} = CreateObject<UniformRandomVariable> ();
206 
207   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a398799911ae136e0b247b4bbd608c336}{m\_hnaRoutingTable} = Create<Ipv4StaticRouting> ();
208 \}
\end{DoxyCode}
\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!````~Routing\+Protocol@{$\sim$\+Routing\+Protocol}}
\index{````~Routing\+Protocol@{$\sim$\+Routing\+Protocol}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{$\sim$\+Routing\+Protocol()}{~RoutingProtocol()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::olsr\+::\+Routing\+Protocol\+::$\sim$\+Routing\+Protocol (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_ac1b31c560c42e7b29fb6fee30df1c9bd}{}\label{classns3_1_1olsr_1_1RoutingProtocol_ac1b31c560c42e7b29fb6fee30df1c9bd}

\begin{DoxyCode}
211 \{
212 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Add\+Association\+Tuple@{Add\+Association\+Tuple}}
\index{Add\+Association\+Tuple@{Add\+Association\+Tuple}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Add\+Association\+Tuple(const Association\+Tuple \&tuple)}{AddAssociationTuple(const AssociationTuple &tuple)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Add\+Association\+Tuple (
\begin{DoxyParamCaption}
\item[{const {\bf Association\+Tuple} \&}]{tuple}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_ad6e926e46d787847b63433a0b9072553}{}\label{classns3_1_1olsr_1_1RoutingProtocol_ad6e926e46d787847b63433a0b9072553}


Adds a host network association tuple to the \hyperlink{structns3_1_1olsr_1_1Association}{Association} Set. 


\begin{DoxyParams}{Parameters}
{\em tuple} & The host network association tuple to be added. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2543 \{
2544   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_acee0d3280a41c1eba08ec454adfef3c5}{InsertAssociationTuple} (tuple);
2545 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2




Here is the caller graph for this function\+:
% FIG 3


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Add\+Duplicate\+Tuple@{Add\+Duplicate\+Tuple}}
\index{Add\+Duplicate\+Tuple@{Add\+Duplicate\+Tuple}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Add\+Duplicate\+Tuple(const Duplicate\+Tuple \&tuple)}{AddDuplicateTuple(const DuplicateTuple &tuple)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Add\+Duplicate\+Tuple (
\begin{DoxyParamCaption}
\item[{const {\bf Duplicate\+Tuple} \&}]{tuple}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_ad863ed4e771bfe7ee021892ddacd2691}{}\label{classns3_1_1olsr_1_1RoutingProtocol_ad863ed4e771bfe7ee021892ddacd2691}


Adds a duplicate tuple to the Duplicate Set. 


\begin{DoxyParams}{Parameters}
{\em tuple} & The duplicate tuple to be added. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2304 \{
2305   \textcolor{comment}{/*debug("%f: Node %d adds dup tuple: addr = %d seq\_num = %d\(\backslash\)n",}
2306 \textcolor{comment}{          Simulator::Now (),}
2307 \textcolor{comment}{          OLSR::node\_id(ra\_addr()),}
2308 \textcolor{comment}{          OLSR::node\_id(tuple->addr()),}
2309 \textcolor{comment}{          tuple->seq\_num());*/}
2310   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a70d7c134bee69a2f22ad6daeaba8f0f8}{InsertDuplicateTuple} (tuple);
2311 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4




Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Add\+Entry@{Add\+Entry}}
\index{Add\+Entry@{Add\+Entry}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Add\+Entry(const Ipv4\+Address \&dest, const Ipv4\+Address \&next, uint32\+\_\+t interface, uint32\+\_\+t distance)}{AddEntry(const Ipv4Address &dest, const Ipv4Address &next, uint32_t interface, uint32_t distance)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Add\+Entry (
\begin{DoxyParamCaption}
\item[{const {\bf Ipv4\+Address} \&}]{dest, }
\item[{const {\bf Ipv4\+Address} \&}]{next, }
\item[{uint32\+\_\+t}]{interface, }
\item[{uint32\+\_\+t}]{distance}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a6ddb7dd3a6584b7d88dc5a41a61b1494}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a6ddb7dd3a6584b7d88dc5a41a61b1494}


Adds a new entry into the routing table. 

If an entry for the given destination existed, it is deleted and freed.


\begin{DoxyParams}{Parameters}
{\em dest} & address of the destination node. \\
\hline
{\em next} & address of the next hop node. \\
\hline
{\em interface} & address of the local interface. \\
\hline
{\em distance} & distance to the destination node. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
3020 \{
3021   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << dest << next << interface << distance << 
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress});
3022 
3023   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (distance > 0);
3024 
3025   \textcolor{comment}{// Creates a new rt entry with specified values}
3026   RoutingTableEntry &entry = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a9703fb92cc9a864c0e2874387ead3aa3}{m\_table}[dest];
3027 
3028   entry.destAddr = dest;
3029   entry.nextAddr = next;
3030   entry.interface = interface;
3031   entry.distance = distance;
3032 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Add\+Entry@{Add\+Entry}}
\index{Add\+Entry@{Add\+Entry}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Add\+Entry(const Ipv4\+Address \&dest, const Ipv4\+Address \&next, const Ipv4\+Address \&interface\+Address, uint32\+\_\+t distance)}{AddEntry(const Ipv4Address &dest, const Ipv4Address &next, const Ipv4Address &interfaceAddress, uint32_t distance)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Add\+Entry (
\begin{DoxyParamCaption}
\item[{const {\bf Ipv4\+Address} \&}]{dest, }
\item[{const {\bf Ipv4\+Address} \&}]{next, }
\item[{const {\bf Ipv4\+Address} \&}]{interface\+Address, }
\item[{uint32\+\_\+t}]{distance}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a7f5674689d4265d024379f9c7650ea07}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a7f5674689d4265d024379f9c7650ea07}


Adds a new entry into the routing table. 

If an entry for the given destination existed, an error is thrown.


\begin{DoxyParams}{Parameters}
{\em dest} & address of the destination node. \\
\hline
{\em next} & address of the next hop node. \\
\hline
{\em interface\+Address} & address of the local interface. \\
\hline
{\em distance} & distance to the destination node. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
3039 \{
3040   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << dest << next << interfaceAddress << distance << 
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress});
3041 
3042   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (distance > 0);
3043   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4});
3044 
3045   RoutingTableEntry entry;
3046   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4}->GetNInterfaces (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
3047     \{
3048       \textcolor{keywordflow}{for} (uint32\_t j = 0; j < \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4}->GetNAddresses (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}); j++)
3049         \{
3050           \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i},j).GetLocal () == interfaceAddress)
3051             \{
3052               \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a6ddb7dd3a6584b7d88dc5a41a61b1494}{AddEntry} (dest, next, \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, distance);
3053               \textcolor{keywordflow}{return};
3054             \}
3055         \}
3056     \}
3057   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\textcolor{keyword}{false}); \textcolor{comment}{// should not be reached}
3058   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a6ddb7dd3a6584b7d88dc5a41a61b1494}{AddEntry} (dest, next, 0, distance);
3059 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Add\+Host\+Network\+Association@{Add\+Host\+Network\+Association}}
\index{Add\+Host\+Network\+Association@{Add\+Host\+Network\+Association}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Add\+Host\+Network\+Association(\+Ipv4\+Address network\+Addr, Ipv4\+Mask netmask)}{AddHostNetworkAssociation(Ipv4Address networkAddr, Ipv4Mask netmask)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Add\+Host\+Network\+Association (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{network\+Addr, }
\item[{{\bf Ipv4\+Mask}}]{netmask}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a330fa7cafeb6258b6ef816e5b54e0327}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a330fa7cafeb6258b6ef816e5b54e0327}


Injects the specified (network\+Addr, netmask) tuple in the list of local H\+NA associations to be sent by the node via H\+NA messages. If this tuple already exists, nothing is done. 


\begin{DoxyParams}{Parameters}
{\em network\+Addr} & The network address. \\
\hline
{\em netmask} & The network mask. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1846 \{
1847   \textcolor{comment}{// Check if the (networkAddr, netmask) tuple already exist}
1848   \textcolor{comment}{// in the list of local HNA associations}
1849   \textcolor{keyword}{const} \hyperlink{namespacens3_1_1olsr_a7aefab4ffae5b289262125647510a2ef}{Associations} &localHnaAssociations = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.
      \hyperlink{classns3_1_1olsr_1_1OlsrState_af0d7450ccc6238bb018e8f22fcaf0552}{GetAssociations} ();
1850   \textcolor{keywordflow}{for} (Associations::const\_iterator assocIterator = localHnaAssociations.begin ();
1851        assocIterator != localHnaAssociations.end (); assocIterator++)
1852     \{
1853       Association \textcolor{keyword}{const} &localHnaAssoc = *assocIterator;
1854       \textcolor{keywordflow}{if} (localHnaAssoc.networkAddr == networkAddr && localHnaAssoc.netmask == netmask)
1855         \{
1856           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"HNA association for network "} << networkAddr << \textcolor{stringliteral}{"/"} << netmask << \textcolor{stringliteral}{"
       already exists."});
1857           \textcolor{keywordflow}{return};
1858         \}
1859     \}
1860   \textcolor{comment}{// If the tuple does not already exist, add it to the list of local HNA associations.}
1861   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Adding HNA association for network "} << networkAddr << \textcolor{stringliteral}{"/"} << netmask << \textcolor{stringliteral}{"."});
1862   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a4cdfceadaf69dda63b8fbe08d4ba5acc}{InsertAssociation} ( (Association) \{ networkAddr, netmask\} );
1863 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8




Here is the caller graph for this function\+:
% FIG 9


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Add\+Iface\+Assoc\+Tuple@{Add\+Iface\+Assoc\+Tuple}}
\index{Add\+Iface\+Assoc\+Tuple@{Add\+Iface\+Assoc\+Tuple}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Add\+Iface\+Assoc\+Tuple(const Iface\+Assoc\+Tuple \&tuple)}{AddIfaceAssocTuple(const IfaceAssocTuple &tuple)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Add\+Iface\+Assoc\+Tuple (
\begin{DoxyParamCaption}
\item[{const {\bf Iface\+Assoc\+Tuple} \&}]{tuple}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a727294984dac11244bf1e92baa141934}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a727294984dac11244bf1e92baa141934}


Adds an interface association tuple to the Interface \hyperlink{structns3_1_1olsr_1_1Association}{Association} Set. 


\begin{DoxyParams}{Parameters}
{\em tuple} & The interface association tuple to be added. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2519 \{
2520 \textcolor{comment}{//   debug("%f: Node %d adds iface association tuple: main\_addr = %d iface\_addr = %d\(\backslash\)n",}
2521 \textcolor{comment}{//         Simulator::Now (),}
2522 \textcolor{comment}{//         OLSR::node\_id(ra\_addr()),}
2523 \textcolor{comment}{//         OLSR::node\_id(tuple->main\_addr()),}
2524 \textcolor{comment}{//         OLSR::node\_id(tuple->iface\_addr()));}
2525 
2526   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_adfa9fad0b607bb12e917b4498d1f4547}{InsertIfaceAssocTuple} (tuple);
2527 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10




Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Add\+Mpr\+Selector\+Tuple@{Add\+Mpr\+Selector\+Tuple}}
\index{Add\+Mpr\+Selector\+Tuple@{Add\+Mpr\+Selector\+Tuple}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Add\+Mpr\+Selector\+Tuple(const Mpr\+Selector\+Tuple \&tuple)}{AddMprSelectorTuple(const MprSelectorTuple &tuple)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Add\+Mpr\+Selector\+Tuple (
\begin{DoxyParamCaption}
\item[{const {\bf Mpr\+Selector\+Tuple} \&}]{tuple}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_aff14042e35d2343b080522580f3d5b24}{}\label{classns3_1_1olsr_1_1RoutingProtocol_aff14042e35d2343b080522580f3d5b24}


Adds an M\+PR selector tuple to the M\+PR Selector Set. Advertised Neighbor Sequence Number (A\+N\+SN) is also updated. 


\begin{DoxyParams}{Parameters}
{\em tuple} & The M\+PR selector tuple to be added. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2469 \{
2470 \textcolor{comment}{//   debug("%f: Node %d adds MPR selector tuple: nb\_addr = %d\(\backslash\)n",}
2471 \textcolor{comment}{//         Simulator::Now (),}
2472 \textcolor{comment}{//         OLSR::node\_id(ra\_addr()),}
2473 \textcolor{comment}{//         OLSR::node\_id(tuple->main\_addr()));}
2474 
2475   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_ad21822ab75e7587b10cee641ca846049}{InsertMprSelectorTuple} (tuple);
2476   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ac1cfaea5b2ba8a3b32e39256b0221774}{IncrementAnsn} ();
2477 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12




Here is the caller graph for this function\+:
% FIG 13


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Add\+Neighbor\+Tuple@{Add\+Neighbor\+Tuple}}
\index{Add\+Neighbor\+Tuple@{Add\+Neighbor\+Tuple}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Add\+Neighbor\+Tuple(const Neighbor\+Tuple \&tuple)}{AddNeighborTuple(const NeighborTuple &tuple)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Add\+Neighbor\+Tuple (
\begin{DoxyParamCaption}
\item[{const {\bf Neighbor\+Tuple} \&}]{tuple}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a2378ff630c93a17fd040b61e8a9c1fb4}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a2378ff630c93a17fd040b61e8a9c1fb4}


Adds a neighbor tuple to the Neighbor Set. 


\begin{DoxyParams}{Parameters}
{\em tuple} & The neighbor tuple to be added. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2413 \{
2414 \textcolor{comment}{//   debug("%f: Node %d adds neighbor tuple: nb\_addr = %d status = %s\(\backslash\)n",}
2415 \textcolor{comment}{//         Simulator::Now (),}
2416 \textcolor{comment}{//         OLSR::node\_id(ra\_addr()),}
2417 \textcolor{comment}{//         OLSR::node\_id(tuple->neighborMainAddr),}
2418 \textcolor{comment}{//         ((tuple->status() == OLSR\_STATUS\_SYM) ? "sym" : "not\_sym"));}
2419 
2420   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a94907867178616f16e98d62455f29910}{InsertNeighborTuple} (tuple);
2421   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ac1cfaea5b2ba8a3b32e39256b0221774}{IncrementAnsn} ();
2422 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 14




Here is the caller graph for this function\+:
% FIG 15


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Add\+Topology\+Tuple@{Add\+Topology\+Tuple}}
\index{Add\+Topology\+Tuple@{Add\+Topology\+Tuple}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Add\+Topology\+Tuple(const Topology\+Tuple \&tuple)}{AddTopologyTuple(const TopologyTuple &tuple)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Add\+Topology\+Tuple (
\begin{DoxyParamCaption}
\item[{const {\bf Topology\+Tuple} \&}]{tuple}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a4c151dc96f3b7208d03be261a2ada627}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a4c151dc96f3b7208d03be261a2ada627}


Adds a topology tuple to the Topology Set. 


\begin{DoxyParams}{Parameters}
{\em tuple} & The topology tuple to be added. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2493 \{
2494 \textcolor{comment}{//   debug("%f: Node %d adds topology tuple: dest\_addr = %d last\_addr = %d seq = %d\(\backslash\)n",}
2495 \textcolor{comment}{//         Simulator::Now (),}
2496 \textcolor{comment}{//         OLSR::node\_id(ra\_addr()),}
2497 \textcolor{comment}{//         OLSR::node\_id(tuple->dest\_addr()),}
2498 \textcolor{comment}{//         OLSR::node\_id(tuple->last\_addr()),}
2499 \textcolor{comment}{//         tuple->seq());}
2500 
2501   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a2f5c3c6493a7c8df5d6fcd684c65ee3c}{InsertTopologyTuple} (tuple);
2502 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 16




Here is the caller graph for this function\+:
% FIG 17


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Add\+Two\+Hop\+Neighbor\+Tuple@{Add\+Two\+Hop\+Neighbor\+Tuple}}
\index{Add\+Two\+Hop\+Neighbor\+Tuple@{Add\+Two\+Hop\+Neighbor\+Tuple}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Add\+Two\+Hop\+Neighbor\+Tuple(const Two\+Hop\+Neighbor\+Tuple \&tuple)}{AddTwoHopNeighborTuple(const TwoHopNeighborTuple &tuple)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Add\+Two\+Hop\+Neighbor\+Tuple (
\begin{DoxyParamCaption}
\item[{const {\bf Two\+Hop\+Neighbor\+Tuple} \&}]{tuple}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a0ba9661c0d7b61bb0785f3c10af566d5}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a0ba9661c0d7b61bb0785f3c10af566d5}


Adds a 2-\/hop neighbor tuple to the 2-\/hop Neighbor Set. 


\begin{DoxyParams}{Parameters}
{\em tuple} & The 2-\/hop neighbor tuple to be added. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2439 \{
2440 \textcolor{comment}{//   debug("%f: Node %d adds 2-hop neighbor tuple: nb\_addr = %d nb2hop\_addr = %d\(\backslash\)n",}
2441 \textcolor{comment}{//         Simulator::Now (),}
2442 \textcolor{comment}{//         OLSR::node\_id(ra\_addr()),}
2443 \textcolor{comment}{//         OLSR::node\_id(tuple->neighborMainAddr),}
2444 \textcolor{comment}{//         OLSR::node\_id(tuple->twoHopNeighborAddr));}
2445 
2446   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_ab1fcedee8cd07d9067b1e5db4a84c80e}{InsertTwoHopNeighborTuple} (tuple);
2447 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 18




Here is the caller graph for this function\+:
% FIG 19


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Assign\+Streams@{Assign\+Streams}}
\index{Assign\+Streams@{Assign\+Streams}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Assign\+Streams(int64\+\_\+t stream)}{AssignStreams(int64_t stream)}}]{\setlength{\rightskip}{0pt plus 5cm}int64\+\_\+t ns3\+::olsr\+::\+Routing\+Protocol\+::\+Assign\+Streams (
\begin{DoxyParamCaption}
\item[{int64\+\_\+t}]{stream}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_aa4c678c146b32eafc73ae404a3a8103f}{}\label{classns3_1_1olsr_1_1RoutingProtocol_aa4c678c146b32eafc73ae404a3a8103f}
Assign a fixed random variable stream number to the random variables used by this model. Return the number of streams (possibly zero) that have been assigned.


\begin{DoxyParams}{Parameters}
{\em stream} & first stream index to use \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of stream indices assigned by this model 
\end{DoxyReturn}

\begin{DoxyCode}
3076 \{
3077   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << stream);
3078   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a5aacf6e47c25a9cedfb2998d09e05193}{m\_uniformRandomVariable}->\hyperlink{classns3_1_1RandomVariableStream_add11aaf975607746b7e271d300659a94}{SetStream} (stream);
3079   \textcolor{keywordflow}{return} 1;
3080 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 20


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Association\+Tuple\+Timer\+Expire@{Association\+Tuple\+Timer\+Expire}}
\index{Association\+Tuple\+Timer\+Expire@{Association\+Tuple\+Timer\+Expire}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Association\+Tuple\+Timer\+Expire(\+Ipv4\+Address gateway\+Addr, Ipv4\+Address network\+Addr, Ipv4\+Mask netmask)}{AssociationTupleTimerExpire(Ipv4Address gatewayAddr, Ipv4Address networkAddr, Ipv4Mask netmask)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Association\+Tuple\+Timer\+Expire (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{gateway\+Addr, }
\item[{{\bf Ipv4\+Address}}]{network\+Addr, }
\item[{{\bf Ipv4\+Mask}}]{netmask}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a60b5814cf05807e207ac9ebe1f6d90b6}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a60b5814cf05807e207ac9ebe1f6d90b6}


Removes association tuple\+\_\+ if expired. Else timer is rescheduled to expire at tuple\+\_\+-\/$>$time(). 


\begin{DoxyParams}{Parameters}
{\em gateway\+Addr} & The gateway address. \\
\hline
{\em network\+Addr} & The network address. \\
\hline
{\em netmask} & The network mask. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2749 \{
2750   AssociationTuple *tuple = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_aa399ca44ad27907342350710d1904b84}{FindAssociationTuple} (gatewayAddr, 
      networkAddr, netmask);
2751   \textcolor{keywordflow}{if} (tuple == NULL)
2752     \{
2753       \textcolor{keywordflow}{return};
2754     \}
2755   \textcolor{keywordflow}{if} (tuple->expirationTime < \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ())
2756     \{
2757       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_adde5e8973ecbb7a4cbe0c8585e5c2237}{RemoveAssociationTuple} (*tuple);
2758     \}
2759   \textcolor{keywordflow}{else}
2760     \{
2761       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a80368d3da46150cf3fc9139c40f33d53}{m\_events}.\hyperlink{classns3_1_1EventGarbageCollector_a4f26a1f6e9a09e648eb31b46acd85144}{Track} (\hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{olsr-routing-protocol_8cc_ad0a00c3386c4a24278b3b710ae798220}{DELAY} (tuple->
      expirationTime),
2762                                            &
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a60b5814cf05807e207ac9ebe1f6d90b6}{RoutingProtocol::AssociationTupleTimerExpire},
2763                                            \textcolor{keyword}{this}, gatewayAddr, networkAddr, netmask));
2764     \}
2765 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 21




Here is the caller graph for this function\+:
% FIG 22


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Clear@{Clear}}
\index{Clear@{Clear}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Clear()}{Clear()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Clear (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a91a0babaefcd493c649fceb4fb1a2e60}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a91a0babaefcd493c649fceb4fb1a2e60}


Clears the routing table and frees the memory assigned to each one of its entries. 


\begin{DoxyCode}
2769 \{
2770   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
2771   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a9703fb92cc9a864c0e2874387ead3aa3}{m\_table}.clear ();
2772 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 23


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Degree@{Degree}}
\index{Degree@{Degree}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Degree(\+Neighbor\+Tuple const \&tuple)}{Degree(NeighborTuple const &tuple)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::olsr\+::\+Routing\+Protocol\+::\+Degree (
\begin{DoxyParamCaption}
\item[{{\bf Neighbor\+Tuple} const \&}]{tuple}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_af4806875b065d6fe5704ce65824dc1a7}{}\label{classns3_1_1olsr_1_1RoutingProtocol_af4806875b065d6fe5704ce65824dc1a7}


This auxiliary function (defined in \{3626\}) is used for calculating the M\+PR Set. 


\begin{DoxyParams}{Parameters}
{\em tuple} & the neighbor tuple which has the main address of the node we are going to calculate its degree to. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the degree of the node. 
\end{DoxyReturn}

\begin{DoxyCode}
540 \{
541   \textcolor{keywordtype}{int} degree = 0;
542   \textcolor{keywordflow}{for} (TwoHopNeighborSet::const\_iterator it = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_ab03738874d0d785b770beef6dc9c2e1a}{GetTwoHopNeighbors} ().begin 
      ();
543        it != \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_ab03738874d0d785b770beef6dc9c2e1a}{GetTwoHopNeighbors} ().end (); it++)
544     \{
545       TwoHopNeighborTuple \textcolor{keyword}{const} &nb2hop\_tuple = *it;
546       \textcolor{keywordflow}{if} (nb2hop\_tuple.neighborMainAddr == tuple.neighborMainAddr)
547         \{
548           \textcolor{keyword}{const} NeighborTuple *nb\_tuple =
549             \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_ae116327f63bf588f61e55c7e3f905787}{FindNeighborTuple} (nb2hop\_tuple.neighborMainAddr);
550           \textcolor{keywordflow}{if} (nb\_tuple == NULL)
551             \{
552               degree++;
553             \}
554         \}
555     \}
556   \textcolor{keywordflow}{return} degree;
557 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 24




Here is the caller graph for this function\+:
% FIG 25


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Do\+Dispose()}{DoDispose()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a4f4847a879139dc41e184b8233573143}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a4f4847a879139dc41e184b8233573143}
Destructor implementation.

This method is called by \hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose()} or by the \hyperlink{classns3_1_1Object}{Object}\textquotesingle{}s destructor, whichever comes first.

Subclasses are expected to implement their real destruction code in an overriden version of this method and chain up to their parent\textquotesingle{}s implementation once they are done. {\itshape i.\+e}, for simplicity, the destructor of every subclass should be empty and its content should be moved to the associated \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a4f4847a879139dc41e184b8233573143}{Do\+Dispose()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.


\begin{DoxyCode}
238 \{
239   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4} = 0;
240   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a398799911ae136e0b247b4bbd608c336}{m\_hnaRoutingTable} = 0;
241   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae631ae3941f563718274166203d3b178}{m\_routingTableAssociation} = 0;
242 
243   \textcolor{keywordflow}{for} (std::map< Ptr<Socket>, Ipv4InterfaceAddress >::iterator iter = 
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae590f1f394f2ebc0fac434a6866d7c75}{m\_socketAddresses}.begin ();
244        iter != \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae590f1f394f2ebc0fac434a6866d7c75}{m\_socketAddresses}.end (); iter++)
245     \{
246       iter->first->Close ();
247     \}
248   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae590f1f394f2ebc0fac434a6866d7c75}{m\_socketAddresses}.clear ();
249 
250   \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{Ipv4RoutingProtocol::DoDispose} ();
251 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 26


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Do\+Initialize@{Do\+Initialize}}
\index{Do\+Initialize@{Do\+Initialize}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Do\+Initialize(void)}{DoInitialize(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Do\+Initialize (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_afe5419799e8d38ee32d82615de55ef22}{}\label{classns3_1_1olsr_1_1RoutingProtocol_afe5419799e8d38ee32d82615de55ef22}
\hyperlink{classns3_1_1Object_af4411cb29971772fcd09203474a95078}{Initialize()} implementation.

This method is called only once by \hyperlink{classns3_1_1Object_af4411cb29971772fcd09203474a95078}{Initialize()}. If the user calls \hyperlink{classns3_1_1Object_af4411cb29971772fcd09203474a95078}{Initialize()} multiple times, \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afe5419799e8d38ee32d82615de55ef22}{Do\+Initialize()} is called only the first time.

Subclasses are expected to override this method and chain up to their parent\textquotesingle{}s implementation once they are done. It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} and \hyperlink{classns3_1_1Object_a79dd435d300f3deca814553f561a2922}{Aggregate\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_af8482a521433409fb5c7f749398c9dbe}{ns3\+::\+Object}.


\begin{DoxyCode}
295 \{
296   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress} == Ipv4Address ())
297     \{
298       Ipv4Address loopback (\textcolor{stringliteral}{"127.0.0.1"});
299       \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4}->GetNInterfaces (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
300         \{
301           \textcolor{comment}{// Use primary address, if multiple}
302           Ipv4Address addr = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, 0).GetLocal ();
303           \textcolor{keywordflow}{if} (addr != loopback)
304             \{
305               \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress} = addr;
306               \textcolor{keywordflow}{break};
307             \}
308         \}
309 
310       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress} != Ipv4Address ());
311     \}
312 
313   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Starting OLSR on node "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress});
314 
315   Ipv4Address loopback (\textcolor{stringliteral}{"127.0.0.1"});
316 
317   \textcolor{keywordtype}{bool} canRunOlsr = \textcolor{keyword}{false};
318   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4}->GetNInterfaces (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
319     \{
320       Ipv4Address addr = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, 0).GetLocal ();
321       \textcolor{keywordflow}{if} (addr == loopback)
322         \{
323           \textcolor{keywordflow}{continue};
324         \}
325 
326       \textcolor{keywordflow}{if} (addr != \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress})
327         \{
328           \textcolor{comment}{// Create never expiring interface association tuple entries for our}
329           \textcolor{comment}{// own network interfaces, so that GetMainAddress () works to}
330           \textcolor{comment}{// translate the node's own interface addresses into the main address.}
331           IfaceAssocTuple tuple;
332           tuple.ifaceAddr = addr;
333           tuple.mainAddr = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress};
334           \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a727294984dac11244bf1e92baa141934}{AddIfaceAssocTuple} (tuple);
335           \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae01451170fb389d322b33ed6d954f460}{GetMainAddress} (addr) == 
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress});
336         \}
337 
338       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afa7fdc171732e31fb92298d62f6340e6}{m\_interfaceExclusions}.find (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) != 
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afa7fdc171732e31fb92298d62f6340e6}{m\_interfaceExclusions}.end ())
339         \{
340           \textcolor{keywordflow}{continue};
341         \}
342 
343       \textcolor{comment}{// Create a socket to listen only on this interface}
344       Ptr<Socket> socket = \hyperlink{classns3_1_1Socket_ad448a62bb50ad3dbac59c879a885a8d2}{Socket::CreateSocket} (GetObject<Node> (),
345                                                  \hyperlink{classns3_1_1UdpSocketFactory_ad5b47e944de8861e3dc2b6de1ccbdf5b}{UdpSocketFactory::GetTypeId} ())
      ;
346       socket->SetAllowBroadcast (\textcolor{keyword}{true});
347       InetSocketAddress inetAddr (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, 0).GetLocal (), 
      \hyperlink{olsr-routing-protocol_8cc_a56099fb2a14f4a74c5e155c13e9ef8db}{OLSR\_PORT\_NUMBER});
348       socket->SetRecvCallback (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afa449e39488b5c03609960e66553490e}{RoutingProtocol::RecvOlsr},  \textcolor{keyword}{this}));
349       \textcolor{keywordflow}{if} (socket->Bind (inetAddr))
350         \{
351           \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Failed to bind() OLSR socket"});
352         \}
353       socket->BindToNetDevice (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4}->GetNetDevice (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}));
354       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae590f1f394f2ebc0fac434a6866d7c75}{m\_socketAddresses}[socket] = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, 0);
355 
356       canRunOlsr = \textcolor{keyword}{true};
357     \}
358 
359   \textcolor{keywordflow}{if} (canRunOlsr)
360     \{
361       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a5f10703d9d0e82e48466ab69838c7b2b}{HelloTimerExpire} ();
362       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ad9443857cbc18e1fe48848106c40c96f}{TcTimerExpire} ();
363       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_adb532d5890ea3954e8ab73a625d53e66}{MidTimerExpire} ();
364       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a6ef2a79ac872935b84a3f1d54316456d}{HnaTimerExpire} ();
365 
366       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"OLSR on node "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress} << \textcolor{stringliteral}{" started"});
367     \}
368 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 27


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Dump@{Dump}}
\index{Dump@{Dump}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Dump(void)}{Dump(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Dump (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_ac4958795cfe7a164514c3e1a09e159ab}{}\label{classns3_1_1olsr_1_1RoutingProtocol_ac4958795cfe7a164514c3e1a09e159ab}
Dump the neighbor table, two-\/hop neighbor table, and routing table to logging output (N\+S\+\_\+\+L\+O\+G\+\_\+\+D\+E\+B\+UG log level). If logging is disabled, this function does nothing. 
\begin{DoxyCode}
3099 \{
3100 \textcolor{preprocessor}{#ifdef NS3\_LOG\_ENABLE}
3101   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} now = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ();
3102   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Dumping for node with main address "} << 
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress});
3103   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{" Neighbor set"});
3104   \textcolor{keywordflow}{for} (NeighborSet::const\_iterator iter = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a82d5882ca3fdb93a9c1110c6f176c03c}{GetNeighbors} ().begin ();
3105        iter != \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a82d5882ca3fdb93a9c1110c6f176c03c}{GetNeighbors} ().end (); iter++)
3106     \{
3107       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"  "} << *iter);
3108     \}
3109   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{" Two-hop neighbor set"});
3110   \textcolor{keywordflow}{for} (TwoHopNeighborSet::const\_iterator iter = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.
      \hyperlink{classns3_1_1olsr_1_1OlsrState_ab03738874d0d785b770beef6dc9c2e1a}{GetTwoHopNeighbors} ().begin ();
3111        iter != \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_ab03738874d0d785b770beef6dc9c2e1a}{GetTwoHopNeighbors} ().end (); iter++)
3112     \{
3113       \textcolor{keywordflow}{if} (now < iter->expirationTime)
3114         \{
3115           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"  "} << *iter);
3116         \}
3117     \}
3118   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{" Routing table"});
3119   \textcolor{keywordflow}{for} (std::map<Ipv4Address, RoutingTableEntry>::const\_iterator iter = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a9703fb92cc9a864c0e2874387ead3aa3}{m\_table}.begin (); iter != 
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a9703fb92cc9a864c0e2874387ead3aa3}{m\_table}.end (); iter++)
3120     \{
3121       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"  dest="} << iter->first << \textcolor{stringliteral}{" --> next="} << iter->second.nextAddr << \textcolor{stringliteral}{" via
       interface "} << iter->second.interface);
3122     \}
3123   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{""});
3124 \textcolor{preprocessor}{#endif  //NS3\_LOG\_ENABLE}
3125 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 28


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Dup\+Tuple\+Timer\+Expire@{Dup\+Tuple\+Timer\+Expire}}
\index{Dup\+Tuple\+Timer\+Expire@{Dup\+Tuple\+Timer\+Expire}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Dup\+Tuple\+Timer\+Expire(\+Ipv4\+Address address, uint16\+\_\+t sequence\+Number)}{DupTupleTimerExpire(Ipv4Address address, uint16_t sequenceNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Dup\+Tuple\+Timer\+Expire (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{address, }
\item[{uint16\+\_\+t}]{sequence\+Number}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a78f4aad4a5597ab60fa913e917eabbec}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a78f4aad4a5597ab60fa913e917eabbec}


Removes tuple if expired. Else timer is rescheduled to expire at tuple.\+expiration\+Time. 

The task of actually removing the tuple is left to the O\+L\+SR agent.


\begin{DoxyParams}{Parameters}
{\em address} & The address of the tuple. \\
\hline
{\em sequence\+Number} & The sequence number of the tuple. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2609 \{
2610   DuplicateTuple *tuple =
2611     \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_ab00d5bb24a075329d19cf44af31524d1}{FindDuplicateTuple} (address, sequenceNumber);
2612   \textcolor{keywordflow}{if} (tuple == NULL)
2613     \{
2614       \textcolor{keywordflow}{return};
2615     \}
2616   \textcolor{keywordflow}{if} (tuple->expirationTime < \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ())
2617     \{
2618       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a72a3220cc44a4fadc7156bfc2603e547}{RemoveDuplicateTuple} (*tuple);
2619     \}
2620   \textcolor{keywordflow}{else}
2621     \{
2622       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a80368d3da46150cf3fc9139c40f33d53}{m\_events}.\hyperlink{classns3_1_1EventGarbageCollector_a4f26a1f6e9a09e648eb31b46acd85144}{Track} (\hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{olsr-routing-protocol_8cc_ad0a00c3386c4a24278b3b710ae798220}{DELAY} (tuple->
      expirationTime),
2623                                            &\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a78f4aad4a5597ab60fa913e917eabbec}{RoutingProtocol::DupTupleTimerExpire}
      , \textcolor{keyword}{this},
2624                                            address, sequenceNumber));
2625     \}
2626 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 29




Here is the caller graph for this function\+:
% FIG 30


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Find\+Send\+Entry@{Find\+Send\+Entry}}
\index{Find\+Send\+Entry@{Find\+Send\+Entry}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Find\+Send\+Entry(const Routing\+Table\+Entry \&entry, Routing\+Table\+Entry \&out\+Entry) const }{FindSendEntry(const RoutingTableEntry &entry, RoutingTableEntry &outEntry) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::olsr\+::\+Routing\+Protocol\+::\+Find\+Send\+Entry (
\begin{DoxyParamCaption}
\item[{const {\bf Routing\+Table\+Entry} \&}]{entry, }
\item[{{\bf Routing\+Table\+Entry} \&}]{out\+Entry}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a15394858cdfb821d54f8661ed712083c}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a15394858cdfb821d54f8661ed712083c}


Finds the appropriate entry which must be used in order to forward a data packet to a next hop (given a destination). 

Imagine a routing table like this\+: \mbox{[}A,B\mbox{]} \mbox{[}B,C\mbox{]} \mbox{[}C,C\mbox{]}; being each pair of the form \mbox{[}dest addr, next-\/hop addr\mbox{]}. In this case, if this function is invoked with \mbox{[}A,B\mbox{]} then pair \mbox{[}C,C\mbox{]} is returned because C is the next hop that must be used to forward a data packet destined to A. That is, C is a neighbor of this node, but B isn\textquotesingle{}t. This function finds the appropriate neighbor for forwarding a packet.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em entry} & The routing table entry which indicates the destination node we are interested in.\\
\hline
\mbox{\tt out}  & {\em out\+Entry} & The appropriate routing table entry which indicates the next hop which must be used for forwarding a data packet, or N\+U\+LL if there is no such entry.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if an entry was found, false otherwise. 
\end{DoxyReturn}

\begin{DoxyCode}
2799 \{
2800   outEntry = entry;
2801   \textcolor{keywordflow}{while} (outEntry.destAddr != outEntry.nextAddr)
2802     \{
2803       \textcolor{keywordflow}{if} (not \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a514bf401454b233af509476fc3fd5d6b}{Lookup} (outEntry.nextAddr, outEntry))
2804         \{
2805           \textcolor{keywordflow}{return} \textcolor{keyword}{false};
2806         \}
2807     \}
2808   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
2809 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 31




Here is the caller graph for this function\+:
% FIG 32


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Forward\+Default@{Forward\+Default}}
\index{Forward\+Default@{Forward\+Default}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Forward\+Default(olsr\+::\+Message\+Header olsr\+Message, Duplicate\+Tuple $\ast$duplicated, const Ipv4\+Address \&local\+Iface, const Ipv4\+Address \&sender\+Address)}{ForwardDefault(olsr::MessageHeader olsrMessage, DuplicateTuple *duplicated, const Ipv4Address &localIface, const Ipv4Address &senderAddress)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Forward\+Default (
\begin{DoxyParamCaption}
\item[{{\bf olsr\+::\+Message\+Header}}]{olsr\+Message, }
\item[{{\bf Duplicate\+Tuple} $\ast$}]{duplicated, }
\item[{const {\bf Ipv4\+Address} \&}]{local\+Iface, }
\item[{const {\bf Ipv4\+Address} \&}]{sender\+Address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_ac918fb6674847bee76fedaf16e15ba44}{}\label{classns3_1_1olsr_1_1RoutingProtocol_ac918fb6674847bee76fedaf16e15ba44}


O\+L\+SR\textquotesingle{}s default forwarding algorithm. 

See \{3626\} for details.


\begin{DoxyParams}{Parameters}
{\em olsr\+Message} & The O\+L\+SR message which must be forwarded. \\
\hline
{\em duplicated} & N\+U\+LL if the message has never been considered for forwarding, or a duplicate tuple in other case. \\
\hline
{\em local\+Iface} & The address of the interface where the message was received from. \\
\hline
{\em sender\+Address} & The sender I\+Pv4 address. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1500 \{
1501   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} now = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ();
1502 
1503   \textcolor{comment}{// If the sender interface address is not in the symmetric}
1504   \textcolor{comment}{// 1-hop neighborhood the message must not be forwarded}
1505   \textcolor{keyword}{const} LinkTuple *linkTuple = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a5005529fbbd5fa4a015591a93d715890}{FindSymLinkTuple} (senderAddress, now);
1506   \textcolor{keywordflow}{if} (linkTuple == NULL)
1507     \{
1508       \textcolor{keywordflow}{return};
1509     \}
1510 
1511   \textcolor{comment}{// If the message has already been considered for forwarding,}
1512   \textcolor{comment}{// it must not be retransmitted again}
1513   \textcolor{keywordflow}{if} (duplicated != NULL && duplicated->retransmitted)
1514     \{
1515       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} () << \textcolor{stringliteral}{"Node "} << 
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress} << \textcolor{stringliteral}{" does not forward a message received"}
1516                     \textcolor{stringliteral}{" from "} << olsrMessage.GetOriginatorAddress () << \textcolor{stringliteral}{" because it is duplicated"});
1517       \textcolor{keywordflow}{return};
1518     \}
1519 
1520   \textcolor{comment}{// If the sender interface address is an interface address}
1521   \textcolor{comment}{// of a MPR selector of this node and ttl is greater than 1,}
1522   \textcolor{comment}{// the message must be retransmitted}
1523   \textcolor{keywordtype}{bool} retransmitted = \textcolor{keyword}{false};
1524   \textcolor{keywordflow}{if} (olsrMessage.GetTimeToLive () > 1)
1525     \{
1526       \textcolor{keyword}{const} MprSelectorTuple *mprselTuple =
1527         \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a81bb1e9642f6b840094d199d3654b984}{FindMprSelectorTuple} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae01451170fb389d322b33ed6d954f460}{GetMainAddress} (
      senderAddress));
1528       \textcolor{keywordflow}{if} (mprselTuple != NULL)
1529         \{
1530           olsrMessage.SetTimeToLive (olsrMessage.GetTimeToLive () - 1);
1531           olsrMessage.SetHopCount (olsrMessage.GetHopCount () + 1);
1532           \textcolor{comment}{// We have to introduce a random delay to avoid}
1533           \textcolor{comment}{// synchronization with neighbors.}
1534           \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a206c7c0bba382cba1ac50d11a7df88f3}{QueueMessage} (olsrMessage, \hyperlink{olsr-routing-protocol_8cc_a06863e04dddc5f7fbbedb516974df4b3}{JITTER});
1535           retransmitted = \textcolor{keyword}{true};
1536         \}
1537     \}
1538 
1539   \textcolor{comment}{// Update duplicate tuple...}
1540   \textcolor{keywordflow}{if} (duplicated != NULL)
1541     \{
1542       duplicated->expirationTime = now + \hyperlink{olsr-routing-protocol_8cc_ab108121273061d42abc9819edccc06d2}{OLSR\_DUP\_HOLD\_TIME};
1543       duplicated->retransmitted = retransmitted;
1544       duplicated->ifaceList.push\_back (localIface);
1545     \}
1546   \textcolor{comment}{// ...or create a new one}
1547   \textcolor{keywordflow}{else}
1548     \{
1549       DuplicateTuple newDup;
1550       newDup.address = olsrMessage.GetOriginatorAddress ();
1551       newDup.sequenceNumber = olsrMessage.GetMessageSequenceNumber ();
1552       newDup.expirationTime = now + \hyperlink{olsr-routing-protocol_8cc_ab108121273061d42abc9819edccc06d2}{OLSR\_DUP\_HOLD\_TIME};
1553       newDup.retransmitted = retransmitted;
1554       newDup.ifaceList.push\_back (localIface);
1555       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ad863ed4e771bfe7ee021892ddacd2691}{AddDuplicateTuple} (newDup);
1556       \textcolor{comment}{// Schedule dup tuple deletion}
1557       \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (OLSR\_DUP\_HOLD\_TIME,
1558                            &\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a78f4aad4a5597ab60fa913e917eabbec}{RoutingProtocol::DupTupleTimerExpire}, \textcolor{keyword}{this},
1559                            newDup.address, newDup.sequenceNumber);
1560     \}
1561 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 33




Here is the caller graph for this function\+:
% FIG 34


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Get\+Interface\+Exclusions@{Get\+Interface\+Exclusions}}
\index{Get\+Interface\+Exclusions@{Get\+Interface\+Exclusions}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Interface\+Exclusions() const }{GetInterfaceExclusions() const }}]{\setlength{\rightskip}{0pt plus 5cm}std\+::set$<$uint32\+\_\+t$>$ ns3\+::olsr\+::\+Routing\+Protocol\+::\+Get\+Interface\+Exclusions (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_af49d8e372249668ec53cf329a4cf2253}{}\label{classns3_1_1olsr_1_1RoutingProtocol_af49d8e372249668ec53cf329a4cf2253}
Get the excluded interfaces. \begin{DoxyReturn}{Returns}
Container of excluded interfaces. 
\end{DoxyReturn}

\begin{DoxyCode}
148   \{
149     \textcolor{keywordflow}{return} \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afa7fdc171732e31fb92298d62f6340e6}{m\_interfaceExclusions};
150   \}
\end{DoxyCode}
\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Get\+Main\+Address@{Get\+Main\+Address}}
\index{Get\+Main\+Address@{Get\+Main\+Address}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Main\+Address(\+Ipv4\+Address iface\+\_\+addr) const }{GetMainAddress(Ipv4Address iface_addr) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Address} ns3\+::olsr\+::\+Routing\+Protocol\+::\+Get\+Main\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{iface\+\_\+addr}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_ae01451170fb389d322b33ed6d954f460}{}\label{classns3_1_1olsr_1_1RoutingProtocol_ae01451170fb389d322b33ed6d954f460}


Gets the main address associated with a given interface address. 


\begin{DoxyParams}{Parameters}
{\em iface\+\_\+addr} & the interface address. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the corresponding main address. 
\end{DoxyReturn}

\begin{DoxyCode}
891 \{
892   \textcolor{keyword}{const} IfaceAssocTuple *tuple =
893     \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a35a68caeae507605f294290967216d50}{FindIfaceAssocTuple} (iface\_addr);
894 
895   \textcolor{keywordflow}{if} (tuple != NULL)
896     \{
897       \textcolor{keywordflow}{return} tuple->\hyperlink{structns3_1_1olsr_1_1IfaceAssocTuple_ab8718ae7260c4fcdf68fbdb3e86831c2}{mainAddr};
898     \}
899   \textcolor{keywordflow}{else}
900     \{
901       \textcolor{keywordflow}{return} iface\_addr;
902     \}
903 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 35




Here is the caller graph for this function\+:
% FIG 36


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Get\+Message\+Sequence\+Number@{Get\+Message\+Sequence\+Number}}
\index{Get\+Message\+Sequence\+Number@{Get\+Message\+Sequence\+Number}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Message\+Sequence\+Number()}{GetMessageSequenceNumber()}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::olsr\+::\+Routing\+Protocol\+::\+Get\+Message\+Sequence\+Number (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_af8656b873ecc22d25d5e5795f936d61a}{}\label{classns3_1_1olsr_1_1RoutingProtocol_af8656b873ecc22d25d5e5795f936d61a}
Increments message sequence number and returns the new value. \begin{DoxyReturn}{Returns}
The message sequence number. 
\end{DoxyReturn}

\begin{DoxyCode}
2560 \{
2561   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a0f6d3f3ae8a78fbf2e2522d9f21e23ca}{m\_messageSequenceNumber} = (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a0f6d3f3ae8a78fbf2e2522d9f21e23ca}{m\_messageSequenceNumber} + 1) % (
      \hyperlink{olsr-routing-protocol_8cc_a33c0bdae6376cc58e151fdd28db2a33b}{OLSR\_MAX\_SEQ\_NUM} + 1);
2562   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a0f6d3f3ae8a78fbf2e2522d9f21e23ca}{m\_messageSequenceNumber};
2563 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 37


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Get\+Packet\+Sequence\+Number@{Get\+Packet\+Sequence\+Number}}
\index{Get\+Packet\+Sequence\+Number@{Get\+Packet\+Sequence\+Number}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Packet\+Sequence\+Number()}{GetPacketSequenceNumber()}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::olsr\+::\+Routing\+Protocol\+::\+Get\+Packet\+Sequence\+Number (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_ab7cac75ba09d451d4cc12acb2030fbee}{}\label{classns3_1_1olsr_1_1RoutingProtocol_ab7cac75ba09d451d4cc12acb2030fbee}
Increments packet sequence number and returns the new value. \begin{DoxyReturn}{Returns}
The packet sequence number. 
\end{DoxyReturn}

\begin{DoxyCode}
2554 \{
2555   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_aa5051691fb81c7109b9e2b6c54b43b7f}{m\_packetSequenceNumber} = (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_aa5051691fb81c7109b9e2b6c54b43b7f}{m\_packetSequenceNumber} + 1) % (
      \hyperlink{olsr-routing-protocol_8cc_a33c0bdae6376cc58e151fdd28db2a33b}{OLSR\_MAX\_SEQ\_NUM} + 1);
2556   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_aa5051691fb81c7109b9e2b6c54b43b7f}{m\_packetSequenceNumber};
2557 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 38


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Get\+Routing\+Table\+Association@{Get\+Routing\+Table\+Association}}
\index{Get\+Routing\+Table\+Association@{Get\+Routing\+Table\+Association}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Routing\+Table\+Association() const }{GetRoutingTableAssociation() const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ const {\bf Ipv4\+Static\+Routing} $>$ ns3\+::olsr\+::\+Routing\+Protocol\+::\+Get\+Routing\+Table\+Association (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a3fe8efac9decd461ef713cf4451121dd}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a3fe8efac9decd461ef713cf4451121dd}


Returns the internal H\+NA table. 

\begin{DoxyReturn}{Returns}
the internal H\+NA table 
\end{DoxyReturn}

\begin{DoxyCode}
3129 \{
3130   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a398799911ae136e0b247b4bbd608c336}{m\_hnaRoutingTable};
3131 \}
\end{DoxyCode}
\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Get\+Routing\+Table\+Entries@{Get\+Routing\+Table\+Entries}}
\index{Get\+Routing\+Table\+Entries@{Get\+Routing\+Table\+Entries}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Routing\+Table\+Entries() const }{GetRoutingTableEntries() const }}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<$ {\bf Routing\+Table\+Entry} $>$ ns3\+::olsr\+::\+Routing\+Protocol\+::\+Get\+Routing\+Table\+Entries (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a81a605ea088a3508a27414a263a725af}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a81a605ea088a3508a27414a263a725af}
Return the list of routing table entries discovered by O\+L\+SR 
\begin{DoxyCode}
3064 \{
3065   std::vector<RoutingTableEntry> retval;
3066   \textcolor{keywordflow}{for} (std::map<Ipv4Address, RoutingTableEntry>::const\_iterator iter = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a9703fb92cc9a864c0e2874387ead3aa3}{m\_table}.begin ();
3067        iter != \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a9703fb92cc9a864c0e2874387ead3aa3}{m\_table}.end (); iter++)
3068     \{
3069       retval.push\_back (iter->second);
3070     \}
3071   \textcolor{keywordflow}{return} retval;
3072 \}
\end{DoxyCode}
\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Get\+Size@{Get\+Size}}
\index{Get\+Size@{Get\+Size}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Size() const }{GetSize() const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::olsr\+::\+Routing\+Protocol\+::\+Get\+Size (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_afbbc663c6c3e814b0a71aa4b44312abb}{}\label{classns3_1_1olsr_1_1RoutingProtocol_afbbc663c6c3e814b0a71aa4b44312abb}
Returns the routing table size. \begin{DoxyReturn}{Returns}
The routing table size. 
\end{DoxyReturn}

\begin{DoxyCode}
228   \{
229     \textcolor{keywordflow}{return} \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a9703fb92cc9a864c0e2874387ead3aa3}{m\_table}.size ();
230   \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 39




Here is the caller graph for this function\+:
% FIG 40


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::olsr\+::\+Routing\+Protocol\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a8c75d345a2a52bc56919f469d3e09849}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a8c75d345a2a52bc56919f469d3e09849}


Get the type ID. 

\begin{DoxyReturn}{Returns}
The object \hyperlink{classns3_1_1TypeId}{Type\+Id}. 
\end{DoxyReturn}

\begin{DoxyCode}
153 \{
154   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::olsr::RoutingProtocol"})
155     .SetParent<Ipv4RoutingProtocol> ()
156     .SetGroupName (\textcolor{stringliteral}{"Olsr"})
157     .AddConstructor<\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a3415aee30083fbfc432e985ec1e68125}{RoutingProtocol}> ()
158     .AddAttribute (\textcolor{stringliteral}{"HelloInterval"}, \textcolor{stringliteral}{"HELLO messages emission interval."},
159                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (2)),
160                    MakeTimeAccessor (&\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ac973c86cbf21168c11cd7f16acc1ae4c}{RoutingProtocol::m\_helloInterval}),
161                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
162     .AddAttribute (\textcolor{stringliteral}{"TcInterval"}, \textcolor{stringliteral}{"TC messages emission interval."},
163                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (5)),
164                    MakeTimeAccessor (&\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae282dcb4112be0b4f2ac8f413b022fa9}{RoutingProtocol::m\_tcInterval}),
165                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
166     .AddAttribute (\textcolor{stringliteral}{"MidInterval"}, \textcolor{stringliteral}{"MID messages emission interval.  Normally it is equal to TcInterval."},
167                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (5)),
168                    MakeTimeAccessor (&\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a9109a692ebfe241e01a68a584a4961b9}{RoutingProtocol::m\_midInterval}),
169                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
170     .AddAttribute (\textcolor{stringliteral}{"HnaInterval"}, \textcolor{stringliteral}{"HNA messages emission interval.  Normally it is equal to TcInterval."},
171                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (5)),
172                    MakeTimeAccessor (&\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a0d117664d5991c4b405b9ef14c33ea23}{RoutingProtocol::m\_hnaInterval}),
173                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
174     .AddAttribute (\textcolor{stringliteral}{"Willingness"}, \textcolor{stringliteral}{"Willingness of a node to carry and forward traffic for other nodes."},
175                    EnumValue (\hyperlink{olsr-routing-protocol_8cc_a0b87d49ad8114eabe8dd6eecfb6858e1}{OLSR\_WILL\_DEFAULT}),
176                    \hyperlink{namespacens3_af5050739867ce63896dec011e332c8ec}{MakeEnumAccessor} (&
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a2e94c2954ffa92d1c7d3b627087c9430}{RoutingProtocol::m\_willingness}),
177                    \hyperlink{namespacens3_a48832781a2b521d3d0091e05ece30615}{MakeEnumChecker} (\hyperlink{olsr-routing-protocol_8cc_a146d2c103abd49bdfad44b4424769696}{OLSR\_WILL\_NEVER}, \textcolor{stringliteral}{"never"},
178                                     \hyperlink{olsr-routing-protocol_8cc_af5179e8ea62927c15150f279ce4bf0c7}{OLSR\_WILL\_LOW}, \textcolor{stringliteral}{"low"},
179                                     \hyperlink{olsr-routing-protocol_8cc_a0b87d49ad8114eabe8dd6eecfb6858e1}{OLSR\_WILL\_DEFAULT}, \textcolor{stringliteral}{"default"},
180                                     \hyperlink{olsr-routing-protocol_8cc_ac18eca80c0f239fb80d32461d51e3644}{OLSR\_WILL\_HIGH}, \textcolor{stringliteral}{"high"},
181                                     \hyperlink{olsr-routing-protocol_8cc_a47254d140ed26351d672c338a8cda435}{OLSR\_WILL\_ALWAYS}, \textcolor{stringliteral}{"always"}))
182     .AddTraceSource (\textcolor{stringliteral}{"Rx"}, \textcolor{stringliteral}{"Receive OLSR packet."},
183                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a861b1d2ce370ab0137e67c5a1102a937}{RoutingProtocol::m\_rxPacketTrace}),
184                      \textcolor{stringliteral}{"ns3::olsr::RoutingProtocol::PacketTxRxTracedCallback"})
185     .AddTraceSource (\textcolor{stringliteral}{"Tx"}, \textcolor{stringliteral}{"Send OLSR packet."},
186                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_aadd8d4fea9a32b185bf23d787004de9d}{RoutingProtocol::m\_txPacketTrace}),
187                      \textcolor{stringliteral}{"ns3::olsr::RoutingProtocol::PacketTxRxTracedCallback"})
188     .AddTraceSource (\textcolor{stringliteral}{"RoutingTableChanged"}, \textcolor{stringliteral}{"The OLSR routing table has changed."},
189                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a1cbaa4bdf90462b6d8e0ddc90eaa4130}{RoutingProtocol::m\_routingTableChanged}),
190                      \textcolor{stringliteral}{"ns3::olsr::RoutingProtocol::TableChangeTracedCallback"})
191   ;
192   \textcolor{keywordflow}{return} tid;
193 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 41


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Hello\+Timer\+Expire@{Hello\+Timer\+Expire}}
\index{Hello\+Timer\+Expire@{Hello\+Timer\+Expire}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Hello\+Timer\+Expire()}{HelloTimerExpire()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Hello\+Timer\+Expire (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a5f10703d9d0e82e48466ab69838c7b2b}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a5f10703d9d0e82e48466ab69838c7b2b}


Sends a H\+E\+L\+LO message and reschedules the H\+E\+L\+LO timer. 


\begin{DoxyCode}
2567 \{
2568   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a3b24f29bfb5d4bfa60e0ca1eb28a8b13}{SendHello} ();
2569   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_aa739535b4dfd71566cb385c9c58f59c9}{m\_helloTimer}.\hyperlink{classns3_1_1Timer_ac3345d696887578f518b19f359f7f94b}{Schedule} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ac973c86cbf21168c11cd7f16acc1ae4c}{m\_helloInterval});
2570 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 42




Here is the caller graph for this function\+:
% FIG 43


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Hna\+Timer\+Expire@{Hna\+Timer\+Expire}}
\index{Hna\+Timer\+Expire@{Hna\+Timer\+Expire}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Hna\+Timer\+Expire()}{HnaTimerExpire()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Hna\+Timer\+Expire (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a6ef2a79ac872935b84a3f1d54316456d}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a6ef2a79ac872935b84a3f1d54316456d}


Sends an H\+NA message (if the node has associated hosts/networks) and reschedules the H\+NA timer. 


\begin{DoxyCode}
2595 \{
2596   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_af0d7450ccc6238bb018e8f22fcaf0552}{GetAssociations} ().size () > 0)
2597     \{
2598       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a02fe3cc6e62962d002818651fc6988df}{SendHna} ();
2599     \}
2600   \textcolor{keywordflow}{else}
2601     \{
2602       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Not sending any HNA, no associations to advertise."});
2603     \}
2604   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_acaf11a25b83098c640a063a094148374}{m\_hnaTimer}.\hyperlink{classns3_1_1Timer_ac3345d696887578f518b19f359f7f94b}{Schedule} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a0d117664d5991c4b405b9ef14c33ea23}{m\_hnaInterval});
2605 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 44




Here is the caller graph for this function\+:
% FIG 45


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Iface\+Assoc\+Tuple\+Timer\+Expire@{Iface\+Assoc\+Tuple\+Timer\+Expire}}
\index{Iface\+Assoc\+Tuple\+Timer\+Expire@{Iface\+Assoc\+Tuple\+Timer\+Expire}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Iface\+Assoc\+Tuple\+Timer\+Expire(\+Ipv4\+Address iface\+Addr)}{IfaceAssocTupleTimerExpire(Ipv4Address ifaceAddr)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Iface\+Assoc\+Tuple\+Timer\+Expire (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{iface\+Addr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_af93aa9d349c1be0aef8401d2e4189d4c}{}\label{classns3_1_1olsr_1_1RoutingProtocol_af93aa9d349c1be0aef8401d2e4189d4c}


Removes interface association tuple\+\_\+ if expired. Else the timer is rescheduled to expire at tuple\+\_\+-\/$>$time(). 


\begin{DoxyParams}{Parameters}
{\em iface\+Addr} & The interface address. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2729 \{
2730   IfaceAssocTuple *tuple = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a35a68caeae507605f294290967216d50}{FindIfaceAssocTuple} (ifaceAddr);
2731   \textcolor{keywordflow}{if} (tuple == NULL)
2732     \{
2733       \textcolor{keywordflow}{return};
2734     \}
2735   \textcolor{keywordflow}{if} (tuple->time < \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ())
2736     \{
2737       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a8ecb5343f7e51de7be585b06dbb1b721}{RemoveIfaceAssocTuple} (*tuple);
2738     \}
2739   \textcolor{keywordflow}{else}
2740     \{
2741       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a80368d3da46150cf3fc9139c40f33d53}{m\_events}.\hyperlink{classns3_1_1EventGarbageCollector_a4f26a1f6e9a09e648eb31b46acd85144}{Track} (\hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{olsr-routing-protocol_8cc_ad0a00c3386c4a24278b3b710ae798220}{DELAY} (tuple->time),
2742                                            &
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_af93aa9d349c1be0aef8401d2e4189d4c}{RoutingProtocol::IfaceAssocTupleTimerExpire},
2743                                            \textcolor{keyword}{this}, ifaceAddr));
2744     \}
2745 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 46




Here is the caller graph for this function\+:
% FIG 47


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Increment\+Ansn@{Increment\+Ansn}}
\index{Increment\+Ansn@{Increment\+Ansn}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Increment\+Ansn()}{IncrementAnsn()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Increment\+Ansn (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_ac1cfaea5b2ba8a3b32e39256b0221774}{}\label{classns3_1_1olsr_1_1RoutingProtocol_ac1cfaea5b2ba8a3b32e39256b0221774}
Increments the A\+N\+SN counter. 
\begin{DoxyCode}
2463 \{
2464   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a8c7b6d3b6eab86260e8ac9848e6f2621}{m\_ansn} = (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a8c7b6d3b6eab86260e8ac9848e6f2621}{m\_ansn} + 1) % (\hyperlink{olsr-routing-protocol_8cc_a33c0bdae6376cc58e151fdd28db2a33b}{OLSR\_MAX\_SEQ\_NUM} + 1);
2465 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 48


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Is\+My\+Own\+Address@{Is\+My\+Own\+Address}}
\index{Is\+My\+Own\+Address@{Is\+My\+Own\+Address}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Is\+My\+Own\+Address(const Ipv4\+Address \&a) const }{IsMyOwnAddress(const Ipv4Address &a) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::olsr\+::\+Routing\+Protocol\+::\+Is\+My\+Own\+Address (
\begin{DoxyParamCaption}
\item[{const {\bf Ipv4\+Address} \&}]{a}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a651b14b759452a21133cde6ef0f2f873}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a651b14b759452a21133cde6ef0f2f873}


Check that address is one of my interfaces. 


\begin{DoxyCode}
3084 \{
3085   \textcolor{keywordflow}{for} (std::map<Ptr<Socket>, Ipv4InterfaceAddress>::const\_iterator j =
3086          \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae590f1f394f2ebc0fac434a6866d7c75}{m\_socketAddresses}.begin (); j != \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae590f1f394f2ebc0fac434a6866d7c75}{m\_socketAddresses}.end (); ++j)
3087     \{
3088       Ipv4InterfaceAddress iface = j->second;
3089       \textcolor{keywordflow}{if} (a == iface.GetLocal ())
3090         \{
3091           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
3092         \}
3093     \}
3094   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
3095 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 49




Here is the caller graph for this function\+:
% FIG 50


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Link\+Sensing@{Link\+Sensing}}
\index{Link\+Sensing@{Link\+Sensing}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Link\+Sensing(const olsr\+::\+Message\+Header \&msg, const olsr\+::\+Message\+Header\+::\+Hello \&hello, const Ipv4\+Address \&receiver\+Iface, const Ipv4\+Address \&sender\+Iface)}{LinkSensing(const olsr::MessageHeader &msg, const olsr::MessageHeader::Hello &hello, const Ipv4Address &receiverIface, const Ipv4Address &senderIface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Link\+Sensing (
\begin{DoxyParamCaption}
\item[{const {\bf olsr\+::\+Message\+Header} \&}]{msg, }
\item[{const {\bf olsr\+::\+Message\+Header\+::\+Hello} \&}]{hello, }
\item[{const {\bf Ipv4\+Address} \&}]{receiver\+Iface, }
\item[{const {\bf Ipv4\+Address} \&}]{sender\+Iface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a2a23a0fd6fa714fef6613afd3f5bc1d2}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a2a23a0fd6fa714fef6613afd3f5bc1d2}


Updates Link Set according to a new received H\+E\+L\+LO message (following \{3626\} specification). Neighbor Set is also updated if needed. 


\begin{DoxyParams}{Parameters}
{\em msg} & The received message. \\
\hline
{\em hello} & The received H\+E\+L\+LO sub-\/message. \\
\hline
{\em receiver\+Iface} & The interface that received the message. \\
\hline
{\em sender\+Iface} & The sender interface. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1931 \{
1932   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} now = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ();
1933   \textcolor{keywordtype}{bool} updated = \textcolor{keyword}{false};
1934   \textcolor{keywordtype}{bool} created = \textcolor{keyword}{false};
1935   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"@"} << now.GetSeconds () << \textcolor{stringliteral}{": Olsr node "} << 
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress}
1936                     << \textcolor{stringliteral}{": LinkSensing(receiverIface="} << receiverIface
1937                     << \textcolor{stringliteral}{", senderIface="} << senderIface << \textcolor{stringliteral}{") BEGIN"});
1938 
1939   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (msg.GetVTime () > \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (0));
1940   LinkTuple *link\_tuple = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_aba76198953220cce4526761bf30a216c}{FindLinkTuple} (senderIface);
1941   \textcolor{keywordflow}{if} (link\_tuple == NULL)
1942     \{
1943       LinkTuple newLinkTuple;
1944       \textcolor{comment}{// We have to create a new tuple}
1945       newLinkTuple.\hyperlink{structns3_1_1olsr_1_1LinkTuple_af96017826789616c7bf4f59a193f3939}{neighborIfaceAddr} = senderIface;
1946       newLinkTuple.localIfaceAddr = receiverIface;
1947       newLinkTuple.symTime = now - \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (1);
1948       newLinkTuple.time = now + msg.GetVTime ();
1949       link\_tuple = &\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_ad682801a30a1867d639d5489f0510bf9}{InsertLinkTuple} (newLinkTuple);
1950       created = \textcolor{keyword}{true};
1951       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Existing link tuple did not exist => creating new one"});
1952     \}
1953   \textcolor{keywordflow}{else}
1954     \{
1955       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Existing link tuple already exists => will update it"});
1956       updated = \textcolor{keyword}{true};
1957     \}
1958 
1959   link\_tuple->asymTime = now + msg.GetVTime ();
1960   \textcolor{keywordflow}{for} (std::vector<olsr::MessageHeader::Hello::LinkMessage>::const\_iterator linkMessage =
1961          hello.linkMessages.begin ();
1962        linkMessage != hello.linkMessages.end ();
1963        linkMessage++)
1964     \{
1965       \textcolor{keywordtype}{int} lt = linkMessage->linkCode & 0x03; \textcolor{comment}{// Link Type}
1966       \textcolor{keywordtype}{int} nt = (linkMessage->linkCode >> 2) & 0x03; \textcolor{comment}{// Neighbor Type}
1967 
1968 \textcolor{preprocessor}{#ifdef NS3\_LOG\_ENABLE}
1969       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *linkTypeName;
1970       \textcolor{keywordflow}{switch} (lt)
1971         \{
1972         \textcolor{keywordflow}{case} \hyperlink{olsr-routing-protocol_8cc_a5c8faefa61edbdfbca0858c3cc09e463}{OLSR\_UNSPEC\_LINK}:
1973           linkTypeName = \textcolor{stringliteral}{"UNSPEC\_LINK"};
1974           \textcolor{keywordflow}{break};
1975         \textcolor{keywordflow}{case} \hyperlink{olsr-routing-protocol_8cc_a8ebf1daea9834b2e4dfb42ca05b05f4a}{OLSR\_ASYM\_LINK}:
1976           linkTypeName = \textcolor{stringliteral}{"ASYM\_LINK"};
1977           \textcolor{keywordflow}{break};
1978         \textcolor{keywordflow}{case} \hyperlink{olsr-routing-protocol_8cc_aa7acefeda0e22f22d9ca6b9f445859d7}{OLSR\_SYM\_LINK}:
1979           linkTypeName = \textcolor{stringliteral}{"SYM\_LINK"};
1980           \textcolor{keywordflow}{break};
1981         \textcolor{keywordflow}{case} \hyperlink{olsr-routing-protocol_8cc_ab230470cf0b3270a8bba72a05501dd8d}{OLSR\_LOST\_LINK}:
1982           linkTypeName = \textcolor{stringliteral}{"LOST\_LINK"};
1983           \textcolor{keywordflow}{break};
1984         \textcolor{keywordflow}{default}: linkTypeName = \textcolor{stringliteral}{"(invalid value!)"};
1985           
1986         \}
1987 
1988       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *neighborTypeName;
1989       \textcolor{keywordflow}{switch} (nt)
1990         \{
1991         \textcolor{keywordflow}{case} \hyperlink{olsr-routing-protocol_8cc_a7ff690f7463019aec83c1f0edd911034}{OLSR\_NOT\_NEIGH}:
1992           neighborTypeName = \textcolor{stringliteral}{"NOT\_NEIGH"};
1993           \textcolor{keywordflow}{break};
1994         \textcolor{keywordflow}{case} \hyperlink{olsr-routing-protocol_8cc_a46286c316da9922151b354295e71d35a}{OLSR\_SYM\_NEIGH}:
1995           neighborTypeName = \textcolor{stringliteral}{"SYM\_NEIGH"};
1996           \textcolor{keywordflow}{break};
1997         \textcolor{keywordflow}{case} \hyperlink{olsr-routing-protocol_8cc_a08fbe0b4c74b944f681630df4fa0fd82}{OLSR\_MPR\_NEIGH}:
1998           neighborTypeName = \textcolor{stringliteral}{"MPR\_NEIGH"};
1999           \textcolor{keywordflow}{break};
2000         \textcolor{keywordflow}{default}:
2001           neighborTypeName = \textcolor{stringliteral}{"(invalid value!)"};
2002         \}
2003 
2004       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Looking at HELLO link messages with Link Type "}
2005                     << lt << \textcolor{stringliteral}{" ("} << linkTypeName
2006                     << \textcolor{stringliteral}{") and Neighbor Type "} << nt
2007                     << \textcolor{stringliteral}{" ("} << neighborTypeName << \textcolor{stringliteral}{")"});
2008 \textcolor{preprocessor}{#endif // NS3\_LOG\_ENABLE}
2009 
2010       \textcolor{comment}{// We must not process invalid advertised links}
2011       \textcolor{keywordflow}{if} ((lt == \hyperlink{olsr-routing-protocol_8cc_aa7acefeda0e22f22d9ca6b9f445859d7}{OLSR\_SYM\_LINK} && nt == \hyperlink{olsr-routing-protocol_8cc_a7ff690f7463019aec83c1f0edd911034}{OLSR\_NOT\_NEIGH})
2012           || (nt != \hyperlink{olsr-routing-protocol_8cc_a46286c316da9922151b354295e71d35a}{OLSR\_SYM\_NEIGH} && nt != \hyperlink{olsr-routing-protocol_8cc_a08fbe0b4c74b944f681630df4fa0fd82}{OLSR\_MPR\_NEIGH}
2013               && nt != \hyperlink{olsr-routing-protocol_8cc_a7ff690f7463019aec83c1f0edd911034}{OLSR\_NOT\_NEIGH}))
2014         \{
2015           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"HELLO link code is invalid => IGNORING"});
2016           \textcolor{keywordflow}{continue};
2017         \}
2018 
2019       \textcolor{keywordflow}{for} (std::vector<Ipv4Address>::const\_iterator neighIfaceAddr =
2020              linkMessage->neighborInterfaceAddresses.begin ();
2021            neighIfaceAddr != linkMessage->neighborInterfaceAddresses.end ();
2022            neighIfaceAddr++)
2023         \{
2024           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"   -> Neighbor: "} << *neighIfaceAddr);
2025           \textcolor{keywordflow}{if} (*neighIfaceAddr == receiverIface)
2026             \{
2027               \textcolor{keywordflow}{if} (lt == \hyperlink{olsr-routing-protocol_8cc_ab230470cf0b3270a8bba72a05501dd8d}{OLSR\_LOST\_LINK})
2028                 \{
2029                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"link is LOST => expiring it"});
2030                   link\_tuple->symTime = now - \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (1);
2031                   updated = \textcolor{keyword}{true};
2032                 \}
2033               \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (lt == \hyperlink{olsr-routing-protocol_8cc_aa7acefeda0e22f22d9ca6b9f445859d7}{OLSR\_SYM\_LINK} || lt == \hyperlink{olsr-routing-protocol_8cc_a8ebf1daea9834b2e4dfb42ca05b05f4a}{OLSR\_ASYM\_LINK})
2034                 \{
2035                   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (*link\_tuple << \textcolor{stringliteral}{": link is SYM or ASYM => should become SYM now"}
2036                                 \textcolor{stringliteral}{" (symTime being increased to "} << now + msg.GetVTime ());
2037                   link\_tuple->symTime = now + msg.GetVTime ();
2038                   link\_tuple->time = link\_tuple->symTime + \hyperlink{olsr-routing-protocol_8cc_a32428f0b560f93c0a160b27181704faa}{OLSR\_NEIGHB\_HOLD\_TIME};
2039                   updated = \textcolor{keyword}{true};
2040                 \}
2041               \textcolor{keywordflow}{else}
2042                 \{
2043                   \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"bad link type"});
2044                 \}
2045               \textcolor{keywordflow}{break};
2046             \}
2047           \textcolor{keywordflow}{else}
2048             \{
2049               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"     \(\backslash\)\(\backslash\)-> *neighIfaceAddr ("} << *neighIfaceAddr
2050                                                           << \textcolor{stringliteral}{" != receiverIface ("} << receiverIface << \textcolor{stringliteral}{")
       => IGNORING!"});
2051             \}
2052         \}
2053       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Link tuple updated: "} << \textcolor{keywordtype}{int} (updated));
2054     \}
2055   link\_tuple->time = \hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{std::max} (link\_tuple->time, link\_tuple->asymTime);
2056 
2057   \textcolor{keywordflow}{if} (updated)
2058     \{
2059       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a00df90e72ca9f8de10b6f7859fb730eb}{LinkTupleUpdated} (*link\_tuple, hello.willingness);
2060     \}
2061 
2062   \textcolor{comment}{// Schedules link tuple deletion}
2063   \textcolor{keywordflow}{if} (created)
2064     \{
2065       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a49feb372260a7d855e02c789e584d5db}{LinkTupleAdded} (*link\_tuple, hello.willingness);
2066       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a80368d3da46150cf3fc9139c40f33d53}{m\_events}.\hyperlink{classns3_1_1EventGarbageCollector_a4f26a1f6e9a09e648eb31b46acd85144}{Track} (\hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{olsr-routing-protocol_8cc_ad0a00c3386c4a24278b3b710ae798220}{DELAY} (
      \hyperlink{80211b_8c_ac6afabdc09a49a433ee19d8a9486056d}{std::min} (link\_tuple->time, link\_tuple->symTime)),
2067                                            &
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a468cf0d2f46d44f105dff8dffdabcb67}{RoutingProtocol::LinkTupleTimerExpire}, \textcolor{keyword}{this},
2068                                            link\_tuple->neighborIfaceAddr));
2069     \}
2070   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"@"} << now.GetSeconds () << \textcolor{stringliteral}{": Olsr node "} << 
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress}
2071                     << \textcolor{stringliteral}{": LinkSensing END"});
2072 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 51




Here is the caller graph for this function\+:
% FIG 52


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Link\+Tuple\+Added@{Link\+Tuple\+Added}}
\index{Link\+Tuple\+Added@{Link\+Tuple\+Added}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Link\+Tuple\+Added(const Link\+Tuple \&tuple, uint8\+\_\+t willingness)}{LinkTupleAdded(const LinkTuple &tuple, uint8_t willingness)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Link\+Tuple\+Added (
\begin{DoxyParamCaption}
\item[{const {\bf Link\+Tuple} \&}]{tuple, }
\item[{uint8\+\_\+t}]{willingness}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a49feb372260a7d855e02c789e584d5db}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a49feb372260a7d855e02c789e584d5db}
Adds a link tuple. 
\begin{DoxyParams}{Parameters}
{\em tuple} & Thetuple to be added. \\
\hline
{\em willingness} & The tuple willingness. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2326 \{
2327   \textcolor{comment}{// Creates associated neighbor tuple}
2328   NeighborTuple nb\_tuple;
2329   nb\_tuple.neighborMainAddr = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae01451170fb389d322b33ed6d954f460}{GetMainAddress} (tuple.neighborIfaceAddr);
2330   nb\_tuple.willingness = willingness;
2331 
2332   \textcolor{keywordflow}{if} (tuple.symTime >= \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ())
2333     \{
2334       nb\_tuple.status = \hyperlink{structns3_1_1olsr_1_1NeighborTuple_ad4b623edaedb3a5244291c738ce87e12a1649b9e4d61ac6e27eff65e8bd5dfe15}{NeighborTuple::STATUS\_SYM};
2335     \}
2336   \textcolor{keywordflow}{else}
2337     \{
2338       nb\_tuple.status = \hyperlink{structns3_1_1olsr_1_1NeighborTuple_ad4b623edaedb3a5244291c738ce87e12ab633cfd28c2ec5d1f2b6deec3c7ebcf9}{NeighborTuple::STATUS\_NOT\_SYM};
2339     \}
2340 
2341   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a2378ff630c93a17fd040b61e8a9c1fb4}{AddNeighborTuple} (nb\_tuple);
2342 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 53




Here is the caller graph for this function\+:
% FIG 54


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Link\+Tuple\+Timer\+Expire@{Link\+Tuple\+Timer\+Expire}}
\index{Link\+Tuple\+Timer\+Expire@{Link\+Tuple\+Timer\+Expire}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Link\+Tuple\+Timer\+Expire(\+Ipv4\+Address neighbor\+Iface\+Addr)}{LinkTupleTimerExpire(Ipv4Address neighborIfaceAddr)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Link\+Tuple\+Timer\+Expire (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{neighbor\+Iface\+Addr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a468cf0d2f46d44f105dff8dffdabcb67}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a468cf0d2f46d44f105dff8dffdabcb67}


Removes tuple\+\_\+ if expired. Else if symmetric time has expired then it is assumed a neighbor loss and agent\+\_\+-\/$>$nb\+\_\+loss() is called. In this case the timer is rescheduled to expire at tuple\+\_\+-\/$>$time(). Otherwise the timer is rescheduled to expire at the minimum between tuple\+\_\+-\/$>$time() and tuple\+\_\+-\/$>$sym\+\_\+time(). 

The task of actually removing the tuple is left to the O\+L\+SR agent.


\begin{DoxyParams}{Parameters}
{\em neighbor\+Iface\+Addr} & The tuple neighbor interface address. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2630 \{
2631   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} now = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ();
2632 
2633   \textcolor{comment}{// the tuple parameter may be a stale copy; get a newer version from m\_state}
2634   LinkTuple *tuple = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_aba76198953220cce4526761bf30a216c}{FindLinkTuple} (neighborIfaceAddr);
2635   \textcolor{keywordflow}{if} (tuple == NULL)
2636     \{
2637       \textcolor{keywordflow}{return};
2638     \}
2639   \textcolor{keywordflow}{if} (tuple->time < now)
2640     \{
2641       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a1386148ca4a591a3409b54008b7ecae0}{RemoveLinkTuple} (*tuple);
2642     \}
2643   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (tuple->symTime < now)
2644     \{
2645       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae6557d76350cf59d34d2aae8e9c79831}{m\_linkTupleTimerFirstTime})
2646         \{
2647           \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae6557d76350cf59d34d2aae8e9c79831}{m\_linkTupleTimerFirstTime} = \textcolor{keyword}{false};
2648         \}
2649       \textcolor{keywordflow}{else}
2650         \{
2651           \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afe342f9ee1d563e0691e12143f47233d}{NeighborLoss} (*tuple);
2652         \}
2653 
2654       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a80368d3da46150cf3fc9139c40f33d53}{m\_events}.\hyperlink{classns3_1_1EventGarbageCollector_a4f26a1f6e9a09e648eb31b46acd85144}{Track} (\hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{olsr-routing-protocol_8cc_ad0a00c3386c4a24278b3b710ae798220}{DELAY} (tuple->time),
2655                                            &
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a468cf0d2f46d44f105dff8dffdabcb67}{RoutingProtocol::LinkTupleTimerExpire}, \textcolor{keyword}{this},
2656                                            neighborIfaceAddr));
2657     \}
2658   \textcolor{keywordflow}{else}
2659     \{
2660       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a80368d3da46150cf3fc9139c40f33d53}{m\_events}.\hyperlink{classns3_1_1EventGarbageCollector_a4f26a1f6e9a09e648eb31b46acd85144}{Track} (\hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{olsr-routing-protocol_8cc_ad0a00c3386c4a24278b3b710ae798220}{DELAY} (
      \hyperlink{80211b_8c_ac6afabdc09a49a433ee19d8a9486056d}{std::min} (tuple->time, tuple->symTime)),
2661                                            &
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a468cf0d2f46d44f105dff8dffdabcb67}{RoutingProtocol::LinkTupleTimerExpire}, \textcolor{keyword}{this},
2662                                            neighborIfaceAddr));
2663     \}
2664 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 55




Here is the caller graph for this function\+:
% FIG 56


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Link\+Tuple\+Updated@{Link\+Tuple\+Updated}}
\index{Link\+Tuple\+Updated@{Link\+Tuple\+Updated}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Link\+Tuple\+Updated(const Link\+Tuple \&tuple, uint8\+\_\+t willingness)}{LinkTupleUpdated(const LinkTuple &tuple, uint8_t willingness)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Link\+Tuple\+Updated (
\begin{DoxyParamCaption}
\item[{const {\bf Link\+Tuple} \&}]{tuple, }
\item[{uint8\+\_\+t}]{willingness}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a00df90e72ca9f8de10b6f7859fb730eb}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a00df90e72ca9f8de10b6f7859fb730eb}


This function is invoked when a link tuple is updated. Its aim is to also update the corresponding neighbor tuple if it is needed. 


\begin{DoxyParams}{Parameters}
{\em tuple} & The link tuple which has been updated. \\
\hline
{\em willingness} & The tuple willingness. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2357 \{
2358   \textcolor{comment}{// Each time a link tuple changes, the associated neighbor tuple must be recomputed}
2359 
2360   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds ()
2361                 << \textcolor{stringliteral}{"s: OLSR Node "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress}
2362                 << \textcolor{stringliteral}{" LinkTuple "} << tuple << \textcolor{stringliteral}{" UPDATED."});
2363 
2364   NeighborTuple *nb\_tuple =
2365     \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_ae116327f63bf588f61e55c7e3f905787}{FindNeighborTuple} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae01451170fb389d322b33ed6d954f460}{GetMainAddress} (tuple.
      neighborIfaceAddr));
2366 
2367   \textcolor{keywordflow}{if} (nb\_tuple == NULL)
2368     \{
2369       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a49feb372260a7d855e02c789e584d5db}{LinkTupleAdded} (tuple, willingness);
2370       nb\_tuple = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_ae116327f63bf588f61e55c7e3f905787}{FindNeighborTuple} (
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae01451170fb389d322b33ed6d954f460}{GetMainAddress} (tuple.neighborIfaceAddr));
2371     \}
2372 
2373   \textcolor{keywordflow}{if} (nb\_tuple != NULL)
2374     \{
2375       \textcolor{keywordtype}{int} statusBefore = nb\_tuple->\hyperlink{structns3_1_1olsr_1_1NeighborTuple_a893b70912d3bd7b437b493e4cb09f738}{status};
2376 
2377       \textcolor{keywordtype}{bool} hasSymmetricLink = \textcolor{keyword}{false};
2378 
2379       \textcolor{keyword}{const} \hyperlink{namespacens3_1_1olsr_a60381cc41d65a2e0daabd286077a378a}{LinkSet} &linkSet = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a1d8f1a95165973f05e3fd1ff0d76fbda}{GetLinks} ();
2380       \textcolor{keywordflow}{for} (LinkSet::const\_iterator it = linkSet.begin ();
2381            it != linkSet.end (); it++)
2382         \{
2383           \textcolor{keyword}{const} LinkTuple &link\_tuple = *it;
2384           \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae01451170fb389d322b33ed6d954f460}{GetMainAddress} (link\_tuple.neighborIfaceAddr) == nb\_tuple->neighborMainAddr
2385               && link\_tuple.symTime >= \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ())
2386             \{
2387               hasSymmetricLink = \textcolor{keyword}{true};
2388               \textcolor{keywordflow}{break};
2389             \}
2390         \}
2391 
2392       \textcolor{keywordflow}{if} (hasSymmetricLink)
2393         \{
2394           nb\_tuple->status = \hyperlink{structns3_1_1olsr_1_1NeighborTuple_ad4b623edaedb3a5244291c738ce87e12a1649b9e4d61ac6e27eff65e8bd5dfe15}{NeighborTuple::STATUS\_SYM};
2395           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (*nb\_tuple << \textcolor{stringliteral}{"->status = STATUS\_SYM; changed:"}
2396                                   << \textcolor{keywordtype}{int} (statusBefore != nb\_tuple->status));
2397         \}
2398       \textcolor{keywordflow}{else}
2399         \{
2400           nb\_tuple->status = \hyperlink{structns3_1_1olsr_1_1NeighborTuple_ad4b623edaedb3a5244291c738ce87e12ab633cfd28c2ec5d1f2b6deec3c7ebcf9}{NeighborTuple::STATUS\_NOT\_SYM};
2401           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (*nb\_tuple << \textcolor{stringliteral}{"->status = STATUS\_NOT\_SYM; changed:"}
2402                                   << \textcolor{keywordtype}{int} (statusBefore != nb\_tuple->status));
2403         \}
2404     \}
2405   \textcolor{keywordflow}{else}
2406     \{
2407       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"ERROR! Wanted to update a NeighborTuple but none was found!"});
2408     \}
2409 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 57




Here is the caller graph for this function\+:
% FIG 58


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Lookup@{Lookup}}
\index{Lookup@{Lookup}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Lookup(const Ipv4\+Address \&dest, Routing\+Table\+Entry \&out\+Entry) const }{Lookup(const Ipv4Address &dest, RoutingTableEntry &outEntry) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::olsr\+::\+Routing\+Protocol\+::\+Lookup (
\begin{DoxyParamCaption}
\item[{const {\bf Ipv4\+Address} \&}]{dest, }
\item[{{\bf Routing\+Table\+Entry} \&}]{out\+Entry}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a514bf401454b233af509476fc3fd5d6b}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a514bf401454b233af509476fc3fd5d6b}


Looks up an entry for the specified destination address. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em dest} & Destination address. \\
\hline
\mbox{\tt out}  & {\em out\+Entry} & Holds the routing entry result, if found. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if found, false if not found. 
\end{DoxyReturn}

\begin{DoxyCode}
2783 \{
2784   \textcolor{comment}{// Get the iterator at "dest" position}
2785   std::map<Ipv4Address, RoutingTableEntry>::const\_iterator it =
2786     \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a9703fb92cc9a864c0e2874387ead3aa3}{m\_table}.find (dest);
2787   \textcolor{comment}{// If there is no route to "dest", return NULL}
2788   \textcolor{keywordflow}{if} (it == \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a9703fb92cc9a864c0e2874387ead3aa3}{m\_table}.end ())
2789     \{
2790       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
2791     \}
2792   outEntry = it->second;
2793   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
2794 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 59


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Mid\+Timer\+Expire@{Mid\+Timer\+Expire}}
\index{Mid\+Timer\+Expire@{Mid\+Timer\+Expire}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Mid\+Timer\+Expire()}{MidTimerExpire()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Mid\+Timer\+Expire (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_adb532d5890ea3954e8ab73a625d53e66}{}\label{classns3_1_1olsr_1_1RoutingProtocol_adb532d5890ea3954e8ab73a625d53e66}


Sends a M\+ID message (if the node has more than one interface) and resets the M\+ID timer. 


\begin{DoxyCode}
2588 \{
2589   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a6da315bbcafcdda3dc11acfea3b33d28}{SendMid} ();
2590   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a7d525e1847150003ef21cd962a66c759}{m\_midTimer}.\hyperlink{classns3_1_1Timer_ac3345d696887578f518b19f359f7f94b}{Schedule} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a9109a692ebfe241e01a68a584a4961b9}{m\_midInterval});
2591 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 60




Here is the caller graph for this function\+:
% FIG 61


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Mpr\+Computation@{Mpr\+Computation}}
\index{Mpr\+Computation@{Mpr\+Computation}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Mpr\+Computation()}{MprComputation()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Mpr\+Computation (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a947ab35f39d191ed51d3fbb7c1cc282c}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a947ab35f39d191ed51d3fbb7c1cc282c}


Computates M\+PR set of a node following \{3626\} hints. 


\begin{DoxyCode}
596 \{
597   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
598 
599   \textcolor{comment}{// MPR computation should be done for each interface. See section 8.3.1}
600   \textcolor{comment}{// (RFC 3626) for details.}
601   \hyperlink{namespacens3_1_1olsr_aa7c4ede0ba85f0ea9da6e6699525bd4a}{MprSet} mprSet;
602 
603   \textcolor{comment}{// N is the subset of neighbors of the node, which are}
604   \textcolor{comment}{// neighbor "of the interface I"}
605   \hyperlink{namespacens3_1_1olsr_af0afef1f28c6f0a0b528b03b638df05d}{NeighborSet} \hyperlink{loss__ITU1238_8m_aaa6c78b1d659f53598dbe891c1139b3e}{N};
606   \textcolor{keywordflow}{for} (NeighborSet::const\_iterator neighbor = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a82d5882ca3fdb93a9c1110c6f176c03c}{GetNeighbors} ().begin ();
607        neighbor != \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a82d5882ca3fdb93a9c1110c6f176c03c}{GetNeighbors} ().end (); neighbor++)
608     \{
609       \textcolor{keywordflow}{if} (neighbor->status == \hyperlink{structns3_1_1olsr_1_1NeighborTuple_ad4b623edaedb3a5244291c738ce87e12a1649b9e4d61ac6e27eff65e8bd5dfe15}{NeighborTuple::STATUS\_SYM}) \textcolor{comment}{// I think that we need
       this check}
610         \{
611           N.push\_back (*neighbor);
612         \}
613     \}
614 
615   \textcolor{comment}{// N2 is the set of 2-hop neighbors reachable from "the interface}
616   \textcolor{comment}{// I", excluding:}
617   \textcolor{comment}{// (i)   the nodes only reachable by members of N with willingness WILL\_NEVER}
618   \textcolor{comment}{// (ii)  the node performing the computation}
619   \textcolor{comment}{// (iii) all the symmetric neighbors: the nodes for which there exists a symmetric}
620   \textcolor{comment}{//       link to this node on some interface.}
621   \hyperlink{namespacens3_1_1olsr_a5f9963792af7fea4dc66fb8718394604}{TwoHopNeighborSet} N2;
622   \textcolor{keywordflow}{for} (TwoHopNeighborSet::const\_iterator twoHopNeigh = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.
      \hyperlink{classns3_1_1olsr_1_1OlsrState_ab03738874d0d785b770beef6dc9c2e1a}{GetTwoHopNeighbors} ().begin ();
623        twoHopNeigh != \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_ab03738874d0d785b770beef6dc9c2e1a}{GetTwoHopNeighbors} ().end (); twoHopNeigh++)
624     \{
625       \textcolor{comment}{// excluding:}
626       \textcolor{comment}{// (ii)  the node performing the computation}
627       \textcolor{keywordflow}{if} (twoHopNeigh->twoHopNeighborAddr == \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress})
628         \{
629           \textcolor{keywordflow}{continue};
630         \}
631 
632       \textcolor{comment}{//  excluding:}
633       \textcolor{comment}{// (i)   the nodes only reachable by members of N with willingness WILL\_NEVER}
634       \textcolor{keywordtype}{bool} ok = \textcolor{keyword}{false};
635       \textcolor{keywordflow}{for} (NeighborSet::const\_iterator neigh = N.begin ();
636            neigh != N.end (); neigh++)
637         \{
638           \textcolor{keywordflow}{if} (neigh->neighborMainAddr == twoHopNeigh->neighborMainAddr)
639             \{
640               \textcolor{keywordflow}{if} (neigh->willingness == \hyperlink{olsr-routing-protocol_8cc_a146d2c103abd49bdfad44b4424769696}{OLSR\_WILL\_NEVER})
641                 \{
642                   ok = \textcolor{keyword}{false};
643                   \textcolor{keywordflow}{break};
644                 \}
645               \textcolor{keywordflow}{else}
646                 \{
647                   ok = \textcolor{keyword}{true};
648                   \textcolor{keywordflow}{break};
649                 \}
650             \}
651         \}
652       \textcolor{keywordflow}{if} (!ok)
653         \{
654           \textcolor{keywordflow}{continue};
655         \}
656 
657       \textcolor{comment}{// excluding:}
658       \textcolor{comment}{// (iii) all the symmetric neighbors: the nodes for which there exists a symmetric}
659       \textcolor{comment}{//       link to this node on some interface.}
660       \textcolor{keywordflow}{for} (NeighborSet::const\_iterator neigh = N.begin ();
661            neigh != N.end (); neigh++)
662         \{
663           \textcolor{keywordflow}{if} (neigh->neighborMainAddr == twoHopNeigh->twoHopNeighborAddr)
664             \{
665               ok = \textcolor{keyword}{false};
666               \textcolor{keywordflow}{break};
667             \}
668         \}
669 
670       \textcolor{keywordflow}{if} (ok)
671         \{
672           N2.push\_back (*twoHopNeigh);
673         \}
674     \}
675 
676 \textcolor{preprocessor}{#ifdef NS3\_LOG\_ENABLE}
677   \{
678     std::ostringstream os;
679     os << \textcolor{stringliteral}{"["};
680     \textcolor{keywordflow}{for} (TwoHopNeighborSet::const\_iterator iter = N2.begin ();
681          iter != N2.end (); iter++)
682       \{
683         TwoHopNeighborSet::const\_iterator next = iter;
684         next++;
685         os << iter->neighborMainAddr << \textcolor{stringliteral}{"->"} << iter->twoHopNeighborAddr;
686         \textcolor{keywordflow}{if} (next != N2.end ())
687           \{
688             os << \textcolor{stringliteral}{", "};
689           \}
690       \}
691     os << \textcolor{stringliteral}{"]"};
692     \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"N2: "} << os.str ());
693   \}
694 \textcolor{preprocessor}{#endif  //NS3\_LOG\_ENABLE}
695 
696   \textcolor{comment}{// 1. Start with an MPR set made of all members of N with}
697   \textcolor{comment}{// N\_willingness equal to WILL\_ALWAYS}
698   \textcolor{keywordflow}{for} (NeighborSet::const\_iterator neighbor = N.begin (); neighbor != N.end (); neighbor++)
699     \{
700       \textcolor{keywordflow}{if} (neighbor->willingness == \hyperlink{olsr-routing-protocol_8cc_a47254d140ed26351d672c338a8cda435}{OLSR\_WILL\_ALWAYS})
701         \{
702           mprSet.insert (neighbor->neighborMainAddr);
703           \textcolor{comment}{// (not in RFC but I think is needed: remove the 2-hop}
704           \textcolor{comment}{// neighbors reachable by the MPR from N2)}
705           CoverTwoHopNeighbors (neighbor->neighborMainAddr, N2);
706         \}
707     \}
708 
709   \textcolor{comment}{// 2. Calculate D(y), where y is a member of N, for all nodes in N.}
710   \textcolor{comment}{// (we do this later)}
711 
712   \textcolor{comment}{// 3. Add to the MPR set those nodes in N, which are the *only*}
713   \textcolor{comment}{// nodes to provide reachability to a node in N2.}
714   std::set<Ipv4Address> coveredTwoHopNeighbors;
715   \textcolor{keywordflow}{for} (TwoHopNeighborSet::const\_iterator twoHopNeigh = N2.begin (); twoHopNeigh != N2.end (); twoHopNeigh++
      )
716     \{
717       \textcolor{keywordtype}{bool} onlyOne = \textcolor{keyword}{true};
718       \textcolor{comment}{// try to find another neighbor that can reach twoHopNeigh->twoHopNeighborAddr}
719       \textcolor{keywordflow}{for} (TwoHopNeighborSet::const\_iterator otherTwoHopNeigh = N2.begin (); otherTwoHopNeigh != N2.end ();
       otherTwoHopNeigh++)
720         \{
721           \textcolor{keywordflow}{if} (otherTwoHopNeigh->twoHopNeighborAddr == twoHopNeigh->twoHopNeighborAddr
722               && otherTwoHopNeigh->neighborMainAddr != twoHopNeigh->neighborMainAddr)
723             \{
724               onlyOne = \textcolor{keyword}{false};
725               \textcolor{keywordflow}{break};
726             \}
727         \}
728       \textcolor{keywordflow}{if} (onlyOne)
729         \{
730           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Neighbor "} << twoHopNeigh->neighborMainAddr
731                                     << \textcolor{stringliteral}{" is the only that can reach 2-hop neigh. "}
732                                     << twoHopNeigh->twoHopNeighborAddr
733                                     << \textcolor{stringliteral}{" => select as MPR."});
734 
735           mprSet.insert (twoHopNeigh->neighborMainAddr);
736 
737           \textcolor{comment}{// take note of all the 2-hop neighbors reachable by the newly elected MPR}
738           \textcolor{keywordflow}{for} (TwoHopNeighborSet::const\_iterator otherTwoHopNeigh = N2.begin ();
739                otherTwoHopNeigh != N2.end (); otherTwoHopNeigh++)
740             \{
741               \textcolor{keywordflow}{if} (otherTwoHopNeigh->neighborMainAddr == twoHopNeigh->neighborMainAddr)
742                 \{
743                   coveredTwoHopNeighbors.insert (otherTwoHopNeigh->twoHopNeighborAddr);
744                 \}
745             \}
746         \}
747     \}
748   \textcolor{comment}{// Remove the nodes from N2 which are now covered by a node in the MPR set.}
749   \textcolor{keywordflow}{for} (TwoHopNeighborSet::iterator twoHopNeigh = N2.begin ();
750        twoHopNeigh != N2.end (); )
751     \{
752       \textcolor{keywordflow}{if} (coveredTwoHopNeighbors.find (twoHopNeigh->twoHopNeighborAddr) != coveredTwoHopNeighbors.end ())
753         \{
754           \textcolor{comment}{// This works correctly only because it is known that twoHopNeigh is reachable by exactly one
       neighbor,}
755           \textcolor{comment}{// so only one record in N2 exists for each of them. This record is erased here.}
756           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"2-hop neigh. "} << twoHopNeigh->twoHopNeighborAddr << \textcolor{stringliteral}{" is already
       covered by an MPR."});
757           twoHopNeigh = N2.erase (twoHopNeigh);
758         \}
759       \textcolor{keywordflow}{else}
760         \{
761           twoHopNeigh++;
762         \}
763     \}
764 
765   \textcolor{comment}{// 4. While there exist nodes in N2 which are not covered by at}
766   \textcolor{comment}{// least one node in the MPR set:}
767   \textcolor{keywordflow}{while} (N2.begin () != N2.end ())
768     \{
769 
770 \textcolor{preprocessor}{#ifdef NS3\_LOG\_ENABLE}
771       \{
772         std::ostringstream os;
773         os << \textcolor{stringliteral}{"["};
774         \textcolor{keywordflow}{for} (TwoHopNeighborSet::const\_iterator iter = N2.begin ();
775              iter != N2.end (); iter++)
776           \{
777             TwoHopNeighborSet::const\_iterator next = iter;
778             next++;
779             os << iter->neighborMainAddr << \textcolor{stringliteral}{"->"} << iter->twoHopNeighborAddr;
780             \textcolor{keywordflow}{if} (next != N2.end ())
781               \{
782                 os << \textcolor{stringliteral}{", "};
783               \}
784           \}
785         os << \textcolor{stringliteral}{"]"};
786         \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Step 4 iteration: N2="} << os.str ());
787       \}
788 \textcolor{preprocessor}{#endif  //NS3\_LOG\_ENABLE}
789 
790 
791       \textcolor{comment}{// 4.1. For each node in N, calculate the reachability, i.e., the}
792       \textcolor{comment}{// number of nodes in N2 which are not yet covered by at}
793       \textcolor{comment}{// least one node in the MPR set, and which are reachable}
794       \textcolor{comment}{// through this 1-hop neighbor}
795       std::map<int, std::vector<const NeighborTuple *> > reachability;
796       std::set<int> rs;
797       \textcolor{keywordflow}{for} (NeighborSet::iterator it = N.begin (); it != N.end (); it++)
798         \{
799           NeighborTuple \textcolor{keyword}{const} &nb\_tuple = *it;
800           \textcolor{keywordtype}{int} r = 0;
801           \textcolor{keywordflow}{for} (TwoHopNeighborSet::iterator it2 = N2.begin (); it2 != N2.end (); it2++)
802             \{
803               TwoHopNeighborTuple \textcolor{keyword}{const} &nb2hop\_tuple = *it2;
804               \textcolor{keywordflow}{if} (nb\_tuple.neighborMainAddr == nb2hop\_tuple.neighborMainAddr)
805                 \{
806                   r++;
807                 \}
808             \}
809           rs.insert (r);
810           reachability[r].push\_back (&nb\_tuple);
811         \}
812 
813       \textcolor{comment}{// 4.2. Select as a MPR the node with highest N\_willingness among}
814       \textcolor{comment}{// the nodes in N with non-zero reachability. In case of}
815       \textcolor{comment}{// multiple choice select the node which provides}
816       \textcolor{comment}{// reachability to the maximum number of nodes in N2. In}
817       \textcolor{comment}{// case of multiple nodes providing the same amount of}
818       \textcolor{comment}{// reachability, select the node as MPR whose D(y) is}
819       \textcolor{comment}{// greater. Remove the nodes from N2 which are now covered}
820       \textcolor{comment}{// by a node in the MPR set.}
821       NeighborTuple \textcolor{keyword}{const} *\hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{max} = NULL;
822       \textcolor{keywordtype}{int} max\_r = 0;
823       \textcolor{keywordflow}{for} (std::set<int>::iterator it = rs.begin (); it != rs.end (); it++)
824         \{
825           \textcolor{keywordtype}{int} r = *it;
826           \textcolor{keywordflow}{if} (r == 0)
827             \{
828               \textcolor{keywordflow}{continue};
829             \}
830           \textcolor{keywordflow}{for} (std::vector<const NeighborTuple *>::iterator it2 = reachability[r].begin ();
831                it2 != reachability[r].end (); it2++)
832             \{
833               \textcolor{keyword}{const} NeighborTuple *nb\_tuple = *it2;
834               \textcolor{keywordflow}{if} (max == NULL || nb\_tuple->willingness > max->willingness)
835                 \{
836                   max = nb\_tuple;
837                   max\_r = r;
838                 \}
839               \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (nb\_tuple->willingness == max->willingness)
840                 \{
841                   \textcolor{keywordflow}{if} (r > max\_r)
842                     \{
843                       max = nb\_tuple;
844                       max\_r = r;
845                     \}
846                   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (r == max\_r)
847                     \{
848                       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_af4806875b065d6fe5704ce65824dc1a7}{Degree} (*nb\_tuple) > \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_af4806875b065d6fe5704ce65824dc1a7}{Degree} (*max))
849                         \{
850                           max = nb\_tuple;
851                           max\_r = r;
852                         \}
853                     \}
854                 \}
855             \}
856         \}
857 
858       \textcolor{keywordflow}{if} (max != NULL)
859         \{
860           mprSet.insert (max->neighborMainAddr);
861           CoverTwoHopNeighbors (max->neighborMainAddr, N2);
862           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (N2.size () << \textcolor{stringliteral}{" 2-hop neighbors left to cover!"});
863         \}
864     \}
865 
866 \textcolor{preprocessor}{#ifdef NS3\_LOG\_ENABLE}
867   \{
868     std::ostringstream os;
869     os << \textcolor{stringliteral}{"["};
870     \textcolor{keywordflow}{for} (MprSet::const\_iterator iter = mprSet.begin ();
871          iter != mprSet.end (); iter++)
872       \{
873         MprSet::const\_iterator next = iter;
874         next++;
875         os << *iter;
876         \textcolor{keywordflow}{if} (next != mprSet.end ())
877           \{
878             os << \textcolor{stringliteral}{", "};
879           \}
880       \}
881     os << \textcolor{stringliteral}{"]"};
882     \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Computed MPR set for node "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress} << \textcolor{stringliteral}{": "} << os.str 
      ());
883   \}
884 \textcolor{preprocessor}{#endif  //NS3\_LOG\_ENABLE}
885 
886   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a8c59c2a9b6932ad26772f7041bd4d4e3}{SetMprSet} (mprSet);
887 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 62




Here is the caller graph for this function\+:
% FIG 63


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Mpr\+Sel\+Tuple\+Timer\+Expire@{Mpr\+Sel\+Tuple\+Timer\+Expire}}
\index{Mpr\+Sel\+Tuple\+Timer\+Expire@{Mpr\+Sel\+Tuple\+Timer\+Expire}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Mpr\+Sel\+Tuple\+Timer\+Expire(\+Ipv4\+Address main\+Addr)}{MprSelTupleTimerExpire(Ipv4Address mainAddr)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Mpr\+Sel\+Tuple\+Timer\+Expire (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{main\+Addr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a47272f0889e3c50e4fe26f1f4d9fb3fe}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a47272f0889e3c50e4fe26f1f4d9fb3fe}


Removes M\+PR selector tuple\+\_\+ if expired. Else the timer is rescheduled to expire at tuple\+\_\+-\/$>$time(). 

The task of actually removing the tuple is left to the O\+L\+SR agent.


\begin{DoxyParams}{Parameters}
{\em main\+Addr} & The tuple I\+Pv4 address. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2689 \{
2690   MprSelectorTuple *tuple = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a81bb1e9642f6b840094d199d3654b984}{FindMprSelectorTuple} (mainAddr);
2691   \textcolor{keywordflow}{if} (tuple == NULL)
2692     \{
2693       \textcolor{keywordflow}{return};
2694     \}
2695   \textcolor{keywordflow}{if} (tuple->expirationTime < \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ())
2696     \{
2697       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ab3455ede71dab3092016964ef8577521}{RemoveMprSelectorTuple} (*tuple);
2698     \}
2699   \textcolor{keywordflow}{else}
2700     \{
2701       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a80368d3da46150cf3fc9139c40f33d53}{m\_events}.\hyperlink{classns3_1_1EventGarbageCollector_a4f26a1f6e9a09e648eb31b46acd85144}{Track} (\hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{olsr-routing-protocol_8cc_ad0a00c3386c4a24278b3b710ae798220}{DELAY} (tuple->
      expirationTime),
2702                                            &
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a47272f0889e3c50e4fe26f1f4d9fb3fe}{RoutingProtocol::MprSelTupleTimerExpire},
2703                                            \textcolor{keyword}{this}, mainAddr));
2704     \}
2705 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 64




Here is the caller graph for this function\+:
% FIG 65


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Nb2hop\+Tuple\+Timer\+Expire@{Nb2hop\+Tuple\+Timer\+Expire}}
\index{Nb2hop\+Tuple\+Timer\+Expire@{Nb2hop\+Tuple\+Timer\+Expire}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Nb2hop\+Tuple\+Timer\+Expire(\+Ipv4\+Address neighbor\+Main\+Addr, Ipv4\+Address two\+Hop\+Neighbor\+Addr)}{Nb2hopTupleTimerExpire(Ipv4Address neighborMainAddr, Ipv4Address twoHopNeighborAddr)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Nb2hop\+Tuple\+Timer\+Expire (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{neighbor\+Main\+Addr, }
\item[{{\bf Ipv4\+Address}}]{two\+Hop\+Neighbor\+Addr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a5e71d702e1b560c4645139912da27002}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a5e71d702e1b560c4645139912da27002}


Removes 2\+\_\+hop neighbor tuple\+\_\+ if expired. Else the timer is rescheduled to expire at tuple\+\_\+-\/$>$time(). 

The task of actually removing the tuple is left to the O\+L\+SR agent.


\begin{DoxyParams}{Parameters}
{\em neighbor\+Main\+Addr} & The neighbor main address. \\
\hline
{\em two\+Hop\+Neighbor\+Addr} & The 2-\/hop neighbor address. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2668 \{
2669   TwoHopNeighborTuple *tuple;
2670   tuple = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a420ef02aeb9997bff09bbebd6a72e642}{FindTwoHopNeighborTuple} (neighborMainAddr, 
      twoHopNeighborAddr);
2671   \textcolor{keywordflow}{if} (tuple == NULL)
2672     \{
2673       \textcolor{keywordflow}{return};
2674     \}
2675   \textcolor{keywordflow}{if} (tuple->expirationTime < \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ())
2676     \{
2677       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_adc613a8eb47ccb94878d8e9f61e9d11a}{RemoveTwoHopNeighborTuple} (*tuple);
2678     \}
2679   \textcolor{keywordflow}{else}
2680     \{
2681       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a80368d3da46150cf3fc9139c40f33d53}{m\_events}.\hyperlink{classns3_1_1EventGarbageCollector_a4f26a1f6e9a09e648eb31b46acd85144}{Track} (\hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{olsr-routing-protocol_8cc_ad0a00c3386c4a24278b3b710ae798220}{DELAY} (tuple->
      expirationTime),
2682                                            &
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a5e71d702e1b560c4645139912da27002}{RoutingProtocol::Nb2hopTupleTimerExpire},
2683                                            \textcolor{keyword}{this}, neighborMainAddr, twoHopNeighborAddr));
2684     \}
2685 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 66




Here is the caller graph for this function\+:
% FIG 67


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Neighbor\+Loss@{Neighbor\+Loss}}
\index{Neighbor\+Loss@{Neighbor\+Loss}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Neighbor\+Loss(const Link\+Tuple \&tuple)}{NeighborLoss(const LinkTuple &tuple)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Neighbor\+Loss (
\begin{DoxyParamCaption}
\item[{const {\bf Link\+Tuple} \&}]{tuple}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_afe342f9ee1d563e0691e12143f47233d}{}\label{classns3_1_1olsr_1_1RoutingProtocol_afe342f9ee1d563e0691e12143f47233d}


Performs all actions needed when a neighbor loss occurs. 

Neighbor Set, 2-\/hop Neighbor Set, M\+PR Set and M\+PR Selector Set are updated.


\begin{DoxyParams}{Parameters}
{\em tuple} & link tuple with the information of the link to the neighbor which has been lost. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2290 \{
2291   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds ()
2292                 << \textcolor{stringliteral}{"s: OLSR Node "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress}
2293                 << \textcolor{stringliteral}{" LinkTuple "} << tuple.neighborIfaceAddr << \textcolor{stringliteral}{" -> neighbor loss."});
2294   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a00df90e72ca9f8de10b6f7859fb730eb}{LinkTupleUpdated} (tuple, \hyperlink{olsr-routing-protocol_8cc_a0b87d49ad8114eabe8dd6eecfb6858e1}{OLSR\_WILL\_DEFAULT});
2295   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a42bb2907567fb9ab9b17d28476c9859b}{EraseTwoHopNeighborTuples} (
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae01451170fb389d322b33ed6d954f460}{GetMainAddress} (tuple.neighborIfaceAddr));
2296   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a7efa14fb8cbd5cae78180a73f5369854}{EraseMprSelectorTuples} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae01451170fb389d322b33ed6d954f460}{GetMainAddress} (tuple.
      neighborIfaceAddr));
2297 
2298   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a947ab35f39d191ed51d3fbb7c1cc282c}{MprComputation} ();
2299   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a69fcd3b690fbf6e2b46735145cecfe3e}{RoutingTableComputation} ();
2300 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 68




Here is the caller graph for this function\+:
% FIG 69


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Notify\+Add\+Address@{Notify\+Add\+Address}}
\index{Notify\+Add\+Address@{Notify\+Add\+Address}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Notify\+Add\+Address(uint32\+\_\+t interface, Ipv4\+Interface\+Address address)}{NotifyAddAddress(uint32_t interface, Ipv4InterfaceAddress address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Notify\+Add\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv4\+Interface\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a054b550049839fe54a67e73c4d492a21}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a054b550049839fe54a67e73c4d492a21}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
{\em address} & a new address being added to an interface\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified whenever a new address is added to an interface. Typically used to add a \textquotesingle{}network route\textquotesingle{} on an interface. Can be invoked on an up or down interface. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_aef12fcf9cc478536876b0281505d40aa}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
3007 \{
3008 \}
\end{DoxyCode}
\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Notify\+Interface\+Down@{Notify\+Interface\+Down}}
\index{Notify\+Interface\+Down@{Notify\+Interface\+Down}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Notify\+Interface\+Down(uint32\+\_\+t interface)}{NotifyInterfaceDown(uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Notify\+Interface\+Down (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a8fc8faa57ffe549d56b5db197dcd17e4}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a8fc8faa57ffe549d56b5db197dcd17e4}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified of the state change of an interface in a node. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a90f728b73ccb1806e5a4093ff156f607}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
3003 \{
3004 \}
\end{DoxyCode}
\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Notify\+Interface\+Up@{Notify\+Interface\+Up}}
\index{Notify\+Interface\+Up@{Notify\+Interface\+Up}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Notify\+Interface\+Up(uint32\+\_\+t interface)}{NotifyInterfaceUp(uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Notify\+Interface\+Up (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a389d83b05f1110042dfb4fc77666c5d3}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a389d83b05f1110042dfb4fc77666c5d3}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified of the state change of an interface in a node. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_aabb99ce7a048e75ff4b36fa9af8745e4}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
2999 \{
3000 \}
\end{DoxyCode}
\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Notify\+Remove\+Address@{Notify\+Remove\+Address}}
\index{Notify\+Remove\+Address@{Notify\+Remove\+Address}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Notify\+Remove\+Address(uint32\+\_\+t interface, Ipv4\+Interface\+Address address)}{NotifyRemoveAddress(uint32_t interface, Ipv4InterfaceAddress address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Notify\+Remove\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv4\+Interface\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_ab21c8e08be88e0e03d9327731a3b52da}{}\label{classns3_1_1olsr_1_1RoutingProtocol_ab21c8e08be88e0e03d9327731a3b52da}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
{\em address} & a new address being added to an interface\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified whenever a new address is removed from an interface. Typically used to remove the \textquotesingle{}network route\textquotesingle{} of an interface. Can be invoked on an up or down interface. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a0160e49e509d6699ec837e5485f65cd2}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
3011 \{
3012 \}
\end{DoxyCode}
\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Populate\+Mpr\+Selector\+Set@{Populate\+Mpr\+Selector\+Set}}
\index{Populate\+Mpr\+Selector\+Set@{Populate\+Mpr\+Selector\+Set}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Populate\+Mpr\+Selector\+Set(const olsr\+::\+Message\+Header \&msg, const olsr\+::\+Message\+Header\+::\+Hello \&hello)}{PopulateMprSelectorSet(const olsr::MessageHeader &msg, const olsr::MessageHeader::Hello &hello)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Populate\+Mpr\+Selector\+Set (
\begin{DoxyParamCaption}
\item[{const {\bf olsr\+::\+Message\+Header} \&}]{msg, }
\item[{const {\bf olsr\+::\+Message\+Header\+::\+Hello} \&}]{hello}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a56bce0e7794315308e10e5fd1343cfaf}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a56bce0e7794315308e10e5fd1343cfaf}


Updates the M\+PR Selector Set according to the information contained in a new received H\+E\+L\+LO message (following \{3626\}). 


\begin{DoxyParams}{Parameters}
{\em msg} & The received message. \\
\hline
{\em hello} & The received H\+E\+L\+LO sub-\/message. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2195 \{
2196   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
2197 
2198   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} now = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ();
2199 
2200   \textcolor{keyword}{typedef} std::vector<olsr::MessageHeader::Hello::LinkMessage> LinkMessageVec;
2201   \textcolor{keywordflow}{for} (LinkMessageVec::const\_iterator linkMessage = hello.linkMessages.begin ();
2202        linkMessage != hello.linkMessages.end ();
2203        linkMessage++)
2204     \{
2205       \textcolor{keywordtype}{int} nt = linkMessage->linkCode >> 2;
2206       \textcolor{keywordflow}{if} (nt == \hyperlink{olsr-routing-protocol_8cc_a08fbe0b4c74b944f681630df4fa0fd82}{OLSR\_MPR\_NEIGH})
2207         \{
2208           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Processing a link message with neighbor type MPR\_NEIGH"});
2209 
2210           \textcolor{keywordflow}{for} (std::vector<Ipv4Address>::const\_iterator nb\_iface\_addr =
2211                  linkMessage->neighborInterfaceAddresses.begin ();
2212                nb\_iface\_addr != linkMessage->neighborInterfaceAddresses.end ();
2213                nb\_iface\_addr++)
2214             \{
2215               \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae01451170fb389d322b33ed6d954f460}{GetMainAddress} (*nb\_iface\_addr) == \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress})
2216                 \{
2217                   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Adding entry to mpr selector set for neighbor "} << *
      nb\_iface\_addr);
2218 
2219                   \textcolor{comment}{// We must create a new entry into the mpr selector set}
2220                   MprSelectorTuple *existing\_mprsel\_tuple =
2221                     \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a81bb1e9642f6b840094d199d3654b984}{FindMprSelectorTuple} (msg.GetOriginatorAddress ());
2222                   \textcolor{keywordflow}{if} (existing\_mprsel\_tuple == NULL)
2223                     \{
2224                       MprSelectorTuple mprsel\_tuple;
2225 
2226                       mprsel\_tuple.\hyperlink{structns3_1_1olsr_1_1MprSelectorTuple_a7e1e37f791d34c0e3e0e2b57ab5d1925}{mainAddr} = msg.GetOriginatorAddress ();
2227                       mprsel\_tuple.expirationTime = now + msg.GetVTime ();
2228                       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_aff14042e35d2343b080522580f3d5b24}{AddMprSelectorTuple} (mprsel\_tuple);
2229 
2230                       \textcolor{comment}{// Schedules mpr selector tuple deletion}
2231                       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a80368d3da46150cf3fc9139c40f33d53}{m\_events}.\hyperlink{classns3_1_1EventGarbageCollector_a4f26a1f6e9a09e648eb31b46acd85144}{Track} (\hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule}
2232                                         (\hyperlink{olsr-routing-protocol_8cc_ad0a00c3386c4a24278b3b710ae798220}{DELAY} (mprsel\_tuple.expirationTime),
2233                                         &\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a47272f0889e3c50e4fe26f1f4d9fb3fe}{RoutingProtocol::MprSelTupleTimerExpire}
      , \textcolor{keyword}{this},
2234                                         mprsel\_tuple.mainAddr));
2235                     \}
2236                   \textcolor{keywordflow}{else}
2237                     \{
2238                       existing\_mprsel\_tuple->expirationTime = now + msg.GetVTime ();
2239                     \}
2240                 \}
2241             \}
2242         \}
2243     \}
2244   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Computed MPR selector set for node "} << 
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress} << \textcolor{stringliteral}{": "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a54a82f932deb7904e5ec0ffcdd70c8a9}{PrintMprSelectorSet} ());
2245 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 70




Here is the caller graph for this function\+:
% FIG 71


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Populate\+Neighbor\+Set@{Populate\+Neighbor\+Set}}
\index{Populate\+Neighbor\+Set@{Populate\+Neighbor\+Set}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Populate\+Neighbor\+Set(const olsr\+::\+Message\+Header \&msg, const olsr\+::\+Message\+Header\+::\+Hello \&hello)}{PopulateNeighborSet(const olsr::MessageHeader &msg, const olsr::MessageHeader::Hello &hello)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Populate\+Neighbor\+Set (
\begin{DoxyParamCaption}
\item[{const {\bf olsr\+::\+Message\+Header} \&}]{msg, }
\item[{const {\bf olsr\+::\+Message\+Header\+::\+Hello} \&}]{hello}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a9a9cccf9682782a0b95539862b4e6b53}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a9a9cccf9682782a0b95539862b4e6b53}


Updates the Neighbor Set according to the information contained in a new received H\+E\+L\+LO message (following \{3626\}). 


\begin{DoxyParams}{Parameters}
{\em msg} & The received message. \\
\hline
{\em hello} & The received H\+E\+L\+LO sub-\/message. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2077 \{
2078   NeighborTuple *nb\_tuple = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_ae116327f63bf588f61e55c7e3f905787}{FindNeighborTuple} (msg.GetOriginatorAddress ())
      ;
2079   \textcolor{keywordflow}{if} (nb\_tuple != NULL)
2080     \{
2081       nb\_tuple->\hyperlink{structns3_1_1olsr_1_1NeighborTuple_a96d469ddecd638d7eb524de3bcd79edf}{willingness} = hello.willingness;
2082     \}
2083 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 72




Here is the caller graph for this function\+:
% FIG 73


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Populate\+Two\+Hop\+Neighbor\+Set@{Populate\+Two\+Hop\+Neighbor\+Set}}
\index{Populate\+Two\+Hop\+Neighbor\+Set@{Populate\+Two\+Hop\+Neighbor\+Set}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Populate\+Two\+Hop\+Neighbor\+Set(const olsr\+::\+Message\+Header \&msg, const olsr\+::\+Message\+Header\+::\+Hello \&hello)}{PopulateTwoHopNeighborSet(const olsr::MessageHeader &msg, const olsr::MessageHeader::Hello &hello)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Populate\+Two\+Hop\+Neighbor\+Set (
\begin{DoxyParamCaption}
\item[{const {\bf olsr\+::\+Message\+Header} \&}]{msg, }
\item[{const {\bf olsr\+::\+Message\+Header\+::\+Hello} \&}]{hello}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a4a8eb48c32cebfa630bb7168882faa26}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a4a8eb48c32cebfa630bb7168882faa26}


Updates the 2-\/hop Neighbor Set according to the information contained in a new received H\+E\+L\+LO message (following \{3626\}). 


\begin{DoxyParams}{Parameters}
{\em msg} & The received message. \\
\hline
{\em hello} & The received H\+E\+L\+LO sub-\/message. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2088 \{
2089   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} now = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ();
2090 
2091   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Olsr node "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress} << \textcolor{stringliteral}{": PopulateTwoHopNeighborSet
       BEGIN"});
2092 
2093   \textcolor{keywordflow}{for} (LinkSet::const\_iterator link\_tuple = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a1d8f1a95165973f05e3fd1ff0d76fbda}{GetLinks} ().begin ();
2094        link\_tuple != \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a1d8f1a95165973f05e3fd1ff0d76fbda}{GetLinks} ().end (); link\_tuple++)
2095     \{
2096       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Looking at link tuple: "} << *link\_tuple);
2097       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae01451170fb389d322b33ed6d954f460}{GetMainAddress} (link\_tuple->neighborIfaceAddr) != msg.GetOriginatorAddress ())
2098         \{
2099           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Link tuple ignored: "}
2100                         \textcolor{stringliteral}{"GetMainAddress (link\_tuple->neighborIfaceAddr) != msg.GetOriginatorAddress ()"});
2101           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"(GetMainAddress("} << link\_tuple->neighborIfaceAddr << \textcolor{stringliteral}{"): "}
2102                                            << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae01451170fb389d322b33ed6d954f460}{GetMainAddress} (link\_tuple->neighborIfaceAddr)
2103                                            << \textcolor{stringliteral}{"; msg.GetOriginatorAddress (): "} << msg.GetOriginatorAddress
       ());
2104           \textcolor{keywordflow}{continue};
2105         \}
2106 
2107       \textcolor{keywordflow}{if} (link\_tuple->symTime < now)
2108         \{
2109           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Link tuple ignored: expired."});
2110           \textcolor{keywordflow}{continue};
2111         \}
2112 
2113       \textcolor{keyword}{typedef} std::vector<olsr::MessageHeader::Hello::LinkMessage> LinkMessageVec;
2114       \textcolor{keywordflow}{for} (LinkMessageVec::const\_iterator linkMessage = hello.linkMessages.begin ();
2115            linkMessage != hello.linkMessages.end (); linkMessage++)
2116         \{
2117           \textcolor{keywordtype}{int} neighborType = (linkMessage->linkCode >> 2) & 0x3;
2118 \textcolor{preprocessor}{#ifdef NS3\_LOG\_ENABLE}
2119           \textcolor{keyword}{const} \textcolor{keywordtype}{char} *neighborTypeNames[3] = \{ \textcolor{stringliteral}{"NOT\_NEIGH"}, \textcolor{stringliteral}{"SYM\_NEIGH"}, \textcolor{stringliteral}{"MPR\_NEIGH"} \};
2120           \textcolor{keyword}{const} \textcolor{keywordtype}{char} *neighborTypeName = ((neighborType < 3) ?
2121                                           neighborTypeNames[neighborType]
2122                                           : \textcolor{stringliteral}{"(invalid value)"});
2123           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Looking at Link Message from HELLO message: neighborType="}
2124                         << neighborType << \textcolor{stringliteral}{" ("} << neighborTypeName << \textcolor{stringliteral}{")"});
2125 \textcolor{preprocessor}{#endif // NS3\_LOG\_ENABLE}
2126 
2127           \textcolor{keywordflow}{for} (std::vector<Ipv4Address>::const\_iterator nb2hop\_addr\_iter =
2128                  linkMessage->neighborInterfaceAddresses.begin ();
2129                nb2hop\_addr\_iter != linkMessage->neighborInterfaceAddresses.end ();
2130                nb2hop\_addr\_iter++)
2131             \{
2132               Ipv4Address nb2hop\_addr = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae01451170fb389d322b33ed6d954f460}{GetMainAddress} (*nb2hop\_addr\_iter);
2133               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Looking at 2-hop neighbor address from HELLO message: "}
2134                             << *nb2hop\_addr\_iter
2135                             << \textcolor{stringliteral}{" (main address is "} << nb2hop\_addr << \textcolor{stringliteral}{")"});
2136               \textcolor{keywordflow}{if} (neighborType == \hyperlink{olsr-routing-protocol_8cc_a46286c316da9922151b354295e71d35a}{OLSR\_SYM\_NEIGH} || neighborType == 
      \hyperlink{olsr-routing-protocol_8cc_a08fbe0b4c74b944f681630df4fa0fd82}{OLSR\_MPR\_NEIGH})
2137                 \{
2138                   \textcolor{comment}{// If the main address of the 2-hop neighbor address == main address}
2139                   \textcolor{comment}{// of the receiving node, silently discard the 2-hop}
2140                   \textcolor{comment}{// neighbor address.}
2141                   \textcolor{keywordflow}{if} (nb2hop\_addr == \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress})
2142                     \{
2143                       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Ignoring 2-hop neighbor (it is the node itself)"});
2144                       \textcolor{keywordflow}{continue};
2145                     \}
2146 
2147                   \textcolor{comment}{// Otherwise, a 2-hop tuple is created}
2148                   TwoHopNeighborTuple *nb2hop\_tuple =
2149                     \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a420ef02aeb9997bff09bbebd6a72e642}{FindTwoHopNeighborTuple} (msg.GetOriginatorAddress
       (), nb2hop\_addr);
2150                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Adding the 2-hop neighbor"}
2151                                 << (nb2hop\_tuple ? \textcolor{stringliteral}{" (refreshing existing entry)"} : \textcolor{stringliteral}{""}));
2152                   \textcolor{keywordflow}{if} (nb2hop\_tuple == NULL)
2153                     \{
2154                       TwoHopNeighborTuple new\_nb2hop\_tuple;
2155                       new\_nb2hop\_tuple.neighborMainAddr = msg.GetOriginatorAddress ();
2156                       new\_nb2hop\_tuple.twoHopNeighborAddr = nb2hop\_addr;
2157                       new\_nb2hop\_tuple.expirationTime = now + msg.GetVTime ();
2158                       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a0ba9661c0d7b61bb0785f3c10af566d5}{AddTwoHopNeighborTuple} (new\_nb2hop\_tuple);
2159                       \textcolor{comment}{// Schedules nb2hop tuple deletion}
2160                       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a80368d3da46150cf3fc9139c40f33d53}{m\_events}.\hyperlink{classns3_1_1EventGarbageCollector_a4f26a1f6e9a09e648eb31b46acd85144}{Track} (\hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (
      \hyperlink{olsr-routing-protocol_8cc_ad0a00c3386c4a24278b3b710ae798220}{DELAY} (new\_nb2hop\_tuple.expirationTime),
2161                                                            &
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a5e71d702e1b560c4645139912da27002}{RoutingProtocol::Nb2hopTupleTimerExpire}, \textcolor{keyword}{this},
2162                                                            new\_nb2hop\_tuple.neighborMainAddr,
2163                                                            new\_nb2hop\_tuple.twoHopNeighborAddr));
2164                     \}
2165                   \textcolor{keywordflow}{else}
2166                     \{
2167                       nb2hop\_tuple->expirationTime = now + msg.GetVTime ();
2168                     \}
2169                 \}
2170               \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (neighborType == \hyperlink{olsr-routing-protocol_8cc_a7ff690f7463019aec83c1f0edd911034}{OLSR\_NOT\_NEIGH})
2171                 \{
2172                   \textcolor{comment}{// For each 2-hop node listed in the HELLO message}
2173                   \textcolor{comment}{// with Neighbor Type equal to NOT\_NEIGH all 2-hop}
2174                   \textcolor{comment}{// tuples where: N\_neighbor\_main\_addr == Originator}
2175                   \textcolor{comment}{// Address AND N\_2hop\_addr == main address of the}
2176                   \textcolor{comment}{// 2-hop neighbor are deleted.}
2177                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"2-hop neighbor is NOT\_NEIGH => deleting matching 2-hop
       neighbor state"});
2178                   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a42bb2907567fb9ab9b17d28476c9859b}{EraseTwoHopNeighborTuples} (msg.
      GetOriginatorAddress (), nb2hop\_addr);
2179                 \}
2180               \textcolor{keywordflow}{else}
2181                 \{
2182                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"*** WARNING *** Ignoring link message (inside HELLO) with bad"}
2183                                 \textcolor{stringliteral}{" neighbor type value: "} << neighborType);
2184                 \}
2185             \}
2186         \}
2187     \}
2188 
2189   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Olsr node "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress} << \textcolor{stringliteral}{": PopulateTwoHopNeighborSet END"}
      );
2190 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 74




Here is the caller graph for this function\+:
% FIG 75


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Print\+Routing\+Table@{Print\+Routing\+Table}}
\index{Print\+Routing\+Table@{Print\+Routing\+Table}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Print\+Routing\+Table(\+Ptr$<$ Output\+Stream\+Wrapper $>$ stream, Time\+::\+Unit unit=\+Time\+::\+S) const }{PrintRoutingTable(Ptr< OutputStreamWrapper > stream, Time::Unit unit=Time::S) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Print\+Routing\+Table (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream, }
\item[{{\bf Time\+::\+Unit}}]{unit = {\ttfamily {\bf Time\+::S}}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a8b7d440d2ff617159fbf48c93e2ca895}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a8b7d440d2ff617159fbf48c93e2ca895}


Print the Routing Table entries. 


\begin{DoxyParams}{Parameters}
{\em stream} & The ostream the Routing table is printed to \\
\hline
{\em unit} & The time unit to be used in the report \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a86ad3fc1d17b06b6553a13b03d7e8cb4}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
255 \{
256   std::ostream* os = stream->\hyperlink{classns3_1_1OutputStreamWrapper_a0cf30a4188ab6fdae2b2ab74db11acc2}{GetStream} ();
257 
258   *os << \textcolor{stringliteral}{"Node: "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4}->GetObject<Node> ()->GetId ()
259       << \textcolor{stringliteral}{", Time: "} << \hyperlink{group__simulator_gac3635e2e87f7ce316c89290ee1b01d0d}{Now} ().\hyperlink{classns3_1_1Time_a0bb1110638ce9938248bd07865a328ab}{As} (unit)
260       << \textcolor{stringliteral}{", Local time: "} << GetObject<Node> ()->GetLocalTime ().As (unit)
261       << \textcolor{stringliteral}{", OLSR Routing table"} << std::endl;
262 
263   *os << \textcolor{stringliteral}{"Destination\(\backslash\)t\(\backslash\)tNextHop\(\backslash\)t\(\backslash\)tInterface\(\backslash\)tDistance\(\backslash\)n"};
264 
265   \textcolor{keywordflow}{for} (std::map<Ipv4Address, RoutingTableEntry>::const\_iterator iter = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a9703fb92cc9a864c0e2874387ead3aa3}{m\_table}.begin ();
266        iter != \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a9703fb92cc9a864c0e2874387ead3aa3}{m\_table}.end (); iter++)
267     \{
268       *os << iter->first << \textcolor{stringliteral}{"\(\backslash\)t\(\backslash\)t"};
269       *os << iter->second.nextAddr << \textcolor{stringliteral}{"\(\backslash\)t\(\backslash\)t"};
270       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Names_ab9664faf23569aaae64a2d1f65265045}{Names::FindName} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4}->GetNetDevice (iter->second.interface)) != \textcolor{stringliteral}{""})
271         \{
272           *os << \hyperlink{classns3_1_1Names_ab9664faf23569aaae64a2d1f65265045}{Names::FindName} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4}->GetNetDevice (iter->second.interface)) << \textcolor{stringliteral}{"
      \(\backslash\)t\(\backslash\)t"};
273         \}
274       \textcolor{keywordflow}{else}
275         \{
276           *os << iter->second.interface << \textcolor{stringliteral}{"\(\backslash\)t\(\backslash\)t"};
277         \}
278       *os << iter->second.distance << \textcolor{stringliteral}{"\(\backslash\)t"};
279       *os << \textcolor{stringliteral}{"\(\backslash\)n"};
280     \}
281 
282   \textcolor{comment}{// Also print the HNA routing table}
283   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a398799911ae136e0b247b4bbd608c336}{m\_hnaRoutingTable}->GetNRoutes () > 0)
284     \{
285       *os << \textcolor{stringliteral}{" HNA Routing Table: "};
286       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a398799911ae136e0b247b4bbd608c336}{m\_hnaRoutingTable}->PrintRoutingTable (stream, unit);
287     \}
288   \textcolor{keywordflow}{else}
289     \{
290       *os << \textcolor{stringliteral}{" HNA Routing Table: empty"} << std::endl;
291     \}
292 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 76


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Process\+Hello@{Process\+Hello}}
\index{Process\+Hello@{Process\+Hello}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Process\+Hello(const olsr\+::\+Message\+Header \&msg, const Ipv4\+Address \&receiver\+Iface, const Ipv4\+Address \&sender\+Iface)}{ProcessHello(const olsr::MessageHeader &msg, const Ipv4Address &receiverIface, const Ipv4Address &senderIface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Process\+Hello (
\begin{DoxyParamCaption}
\item[{const {\bf olsr\+::\+Message\+Header} \&}]{msg, }
\item[{const {\bf Ipv4\+Address} \&}]{receiver\+Iface, }
\item[{const {\bf Ipv4\+Address} \&}]{sender\+Iface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a9518c29e8994234ead40d408498237ce}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a9518c29e8994234ead40d408498237ce}


Processes a H\+E\+L\+LO message following \{3626\} specification. 

Link sensing and population of the Neighbor Set, 2-\/hop Neighbor Set and M\+PR Selector Set are performed.


\begin{DoxyParams}{Parameters}
{\em msg} & the O\+L\+SR message which contains the H\+E\+L\+LO message. \\
\hline
{\em receiver\+Iface} & the address of the interface where the message was received from. \\
\hline
{\em sender\+Iface} & the address of the interface where the message was sent from. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1226 \{
1227   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (msg << receiverIface << senderIface);
1228 
1229   \textcolor{keyword}{const} olsr::MessageHeader::Hello &hello = msg.GetHello ();
1230 
1231   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a2a23a0fd6fa714fef6613afd3f5bc1d2}{LinkSensing} (msg, hello, receiverIface, senderIface);
1232 
1233 \textcolor{preprocessor}{#ifdef NS3\_LOG\_ENABLE}
1234   \{
1235     \textcolor{keyword}{const} \hyperlink{namespacens3_1_1olsr_a60381cc41d65a2e0daabd286077a378a}{LinkSet} &links = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a1d8f1a95165973f05e3fd1ff0d76fbda}{GetLinks} ();
1236     \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds ()
1237                   << \textcolor{stringliteral}{"s ** BEGIN dump Link Set for OLSR Node "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress});
1238     \textcolor{keywordflow}{for} (LinkSet::const\_iterator link = links.begin (); link != links.end (); link++)
1239       \{
1240         \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (*link);
1241       \}
1242     \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"** END dump Link Set for OLSR Node "} << 
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress});
1243 
1244     \textcolor{keyword}{const} \hyperlink{namespacens3_1_1olsr_af0afef1f28c6f0a0b528b03b638df05d}{NeighborSet} &neighbors = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a82d5882ca3fdb93a9c1110c6f176c03c}{GetNeighbors} ();
1245     \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds ()
1246                   << \textcolor{stringliteral}{"s ** BEGIN dump Neighbor Set for OLSR Node "} << 
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress});
1247     \textcolor{keywordflow}{for} (NeighborSet::const\_iterator neighbor = neighbors.begin (); neighbor != neighbors.end (); neighbor+
      +)
1248       \{
1249         \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (*neighbor);
1250       \}
1251     \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"** END dump Neighbor Set for OLSR Node "} << 
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress});
1252   \}
1253 \textcolor{preprocessor}{#endif // NS3\_LOG\_ENABLE}
1254 
1255   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a9a9cccf9682782a0b95539862b4e6b53}{PopulateNeighborSet} (msg, hello);
1256   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a4a8eb48c32cebfa630bb7168882faa26}{PopulateTwoHopNeighborSet} (msg, hello);
1257 
1258 \textcolor{preprocessor}{#ifdef NS3\_LOG\_ENABLE}
1259   \{
1260     \textcolor{keyword}{const} \hyperlink{namespacens3_1_1olsr_a5f9963792af7fea4dc66fb8718394604}{TwoHopNeighborSet} &twoHopNeighbors = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.
      \hyperlink{classns3_1_1olsr_1_1OlsrState_ab03738874d0d785b770beef6dc9c2e1a}{GetTwoHopNeighbors} ();
1261     \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds ()
1262                   << \textcolor{stringliteral}{"s ** BEGIN dump TwoHopNeighbor Set for OLSR Node "} << 
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress});
1263     \textcolor{keywordflow}{for} (TwoHopNeighborSet::const\_iterator tuple = twoHopNeighbors.begin ();
1264          tuple != twoHopNeighbors.end (); tuple++)
1265       \{
1266         \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (*tuple);
1267       \}
1268     \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"** END dump TwoHopNeighbor Set for OLSR Node "} << 
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress});
1269   \}
1270 \textcolor{preprocessor}{#endif // NS3\_LOG\_ENABLE}
1271 
1272   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a947ab35f39d191ed51d3fbb7c1cc282c}{MprComputation} ();
1273   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a56bce0e7794315308e10e5fd1343cfaf}{PopulateMprSelectorSet} (msg, hello);
1274 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 77




Here is the caller graph for this function\+:
% FIG 78


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Process\+Hna@{Process\+Hna}}
\index{Process\+Hna@{Process\+Hna}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Process\+Hna(const olsr\+::\+Message\+Header \&msg, const Ipv4\+Address \&sender\+Iface)}{ProcessHna(const olsr::MessageHeader &msg, const Ipv4Address &senderIface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Process\+Hna (
\begin{DoxyParamCaption}
\item[{const {\bf olsr\+::\+Message\+Header} \&}]{msg, }
\item[{const {\bf Ipv4\+Address} \&}]{sender\+Iface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_ab384b31d2faae5b64952052a7eb4eed2}{}\label{classns3_1_1olsr_1_1RoutingProtocol_ab384b31d2faae5b64952052a7eb4eed2}


Processes a H\+NA message following \{3626\} specification. 

The Host Network \hyperlink{structns3_1_1olsr_1_1Association}{Association} Set is updated (if needed) with the information of the received H\+NA message.


\begin{DoxyParams}{Parameters}
{\em msg} & the O\+L\+SR message which contains the H\+NA message. \\
\hline
{\em sender\+Iface} & the address of the interface where the message was sent from. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1439 \{
1440 
1441   \textcolor{keyword}{const} olsr::MessageHeader::Hna &hna = msg.GetHna ();
1442   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} now = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ();
1443 
1444   \textcolor{comment}{// 1. If the sender interface of this message is not in the symmetric}
1445   \textcolor{comment}{// 1-hop neighborhood of this node, the message MUST be discarded.}
1446   \textcolor{keyword}{const} LinkTuple *link\_tuple = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a5005529fbbd5fa4a015591a93d715890}{FindSymLinkTuple} (senderIface, now);
1447   \textcolor{keywordflow}{if} (link\_tuple == NULL)
1448     \{
1449       \textcolor{keywordflow}{return};
1450     \}
1451 
1452   \textcolor{comment}{// 2. Otherwise, for each (network address, netmask) pair in the}
1453   \textcolor{comment}{// message:}
1454 
1455   \textcolor{keywordflow}{for} (std::vector<olsr::MessageHeader::Hna::Association>::const\_iterator it = hna.associations.begin ();
1456        it != hna.associations.end (); it++)
1457     \{
1458       AssociationTuple *tuple = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_aa399ca44ad27907342350710d1904b84}{FindAssociationTuple} (msg.
      GetOriginatorAddress (),it->address,it->mask);
1459 
1460       \textcolor{comment}{// 2.1  if an entry in the association set already exists, where:}
1461       \textcolor{comment}{//          A\_gateway\_addr == originator address}
1462       \textcolor{comment}{//          A\_network\_addr == network address}
1463       \textcolor{comment}{//          A\_netmask      == netmask}
1464       \textcolor{comment}{//      then the holding time for that tuple MUST be set to:}
1465       \textcolor{comment}{//          A\_time         =  current time + validity time}
1466       \textcolor{keywordflow}{if} (tuple != NULL)
1467         \{
1468           tuple->\hyperlink{structns3_1_1olsr_1_1AssociationTuple_a9becaf0d713a9ed1db7834d0f3cdb864}{expirationTime} = now + msg.GetVTime ();
1469         \}
1470 
1471       \textcolor{comment}{// 2.2 otherwise, a new tuple MUST be recorded with:}
1472       \textcolor{comment}{//          A\_gateway\_addr =  originator address}
1473       \textcolor{comment}{//          A\_network\_addr =  network address}
1474       \textcolor{comment}{//          A\_netmask      =  netmask}
1475       \textcolor{comment}{//          A\_time         =  current time + validity time}
1476       \textcolor{keywordflow}{else}
1477         \{
1478           AssociationTuple assocTuple = \{
1479             msg.GetOriginatorAddress (),
1480             it->address,
1481             it->mask,
1482             now + msg.GetVTime ()
1483           \};
1484           \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ad6e926e46d787847b63433a0b9072553}{AddAssociationTuple} (assocTuple);
1485 
1486           \textcolor{comment}{//Schedule Association Tuple deletion}
1487           \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{olsr-routing-protocol_8cc_ad0a00c3386c4a24278b3b710ae798220}{DELAY} (assocTuple.expirationTime),
1488                                &\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a60b5814cf05807e207ac9ebe1f6d90b6}{RoutingProtocol::AssociationTupleTimerExpire}
      , \textcolor{keyword}{this},
1489                                assocTuple.gatewayAddr,assocTuple.networkAddr,assocTuple.netmask);
1490         \}
1491 
1492     \}
1493 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 79




Here is the caller graph for this function\+:
% FIG 80


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Process\+Mid@{Process\+Mid}}
\index{Process\+Mid@{Process\+Mid}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Process\+Mid(const olsr\+::\+Message\+Header \&msg, const Ipv4\+Address \&sender\+Iface)}{ProcessMid(const olsr::MessageHeader &msg, const Ipv4Address &senderIface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Process\+Mid (
\begin{DoxyParamCaption}
\item[{const {\bf olsr\+::\+Message\+Header} \&}]{msg, }
\item[{const {\bf Ipv4\+Address} \&}]{sender\+Iface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a88dd2a9e226e50034c548787d9d529f3}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a88dd2a9e226e50034c548787d9d529f3}


Processes a M\+ID message following \{3626\} specification. 

The Interface \hyperlink{structns3_1_1olsr_1_1Association}{Association} Set is updated (if needed) with the information of the received M\+ID message.


\begin{DoxyParams}{Parameters}
{\em msg} & the O\+L\+SR message which contains the M\+ID message. \\
\hline
{\em sender\+Iface} & the address of the interface where the message was sent from. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1369 \{
1370   \textcolor{keyword}{const} olsr::MessageHeader::Mid &mid = msg.GetMid ();
1371   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} now = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ();
1372 
1373   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Node "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress} << \textcolor{stringliteral}{" ProcessMid from "} << senderIface);
1374   \textcolor{comment}{// 1. If the sender interface of this message is not in the symmetric}
1375   \textcolor{comment}{// 1-hop neighborhood of this node, the message MUST be discarded.}
1376   \textcolor{keyword}{const} LinkTuple *linkTuple = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a5005529fbbd5fa4a015591a93d715890}{FindSymLinkTuple} (senderIface, now);
1377   \textcolor{keywordflow}{if} (linkTuple == NULL)
1378     \{
1379       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Node "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress} <<
1380                     \textcolor{stringliteral}{": the sender interface of this message is not in the "}
1381                     \textcolor{stringliteral}{"symmetric 1-hop neighborhood of this node,"}
1382                     \textcolor{stringliteral}{" the message MUST be discarded."});
1383       \textcolor{keywordflow}{return};
1384     \}
1385 
1386   \textcolor{comment}{// 2. For each interface address listed in the MID message}
1387   \textcolor{keywordflow}{for} (std::vector<Ipv4Address>::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = mid.interfaceAddresses.begin ();
1388        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != mid.interfaceAddresses.end (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
1389     \{
1390       \textcolor{keywordtype}{bool} updated = \textcolor{keyword}{false};
1391       \hyperlink{namespacens3_1_1olsr_af7456b9ea2cde8c7d88443de06c015f4}{IfaceAssocSet} &ifaceAssoc = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.
      \hyperlink{classns3_1_1olsr_1_1OlsrState_aff6a1f0bac684ac28ea0bed037cc7ef2}{GetIfaceAssocSetMutable} ();
1392       \textcolor{keywordflow}{for} (IfaceAssocSet::iterator tuple = ifaceAssoc.begin ();
1393            tuple != ifaceAssoc.end (); tuple++)
1394         \{
1395           \textcolor{keywordflow}{if} (tuple->ifaceAddr == *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}
1396               && tuple->mainAddr == msg.GetOriginatorAddress ())
1397             \{
1398               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"IfaceAssoc updated: "} << *tuple);
1399               tuple->time = now + msg.GetVTime ();
1400               updated = \textcolor{keyword}{true};
1401             \}
1402         \}
1403       \textcolor{keywordflow}{if} (!updated)
1404         \{
1405           IfaceAssocTuple tuple;
1406           tuple.ifaceAddr = *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
1407           tuple.mainAddr = msg.GetOriginatorAddress ();
1408           tuple.time = now + msg.GetVTime ();
1409           \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a727294984dac11244bf1e92baa141934}{AddIfaceAssocTuple} (tuple);
1410           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"New IfaceAssoc added: "} << tuple);
1411           \textcolor{comment}{// Schedules iface association tuple deletion}
1412           \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{olsr-routing-protocol_8cc_ad0a00c3386c4a24278b3b710ae798220}{DELAY} (tuple.time),
1413                                &\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_af93aa9d349c1be0aef8401d2e4189d4c}{RoutingProtocol::IfaceAssocTupleTimerExpire}
      , \textcolor{keyword}{this}, tuple.ifaceAddr);
1414         \}
1415     \}
1416 
1417   \textcolor{comment}{// 3. (not part of the RFC) iterate over all NeighborTuple's and}
1418   \textcolor{comment}{// TwoHopNeighborTuples, update the neighbor addresses taking into account}
1419   \textcolor{comment}{// the new MID information.}
1420   \hyperlink{namespacens3_1_1olsr_af0afef1f28c6f0a0b528b03b638df05d}{NeighborSet} &neighbors = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a82d5882ca3fdb93a9c1110c6f176c03c}{GetNeighbors} ();
1421   \textcolor{keywordflow}{for} (NeighborSet::iterator neighbor = neighbors.begin (); neighbor != neighbors.end (); neighbor++)
1422     \{
1423       neighbor->neighborMainAddr = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae01451170fb389d322b33ed6d954f460}{GetMainAddress} (neighbor->neighborMainAddr);
1424     \}
1425 
1426   \hyperlink{namespacens3_1_1olsr_a5f9963792af7fea4dc66fb8718394604}{TwoHopNeighborSet} &twoHopNeighbors = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.
      \hyperlink{classns3_1_1olsr_1_1OlsrState_ab03738874d0d785b770beef6dc9c2e1a}{GetTwoHopNeighbors} ();
1427   \textcolor{keywordflow}{for} (TwoHopNeighborSet::iterator twoHopNeighbor = twoHopNeighbors.begin ();
1428        twoHopNeighbor != twoHopNeighbors.end (); twoHopNeighbor++)
1429     \{
1430       twoHopNeighbor->neighborMainAddr = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae01451170fb389d322b33ed6d954f460}{GetMainAddress} (twoHopNeighbor->neighborMainAddr);
1431       twoHopNeighbor->twoHopNeighborAddr = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae01451170fb389d322b33ed6d954f460}{GetMainAddress} (twoHopNeighbor->twoHopNeighborAddr
      );
1432     \}
1433   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Node "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress} << \textcolor{stringliteral}{" ProcessMid from "} << senderIface << \textcolor{stringliteral}{
      " -> END."});
1434 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 81




Here is the caller graph for this function\+:
% FIG 82


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Process\+Tc@{Process\+Tc}}
\index{Process\+Tc@{Process\+Tc}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Process\+Tc(const olsr\+::\+Message\+Header \&msg, const Ipv4\+Address \&sender\+Iface)}{ProcessTc(const olsr::MessageHeader &msg, const Ipv4Address &senderIface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Process\+Tc (
\begin{DoxyParamCaption}
\item[{const {\bf olsr\+::\+Message\+Header} \&}]{msg, }
\item[{const {\bf Ipv4\+Address} \&}]{sender\+Iface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a5087b5cbf87313f1073341aebc9ced27}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a5087b5cbf87313f1073341aebc9ced27}


Processes a TC message following \{3626\} specification. 

The Topology Set is updated (if needed) with the information of the received TC message.


\begin{DoxyParams}{Parameters}
{\em msg} & The O\+L\+SR message which contains the TC message. \\
\hline
{\em sender\+Iface} & The address of the interface where the message was sent from. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1279 \{
1280   \textcolor{keyword}{const} olsr::MessageHeader::Tc &tc = msg.GetTc ();
1281   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} now = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ();
1282 
1283   \textcolor{comment}{// 1. If the sender interface of this message is not in the symmetric}
1284   \textcolor{comment}{// 1-hop neighborhood of this node, the message MUST be discarded.}
1285   \textcolor{keyword}{const} LinkTuple *link\_tuple = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a5005529fbbd5fa4a015591a93d715890}{FindSymLinkTuple} (senderIface, now);
1286   \textcolor{keywordflow}{if} (link\_tuple == NULL)
1287     \{
1288       \textcolor{keywordflow}{return};
1289     \}
1290 
1291   \textcolor{comment}{// 2. If there exist some tuple in the topology set where:}
1292   \textcolor{comment}{//    T\_last\_addr == originator address AND}
1293   \textcolor{comment}{//    T\_seq       >  ANSN,}
1294   \textcolor{comment}{// then further processing of this TC message MUST NOT be}
1295   \textcolor{comment}{// performed.}
1296   \textcolor{keyword}{const} TopologyTuple *topologyTuple =
1297     \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a6d2971e517b703daede2df48ff3ece15}{FindNewerTopologyTuple} (msg.GetOriginatorAddress (), tc.ansn);
1298   \textcolor{keywordflow}{if} (topologyTuple != NULL)
1299     \{
1300       \textcolor{keywordflow}{return};
1301     \}
1302 
1303   \textcolor{comment}{// 3. All tuples in the topology set where:}
1304   \textcolor{comment}{//    T\_last\_addr == originator address AND}
1305   \textcolor{comment}{//    T\_seq       <  ANSN}
1306   \textcolor{comment}{// MUST be removed from the topology set.}
1307   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_ae5a0a2833e66d8e0df0315502e2d7acb}{EraseOlderTopologyTuples} (msg.GetOriginatorAddress (), tc.ansn);
1308 
1309   \textcolor{comment}{// 4. For each of the advertised neighbor main address received in}
1310   \textcolor{comment}{// the TC message:}
1311   \textcolor{keywordflow}{for} (std::vector<Ipv4Address>::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = tc.neighborAddresses.begin ();
1312        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != tc.neighborAddresses.end (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
1313     \{
1314       \textcolor{keyword}{const} Ipv4Address &addr = *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
1315       \textcolor{comment}{// 4.1. If there exist some tuple in the topology set where:}
1316       \textcolor{comment}{//      T\_dest\_addr == advertised neighbor main address, AND}
1317       \textcolor{comment}{//      T\_last\_addr == originator address,}
1318       \textcolor{comment}{// then the holding time of that tuple MUST be set to:}
1319       \textcolor{comment}{//      T\_time      =  current time + validity time.}
1320       TopologyTuple *topologyTuple =
1321         \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a9f2882a2443c4bbcaeea3e92d178b960}{FindTopologyTuple} (addr, msg.GetOriginatorAddress ());
1322 
1323       \textcolor{keywordflow}{if} (topologyTuple != NULL)
1324         \{
1325           topologyTuple->\hyperlink{structns3_1_1olsr_1_1TopologyTuple_ac567bb92fd21ca445e202dcec2538ecb}{expirationTime} = now + msg.GetVTime ();
1326         \}
1327       \textcolor{keywordflow}{else}
1328         \{
1329           \textcolor{comment}{// 4.2. Otherwise, a new tuple MUST be recorded in the topology}
1330           \textcolor{comment}{// set where:}
1331           \textcolor{comment}{//      T\_dest\_addr = advertised neighbor main address,}
1332           \textcolor{comment}{//      T\_last\_addr = originator address,}
1333           \textcolor{comment}{//      T\_seq       = ANSN,}
1334           \textcolor{comment}{//      T\_time      = current time + validity time.}
1335           TopologyTuple topologyTuple;
1336           topologyTuple.destAddr = addr;
1337           topologyTuple.lastAddr = msg.GetOriginatorAddress ();
1338           topologyTuple.sequenceNumber = tc.ansn;
1339           topologyTuple.expirationTime = now + msg.GetVTime ();
1340           \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a4c151dc96f3b7208d03be261a2ada627}{AddTopologyTuple} (topologyTuple);
1341 
1342           \textcolor{comment}{// Schedules topology tuple deletion}
1343           \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a80368d3da46150cf3fc9139c40f33d53}{m\_events}.\hyperlink{classns3_1_1EventGarbageCollector_a4f26a1f6e9a09e648eb31b46acd85144}{Track} (\hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (
      \hyperlink{olsr-routing-protocol_8cc_ad0a00c3386c4a24278b3b710ae798220}{DELAY} (topologyTuple.expirationTime),
1344                                                &
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a9200f9b5d45ca2eacf92027ca0355182}{RoutingProtocol::TopologyTupleTimerExpire},
1345                                                \textcolor{keyword}{this},
1346                                                topologyTuple.destAddr,
1347                                                topologyTuple.lastAddr));
1348         \}
1349     \}
1350 
1351 \textcolor{preprocessor}{#ifdef NS3\_LOG\_ENABLE}
1352   \{
1353     \textcolor{keyword}{const} \hyperlink{namespacens3_1_1olsr_aa5a4b5a4c916439ca513b91928d7eba0}{TopologySet} &topology = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a2ca307d08ead8410b13ab05ec073b45a}{GetTopologySet} ();
1354     \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds ()
1355                   << \textcolor{stringliteral}{"s ** BEGIN dump TopologySet for OLSR Node "} << 
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress});
1356     \textcolor{keywordflow}{for} (TopologySet::const\_iterator tuple = topology.begin ();
1357          tuple != topology.end (); tuple++)
1358       \{
1359         \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (*tuple);
1360       \}
1361     \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"** END dump TopologySet Set for OLSR Node "} << 
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress});
1362   \}
1363 \textcolor{preprocessor}{#endif // NS3\_LOG\_ENABLE}
1364 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 83




Here is the caller graph for this function\+:
% FIG 84


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Queue\+Message@{Queue\+Message}}
\index{Queue\+Message@{Queue\+Message}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Queue\+Message(const olsr\+::\+Message\+Header \&message, Time delay)}{QueueMessage(const olsr::MessageHeader &message, Time delay)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Queue\+Message (
\begin{DoxyParamCaption}
\item[{const {\bf olsr\+::\+Message\+Header} \&}]{message, }
\item[{{\bf Time}}]{delay}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a206c7c0bba382cba1ac50d11a7df88f3}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a206c7c0bba382cba1ac50d11a7df88f3}


Enques an O\+L\+SR message which will be sent with a delay of (0, delay\mbox{]}. 

This buffering system is used in order to piggyback several O\+L\+SR messages in a same O\+L\+SR packet.


\begin{DoxyParams}{Parameters}
{\em message} & the O\+L\+SR message which must be sent. \\
\hline
{\em delay} & maximum delay the O\+L\+SR message is going to be buffered. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1565 \{
1566   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a1366596191a80005da6f45af00585d1d}{m\_queuedMessages}.push\_back (message);
1567   \textcolor{keywordflow}{if} (not \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a8b54985da7787840baa68ce4781e5d76}{m\_queuedMessagesTimer}.\hyperlink{classns3_1_1Timer_addbc6c740f21ddeb6ad358557962b24c}{IsRunning} ())
1568     \{
1569       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a8b54985da7787840baa68ce4781e5d76}{m\_queuedMessagesTimer}.\hyperlink{classns3_1_1Timer_a02ac85f61e64a2bc3a104914859504c9}{SetDelay} (\hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_a7964e6aa8f61a9d28973c8267a606ad8}{delay});
1570       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a8b54985da7787840baa68ce4781e5d76}{m\_queuedMessagesTimer}.\hyperlink{classns3_1_1Timer_ac3345d696887578f518b19f359f7f94b}{Schedule} ();
1571     \}
1572 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 85




Here is the caller graph for this function\+:
% FIG 86


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Recv\+Olsr@{Recv\+Olsr}}
\index{Recv\+Olsr@{Recv\+Olsr}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Recv\+Olsr(\+Ptr$<$ Socket $>$ socket)}{RecvOlsr(Ptr< Socket > socket)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Recv\+Olsr (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Socket} $>$}]{socket}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_afa449e39488b5c03609960e66553490e}{}\label{classns3_1_1olsr_1_1RoutingProtocol_afa449e39488b5c03609960e66553490e}
Receive an O\+L\+SR message. 
\begin{DoxyParams}{Parameters}
{\em socket} & The receiving socket. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
384 \{
385   Ptr<Packet> receivedPacket;
386   Address sourceAddress;
387   receivedPacket = socket->\hyperlink{classns3_1_1Socket_af22378d7af9a2745a9eada20210da215}{RecvFrom} (sourceAddress);
388 
389   InetSocketAddress inetSourceAddr = \hyperlink{classns3_1_1InetSocketAddress_ade776b1109e7b9a7be0b22ced49931e3}{InetSocketAddress::ConvertFrom} (
      sourceAddress);
390   Ipv4Address senderIfaceAddr = inetSourceAddr.GetIpv4 ();
391   Ipv4Address receiverIfaceAddr = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae590f1f394f2ebc0fac434a6866d7c75}{m\_socketAddresses}[socket].GetLocal ();
392   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (receiverIfaceAddr != Ipv4Address ());
393   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"OLSR node "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress} << \textcolor{stringliteral}{" received a OLSR packet from "}
394                              << senderIfaceAddr << \textcolor{stringliteral}{" to "} << receiverIfaceAddr);
395 
396   \textcolor{comment}{// All routing messages are sent from and to port RT\_PORT,}
397   \textcolor{comment}{// so we check it.}
398   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (inetSourceAddr.GetPort () == \hyperlink{olsr-routing-protocol_8cc_a56099fb2a14f4a74c5e155c13e9ef8db}{OLSR\_PORT\_NUMBER});
399 
400   Ptr<Packet> packet = receivedPacket;
401 
402   olsr::PacketHeader olsrPacketHeader;
403   packet->RemoveHeader (olsrPacketHeader);
404   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (olsrPacketHeader.GetPacketLength () >= olsrPacketHeader.GetSerializedSize ());
405   uint32\_t sizeLeft = olsrPacketHeader.GetPacketLength () - olsrPacketHeader.GetSerializedSize ();
406 
407   \hyperlink{namespacens3_1_1olsr_af17c710718a5637d01f37804a0a53e78}{MessageList} messages;
408 
409   \textcolor{keywordflow}{while} (sizeLeft)
410     \{
411       MessageHeader messageHeader;
412       \textcolor{keywordflow}{if} (packet->RemoveHeader (messageHeader) == 0)
413         \{
414           \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\textcolor{keyword}{false});
415         \}
416 
417       sizeLeft -= messageHeader.GetSerializedSize ();
418 
419       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Olsr Msg received with type "}
420                     << std::dec << \textcolor{keywordtype}{int} (messageHeader.GetMessageType ())
421                     << \textcolor{stringliteral}{" TTL="} << \textcolor{keywordtype}{int} (messageHeader.GetTimeToLive ())
422                     << \textcolor{stringliteral}{" origAddr="} << messageHeader.GetOriginatorAddress ());
423       messages.push\_back (messageHeader);
424     \}
425 
426   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a861b1d2ce370ab0137e67c5a1102a937}{m\_rxPacketTrace} (olsrPacketHeader, messages);
427 
428   \textcolor{keywordflow}{for} (MessageList::const\_iterator messageIter = messages.begin ();
429        messageIter != messages.end (); messageIter++)
430     \{
431       \textcolor{keyword}{const} MessageHeader &messageHeader = *messageIter;
432       \textcolor{comment}{// If ttl is less than or equal to zero, or}
433       \textcolor{comment}{// the receiver is the same as the originator,}
434       \textcolor{comment}{// the message must be silently dropped}
435       \textcolor{keywordflow}{if} (messageHeader.GetTimeToLive () == 0
436           || messageHeader.GetOriginatorAddress () == \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress})
437         \{
438           packet->RemoveAtStart (messageHeader.GetSerializedSize ()
439                                  - messageHeader.GetSerializedSize ());
440           \textcolor{keywordflow}{continue};
441         \}
442 
443       \textcolor{comment}{// If the message has been processed it must not be processed again}
444       \textcolor{keywordtype}{bool} do\_forwarding = \textcolor{keyword}{true};
445       DuplicateTuple *duplicated = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_ab00d5bb24a075329d19cf44af31524d1}{FindDuplicateTuple}
446           (messageHeader.GetOriginatorAddress (),
447           messageHeader.GetMessageSequenceNumber ());
448 
449       \textcolor{comment}{// Get main address of the peer, which may be different from the packet source address}
450 \textcolor{comment}{//       const IfaceAssocTuple *ifaceAssoc = m\_state.FindIfaceAssocTuple (inetSourceAddr.GetIpv4 ());}
451 \textcolor{comment}{//       Ipv4Address peerMainAddress;}
452 \textcolor{comment}{//       if (ifaceAssoc != NULL)}
453 \textcolor{comment}{//         \{}
454 \textcolor{comment}{//           peerMainAddress = ifaceAssoc->mainAddr;}
455 \textcolor{comment}{//         \}}
456 \textcolor{comment}{//       else}
457 \textcolor{comment}{//         \{}
458 \textcolor{comment}{//           peerMainAddress = inetSourceAddr.GetIpv4 () ;}
459 \textcolor{comment}{//         \}}
460 
461       \textcolor{keywordflow}{if} (duplicated == NULL)
462         \{
463           \textcolor{keywordflow}{switch} (messageHeader.GetMessageType ())
464             \{
465             \textcolor{keywordflow}{case} \hyperlink{classns3_1_1olsr_1_1MessageHeader_aff5a31b07c415097a5ada41d53e9a99ea95ef9dc453d91d351d1a35cc4650e192}{olsr::MessageHeader::HELLO\_MESSAGE}:
466               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds ()
467                             << \textcolor{stringliteral}{"s OLSR node "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress}
468                             << \textcolor{stringliteral}{" received HELLO message of size "} << messageHeader.GetSerializedSize ());
469               \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a9518c29e8994234ead40d408498237ce}{ProcessHello} (messageHeader, receiverIfaceAddr, senderIfaceAddr);
470               \textcolor{keywordflow}{break};
471 
472             \textcolor{keywordflow}{case} \hyperlink{classns3_1_1olsr_1_1MessageHeader_aff5a31b07c415097a5ada41d53e9a99ea079e75713d9846b17df8b9d722ee5ab3}{olsr::MessageHeader::TC\_MESSAGE}:
473               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds ()
474                             << \textcolor{stringliteral}{"s OLSR node "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress}
475                             << \textcolor{stringliteral}{" received TC message of size "} << messageHeader.GetSerializedSize ());
476               \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a5087b5cbf87313f1073341aebc9ced27}{ProcessTc} (messageHeader, senderIfaceAddr);
477               \textcolor{keywordflow}{break};
478 
479             \textcolor{keywordflow}{case} \hyperlink{classns3_1_1olsr_1_1MessageHeader_aff5a31b07c415097a5ada41d53e9a99ea56ed595e1305b9889be591227fb9997b}{olsr::MessageHeader::MID\_MESSAGE}:
480               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds ()
481                             << \textcolor{stringliteral}{"s OLSR node "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress}
482                             <<  \textcolor{stringliteral}{" received MID message of size "} << messageHeader.GetSerializedSize ());
483               \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a88dd2a9e226e50034c548787d9d529f3}{ProcessMid} (messageHeader, senderIfaceAddr);
484               \textcolor{keywordflow}{break};
485             \textcolor{keywordflow}{case} \hyperlink{classns3_1_1olsr_1_1MessageHeader_aff5a31b07c415097a5ada41d53e9a99ea12c3f411859a1e9cc5b5442a7fdd2f89}{olsr::MessageHeader::HNA\_MESSAGE}:
486               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds ()
487                             << \textcolor{stringliteral}{"s OLSR node "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress}
488                             <<  \textcolor{stringliteral}{" received HNA message of size "} << messageHeader.GetSerializedSize ());
489               \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ab384b31d2faae5b64952052a7eb4eed2}{ProcessHna} (messageHeader, senderIfaceAddr);
490               \textcolor{keywordflow}{break};
491 
492             \textcolor{keywordflow}{default}:
493               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"OLSR message type "} <<
494                             \textcolor{keywordtype}{int} (messageHeader.GetMessageType ()) <<
495                             \textcolor{stringliteral}{" not implemented"});
496             \}
497         \}
498       \textcolor{keywordflow}{else}
499         \{
500           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"OLSR message is duplicated, not reading it."});
501 
502           \textcolor{comment}{// If the message has been considered for forwarding, it should}
503           \textcolor{comment}{// not be retransmitted again}
504           \textcolor{keywordflow}{for} (std::vector<Ipv4Address>::const\_iterator it = duplicated->ifaceList.begin ();
505                it != duplicated->ifaceList.end (); it++)
506             \{
507               \textcolor{keywordflow}{if} (*it == receiverIfaceAddr)
508                 \{
509                   do\_forwarding = \textcolor{keyword}{false};
510                   \textcolor{keywordflow}{break};
511                 \}
512             \}
513         \}
514 
515       \textcolor{keywordflow}{if} (do\_forwarding)
516         \{
517           \textcolor{comment}{// HELLO messages are never forwarded.}
518           \textcolor{comment}{// TC and MID messages are forwarded using the default algorithm.}
519           \textcolor{comment}{// Remaining messages are also forwarded using the default algorithm.}
520           \textcolor{keywordflow}{if} (messageHeader.GetMessageType ()  != 
      \hyperlink{classns3_1_1olsr_1_1MessageHeader_aff5a31b07c415097a5ada41d53e9a99ea95ef9dc453d91d351d1a35cc4650e192}{olsr::MessageHeader::HELLO\_MESSAGE})
521             \{
522               \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ac918fb6674847bee76fedaf16e15ba44}{ForwardDefault} (messageHeader, duplicated,
523                               receiverIfaceAddr, inetSourceAddr.GetIpv4 ());
524             \}
525         \}
526     \}
527 
528   \textcolor{comment}{// After processing all OLSR messages, we must recompute the routing table}
529   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a69fcd3b690fbf6e2b46735145cecfe3e}{RoutingTableComputation} ();
530 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 87




Here is the caller graph for this function\+:
% FIG 88


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Remove\+Association\+Tuple@{Remove\+Association\+Tuple}}
\index{Remove\+Association\+Tuple@{Remove\+Association\+Tuple}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Remove\+Association\+Tuple(const Association\+Tuple \&tuple)}{RemoveAssociationTuple(const AssociationTuple &tuple)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Remove\+Association\+Tuple (
\begin{DoxyParamCaption}
\item[{const {\bf Association\+Tuple} \&}]{tuple}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_adde5e8973ecbb7a4cbe0c8585e5c2237}{}\label{classns3_1_1olsr_1_1RoutingProtocol_adde5e8973ecbb7a4cbe0c8585e5c2237}


Removes a host network association tuple to the \hyperlink{structns3_1_1olsr_1_1Association}{Association} Set. 


\begin{DoxyParams}{Parameters}
{\em tuple} & The host network association tuple to be removed. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2549 \{
2550   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a91bb7f6b82946760281081ee3f53f13c}{EraseAssociationTuple} (tuple);
2551 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 89




Here is the caller graph for this function\+:
% FIG 90


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Remove\+Duplicate\+Tuple@{Remove\+Duplicate\+Tuple}}
\index{Remove\+Duplicate\+Tuple@{Remove\+Duplicate\+Tuple}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Remove\+Duplicate\+Tuple(const Duplicate\+Tuple \&tuple)}{RemoveDuplicateTuple(const DuplicateTuple &tuple)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Remove\+Duplicate\+Tuple (
\begin{DoxyParamCaption}
\item[{const {\bf Duplicate\+Tuple} \&}]{tuple}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a72a3220cc44a4fadc7156bfc2603e547}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a72a3220cc44a4fadc7156bfc2603e547}


Removes a duplicate tuple from the Duplicate Set. 


\begin{DoxyParams}{Parameters}
{\em tuple} & The duplicate tuple to be removed. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2315 \{
2316   \textcolor{comment}{/*debug("%f: Node %d removes dup tuple: addr = %d seq\_num = %d\(\backslash\)n",}
2317 \textcolor{comment}{    Simulator::Now (),}
2318 \textcolor{comment}{    OLSR::node\_id(ra\_addr()),}
2319 \textcolor{comment}{    OLSR::node\_id(tuple->addr()),}
2320 \textcolor{comment}{    tuple->seq\_num());*/}
2321   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_ae5c6cc7ca8d102f3ac28026dd84149c4}{EraseDuplicateTuple} (tuple);
2322 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 91




Here is the caller graph for this function\+:
% FIG 92


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Remove\+Entry@{Remove\+Entry}}
\index{Remove\+Entry@{Remove\+Entry}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Remove\+Entry(const Ipv4\+Address \&dest)}{RemoveEntry(const Ipv4Address &dest)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Remove\+Entry (
\begin{DoxyParamCaption}
\item[{const {\bf Ipv4\+Address} \&}]{dest}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a9a1bd13a5259f062ede82512067545c1}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a9a1bd13a5259f062ede82512067545c1}


Deletes the entry whose destination address is given. 


\begin{DoxyParams}{Parameters}
{\em dest} & address of the destination node. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2776 \{
2777   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a9703fb92cc9a864c0e2874387ead3aa3}{m\_table}.erase (dest);
2778 \}
\end{DoxyCode}
\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Remove\+Host\+Network\+Association@{Remove\+Host\+Network\+Association}}
\index{Remove\+Host\+Network\+Association@{Remove\+Host\+Network\+Association}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Remove\+Host\+Network\+Association(\+Ipv4\+Address network\+Addr, Ipv4\+Mask netmask)}{RemoveHostNetworkAssociation(Ipv4Address networkAddr, Ipv4Mask netmask)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Remove\+Host\+Network\+Association (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{network\+Addr, }
\item[{{\bf Ipv4\+Mask}}]{netmask}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a06c4bb2917ebc46ab608d4c9c3c4cbaa}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a06c4bb2917ebc46ab608d4c9c3c4cbaa}


Removes the specified (network\+Addr, netmask) tuple from the list of local H\+NA associations to be sent by the node via H\+NA messages. If this tuple does not exist, nothing is done (see \char`\"{}\+Olsr\+State\+::\+Erase\+Association()\char`\"{}). 


\begin{DoxyParams}{Parameters}
{\em network\+Addr} & The network address. \\
\hline
{\em netmask} & The network mask. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1867 \{
1868   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Removing HNA association for network "} << networkAddr << \textcolor{stringliteral}{"/"} << netmask << \textcolor{stringliteral}{"."});
1869   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a10d846d1a722985ed3c98d2f1ab5316a}{EraseAssociation} ( (Association) \{ networkAddr, netmask\} );
1870 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 93




Here is the caller graph for this function\+:
% FIG 94


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Remove\+Iface\+Assoc\+Tuple@{Remove\+Iface\+Assoc\+Tuple}}
\index{Remove\+Iface\+Assoc\+Tuple@{Remove\+Iface\+Assoc\+Tuple}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Remove\+Iface\+Assoc\+Tuple(const Iface\+Assoc\+Tuple \&tuple)}{RemoveIfaceAssocTuple(const IfaceAssocTuple &tuple)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Remove\+Iface\+Assoc\+Tuple (
\begin{DoxyParamCaption}
\item[{const {\bf Iface\+Assoc\+Tuple} \&}]{tuple}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a8ecb5343f7e51de7be585b06dbb1b721}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a8ecb5343f7e51de7be585b06dbb1b721}


Removed an interface association tuple to the Interface \hyperlink{structns3_1_1olsr_1_1Association}{Association} Set. 


\begin{DoxyParams}{Parameters}
{\em tuple} & The interface association tuple to be removed. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2531 \{
2532 \textcolor{comment}{//   debug("%f: Node %d removes iface association tuple: main\_addr = %d iface\_addr = %d\(\backslash\)n",}
2533 \textcolor{comment}{//         Simulator::Now (),}
2534 \textcolor{comment}{//         OLSR::node\_id(ra\_addr()),}
2535 \textcolor{comment}{//         OLSR::node\_id(tuple->main\_addr()),}
2536 \textcolor{comment}{//         OLSR::node\_id(tuple->iface\_addr()));}
2537 
2538   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a16dc218c6ffe6aed37c5ddfb9d941970}{EraseIfaceAssocTuple} (tuple);
2539 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 95




Here is the caller graph for this function\+:
% FIG 96


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Remove\+Link\+Tuple@{Remove\+Link\+Tuple}}
\index{Remove\+Link\+Tuple@{Remove\+Link\+Tuple}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Remove\+Link\+Tuple(const Link\+Tuple \&tuple)}{RemoveLinkTuple(const LinkTuple &tuple)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Remove\+Link\+Tuple (
\begin{DoxyParamCaption}
\item[{const {\bf Link\+Tuple} \&}]{tuple}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a1386148ca4a591a3409b54008b7ecae0}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a1386148ca4a591a3409b54008b7ecae0}


Removes a link tuple from the Link Set. 


\begin{DoxyParams}{Parameters}
{\em tuple} & The link tuple to be removed. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2346 \{
2347   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds ()
2348                 << \textcolor{stringliteral}{"s: OLSR Node "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress}
2349                 << \textcolor{stringliteral}{" LinkTuple "} << tuple << \textcolor{stringliteral}{" REMOVED."});
2350 
2351   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a651042cf0a72009f202932679c5eb1eb}{EraseNeighborTuple} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae01451170fb389d322b33ed6d954f460}{GetMainAddress} (tuple.
      neighborIfaceAddr));
2352   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_aa7fad36839c627b1b645857b2cc1c769}{EraseLinkTuple} (tuple);
2353 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 97




Here is the caller graph for this function\+:
% FIG 98


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Remove\+Mpr\+Selector\+Tuple@{Remove\+Mpr\+Selector\+Tuple}}
\index{Remove\+Mpr\+Selector\+Tuple@{Remove\+Mpr\+Selector\+Tuple}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Remove\+Mpr\+Selector\+Tuple(const Mpr\+Selector\+Tuple \&tuple)}{RemoveMprSelectorTuple(const MprSelectorTuple &tuple)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Remove\+Mpr\+Selector\+Tuple (
\begin{DoxyParamCaption}
\item[{const {\bf Mpr\+Selector\+Tuple} \&}]{tuple}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_ab3455ede71dab3092016964ef8577521}{}\label{classns3_1_1olsr_1_1RoutingProtocol_ab3455ede71dab3092016964ef8577521}


Removes an M\+PR selector tuple from the M\+PR Selector Set. Advertised Neighbor Sequence Number (A\+N\+SN) is also updated. 


\begin{DoxyParams}{Parameters}
{\em tuple} & The M\+PR selector tuple to be removed. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2481 \{
2482 \textcolor{comment}{//   debug("%f: Node %d removes MPR selector tuple: nb\_addr = %d\(\backslash\)n",}
2483 \textcolor{comment}{//         Simulator::Now (),}
2484 \textcolor{comment}{//         OLSR::node\_id(ra\_addr()),}
2485 \textcolor{comment}{//         OLSR::node\_id(tuple->main\_addr()));}
2486 
2487   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_afef3afa980a9340e4cadc21bb33bc241}{EraseMprSelectorTuple} (tuple);
2488   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ac1cfaea5b2ba8a3b32e39256b0221774}{IncrementAnsn} ();
2489 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 99




Here is the caller graph for this function\+:
% FIG 100


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Remove\+Neighbor\+Tuple@{Remove\+Neighbor\+Tuple}}
\index{Remove\+Neighbor\+Tuple@{Remove\+Neighbor\+Tuple}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Remove\+Neighbor\+Tuple(const Neighbor\+Tuple \&tuple)}{RemoveNeighborTuple(const NeighborTuple &tuple)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Remove\+Neighbor\+Tuple (
\begin{DoxyParamCaption}
\item[{const {\bf Neighbor\+Tuple} \&}]{tuple}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_af91353f674fb4f529921fb654203ab74}{}\label{classns3_1_1olsr_1_1RoutingProtocol_af91353f674fb4f529921fb654203ab74}


Removes a neighbor tuple from the Neighbor Set. 


\begin{DoxyParams}{Parameters}
{\em tuple} & The neighbor tuple to be removed. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2426 \{
2427 \textcolor{comment}{//   debug("%f: Node %d removes neighbor tuple: nb\_addr = %d status = %s\(\backslash\)n",}
2428 \textcolor{comment}{//         Simulator::Now (),}
2429 \textcolor{comment}{//         OLSR::node\_id(ra\_addr()),}
2430 \textcolor{comment}{//         OLSR::node\_id(tuple->neighborMainAddr),}
2431 \textcolor{comment}{//         ((tuple->status() == OLSR\_STATUS\_SYM) ? "sym" : "not\_sym"));}
2432 
2433   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a651042cf0a72009f202932679c5eb1eb}{EraseNeighborTuple} (tuple);
2434   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ac1cfaea5b2ba8a3b32e39256b0221774}{IncrementAnsn} ();
2435 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 101


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Remove\+Topology\+Tuple@{Remove\+Topology\+Tuple}}
\index{Remove\+Topology\+Tuple@{Remove\+Topology\+Tuple}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Remove\+Topology\+Tuple(const Topology\+Tuple \&tuple)}{RemoveTopologyTuple(const TopologyTuple &tuple)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Remove\+Topology\+Tuple (
\begin{DoxyParamCaption}
\item[{const {\bf Topology\+Tuple} \&}]{tuple}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a496a7619f3c2de003aebd7554eba2e6e}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a496a7619f3c2de003aebd7554eba2e6e}


Removes a topology tuple to the Topology Set. 


\begin{DoxyParams}{Parameters}
{\em tuple} & The topology tuple to be removed. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2506 \{
2507 \textcolor{comment}{//   debug("%f: Node %d removes topology tuple: dest\_addr = %d last\_addr = %d seq = %d\(\backslash\)n",}
2508 \textcolor{comment}{//         Simulator::Now (),}
2509 \textcolor{comment}{//         OLSR::node\_id(ra\_addr()),}
2510 \textcolor{comment}{//         OLSR::node\_id(tuple->dest\_addr()),}
2511 \textcolor{comment}{//         OLSR::node\_id(tuple->last\_addr()),}
2512 \textcolor{comment}{//         tuple->seq());}
2513 
2514   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_ae0f9f71438bb946538206be815cc68d3}{EraseTopologyTuple} (tuple);
2515 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 102




Here is the caller graph for this function\+:
% FIG 103


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Remove\+Two\+Hop\+Neighbor\+Tuple@{Remove\+Two\+Hop\+Neighbor\+Tuple}}
\index{Remove\+Two\+Hop\+Neighbor\+Tuple@{Remove\+Two\+Hop\+Neighbor\+Tuple}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Remove\+Two\+Hop\+Neighbor\+Tuple(const Two\+Hop\+Neighbor\+Tuple \&tuple)}{RemoveTwoHopNeighborTuple(const TwoHopNeighborTuple &tuple)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Remove\+Two\+Hop\+Neighbor\+Tuple (
\begin{DoxyParamCaption}
\item[{const {\bf Two\+Hop\+Neighbor\+Tuple} \&}]{tuple}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_adc613a8eb47ccb94878d8e9f61e9d11a}{}\label{classns3_1_1olsr_1_1RoutingProtocol_adc613a8eb47ccb94878d8e9f61e9d11a}


Removes a 2-\/hop neighbor tuple from the 2-\/hop Neighbor Set. 


\begin{DoxyParams}{Parameters}
{\em tuple} & The 2-\/hop neighbor tuple to be removed. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2451 \{
2452 \textcolor{comment}{//   debug("%f: Node %d removes 2-hop neighbor tuple: nb\_addr = %d nb2hop\_addr = %d\(\backslash\)n",}
2453 \textcolor{comment}{//         Simulator::Now (),}
2454 \textcolor{comment}{//         OLSR::node\_id(ra\_addr()),}
2455 \textcolor{comment}{//         OLSR::node\_id(tuple->neighborMainAddr),}
2456 \textcolor{comment}{//         OLSR::node\_id(tuple->twoHopNeighborAddr));}
2457 
2458   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_adcf079d794ae8637cd1245c4705efc2c}{EraseTwoHopNeighborTuple} (tuple);
2459 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 104




Here is the caller graph for this function\+:
% FIG 105


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Route\+Input@{Route\+Input}}
\index{Route\+Input@{Route\+Input}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Route\+Input(\+Ptr$<$ const Packet $>$ p, const Ipv4\+Header \&header, Ptr$<$ const Net\+Device $>$ idev, Unicast\+Forward\+Callback ucb, Multicast\+Forward\+Callback mcb, Local\+Deliver\+Callback lcb, Error\+Callback ecb)}{RouteInput(Ptr< const Packet > p, const Ipv4Header &header, Ptr< const NetDevice > idev, UnicastForwardCallback ucb, MulticastForwardCallback mcb, LocalDeliverCallback lcb, ErrorCallback ecb)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::olsr\+::\+Routing\+Protocol\+::\+Route\+Input (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv4\+Header} \&}]{header, }
\item[{{\bf Ptr}$<$ const {\bf Net\+Device} $>$}]{idev, }
\item[{{\bf Unicast\+Forward\+Callback}}]{ucb, }
\item[{{\bf Multicast\+Forward\+Callback}}]{mcb, }
\item[{{\bf Local\+Deliver\+Callback}}]{lcb, }
\item[{{\bf Error\+Callback}}]{ecb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_aa0291ccccb5e4e0d42e8b5da4167a5ab}{}\label{classns3_1_1olsr_1_1RoutingProtocol_aa0291ccccb5e4e0d42e8b5da4167a5ab}


Route an input packet (to be forwarded or locally delivered) 

This lookup is used in the forwarding process. The packet is handed over to the \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol}, and will get forwarded onward by one of the callbacks. The Linux equivalent is ip\+\_\+route\+\_\+input(). There are four valid outcomes, and a matching callbacks to handle each.


\begin{DoxyParams}{Parameters}
{\em p} & received packet \\
\hline
{\em header} & input parameter used to form a search key for a route \\
\hline
{\em idev} & Pointer to ingress network device \\
\hline
{\em ucb} & \hyperlink{classns3_1_1Callback}{Callback} for the case in which the packet is to be forwarded as unicast \\
\hline
{\em mcb} & \hyperlink{classns3_1_1Callback}{Callback} for the case in which the packet is to be forwarded as multicast \\
\hline
{\em lcb} & \hyperlink{classns3_1_1Callback}{Callback} for the case in which the packet is to be locally delivered \\
\hline
{\em ecb} & \hyperlink{classns3_1_1Callback}{Callback} to call if there is an error in forwarding \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} takes responsibility for forwarding or delivering the packet, false otherwise 
\end{DoxyReturn}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000157}{Todo}]Implment IP aliasing and O\+L\+SR \end{DoxyRefDesc}


Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a67e815ff40ebb9f5f4eec4e22e23132e}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
2894 \{
2895   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4}->GetObject<Node> ()->GetId () << \textcolor{stringliteral}{" "} << 
      header.GetDestination ());
2896 
2897   Ipv4Address dst = header.GetDestination ();
2898   Ipv4Address origin = header.GetSource ();
2899 
2900   \textcolor{comment}{// Consume self-originated packets}
2901   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a651b14b759452a21133cde6ef0f2f873}{IsMyOwnAddress} (origin) == \textcolor{keyword}{true})
2902     \{
2903       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
2904     \}
2905 
2906   \textcolor{comment}{// Local delivery}
2907   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4}->GetInterfaceForDevice (idev) >= 0);
2908   uint32\_t iif = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4}->GetInterfaceForDevice (idev);
2909   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4}->IsDestinationAddress (dst, iif))
2910     \{
2911       \textcolor{keywordflow}{if} (!lcb.IsNull ())
2912         \{
2913           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Local delivery to "} << dst);
2914           lcb (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header, iif);
2915           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
2916         \}
2917       \textcolor{keywordflow}{else}
2918         \{
2919           \textcolor{comment}{// The local delivery callback is null.  This may be a multicast}
2920           \textcolor{comment}{// or broadcast packet, so return false so that another}
2921           \textcolor{comment}{// multicast routing protocol can handle it.  It should be possible}
2922           \textcolor{comment}{// to extend this to explicitly check whether it is a unicast}
2923           \textcolor{comment}{// packet, and invoke the error callback if so}
2924           \textcolor{keywordflow}{return} \textcolor{keyword}{false};
2925         \}
2926     \}
2927 
2928   \textcolor{comment}{// Forwarding}
2929   Ptr<Ipv4Route> rtentry;
2930   RoutingTableEntry entry1, entry2;
2931   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a514bf401454b233af509476fc3fd5d6b}{Lookup} (header.GetDestination (), entry1))
2932     \{
2933       \textcolor{keywordtype}{bool} foundSendEntry = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a15394858cdfb821d54f8661ed712083c}{FindSendEntry} (entry1, entry2);
2934       \textcolor{keywordflow}{if} (!foundSendEntry)
2935         \{
2936           \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"FindSendEntry failure"});
2937         \}
2938       rtentry = Create<Ipv4Route> ();
2939       rtentry->SetDestination (header.GetDestination ());
2940       uint32\_t interfaceIdx = entry2.interface;
2941       \textcolor{comment}{// the source address is the interface address that matches}
2942       \textcolor{comment}{// the destination address (when multiple are present on the}
2943       \textcolor{comment}{// outgoing interface, one is selected via scoping rules)}
2944       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4});
2945       uint32\_t numOifAddresses = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4}->GetNAddresses (interfaceIdx);
2946       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (numOifAddresses > 0);
2947       Ipv4InterfaceAddress ifAddr;
2948       \textcolor{keywordflow}{if} (numOifAddresses == 1)
2949         \{
2950           ifAddr = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4}->GetAddress (interfaceIdx, 0);
2951         \}
2952       \textcolor{keywordflow}{else}
2953         \{
2955           \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"XXX Not implemented yet:  IP aliasing and OLSR"});
2956         \}
2957       rtentry->SetSource (ifAddr.GetLocal ());
2958       rtentry->SetGateway (entry2.nextAddr);
2959       rtentry->SetOutputDevice (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4}->GetNetDevice (interfaceIdx));
2960 
2961       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Olsr node "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress}
2962                                  << \textcolor{stringliteral}{": RouteInput for dest="} << header.GetDestination ()
2963                                  << \textcolor{stringliteral}{" --> nextHop="} << entry2.nextAddr
2964                                  << \textcolor{stringliteral}{" interface="} << entry2.interface);
2965 
2966       ucb (rtentry, \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header);
2967       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
2968     \}
2969   \textcolor{keywordflow}{else}
2970     \{
2971       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a398799911ae136e0b247b4bbd608c336}{m\_hnaRoutingTable}->RouteInput (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header, idev, ucb, mcb, lcb, ecb))
2972         \{
2973           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
2974         \}
2975       \textcolor{keywordflow}{else}
2976         \{
2977 
2978 \textcolor{preprocessor}{#ifdef NS3\_LOG\_ENABLE}
2979           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Olsr node "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress}
2980                                      << \textcolor{stringliteral}{": RouteInput for dest="} << header.GetDestination ()
2981                                      << \textcolor{stringliteral}{" --> NOT FOUND; ** Dumping routing table..."});
2982 
2983           \textcolor{keywordflow}{for} (std::map<Ipv4Address, RoutingTableEntry>::const\_iterator iter = 
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a9703fb92cc9a864c0e2874387ead3aa3}{m\_table}.begin ();
2984                iter != \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a9703fb92cc9a864c0e2874387ead3aa3}{m\_table}.end (); iter++)
2985             \{
2986               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"dest="} << iter->first << \textcolor{stringliteral}{" --> next="} << iter->second.nextAddr
2987                                     << \textcolor{stringliteral}{" via interface "} << iter->second.interface);
2988             \}
2989 
2990           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"** Routing table dump end."});
2991 \textcolor{preprocessor}{#endif // NS3\_LOG\_ENABLE}
2992 
2993           \textcolor{keywordflow}{return} \textcolor{keyword}{false};
2994         \}
2995     \}
2996 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 106


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Route\+Output@{Route\+Output}}
\index{Route\+Output@{Route\+Output}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Route\+Output(\+Ptr$<$ Packet $>$ p, const Ipv4\+Header \&header, Ptr$<$ Net\+Device $>$ oif, Socket\+::\+Socket\+Errno \&sockerr)}{RouteOutput(Ptr< Packet > p, const Ipv4Header &header, Ptr< NetDevice > oif, Socket::SocketErrno &sockerr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv4\+Route} $>$ ns3\+::olsr\+::\+Routing\+Protocol\+::\+Route\+Output (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv4\+Header} \&}]{header, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{oif, }
\item[{{\bf Socket\+::\+Socket\+Errno} \&}]{sockerr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a4b0f79333d7f1f1a68ff057e8f00512d}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a4b0f79333d7f1f1a68ff057e8f00512d}


Query routing cache for an existing route, for an outbound packet. 

This lookup is used by transport protocols. It does not cause any packet to be forwarded, and is synchronous. Can be used for multicast or unicast. The Linux equivalent is ip\+\_\+route\+\_\+output()

The header input parameter may have an uninitialized value for the source address, but the destination address should always be properly set by the caller.


\begin{DoxyParams}{Parameters}
{\em p} & packet to be routed. Note that this method may modify the packet. Callers may also pass in a null pointer. \\
\hline
{\em header} & input parameter (used to form key to search for the route) \\
\hline
{\em oif} & Output interface Netdevice. May be zero, or may be bound via socket options to a particular output interface. \\
\hline
{\em sockerr} & Output parameter; socket errno\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a code that indicates what happened in the lookup 
\end{DoxyReturn}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000156}{Todo}]Implment IP aliasing and O\+L\+SR \end{DoxyRefDesc}


Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a9c0e9b77772a4974c06ee4577fe60547}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
2813 \{
2814   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4}->GetObject<Node> ()->GetId () << \textcolor{stringliteral}{" "} << 
      header.GetDestination () << \textcolor{stringliteral}{" "} << oif);
2815   Ptr<Ipv4Route> rtentry;
2816   RoutingTableEntry entry1, entry2;
2817   \textcolor{keywordtype}{bool} found = \textcolor{keyword}{false};
2818 
2819   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a514bf401454b233af509476fc3fd5d6b}{Lookup} (header.GetDestination (), entry1) != 0)
2820     \{
2821       \textcolor{keywordtype}{bool} foundSendEntry = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a15394858cdfb821d54f8661ed712083c}{FindSendEntry} (entry1, entry2);
2822       \textcolor{keywordflow}{if} (!foundSendEntry)
2823         \{
2824           \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"FindSendEntry failure"});
2825         \}
2826       uint32\_t interfaceIdx = entry2.interface;
2827       \textcolor{keywordflow}{if} (oif && \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4}->GetInterfaceForDevice (oif) != \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>} (interfaceIdx))
2828         \{
2829           \textcolor{comment}{// We do not attempt to perform a constrained routing search}
2830           \textcolor{comment}{// if the caller specifies the oif; we just enforce that}
2831           \textcolor{comment}{// that the found route matches the requested outbound interface}
2832           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Olsr node "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress}
2833                                      << \textcolor{stringliteral}{": RouteOutput for dest="} << header.GetDestination ()
2834                                      << \textcolor{stringliteral}{" Route interface "} << interfaceIdx
2835                                      << \textcolor{stringliteral}{" does not match requested output interface "}
2836                                      << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4}->GetInterfaceForDevice (oif));
2837           sockerr = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{Socket::ERROR\_NOROUTETOHOST};
2838           \textcolor{keywordflow}{return} rtentry;
2839         \}
2840       rtentry = Create<Ipv4Route> ();
2841       rtentry->SetDestination (header.GetDestination ());
2842       \textcolor{comment}{// the source address is the interface address that matches}
2843       \textcolor{comment}{// the destination address (when multiple are present on the}
2844       \textcolor{comment}{// outgoing interface, one is selected via scoping rules)}
2845       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4});
2846       uint32\_t numOifAddresses = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4}->GetNAddresses (interfaceIdx);
2847       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (numOifAddresses > 0);
2848       Ipv4InterfaceAddress ifAddr;
2849       \textcolor{keywordflow}{if} (numOifAddresses == 1)
2850         \{
2851           ifAddr = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4}->GetAddress (interfaceIdx, 0);
2852         \}
2853       \textcolor{keywordflow}{else}
2854         \{
2856           \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"XXX Not implemented yet:  IP aliasing and OLSR"});
2857         \}
2858       rtentry->SetSource (ifAddr.GetLocal ());
2859       rtentry->SetGateway (entry2.nextAddr);
2860       rtentry->SetOutputDevice (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4}->GetNetDevice (interfaceIdx));
2861       sockerr = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaaa7eb006d73c5ad0117c5591fcb3469f7}{Socket::ERROR\_NOTERROR};
2862       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Olsr node "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress}
2863                                  << \textcolor{stringliteral}{": RouteOutput for dest="} << header.GetDestination ()
2864                                  << \textcolor{stringliteral}{" --> nextHop="} << entry2.nextAddr
2865                                  << \textcolor{stringliteral}{" interface="} << entry2.interface);
2866       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Found route to "} << rtentry->GetDestination () << \textcolor{stringliteral}{" via nh "} << rtentry->
      GetGateway () << \textcolor{stringliteral}{" with source addr "} << rtentry->GetSource () << \textcolor{stringliteral}{" and output dev "} << rtentry->
      GetOutputDevice ());
2867       found = \textcolor{keyword}{true};
2868     \}
2869   \textcolor{keywordflow}{else}
2870     \{
2871       rtentry = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a398799911ae136e0b247b4bbd608c336}{m\_hnaRoutingTable}->RouteOutput (p, header, oif, sockerr);
2872 
2873       \textcolor{keywordflow}{if} (rtentry)
2874         \{
2875           found = \textcolor{keyword}{true};
2876           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Found route to "} << rtentry->GetDestination () << \textcolor{stringliteral}{" via nh "} << 
      rtentry->GetGateway () << \textcolor{stringliteral}{" with source addr "} << rtentry->GetSource () << \textcolor{stringliteral}{" and output dev "} << rtentry->
      GetOutputDevice ());
2877         \}
2878     \}
2879 
2880   \textcolor{keywordflow}{if} (!found)
2881     \{
2882       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Olsr node "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress}
2883                                  << \textcolor{stringliteral}{": RouteOutput for dest="} << header.GetDestination ()
2884                                  << \textcolor{stringliteral}{" No route to host"});
2885       sockerr = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{Socket::ERROR\_NOROUTETOHOST};
2886     \}
2887   \textcolor{keywordflow}{return} rtentry;
2888 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 107


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Routing\+Table\+Computation@{Routing\+Table\+Computation}}
\index{Routing\+Table\+Computation@{Routing\+Table\+Computation}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Routing\+Table\+Computation()}{RoutingTableComputation()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Routing\+Table\+Computation (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a69fcd3b690fbf6e2b46735145cecfe3e}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a69fcd3b690fbf6e2b46735145cecfe3e}


Creates the routing table of the node following \{3626\} hints. 


\begin{DoxyCode}
907 \{
908   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds () << \textcolor{stringliteral}{" s: Node "} << 
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress}
909                                                 << \textcolor{stringliteral}{": RoutingTableComputation begin..."});
910 
911   \textcolor{comment}{// 1. All the entries from the routing table are removed.}
912   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a91a0babaefcd493c649fceb4fb1a2e60}{Clear} ();
913 
914   \textcolor{comment}{// 2. The new routing entries are added starting with the}
915   \textcolor{comment}{// symmetric neighbors (h=1) as the destination nodes.}
916   \textcolor{keyword}{const} \hyperlink{namespacens3_1_1olsr_af0afef1f28c6f0a0b528b03b638df05d}{NeighborSet} &neighborSet = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a82d5882ca3fdb93a9c1110c6f176c03c}{GetNeighbors} ();
917   \textcolor{keywordflow}{for} (NeighborSet::const\_iterator it = neighborSet.begin ();
918        it != neighborSet.end (); it++)
919     \{
920       NeighborTuple \textcolor{keyword}{const} &nb\_tuple = *it;
921       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Looking at neighbor tuple: "} << nb\_tuple);
922       \textcolor{keywordflow}{if} (nb\_tuple.status == \hyperlink{structns3_1_1olsr_1_1NeighborTuple_ad4b623edaedb3a5244291c738ce87e12a1649b9e4d61ac6e27eff65e8bd5dfe15}{NeighborTuple::STATUS\_SYM})
923         \{
924           \textcolor{keywordtype}{bool} nb\_main\_addr = \textcolor{keyword}{false};
925           \textcolor{keyword}{const} LinkTuple *lt = NULL;
926           \textcolor{keyword}{const} \hyperlink{namespacens3_1_1olsr_a60381cc41d65a2e0daabd286077a378a}{LinkSet} &linkSet = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a1d8f1a95165973f05e3fd1ff0d76fbda}{GetLinks} ();
927           \textcolor{keywordflow}{for} (LinkSet::const\_iterator it2 = linkSet.begin ();
928                it2 != linkSet.end (); it2++)
929             \{
930               LinkTuple \textcolor{keyword}{const} &link\_tuple = *it2;
931               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Looking at link tuple: "} << link\_tuple
932                                                       << (link\_tuple.time >= 
      \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} () ? \textcolor{stringliteral}{""} : \textcolor{stringliteral}{" (expired)"}));
933               \textcolor{keywordflow}{if} ((\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae01451170fb389d322b33ed6d954f460}{GetMainAddress} (link\_tuple.neighborIfaceAddr) == nb\_tuple.neighborMainAddr
      )
934                   && link\_tuple.time >= \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ())
935                 \{
936                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Link tuple matches neighbor "} << nb\_tuple.neighborMainAddr
937                                                                << \textcolor{stringliteral}{" => adding routing table entry to
       neighbor"});
938                   lt = &link\_tuple;
939                   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a6ddb7dd3a6584b7d88dc5a41a61b1494}{AddEntry} (link\_tuple.neighborIfaceAddr,
940                             link\_tuple.neighborIfaceAddr,
941                             link\_tuple.localIfaceAddr,
942                             1);
943                   \textcolor{keywordflow}{if} (link\_tuple.neighborIfaceAddr == nb\_tuple.neighborMainAddr)
944                     \{
945                       nb\_main\_addr = \textcolor{keyword}{true};
946                     \}
947                 \}
948               \textcolor{keywordflow}{else}
949                 \{
950                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Link tuple: linkMainAddress= "} << 
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae01451170fb389d322b33ed6d954f460}{GetMainAddress} (link\_tuple.neighborIfaceAddr)
951                                                                 << \textcolor{stringliteral}{"; neighborMainAddr =  "} << nb\_tuple.
      neighborMainAddr
952                                                                 << \textcolor{stringliteral}{"; expired="} << int (link\_tuple.time < 
      \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ())
953                                                                 << \textcolor{stringliteral}{" => IGNORE"});
954                 \}
955             \}
956 
957           \textcolor{comment}{// If, in the above, no R\_dest\_addr is equal to the main}
958           \textcolor{comment}{// address of the neighbor, then another new routing entry}
959           \textcolor{comment}{// with MUST be added, with:}
960           \textcolor{comment}{//      R\_dest\_addr  = main address of the neighbor;}
961           \textcolor{comment}{//      R\_next\_addr  = L\_neighbor\_iface\_addr of one of the}
962           \textcolor{comment}{//                     associated link tuple with L\_time >= current time;}
963           \textcolor{comment}{//      R\_dist       = 1;}
964           \textcolor{comment}{//      R\_iface\_addr = L\_local\_iface\_addr of the}
965           \textcolor{comment}{//                     associated link tuple.}
966           \textcolor{keywordflow}{if} (!nb\_main\_addr && lt != NULL)
967             \{
968               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"no R\_dest\_addr is equal to the main address of the neighbor "}
969                             \textcolor{stringliteral}{"=> adding additional routing entry"});
970               \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a6ddb7dd3a6584b7d88dc5a41a61b1494}{AddEntry} (nb\_tuple.neighborMainAddr,
971                         lt->neighborIfaceAddr,
972                         lt->localIfaceAddr,
973                         1);
974             \}
975         \}
976     \}
977 
978   \textcolor{comment}{//  3. for each node in N2, i.e., a 2-hop neighbor which is not a}
979   \textcolor{comment}{//  neighbor node or the node itself, and such that there exist at}
980   \textcolor{comment}{//  least one entry in the 2-hop neighbor set where}
981   \textcolor{comment}{//  N\_neighbor\_main\_addr correspond to a neighbor node with}
982   \textcolor{comment}{//  willingness different of WILL\_NEVER,}
983   \textcolor{keyword}{const} \hyperlink{namespacens3_1_1olsr_a5f9963792af7fea4dc66fb8718394604}{TwoHopNeighborSet} &twoHopNeighbors = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.
      \hyperlink{classns3_1_1olsr_1_1OlsrState_ab03738874d0d785b770beef6dc9c2e1a}{GetTwoHopNeighbors} ();
984   \textcolor{keywordflow}{for} (TwoHopNeighborSet::const\_iterator it = twoHopNeighbors.begin ();
985        it != twoHopNeighbors.end (); it++)
986     \{
987       TwoHopNeighborTuple \textcolor{keyword}{const} &nb2hop\_tuple = *it;
988 
989       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Looking at two-hop neighbor tuple: "} << nb2hop\_tuple);
990 
991       \textcolor{comment}{// a 2-hop neighbor which is not a neighbor node or the node itself}
992       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_aa26af34492ae406f145c53bd189ed7fb}{FindSymNeighborTuple} (nb2hop\_tuple.twoHopNeighborAddr))
993         \{
994           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Two-hop neighbor tuple is also neighbor; skipped."});
995           \textcolor{keywordflow}{continue};
996         \}
997 
998       \textcolor{keywordflow}{if} (nb2hop\_tuple.twoHopNeighborAddr == \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress})
999         \{
1000           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Two-hop neighbor is self; skipped."});
1001           \textcolor{keywordflow}{continue};
1002         \}
1003 
1004       \textcolor{comment}{// ...and such that there exist at least one entry in the 2-hop}
1005       \textcolor{comment}{// neighbor set where N\_neighbor\_main\_addr correspond to a}
1006       \textcolor{comment}{// neighbor node with willingness different of WILL\_NEVER...}
1007       \textcolor{keywordtype}{bool} nb2hopOk = \textcolor{keyword}{false};
1008       \textcolor{keywordflow}{for} (NeighborSet::const\_iterator neighbor = neighborSet.begin ();
1009            neighbor != neighborSet.end (); neighbor++)
1010         \{
1011           \textcolor{keywordflow}{if} (neighbor->neighborMainAddr == nb2hop\_tuple.neighborMainAddr
1012               && neighbor->willingness != \hyperlink{olsr-routing-protocol_8cc_a146d2c103abd49bdfad44b4424769696}{OLSR\_WILL\_NEVER})
1013             \{
1014               nb2hopOk = \textcolor{keyword}{true};
1015               \textcolor{keywordflow}{break};
1016             \}
1017         \}
1018       \textcolor{keywordflow}{if} (!nb2hopOk)
1019         \{
1020           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Two-hop neighbor tuple skipped: 2-hop neighbor "}
1021                         << nb2hop\_tuple.twoHopNeighborAddr
1022                         << \textcolor{stringliteral}{" is attached to neighbor "} << nb2hop\_tuple.neighborMainAddr
1023                         << \textcolor{stringliteral}{", which was not found in the Neighbor Set."});
1024           \textcolor{keywordflow}{continue};
1025         \}
1026 
1027       \textcolor{comment}{// one selects one 2-hop tuple and creates one entry in the routing table with:}
1028       \textcolor{comment}{//                R\_dest\_addr  =  the main address of the 2-hop neighbor;}
1029       \textcolor{comment}{//                R\_next\_addr  = the R\_next\_addr of the entry in the}
1030       \textcolor{comment}{//                               routing table with:}
1031       \textcolor{comment}{//                                   R\_dest\_addr == N\_neighbor\_main\_addr}
1032       \textcolor{comment}{//                                                  of the 2-hop tuple;}
1033       \textcolor{comment}{//                R\_dist       = 2;}
1034       \textcolor{comment}{//                R\_iface\_addr = the R\_iface\_addr of the entry in the}
1035       \textcolor{comment}{//                               routing table with:}
1036       \textcolor{comment}{//                                   R\_dest\_addr == N\_neighbor\_main\_addr}
1037       \textcolor{comment}{//                                                  of the 2-hop tuple;}
1038       RoutingTableEntry entry;
1039       \textcolor{keywordtype}{bool} foundEntry = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a514bf401454b233af509476fc3fd5d6b}{Lookup} (nb2hop\_tuple.neighborMainAddr, entry);
1040       \textcolor{keywordflow}{if} (foundEntry)
1041         \{
1042           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Adding routing entry for two-hop neighbor."});
1043           \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a6ddb7dd3a6584b7d88dc5a41a61b1494}{AddEntry} (nb2hop\_tuple.twoHopNeighborAddr,
1044                     entry.nextAddr,
1045                     entry.interface,
1046                     2);
1047         \}
1048       \textcolor{keywordflow}{else}
1049         \{
1050           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"NOT adding routing entry for two-hop neighbor ("}
1051                         << nb2hop\_tuple.twoHopNeighborAddr
1052                         << \textcolor{stringliteral}{" not found in the routing table)"});
1053         \}
1054     \}
1055 
1056   \textcolor{keywordflow}{for} (uint32\_t h = 2;; h++)
1057     \{
1058       \textcolor{keywordtype}{bool} added = \textcolor{keyword}{false};
1059 
1060       \textcolor{comment}{// 3.1. For each topology entry in the topology table, if its}
1061       \textcolor{comment}{// T\_dest\_addr does not correspond to R\_dest\_addr of any}
1062       \textcolor{comment}{// route entry in the routing table AND its T\_last\_addr}
1063       \textcolor{comment}{// corresponds to R\_dest\_addr of a route entry whose R\_dist}
1064       \textcolor{comment}{// is equal to h, then a new route entry MUST be recorded in}
1065       \textcolor{comment}{// the routing table (if it does not already exist)}
1066       \textcolor{keyword}{const} \hyperlink{namespacens3_1_1olsr_aa5a4b5a4c916439ca513b91928d7eba0}{TopologySet} &topology = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a2ca307d08ead8410b13ab05ec073b45a}{GetTopologySet} ();
1067       \textcolor{keywordflow}{for} (TopologySet::const\_iterator it = topology.begin ();
1068            it != topology.end (); it++)
1069         \{
1070           \textcolor{keyword}{const} TopologyTuple &topology\_tuple = *it;
1071           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Looking at topology tuple: "} << topology\_tuple);
1072 
1073           RoutingTableEntry destAddrEntry, lastAddrEntry;
1074           \textcolor{keywordtype}{bool} have\_destAddrEntry = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a514bf401454b233af509476fc3fd5d6b}{Lookup} (topology\_tuple.destAddr, destAddrEntry);
1075           \textcolor{keywordtype}{bool} have\_lastAddrEntry = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a514bf401454b233af509476fc3fd5d6b}{Lookup} (topology\_tuple.lastAddr, lastAddrEntry);
1076           \textcolor{keywordflow}{if} (!have\_destAddrEntry && have\_lastAddrEntry && lastAddrEntry.distance == h)
1077             \{
1078               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Adding routing table entry based on the topology tuple."});
1079               \textcolor{comment}{// then a new route entry MUST be recorded in}
1080               \textcolor{comment}{//                the routing table (if it does not already exist) where:}
1081               \textcolor{comment}{//                     R\_dest\_addr  = T\_dest\_addr;}
1082               \textcolor{comment}{//                     R\_next\_addr  = R\_next\_addr of the recorded}
1083               \textcolor{comment}{//                                    route entry where:}
1084               \textcolor{comment}{//                                    R\_dest\_addr == T\_last\_addr}
1085               \textcolor{comment}{//                     R\_dist       = h+1; and}
1086               \textcolor{comment}{//                     R\_iface\_addr = R\_iface\_addr of the recorded}
1087               \textcolor{comment}{//                                    route entry where:}
1088               \textcolor{comment}{//                                       R\_dest\_addr == T\_last\_addr.}
1089               \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a6ddb7dd3a6584b7d88dc5a41a61b1494}{AddEntry} (topology\_tuple.destAddr,
1090                         lastAddrEntry.nextAddr,
1091                         lastAddrEntry.interface,
1092                         h + 1);
1093               added = \textcolor{keyword}{true};
1094             \}
1095           \textcolor{keywordflow}{else}
1096             \{
1097               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"NOT adding routing table entry based on the topology tuple: "}
1098                             \textcolor{stringliteral}{"have\_destAddrEntry="} << have\_destAddrEntry
1099                                                   << \textcolor{stringliteral}{" have\_lastAddrEntry="} << have\_lastAddrEntry
1100                                                   << \textcolor{stringliteral}{" lastAddrEntry.distance="} << (\textcolor{keywordtype}{int}) lastAddrEntry.
      distance
1101                                                   << \textcolor{stringliteral}{" (h="} << h << \textcolor{stringliteral}{")"});
1102             \}
1103         \}
1104 
1105       \textcolor{keywordflow}{if} (!added)
1106         \{
1107           \textcolor{keywordflow}{break};
1108         \}
1109     \}
1110 
1111   \textcolor{comment}{// 4. For each entry in the multiple interface association base}
1112   \textcolor{comment}{// where there exists a routing entry such that:}
1113   \textcolor{comment}{// R\_dest\_addr == I\_main\_addr (of the multiple interface association entry)}
1114   \textcolor{comment}{// AND there is no routing entry such that:}
1115   \textcolor{comment}{// R\_dest\_addr == I\_iface\_addr}
1116   \textcolor{keyword}{const} \hyperlink{namespacens3_1_1olsr_af7456b9ea2cde8c7d88443de06c015f4}{IfaceAssocSet} &ifaceAssocSet = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.
      \hyperlink{classns3_1_1olsr_1_1OlsrState_ae2958cc39b5a1e154797ad2efe462cfb}{GetIfaceAssocSet} ();
1117   \textcolor{keywordflow}{for} (IfaceAssocSet::const\_iterator it = ifaceAssocSet.begin ();
1118        it != ifaceAssocSet.end (); it++)
1119     \{
1120       IfaceAssocTuple \textcolor{keyword}{const} &tuple = *it;
1121       RoutingTableEntry entry1, entry2;
1122       \textcolor{keywordtype}{bool} have\_entry1 = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a514bf401454b233af509476fc3fd5d6b}{Lookup} (tuple.mainAddr, entry1);
1123       \textcolor{keywordtype}{bool} have\_entry2 = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a514bf401454b233af509476fc3fd5d6b}{Lookup} (tuple.ifaceAddr, entry2);
1124       \textcolor{keywordflow}{if} (have\_entry1 && !have\_entry2)
1125         \{
1126           \textcolor{comment}{// then a route entry is created in the routing table with:}
1127           \textcolor{comment}{//       R\_dest\_addr  =  I\_iface\_addr (of the multiple interface}
1128           \textcolor{comment}{//                                     association entry)}
1129           \textcolor{comment}{//       R\_next\_addr  =  R\_next\_addr  (of the recorded route entry)}
1130           \textcolor{comment}{//       R\_dist       =  R\_dist       (of the recorded route entry)}
1131           \textcolor{comment}{//       R\_iface\_addr =  R\_iface\_addr (of the recorded route entry).}
1132           \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a6ddb7dd3a6584b7d88dc5a41a61b1494}{AddEntry} (tuple.ifaceAddr,
1133                     entry1.nextAddr,
1134                     entry1.interface,
1135                     entry1.distance);
1136         \}
1137     \}
1138 
1139   \textcolor{comment}{// 5. For each tuple in the association set,}
1140   \textcolor{comment}{//    If there is no entry in the routing table with:}
1141   \textcolor{comment}{//        R\_dest\_addr     == A\_network\_addr/A\_netmask}
1142   \textcolor{comment}{//   and if the announced network is not announced by the node itself,}
1143   \textcolor{comment}{//   then a new routing entry is created.}
1144   \textcolor{keyword}{const} \hyperlink{namespacens3_1_1olsr_a35c0d7e5a941dd49e212f0c9e81ba466}{AssociationSet} &associationSet = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.
      \hyperlink{classns3_1_1olsr_1_1OlsrState_acfc3b69f5b2a730cfe5501f757ec7c80}{GetAssociationSet} ();
1145 
1146   \textcolor{comment}{// Clear HNA routing table}
1147   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a398799911ae136e0b247b4bbd608c336}{m\_hnaRoutingTable}->GetNRoutes (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
1148     \{
1149       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a398799911ae136e0b247b4bbd608c336}{m\_hnaRoutingTable}->RemoveRoute (0);
1150     \}
1151 
1152   \textcolor{keywordflow}{for} (AssociationSet::const\_iterator it = associationSet.begin ();
1153        it != associationSet.end (); it++)
1154     \{
1155       AssociationTuple \textcolor{keyword}{const} &tuple = *it;
1156 
1157       \textcolor{comment}{// Test if HNA associations received from other gateways}
1158       \textcolor{comment}{// are also announced by this node. In such a case, no route}
1159       \textcolor{comment}{// is created for this association tuple (go to the next one).}
1160       \textcolor{keywordtype}{bool} goToNextAssociationTuple = \textcolor{keyword}{false};
1161       \textcolor{keyword}{const} \hyperlink{namespacens3_1_1olsr_a7aefab4ffae5b289262125647510a2ef}{Associations} &localHnaAssociations = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.
      \hyperlink{classns3_1_1olsr_1_1OlsrState_af0d7450ccc6238bb018e8f22fcaf0552}{GetAssociations} ();
1162       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Nb local associations: "} << localHnaAssociations.size ());
1163       \textcolor{keywordflow}{for} (Associations::const\_iterator assocIterator = localHnaAssociations.begin ();
1164            assocIterator != localHnaAssociations.end (); assocIterator++)
1165         \{
1166           Association \textcolor{keyword}{const} &localHnaAssoc = *assocIterator;
1167           \textcolor{keywordflow}{if} (localHnaAssoc.networkAddr == tuple.networkAddr && localHnaAssoc.netmask == tuple.netmask)
1168             \{
1169               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"HNA association received from another GW is part of local HNA
       associations: no route added for network "}
1170                             << tuple.networkAddr << \textcolor{stringliteral}{"/"} << tuple.netmask);
1171               goToNextAssociationTuple = \textcolor{keyword}{true};
1172             \}
1173         \}
1174       \textcolor{keywordflow}{if} (goToNextAssociationTuple)
1175         \{
1176           \textcolor{keywordflow}{continue};
1177         \}
1178 
1179       RoutingTableEntry gatewayEntry;
1180 
1181       \textcolor{keywordtype}{bool} gatewayEntryExists = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a514bf401454b233af509476fc3fd5d6b}{Lookup} (tuple.gatewayAddr, gatewayEntry);
1182       \textcolor{keywordtype}{bool} addRoute = \textcolor{keyword}{false};
1183 
1184       uint32\_t routeIndex = 0;
1185 
1186       \textcolor{keywordflow}{for} (routeIndex = 0; routeIndex < \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a398799911ae136e0b247b4bbd608c336}{m\_hnaRoutingTable}->GetNRoutes (); routeIndex++)
1187         \{
1188           Ipv4RoutingTableEntry route = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a398799911ae136e0b247b4bbd608c336}{m\_hnaRoutingTable}->GetRoute (routeIndex);
1189           \textcolor{keywordflow}{if} (route.GetDestNetwork () == tuple.networkAddr
1190               && route.GetDestNetworkMask () == tuple.netmask)
1191             \{
1192               \textcolor{keywordflow}{break};
1193             \}
1194         \}
1195 
1196       \textcolor{keywordflow}{if} (routeIndex == \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a398799911ae136e0b247b4bbd608c336}{m\_hnaRoutingTable}->GetNRoutes ())
1197         \{
1198           addRoute = \textcolor{keyword}{true};
1199         \}
1200       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (gatewayEntryExists && \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a398799911ae136e0b247b4bbd608c336}{m\_hnaRoutingTable}->GetMetric (routeIndex) > 
      gatewayEntry.distance)
1201         \{
1202           \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a398799911ae136e0b247b4bbd608c336}{m\_hnaRoutingTable}->RemoveRoute (routeIndex);
1203           addRoute = \textcolor{keyword}{true};
1204         \}
1205 
1206       \textcolor{keywordflow}{if} (addRoute && gatewayEntryExists)
1207         \{
1208           \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a398799911ae136e0b247b4bbd608c336}{m\_hnaRoutingTable}->AddNetworkRouteTo (tuple.networkAddr,
1209                                                 tuple.netmask,
1210                                                 gatewayEntry.nextAddr,
1211                                                 gatewayEntry.interface,
1212                                                 gatewayEntry.distance);
1213 
1214         \}
1215     \}
1216 
1217   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Node "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress} << \textcolor{stringliteral}{": RoutingTableComputation end."});
1218   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a1cbaa4bdf90462b6d8e0ddc90eaa4130}{m\_routingTableChanged} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afbbc663c6c3e814b0a71aa4b44312abb}{GetSize} ());
1219 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 108




Here is the caller graph for this function\+:
% FIG 109


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Send\+Hello@{Send\+Hello}}
\index{Send\+Hello@{Send\+Hello}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Hello()}{SendHello()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Send\+Hello (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a3b24f29bfb5d4bfa60e0ca1eb28a8b13}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a3b24f29bfb5d4bfa60e0ca1eb28a8b13}


Creates a new O\+L\+SR H\+E\+L\+LO message which is buffered for being sent later on. 


\begin{DoxyCode}
1636 \{
1637   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1638 
1639   olsr::MessageHeader msg;
1640   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} now = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ();
1641 
1642   msg.SetVTime (\hyperlink{olsr-routing-protocol_8cc_a32428f0b560f93c0a160b27181704faa}{OLSR\_NEIGHB\_HOLD\_TIME});
1643   msg.SetOriginatorAddress (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress});
1644   msg.SetTimeToLive (1);
1645   msg.SetHopCount (0);
1646   msg.SetMessageSequenceNumber (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_af8656b873ecc22d25d5e5795f936d61a}{GetMessageSequenceNumber} ());
1647   olsr::MessageHeader::Hello &hello = msg.GetHello ();
1648 
1649   hello.SetHTime (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ac973c86cbf21168c11cd7f16acc1ae4c}{m\_helloInterval});
1650   hello.willingness = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a2e94c2954ffa92d1c7d3b627087c9430}{m\_willingness};
1651 
1652   std::vector<olsr::MessageHeader::Hello::LinkMessage>
1653   &linkMessages = hello.linkMessages;
1654 
1655   \textcolor{keyword}{const} \hyperlink{namespacens3_1_1olsr_a60381cc41d65a2e0daabd286077a378a}{LinkSet} &links = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a1d8f1a95165973f05e3fd1ff0d76fbda}{GetLinks} ();
1656   \textcolor{keywordflow}{for} (LinkSet::const\_iterator link\_tuple = links.begin ();
1657        link\_tuple != links.end (); link\_tuple++)
1658     \{
1659       \textcolor{keywordflow}{if} (!(\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae01451170fb389d322b33ed6d954f460}{GetMainAddress} (link\_tuple->localIfaceAddr) == 
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress}
1660             && link\_tuple->time >= now))
1661         \{
1662           \textcolor{keywordflow}{continue};
1663         \}
1664 
1665       uint8\_t link\_type, nb\_type = 0xff;
1666 
1667       \textcolor{comment}{// Establishes link type}
1668       \textcolor{keywordflow}{if} (link\_tuple->symTime >= now)
1669         \{
1670           link\_type = \hyperlink{olsr-routing-protocol_8cc_aa7acefeda0e22f22d9ca6b9f445859d7}{OLSR\_SYM\_LINK};
1671         \}
1672       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (link\_tuple->asymTime >= now)
1673         \{
1674           link\_type = \hyperlink{olsr-routing-protocol_8cc_a8ebf1daea9834b2e4dfb42ca05b05f4a}{OLSR\_ASYM\_LINK};
1675         \}
1676       \textcolor{keywordflow}{else}
1677         \{
1678           link\_type = \hyperlink{olsr-routing-protocol_8cc_ab230470cf0b3270a8bba72a05501dd8d}{OLSR\_LOST\_LINK};
1679         \}
1680       \textcolor{comment}{// Establishes neighbor type.}
1681       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_aa73e8ae0cc7d2d68b148cc5937259d03}{FindMprAddress} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae01451170fb389d322b33ed6d954f460}{GetMainAddress} (link\_tuple->
      neighborIfaceAddr)))
1682         \{
1683           nb\_type = \hyperlink{olsr-routing-protocol_8cc_a08fbe0b4c74b944f681630df4fa0fd82}{OLSR\_MPR\_NEIGH};
1684           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"I consider neighbor "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae01451170fb389d322b33ed6d954f460}{GetMainAddress} (link\_tuple->
      neighborIfaceAddr)
1685                                                << \textcolor{stringliteral}{" to be MPR\_NEIGH."});
1686         \}
1687       \textcolor{keywordflow}{else}
1688         \{
1689           \textcolor{keywordtype}{bool} ok = \textcolor{keyword}{false};
1690           \textcolor{keywordflow}{for} (NeighborSet::const\_iterator nb\_tuple = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.
      \hyperlink{classns3_1_1olsr_1_1OlsrState_a82d5882ca3fdb93a9c1110c6f176c03c}{GetNeighbors} ().begin ();
1691                nb\_tuple != \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a82d5882ca3fdb93a9c1110c6f176c03c}{GetNeighbors} ().end ();
1692                nb\_tuple++)
1693             \{
1694               \textcolor{keywordflow}{if} (nb\_tuple->neighborMainAddr == \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae01451170fb389d322b33ed6d954f460}{GetMainAddress} (link\_tuple->neighborIfaceAddr
      ))
1695                 \{
1696                   \textcolor{keywordflow}{if} (nb\_tuple->status == \hyperlink{structns3_1_1olsr_1_1NeighborTuple_ad4b623edaedb3a5244291c738ce87e12a1649b9e4d61ac6e27eff65e8bd5dfe15}{NeighborTuple::STATUS\_SYM})
1697                     \{
1698                       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"I consider neighbor "} << 
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae01451170fb389d322b33ed6d954f460}{GetMainAddress} (link\_tuple->neighborIfaceAddr)
1699                                                            << \textcolor{stringliteral}{" to be SYM\_NEIGH."});
1700                       nb\_type = \hyperlink{olsr-routing-protocol_8cc_a46286c316da9922151b354295e71d35a}{OLSR\_SYM\_NEIGH};
1701                     \}
1702                   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (nb\_tuple->status == \hyperlink{structns3_1_1olsr_1_1NeighborTuple_ad4b623edaedb3a5244291c738ce87e12ab633cfd28c2ec5d1f2b6deec3c7ebcf9}{NeighborTuple::STATUS\_NOT\_SYM})
1703                     \{
1704                       nb\_type = \hyperlink{olsr-routing-protocol_8cc_a7ff690f7463019aec83c1f0edd911034}{OLSR\_NOT\_NEIGH};
1705                       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"I consider neighbor "} << 
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae01451170fb389d322b33ed6d954f460}{GetMainAddress} (link\_tuple->neighborIfaceAddr)
1706                                                            << \textcolor{stringliteral}{" to be NOT\_NEIGH."});
1707                     \}
1708                   \textcolor{keywordflow}{else}
1709                     \{
1710                       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"There is a neighbor tuple with an unknown status!\(\backslash\)n"});
1711                     \}
1712                   ok = \textcolor{keyword}{true};
1713                   \textcolor{keywordflow}{break};
1714                 \}
1715             \}
1716           \textcolor{keywordflow}{if} (!ok)
1717             \{
1718               \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"I don't know the neighbor "} << 
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae01451170fb389d322b33ed6d954f460}{GetMainAddress} (link\_tuple->neighborIfaceAddr) << \textcolor{stringliteral}{"!!!"});
1719               \textcolor{keywordflow}{continue};
1720             \}
1721         \}
1722 
1723       olsr::MessageHeader::Hello::LinkMessage linkMessage;
1724       linkMessage.linkCode = (link\_type & 0x03) | ((nb\_type << 2) & 0x0f);
1725       linkMessage.neighborInterfaceAddresses.push\_back
1726         (link\_tuple->neighborIfaceAddr);
1727 
1728       std::vector<Ipv4Address> interfaces =
1729         \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a90204c0096fb66ea3f41a3e530f4befe}{FindNeighborInterfaces} (link\_tuple->neighborIfaceAddr);
1730 
1731       linkMessage.neighborInterfaceAddresses.insert
1732         (linkMessage.neighborInterfaceAddresses.end (),
1733         interfaces.begin (), interfaces.end ());
1734 
1735       linkMessages.push\_back (linkMessage);
1736     \}
1737   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"OLSR HELLO message size: "} << \textcolor{keywordtype}{int} (msg.GetSerializedSize ())
1738                                             << \textcolor{stringliteral}{" (with "} << \textcolor{keywordtype}{int} (linkMessages.size ()) << \textcolor{stringliteral}{" link messages)"}
      );
1739   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a206c7c0bba382cba1ac50d11a7df88f3}{QueueMessage} (msg, \hyperlink{olsr-routing-protocol_8cc_a06863e04dddc5f7fbbedb516974df4b3}{JITTER});
1740 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 110




Here is the caller graph for this function\+:
% FIG 111


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Send\+Hna@{Send\+Hna}}
\index{Send\+Hna@{Send\+Hna}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Hna()}{SendHna()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Send\+Hna (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a02fe3cc6e62962d002818651fc6988df}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a02fe3cc6e62962d002818651fc6988df}


Creates a new O\+L\+SR H\+NA message which is buffered for being sent later on. 


\begin{DoxyCode}
1813 \{
1814 
1815   olsr::MessageHeader msg;
1816 
1817   msg.SetVTime (\hyperlink{olsr-routing-protocol_8cc_a223d875fc1256e80f16130ae9d74be5f}{OLSR\_HNA\_HOLD\_TIME});
1818   msg.SetOriginatorAddress (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress});
1819   msg.SetTimeToLive (255);
1820   msg.SetHopCount (0);
1821   msg.SetMessageSequenceNumber (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_af8656b873ecc22d25d5e5795f936d61a}{GetMessageSequenceNumber} ());
1822   olsr::MessageHeader::Hna &hna = msg.GetHna ();
1823 
1824   std::vector<olsr::MessageHeader::Hna::Association> &associations = hna.associations;
1825 
1826   \textcolor{comment}{// Add all local HNA associations to the HNA message}
1827   \textcolor{keyword}{const} \hyperlink{namespacens3_1_1olsr_a7aefab4ffae5b289262125647510a2ef}{Associations} &localHnaAssociations = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.
      \hyperlink{classns3_1_1olsr_1_1OlsrState_af0d7450ccc6238bb018e8f22fcaf0552}{GetAssociations} ();
1828   \textcolor{keywordflow}{for} (Associations::const\_iterator it = localHnaAssociations.begin ();
1829        it != localHnaAssociations.end (); it++)
1830     \{
1831       olsr::MessageHeader::Hna::Association assoc = \{ it->networkAddr, it->netmask\};
1832       associations.push\_back (assoc);
1833     \}
1834   \textcolor{comment}{// If there is no HNA associations to send, return without queuing the message}
1835   \textcolor{keywordflow}{if} (associations.size () == 0)
1836     \{
1837       \textcolor{keywordflow}{return};
1838     \}
1839 
1840   \textcolor{comment}{// Else, queue the message to be sent later on}
1841   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a206c7c0bba382cba1ac50d11a7df88f3}{QueueMessage} (msg, \hyperlink{olsr-routing-protocol_8cc_a06863e04dddc5f7fbbedb516974df4b3}{JITTER});
1842 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 112




Here is the caller graph for this function\+:
% FIG 113


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Send\+Mid@{Send\+Mid}}
\index{Send\+Mid@{Send\+Mid}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Mid()}{SendMid()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Send\+Mid (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a6da315bbcafcdda3dc11acfea3b33d28}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a6da315bbcafcdda3dc11acfea3b33d28}


Creates a new O\+L\+SR M\+ID message which is buffered for being sent later on. 


\begin{DoxyCode}
1768 \{
1769   olsr::MessageHeader msg;
1770   olsr::MessageHeader::Mid &mid = msg.GetMid ();
1771 
1772   \textcolor{comment}{// A node which has only a single interface address participating in}
1773   \textcolor{comment}{// the MANET (i.e., running OLSR), MUST NOT generate any MID}
1774   \textcolor{comment}{// message.}
1775 
1776   \textcolor{comment}{// A node with several interfaces, where only one is participating}
1777   \textcolor{comment}{// in the MANET and running OLSR (e.g., a node is connected to a}
1778   \textcolor{comment}{// wired network as well as to a MANET) MUST NOT generate any MID}
1779   \textcolor{comment}{// messages.}
1780 
1781   \textcolor{comment}{// A node with several interfaces, where more than one is}
1782   \textcolor{comment}{// participating in the MANET and running OLSR MUST generate MID}
1783   \textcolor{comment}{// messages as specified.}
1784 
1785   \textcolor{comment}{// [ Note: assuming here that all interfaces participate in the}
1786   \textcolor{comment}{// MANET; later we may want to make this configurable. ]}
1787 
1788   Ipv4Address loopback (\textcolor{stringliteral}{"127.0.0.1"});
1789   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4}->GetNInterfaces (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
1790     \{
1791       Ipv4Address addr = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, 0).GetLocal ();
1792       \textcolor{keywordflow}{if} (addr != \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress} && addr != loopback && 
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afa7fdc171732e31fb92298d62f6340e6}{m\_interfaceExclusions}.find (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) == \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afa7fdc171732e31fb92298d62f6340e6}{m\_interfaceExclusions}.end ())
1793         \{
1794           mid.interfaceAddresses.push\_back (addr);
1795         \}
1796     \}
1797   \textcolor{keywordflow}{if} (mid.interfaceAddresses.size () == 0)
1798     \{
1799       \textcolor{keywordflow}{return};
1800     \}
1801 
1802   msg.SetVTime (\hyperlink{olsr-routing-protocol_8cc_a823aeb2161a33758b6e99c3d1c00e7fa}{OLSR\_MID\_HOLD\_TIME});
1803   msg.SetOriginatorAddress (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress});
1804   msg.SetTimeToLive (255);
1805   msg.SetHopCount (0);
1806   msg.SetMessageSequenceNumber (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_af8656b873ecc22d25d5e5795f936d61a}{GetMessageSequenceNumber} ());
1807 
1808   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a206c7c0bba382cba1ac50d11a7df88f3}{QueueMessage} (msg, \hyperlink{olsr-routing-protocol_8cc_a06863e04dddc5f7fbbedb516974df4b3}{JITTER});
1809 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 114




Here is the caller graph for this function\+:
% FIG 115


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Send\+Packet@{Send\+Packet}}
\index{Send\+Packet@{Send\+Packet}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Packet(\+Ptr$<$ Packet $>$ packet, const Message\+List \&contained\+Messages)}{SendPacket(Ptr< Packet > packet, const MessageList &containedMessages)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Send\+Packet (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{const {\bf Message\+List} \&}]{contained\+Messages}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a31a103b24f235d7a7719258993363fc9}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a31a103b24f235d7a7719258993363fc9}
Send an O\+L\+SR message. 
\begin{DoxyParams}{Parameters}
{\em packet} & The packet to be sent. \\
\hline
{\em contained\+Messages} & The messages contained in the packet. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1577 \{
1578   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"OLSR node "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress} << \textcolor{stringliteral}{" sending a OLSR packet"});
1579 
1580   \textcolor{comment}{// Add a header}
1581   olsr::PacketHeader header;
1582   header.SetPacketLength (header.GetSerializedSize () + packet->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ());
1583   header.SetPacketSequenceNumber (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ab7cac75ba09d451d4cc12acb2030fbee}{GetPacketSequenceNumber} ());
1584   packet->\hyperlink{classns3_1_1Packet_a465108c595a0bc592095cbcab1832ed8}{AddHeader} (header);
1585 
1586   \textcolor{comment}{// Trace it}
1587   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_aadd8d4fea9a32b185bf23d787004de9d}{m\_txPacketTrace} (header, containedMessages);
1588 
1589   \textcolor{comment}{// Send it}
1590   \textcolor{keywordflow}{for} (std::map<Ptr<Socket>, Ipv4InterfaceAddress>::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} =
1591          \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae590f1f394f2ebc0fac434a6866d7c75}{m\_socketAddresses}.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae590f1f394f2ebc0fac434a6866d7c75}{m\_socketAddresses}.end (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
1592     \{
1593       Ipv4Address bcast = \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second.GetLocal ().GetSubnetDirectedBroadcast (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second.GetMask ());
1594       \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->first->SendTo (packet, 0, InetSocketAddress (bcast, \hyperlink{olsr-routing-protocol_8cc_a56099fb2a14f4a74c5e155c13e9ef8db}{OLSR\_PORT\_NUMBER}));
1595     \}
1596 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 116




Here is the caller graph for this function\+:
% FIG 117


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Send\+Queued\+Messages@{Send\+Queued\+Messages}}
\index{Send\+Queued\+Messages@{Send\+Queued\+Messages}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Queued\+Messages()}{SendQueuedMessages()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Send\+Queued\+Messages (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a0ee7494c6ac857210f7f12d40d39e349}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a0ee7494c6ac857210f7f12d40d39e349}


Creates as many O\+L\+SR packets as needed in order to send all buffered O\+L\+SR messages. 

Maximum number of messages which can be contained in an O\+L\+SR packet is dictated by O\+L\+S\+R\+\_\+\+M\+A\+X\+\_\+\+M\+S\+GS constant. 
\begin{DoxyCode}
1600 \{
1601   Ptr<Packet> packet = Create<Packet> ();
1602   \textcolor{keywordtype}{int} numMessages = 0;
1603 
1604   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Olsr node "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress} << \textcolor{stringliteral}{": SendQueuedMessages"});
1605 
1606   \hyperlink{namespacens3_1_1olsr_af17c710718a5637d01f37804a0a53e78}{MessageList} msglist;
1607 
1608   \textcolor{keywordflow}{for} (std::vector<olsr::MessageHeader>::const\_iterator message = 
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a1366596191a80005da6f45af00585d1d}{m\_queuedMessages}.begin ();
1609        message != \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a1366596191a80005da6f45af00585d1d}{m\_queuedMessages}.end ();
1610        message++)
1611     \{
1612       Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = Create<Packet> ();
1613       p->AddHeader (*message);
1614       packet->AddAtEnd (p);
1615       msglist.push\_back (*message);
1616       \textcolor{keywordflow}{if} (++numMessages == \hyperlink{olsr-routing-protocol_8cc_acec0137086044d30a83596f39122a0f9}{OLSR\_MAX\_MSGS})
1617         \{
1618           \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a31a103b24f235d7a7719258993363fc9}{SendPacket} (packet, msglist);
1619           msglist.clear ();
1620           \textcolor{comment}{// Reset variables for next packet}
1621           numMessages = 0;
1622           packet = Create<Packet> ();
1623         \}
1624     \}
1625 
1626   \textcolor{keywordflow}{if} (packet->GetSize ())
1627     \{
1628       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a31a103b24f235d7a7719258993363fc9}{SendPacket} (packet, msglist);
1629     \}
1630 
1631   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a1366596191a80005da6f45af00585d1d}{m\_queuedMessages}.clear ();
1632 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 118




Here is the caller graph for this function\+:
% FIG 119


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Send\+Tc@{Send\+Tc}}
\index{Send\+Tc@{Send\+Tc}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Tc()}{SendTc()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Send\+Tc (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a78a41697a6d747bde67d5cb2cd13a4bd}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a78a41697a6d747bde67d5cb2cd13a4bd}


Creates a new O\+L\+SR TC message which is buffered for being sent later on. 


\begin{DoxyCode}
1744 \{
1745   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1746 
1747   olsr::MessageHeader msg;
1748 
1749   msg.SetVTime (\hyperlink{olsr-routing-protocol_8cc_a52dd6b4ef360db0602f9cfbc820e3402}{OLSR\_TOP\_HOLD\_TIME});
1750   msg.SetOriginatorAddress (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress});
1751   msg.SetTimeToLive (255);
1752   msg.SetHopCount (0);
1753   msg.SetMessageSequenceNumber (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_af8656b873ecc22d25d5e5795f936d61a}{GetMessageSequenceNumber} ());
1754 
1755   olsr::MessageHeader::Tc &tc = msg.GetTc ();
1756   tc.ansn = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a8c7b6d3b6eab86260e8ac9848e6f2621}{m\_ansn};
1757 
1758   \textcolor{keywordflow}{for} (MprSelectorSet::const\_iterator mprsel\_tuple = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.
      \hyperlink{classns3_1_1olsr_1_1OlsrState_a2514e58296452650e5fffc4cc7036a8d}{GetMprSelectors} ().begin ();
1759        mprsel\_tuple != \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a2514e58296452650e5fffc4cc7036a8d}{GetMprSelectors} ().end (); mprsel\_tuple++)
1760     \{
1761       tc.neighborAddresses.push\_back (mprsel\_tuple->mainAddr);
1762     \}
1763   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a206c7c0bba382cba1ac50d11a7df88f3}{QueueMessage} (msg, \hyperlink{olsr-routing-protocol_8cc_a06863e04dddc5f7fbbedb516974df4b3}{JITTER});
1764 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 120




Here is the caller graph for this function\+:
% FIG 121


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Set\+Interface\+Exclusions@{Set\+Interface\+Exclusions}}
\index{Set\+Interface\+Exclusions@{Set\+Interface\+Exclusions}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Interface\+Exclusions(std\+::set$<$ uint32\+\_\+t $>$ exceptions)}{SetInterfaceExclusions(std::set< uint32_t > exceptions)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Set\+Interface\+Exclusions (
\begin{DoxyParamCaption}
\item[{std\+::set$<$ uint32\+\_\+t $>$}]{exceptions}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_ac835a5b09eceb7c7168a953b640cac5c}{}\label{classns3_1_1olsr_1_1RoutingProtocol_ac835a5b09eceb7c7168a953b640cac5c}
Set the interfaces to be excluded. 
\begin{DoxyParams}{Parameters}
{\em exceptions} & Container of excluded interfaces. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
376 \{
377   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afa7fdc171732e31fb92298d62f6340e6}{m\_interfaceExclusions} = exceptions;
378 \}
\end{DoxyCode}
\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Set\+Ipv4@{Set\+Ipv4}}
\index{Set\+Ipv4@{Set\+Ipv4}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Ipv4(\+Ptr$<$ Ipv4 $>$ ipv4)}{SetIpv4(Ptr< Ipv4 > ipv4)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Set\+Ipv4 (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv4} $>$}]{ipv4}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_ab0e32a7ea7f5198133eaacca3b4c12da}{}\label{classns3_1_1olsr_1_1RoutingProtocol_ab0e32a7ea7f5198133eaacca3b4c12da}

\begin{DoxyParams}{Parameters}
{\em ipv4} & the ipv4 object this routing protocol is being associated with\\
\hline
\end{DoxyParams}
Typically, invoked directly or indirectly from \hyperlink{classns3_1_1Ipv4_a2d165c3bafd4ca580f02a03536db80d3}{ns3\+::\+Ipv4\+::\+Set\+Routing\+Protocol} 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_af3947a05b912ea3f2a1ef0e9777f723e}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
216 \{
217   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (ipv4 != 0);
218   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4} == 0);
219   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Created olsr::RoutingProtocol"});
220   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_aa739535b4dfd71566cb385c9c58f59c9}{m\_helloTimer}.\hyperlink{classns3_1_1Timer_a044b29030c9de99298d51ac0ccfc104c}{SetFunction} (&
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a5f10703d9d0e82e48466ab69838c7b2b}{RoutingProtocol::HelloTimerExpire}, \textcolor{keyword}{this});
221   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a31e8b4356d659f7ec1c82b86365a179d}{m\_tcTimer}.\hyperlink{classns3_1_1Timer_a044b29030c9de99298d51ac0ccfc104c}{SetFunction} (&\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ad9443857cbc18e1fe48848106c40c96f}{RoutingProtocol::TcTimerExpire},
       \textcolor{keyword}{this});
222   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a7d525e1847150003ef21cd962a66c759}{m\_midTimer}.\hyperlink{classns3_1_1Timer_a044b29030c9de99298d51ac0ccfc104c}{SetFunction} (&\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_adb532d5890ea3954e8ab73a625d53e66}{RoutingProtocol::MidTimerExpire}
      , \textcolor{keyword}{this});
223   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_acaf11a25b83098c640a063a094148374}{m\_hnaTimer}.\hyperlink{classns3_1_1Timer_a044b29030c9de99298d51ac0ccfc104c}{SetFunction} (&\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a6ef2a79ac872935b84a3f1d54316456d}{RoutingProtocol::HnaTimerExpire}
      , \textcolor{keyword}{this});
224   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a8b54985da7787840baa68ce4781e5d76}{m\_queuedMessagesTimer}.\hyperlink{classns3_1_1Timer_a044b29030c9de99298d51ac0ccfc104c}{SetFunction} (&
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a0ee7494c6ac857210f7f12d40d39e349}{RoutingProtocol::SendQueuedMessages}, \textcolor{keyword}{this});
225 
226   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_aa5051691fb81c7109b9e2b6c54b43b7f}{m\_packetSequenceNumber} = \hyperlink{olsr-routing-protocol_8cc_a33c0bdae6376cc58e151fdd28db2a33b}{OLSR\_MAX\_SEQ\_NUM};
227   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a0f6d3f3ae8a78fbf2e2522d9f21e23ca}{m\_messageSequenceNumber} = \hyperlink{olsr-routing-protocol_8cc_a33c0bdae6376cc58e151fdd28db2a33b}{OLSR\_MAX\_SEQ\_NUM};
228   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a8c7b6d3b6eab86260e8ac9848e6f2621}{m\_ansn} = \hyperlink{olsr-routing-protocol_8cc_a33c0bdae6376cc58e151fdd28db2a33b}{OLSR\_MAX\_SEQ\_NUM};
229 
230   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae6557d76350cf59d34d2aae8e9c79831}{m\_linkTupleTimerFirstTime} = \textcolor{keyword}{true};
231 
232   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4} = ipv4;
233 
234   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a398799911ae136e0b247b4bbd608c336}{m\_hnaRoutingTable}->SetIpv4 (ipv4);
235 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 122


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Set\+Main\+Interface@{Set\+Main\+Interface}}
\index{Set\+Main\+Interface@{Set\+Main\+Interface}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Main\+Interface(uint32\+\_\+t interface)}{SetMainInterface(uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Set\+Main\+Interface (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a688aa2a34930b4132f500d9d6c253f0e}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a688aa2a34930b4132f500d9d6c253f0e}


Set the O\+L\+SR main address to the first address on the indicated interface. 


\begin{DoxyParams}{Parameters}
{\em interface} & I\+Pv4 interface index \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
371 \{
372   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{m\_mainAddress} = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{m\_ipv4}->GetAddress (interface, 0).GetLocal ();
373 \}
\end{DoxyCode}
\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Set\+Routing\+Table\+Association@{Set\+Routing\+Table\+Association}}
\index{Set\+Routing\+Table\+Association@{Set\+Routing\+Table\+Association}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Routing\+Table\+Association(\+Ptr$<$ Ipv4\+Static\+Routing $>$ routing\+Table)}{SetRoutingTableAssociation(Ptr< Ipv4StaticRouting > routingTable)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Set\+Routing\+Table\+Association (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv4\+Static\+Routing} $>$}]{routing\+Table}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a54e6ae3299f2f4e6390792801fe01ae3}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a54e6ae3299f2f4e6390792801fe01ae3}


Associates the specified \hyperlink{classns3_1_1Ipv4StaticRouting}{Ipv4\+Static\+Routing} routing table to the O\+L\+SR routing protocol. Entries from this associated routing table that use non-\/olsr outgoing interfaces are added to the list of local H\+NA associations so that they are included in H\+NA messages sent by the node. If this method is called more than once, entries from the old association are deleted before entries from the new one are added. 


\begin{DoxyParams}{Parameters}
{\em routing\+Table} & the \hyperlink{classns3_1_1Ipv4StaticRouting}{Ipv4\+Static\+Routing} routing table to be associated. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1874 \{
1875   \textcolor{comment}{// If a routing table has already been associated, remove}
1876   \textcolor{comment}{// corresponding entries from the list of local HNA associations}
1877   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae631ae3941f563718274166203d3b178}{m\_routingTableAssociation} != 0)
1878     \{
1879       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Removing HNA entries coming from the old routing table association."});
1880       \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae631ae3941f563718274166203d3b178}{m\_routingTableAssociation}->GetNRoutes (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
1881         \{
1882           Ipv4RoutingTableEntry route = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae631ae3941f563718274166203d3b178}{m\_routingTableAssociation}->GetRoute (
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
1883           \textcolor{comment}{// If the outgoing interface for this route is a non-olsr interface}
1884           \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae4f144aababb20e17a8cfc7c0823bb89}{UsesNonOlsrOutgoingInterface} (route))
1885             \{
1886               \textcolor{comment}{// remove the corresponding entry}
1887               \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a06c4bb2917ebc46ab608d4c9c3c4cbaa}{RemoveHostNetworkAssociation} (route.GetDestNetwork (), route.
      GetDestNetworkMask ());
1888             \}
1889         \}
1890     \}
1891 
1892   \textcolor{comment}{// Sets the routingTableAssociation to its new value}
1893   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae631ae3941f563718274166203d3b178}{m\_routingTableAssociation} = routingTable;
1894 
1895   \textcolor{comment}{// Iterate over entries of the associated routing table and}
1896   \textcolor{comment}{// add the routes using non-olsr outgoing interfaces to the list}
1897   \textcolor{comment}{// of local HNA associations}
1898   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Nb local associations before adding some entries from"}
1899                 \textcolor{stringliteral}{" the associated routing table: "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.
      \hyperlink{classns3_1_1olsr_1_1OlsrState_af0d7450ccc6238bb018e8f22fcaf0552}{GetAssociations} ().size ());
1900   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < m\_routingTableAssociation->GetNRoutes (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
1901     \{
1902       Ipv4RoutingTableEntry route = m\_routingTableAssociation->GetRoute (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
1903       Ipv4Address destNetworkAddress = route.GetDestNetwork ();
1904       Ipv4Mask destNetmask = route.GetDestNetworkMask ();
1905 
1906       \textcolor{comment}{// If the outgoing interface for this route is a non-olsr interface,}
1907       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae4f144aababb20e17a8cfc7c0823bb89}{UsesNonOlsrOutgoingInterface} (route))
1908         \{
1909           \textcolor{comment}{// Add this entry's network address and netmask to the list of local HNA entries}
1910           \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a330fa7cafeb6258b6ef816e5b54e0327}{AddHostNetworkAssociation} (destNetworkAddress, destNetmask);
1911         \}
1912     \}
1913   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Nb local associations after having added some entries from "}
1914                 \textcolor{stringliteral}{"the associated routing table: "} << \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.
      \hyperlink{classns3_1_1olsr_1_1OlsrState_af0d7450ccc6238bb018e8f22fcaf0552}{GetAssociations} ().size ());
1915 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 123


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Tc\+Timer\+Expire@{Tc\+Timer\+Expire}}
\index{Tc\+Timer\+Expire@{Tc\+Timer\+Expire}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Tc\+Timer\+Expire()}{TcTimerExpire()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Tc\+Timer\+Expire (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_ad9443857cbc18e1fe48848106c40c96f}{}\label{classns3_1_1olsr_1_1RoutingProtocol_ad9443857cbc18e1fe48848106c40c96f}


Sends a TC message (if there exists any M\+PR selector) and reschedules the TC timer. 


\begin{DoxyCode}
2574 \{
2575   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a2514e58296452650e5fffc4cc7036a8d}{GetMprSelectors} ().size () > 0)
2576     \{
2577       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a78a41697a6d747bde67d5cb2cd13a4bd}{SendTc} ();
2578     \}
2579   \textcolor{keywordflow}{else}
2580     \{
2581       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Not sending any TC, no one selected me as MPR."});
2582     \}
2583   \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a31e8b4356d659f7ec1c82b86365a179d}{m\_tcTimer}.\hyperlink{classns3_1_1Timer_ac3345d696887578f518b19f359f7f94b}{Schedule} (\hyperlink{classns3_1_1olsr_1_1RoutingProtocol_ae282dcb4112be0b4f2ac8f413b022fa9}{m\_tcInterval});
2584 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 124




Here is the caller graph for this function\+:
% FIG 125


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Topology\+Tuple\+Timer\+Expire@{Topology\+Tuple\+Timer\+Expire}}
\index{Topology\+Tuple\+Timer\+Expire@{Topology\+Tuple\+Timer\+Expire}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Topology\+Tuple\+Timer\+Expire(\+Ipv4\+Address dest\+Addr, Ipv4\+Address last\+Addr)}{TopologyTupleTimerExpire(Ipv4Address destAddr, Ipv4Address lastAddr)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Routing\+Protocol\+::\+Topology\+Tuple\+Timer\+Expire (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{dest\+Addr, }
\item[{{\bf Ipv4\+Address}}]{last\+Addr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a9200f9b5d45ca2eacf92027ca0355182}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a9200f9b5d45ca2eacf92027ca0355182}


Removes topology tuple\+\_\+ if expired. Else the timer is rescheduled to expire at tuple\+\_\+-\/$>$time(). 

The task of actually removing the tuple is left to the O\+L\+SR agent.


\begin{DoxyParams}{Parameters}
{\em dest\+Addr} & The destination address. \\
\hline
{\em last\+Addr} & The last address. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2709 \{
2710   TopologyTuple *tuple = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{m\_state}.\hyperlink{classns3_1_1olsr_1_1OlsrState_a9f2882a2443c4bbcaeea3e92d178b960}{FindTopologyTuple} (destAddr, lastAddr);
2711   \textcolor{keywordflow}{if} (tuple == NULL)
2712     \{
2713       \textcolor{keywordflow}{return};
2714     \}
2715   \textcolor{keywordflow}{if} (tuple->expirationTime < \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ())
2716     \{
2717       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a496a7619f3c2de003aebd7554eba2e6e}{RemoveTopologyTuple} (*tuple);
2718     \}
2719   \textcolor{keywordflow}{else}
2720     \{
2721       \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a80368d3da46150cf3fc9139c40f33d53}{m\_events}.\hyperlink{classns3_1_1EventGarbageCollector_a4f26a1f6e9a09e648eb31b46acd85144}{Track} (\hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{olsr-routing-protocol_8cc_ad0a00c3386c4a24278b3b710ae798220}{DELAY} (tuple->
      expirationTime),
2722                                            &
      \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_a9200f9b5d45ca2eacf92027ca0355182}{RoutingProtocol::TopologyTupleTimerExpire},
2723                                            \textcolor{keyword}{this}, tuple->destAddr, tuple->lastAddr));
2724     \}
2725 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 126




Here is the caller graph for this function\+:
% FIG 127


\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!Uses\+Non\+Olsr\+Outgoing\+Interface@{Uses\+Non\+Olsr\+Outgoing\+Interface}}
\index{Uses\+Non\+Olsr\+Outgoing\+Interface@{Uses\+Non\+Olsr\+Outgoing\+Interface}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Uses\+Non\+Olsr\+Outgoing\+Interface(const Ipv4\+Routing\+Table\+Entry \&route)}{UsesNonOlsrOutgoingInterface(const Ipv4RoutingTableEntry &route)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::olsr\+::\+Routing\+Protocol\+::\+Uses\+Non\+Olsr\+Outgoing\+Interface (
\begin{DoxyParamCaption}
\item[{const {\bf Ipv4\+Routing\+Table\+Entry} \&}]{route}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_ae4f144aababb20e17a8cfc7c0823bb89}{}\label{classns3_1_1olsr_1_1RoutingProtocol_ae4f144aababb20e17a8cfc7c0823bb89}


Tests whether or not the specified route uses a non-\/\+O\+L\+SR outgoing interface. 


\begin{DoxyParams}{Parameters}
{\em route} & The route to be tested. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the outgoing interface of the specified route is a non-\/\+O\+L\+SR interface, false otherwise. 
\end{DoxyReturn}

\begin{DoxyCode}
1919 \{
1920   std::set<uint32\_t>::const\_iterator ci = \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afa7fdc171732e31fb92298d62f6340e6}{m\_interfaceExclusions}.find (route.
      GetInterface ());
1921   \textcolor{comment}{// The outgoing interface is a non-OLSR interface if a match is found}
1922   \textcolor{comment}{// before reaching the end of the list of excluded interfaces}
1923   \textcolor{keywordflow}{return} ci != \hyperlink{classns3_1_1olsr_1_1RoutingProtocol_afa7fdc171732e31fb92298d62f6340e6}{m\_interfaceExclusions}.end ();
1924 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 128




Here is the caller graph for this function\+:
% FIG 129




\subsection{Friends And Related Function Documentation}
\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!\+::\+Olsr\+Mpr\+Test\+Case@{\+::\+Olsr\+Mpr\+Test\+Case}}
\index{\+::\+Olsr\+Mpr\+Test\+Case@{\+::\+Olsr\+Mpr\+Test\+Case}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{\+::\+Olsr\+Mpr\+Test\+Case}{::OlsrMprTestCase}}]{\setlength{\rightskip}{0pt plus 5cm}friend class \+::{\bf Olsr\+Mpr\+Test\+Case}\hspace{0.3cm}{\ttfamily [friend]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a207c4dff8592b10a0fa2924d05c40380}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a207c4dff8592b10a0fa2924d05c40380}


\subsection{Member Data Documentation}
\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!m\+\_\+ansn@{m\+\_\+ansn}}
\index{m\+\_\+ansn@{m\+\_\+ansn}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+ansn}{m_ansn}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::olsr\+::\+Routing\+Protocol\+::m\+\_\+ansn\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a8c7b6d3b6eab86260e8ac9848e6f2621}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a8c7b6d3b6eab86260e8ac9848e6f2621}


Advertised Neighbor Set sequence number. 

\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!m\+\_\+events@{m\+\_\+events}}
\index{m\+\_\+events@{m\+\_\+events}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+events}{m_events}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Event\+Garbage\+Collector} ns3\+::olsr\+::\+Routing\+Protocol\+::m\+\_\+events\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a80368d3da46150cf3fc9139c40f33d53}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a80368d3da46150cf3fc9139c40f33d53}


Running events. 

\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!m\+\_\+hello\+Interval@{m\+\_\+hello\+Interval}}
\index{m\+\_\+hello\+Interval@{m\+\_\+hello\+Interval}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+hello\+Interval}{m_helloInterval}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::olsr\+::\+Routing\+Protocol\+::m\+\_\+hello\+Interval\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_ac973c86cbf21168c11cd7f16acc1ae4c}{}\label{classns3_1_1olsr_1_1RoutingProtocol_ac973c86cbf21168c11cd7f16acc1ae4c}


H\+E\+L\+LO messages\textquotesingle{} emission interval. 

\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!m\+\_\+hello\+Timer@{m\+\_\+hello\+Timer}}
\index{m\+\_\+hello\+Timer@{m\+\_\+hello\+Timer}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+hello\+Timer}{m_helloTimer}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Timer} ns3\+::olsr\+::\+Routing\+Protocol\+::m\+\_\+hello\+Timer\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_aa739535b4dfd71566cb385c9c58f59c9}{}\label{classns3_1_1olsr_1_1RoutingProtocol_aa739535b4dfd71566cb385c9c58f59c9}


\hyperlink{classns3_1_1Timer}{Timer} for the H\+E\+L\+LO message. 

\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!m\+\_\+hna\+Interval@{m\+\_\+hna\+Interval}}
\index{m\+\_\+hna\+Interval@{m\+\_\+hna\+Interval}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+hna\+Interval}{m_hnaInterval}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::olsr\+::\+Routing\+Protocol\+::m\+\_\+hna\+Interval\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a0d117664d5991c4b405b9ef14c33ea23}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a0d117664d5991c4b405b9ef14c33ea23}


H\+NA messages\textquotesingle{} emission interval. 

\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!m\+\_\+hna\+Routing\+Table@{m\+\_\+hna\+Routing\+Table}}
\index{m\+\_\+hna\+Routing\+Table@{m\+\_\+hna\+Routing\+Table}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+hna\+Routing\+Table}{m_hnaRoutingTable}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Ipv4\+Static\+Routing}$>$ ns3\+::olsr\+::\+Routing\+Protocol\+::m\+\_\+hna\+Routing\+Table\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a398799911ae136e0b247b4bbd608c336}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a398799911ae136e0b247b4bbd608c336}


Routing table for H\+NA routes. 

\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!m\+\_\+hna\+Timer@{m\+\_\+hna\+Timer}}
\index{m\+\_\+hna\+Timer@{m\+\_\+hna\+Timer}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+hna\+Timer}{m_hnaTimer}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Timer} ns3\+::olsr\+::\+Routing\+Protocol\+::m\+\_\+hna\+Timer\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_acaf11a25b83098c640a063a094148374}{}\label{classns3_1_1olsr_1_1RoutingProtocol_acaf11a25b83098c640a063a094148374}


\hyperlink{classns3_1_1Timer}{Timer} for the H\+NA message. 

\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!m\+\_\+interface\+Exclusions@{m\+\_\+interface\+Exclusions}}
\index{m\+\_\+interface\+Exclusions@{m\+\_\+interface\+Exclusions}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+interface\+Exclusions}{m_interfaceExclusions}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::set$<$uint32\+\_\+t$>$ ns3\+::olsr\+::\+Routing\+Protocol\+::m\+\_\+interface\+Exclusions\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_afa7fdc171732e31fb92298d62f6340e6}{}\label{classns3_1_1olsr_1_1RoutingProtocol_afa7fdc171732e31fb92298d62f6340e6}


Set of interfaces excluded by O\+S\+LR. 

\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!m\+\_\+ipv4@{m\+\_\+ipv4}}
\index{m\+\_\+ipv4@{m\+\_\+ipv4}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+ipv4}{m_ipv4}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Ipv4}$>$ ns3\+::olsr\+::\+Routing\+Protocol\+::m\+\_\+ipv4\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}{}\label{classns3_1_1olsr_1_1RoutingProtocol_afede79b25ec57e797ff900ae01bca1df}


I\+Pv4 object the routing is linked to. 

\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!m\+\_\+link\+Tuple\+Timer\+First\+Time@{m\+\_\+link\+Tuple\+Timer\+First\+Time}}
\index{m\+\_\+link\+Tuple\+Timer\+First\+Time@{m\+\_\+link\+Tuple\+Timer\+First\+Time}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+link\+Tuple\+Timer\+First\+Time}{m_linkTupleTimerFirstTime}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::olsr\+::\+Routing\+Protocol\+::m\+\_\+link\+Tuple\+Timer\+First\+Time\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_ae6557d76350cf59d34d2aae8e9c79831}{}\label{classns3_1_1olsr_1_1RoutingProtocol_ae6557d76350cf59d34d2aae8e9c79831}


Flag to indicate if it is the first time the Link\+Tuple\+Timer fires. 

\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!m\+\_\+main\+Address@{m\+\_\+main\+Address}}
\index{m\+\_\+main\+Address@{m\+\_\+main\+Address}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+main\+Address}{m_mainAddress}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Address} ns3\+::olsr\+::\+Routing\+Protocol\+::m\+\_\+main\+Address\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a58cc50ed5d1039aab603e90e318aabfb}


the node main address. 

\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!m\+\_\+message\+Sequence\+Number@{m\+\_\+message\+Sequence\+Number}}
\index{m\+\_\+message\+Sequence\+Number@{m\+\_\+message\+Sequence\+Number}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+message\+Sequence\+Number}{m_messageSequenceNumber}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::olsr\+::\+Routing\+Protocol\+::m\+\_\+message\+Sequence\+Number\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a0f6d3f3ae8a78fbf2e2522d9f21e23ca}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a0f6d3f3ae8a78fbf2e2522d9f21e23ca}


Messages sequence number counter. 

\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!m\+\_\+mid\+Interval@{m\+\_\+mid\+Interval}}
\index{m\+\_\+mid\+Interval@{m\+\_\+mid\+Interval}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+mid\+Interval}{m_midInterval}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::olsr\+::\+Routing\+Protocol\+::m\+\_\+mid\+Interval\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a9109a692ebfe241e01a68a584a4961b9}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a9109a692ebfe241e01a68a584a4961b9}


M\+ID messages\textquotesingle{} emission interval. 

\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!m\+\_\+mid\+Timer@{m\+\_\+mid\+Timer}}
\index{m\+\_\+mid\+Timer@{m\+\_\+mid\+Timer}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+mid\+Timer}{m_midTimer}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Timer} ns3\+::olsr\+::\+Routing\+Protocol\+::m\+\_\+mid\+Timer\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a7d525e1847150003ef21cd962a66c759}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a7d525e1847150003ef21cd962a66c759}


\hyperlink{classns3_1_1Timer}{Timer} for the M\+ID message. 

\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!m\+\_\+packet\+Sequence\+Number@{m\+\_\+packet\+Sequence\+Number}}
\index{m\+\_\+packet\+Sequence\+Number@{m\+\_\+packet\+Sequence\+Number}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+packet\+Sequence\+Number}{m_packetSequenceNumber}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::olsr\+::\+Routing\+Protocol\+::m\+\_\+packet\+Sequence\+Number\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_aa5051691fb81c7109b9e2b6c54b43b7f}{}\label{classns3_1_1olsr_1_1RoutingProtocol_aa5051691fb81c7109b9e2b6c54b43b7f}


Packets sequence number counter. 

\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!m\+\_\+queued\+Messages@{m\+\_\+queued\+Messages}}
\index{m\+\_\+queued\+Messages@{m\+\_\+queued\+Messages}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+queued\+Messages}{m_queuedMessages}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf olsr\+::\+Message\+List} ns3\+::olsr\+::\+Routing\+Protocol\+::m\+\_\+queued\+Messages\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a1366596191a80005da6f45af00585d1d}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a1366596191a80005da6f45af00585d1d}


A list of pending messages which are buffered awaiting for being sent. 

\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!m\+\_\+queued\+Messages\+Timer@{m\+\_\+queued\+Messages\+Timer}}
\index{m\+\_\+queued\+Messages\+Timer@{m\+\_\+queued\+Messages\+Timer}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+queued\+Messages\+Timer}{m_queuedMessagesTimer}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Timer} ns3\+::olsr\+::\+Routing\+Protocol\+::m\+\_\+queued\+Messages\+Timer\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a8b54985da7787840baa68ce4781e5d76}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a8b54985da7787840baa68ce4781e5d76}


timer for throttling outgoing messages 

\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!m\+\_\+routing\+Table\+Association@{m\+\_\+routing\+Table\+Association}}
\index{m\+\_\+routing\+Table\+Association@{m\+\_\+routing\+Table\+Association}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+routing\+Table\+Association}{m_routingTableAssociation}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Ipv4\+Static\+Routing}$>$ ns3\+::olsr\+::\+Routing\+Protocol\+::m\+\_\+routing\+Table\+Association\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_ae631ae3941f563718274166203d3b178}{}\label{classns3_1_1olsr_1_1RoutingProtocol_ae631ae3941f563718274166203d3b178}


Associations from an \hyperlink{classns3_1_1Ipv4StaticRouting}{Ipv4\+Static\+Routing} instance. 

\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!m\+\_\+routing\+Table\+Changed@{m\+\_\+routing\+Table\+Changed}}
\index{m\+\_\+routing\+Table\+Changed@{m\+\_\+routing\+Table\+Changed}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+routing\+Table\+Changed}{m_routingTableChanged}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<$uint32\+\_\+t$>$ ns3\+::olsr\+::\+Routing\+Protocol\+::m\+\_\+routing\+Table\+Changed\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a1cbaa4bdf90462b6d8e0ddc90eaa4130}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a1cbaa4bdf90462b6d8e0ddc90eaa4130}


Routing table chanes challback. 

\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!m\+\_\+rx\+Packet\+Trace@{m\+\_\+rx\+Packet\+Trace}}
\index{m\+\_\+rx\+Packet\+Trace@{m\+\_\+rx\+Packet\+Trace}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+rx\+Packet\+Trace}{m_rxPacketTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<$const {\bf Packet\+Header} \&, const {\bf Message\+List} \&$>$ ns3\+::olsr\+::\+Routing\+Protocol\+::m\+\_\+rx\+Packet\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a861b1d2ce370ab0137e67c5a1102a937}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a861b1d2ce370ab0137e67c5a1102a937}


Rx packet trace. 

\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!m\+\_\+socket\+Addresses@{m\+\_\+socket\+Addresses}}
\index{m\+\_\+socket\+Addresses@{m\+\_\+socket\+Addresses}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+socket\+Addresses}{m_socketAddresses}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<$ {\bf Ptr}$<${\bf Socket}$>$, {\bf Ipv4\+Interface\+Address} $>$ ns3\+::olsr\+::\+Routing\+Protocol\+::m\+\_\+socket\+Addresses\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_ae590f1f394f2ebc0fac434a6866d7c75}{}\label{classns3_1_1olsr_1_1RoutingProtocol_ae590f1f394f2ebc0fac434a6866d7c75}


Container of sockets and the interfaces they are opened onto. 

\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!m\+\_\+state@{m\+\_\+state}}
\index{m\+\_\+state@{m\+\_\+state}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+state}{m_state}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Olsr\+State} ns3\+::olsr\+::\+Routing\+Protocol\+::m\+\_\+state\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a07942ec1a7df71b609c8d2ff3b567c49}


Internal state with all needed data structs. 

\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!m\+\_\+table@{m\+\_\+table}}
\index{m\+\_\+table@{m\+\_\+table}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+table}{m_table}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<${\bf Ipv4\+Address}, {\bf Routing\+Table\+Entry}$>$ ns3\+::olsr\+::\+Routing\+Protocol\+::m\+\_\+table\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a9703fb92cc9a864c0e2874387ead3aa3}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a9703fb92cc9a864c0e2874387ead3aa3}


Data structure for the routing table. 

\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!m\+\_\+tc\+Interval@{m\+\_\+tc\+Interval}}
\index{m\+\_\+tc\+Interval@{m\+\_\+tc\+Interval}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+tc\+Interval}{m_tcInterval}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::olsr\+::\+Routing\+Protocol\+::m\+\_\+tc\+Interval\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_ae282dcb4112be0b4f2ac8f413b022fa9}{}\label{classns3_1_1olsr_1_1RoutingProtocol_ae282dcb4112be0b4f2ac8f413b022fa9}


TC messages\textquotesingle{} emission interval. 

\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!m\+\_\+tc\+Timer@{m\+\_\+tc\+Timer}}
\index{m\+\_\+tc\+Timer@{m\+\_\+tc\+Timer}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+tc\+Timer}{m_tcTimer}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Timer} ns3\+::olsr\+::\+Routing\+Protocol\+::m\+\_\+tc\+Timer\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a31e8b4356d659f7ec1c82b86365a179d}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a31e8b4356d659f7ec1c82b86365a179d}


\hyperlink{classns3_1_1Timer}{Timer} for the TC message. 

\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!m\+\_\+tx\+Packet\+Trace@{m\+\_\+tx\+Packet\+Trace}}
\index{m\+\_\+tx\+Packet\+Trace@{m\+\_\+tx\+Packet\+Trace}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+tx\+Packet\+Trace}{m_txPacketTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<$const {\bf Packet\+Header} \&, const {\bf Message\+List} \&$>$ ns3\+::olsr\+::\+Routing\+Protocol\+::m\+\_\+tx\+Packet\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_aadd8d4fea9a32b185bf23d787004de9d}{}\label{classns3_1_1olsr_1_1RoutingProtocol_aadd8d4fea9a32b185bf23d787004de9d}


Tx packet trace. 

\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!m\+\_\+uniform\+Random\+Variable@{m\+\_\+uniform\+Random\+Variable}}
\index{m\+\_\+uniform\+Random\+Variable@{m\+\_\+uniform\+Random\+Variable}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+uniform\+Random\+Variable}{m_uniformRandomVariable}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Uniform\+Random\+Variable}$>$ ns3\+::olsr\+::\+Routing\+Protocol\+::m\+\_\+uniform\+Random\+Variable\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a5aacf6e47c25a9cedfb2998d09e05193}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a5aacf6e47c25a9cedfb2998d09e05193}


Provides uniform random variables. 

\index{ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}!m\+\_\+willingness@{m\+\_\+willingness}}
\index{m\+\_\+willingness@{m\+\_\+willingness}!ns3\+::olsr\+::\+Routing\+Protocol@{ns3\+::olsr\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+willingness}{m_willingness}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::olsr\+::\+Routing\+Protocol\+::m\+\_\+willingness\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1olsr_1_1RoutingProtocol_a2e94c2954ffa92d1c7d3b627087c9430}{}\label{classns3_1_1olsr_1_1RoutingProtocol_a2e94c2954ffa92d1c7d3b627087c9430}


Willingness for forwarding packets on behalf of other nodes. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
olsr/model/\hyperlink{olsr-routing-protocol_8h}{olsr-\/routing-\/protocol.\+h}\item 
olsr/model/\hyperlink{olsr-routing-protocol_8cc}{olsr-\/routing-\/protocol.\+cc}\end{DoxyCompactItemize}
