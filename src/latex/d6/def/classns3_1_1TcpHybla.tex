\hypertarget{classns3_1_1TcpHybla}{}\section{ns3\+:\+:Tcp\+Hybla Class Reference}
\label{classns3_1_1TcpHybla}\index{ns3\+::\+Tcp\+Hybla@{ns3\+::\+Tcp\+Hybla}}


Implementation of the T\+CP Hybla algorithm.  




{\ttfamily \#include $<$tcp-\/hybla.\+h$>$}



Inheritance diagram for ns3\+:\+:Tcp\+Hybla\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Tcp\+Hybla\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1TcpHybla_afa16f70558054d036592ef9aeaa0ef6e}{Tcp\+Hybla} (void)
\item 
\hyperlink{classns3_1_1TcpHybla_ac5f43582228310d30e541c9ead8558fb}{Tcp\+Hybla} (const \hyperlink{classns3_1_1TcpHybla}{Tcp\+Hybla} \&sock)
\begin{DoxyCompactList}\small\item\em Copy constructor. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1TcpHybla_a79d8b406e07b1b76d318c9849f81ffb1}{$\sim$\+Tcp\+Hybla} (void)
\item 
virtual void \hyperlink{classns3_1_1TcpHybla_a23e291ec4fe822d1abd9d1810c961cb8}{Pkts\+Acked} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1TcpSocketState}{Tcp\+Socket\+State} $>$ tcb, uint32\+\_\+t segments\+Acked, const \hyperlink{classns3_1_1Time}{Time} \&rtt)
\begin{DoxyCompactList}\small\item\em Timing information on received A\+CK. \end{DoxyCompactList}\item 
virtual std\+::string \hyperlink{classns3_1_1TcpHybla_a5f2c0e4bbceebf35436b596effecf1a7}{Get\+Name} () const 
\begin{DoxyCompactList}\small\item\em Get the name of the congestion control algorithm. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1TcpCongestionOps}{Tcp\+Congestion\+Ops} $>$ \hyperlink{classns3_1_1TcpHybla_a43ce1d6a0ee818a29988fdc9f9b1f6bb}{Fork} ()
\begin{DoxyCompactList}\small\item\em Copy the congestion control algorithm across socket. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1TcpHybla_ab0713a818be55782fe433232f5cbc412}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1TcpHybla_a374c804fcaf21e2cd4c51f0ff6003798}{Slow\+Start} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1TcpSocketState}{Tcp\+Socket\+State} $>$ tcb, uint32\+\_\+t segments\+Acked)
\begin{DoxyCompactList}\small\item\em Tcp New\+Reno slow start algorithm. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1TcpHybla_a10463113be84c3506fe85b5abfe8b186}{Congestion\+Avoidance} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1TcpSocketState}{Tcp\+Socket\+State} $>$ tcb, uint32\+\_\+t segments\+Acked)
\begin{DoxyCompactList}\small\item\em New\+Reno congestion avoidance. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classns3_1_1TcpHybla_a95d8b83e64724cd6ee323211a9b2a16f}{Recalc\+Param} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1TcpSocketState}{Tcp\+Socket\+State} $>$ tcb, const \hyperlink{classns3_1_1Time}{Time} \&rtt)
\begin{DoxyCompactList}\small\item\em Recalculate algorithm parameters. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1TracedValue}{Traced\+Value}$<$ double $>$ \hyperlink{classns3_1_1TcpHybla_a89505ef8588ef3cbe7d19422cd8e1c78}{m\+\_\+rho}
\begin{DoxyCompactList}\small\item\em Rho parameter. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1TcpHybla_aba2994395c9fa371e2a1cd84b713a157}{m\+\_\+min\+Rtt}
\begin{DoxyCompactList}\small\item\em Minimum smoothed round trip time value seen. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1TcpHybla_a3bde103cdd139def963021b423853d78}{m\+\_\+r\+Rtt}
\begin{DoxyCompactList}\small\item\em Reference R\+TT. \end{DoxyCompactList}\item 
double \hyperlink{classns3_1_1TcpHybla_ac5ab21faceb85b6e6038419fd8392d54}{m\+\_\+c\+Wnd\+Cnt}
\begin{DoxyCompactList}\small\item\em c\+Wnd integer-\/to-\/float counter \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Implementation of the T\+CP Hybla algorithm. 

The key idea behind T\+CP Hybla is to obtain for long R\+TT connections the same instantaneous transmission rate of a reference T\+CP connection with lower R\+TT. With analytical steps, it is shown that this goal can be achieved by modifying the time scale, in order for the throughput to be independent from the R\+TT. This independence is obtained through the use of a coefficient rho.

This coefficient is used to calculate both the slow start threshold and the congestion window when in slow start and in congestion avoidance, respectively.

More information\+: \href{http://dl.acm.org/citation.cfm?id=2756518}{\tt http\+://dl.\+acm.\+org/citation.\+cfm?id=2756518} 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Tcp\+Hybla@{ns3\+::\+Tcp\+Hybla}!Tcp\+Hybla@{Tcp\+Hybla}}
\index{Tcp\+Hybla@{Tcp\+Hybla}!ns3\+::\+Tcp\+Hybla@{ns3\+::\+Tcp\+Hybla}}
\subsubsection[{\texorpdfstring{Tcp\+Hybla(void)}{TcpHybla(void)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Tcp\+Hybla\+::\+Tcp\+Hybla (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpHybla_afa16f70558054d036592ef9aeaa0ef6e}{}\label{classns3_1_1TcpHybla_afa16f70558054d036592ef9aeaa0ef6e}
Create an unbound tcp socket. 
\begin{DoxyCode}
49   : \hyperlink{classns3_1_1TcpNewReno_a81686cb1590be6d7c754029fc8d7cf4e}{TcpNewReno} (),
50   \hyperlink{classns3_1_1TcpHybla_a89505ef8588ef3cbe7d19422cd8e1c78}{m\_rho} (1.0),
51   \hyperlink{classns3_1_1TcpHybla_aba2994395c9fa371e2a1cd84b713a157}{m\_minRtt} (\hyperlink{classns3_1_1Time_ad3414eb47d40a34971d5e78db88cfc72}{Time::Max} ()),
52   \hyperlink{classns3_1_1TcpHybla_ac5ab21faceb85b6e6038419fd8392d54}{m\_cWndCnt} (0)
53 \{
54   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
55 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+Hybla@{ns3\+::\+Tcp\+Hybla}!Tcp\+Hybla@{Tcp\+Hybla}}
\index{Tcp\+Hybla@{Tcp\+Hybla}!ns3\+::\+Tcp\+Hybla@{ns3\+::\+Tcp\+Hybla}}
\subsubsection[{\texorpdfstring{Tcp\+Hybla(const Tcp\+Hybla \&sock)}{TcpHybla(const TcpHybla &sock)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Tcp\+Hybla\+::\+Tcp\+Hybla (
\begin{DoxyParamCaption}
\item[{const {\bf Tcp\+Hybla} \&}]{sock}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpHybla_ac5f43582228310d30e541c9ead8558fb}{}\label{classns3_1_1TcpHybla_ac5f43582228310d30e541c9ead8558fb}


Copy constructor. 


\begin{DoxyParams}{Parameters}
{\em sock} & the object to copy \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
58   : \hyperlink{classns3_1_1TcpNewReno_a81686cb1590be6d7c754029fc8d7cf4e}{TcpNewReno} (sock),
59   \hyperlink{classns3_1_1TcpHybla_a89505ef8588ef3cbe7d19422cd8e1c78}{m\_rho} (sock.m\_rho),
60   \hyperlink{classns3_1_1TcpHybla_aba2994395c9fa371e2a1cd84b713a157}{m\_minRtt} (sock.m\_minRtt),
61   \hyperlink{classns3_1_1TcpHybla_ac5ab21faceb85b6e6038419fd8392d54}{m\_cWndCnt} (sock.m\_cWndCnt)
62 \{
63   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
64 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+Hybla@{ns3\+::\+Tcp\+Hybla}!````~Tcp\+Hybla@{$\sim$\+Tcp\+Hybla}}
\index{````~Tcp\+Hybla@{$\sim$\+Tcp\+Hybla}!ns3\+::\+Tcp\+Hybla@{ns3\+::\+Tcp\+Hybla}}
\subsubsection[{\texorpdfstring{$\sim$\+Tcp\+Hybla(void)}{~TcpHybla(void)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Tcp\+Hybla\+::$\sim$\+Tcp\+Hybla (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TcpHybla_a79d8b406e07b1b76d318c9849f81ffb1}{}\label{classns3_1_1TcpHybla_a79d8b406e07b1b76d318c9849f81ffb1}

\begin{DoxyCode}
67 \{
68   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
69 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Tcp\+Hybla@{ns3\+::\+Tcp\+Hybla}!Congestion\+Avoidance@{Congestion\+Avoidance}}
\index{Congestion\+Avoidance@{Congestion\+Avoidance}!ns3\+::\+Tcp\+Hybla@{ns3\+::\+Tcp\+Hybla}}
\subsubsection[{\texorpdfstring{Congestion\+Avoidance(\+Ptr$<$ Tcp\+Socket\+State $>$ tcb, uint32\+\_\+t segments\+Acked)}{CongestionAvoidance(Ptr< TcpSocketState > tcb, uint32_t segmentsAcked)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+Hybla\+::\+Congestion\+Avoidance (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Tcp\+Socket\+State} $>$}]{tcb, }
\item[{uint32\+\_\+t}]{segments\+Acked}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1TcpHybla_a10463113be84c3506fe85b5abfe8b186}{}\label{classns3_1_1TcpHybla_a10463113be84c3506fe85b5abfe8b186}


New\+Reno congestion avoidance. 

During congestion avoidance, cwnd is incremented by roughly 1 full-\/sized segment per round-\/trip time (R\+TT).


\begin{DoxyParams}{Parameters}
{\em tcb} & internal congestion state \\
\hline
{\em segments\+Acked} & count of segments acked \\
\hline
\end{DoxyParams}


Reimplemented from \hyperlink{classns3_1_1TcpNewReno_a34a5eec0649a7b485852c74c825e14ba}{ns3\+::\+Tcp\+New\+Reno}.


\begin{DoxyCode}
128 \{
129   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << tcb << segmentsAcked);
130 
131   uint32\_t segCwnd;
132   \textcolor{keywordtype}{double} \hyperlink{mmwave-amc-test2_8cc_ac504dff76b24ab9f15536c51aec9fbbb}{increment};
133 
134   \textcolor{keywordflow}{while} (segmentsAcked > 0)
135     \{
136       \textcolor{comment}{/*}
137 \textcolor{comment}{       * congestion avoidance}
138 \textcolor{comment}{       * INC = RHO^2 / W}
139 \textcolor{comment}{       */}
140       segCwnd = tcb->\hyperlink{classns3_1_1TcpSocketState_ab6dfe309ca53fd3207dcafede75ad12d}{GetCwndInSegments} ();
141       increment = std::pow (\hyperlink{classns3_1_1TcpHybla_a89505ef8588ef3cbe7d19422cd8e1c78}{m\_rho}, 2) / ((double) segCwnd);
142 
143       \hyperlink{classns3_1_1TcpHybla_ac5ab21faceb85b6e6038419fd8392d54}{m\_cWndCnt} += \hyperlink{mmwave-amc-test2_8cc_ac504dff76b24ab9f15536c51aec9fbbb}{increment};
144       segmentsAcked -= 1;
145     \}
146 
147   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TcpHybla_ac5ab21faceb85b6e6038419fd8392d54}{m\_cWndCnt} >= 1.0)
148     \{
149       \textcolor{comment}{// double to int truncates everytime.}
150       uint32\_t inc = (uint32\_t) \hyperlink{classns3_1_1TcpHybla_ac5ab21faceb85b6e6038419fd8392d54}{m\_cWndCnt};
151       \hyperlink{classns3_1_1TcpHybla_ac5ab21faceb85b6e6038419fd8392d54}{m\_cWndCnt} -= inc;
152 
153       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1TcpHybla_ac5ab21faceb85b6e6038419fd8392d54}{m\_cWndCnt} >= 0.0);
154 
155       \textcolor{comment}{/* This leaves space for a tcp pacing implementation; it would be easy}
156 \textcolor{comment}{         to setup a limit on the maximum increment of the cWnd per ACK received.}
157 \textcolor{comment}{         The remaining increment is leaved for the next ACK. */}
158 
159       tcb->\hyperlink{classns3_1_1TcpSocketState_a7cd3d2156a483c1db436097477a0fd7f}{m\_cWnd} += inc * tcb->\hyperlink{classns3_1_1TcpSocketState_a079872f7b0099ef5f3cab4ff47bd2edd}{m\_segmentSize};
160 
161 
162       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"In CongAvoid, updated to cwnd "} << tcb->\hyperlink{classns3_1_1TcpSocketState_a7cd3d2156a483c1db436097477a0fd7f}{m\_cWnd} <<
163                    \textcolor{stringliteral}{" ssthresh "} << tcb->\hyperlink{classns3_1_1TcpSocketState_aec003b6dba9d269bfb1036c7652ffbd6}{m\_ssThresh} <<
164                    \textcolor{stringliteral}{" with an increment of "} << inc * tcb->\hyperlink{classns3_1_1TcpSocketState_a079872f7b0099ef5f3cab4ff47bd2edd}{m\_segmentSize});
165     \}
166 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Tcp\+Hybla@{ns3\+::\+Tcp\+Hybla}!Fork@{Fork}}
\index{Fork@{Fork}!ns3\+::\+Tcp\+Hybla@{ns3\+::\+Tcp\+Hybla}}
\subsubsection[{\texorpdfstring{Fork()}{Fork()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Tcp\+Congestion\+Ops} $>$ ns3\+::\+Tcp\+Hybla\+::\+Fork (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TcpHybla_a43ce1d6a0ee818a29988fdc9f9b1f6bb}{}\label{classns3_1_1TcpHybla_a43ce1d6a0ee818a29988fdc9f9b1f6bb}


Copy the congestion control algorithm across socket. 

\begin{DoxyReturn}{Returns}
a pointer of the copied object 
\end{DoxyReturn}


Reimplemented from \hyperlink{classns3_1_1TcpNewReno_a2606d5fcd01a1eb4d5f4e6beb7a33192}{ns3\+::\+Tcp\+New\+Reno}.


\begin{DoxyCode}
170 \{
171   \textcolor{keywordflow}{return} CopyObject<TcpHybla> (\textcolor{keyword}{this});
172 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+Hybla@{ns3\+::\+Tcp\+Hybla}!Get\+Name@{Get\+Name}}
\index{Get\+Name@{Get\+Name}!ns3\+::\+Tcp\+Hybla@{ns3\+::\+Tcp\+Hybla}}
\subsubsection[{\texorpdfstring{Get\+Name() const }{GetName() const }}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string ns3\+::\+Tcp\+Hybla\+::\+Get\+Name (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TcpHybla_a5f2c0e4bbceebf35436b596effecf1a7}{}\label{classns3_1_1TcpHybla_a5f2c0e4bbceebf35436b596effecf1a7}


Get the name of the congestion control algorithm. 

\begin{DoxyReturn}{Returns}
A string identifying the name 
\end{DoxyReturn}


Reimplemented from \hyperlink{classns3_1_1TcpNewReno_a0ecf92cb36c236c70e0ecaedfff6609e}{ns3\+::\+Tcp\+New\+Reno}.


\begin{DoxyCode}
176 \{
177   \textcolor{keywordflow}{return} \textcolor{stringliteral}{"TcpHybla"};
178 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+Hybla@{ns3\+::\+Tcp\+Hybla}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Tcp\+Hybla@{ns3\+::\+Tcp\+Hybla}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Tcp\+Hybla\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1TcpHybla_ab0713a818be55782fe433232f5cbc412}{}\label{classns3_1_1TcpHybla_ab0713a818be55782fe433232f5cbc412}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
31 \{
32   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::TcpHybla"})
33     .SetParent<\hyperlink{classns3_1_1TcpNewReno_a81686cb1590be6d7c754029fc8d7cf4e}{TcpNewReno}> ()
34     .AddConstructor<TcpHybla> ()
35     .SetGroupName (\textcolor{stringliteral}{"Internet"})
36     .AddAttribute (\textcolor{stringliteral}{"RRTT"}, \textcolor{stringliteral}{"Reference RTT"},
37                    TimeValue (\hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (50)),
38                    MakeTimeAccessor (&\hyperlink{classns3_1_1TcpHybla_a3bde103cdd139def963021b423853d78}{TcpHybla::m\_rRtt}),
39                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
40     .AddTraceSource (\textcolor{stringliteral}{"Rho"},
41                      \textcolor{stringliteral}{"Rho parameter of Hybla"},
42                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1TcpHybla_a89505ef8588ef3cbe7d19422cd8e1c78}{TcpHybla::m\_rho}),
43                      \textcolor{stringliteral}{"ns3::TracedValue::DoubleCallback"})
44   ;
45   \textcolor{keywordflow}{return} tid;
46 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::\+Tcp\+Hybla@{ns3\+::\+Tcp\+Hybla}!Pkts\+Acked@{Pkts\+Acked}}
\index{Pkts\+Acked@{Pkts\+Acked}!ns3\+::\+Tcp\+Hybla@{ns3\+::\+Tcp\+Hybla}}
\subsubsection[{\texorpdfstring{Pkts\+Acked(\+Ptr$<$ Tcp\+Socket\+State $>$ tcb, uint32\+\_\+t segments\+Acked, const Time \&rtt)}{PktsAcked(Ptr< TcpSocketState > tcb, uint32_t segmentsAcked, const Time &rtt)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+Hybla\+::\+Pkts\+Acked (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Tcp\+Socket\+State} $>$}]{tcb, }
\item[{uint32\+\_\+t}]{segments\+Acked, }
\item[{const {\bf Time} \&}]{rtt}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TcpHybla_a23e291ec4fe822d1abd9d1810c961cb8}{}\label{classns3_1_1TcpHybla_a23e291ec4fe822d1abd9d1810c961cb8}


Timing information on received A\+CK. 

The function is called every time an A\+CK is received (only one time also for cumulative A\+C\+Ks) and contains timing information. It is optional (congestion controls can not implement it) and the default implementation does nothing.


\begin{DoxyParams}{Parameters}
{\em tcb} & internal congestion state \\
\hline
{\em segments\+Acked} & count of segments acked \\
\hline
{\em rtt} & last rtt \\
\hline
\end{DoxyParams}


Reimplemented from \hyperlink{classns3_1_1TcpCongestionOps_a76d3ffb7b1a7ba761026e3f94c1f50fa}{ns3\+::\+Tcp\+Congestion\+Ops}.


\begin{DoxyCode}
85 \{
86   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << tcb << segmentsAcked << rtt);
87 
88   \textcolor{keywordflow}{if} (rtt < \hyperlink{classns3_1_1TcpHybla_aba2994395c9fa371e2a1cd84b713a157}{m\_minRtt})
89     \{
90       \hyperlink{classns3_1_1TcpHybla_a95d8b83e64724cd6ee323211a9b2a16f}{RecalcParam} (tcb, rtt);
91       \hyperlink{classns3_1_1TcpHybla_aba2994395c9fa371e2a1cd84b713a157}{m\_minRtt} = rtt;
92       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Updated m\_minRtt="} << \hyperlink{classns3_1_1TcpHybla_aba2994395c9fa371e2a1cd84b713a157}{m\_minRtt});
93     \}
94 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4




Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Tcp\+Hybla@{ns3\+::\+Tcp\+Hybla}!Recalc\+Param@{Recalc\+Param}}
\index{Recalc\+Param@{Recalc\+Param}!ns3\+::\+Tcp\+Hybla@{ns3\+::\+Tcp\+Hybla}}
\subsubsection[{\texorpdfstring{Recalc\+Param(\+Ptr$<$ Tcp\+Socket\+State $>$ tcb, const Time \&rtt)}{RecalcParam(Ptr< TcpSocketState > tcb, const Time &rtt)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+Hybla\+::\+Recalc\+Param (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Tcp\+Socket\+State} $>$}]{tcb, }
\item[{const {\bf Time} \&}]{rtt}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpHybla_a95d8b83e64724cd6ee323211a9b2a16f}{}\label{classns3_1_1TcpHybla_a95d8b83e64724cd6ee323211a9b2a16f}


Recalculate algorithm parameters. 


\begin{DoxyParams}{Parameters}
{\em tcb} & the socket state. \\
\hline
{\em rtt} & the round trip time. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
73 \{
74   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << rtt);
75 
76   \hyperlink{classns3_1_1TcpHybla_a89505ef8588ef3cbe7d19422cd8e1c78}{m\_rho} = \hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{std::max} ((\textcolor{keywordtype}{double}) rtt.GetMilliSeconds () / \hyperlink{classns3_1_1TcpHybla_a3bde103cdd139def963021b423853d78}{m\_rRtt}.
      \hyperlink{classns3_1_1Time_aba3428a8b6c4c8d9014ce44145081f34}{GetMilliSeconds} (), 1.0);
77 
78   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1TcpHybla_a89505ef8588ef3cbe7d19422cd8e1c78}{m\_rho} > 0.0);
79   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Calculated rho="} << \hyperlink{classns3_1_1TcpHybla_a89505ef8588ef3cbe7d19422cd8e1c78}{m\_rho});
80 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6




Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Tcp\+Hybla@{ns3\+::\+Tcp\+Hybla}!Slow\+Start@{Slow\+Start}}
\index{Slow\+Start@{Slow\+Start}!ns3\+::\+Tcp\+Hybla@{ns3\+::\+Tcp\+Hybla}}
\subsubsection[{\texorpdfstring{Slow\+Start(\+Ptr$<$ Tcp\+Socket\+State $>$ tcb, uint32\+\_\+t segments\+Acked)}{SlowStart(Ptr< TcpSocketState > tcb, uint32_t segmentsAcked)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Tcp\+Hybla\+::\+Slow\+Start (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Tcp\+Socket\+State} $>$}]{tcb, }
\item[{uint32\+\_\+t}]{segments\+Acked}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1TcpHybla_a374c804fcaf21e2cd4c51f0ff6003798}{}\label{classns3_1_1TcpHybla_a374c804fcaf21e2cd4c51f0ff6003798}


Tcp New\+Reno slow start algorithm. 

Defined in R\+FC 5681 as

\begin{quote}
During slow start, a T\+CP increments cwnd by at most S\+M\+SS bytes for each A\+CK received that cumulatively acknowledges new data. Slow start ends when cwnd exceeds ssthresh (or, optionally, when it reaches it, as noted above) or when congestion is observed. While traditionally T\+CP implementations have increased cwnd by precisely S\+M\+SS bytes upon receipt of an A\+CK covering new data, we R\+E\+C\+O\+M\+M\+E\+ND that T\+CP implementations increase cwnd, per\+:

cwnd += min (N, S\+M\+SS) (2)

where N is the number of previously unacknowledged bytes acknowledged in the incoming A\+CK. \end{quote}


The ns-\/3 implementation respect the R\+FC definition. Linux does something different\+: \begin{DoxyVerb}u32 tcp_slow_start(struct tcp_sock *tp, u32 acked)
  {
    u32 cwnd = tp->snd_cwnd + acked;

    if (cwnd > tp->snd_ssthresh)
      cwnd = tp->snd_ssthresh + 1;
    acked -= cwnd - tp->snd_cwnd;
    tp->snd_cwnd = min(cwnd, tp->snd_cwnd_clamp);

    return acked;
  }\end{DoxyVerb}


As stated, we want to avoid the case when a cumulative A\+CK increases c\+Wnd more than a segment size, but we keep count of how many segments we have ignored, and return them.


\begin{DoxyParams}{Parameters}
{\em tcb} & internal congestion state \\
\hline
{\em segments\+Acked} & count of segments acked \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of segments not considered for increasing the c\+Wnd 
\end{DoxyReturn}


Reimplemented from \hyperlink{classns3_1_1TcpNewReno_a1cf5fd9585eb3b745727f4f5beae0706}{ns3\+::\+Tcp\+New\+Reno}.


\begin{DoxyCode}
98 \{
99   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << tcb << segmentsAcked);
100 
101   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (tcb->\hyperlink{classns3_1_1TcpSocketState_a7cd3d2156a483c1db436097477a0fd7f}{m\_cWnd} <= tcb->\hyperlink{classns3_1_1TcpSocketState_aec003b6dba9d269bfb1036c7652ffbd6}{m\_ssThresh});
102 
103   \textcolor{keywordflow}{if} (segmentsAcked >= 1)
104     \{
105       \textcolor{comment}{/*}
106 \textcolor{comment}{       * slow start}
107 \textcolor{comment}{       * INC = 2^RHO - 1}
108 \textcolor{comment}{       */}
109 
110       \textcolor{keywordtype}{double} \hyperlink{mmwave-amc-test2_8cc_ac504dff76b24ab9f15536c51aec9fbbb}{increment} = std::pow (2, \hyperlink{classns3_1_1TcpHybla_a89505ef8588ef3cbe7d19422cd8e1c78}{m\_rho}) - 1.0;
111       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Slow start: inc="} << increment);
112 
113       tcb->\hyperlink{classns3_1_1TcpSocketState_a7cd3d2156a483c1db436097477a0fd7f}{m\_cWnd} = \hyperlink{80211b_8c_ac6afabdc09a49a433ee19d8a9486056d}{std::min} (tcb->\hyperlink{classns3_1_1TcpSocketState_a7cd3d2156a483c1db436097477a0fd7f}{m\_cWnd} + (increment * tcb->
      \hyperlink{classns3_1_1TcpSocketState_a079872f7b0099ef5f3cab4ff47bd2edd}{m\_segmentSize}),
114                               tcb->\hyperlink{classns3_1_1TcpSocketState_aec003b6dba9d269bfb1036c7652ffbd6}{m\_ssThresh});
115 
116       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"In SlowStart, updated to cwnd "} << tcb->\hyperlink{classns3_1_1TcpSocketState_a7cd3d2156a483c1db436097477a0fd7f}{m\_cWnd} <<
117                    \textcolor{stringliteral}{" ssthresh "} << tcb->\hyperlink{classns3_1_1TcpSocketState_aec003b6dba9d269bfb1036c7652ffbd6}{m\_ssThresh} <<
118                    \textcolor{stringliteral}{" with an increment of "} << increment * tcb->\hyperlink{classns3_1_1TcpSocketState_a079872f7b0099ef5f3cab4ff47bd2edd}{m\_segmentSize});
119 
120       \textcolor{keywordflow}{return} segmentsAcked - 1;
121     \}
122 
123   \textcolor{keywordflow}{return} 0;
124 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{ns3\+::\+Tcp\+Hybla@{ns3\+::\+Tcp\+Hybla}!m\+\_\+c\+Wnd\+Cnt@{m\+\_\+c\+Wnd\+Cnt}}
\index{m\+\_\+c\+Wnd\+Cnt@{m\+\_\+c\+Wnd\+Cnt}!ns3\+::\+Tcp\+Hybla@{ns3\+::\+Tcp\+Hybla}}
\subsubsection[{\texorpdfstring{m\+\_\+c\+Wnd\+Cnt}{m_cWndCnt}}]{\setlength{\rightskip}{0pt plus 5cm}double ns3\+::\+Tcp\+Hybla\+::m\+\_\+c\+Wnd\+Cnt\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpHybla_ac5ab21faceb85b6e6038419fd8392d54}{}\label{classns3_1_1TcpHybla_ac5ab21faceb85b6e6038419fd8392d54}


c\+Wnd integer-\/to-\/float counter 

\index{ns3\+::\+Tcp\+Hybla@{ns3\+::\+Tcp\+Hybla}!m\+\_\+min\+Rtt@{m\+\_\+min\+Rtt}}
\index{m\+\_\+min\+Rtt@{m\+\_\+min\+Rtt}!ns3\+::\+Tcp\+Hybla@{ns3\+::\+Tcp\+Hybla}}
\subsubsection[{\texorpdfstring{m\+\_\+min\+Rtt}{m_minRtt}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Tcp\+Hybla\+::m\+\_\+min\+Rtt\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpHybla_aba2994395c9fa371e2a1cd84b713a157}{}\label{classns3_1_1TcpHybla_aba2994395c9fa371e2a1cd84b713a157}


Minimum smoothed round trip time value seen. 

\index{ns3\+::\+Tcp\+Hybla@{ns3\+::\+Tcp\+Hybla}!m\+\_\+rho@{m\+\_\+rho}}
\index{m\+\_\+rho@{m\+\_\+rho}!ns3\+::\+Tcp\+Hybla@{ns3\+::\+Tcp\+Hybla}}
\subsubsection[{\texorpdfstring{m\+\_\+rho}{m_rho}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Value}$<$double$>$ ns3\+::\+Tcp\+Hybla\+::m\+\_\+rho\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpHybla_a89505ef8588ef3cbe7d19422cd8e1c78}{}\label{classns3_1_1TcpHybla_a89505ef8588ef3cbe7d19422cd8e1c78}


Rho parameter. 

\index{ns3\+::\+Tcp\+Hybla@{ns3\+::\+Tcp\+Hybla}!m\+\_\+r\+Rtt@{m\+\_\+r\+Rtt}}
\index{m\+\_\+r\+Rtt@{m\+\_\+r\+Rtt}!ns3\+::\+Tcp\+Hybla@{ns3\+::\+Tcp\+Hybla}}
\subsubsection[{\texorpdfstring{m\+\_\+r\+Rtt}{m_rRtt}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Tcp\+Hybla\+::m\+\_\+r\+Rtt\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpHybla_a3bde103cdd139def963021b423853d78}{}\label{classns3_1_1TcpHybla_a3bde103cdd139def963021b423853d78}


Reference R\+TT. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/model/\hyperlink{tcp-hybla_8h}{tcp-\/hybla.\+h}\item 
internet/model/\hyperlink{tcp-hybla_8cc}{tcp-\/hybla.\+cc}\end{DoxyCompactItemize}
