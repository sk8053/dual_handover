\hypertarget{classMyHeader}{}\section{My\+Header Class Reference}
\label{classMyHeader}\index{My\+Header@{My\+Header}}


Inheritance diagram for My\+Header\+:
% FIG 0


Collaboration diagram for My\+Header\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classMyHeader_a5e495ab05c109b1e596936cceabf7048}{My\+Header} ()
\item 
virtual \hyperlink{classMyHeader_a8bf5c38ade8f9f8c07cbacdb808b6ee2}{$\sim$\+My\+Header} ()
\item 
void \hyperlink{classMyHeader_ad431310f2204f150d75717882c2bdb84}{Set\+Data} (uint16\+\_\+t \hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data})
\item 
uint16\+\_\+t \hyperlink{classMyHeader_a84ce206ec1d4c56b0a42b2ae37d74724}{Get\+Data} (void) const 
\item 
virtual \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classMyHeader_a243236ce86e1a2079f507e0cc07018a4}{Get\+Instance\+Type\+Id} (void) const 
\item 
virtual void \hyperlink{classMyHeader_a92aa779c069cafbe408eef00552665dd}{Print} (std\+::ostream \&os) const 
\item 
virtual void \hyperlink{classMyHeader_a975a619818e321e1950a2a541162b56c}{Serialize} (\hyperlink{classns3_1_1Buffer_1_1Iterator}{Buffer\+::\+Iterator} start) const 
\item 
virtual uint32\+\_\+t \hyperlink{classMyHeader_a3db2ab4d7df58086335c0d637bc649ef}{Deserialize} (\hyperlink{classns3_1_1Buffer_1_1Iterator}{Buffer\+::\+Iterator} start)
\item 
virtual uint32\+\_\+t \hyperlink{classMyHeader_aa270edbfeaa8e17bd2042e770a13f802}{Get\+Serialized\+Size} (void) const 
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classMyHeader_a1ccf706f70c2de32bc5e4905a27c945d}{Get\+Type\+Id} (void)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
uint16\+\_\+t \hyperlink{classMyHeader_a1efc48541d85a063277f43179323e97e}{m\+\_\+data}
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Constructor \& Destructor Documentation}
\index{My\+Header@{My\+Header}!My\+Header@{My\+Header}}
\index{My\+Header@{My\+Header}!My\+Header@{My\+Header}}
\subsubsection[{\texorpdfstring{My\+Header()}{MyHeader()}}]{\setlength{\rightskip}{0pt plus 5cm}My\+Header\+::\+My\+Header (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classMyHeader_a5e495ab05c109b1e596936cceabf7048}{}\label{classMyHeader_a5e495ab05c109b1e596936cceabf7048}

\begin{DoxyCode}
32 \{
33   \textcolor{comment}{// we must provide a public default constructor, }
34   \textcolor{comment}{// implicit or explicit, but never private.}
35 \}
\end{DoxyCode}
\index{My\+Header@{My\+Header}!````~My\+Header@{$\sim$\+My\+Header}}
\index{````~My\+Header@{$\sim$\+My\+Header}!My\+Header@{My\+Header}}
\subsubsection[{\texorpdfstring{$\sim$\+My\+Header()}{~MyHeader()}}]{\setlength{\rightskip}{0pt plus 5cm}My\+Header\+::$\sim$\+My\+Header (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classMyHeader_a8bf5c38ade8f9f8c07cbacdb808b6ee2}{}\label{classMyHeader_a8bf5c38ade8f9f8c07cbacdb808b6ee2}

\begin{DoxyCode}
37 \{
38 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{My\+Header@{My\+Header}!Deserialize@{Deserialize}}
\index{Deserialize@{Deserialize}!My\+Header@{My\+Header}}
\subsubsection[{\texorpdfstring{Deserialize(\+Buffer\+::\+Iterator start)}{Deserialize(Buffer::Iterator start)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t My\+Header\+::\+Deserialize (
\begin{DoxyParamCaption}
\item[{{\bf Buffer\+::\+Iterator}}]{start}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classMyHeader_a3db2ab4d7df58086335c0d637bc649ef}{}\label{classMyHeader_a3db2ab4d7df58086335c0d637bc649ef}

\begin{DoxyParams}{Parameters}
{\em start} & an iterator which points to where the header should read from. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of bytes read.
\end{DoxyReturn}
This method is used by Packet\+::\+Remove\+Header to re-\/create a header from the byte buffer of a packet. The data read is expected to match bit-\/for-\/bit the representation of this header in real networks.

Note that data is not actually removed from the buffer to which the iterator points. Both Packet\+::\+Remove\+Header() and Packet\+::\+Peek\+Header() call \hyperlink{classMyHeader_a3db2ab4d7df58086335c0d637bc649ef}{Deserialize()}, but only the Remove\+Header() has additional statements to remove the header bytes from the underlying buffer and associated metadata. 

Implements \hyperlink{classns3_1_1Header_a78be9400bb66b2a8543606f395ef5396}{ns3\+::\+Header}.


\begin{DoxyCode}
78 \{
79   \textcolor{comment}{// we can deserialize two bytes from the start of the buffer.}
80   \textcolor{comment}{// we read them in network byte order and store them}
81   \textcolor{comment}{// in host byte order.}
82   \hyperlink{classMyHeader_a1efc48541d85a063277f43179323e97e}{m\_data} = start.\hyperlink{classns3_1_1Buffer_1_1Iterator_a14d63ac76497032a473d99cc8458608e}{ReadNtohU16} ();
83 
84   \textcolor{comment}{// we return the number of bytes effectively read.}
85   \textcolor{keywordflow}{return} 2;
86 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{My\+Header@{My\+Header}!Get\+Data@{Get\+Data}}
\index{Get\+Data@{Get\+Data}!My\+Header@{My\+Header}}
\subsubsection[{\texorpdfstring{Get\+Data(void) const }{GetData(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t My\+Header\+::\+Get\+Data (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classMyHeader_a84ce206ec1d4c56b0a42b2ae37d74724}{}\label{classMyHeader_a84ce206ec1d4c56b0a42b2ae37d74724}

\begin{DoxyCode}
95 \{
96   \textcolor{keywordflow}{return} \hyperlink{classMyHeader_a1efc48541d85a063277f43179323e97e}{m\_data};
97 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 3


\index{My\+Header@{My\+Header}!Get\+Instance\+Type\+Id@{Get\+Instance\+Type\+Id}}
\index{Get\+Instance\+Type\+Id@{Get\+Instance\+Type\+Id}!My\+Header@{My\+Header}}
\subsubsection[{\texorpdfstring{Get\+Instance\+Type\+Id(void) const }{GetInstanceTypeId(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} My\+Header\+::\+Get\+Instance\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classMyHeader_a243236ce86e1a2079f507e0cc07018a4}{}\label{classMyHeader_a243236ce86e1a2079f507e0cc07018a4}
Get the most derived Type\+Id for this Object.

This method is typically implemented by \hyperlink{classns3_1_1Object_a51e5994fa4b6eae32d719ad69f8fcbf5}{ns3\+::\+Object\+::\+Get\+Instance\+Type\+Id} but some classes which derive from \hyperlink{classns3_1_1ObjectBase}{ns3\+::\+Object\+Base} directly have to implement it themselves.

\begin{DoxyReturn}{Returns}
The Type\+Id associated to the most-\/derived type of this instance. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1ObjectBase_abe5b43a6f5b99a92a4c3122db31f06fb}{ns3\+::\+Object\+Base}.


\begin{DoxyCode}
51 \{
52   \textcolor{keywordflow}{return} \hyperlink{classMyHeader_a1ccf706f70c2de32bc5e4905a27c945d}{GetTypeId} ();
53 \}
\end{DoxyCode}
\index{My\+Header@{My\+Header}!Get\+Serialized\+Size@{Get\+Serialized\+Size}}
\index{Get\+Serialized\+Size@{Get\+Serialized\+Size}!My\+Header@{My\+Header}}
\subsubsection[{\texorpdfstring{Get\+Serialized\+Size(void) const }{GetSerializedSize(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t My\+Header\+::\+Get\+Serialized\+Size (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classMyHeader_aa270edbfeaa8e17bd2042e770a13f802}{}\label{classMyHeader_aa270edbfeaa8e17bd2042e770a13f802}
\begin{DoxyReturn}{Returns}
the expected size of the header.
\end{DoxyReturn}
This method is used by Packet\+::\+Add\+Header to store a header into the byte buffer of a packet. This method should return the number of bytes which are needed to store the full header data by Serialize. 

Implements \hyperlink{classns3_1_1Header_a6ef0497eabc1b1fb0ad42738eb73f934}{ns3\+::\+Header}.


\begin{DoxyCode}
65 \{
66   \textcolor{comment}{// we reserve 2 bytes for our header.}
67   \textcolor{keywordflow}{return} 2;
68 \}
\end{DoxyCode}
\index{My\+Header@{My\+Header}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!My\+Header@{My\+Header}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} My\+Header\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classMyHeader_a1ccf706f70c2de32bc5e4905a27c945d}{}\label{classMyHeader_a1ccf706f70c2de32bc5e4905a27c945d}

\begin{DoxyCode}
42 \{
43   \textcolor{keyword}{static} \hyperlink{classns3_1_1TypeId}{TypeId} tid = \hyperlink{classns3_1_1TypeId}{TypeId} (\textcolor{stringliteral}{"ns3::MyHeader"})
44     .\hyperlink{classns3_1_1TypeId_abaaca67ab7d2471067e7c275df0f7309}{SetParent}<\hyperlink{classns3_1_1Header}{Header}> ()
45     .AddConstructor<MyHeader> ()
46   ;
47   \textcolor{keywordflow}{return} tid;
48 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4


\index{My\+Header@{My\+Header}!Print@{Print}}
\index{Print@{Print}!My\+Header@{My\+Header}}
\subsubsection[{\texorpdfstring{Print(std\+::ostream \&os) const }{Print(std::ostream &os) const }}]{\setlength{\rightskip}{0pt plus 5cm}void My\+Header\+::\+Print (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classMyHeader_a92aa779c069cafbe408eef00552665dd}{}\label{classMyHeader_a92aa779c069cafbe408eef00552665dd}

\begin{DoxyParams}{Parameters}
{\em os} & output stream This method is used by Packet\+::\+Print to print the content of a header as ascii data to a c++ output stream. Although the header is free to format its output as it wishes, it is recommended to follow a few rules to integrate with the packet pretty printer\+: start with flags, small field values located between a pair of parens. Values should be separated by whitespace. Follow the parens with the important fields, separated by whitespace. i.\+e.\+: (field1 val1 field2 val2 field3 val3) field4 val4 field5 val5 \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Header_a2ce1df7579b2ade7bc7302357feac77a}{ns3\+::\+Header}.


\begin{DoxyCode}
57 \{
58   \textcolor{comment}{// This method is invoked by the packet printing}
59   \textcolor{comment}{// routines to print the content of my header.}
60   \textcolor{comment}{//os << "data=" << m\_data << std::endl;}
61   os << \textcolor{stringliteral}{"data="} << \hyperlink{classMyHeader_a1efc48541d85a063277f43179323e97e}{m\_data};
62 \}
\end{DoxyCode}
\index{My\+Header@{My\+Header}!Serialize@{Serialize}}
\index{Serialize@{Serialize}!My\+Header@{My\+Header}}
\subsubsection[{\texorpdfstring{Serialize(\+Buffer\+::\+Iterator start) const }{Serialize(Buffer::Iterator start) const }}]{\setlength{\rightskip}{0pt plus 5cm}void My\+Header\+::\+Serialize (
\begin{DoxyParamCaption}
\item[{{\bf Buffer\+::\+Iterator}}]{start}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classMyHeader_a975a619818e321e1950a2a541162b56c}{}\label{classMyHeader_a975a619818e321e1950a2a541162b56c}

\begin{DoxyParams}{Parameters}
{\em start} & an iterator which points to where the header should be written.\\
\hline
\end{DoxyParams}
This method is used by Packet\+::\+Add\+Header to store a header into the byte buffer of a packet. The data written is expected to match bit-\/for-\/bit the representation of this header in a real network. 

Implements \hyperlink{classns3_1_1Header_afb61f1aac69ff8349a6bfe521fab5404}{ns3\+::\+Header}.


\begin{DoxyCode}
71 \{
72   \textcolor{comment}{// we can serialize two bytes at the start of the buffer.}
73   \textcolor{comment}{// we write them in network byte order.}
74   start.\hyperlink{classns3_1_1Buffer_1_1Iterator_a97ea9c86cfe87b516efc28faa7dfdf21}{WriteHtonU16} (\hyperlink{classMyHeader_a1efc48541d85a063277f43179323e97e}{m\_data});
75 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5


\index{My\+Header@{My\+Header}!Set\+Data@{Set\+Data}}
\index{Set\+Data@{Set\+Data}!My\+Header@{My\+Header}}
\subsubsection[{\texorpdfstring{Set\+Data(uint16\+\_\+t data)}{SetData(uint16_t data)}}]{\setlength{\rightskip}{0pt plus 5cm}void My\+Header\+::\+Set\+Data (
\begin{DoxyParamCaption}
\item[{uint16\+\_\+t}]{data}
\end{DoxyParamCaption}
)}\hypertarget{classMyHeader_ad431310f2204f150d75717882c2bdb84}{}\label{classMyHeader_ad431310f2204f150d75717882c2bdb84}

\begin{DoxyCode}
90 \{
91   \hyperlink{classMyHeader_a1efc48541d85a063277f43179323e97e}{m\_data} = \hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data};
92 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 6




\subsection{Member Data Documentation}
\index{My\+Header@{My\+Header}!m\+\_\+data@{m\+\_\+data}}
\index{m\+\_\+data@{m\+\_\+data}!My\+Header@{My\+Header}}
\subsubsection[{\texorpdfstring{m\+\_\+data}{m_data}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t My\+Header\+::m\+\_\+data\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classMyHeader_a1efc48541d85a063277f43179323e97e}{}\label{classMyHeader_a1efc48541d85a063277f43179323e97e}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
network/examples/\hyperlink{main-packet-header_8cc}{main-\/packet-\/header.\+cc}\end{DoxyCompactItemize}
