\hypertarget{classns3_1_1Ipv4GlobalRouting}{}\section{ns3\+:\+:Ipv4\+Global\+Routing Class Reference}
\label{classns3_1_1Ipv4GlobalRouting}\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}


Global routing protocol for I\+Pv4 stacks.  




{\ttfamily \#include $<$ipv4-\/global-\/routing.\+h$>$}



Inheritance diagram for ns3\+:\+:Ipv4\+Global\+Routing\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Ipv4\+Global\+Routing\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ipv4GlobalRouting_a7cefb1b7e138c5756e3bda9de707f756}{Ipv4\+Global\+Routing} ()
\begin{DoxyCompactList}\small\item\em Construct an empty \hyperlink{classns3_1_1Ipv4GlobalRouting}{Ipv4\+Global\+Routing} routing protocol,. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ipv4GlobalRouting_ac7fa4fb9540f1be32954a0226b24e2f2}{$\sim$\+Ipv4\+Global\+Routing} ()
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ \hyperlink{classns3_1_1Ipv4GlobalRouting_a569e54ce6542c3b88305140cce134d15}{Route\+Output} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ oif, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket\+::\+Socket\+Errno} \&sockerr)
\begin{DoxyCompactList}\small\item\em Query routing cache for an existing route, for an outbound packet. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1Ipv4GlobalRouting_a2d027555864ab2f6a9f028f38a65a8e7}{Route\+Input} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ idev, \hyperlink{classns3_1_1Ipv4RoutingProtocol_a3453a85764cbbb1e704da7e919aa5d19}{Unicast\+Forward\+Callback} ucb, \hyperlink{classns3_1_1Ipv4RoutingProtocol_a26e76f7a555462e6c08fceda64a99d58}{Multicast\+Forward\+Callback} mcb, \hyperlink{classns3_1_1Ipv4RoutingProtocol_aa6ffa0159cb143daa3c46d2ba69bb1b9}{Local\+Deliver\+Callback} lcb, \hyperlink{classns3_1_1Ipv4RoutingProtocol_a0348285418c30d5021b08f7a68af21ea}{Error\+Callback} ecb)
\begin{DoxyCompactList}\small\item\em Route an input packet (to be forwarded or locally delivered) \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv4GlobalRouting_af4068bd0482d47a34ceb857ba2137c97}{Notify\+Interface\+Up} (uint32\+\_\+t interface)
\item 
virtual void \hyperlink{classns3_1_1Ipv4GlobalRouting_a15eb3f2522504b90c7fb28412040e1ff}{Notify\+Interface\+Down} (uint32\+\_\+t interface)
\item 
virtual void \hyperlink{classns3_1_1Ipv4GlobalRouting_a500c6e43cbf90b83b9582d3dc029ede0}{Notify\+Add\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} address)
\item 
virtual void \hyperlink{classns3_1_1Ipv4GlobalRouting_a2fe404417aaa31ac52fe87817075e612}{Notify\+Remove\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} address)
\item 
virtual void \hyperlink{classns3_1_1Ipv4GlobalRouting_a48499c4690b5699fd12aade2e236f214}{Set\+Ipv4} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$ ipv4)
\item 
virtual void \hyperlink{classns3_1_1Ipv4GlobalRouting_aa8be09f66df028d8c3832c1c0da25a7b}{Print\+Routing\+Table} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream, \hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295a}{Time\+::\+Unit} unit=\hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295aade8622b06524a328cd3a59db6ccf76af}{Time\+::S}) const 
\begin{DoxyCompactList}\small\item\em Print the Routing Table entries. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4GlobalRouting_a10009a3ac337496cdef0260ad5b5c106}{Add\+Host\+Route\+To} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} dest, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} next\+Hop, uint32\+\_\+t interface)
\begin{DoxyCompactList}\small\item\em Add a host route to the global routing table. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4GlobalRouting_a17caf38d32c60d9207e78abb9344d366}{Add\+Host\+Route\+To} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} dest, uint32\+\_\+t interface)
\begin{DoxyCompactList}\small\item\em Add a host route to the global routing table. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4GlobalRouting_aa4a606c4c390acd2127c216a9b1d24d4}{Add\+Network\+Route\+To} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} network, \hyperlink{classns3_1_1Ipv4Mask}{Ipv4\+Mask} network\+Mask, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} next\+Hop, uint32\+\_\+t interface)
\begin{DoxyCompactList}\small\item\em Add a network route to the global routing table. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4GlobalRouting_af399f1eef7e7e3dcca122cb8cade0574}{Add\+Network\+Route\+To} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} network, \hyperlink{classns3_1_1Ipv4Mask}{Ipv4\+Mask} network\+Mask, uint32\+\_\+t interface)
\begin{DoxyCompactList}\small\item\em Add a network route to the global routing table. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4GlobalRouting_a1707024a710d982149a18db9725a771d}{Add\+A\+S\+External\+Route\+To} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} network, \hyperlink{classns3_1_1Ipv4Mask}{Ipv4\+Mask} network\+Mask, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} next\+Hop, uint32\+\_\+t interface)
\begin{DoxyCompactList}\small\item\em Add an external route to the global routing table. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1Ipv4GlobalRouting_abb9d2b3642272b9bd2697a5699922fa7}{Get\+N\+Routes} (void) const 
\begin{DoxyCompactList}\small\item\em Get the number of individual unicast routes that have been added to the routing table. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} $\ast$ \hyperlink{classns3_1_1Ipv4GlobalRouting_accd518b9888908dbea189c1d1c73dcf1}{Get\+Route} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) const 
\begin{DoxyCompactList}\small\item\em Get a route from the global unicast routing table. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4GlobalRouting_a406d6a56f246ef9c105a6ad5da4d7ffb}{Remove\+Route} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
\begin{DoxyCompactList}\small\item\em Remove a route from the global unicast routing table. \end{DoxyCompactList}\item 
int64\+\_\+t \hyperlink{classns3_1_1Ipv4GlobalRouting_a392bf55dd79428567bd027c64af0c8be}{Assign\+Streams} (int64\+\_\+t stream)
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1Ipv4GlobalRouting_ae32c45a7d6f10a4501d4d59c51f872ae}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classns3_1_1Ipv4GlobalRouting_a3ed00382c689954195ea0ac02531d1ea}{Do\+Dispose} (void)
\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} $\ast$ $>$ \hyperlink{classns3_1_1Ipv4GlobalRouting_a08b1b12aa1fb8d95b67cefc785f0a235}{Host\+Routes}
\begin{DoxyCompactList}\small\item\em container of \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} (routes to hosts) \end{DoxyCompactList}\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} $\ast$ $>$\+::const\+\_\+iterator \hyperlink{classns3_1_1Ipv4GlobalRouting_aae0bc92477a22c30a84d24b7059feba3}{Host\+Routes\+CI}
\begin{DoxyCompactList}\small\item\em const iterator of container of \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} (routes to hosts) \end{DoxyCompactList}\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} $\ast$ $>$\+::iterator \hyperlink{classns3_1_1Ipv4GlobalRouting_a4a3de9839580400d39d5bac0b0d33308}{Host\+RoutesI}
\begin{DoxyCompactList}\small\item\em iterator of container of \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} (routes to hosts) \end{DoxyCompactList}\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} $\ast$ $>$ \hyperlink{classns3_1_1Ipv4GlobalRouting_ab63c3f6778a619bb464078d9ee0112e9}{Network\+Routes}
\begin{DoxyCompactList}\small\item\em container of \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} (routes to networks) \end{DoxyCompactList}\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} $\ast$ $>$\+::const\+\_\+iterator \hyperlink{classns3_1_1Ipv4GlobalRouting_a951edfd8275e2329a7fd4c5f00ac420e}{Network\+Routes\+CI}
\begin{DoxyCompactList}\small\item\em const iterator of container of \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} (routes to networks) \end{DoxyCompactList}\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} $\ast$ $>$\+::iterator \hyperlink{classns3_1_1Ipv4GlobalRouting_a52c6db3cff38f2600555615bb9840ca5}{Network\+RoutesI}
\begin{DoxyCompactList}\small\item\em iterator of container of \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} (routes to networks) \end{DoxyCompactList}\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} $\ast$ $>$ \hyperlink{classns3_1_1Ipv4GlobalRouting_a1227a5732cb954fe1a2255b7799ba296}{A\+S\+External\+Routes}
\begin{DoxyCompactList}\small\item\em container of \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} (routes to external AS) \end{DoxyCompactList}\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} $\ast$ $>$\+::const\+\_\+iterator \hyperlink{classns3_1_1Ipv4GlobalRouting_aabafd3cfb22a4cc8f84b166a97b88c57}{A\+S\+External\+Routes\+CI}
\begin{DoxyCompactList}\small\item\em const iterator of container of \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} (routes to external AS) \end{DoxyCompactList}\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} $\ast$ $>$\+::iterator \hyperlink{classns3_1_1Ipv4GlobalRouting_a2f2e1f2c8d631cfd016343f993cf577b}{A\+S\+External\+RoutesI}
\begin{DoxyCompactList}\small\item\em iterator of container of \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} (routes to external AS) \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ \hyperlink{classns3_1_1Ipv4GlobalRouting_a647d7654f270ce66e46f26fc729f1d07}{Lookup\+Global} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} dest, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ oif=0)
\begin{DoxyCompactList}\small\item\em Lookup in the forwarding table for destination. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classns3_1_1Ipv4GlobalRouting_aecf81bc1f0bdbb4fff3fa7c56e4707a4}{m\+\_\+random\+Ecmp\+Routing}
\begin{DoxyCompactList}\small\item\em Set to true if packets are randomly routed among E\+C\+MP; set to false for using only one route consistently. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Ipv4GlobalRouting_ae346dbd5b2a06c03df13c1a3987e4719}{m\+\_\+respond\+To\+Interface\+Events}
\begin{DoxyCompactList}\small\item\em Set to true if this interface should respond to interface events by globallly recomputing routes. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UniformRandomVariable}{Uniform\+Random\+Variable} $>$ \hyperlink{classns3_1_1Ipv4GlobalRouting_a3cc74017538737dc3f6ec7f511a3481e}{m\+\_\+rand}
\begin{DoxyCompactList}\small\item\em A uniform random number generator for randomly routing packets among E\+C\+MP. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4GlobalRouting_a08b1b12aa1fb8d95b67cefc785f0a235}{Host\+Routes} \hyperlink{classns3_1_1Ipv4GlobalRouting_adcef09fc8af430a93c9437edfc22511c}{m\+\_\+host\+Routes}
\begin{DoxyCompactList}\small\item\em Routes to hosts. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4GlobalRouting_ab63c3f6778a619bb464078d9ee0112e9}{Network\+Routes} \hyperlink{classns3_1_1Ipv4GlobalRouting_aef3903663955f6f9a411be06752f3976}{m\+\_\+network\+Routes}
\begin{DoxyCompactList}\small\item\em Routes to networks. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4GlobalRouting_a1227a5732cb954fe1a2255b7799ba296}{A\+S\+External\+Routes} \hyperlink{classns3_1_1Ipv4GlobalRouting_ad34f23b0d519a9603b6d9225185fc5ad}{m\+\_\+\+A\+Sexternal\+Routes}
\begin{DoxyCompactList}\small\item\em External routes imported. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$ \hyperlink{classns3_1_1Ipv4GlobalRouting_a8ca97d33982a32fa41a98b56dbec2edc}{m\+\_\+ipv4}
\begin{DoxyCompactList}\small\item\em associated I\+Pv4 instance \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Global routing protocol for I\+Pv4 stacks. 

In ns-\/3 we have the concept of a pluggable routing protocol. Routing protocols are added to a list maintained by the \hyperlink{classns3_1_1Ipv4L3Protocol}{Ipv4\+L3\+Protocol}. Every stack gets one routing protocol for free -- the \hyperlink{classns3_1_1Ipv4StaticRouting}{Ipv4\+Static\+Routing} routing protocol is added in the constructor of the \hyperlink{classns3_1_1Ipv4L3Protocol}{Ipv4\+L3\+Protocol} (this is the piece of code that implements the functionality of the IP layer).

As an option to running a dynamic routing protocol, a \hyperlink{classns3_1_1GlobalRouteManager}{Global\+Route\+Manager} object has been created to allow users to build routes for all participating nodes. One can think of this object as a \char`\"{}routing oracle\char`\"{}; it has an omniscient view of the topology, and can construct shortest path routes between all pairs of nodes. These routes must be stored somewhere in the node, so therefore this class \hyperlink{classns3_1_1Ipv4GlobalRouting}{Ipv4\+Global\+Routing} is used as one of the pluggable routing protocols. It is kept distinct from \hyperlink{classns3_1_1Ipv4StaticRouting}{Ipv4\+Static\+Routing} because these routes may be dynamically cleared and rebuilt in the middle of the simulation, while manually entered routes into the \hyperlink{classns3_1_1Ipv4StaticRouting}{Ipv4\+Static\+Routing} may need to be kept distinct.

This class deals with \hyperlink{classns3_1_1Ipv4}{Ipv4} unicast routes only.

\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} 

\hyperlink{classns3_1_1GlobalRouteManager}{Global\+Route\+Manager} 
\end{DoxySeeAlso}


\subsection{Member Typedef Documentation}
\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!A\+S\+External\+Routes@{A\+S\+External\+Routes}}
\index{A\+S\+External\+Routes@{A\+S\+External\+Routes}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{A\+S\+External\+Routes}{ASExternalRoutes}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Ipv4\+Routing\+Table\+Entry} $\ast$$>$ {\bf ns3\+::\+Ipv4\+Global\+Routing\+::\+A\+S\+External\+Routes}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4GlobalRouting_a1227a5732cb954fe1a2255b7799ba296}{}\label{classns3_1_1Ipv4GlobalRouting_a1227a5732cb954fe1a2255b7799ba296}


container of \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} (routes to external AS) 

\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!A\+S\+External\+Routes\+CI@{A\+S\+External\+Routes\+CI}}
\index{A\+S\+External\+Routes\+CI@{A\+S\+External\+Routes\+CI}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{A\+S\+External\+Routes\+CI}{ASExternalRoutesCI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Ipv4\+Routing\+Table\+Entry} $\ast$$>$\+::const\+\_\+iterator {\bf ns3\+::\+Ipv4\+Global\+Routing\+::\+A\+S\+External\+Routes\+CI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4GlobalRouting_aabafd3cfb22a4cc8f84b166a97b88c57}{}\label{classns3_1_1Ipv4GlobalRouting_aabafd3cfb22a4cc8f84b166a97b88c57}


const iterator of container of \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} (routes to external AS) 

\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!A\+S\+External\+RoutesI@{A\+S\+External\+RoutesI}}
\index{A\+S\+External\+RoutesI@{A\+S\+External\+RoutesI}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{A\+S\+External\+RoutesI}{ASExternalRoutesI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Ipv4\+Routing\+Table\+Entry} $\ast$$>$\+::iterator {\bf ns3\+::\+Ipv4\+Global\+Routing\+::\+A\+S\+External\+RoutesI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4GlobalRouting_a2f2e1f2c8d631cfd016343f993cf577b}{}\label{classns3_1_1Ipv4GlobalRouting_a2f2e1f2c8d631cfd016343f993cf577b}


iterator of container of \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} (routes to external AS) 

\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!Host\+Routes@{Host\+Routes}}
\index{Host\+Routes@{Host\+Routes}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{Host\+Routes}{HostRoutes}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Ipv4\+Routing\+Table\+Entry} $\ast$$>$ {\bf ns3\+::\+Ipv4\+Global\+Routing\+::\+Host\+Routes}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4GlobalRouting_a08b1b12aa1fb8d95b67cefc785f0a235}{}\label{classns3_1_1Ipv4GlobalRouting_a08b1b12aa1fb8d95b67cefc785f0a235}


container of \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} (routes to hosts) 

\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!Host\+Routes\+CI@{Host\+Routes\+CI}}
\index{Host\+Routes\+CI@{Host\+Routes\+CI}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{Host\+Routes\+CI}{HostRoutesCI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Ipv4\+Routing\+Table\+Entry} $\ast$$>$\+::const\+\_\+iterator {\bf ns3\+::\+Ipv4\+Global\+Routing\+::\+Host\+Routes\+CI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4GlobalRouting_aae0bc92477a22c30a84d24b7059feba3}{}\label{classns3_1_1Ipv4GlobalRouting_aae0bc92477a22c30a84d24b7059feba3}


const iterator of container of \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} (routes to hosts) 

\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!Host\+RoutesI@{Host\+RoutesI}}
\index{Host\+RoutesI@{Host\+RoutesI}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{Host\+RoutesI}{HostRoutesI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Ipv4\+Routing\+Table\+Entry} $\ast$$>$\+::iterator {\bf ns3\+::\+Ipv4\+Global\+Routing\+::\+Host\+RoutesI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4GlobalRouting_a4a3de9839580400d39d5bac0b0d33308}{}\label{classns3_1_1Ipv4GlobalRouting_a4a3de9839580400d39d5bac0b0d33308}


iterator of container of \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} (routes to hosts) 

\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!Network\+Routes@{Network\+Routes}}
\index{Network\+Routes@{Network\+Routes}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{Network\+Routes}{NetworkRoutes}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Ipv4\+Routing\+Table\+Entry} $\ast$$>$ {\bf ns3\+::\+Ipv4\+Global\+Routing\+::\+Network\+Routes}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4GlobalRouting_ab63c3f6778a619bb464078d9ee0112e9}{}\label{classns3_1_1Ipv4GlobalRouting_ab63c3f6778a619bb464078d9ee0112e9}


container of \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} (routes to networks) 

\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!Network\+Routes\+CI@{Network\+Routes\+CI}}
\index{Network\+Routes\+CI@{Network\+Routes\+CI}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{Network\+Routes\+CI}{NetworkRoutesCI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Ipv4\+Routing\+Table\+Entry} $\ast$$>$\+::const\+\_\+iterator {\bf ns3\+::\+Ipv4\+Global\+Routing\+::\+Network\+Routes\+CI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4GlobalRouting_a951edfd8275e2329a7fd4c5f00ac420e}{}\label{classns3_1_1Ipv4GlobalRouting_a951edfd8275e2329a7fd4c5f00ac420e}


const iterator of container of \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} (routes to networks) 

\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!Network\+RoutesI@{Network\+RoutesI}}
\index{Network\+RoutesI@{Network\+RoutesI}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{Network\+RoutesI}{NetworkRoutesI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Ipv4\+Routing\+Table\+Entry} $\ast$$>$\+::iterator {\bf ns3\+::\+Ipv4\+Global\+Routing\+::\+Network\+RoutesI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4GlobalRouting_a52c6db3cff38f2600555615bb9840ca5}{}\label{classns3_1_1Ipv4GlobalRouting_a52c6db3cff38f2600555615bb9840ca5}


iterator of container of \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} (routes to networks) 



\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!Ipv4\+Global\+Routing@{Ipv4\+Global\+Routing}}
\index{Ipv4\+Global\+Routing@{Ipv4\+Global\+Routing}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{Ipv4\+Global\+Routing()}{Ipv4GlobalRouting()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv4\+Global\+Routing\+::\+Ipv4\+Global\+Routing (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4GlobalRouting_a7cefb1b7e138c5756e3bda9de707f756}{}\label{classns3_1_1Ipv4GlobalRouting_a7cefb1b7e138c5756e3bda9de707f756}


Construct an empty \hyperlink{classns3_1_1Ipv4GlobalRouting}{Ipv4\+Global\+Routing} routing protocol,. 

The \hyperlink{classns3_1_1Ipv4GlobalRouting}{Ipv4\+Global\+Routing} class supports host and network unicast routes. This method initializes the lists containing these routes to empty.

\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Ipv4GlobalRouting}{Ipv4\+Global\+Routing} 
\end{DoxySeeAlso}

\begin{DoxyCode}
61   : \hyperlink{classns3_1_1Ipv4GlobalRouting_aecf81bc1f0bdbb4fff3fa7c56e4707a4}{m\_randomEcmpRouting} (\textcolor{keyword}{false}),
62     \hyperlink{classns3_1_1Ipv4GlobalRouting_ae346dbd5b2a06c03df13c1a3987e4719}{m\_respondToInterfaceEvents} (\textcolor{keyword}{false})
63 \{
64   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
65 
66   \hyperlink{classns3_1_1Ipv4GlobalRouting_a3cc74017538737dc3f6ec7f511a3481e}{m\_rand} = CreateObject<UniformRandomVariable> ();
67 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!````~Ipv4\+Global\+Routing@{$\sim$\+Ipv4\+Global\+Routing}}
\index{````~Ipv4\+Global\+Routing@{$\sim$\+Ipv4\+Global\+Routing}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{$\sim$\+Ipv4\+Global\+Routing()}{~Ipv4GlobalRouting()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv4\+Global\+Routing\+::$\sim$\+Ipv4\+Global\+Routing (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4GlobalRouting_ac7fa4fb9540f1be32954a0226b24e2f2}{}\label{classns3_1_1Ipv4GlobalRouting_ac7fa4fb9540f1be32954a0226b24e2f2}

\begin{DoxyCode}
70 \{
71   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
72 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!Add\+A\+S\+External\+Route\+To@{Add\+A\+S\+External\+Route\+To}}
\index{Add\+A\+S\+External\+Route\+To@{Add\+A\+S\+External\+Route\+To}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{Add\+A\+S\+External\+Route\+To(\+Ipv4\+Address network, Ipv4\+Mask network\+Mask, Ipv4\+Address next\+Hop, uint32\+\_\+t interface)}{AddASExternalRouteTo(Ipv4Address network, Ipv4Mask networkMask, Ipv4Address nextHop, uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Global\+Routing\+::\+Add\+A\+S\+External\+Route\+To (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{network, }
\item[{{\bf Ipv4\+Mask}}]{network\+Mask, }
\item[{{\bf Ipv4\+Address}}]{next\+Hop, }
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4GlobalRouting_a1707024a710d982149a18db9725a771d}{}\label{classns3_1_1Ipv4GlobalRouting_a1707024a710d982149a18db9725a771d}


Add an external route to the global routing table. 


\begin{DoxyParams}{Parameters}
{\em network} & The \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} network for this route. \\
\hline
{\em network\+Mask} & The \hyperlink{classns3_1_1Ipv4Mask}{Ipv4\+Mask} to extract the network. \\
\hline
{\em next\+Hop} & The next hop \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \\
\hline
{\em interface} & The network interface index used to send packets to the destination. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
128 \{
129   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << network << networkMask << nextHop << interface);
130   Ipv4RoutingTableEntry *route = \textcolor{keyword}{new} Ipv4RoutingTableEntry ();
131   *route = \hyperlink{classns3_1_1Ipv4RoutingTableEntry_abe3447a00495ded05ab095673531947a}{Ipv4RoutingTableEntry::CreateNetworkRouteTo} (network,
132                                                         networkMask,
133                                                         nextHop,
134                                                         interface);
135   \hyperlink{classns3_1_1Ipv4GlobalRouting_ad34f23b0d519a9603b6d9225185fc5ad}{m\_ASexternalRoutes}.push\_back (route);
136 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!Add\+Host\+Route\+To@{Add\+Host\+Route\+To}}
\index{Add\+Host\+Route\+To@{Add\+Host\+Route\+To}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{Add\+Host\+Route\+To(\+Ipv4\+Address dest, Ipv4\+Address next\+Hop, uint32\+\_\+t interface)}{AddHostRouteTo(Ipv4Address dest, Ipv4Address nextHop, uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Global\+Routing\+::\+Add\+Host\+Route\+To (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{dest, }
\item[{{\bf Ipv4\+Address}}]{next\+Hop, }
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4GlobalRouting_a10009a3ac337496cdef0260ad5b5c106}{}\label{classns3_1_1Ipv4GlobalRouting_a10009a3ac337496cdef0260ad5b5c106}


Add a host route to the global routing table. 


\begin{DoxyParams}{Parameters}
{\em dest} & The \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} destination for this route. \\
\hline
{\em next\+Hop} & The \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} of the next hop in the route. \\
\hline
{\em interface} & The network interface index used to send packets to the destination.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} 
\end{DoxySeeAlso}

\begin{DoxyCode}
78 \{
79   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << dest << nextHop << interface);
80   Ipv4RoutingTableEntry *route = \textcolor{keyword}{new} Ipv4RoutingTableEntry ();
81   *route = \hyperlink{classns3_1_1Ipv4RoutingTableEntry_ac19037fbc291dfb873a5a7792d3329be}{Ipv4RoutingTableEntry::CreateHostRouteTo} (dest, nextHop,
       interface);
82   \hyperlink{classns3_1_1Ipv4GlobalRouting_adcef09fc8af430a93c9437edfc22511c}{m\_hostRoutes}.push\_back (route);
83 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!Add\+Host\+Route\+To@{Add\+Host\+Route\+To}}
\index{Add\+Host\+Route\+To@{Add\+Host\+Route\+To}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{Add\+Host\+Route\+To(\+Ipv4\+Address dest, uint32\+\_\+t interface)}{AddHostRouteTo(Ipv4Address dest, uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Global\+Routing\+::\+Add\+Host\+Route\+To (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{dest, }
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4GlobalRouting_a17caf38d32c60d9207e78abb9344d366}{}\label{classns3_1_1Ipv4GlobalRouting_a17caf38d32c60d9207e78abb9344d366}


Add a host route to the global routing table. 


\begin{DoxyParams}{Parameters}
{\em dest} & The \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} destination for this route. \\
\hline
{\em interface} & The network interface index used to send packets to the destination.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} 
\end{DoxySeeAlso}

\begin{DoxyCode}
88 \{
89   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << dest << interface);
90   Ipv4RoutingTableEntry *route = \textcolor{keyword}{new} Ipv4RoutingTableEntry ();
91   *route = \hyperlink{classns3_1_1Ipv4RoutingTableEntry_ac19037fbc291dfb873a5a7792d3329be}{Ipv4RoutingTableEntry::CreateHostRouteTo} (dest, 
      interface);
92   \hyperlink{classns3_1_1Ipv4GlobalRouting_adcef09fc8af430a93c9437edfc22511c}{m\_hostRoutes}.push\_back (route);
93 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4


\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!Add\+Network\+Route\+To@{Add\+Network\+Route\+To}}
\index{Add\+Network\+Route\+To@{Add\+Network\+Route\+To}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{Add\+Network\+Route\+To(\+Ipv4\+Address network, Ipv4\+Mask network\+Mask, Ipv4\+Address next\+Hop, uint32\+\_\+t interface)}{AddNetworkRouteTo(Ipv4Address network, Ipv4Mask networkMask, Ipv4Address nextHop, uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Global\+Routing\+::\+Add\+Network\+Route\+To (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{network, }
\item[{{\bf Ipv4\+Mask}}]{network\+Mask, }
\item[{{\bf Ipv4\+Address}}]{next\+Hop, }
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4GlobalRouting_aa4a606c4c390acd2127c216a9b1d24d4}{}\label{classns3_1_1Ipv4GlobalRouting_aa4a606c4c390acd2127c216a9b1d24d4}


Add a network route to the global routing table. 


\begin{DoxyParams}{Parameters}
{\em network} & The \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} network for this route. \\
\hline
{\em network\+Mask} & The \hyperlink{classns3_1_1Ipv4Mask}{Ipv4\+Mask} to extract the network. \\
\hline
{\em next\+Hop} & The next hop in the route to the destination network. \\
\hline
{\em interface} & The network interface index used to send packets to the destination.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} 
\end{DoxySeeAlso}

\begin{DoxyCode}
100 \{
101   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << network << networkMask << nextHop << interface);
102   Ipv4RoutingTableEntry *route = \textcolor{keyword}{new} Ipv4RoutingTableEntry ();
103   *route = \hyperlink{classns3_1_1Ipv4RoutingTableEntry_abe3447a00495ded05ab095673531947a}{Ipv4RoutingTableEntry::CreateNetworkRouteTo} (network,
104                                                         networkMask,
105                                                         nextHop,
106                                                         interface);
107   \hyperlink{classns3_1_1Ipv4GlobalRouting_aef3903663955f6f9a411be06752f3976}{m\_networkRoutes}.push\_back (route);
108 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5


\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!Add\+Network\+Route\+To@{Add\+Network\+Route\+To}}
\index{Add\+Network\+Route\+To@{Add\+Network\+Route\+To}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{Add\+Network\+Route\+To(\+Ipv4\+Address network, Ipv4\+Mask network\+Mask, uint32\+\_\+t interface)}{AddNetworkRouteTo(Ipv4Address network, Ipv4Mask networkMask, uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Global\+Routing\+::\+Add\+Network\+Route\+To (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{network, }
\item[{{\bf Ipv4\+Mask}}]{network\+Mask, }
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4GlobalRouting_af399f1eef7e7e3dcca122cb8cade0574}{}\label{classns3_1_1Ipv4GlobalRouting_af399f1eef7e7e3dcca122cb8cade0574}


Add a network route to the global routing table. 


\begin{DoxyParams}{Parameters}
{\em network} & The \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} network for this route. \\
\hline
{\em network\+Mask} & The \hyperlink{classns3_1_1Ipv4Mask}{Ipv4\+Mask} to extract the network. \\
\hline
{\em interface} & The network interface index used to send packets to the destination.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} 
\end{DoxySeeAlso}

\begin{DoxyCode}
114 \{
115   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << network << networkMask << interface);
116   Ipv4RoutingTableEntry *route = \textcolor{keyword}{new} Ipv4RoutingTableEntry ();
117   *route = \hyperlink{classns3_1_1Ipv4RoutingTableEntry_abe3447a00495ded05ab095673531947a}{Ipv4RoutingTableEntry::CreateNetworkRouteTo} (network,
118                                                         networkMask,
119                                                         interface);
120   \hyperlink{classns3_1_1Ipv4GlobalRouting_aef3903663955f6f9a411be06752f3976}{m\_networkRoutes}.push\_back (route);
121 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6


\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!Assign\+Streams@{Assign\+Streams}}
\index{Assign\+Streams@{Assign\+Streams}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{Assign\+Streams(int64\+\_\+t stream)}{AssignStreams(int64_t stream)}}]{\setlength{\rightskip}{0pt plus 5cm}int64\+\_\+t ns3\+::\+Ipv4\+Global\+Routing\+::\+Assign\+Streams (
\begin{DoxyParamCaption}
\item[{int64\+\_\+t}]{stream}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4GlobalRouting_a392bf55dd79428567bd027c64af0c8be}{}\label{classns3_1_1Ipv4GlobalRouting_a392bf55dd79428567bd027c64af0c8be}
Assign a fixed random variable stream number to the random variables used by this model. Return the number of streams (possibly zero) that have been assigned.


\begin{DoxyParams}{Parameters}
{\em stream} & first stream index to use \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of stream indices assigned by this model 
\end{DoxyReturn}

\begin{DoxyCode}
367 \{
368   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << stream);
369   \hyperlink{classns3_1_1Ipv4GlobalRouting_a3cc74017538737dc3f6ec7f511a3481e}{m\_rand}->\hyperlink{classns3_1_1RandomVariableStream_add11aaf975607746b7e271d300659a94}{SetStream} (stream);
370   \textcolor{keywordflow}{return} 1;
371 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7


\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{Do\+Dispose(void)}{DoDispose(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Global\+Routing\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4GlobalRouting_a3ed00382c689954195ea0ac02531d1ea}{}\label{classns3_1_1Ipv4GlobalRouting_a3ed00382c689954195ea0ac02531d1ea}
Destructor implementation.

This method is called by \hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose()} or by the \hyperlink{classns3_1_1Object}{Object}\textquotesingle{}s destructor, whichever comes first.

Subclasses are expected to implement their real destruction code in an overriden version of this method and chain up to their parent\textquotesingle{}s implementation once they are done. {\itshape i.\+e}, for simplicity, the destructor of every subclass should be empty and its content should be moved to the associated \hyperlink{classns3_1_1Ipv4GlobalRouting_a3ed00382c689954195ea0ac02531d1ea}{Do\+Dispose()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.


\begin{DoxyCode}
375 \{
376   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
377   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv4GlobalRouting_a4a3de9839580400d39d5bac0b0d33308}{HostRoutesI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Ipv4GlobalRouting_adcef09fc8af430a93c9437edfc22511c}{m\_hostRoutes}.begin (); 
378        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1Ipv4GlobalRouting_adcef09fc8af430a93c9437edfc22511c}{m\_hostRoutes}.end (); 
379        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Ipv4GlobalRouting_adcef09fc8af430a93c9437edfc22511c}{m\_hostRoutes}.erase (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})) 
380     \{
381       \textcolor{keyword}{delete} (*i);
382     \}
383   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv4GlobalRouting_a52c6db3cff38f2600555615bb9840ca5}{NetworkRoutesI} j = \hyperlink{classns3_1_1Ipv4GlobalRouting_aef3903663955f6f9a411be06752f3976}{m\_networkRoutes}.begin (); 
384        j != \hyperlink{classns3_1_1Ipv4GlobalRouting_aef3903663955f6f9a411be06752f3976}{m\_networkRoutes}.end (); 
385        j = \hyperlink{classns3_1_1Ipv4GlobalRouting_aef3903663955f6f9a411be06752f3976}{m\_networkRoutes}.erase (j)) 
386     \{
387       \textcolor{keyword}{delete} (*j);
388     \}
389   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv4GlobalRouting_a2f2e1f2c8d631cfd016343f993cf577b}{ASExternalRoutesI} \hyperlink{buildings__pathloss_8m_a5b54c0a045f179bcbbbc9abcb8b5cd4c}{l} = \hyperlink{classns3_1_1Ipv4GlobalRouting_ad34f23b0d519a9603b6d9225185fc5ad}{m\_ASexternalRoutes}.begin (); 
390        \hyperlink{buildings__pathloss_8m_a5b54c0a045f179bcbbbc9abcb8b5cd4c}{l} != \hyperlink{classns3_1_1Ipv4GlobalRouting_ad34f23b0d519a9603b6d9225185fc5ad}{m\_ASexternalRoutes}.end ();
391        \hyperlink{buildings__pathloss_8m_a5b54c0a045f179bcbbbc9abcb8b5cd4c}{l} = \hyperlink{classns3_1_1Ipv4GlobalRouting_ad34f23b0d519a9603b6d9225185fc5ad}{m\_ASexternalRoutes}.erase (\hyperlink{buildings__pathloss_8m_a5b54c0a045f179bcbbbc9abcb8b5cd4c}{l}))
392     \{
393       \textcolor{keyword}{delete} (*l);
394     \}
395 
396   \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{Ipv4RoutingProtocol::DoDispose} ();
397 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8


\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!Get\+N\+Routes@{Get\+N\+Routes}}
\index{Get\+N\+Routes@{Get\+N\+Routes}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{Get\+N\+Routes(void) const }{GetNRoutes(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Ipv4\+Global\+Routing\+::\+Get\+N\+Routes (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv4GlobalRouting_abb9d2b3642272b9bd2697a5699922fa7}{}\label{classns3_1_1Ipv4GlobalRouting_abb9d2b3642272b9bd2697a5699922fa7}


Get the number of individual unicast routes that have been added to the routing table. 

\begin{DoxyWarning}{Warning}
The default route counts as one of the routes. 
\end{DoxyWarning}
\begin{DoxyReturn}{Returns}
the number of routes 
\end{DoxyReturn}

\begin{DoxyCode}
250 \{
251   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
252   uint32\_t \hyperlink{namespacesample-rng-plot_aeb5ee5c431e338ef39b7ac5431242e1d}{n} = 0;
253   n += \hyperlink{classns3_1_1Ipv4GlobalRouting_adcef09fc8af430a93c9437edfc22511c}{m\_hostRoutes}.size ();
254   n += \hyperlink{classns3_1_1Ipv4GlobalRouting_aef3903663955f6f9a411be06752f3976}{m\_networkRoutes}.size ();
255   n += \hyperlink{classns3_1_1Ipv4GlobalRouting_ad34f23b0d519a9603b6d9225185fc5ad}{m\_ASexternalRoutes}.size ();
256   \textcolor{keywordflow}{return} \hyperlink{namespacesample-rng-plot_aeb5ee5c431e338ef39b7ac5431242e1d}{n};
257 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 9


\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!Get\+Route@{Get\+Route}}
\index{Get\+Route@{Get\+Route}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Route(uint32\+\_\+t i) const }{GetRoute(uint32_t i) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Routing\+Table\+Entry} $\ast$ ns3\+::\+Ipv4\+Global\+Routing\+::\+Get\+Route (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv4GlobalRouting_accd518b9888908dbea189c1d1c73dcf1}{}\label{classns3_1_1Ipv4GlobalRouting_accd518b9888908dbea189c1d1c73dcf1}


Get a route from the global unicast routing table. 

Externally, the unicast global routing table appears simply as a table with n entries. The one subtlety of note is that if a default route has been set it will appear as the zeroth entry in the table. This means that if you add only a default route, the table will have one entry that can be accessed either by explicitly calling Get\+Default\+Route () or by calling Get\+Route (0).

Similarly, if the default route has been set, calling Remove\+Route (0) will remove the default route.


\begin{DoxyParams}{Parameters}
{\em i} & The index (into the routing table) of the route to retrieve. If the default route has been set, it will occupy index zero. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If route is set, a pointer to that \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} is returned, otherwise a zero pointer is returned.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} 

\hyperlink{classns3_1_1Ipv4GlobalRouting_a406d6a56f246ef9c105a6ad5da4d7ffb}{Ipv4\+Global\+Routing\+::\+Remove\+Route} 
\end{DoxySeeAlso}

\begin{DoxyCode}
261 \{
262   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << index);
263   \textcolor{keywordflow}{if} (index < \hyperlink{classns3_1_1Ipv4GlobalRouting_adcef09fc8af430a93c9437edfc22511c}{m\_hostRoutes}.size ())
264     \{
265       uint32\_t tmp = 0;
266       \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv4GlobalRouting_aae0bc92477a22c30a84d24b7059feba3}{HostRoutesCI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Ipv4GlobalRouting_adcef09fc8af430a93c9437edfc22511c}{m\_hostRoutes}.begin (); 
267            \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1Ipv4GlobalRouting_adcef09fc8af430a93c9437edfc22511c}{m\_hostRoutes}.end (); 
268            \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++) 
269         \{
270           \textcolor{keywordflow}{if} (tmp  == index)
271             \{
272               \textcolor{keywordflow}{return} *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
273             \}
274           tmp++;
275         \}
276     \}
277   index -= \hyperlink{classns3_1_1Ipv4GlobalRouting_adcef09fc8af430a93c9437edfc22511c}{m\_hostRoutes}.size ();
278   uint32\_t tmp = 0;
279   \textcolor{keywordflow}{if} (index < \hyperlink{classns3_1_1Ipv4GlobalRouting_aef3903663955f6f9a411be06752f3976}{m\_networkRoutes}.size ())
280     \{
281       \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv4GlobalRouting_a951edfd8275e2329a7fd4c5f00ac420e}{NetworkRoutesCI} j = \hyperlink{classns3_1_1Ipv4GlobalRouting_aef3903663955f6f9a411be06752f3976}{m\_networkRoutes}.begin (); 
282            j != \hyperlink{classns3_1_1Ipv4GlobalRouting_aef3903663955f6f9a411be06752f3976}{m\_networkRoutes}.end ();
283            j++)
284         \{
285           \textcolor{keywordflow}{if} (tmp == index)
286             \{
287               \textcolor{keywordflow}{return} *j;
288             \}
289           tmp++;
290         \}
291     \}
292   index -= \hyperlink{classns3_1_1Ipv4GlobalRouting_aef3903663955f6f9a411be06752f3976}{m\_networkRoutes}.size ();
293   tmp = 0;
294   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv4GlobalRouting_aabafd3cfb22a4cc8f84b166a97b88c57}{ASExternalRoutesCI} k = \hyperlink{classns3_1_1Ipv4GlobalRouting_ad34f23b0d519a9603b6d9225185fc5ad}{m\_ASexternalRoutes}.begin (); 
295        k != \hyperlink{classns3_1_1Ipv4GlobalRouting_ad34f23b0d519a9603b6d9225185fc5ad}{m\_ASexternalRoutes}.end (); 
296        k++) 
297     \{
298       \textcolor{keywordflow}{if} (tmp == index)
299         \{
300           \textcolor{keywordflow}{return} *k;
301         \}
302       tmp++;
303     \}
304   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\textcolor{keyword}{false});
305   \textcolor{comment}{// quiet compiler.}
306   \textcolor{keywordflow}{return} 0;
307 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 10


\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Ipv4\+Global\+Routing\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv4GlobalRouting_ae32c45a7d6f10a4501d4d59c51f872ae}{}\label{classns3_1_1Ipv4GlobalRouting_ae32c45a7d6f10a4501d4d59c51f872ae}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
42 \{ 
43   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::Ipv4GlobalRouting"})
44     .SetParent<\hyperlink{classns3_1_1Object_a40860402e64d8008fb42329df7097cdb}{Object}> ()
45     .SetGroupName (\textcolor{stringliteral}{"Internet"})
46     .AddAttribute (\textcolor{stringliteral}{"RandomEcmpRouting"},
47                    \textcolor{stringliteral}{"Set to true if packets are randomly routed among ECMP; set to false for using only one
       route consistently"},
48                    BooleanValue (\textcolor{keyword}{false}),
49                    MakeBooleanAccessor (&\hyperlink{classns3_1_1Ipv4GlobalRouting_aecf81bc1f0bdbb4fff3fa7c56e4707a4}{Ipv4GlobalRouting::m\_randomEcmpRouting}
      ),
50                    MakeBooleanChecker ())
51     .AddAttribute (\textcolor{stringliteral}{"RespondToInterfaceEvents"},
52                    \textcolor{stringliteral}{"Set to true if you want to dynamically recompute the global routes upon Interface
       notification events (up/down, or add/remove address)"},
53                    BooleanValue (\textcolor{keyword}{false}),
54                    MakeBooleanAccessor (&
      \hyperlink{classns3_1_1Ipv4GlobalRouting_ae346dbd5b2a06c03df13c1a3987e4719}{Ipv4GlobalRouting::m\_respondToInterfaceEvents}),
55                    MakeBooleanChecker ())
56   ;
57   \textcolor{keywordflow}{return} tid;
58 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 11


\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!Lookup\+Global@{Lookup\+Global}}
\index{Lookup\+Global@{Lookup\+Global}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{Lookup\+Global(\+Ipv4\+Address dest, Ptr$<$ Net\+Device $>$ oif=0)}{LookupGlobal(Ipv4Address dest, Ptr< NetDevice > oif=0)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv4\+Route} $>$ ns3\+::\+Ipv4\+Global\+Routing\+::\+Lookup\+Global (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{dest, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{oif = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4GlobalRouting_a647d7654f270ce66e46f26fc729f1d07}{}\label{classns3_1_1Ipv4GlobalRouting_a647d7654f270ce66e46f26fc729f1d07}


Lookup in the forwarding table for destination. 


\begin{DoxyParams}{Parameters}
{\em dest} & destination address \\
\hline
{\em oif} & output interface if any (put 0 otherwise) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} to route the packet to reach dest address 
\end{DoxyReturn}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000042}{Todo}]handle multi-\/address case \end{DoxyRefDesc}

\begin{DoxyCode}
141 \{
142   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << dest << oif);
143   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Looking for route for destination "} << dest);
144   Ptr<Ipv4Route> rtentry = 0;
145   \textcolor{comment}{// store all available routes that bring packets to their destination}
146   \textcolor{keyword}{typedef} std::vector<Ipv4RoutingTableEntry*> RouteVec\_t;
147   RouteVec\_t allRoutes;
148 
149   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Number of m\_hostRoutes = "} << \hyperlink{classns3_1_1Ipv4GlobalRouting_adcef09fc8af430a93c9437edfc22511c}{m\_hostRoutes}.size ());
150   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv4GlobalRouting_aae0bc92477a22c30a84d24b7059feba3}{HostRoutesCI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Ipv4GlobalRouting_adcef09fc8af430a93c9437edfc22511c}{m\_hostRoutes}.begin (); 
151        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1Ipv4GlobalRouting_adcef09fc8af430a93c9437edfc22511c}{m\_hostRoutes}.end (); 
152        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++) 
153     \{
154       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} ((*i)->IsHost ());
155       \textcolor{keywordflow}{if} ((*i)->GetDest ().IsEqual (dest)) 
156         \{
157           \textcolor{keywordflow}{if} (oif != 0)
158             \{
159               \textcolor{keywordflow}{if} (oif != \hyperlink{classns3_1_1Ipv4GlobalRouting_a8ca97d33982a32fa41a98b56dbec2edc}{m\_ipv4}->GetNetDevice ((*i)->GetInterface ()))
160                 \{
161                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Not on requested interface, skipping"});
162                   \textcolor{keywordflow}{continue};
163                 \}
164             \}
165           allRoutes.push\_back (*\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
166           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (allRoutes.size () << \textcolor{stringliteral}{"Found global host route"} << *
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}); 
167         \}
168     \}
169   \textcolor{keywordflow}{if} (allRoutes.size () == 0) \textcolor{comment}{// if no host route is found}
170     \{
171       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Number of m\_networkRoutes"} << \hyperlink{classns3_1_1Ipv4GlobalRouting_aef3903663955f6f9a411be06752f3976}{m\_networkRoutes}.size ());
172       \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv4GlobalRouting_a52c6db3cff38f2600555615bb9840ca5}{NetworkRoutesI} j = \hyperlink{classns3_1_1Ipv4GlobalRouting_aef3903663955f6f9a411be06752f3976}{m\_networkRoutes}.begin (); 
173            j != \hyperlink{classns3_1_1Ipv4GlobalRouting_aef3903663955f6f9a411be06752f3976}{m\_networkRoutes}.end (); 
174            j++) 
175         \{
176           Ipv4Mask mask = (*j)->GetDestNetworkMask ();
177           Ipv4Address entry = (*j)->GetDestNetwork ();
178           \textcolor{keywordflow}{if} (mask.IsMatch (dest, entry)) 
179             \{
180               \textcolor{keywordflow}{if} (oif != 0)
181                 \{
182                   \textcolor{keywordflow}{if} (oif != \hyperlink{classns3_1_1Ipv4GlobalRouting_a8ca97d33982a32fa41a98b56dbec2edc}{m\_ipv4}->GetNetDevice ((*j)->GetInterface ()))
183                     \{
184                       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Not on requested interface, skipping"});
185                       \textcolor{keywordflow}{continue};
186                     \}
187                 \}
188               allRoutes.push\_back (*j);
189               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (allRoutes.size () << \textcolor{stringliteral}{"Found global network route"} << *j);
190             \}
191         \}
192     \}
193   \textcolor{keywordflow}{if} (allRoutes.size () == 0)  \textcolor{comment}{// consider external if no host/network found}
194     \{
195       \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv4GlobalRouting_a2f2e1f2c8d631cfd016343f993cf577b}{ASExternalRoutesI} k = \hyperlink{classns3_1_1Ipv4GlobalRouting_ad34f23b0d519a9603b6d9225185fc5ad}{m\_ASexternalRoutes}.begin ();
196            k != \hyperlink{classns3_1_1Ipv4GlobalRouting_ad34f23b0d519a9603b6d9225185fc5ad}{m\_ASexternalRoutes}.end ();
197            k++)
198         \{
199           Ipv4Mask mask = (*k)->GetDestNetworkMask ();
200           Ipv4Address entry = (*k)->GetDestNetwork ();
201           \textcolor{keywordflow}{if} (mask.IsMatch (dest, entry))
202             \{
203               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Found external route"} << *k);
204               \textcolor{keywordflow}{if} (oif != 0)
205                 \{
206                   \textcolor{keywordflow}{if} (oif != \hyperlink{classns3_1_1Ipv4GlobalRouting_a8ca97d33982a32fa41a98b56dbec2edc}{m\_ipv4}->GetNetDevice ((*k)->GetInterface ()))
207                     \{
208                       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Not on requested interface, skipping"});
209                       \textcolor{keywordflow}{continue};
210                     \}
211                 \}
212               allRoutes.push\_back (*k);
213               \textcolor{keywordflow}{break};
214             \}
215         \}
216     \}
217   \textcolor{keywordflow}{if} (allRoutes.size () > 0 ) \textcolor{comment}{// if route(s) is found}
218     \{
219       \textcolor{comment}{// pick up one of the routes uniformly at random if random}
220       \textcolor{comment}{// ECMP routing is enabled, or always select the first route}
221       \textcolor{comment}{// consistently if random ECMP routing is disabled}
222       uint32\_t selectIndex;
223       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4GlobalRouting_aecf81bc1f0bdbb4fff3fa7c56e4707a4}{m\_randomEcmpRouting})
224         \{
225           selectIndex = \hyperlink{classns3_1_1Ipv4GlobalRouting_a3cc74017538737dc3f6ec7f511a3481e}{m\_rand}->\hyperlink{classns3_1_1RandomVariableStream_a66cd94e6305ce7f000f1a9ff0fcb9aef}{GetInteger} (0, allRoutes.size ()-1);
226         \}
227       \textcolor{keywordflow}{else} 
228         \{
229           selectIndex = 0;
230         \}
231       Ipv4RoutingTableEntry* route = allRoutes.at (selectIndex); 
232       \textcolor{comment}{// create a Ipv4Route object from the selected routing table entry}
233       rtentry = Create<Ipv4Route> ();
234       rtentry->SetDestination (route->GetDest ());
236       rtentry->SetSource (\hyperlink{classns3_1_1Ipv4GlobalRouting_a8ca97d33982a32fa41a98b56dbec2edc}{m\_ipv4}->GetAddress (route->GetInterface (), 0).GetLocal ());
237       rtentry->SetGateway (route->GetGateway ());
238       uint32\_t interfaceIdx = route->GetInterface ();
239       rtentry->SetOutputDevice (\hyperlink{classns3_1_1Ipv4GlobalRouting_a8ca97d33982a32fa41a98b56dbec2edc}{m\_ipv4}->GetNetDevice (interfaceIdx));
240       \textcolor{keywordflow}{return} rtentry;
241     \}
242   \textcolor{keywordflow}{else} 
243     \{
244       \textcolor{keywordflow}{return} 0;
245     \}
246 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12




Here is the caller graph for this function\+:
% FIG 13


\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!Notify\+Add\+Address@{Notify\+Add\+Address}}
\index{Notify\+Add\+Address@{Notify\+Add\+Address}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{Notify\+Add\+Address(uint32\+\_\+t interface, Ipv4\+Interface\+Address address)}{NotifyAddAddress(uint32_t interface, Ipv4InterfaceAddress address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Global\+Routing\+::\+Notify\+Add\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv4\+Interface\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4GlobalRouting_a500c6e43cbf90b83b9582d3dc029ede0}{}\label{classns3_1_1Ipv4GlobalRouting_a500c6e43cbf90b83b9582d3dc029ede0}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
{\em address} & a new address being added to an interface\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified whenever a new address is added to an interface. Typically used to add a \textquotesingle{}network route\textquotesingle{} on an interface. Can be invoked on an up or down interface. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_aef12fcf9cc478536876b0281505d40aa}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
560 \{
561   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << interface << address);
562   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4GlobalRouting_ae346dbd5b2a06c03df13c1a3987e4719}{m\_respondToInterfaceEvents} && \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds ()
       > 0)  \textcolor{comment}{// avoid startup events}
563     \{
564       \hyperlink{classns3_1_1GlobalRouteManager_a046807276556c567868fca992895b695}{GlobalRouteManager::DeleteGlobalRoutes} ();
565       \hyperlink{classns3_1_1GlobalRouteManager_af0d9e010837cc915d430b17f63175910}{GlobalRouteManager::BuildGlobalRoutingDatabase} ();
566       \hyperlink{classns3_1_1GlobalRouteManager_aea21f6fb4dbecb0d2e3dadc7db1087d3}{GlobalRouteManager::InitializeRoutes} ();
567     \}
568 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 14


\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!Notify\+Interface\+Down@{Notify\+Interface\+Down}}
\index{Notify\+Interface\+Down@{Notify\+Interface\+Down}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{Notify\+Interface\+Down(uint32\+\_\+t interface)}{NotifyInterfaceDown(uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Global\+Routing\+::\+Notify\+Interface\+Down (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4GlobalRouting_a15eb3f2522504b90c7fb28412040e1ff}{}\label{classns3_1_1Ipv4GlobalRouting_a15eb3f2522504b90c7fb28412040e1ff}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified of the state change of an interface in a node. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a90f728b73ccb1806e5a4093ff156f607}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
548 \{
549   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
550   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4GlobalRouting_ae346dbd5b2a06c03df13c1a3987e4719}{m\_respondToInterfaceEvents} && \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds ()
       > 0)  \textcolor{comment}{// avoid startup events}
551     \{
552       \hyperlink{classns3_1_1GlobalRouteManager_a046807276556c567868fca992895b695}{GlobalRouteManager::DeleteGlobalRoutes} ();
553       \hyperlink{classns3_1_1GlobalRouteManager_af0d9e010837cc915d430b17f63175910}{GlobalRouteManager::BuildGlobalRoutingDatabase} ();
554       \hyperlink{classns3_1_1GlobalRouteManager_aea21f6fb4dbecb0d2e3dadc7db1087d3}{GlobalRouteManager::InitializeRoutes} ();
555     \}
556 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 15


\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!Notify\+Interface\+Up@{Notify\+Interface\+Up}}
\index{Notify\+Interface\+Up@{Notify\+Interface\+Up}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{Notify\+Interface\+Up(uint32\+\_\+t interface)}{NotifyInterfaceUp(uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Global\+Routing\+::\+Notify\+Interface\+Up (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4GlobalRouting_af4068bd0482d47a34ceb857ba2137c97}{}\label{classns3_1_1Ipv4GlobalRouting_af4068bd0482d47a34ceb857ba2137c97}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified of the state change of an interface in a node. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_aabb99ce7a048e75ff4b36fa9af8745e4}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
536 \{
537   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
538   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4GlobalRouting_ae346dbd5b2a06c03df13c1a3987e4719}{m\_respondToInterfaceEvents} && \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds ()
       > 0)  \textcolor{comment}{// avoid startup events}
539     \{
540       \hyperlink{classns3_1_1GlobalRouteManager_a046807276556c567868fca992895b695}{GlobalRouteManager::DeleteGlobalRoutes} ();
541       \hyperlink{classns3_1_1GlobalRouteManager_af0d9e010837cc915d430b17f63175910}{GlobalRouteManager::BuildGlobalRoutingDatabase} ();
542       \hyperlink{classns3_1_1GlobalRouteManager_aea21f6fb4dbecb0d2e3dadc7db1087d3}{GlobalRouteManager::InitializeRoutes} ();
543     \}
544 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 16


\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!Notify\+Remove\+Address@{Notify\+Remove\+Address}}
\index{Notify\+Remove\+Address@{Notify\+Remove\+Address}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{Notify\+Remove\+Address(uint32\+\_\+t interface, Ipv4\+Interface\+Address address)}{NotifyRemoveAddress(uint32_t interface, Ipv4InterfaceAddress address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Global\+Routing\+::\+Notify\+Remove\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv4\+Interface\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4GlobalRouting_a2fe404417aaa31ac52fe87817075e612}{}\label{classns3_1_1Ipv4GlobalRouting_a2fe404417aaa31ac52fe87817075e612}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
{\em address} & a new address being added to an interface\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified whenever a new address is removed from an interface. Typically used to remove the \textquotesingle{}network route\textquotesingle{} of an interface. Can be invoked on an up or down interface. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a0160e49e509d6699ec837e5485f65cd2}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
572 \{
573   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << interface << address);
574   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4GlobalRouting_ae346dbd5b2a06c03df13c1a3987e4719}{m\_respondToInterfaceEvents} && \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds ()
       > 0)  \textcolor{comment}{// avoid startup events}
575     \{
576       \hyperlink{classns3_1_1GlobalRouteManager_a046807276556c567868fca992895b695}{GlobalRouteManager::DeleteGlobalRoutes} ();
577       \hyperlink{classns3_1_1GlobalRouteManager_af0d9e010837cc915d430b17f63175910}{GlobalRouteManager::BuildGlobalRoutingDatabase} ();
578       \hyperlink{classns3_1_1GlobalRouteManager_aea21f6fb4dbecb0d2e3dadc7db1087d3}{GlobalRouteManager::InitializeRoutes} ();
579     \}
580 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 17


\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!Print\+Routing\+Table@{Print\+Routing\+Table}}
\index{Print\+Routing\+Table@{Print\+Routing\+Table}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{Print\+Routing\+Table(\+Ptr$<$ Output\+Stream\+Wrapper $>$ stream, Time\+::\+Unit unit=\+Time\+::\+S) const }{PrintRoutingTable(Ptr< OutputStreamWrapper > stream, Time::Unit unit=Time::S) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Global\+Routing\+::\+Print\+Routing\+Table (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream, }
\item[{{\bf Time\+::\+Unit}}]{unit = {\ttfamily {\bf Time\+::S}}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4GlobalRouting_aa8be09f66df028d8c3832c1c0da25a7b}{}\label{classns3_1_1Ipv4GlobalRouting_aa8be09f66df028d8c3832c1c0da25a7b}


Print the Routing Table entries. 


\begin{DoxyParams}{Parameters}
{\em stream} & The ostream the Routing table is printed to \\
\hline
{\em unit} & The time unit to be used in the report \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a86ad3fc1d17b06b6553a13b03d7e8cb4}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
402 \{
403   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << stream);
404   std::ostream* os = stream->\hyperlink{classns3_1_1OutputStreamWrapper_a0cf30a4188ab6fdae2b2ab74db11acc2}{GetStream} ();
405 
406   *os << \textcolor{stringliteral}{"Node: "} << \hyperlink{classns3_1_1Ipv4GlobalRouting_a8ca97d33982a32fa41a98b56dbec2edc}{m\_ipv4}->GetObject<Node> ()->GetId ()
407       << \textcolor{stringliteral}{", Time: "} << \hyperlink{group__simulator_gac3635e2e87f7ce316c89290ee1b01d0d}{Now}().\hyperlink{classns3_1_1Time_a0bb1110638ce9938248bd07865a328ab}{As} (unit)
408       << \textcolor{stringliteral}{", Local time: "} << GetObject<Node> ()->GetLocalTime ().As (unit)
409       << \textcolor{stringliteral}{", Ipv4GlobalRouting table"} << std::endl;
410 
411   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4GlobalRouting_abb9d2b3642272b9bd2697a5699922fa7}{GetNRoutes} () > 0)
412     \{
413       *os << \textcolor{stringliteral}{"Destination     Gateway         Genmask         Flags Metric Ref    Use Iface"} << std::endl;
414       \textcolor{keywordflow}{for} (uint32\_t j = 0; j < \hyperlink{classns3_1_1Ipv4GlobalRouting_abb9d2b3642272b9bd2697a5699922fa7}{GetNRoutes} (); j++)
415         \{
416           std::ostringstream dest, gw, mask, flags;
417           Ipv4RoutingTableEntry route = \hyperlink{classns3_1_1Ipv4GlobalRouting_accd518b9888908dbea189c1d1c73dcf1}{GetRoute} (j);
418           dest << route.GetDest ();
419           *os << std::setiosflags (std::ios::left) << std::setw (16) << dest.str ();
420           gw << route.GetGateway ();
421           *os << std::setiosflags (std::ios::left) << std::setw (16) << gw.str ();
422           mask << route.GetDestNetworkMask ();
423           *os << std::setiosflags (std::ios::left) << std::setw (16) << mask.str ();
424           flags << \textcolor{stringliteral}{"U"};
425           \textcolor{keywordflow}{if} (route.IsHost ())
426             \{
427               flags << \textcolor{stringliteral}{"H"};
428             \}
429           \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (route.IsGateway ())
430             \{
431               flags << \textcolor{stringliteral}{"G"};
432             \}
433           *os << std::setiosflags (std::ios::left) << std::setw (6) << flags.str ();
434           \textcolor{comment}{// Metric not implemented}
435           *os << \textcolor{stringliteral}{"-"} << \textcolor{stringliteral}{"      "};
436           \textcolor{comment}{// Ref ct not implemented}
437           *os << \textcolor{stringliteral}{"-"} << \textcolor{stringliteral}{"      "};
438           \textcolor{comment}{// Use not implemented}
439           *os << \textcolor{stringliteral}{"-"} << \textcolor{stringliteral}{"   "};
440           \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Names_ab9664faf23569aaae64a2d1f65265045}{Names::FindName} (\hyperlink{classns3_1_1Ipv4GlobalRouting_a8ca97d33982a32fa41a98b56dbec2edc}{m\_ipv4}->GetNetDevice (route.GetInterface ())) != \textcolor{stringliteral}{""})
441             \{
442               *os << \hyperlink{classns3_1_1Names_ab9664faf23569aaae64a2d1f65265045}{Names::FindName} (\hyperlink{classns3_1_1Ipv4GlobalRouting_a8ca97d33982a32fa41a98b56dbec2edc}{m\_ipv4}->GetNetDevice (route.GetInterface ()));
443             \}
444           \textcolor{keywordflow}{else}
445             \{
446               *os << route.GetInterface ();
447             \}
448           *os << std::endl;
449         \}
450     \}
451   *os << std::endl;
452 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 18


\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!Remove\+Route@{Remove\+Route}}
\index{Remove\+Route@{Remove\+Route}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{Remove\+Route(uint32\+\_\+t i)}{RemoveRoute(uint32_t i)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Global\+Routing\+::\+Remove\+Route (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4GlobalRouting_a406d6a56f246ef9c105a6ad5da4d7ffb}{}\label{classns3_1_1Ipv4GlobalRouting_a406d6a56f246ef9c105a6ad5da4d7ffb}


Remove a route from the global unicast routing table. 

Externally, the unicast global routing table appears simply as a table with n entries. The one subtlety of note is that if a default route has been set it will appear as the zeroth entry in the table. This means that if the default route has been set, calling Remove\+Route (0) will remove the default route.


\begin{DoxyParams}{Parameters}
{\em i} & The index (into the routing table) of the route to remove. If the default route has been set, it will occupy index zero.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} 

\hyperlink{classns3_1_1Ipv4GlobalRouting_accd518b9888908dbea189c1d1c73dcf1}{Ipv4\+Global\+Routing\+::\+Get\+Route} 

Ipv4\+Global\+Routing\+::\+Add\+Route 
\end{DoxySeeAlso}

\begin{DoxyCode}
310 \{
311   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << index);
312   \textcolor{keywordflow}{if} (index < \hyperlink{classns3_1_1Ipv4GlobalRouting_adcef09fc8af430a93c9437edfc22511c}{m\_hostRoutes}.size ())
313     \{
314       uint32\_t tmp = 0;
315       \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv4GlobalRouting_a4a3de9839580400d39d5bac0b0d33308}{HostRoutesI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Ipv4GlobalRouting_adcef09fc8af430a93c9437edfc22511c}{m\_hostRoutes}.begin (); 
316            \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1Ipv4GlobalRouting_adcef09fc8af430a93c9437edfc22511c}{m\_hostRoutes}.end (); 
317            \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++) 
318         \{
319           \textcolor{keywordflow}{if} (tmp  == index)
320             \{
321               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Removing route "} << index << \textcolor{stringliteral}{"; size = "} << 
      \hyperlink{classns3_1_1Ipv4GlobalRouting_adcef09fc8af430a93c9437edfc22511c}{m\_hostRoutes}.size ());
322               \textcolor{keyword}{delete} *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
323               \hyperlink{classns3_1_1Ipv4GlobalRouting_adcef09fc8af430a93c9437edfc22511c}{m\_hostRoutes}.erase (i);
324               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Done removing host route "} << index << \textcolor{stringliteral}{"; host route remaining
       size = "} << \hyperlink{classns3_1_1Ipv4GlobalRouting_adcef09fc8af430a93c9437edfc22511c}{m\_hostRoutes}.size ());
325               \textcolor{keywordflow}{return};
326             \}
327           tmp++;
328         \}
329     \}
330   index -= \hyperlink{classns3_1_1Ipv4GlobalRouting_adcef09fc8af430a93c9437edfc22511c}{m\_hostRoutes}.size ();
331   uint32\_t tmp = 0;
332   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv4GlobalRouting_a52c6db3cff38f2600555615bb9840ca5}{NetworkRoutesI} j = \hyperlink{classns3_1_1Ipv4GlobalRouting_aef3903663955f6f9a411be06752f3976}{m\_networkRoutes}.begin (); 
333        j != \hyperlink{classns3_1_1Ipv4GlobalRouting_aef3903663955f6f9a411be06752f3976}{m\_networkRoutes}.end (); 
334        j++) 
335     \{
336       \textcolor{keywordflow}{if} (tmp == index)
337         \{
338           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Removing route "} << index << \textcolor{stringliteral}{"; size = "} << 
      \hyperlink{classns3_1_1Ipv4GlobalRouting_aef3903663955f6f9a411be06752f3976}{m\_networkRoutes}.size ());
339           \textcolor{keyword}{delete} *j;
340           \hyperlink{classns3_1_1Ipv4GlobalRouting_aef3903663955f6f9a411be06752f3976}{m\_networkRoutes}.erase (j);
341           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Done removing network route "} << index << \textcolor{stringliteral}{"; network route remaining
       size = "} << \hyperlink{classns3_1_1Ipv4GlobalRouting_aef3903663955f6f9a411be06752f3976}{m\_networkRoutes}.size ());
342           \textcolor{keywordflow}{return};
343         \}
344       tmp++;
345     \}
346   index -= \hyperlink{classns3_1_1Ipv4GlobalRouting_aef3903663955f6f9a411be06752f3976}{m\_networkRoutes}.size ();
347   tmp = 0;
348   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv4GlobalRouting_a2f2e1f2c8d631cfd016343f993cf577b}{ASExternalRoutesI} k = \hyperlink{classns3_1_1Ipv4GlobalRouting_ad34f23b0d519a9603b6d9225185fc5ad}{m\_ASexternalRoutes}.begin (); 
349        k != \hyperlink{classns3_1_1Ipv4GlobalRouting_ad34f23b0d519a9603b6d9225185fc5ad}{m\_ASexternalRoutes}.end ();
350        k++)
351     \{
352       \textcolor{keywordflow}{if} (tmp == index)
353         \{
354           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Removing route "} << index << \textcolor{stringliteral}{"; size = "} << 
      \hyperlink{classns3_1_1Ipv4GlobalRouting_ad34f23b0d519a9603b6d9225185fc5ad}{m\_ASexternalRoutes}.size ());
355           \textcolor{keyword}{delete} *k;
356           \hyperlink{classns3_1_1Ipv4GlobalRouting_ad34f23b0d519a9603b6d9225185fc5ad}{m\_ASexternalRoutes}.erase (k);
357           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Done removing network route "} << index << \textcolor{stringliteral}{"; network route remaining
       size = "} << \hyperlink{classns3_1_1Ipv4GlobalRouting_aef3903663955f6f9a411be06752f3976}{m\_networkRoutes}.size ());
358           \textcolor{keywordflow}{return};
359         \}
360       tmp++;
361     \}
362   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\textcolor{keyword}{false});
363 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!Route\+Input@{Route\+Input}}
\index{Route\+Input@{Route\+Input}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{Route\+Input(\+Ptr$<$ const Packet $>$ p, const Ipv4\+Header \&header, Ptr$<$ const Net\+Device $>$ idev, Unicast\+Forward\+Callback ucb, Multicast\+Forward\+Callback mcb, Local\+Deliver\+Callback lcb, Error\+Callback ecb)}{RouteInput(Ptr< const Packet > p, const Ipv4Header &header, Ptr< const NetDevice > idev, UnicastForwardCallback ucb, MulticastForwardCallback mcb, LocalDeliverCallback lcb, ErrorCallback ecb)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv4\+Global\+Routing\+::\+Route\+Input (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv4\+Header} \&}]{header, }
\item[{{\bf Ptr}$<$ const {\bf Net\+Device} $>$}]{idev, }
\item[{{\bf Unicast\+Forward\+Callback}}]{ucb, }
\item[{{\bf Multicast\+Forward\+Callback}}]{mcb, }
\item[{{\bf Local\+Deliver\+Callback}}]{lcb, }
\item[{{\bf Error\+Callback}}]{ecb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4GlobalRouting_a2d027555864ab2f6a9f028f38a65a8e7}{}\label{classns3_1_1Ipv4GlobalRouting_a2d027555864ab2f6a9f028f38a65a8e7}


Route an input packet (to be forwarded or locally delivered) 

This lookup is used in the forwarding process. The packet is handed over to the \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol}, and will get forwarded onward by one of the callbacks. The Linux equivalent is ip\+\_\+route\+\_\+input(). There are four valid outcomes, and a matching callbacks to handle each.


\begin{DoxyParams}{Parameters}
{\em p} & received packet \\
\hline
{\em header} & input parameter used to form a search key for a route \\
\hline
{\em idev} & Pointer to ingress network device \\
\hline
{\em ucb} & \hyperlink{classns3_1_1Callback}{Callback} for the case in which the packet is to be forwarded as unicast \\
\hline
{\em mcb} & \hyperlink{classns3_1_1Callback}{Callback} for the case in which the packet is to be forwarded as multicast \\
\hline
{\em lcb} & \hyperlink{classns3_1_1Callback}{Callback} for the case in which the packet is to be locally delivered \\
\hline
{\em ecb} & \hyperlink{classns3_1_1Callback}{Callback} to call if there is an error in forwarding \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} takes responsibility for forwarding or delivering the packet, false otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a67e815ff40ebb9f5f4eec4e22e23132e}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
486 \{ 
487   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} << header << header.GetSource () << header.GetDestination () <
      < idev << &lcb << &ecb);
488   \textcolor{comment}{// Check if input device supports IP}
489   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1Ipv4GlobalRouting_a8ca97d33982a32fa41a98b56dbec2edc}{m\_ipv4}->GetInterfaceForDevice (idev) >= 0);
490   uint32\_t iif = \hyperlink{classns3_1_1Ipv4GlobalRouting_a8ca97d33982a32fa41a98b56dbec2edc}{m\_ipv4}->GetInterfaceForDevice (idev);
491 
492   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4GlobalRouting_a8ca97d33982a32fa41a98b56dbec2edc}{m\_ipv4}->IsDestinationAddress (header.GetDestination (), iif))
493     \{
494       \textcolor{keywordflow}{if} (!lcb.IsNull ())
495         \{
496           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Local delivery to "} << header.GetDestination ());
497           lcb (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header, iif);
498           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
499         \}
500       \textcolor{keywordflow}{else}
501         \{
502           \textcolor{comment}{// The local delivery callback is null.  This may be a multicast}
503           \textcolor{comment}{// or broadcast packet, so return false so that another}
504           \textcolor{comment}{// multicast routing protocol can handle it.  It should be possible}
505           \textcolor{comment}{// to extend this to explicitly check whether it is a unicast}
506           \textcolor{comment}{// packet, and invoke the error callback if so}
507           \textcolor{keywordflow}{return} \textcolor{keyword}{false};
508         \}
509     \}
510 
511   \textcolor{comment}{// Check if input device supports IP forwarding}
512   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4GlobalRouting_a8ca97d33982a32fa41a98b56dbec2edc}{m\_ipv4}->IsForwarding (iif) == \textcolor{keyword}{false})
513     \{
514       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Forwarding disabled for this interface"});
515       ecb (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{Socket::ERROR\_NOROUTETOHOST});
516       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
517     \}
518   \textcolor{comment}{// Next, try to find a route}
519   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Unicast destination- looking up global route"});
520   Ptr<Ipv4Route> rtentry = \hyperlink{classns3_1_1Ipv4GlobalRouting_a647d7654f270ce66e46f26fc729f1d07}{LookupGlobal} (header.GetDestination ());
521   \textcolor{keywordflow}{if} (rtentry != 0)
522     \{
523       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Found unicast destination- calling unicast callback"});
524       ucb (rtentry, \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header);
525       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
526     \}
527   \textcolor{keywordflow}{else}
528     \{
529       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Did not find unicast destination- returning false"});
530       \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \textcolor{comment}{// Let other routing protocols try to handle this}
531                     \textcolor{comment}{// route request.}
532     \}
533 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 19


\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!Route\+Output@{Route\+Output}}
\index{Route\+Output@{Route\+Output}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{Route\+Output(\+Ptr$<$ Packet $>$ p, const Ipv4\+Header \&header, Ptr$<$ Net\+Device $>$ oif, Socket\+::\+Socket\+Errno \&sockerr)}{RouteOutput(Ptr< Packet > p, const Ipv4Header &header, Ptr< NetDevice > oif, Socket::SocketErrno &sockerr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv4\+Route} $>$ ns3\+::\+Ipv4\+Global\+Routing\+::\+Route\+Output (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv4\+Header} \&}]{header, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{oif, }
\item[{{\bf Socket\+::\+Socket\+Errno} \&}]{sockerr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4GlobalRouting_a569e54ce6542c3b88305140cce134d15}{}\label{classns3_1_1Ipv4GlobalRouting_a569e54ce6542c3b88305140cce134d15}


Query routing cache for an existing route, for an outbound packet. 

This lookup is used by transport protocols. It does not cause any packet to be forwarded, and is synchronous. Can be used for multicast or unicast. The Linux equivalent is ip\+\_\+route\+\_\+output()

The header input parameter may have an uninitialized value for the source address, but the destination address should always be properly set by the caller.


\begin{DoxyParams}{Parameters}
{\em p} & packet to be routed. Note that this method may modify the packet. Callers may also pass in a null pointer. \\
\hline
{\em header} & input parameter (used to form key to search for the route) \\
\hline
{\em oif} & Output interface Netdevice. May be zero, or may be bound via socket options to a particular output interface. \\
\hline
{\em sockerr} & Output parameter; socket errno\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a code that indicates what happened in the lookup 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a9c0e9b77772a4974c06ee4577fe60547}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
456 \{
457   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << p << &header << oif << &sockerr);
458 \textcolor{comment}{//}
459 \textcolor{comment}{// First, see if this is a multicast packet we have a route for.  If we}
460 \textcolor{comment}{// have a route, then send the packet down each of the specified interfaces.}
461 \textcolor{comment}{//}
462   \textcolor{keywordflow}{if} (header.GetDestination ().IsMulticast ())
463     \{
464       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Multicast destination-- returning false"});
465       \textcolor{keywordflow}{return} 0; \textcolor{comment}{// Let other routing protocols try to handle this}
466     \}
467 \textcolor{comment}{//}
468 \textcolor{comment}{// See if this is a unicast packet we have a route for.}
469 \textcolor{comment}{//}
470   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Unicast destination- looking up"});
471   Ptr<Ipv4Route> rtentry = \hyperlink{classns3_1_1Ipv4GlobalRouting_a647d7654f270ce66e46f26fc729f1d07}{LookupGlobal} (header.GetDestination (), oif);
472   \textcolor{keywordflow}{if} (rtentry)
473     \{
474       sockerr = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaaa7eb006d73c5ad0117c5591fcb3469f7}{Socket::ERROR\_NOTERROR};
475     \}
476   \textcolor{keywordflow}{else}
477     \{
478       sockerr = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{Socket::ERROR\_NOROUTETOHOST};
479     \}
480   \textcolor{keywordflow}{return} rtentry;
481 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 20


\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!Set\+Ipv4@{Set\+Ipv4}}
\index{Set\+Ipv4@{Set\+Ipv4}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{Set\+Ipv4(\+Ptr$<$ Ipv4 $>$ ipv4)}{SetIpv4(Ptr< Ipv4 > ipv4)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Global\+Routing\+::\+Set\+Ipv4 (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv4} $>$}]{ipv4}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4GlobalRouting_a48499c4690b5699fd12aade2e236f214}{}\label{classns3_1_1Ipv4GlobalRouting_a48499c4690b5699fd12aade2e236f214}

\begin{DoxyParams}{Parameters}
{\em ipv4} & the ipv4 object this routing protocol is being associated with\\
\hline
\end{DoxyParams}
Typically, invoked directly or indirectly from \hyperlink{classns3_1_1Ipv4_a2d165c3bafd4ca580f02a03536db80d3}{ns3\+::\+Ipv4\+::\+Set\+Routing\+Protocol} 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_af3947a05b912ea3f2a1ef0e9777f723e}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
584 \{
585   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << ipv4);
586   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1Ipv4GlobalRouting_a8ca97d33982a32fa41a98b56dbec2edc}{m\_ipv4} == 0 && ipv4 != 0);
587   \hyperlink{classns3_1_1Ipv4GlobalRouting_a8ca97d33982a32fa41a98b56dbec2edc}{m\_ipv4} = ipv4;
588 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!m\+\_\+\+A\+Sexternal\+Routes@{m\+\_\+\+A\+Sexternal\+Routes}}
\index{m\+\_\+\+A\+Sexternal\+Routes@{m\+\_\+\+A\+Sexternal\+Routes}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+\+A\+Sexternal\+Routes}{m_ASexternalRoutes}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf A\+S\+External\+Routes} ns3\+::\+Ipv4\+Global\+Routing\+::m\+\_\+\+A\+Sexternal\+Routes\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4GlobalRouting_ad34f23b0d519a9603b6d9225185fc5ad}{}\label{classns3_1_1Ipv4GlobalRouting_ad34f23b0d519a9603b6d9225185fc5ad}


External routes imported. 

\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!m\+\_\+host\+Routes@{m\+\_\+host\+Routes}}
\index{m\+\_\+host\+Routes@{m\+\_\+host\+Routes}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+host\+Routes}{m_hostRoutes}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Host\+Routes} ns3\+::\+Ipv4\+Global\+Routing\+::m\+\_\+host\+Routes\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4GlobalRouting_adcef09fc8af430a93c9437edfc22511c}{}\label{classns3_1_1Ipv4GlobalRouting_adcef09fc8af430a93c9437edfc22511c}


Routes to hosts. 

\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!m\+\_\+ipv4@{m\+\_\+ipv4}}
\index{m\+\_\+ipv4@{m\+\_\+ipv4}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+ipv4}{m_ipv4}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Ipv4}$>$ ns3\+::\+Ipv4\+Global\+Routing\+::m\+\_\+ipv4\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4GlobalRouting_a8ca97d33982a32fa41a98b56dbec2edc}{}\label{classns3_1_1Ipv4GlobalRouting_a8ca97d33982a32fa41a98b56dbec2edc}


associated I\+Pv4 instance 

\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!m\+\_\+network\+Routes@{m\+\_\+network\+Routes}}
\index{m\+\_\+network\+Routes@{m\+\_\+network\+Routes}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+network\+Routes}{m_networkRoutes}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Network\+Routes} ns3\+::\+Ipv4\+Global\+Routing\+::m\+\_\+network\+Routes\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4GlobalRouting_aef3903663955f6f9a411be06752f3976}{}\label{classns3_1_1Ipv4GlobalRouting_aef3903663955f6f9a411be06752f3976}


Routes to networks. 

\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!m\+\_\+rand@{m\+\_\+rand}}
\index{m\+\_\+rand@{m\+\_\+rand}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+rand}{m_rand}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Uniform\+Random\+Variable}$>$ ns3\+::\+Ipv4\+Global\+Routing\+::m\+\_\+rand\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4GlobalRouting_a3cc74017538737dc3f6ec7f511a3481e}{}\label{classns3_1_1Ipv4GlobalRouting_a3cc74017538737dc3f6ec7f511a3481e}


A uniform random number generator for randomly routing packets among E\+C\+MP. 

\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!m\+\_\+random\+Ecmp\+Routing@{m\+\_\+random\+Ecmp\+Routing}}
\index{m\+\_\+random\+Ecmp\+Routing@{m\+\_\+random\+Ecmp\+Routing}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+random\+Ecmp\+Routing}{m_randomEcmpRouting}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv4\+Global\+Routing\+::m\+\_\+random\+Ecmp\+Routing\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4GlobalRouting_aecf81bc1f0bdbb4fff3fa7c56e4707a4}{}\label{classns3_1_1Ipv4GlobalRouting_aecf81bc1f0bdbb4fff3fa7c56e4707a4}


Set to true if packets are randomly routed among E\+C\+MP; set to false for using only one route consistently. 

\index{ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}!m\+\_\+respond\+To\+Interface\+Events@{m\+\_\+respond\+To\+Interface\+Events}}
\index{m\+\_\+respond\+To\+Interface\+Events@{m\+\_\+respond\+To\+Interface\+Events}!ns3\+::\+Ipv4\+Global\+Routing@{ns3\+::\+Ipv4\+Global\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+respond\+To\+Interface\+Events}{m_respondToInterfaceEvents}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv4\+Global\+Routing\+::m\+\_\+respond\+To\+Interface\+Events\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4GlobalRouting_ae346dbd5b2a06c03df13c1a3987e4719}{}\label{classns3_1_1Ipv4GlobalRouting_ae346dbd5b2a06c03df13c1a3987e4719}


Set to true if this interface should respond to interface events by globallly recomputing routes. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/model/\hyperlink{ipv4-global-routing_8h}{ipv4-\/global-\/routing.\+h}\item 
internet/model/\hyperlink{ipv4-global-routing_8cc}{ipv4-\/global-\/routing.\+cc}\end{DoxyCompactItemize}
