\hypertarget{classns3_1_1aodv_1_1RoutingProtocol}{}\section{ns3\+:\+:aodv\+:\+:Routing\+Protocol Class Reference}
\label{classns3_1_1aodv_1_1RoutingProtocol}\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}


A\+O\+DV routing protocol.  




{\ttfamily \#include $<$aodv-\/routing-\/protocol.\+h$>$}



Inheritance diagram for ns3\+:\+:aodv\+:\+:Routing\+Protocol\+:
% FIG 0


Collaboration diagram for ns3\+:\+:aodv\+:\+:Routing\+Protocol\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ad27c1423db534d49ebbd616b189567ae}{Routing\+Protocol} ()
\begin{DoxyCompactList}\small\item\em c-\/tor \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a27bb582738ca2a7c82ed620b598f0d4c}{$\sim$\+Routing\+Protocol} ()
\item 
virtual void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a338ef59a9193b074021d2ae41cd46c07}{Do\+Dispose} ()
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a71210f21868d71657400f6e616153c83}{Route\+Output} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ oif, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket\+::\+Socket\+Errno} \&sockerr)
\begin{DoxyCompactList}\small\item\em Query routing cache for an existing route, for an outbound packet. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a2190605f405bf68aef54630652988163}{Route\+Input} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ idev, \hyperlink{classns3_1_1Ipv4RoutingProtocol_a3453a85764cbbb1e704da7e919aa5d19}{Unicast\+Forward\+Callback} ucb, \hyperlink{classns3_1_1Ipv4RoutingProtocol_a26e76f7a555462e6c08fceda64a99d58}{Multicast\+Forward\+Callback} mcb, \hyperlink{classns3_1_1Ipv4RoutingProtocol_aa6ffa0159cb143daa3c46d2ba69bb1b9}{Local\+Deliver\+Callback} lcb, \hyperlink{classns3_1_1Ipv4RoutingProtocol_a0348285418c30d5021b08f7a68af21ea}{Error\+Callback} ecb)
\begin{DoxyCompactList}\small\item\em Route an input packet (to be forwarded or locally delivered) \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a006b7deb41f4eb2dc1e0d69d50c5a284}{Notify\+Interface\+Up} (uint32\+\_\+t interface)
\item 
virtual void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a26b018550c9d7195f00bc73b266cc821}{Notify\+Interface\+Down} (uint32\+\_\+t interface)
\item 
virtual void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a8d6ee1881856a557d8c051e40785e51b}{Notify\+Add\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} address)
\item 
virtual void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3ada55a69e945cc414d87566cca0388}{Notify\+Remove\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} address)
\item 
virtual void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a34df0b3e287abea45d48ab7c8162e183}{Set\+Ipv4} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$ ipv4)
\item 
virtual void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a8c8226567e54cf4b98fa43349ed0725a}{Print\+Routing\+Table} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream, \hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295a}{Time\+::\+Unit} unit=\hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295aade8622b06524a328cd3a59db6ccf76af}{Time\+::S}) const 
\begin{DoxyCompactList}\small\item\em Print the Routing Table entries. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_acc957689cc3f248baaaf256b4f146a59}{Get\+Max\+Queue\+Time} () const 
\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a6da1de88e09c9f1fa1983713b5fdbac7}{Set\+Max\+Queue\+Time} (\hyperlink{classns3_1_1Time}{Time} t)
\item 
uint32\+\_\+t \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a083d3102e6470b92f3027bc771a9b454}{Get\+Max\+Queue\+Len} () const 
\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a852b0099e96031ff62da030f773720ac}{Set\+Max\+Queue\+Len} (uint32\+\_\+t len)
\item 
bool \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ae0852a1cb6bfda37aef7289a6df42582}{Get\+Desination\+Only\+Flag} () const 
\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_accd8a8cfc59ed0990c938ddc630d2349}{Set\+Desination\+Only\+Flag} (bool \hyperlink{80211b_8c_ae7ffc1a8f84fa47a0812b2f2b9627132}{f})
\item 
bool \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a06777e1e90af0bf8badbc6e8664dda2c}{Get\+Gratuitous\+Reply\+Flag} () const 
\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a87d5d76fac11f8d674cc599d71e6d3aa}{Set\+Gratuitous\+Reply\+Flag} (bool \hyperlink{80211b_8c_ae7ffc1a8f84fa47a0812b2f2b9627132}{f})
\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aace3f902cf89b88cedd6cc64af35c912}{Set\+Hello\+Enable} (bool \hyperlink{80211b_8c_ae7ffc1a8f84fa47a0812b2f2b9627132}{f})
\item 
bool \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ab1efe83b7bbc5c2b262a71c54000ddba}{Get\+Hello\+Enable} () const 
\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a7b9ff3dbdf0a3cb34965fc271e311eff}{Set\+Broadcast\+Enable} (bool \hyperlink{80211b_8c_ae7ffc1a8f84fa47a0812b2f2b9627132}{f})
\item 
bool \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aabd68c3a12f1de9f3465e5025cdaa5bc}{Get\+Broadcast\+Enable} () const 
\item 
int64\+\_\+t \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac2f2cc4e2b7e6edd4cec0e583e6329bb}{Assign\+Streams} (int64\+\_\+t stream)
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a430a9cb799a51fc76e8e1580edf5f413}{Get\+Type\+Id} (void)
\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const uint32\+\_\+t \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac4a3de99b49ad5f6efc9b71a700f7ec4}{A\+O\+D\+V\+\_\+\+P\+O\+RT} = 654
\begin{DoxyCompactList}\small\item\em U\+DP Port for A\+O\+DV control traffic. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ae42c9385e8ede77f42fdb575e26ef880}{Do\+Initialize} (void)
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a93dd1a9a127ebea592e06e3cf3f5cb11}{Start} ()
\begin{DoxyCompactList}\small\item\em Start protocol operation. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a3e53873fd2f4dad41aeba24b9a16ce48}{Deferred\+Route\+Output} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&header, \hyperlink{classns3_1_1Ipv4RoutingProtocol_a3453a85764cbbb1e704da7e919aa5d19}{Unicast\+Forward\+Callback} ucb, \hyperlink{classns3_1_1Ipv4RoutingProtocol_a0348285418c30d5021b08f7a68af21ea}{Error\+Callback} ecb)
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Queue}{Queue} packet and send route request. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac2a8a2aa27dacd9fec657bcb3495bed3}{Forwarding} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&header, \hyperlink{classns3_1_1Ipv4RoutingProtocol_a3453a85764cbbb1e704da7e919aa5d19}{Unicast\+Forward\+Callback} ucb, \hyperlink{classns3_1_1Ipv4RoutingProtocol_a0348285418c30d5021b08f7a68af21ea}{Error\+Callback} ecb)
\begin{DoxyCompactList}\small\item\em If route exists and valid, forward packet. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a85e17b36131d0582099347a4379bef11}{Schedule\+Rreq\+Retry} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} dst)
\item 
bool \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a204c68e4ce5aa8dc799f9fd039f8cbc7}{Update\+Route\+Life\+Time} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} addr, \hyperlink{classns3_1_1Time}{Time} lt)
\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a0df782358a389aadd46ceffab9535cef}{Update\+Route\+To\+Neighbor} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} sender, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} receiver)
\item 
bool \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a822621de276958cf1d22fb3be536bb49}{Is\+My\+Own\+Address} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} src)
\begin{DoxyCompactList}\small\item\em Check that packet is send from own interface. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$ \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a7cebc7baa398569f432ea2521310dffe}{Find\+Socket\+With\+Interface\+Address} (\hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} iface) const 
\begin{DoxyCompactList}\small\item\em Find unicast socket with local interface address iface. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$ \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac7263145b54db100e0adc56a06d94c6b}{Find\+Subnet\+Broadcast\+Socket\+With\+Interface\+Address} (\hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} iface) const 
\begin{DoxyCompactList}\small\item\em Find subnet directed broadcast socket with local interface address iface. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a5535371d9e72ee97a24be5b67eef982f}{Process\+Hello} (\hyperlink{classns3_1_1aodv_1_1RrepHeader}{Rrep\+Header} const \&rrep\+Header, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} receiver\+Iface\+Addr)
\begin{DoxyCompactList}\small\item\em Process hello message. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa5a41c2ee6ff24a85cfa394d2e061762}{Loopback\+Route} (const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ oif) const 
\begin{DoxyCompactList}\small\item\em Create loopback route for given header. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a41daaba7b2254917daa563575572c1ed}{Send\+To} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$ socket, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} destination)
\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4dc002f2942cbcf436d16183c1c71f10}{Hello\+Timer\+Expire} ()
\begin{DoxyCompactList}\small\item\em Schedule next send of hello message. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee7a58848233510a151f89c92488c0dd}{Rreq\+Rate\+Limit\+Timer\+Expire} ()
\begin{DoxyCompactList}\small\item\em Reset R\+R\+EQ count and schedule R\+R\+EQ rate limit timer with delay 1 sec. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a224b04cf88ed78efbc44014502125b53}{Rerr\+Rate\+Limit\+Timer\+Expire} ()
\begin{DoxyCompactList}\small\item\em Reset R\+E\+RR count and schedule R\+E\+RR rate limit timer with delay 1 sec. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ae2ede2e919e00345ce1ba385c0527611}{Route\+Request\+Timer\+Expire} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} dst)
\begin{DoxyCompactList}\small\item\em Handle route discovery process. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa98fb4cc6871a7f5e918c4992a05b813}{Ack\+Timer\+Expire} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} neighbor, \hyperlink{classns3_1_1Time}{Time} blacklist\+Timeout)
\begin{DoxyCompactList}\small\item\em Mark link to neighbor node as unidirectional for blacklist\+Timeout. \end{DoxyCompactList}\end{DoxyCompactItemize}
\begin{Indent}{\bf Receive control packets}\par
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a08c44000f66533e69bde85d68d75c354}{Recv\+Aodv} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$ socket)
\begin{DoxyCompactList}\small\item\em Receive and process control packet. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_adc8555f0e1e8ba05ea80a412b412d064}{Recv\+Request} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} receiver, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} src)
\begin{DoxyCompactList}\small\item\em Receive R\+R\+EQ. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a15459eff0cb816e8d03a73c78d9cdc9d}{Recv\+Reply} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} my, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} src)
\begin{DoxyCompactList}\small\item\em Receive R\+R\+EP. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a25f07838b23ab376930c4338fa9fbe50}{Recv\+Reply\+Ack} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} neighbor)
\begin{DoxyCompactList}\small\item\em Receive R\+R\+E\+P\+\_\+\+A\+CK. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ae93fba9dbcde4f1eb0f2d7a189e9ae54}{Recv\+Error} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} src)
\begin{DoxyCompactList}\small\item\em Receive R\+E\+RR from node with address src. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf Send}\par
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a7cd2a3baf7b377fbbf85de4275164f2b}{Send\+Packet\+From\+Queue} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} dst, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ route)
\begin{DoxyCompactList}\small\item\em Forward packet from route request queue. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a1b772ee4eda1d3dae376dac6926c0dcf}{Send\+Hello} ()
\begin{DoxyCompactList}\small\item\em Send hello. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a483f8df4d7855b2a71e506f665ca0828}{Send\+Request} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} dst)
\begin{DoxyCompactList}\small\item\em Send R\+R\+EQ. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a39c60e597085c4abc690e6215d302a1f}{Send\+Reply} (\hyperlink{classns3_1_1aodv_1_1RreqHeader}{Rreq\+Header} const \&rreq\+Header, \hyperlink{classns3_1_1aodv_1_1RoutingTableEntry}{Routing\+Table\+Entry} const \&to\+Origin)
\begin{DoxyCompactList}\small\item\em Send R\+R\+EP. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a862f551b61c45fb8de62bfbfa4c0a2ab}{Send\+Reply\+By\+Intermediate\+Node} (\hyperlink{classns3_1_1aodv_1_1RoutingTableEntry}{Routing\+Table\+Entry} \&to\+Dst, \hyperlink{classns3_1_1aodv_1_1RoutingTableEntry}{Routing\+Table\+Entry} \&to\+Origin, bool grat\+Rep)
\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aec193d679517de0a34d2e9d592b7bc77}{Send\+Reply\+Ack} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} neighbor)
\begin{DoxyCompactList}\small\item\em Send R\+R\+E\+P\+\_\+\+A\+CK. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ae2ab3a83b71210d82c458e5e680c1351}{Send\+Rerr\+When\+Breaks\+Link\+To\+Next\+Hop} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} next\+Hop)
\begin{DoxyCompactList}\small\item\em Initiate R\+E\+RR. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_abc216040fe7b7ac100ea7bf2ce9a0bdb}{Send\+Rerr\+Message} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, std\+::vector$<$ \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} $>$ precursors)
\begin{DoxyCompactList}\small\item\em Forward R\+E\+RR. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa8b4c8c3811348aa19e76218523796af}{Send\+Rerr\+When\+No\+Route\+To\+Forward} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} dst, uint32\+\_\+t dst\+Seq\+No, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} origin)
\end{DoxyCompactItemize}
\end{Indent}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
uint32\+\_\+t \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_abecbe245cb328bc299a47f9a8a89aa6e}{m\+\_\+rreq\+Retries}
\begin{DoxyCompactList}\small\item\em Maximum number of retransmissions of R\+R\+EQ with T\+TL = Net\+Diameter to discover a route. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_abc9bab73b39d584866faf18e95704e0f}{m\+\_\+ttl\+Start}
\begin{DoxyCompactList}\small\item\em Initial T\+TL value for R\+R\+EQ. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a7155a27e029832bfd90448bd6ae831db}{m\+\_\+ttl\+Increment}
\begin{DoxyCompactList}\small\item\em T\+TL increment for each attempt using the expanding ring search for R\+R\+EQ dissemination. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a5fa99f38d3f75c20e1a89f4f2e60c42f}{m\+\_\+ttl\+Threshold}
\begin{DoxyCompactList}\small\item\em Maximum T\+TL value for expanding ring search, T\+TL = Net\+Diameter is used beyond this value. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a7805d2b1f8e48f3609f8770255a71e47}{m\+\_\+timeout\+Buffer}
\begin{DoxyCompactList}\small\item\em Provide a buffer for the timeout. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a543abca2b224dcde1362f1050f1887c7}{m\+\_\+rreq\+Rate\+Limit}
\begin{DoxyCompactList}\small\item\em Maximum number of R\+R\+EQ per second. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ad7a69761e61bcea41a2bc87ad8928e2d}{m\+\_\+rerr\+Rate\+Limit}
\begin{DoxyCompactList}\small\item\em Maximum number of R\+E\+ER per second. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a37ec921ef1c48e4d8e7072fe989613d2}{m\+\_\+active\+Route\+Timeout}
\begin{DoxyCompactList}\small\item\em Period of time during which the route is considered to be valid. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a563c2234b89a44628f8e71b38e7c60ec}{m\+\_\+net\+Diameter}
\begin{DoxyCompactList}\small\item\em Net diameter measures the maximum possible number of hops between two nodes in the network. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ad467863779ea1559ad5942ff6c24a706}{m\+\_\+node\+Traversal\+Time}
\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4642e67ba68a7ef40405f5773650ea1a}{m\+\_\+net\+Traversal\+Time}
\begin{DoxyCompactList}\small\item\em Estimate of the average net traversal time. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a491c2fe5559a8153343df590999b468f}{m\+\_\+path\+Discovery\+Time}
\begin{DoxyCompactList}\small\item\em Estimate of maximum time needed to find route in network. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a7681a59458486d0b7a61937a9a90b0a1}{m\+\_\+my\+Route\+Timeout}
\begin{DoxyCompactList}\small\item\em Value of lifetime field in R\+R\+EP generating by this node. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa9750612eb154b537b1d7d0350cb8912}{m\+\_\+hello\+Interval}
\item 
uint32\+\_\+t \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a80e1dc9b9a640570ba5d5270846a2f6f}{m\+\_\+allowed\+Hello\+Loss}
\begin{DoxyCompactList}\small\item\em Number of hello messages which may be loss for valid link. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa337fb24748eda19dda872f172e594a3}{m\+\_\+delete\+Period}
\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aeac3f146e52514d060a69f1a2d62690b}{m\+\_\+next\+Hop\+Wait}
\begin{DoxyCompactList}\small\item\em Period of our waiting for the neighbour\textquotesingle{}s R\+R\+E\+P\+\_\+\+A\+CK. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a23de7759e9c26ded382a09a860b4f987}{m\+\_\+black\+List\+Timeout}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Time}{Time} for which the node is put into the blacklist. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a5ded249d42f2e6364728892f32c15d9b}{m\+\_\+max\+Queue\+Len}
\begin{DoxyCompactList}\small\item\em The maximum number of packets that we allow a routing protocol to buffer. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a33caddd54ebe2e9c177b8986b5abb7ba}{m\+\_\+max\+Queue\+Time}
\begin{DoxyCompactList}\small\item\em The maximum period of time that a routing protocol is allowed to buffer a packet for. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aad49f5618b2843a1ae43a9c50aabc54f}{m\+\_\+destination\+Only}
\begin{DoxyCompactList}\small\item\em Indicates only the destination may respond to this R\+R\+EQ. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a492b1b69b8f91b56ba3301006318a4f3}{m\+\_\+gratuitous\+Reply}
\begin{DoxyCompactList}\small\item\em Indicates whether a gratuitous R\+R\+EP should be unicast to the node originated route discovery. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac1cb4715e9ac42540c051268db368ae8}{m\+\_\+enable\+Hello}
\begin{DoxyCompactList}\small\item\em Indicates whether a hello messages enable. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a15b6c0f3a19ecf251f4492a71e95d080}{m\+\_\+enable\+Broadcast}
\begin{DoxyCompactList}\small\item\em Indicates whether a a broadcast data packets forwarding enable. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$ \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\+\_\+ipv4}
\begin{DoxyCompactList}\small\item\em IP protocol. \end{DoxyCompactList}\item 
std\+::map$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$, \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} $>$ \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\+\_\+socket\+Addresses}
\begin{DoxyCompactList}\small\item\em Raw unicast socket per each IP interface, map socket -\/$>$ iface address (IP + mask) \end{DoxyCompactList}\item 
std\+::map$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$, \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} $>$ \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a3516a9ee6cc1a0ebde0fdc08680dc7c4}{m\+\_\+socket\+Subnet\+Broadcast\+Addresses}
\begin{DoxyCompactList}\small\item\em Raw subnet directed broadcast socket per each IP interface, map socket -\/$>$ iface address (IP + mask) \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a55d7e550c45e7a211ba8781f1b5b0015}{m\+\_\+lo}
\begin{DoxyCompactList}\small\item\em Loopback device used to defer R\+R\+EQ until packet will be fully formed. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1aodv_1_1RoutingTable}{Routing\+Table} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\+\_\+routing\+Table}
\begin{DoxyCompactList}\small\item\em Routing table. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1aodv_1_1RequestQueue}{Request\+Queue} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_afd2e6004e54cac8abd2d95cec3ee9580}{m\+\_\+queue}
\begin{DoxyCompactList}\small\item\em A \char`\"{}drop-\/front\char`\"{} queue used by the routing layer to buffer packets to which it does not have a route. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a0075a9d7db2eeb40aaa9066c0a073942}{m\+\_\+request\+Id}
\begin{DoxyCompactList}\small\item\em Broadcast ID. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_abf5ef6b30d0ccf20b9b5ecf7918f67b2}{m\+\_\+seq\+No}
\begin{DoxyCompactList}\small\item\em Request sequence number. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1aodv_1_1IdCache}{Id\+Cache} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a96743ff957b0a878c23e55a84e209d5d}{m\+\_\+rreq\+Id\+Cache}
\begin{DoxyCompactList}\small\item\em Handle duplicated R\+R\+EQ. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1aodv_1_1DuplicatePacketDetection}{Duplicate\+Packet\+Detection} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a43361f0a08b0c538415910cd904d0af9}{m\+\_\+dpd}
\begin{DoxyCompactList}\small\item\em Handle duplicated broadcast/multicast packets. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1aodv_1_1Neighbors}{Neighbors} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac1f61cf6b680f2fe8c82983d18bfd3cd}{m\+\_\+nb}
\begin{DoxyCompactList}\small\item\em Handle neighbors. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a942f693d81f870c9ed9f155effae9577}{m\+\_\+rreq\+Count}
\begin{DoxyCompactList}\small\item\em Number of R\+R\+E\+Qs used for R\+R\+EQ rate control. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4afc71535ffd2ea1bd7dcb03e3fd4233}{m\+\_\+rerr\+Count}
\begin{DoxyCompactList}\small\item\em Number of R\+E\+R\+Rs used for R\+E\+RR rate control. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Timer}{Timer} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_af02203aca026cce1814848e0b025d212}{m\+\_\+htimer}
\begin{DoxyCompactList}\small\item\em Hello timer. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Timer}{Timer} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac8ad71cc3349d46b7740f59dd18b91b0}{m\+\_\+rreq\+Rate\+Limit\+Timer}
\begin{DoxyCompactList}\small\item\em R\+R\+EQ rate limit timer. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Timer}{Timer} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a0eaa679b6dea15e92c550591eabbccc1}{m\+\_\+rerr\+Rate\+Limit\+Timer}
\begin{DoxyCompactList}\small\item\em R\+E\+RR rate limit timer. \end{DoxyCompactList}\item 
std\+::map$<$ \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address}, \hyperlink{classns3_1_1Timer}{Timer} $>$ \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a3e21cac8acb05e13339eb0cabf13ddcf}{m\+\_\+address\+Req\+Timer}
\begin{DoxyCompactList}\small\item\em Map IP address + R\+R\+EQ timer. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UniformRandomVariable}{Uniform\+Random\+Variable} $>$ \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a62dd29f4ef02720f5c1c00214dfdd7f9}{m\+\_\+uniform\+Random\+Variable}
\begin{DoxyCompactList}\small\item\em Provides uniform random variables. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a0edfc4673f09d0145efba15a1476bc15}{m\+\_\+last\+Bcast\+Time}
\begin{DoxyCompactList}\small\item\em Keep track of the last bcast time. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
A\+O\+DV routing protocol. 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Routing\+Protocol@{Routing\+Protocol}}
\index{Routing\+Protocol@{Routing\+Protocol}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Routing\+Protocol()}{RoutingProtocol()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::aodv\+::\+Routing\+Protocol\+::\+Routing\+Protocol (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_ad27c1423db534d49ebbd616b189567ae}{}\label{classns3_1_1aodv_1_1RoutingProtocol_ad27c1423db534d49ebbd616b189567ae}


c-\/tor 


\begin{DoxyCode}
122                                   :
123   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_abecbe245cb328bc299a47f9a8a89aa6e}{m\_rreqRetries} (2),
124   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_abc9bab73b39d584866faf18e95704e0f}{m\_ttlStart} (1),
125   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a7155a27e029832bfd90448bd6ae831db}{m\_ttlIncrement} (2),
126   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a5fa99f38d3f75c20e1a89f4f2e60c42f}{m\_ttlThreshold} (7),
127   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a7805d2b1f8e48f3609f8770255a71e47}{m\_timeoutBuffer} (2),
128   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a543abca2b224dcde1362f1050f1887c7}{m\_rreqRateLimit} (10),
129   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ad7a69761e61bcea41a2bc87ad8928e2d}{m\_rerrRateLimit} (10),
130   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a37ec921ef1c48e4d8e7072fe989613d2}{m\_activeRouteTimeout} (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (3)),
131   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a563c2234b89a44628f8e71b38e7c60ec}{m\_netDiameter} (35),
132   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ad467863779ea1559ad5942ff6c24a706}{m\_nodeTraversalTime} (\hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (40)),
133   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4642e67ba68a7ef40405f5773650ea1a}{m\_netTraversalTime} (\hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} ((2 * \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a563c2234b89a44628f8e71b38e7c60ec}{m\_netDiameter}) * 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ad467863779ea1559ad5942ff6c24a706}{m\_nodeTraversalTime})),
134   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a491c2fe5559a8153343df590999b468f}{m\_pathDiscoveryTime} ( \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (2 * \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4642e67ba68a7ef40405f5773650ea1a}{m\_netTraversalTime})),
135   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a7681a59458486d0b7a61937a9a90b0a1}{m\_myRouteTimeout} (\hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (2 * \hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{std::max} (
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a491c2fe5559a8153343df590999b468f}{m\_pathDiscoveryTime}, \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a37ec921ef1c48e4d8e7072fe989613d2}{m\_activeRouteTimeout}))),
136   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa9750612eb154b537b1d7d0350cb8912}{m\_helloInterval} (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (1)),
137   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a80e1dc9b9a640570ba5d5270846a2f6f}{m\_allowedHelloLoss} (2),
138   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa337fb24748eda19dda872f172e594a3}{m\_deletePeriod} (\hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (5 * \hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{std::max} (
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a37ec921ef1c48e4d8e7072fe989613d2}{m\_activeRouteTimeout}, \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa9750612eb154b537b1d7d0350cb8912}{m\_helloInterval}))),
139   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aeac3f146e52514d060a69f1a2d62690b}{m\_nextHopWait} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ad467863779ea1559ad5942ff6c24a706}{m\_nodeTraversalTime} + 
      \hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (10)),
140   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a23de7759e9c26ded382a09a860b4f987}{m\_blackListTimeout} (\hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_abecbe245cb328bc299a47f9a8a89aa6e}{m\_rreqRetries} * 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4642e67ba68a7ef40405f5773650ea1a}{m\_netTraversalTime})),
141   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a5ded249d42f2e6364728892f32c15d9b}{m\_maxQueueLen} (64),
142   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a33caddd54ebe2e9c177b8986b5abb7ba}{m\_maxQueueTime} (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (30)),
143   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aad49f5618b2843a1ae43a9c50aabc54f}{m\_destinationOnly} (\textcolor{keyword}{false}),
144   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a492b1b69b8f91b56ba3301006318a4f3}{m\_gratuitousReply} (\textcolor{keyword}{true}),
145   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac1cb4715e9ac42540c051268db368ae8}{m\_enableHello} (\textcolor{keyword}{false}),
146   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa337fb24748eda19dda872f172e594a3}{m\_deletePeriod}),
147   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_afd2e6004e54cac8abd2d95cec3ee9580}{m\_queue} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a5ded249d42f2e6364728892f32c15d9b}{m\_maxQueueLen}, \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a33caddd54ebe2e9c177b8986b5abb7ba}{m\_maxQueueTime}),
148   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a0075a9d7db2eeb40aaa9066c0a073942}{m\_requestId} (0),
149   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_abf5ef6b30d0ccf20b9b5ecf7918f67b2}{m\_seqNo} (0),
150   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a96743ff957b0a878c23e55a84e209d5d}{m\_rreqIdCache} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a491c2fe5559a8153343df590999b468f}{m\_pathDiscoveryTime}),
151   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a43361f0a08b0c538415910cd904d0af9}{m\_dpd} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a491c2fe5559a8153343df590999b468f}{m\_pathDiscoveryTime}),
152   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac1f61cf6b680f2fe8c82983d18bfd3cd}{m\_nb} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa9750612eb154b537b1d7d0350cb8912}{m\_helloInterval}),
153   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a942f693d81f870c9ed9f155effae9577}{m\_rreqCount} (0),
154   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4afc71535ffd2ea1bd7dcb03e3fd4233}{m\_rerrCount} (0),
155   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_af02203aca026cce1814848e0b025d212}{m\_htimer} (\hyperlink{classns3_1_1Timer_a816309b83cd2a35bea47d9bbc6bbf721a07a9dd5063b32fb6cf1f813c6ee7e28e}{Timer::CANCEL\_ON\_DESTROY}),
156   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac8ad71cc3349d46b7740f59dd18b91b0}{m\_rreqRateLimitTimer} (\hyperlink{classns3_1_1Timer_a816309b83cd2a35bea47d9bbc6bbf721a07a9dd5063b32fb6cf1f813c6ee7e28e}{Timer::CANCEL\_ON\_DESTROY}),
157   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a0eaa679b6dea15e92c550591eabbccc1}{m\_rerrRateLimitTimer} (\hyperlink{classns3_1_1Timer_a816309b83cd2a35bea47d9bbc6bbf721a07a9dd5063b32fb6cf1f813c6ee7e28e}{Timer::CANCEL\_ON\_DESTROY}),
158   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a0edfc4673f09d0145efba15a1476bc15}{m\_lastBcastTime} (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (0))
159 \{
160   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac1f61cf6b680f2fe8c82983d18bfd3cd}{m\_nb}.\hyperlink{classns3_1_1aodv_1_1Neighbors_aa034a98c6f91c1a20db28a4774ea13c5}{SetCallback} (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ae2ab3a83b71210d82c458e5e680c1351}{RoutingProtocol::SendRerrWhenBreaksLinkToNextHop}, \textcolor{keyword}{this}));
161 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!````~Routing\+Protocol@{$\sim$\+Routing\+Protocol}}
\index{````~Routing\+Protocol@{$\sim$\+Routing\+Protocol}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{$\sim$\+Routing\+Protocol()}{~RoutingProtocol()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::aodv\+::\+Routing\+Protocol\+::$\sim$\+Routing\+Protocol (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a27bb582738ca2a7c82ed620b598f0d4c}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a27bb582738ca2a7c82ed620b598f0d4c}

\begin{DoxyCode}
298 \{
299 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Ack\+Timer\+Expire@{Ack\+Timer\+Expire}}
\index{Ack\+Timer\+Expire@{Ack\+Timer\+Expire}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Ack\+Timer\+Expire(\+Ipv4\+Address neighbor, Time blacklist\+Timeout)}{AckTimerExpire(Ipv4Address neighbor, Time blacklistTimeout)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Ack\+Timer\+Expire (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{neighbor, }
\item[{{\bf Time}}]{blacklist\+Timeout}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_aa98fb4cc6871a7f5e918c4992a05b813}{}\label{classns3_1_1aodv_1_1RoutingProtocol_aa98fb4cc6871a7f5e918c4992a05b813}


Mark link to neighbor node as unidirectional for blacklist\+Timeout. 


\begin{DoxyCode}
1773 \{
1774   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1775   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_ae82d9009d8a05047561df8896c4c4d57}{MarkLinkAsUnidirectional} (neighbor, blacklistTimeout
      );
1776 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3




Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Assign\+Streams@{Assign\+Streams}}
\index{Assign\+Streams@{Assign\+Streams}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Assign\+Streams(int64\+\_\+t stream)}{AssignStreams(int64_t stream)}}]{\setlength{\rightskip}{0pt plus 5cm}int64\+\_\+t ns3\+::aodv\+::\+Routing\+Protocol\+::\+Assign\+Streams (
\begin{DoxyParamCaption}
\item[{int64\+\_\+t}]{stream}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_ac2f2cc4e2b7e6edd4cec0e583e6329bb}{}\label{classns3_1_1aodv_1_1RoutingProtocol_ac2f2cc4e2b7e6edd4cec0e583e6329bb}
Assign a fixed random variable stream number to the random variables used by this model. Return the number of streams (possibly zero) that have been assigned.


\begin{DoxyParams}{Parameters}
{\em stream} & first stream index to use \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of stream indices assigned by this model 
\end{DoxyReturn}

\begin{DoxyCode}
334 \{
335   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << stream);
336   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a62dd29f4ef02720f5c1c00214dfdd7f9}{m\_uniformRandomVariable}->\hyperlink{classns3_1_1RandomVariableStream_add11aaf975607746b7e271d300659a94}{SetStream} (stream);
337   \textcolor{keywordflow}{return} 1;
338 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5




Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Deferred\+Route\+Output@{Deferred\+Route\+Output}}
\index{Deferred\+Route\+Output@{Deferred\+Route\+Output}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Deferred\+Route\+Output(\+Ptr$<$ const Packet $>$ p, const Ipv4\+Header \&header, Unicast\+Forward\+Callback ucb, Error\+Callback ecb)}{DeferredRouteOutput(Ptr< const Packet > p, const Ipv4Header &header, UnicastForwardCallback ucb, ErrorCallback ecb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Deferred\+Route\+Output (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv4\+Header} \&}]{header, }
\item[{{\bf Unicast\+Forward\+Callback}}]{ucb, }
\item[{{\bf Error\+Callback}}]{ecb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a3e53873fd2f4dad41aeba24b9a16ce48}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a3e53873fd2f4dad41aeba24b9a16ce48}


\hyperlink{classns3_1_1Queue}{Queue} packet and send route request. 


\begin{DoxyCode}
411 \{
412   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} << header);
413   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} != 0 && \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} != Ptr<Packet> ());
414 
415   QueueEntry newEntry (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header, ucb, ecb);
416   \textcolor{keywordtype}{bool} result = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_afd2e6004e54cac8abd2d95cec3ee9580}{m\_queue}.\hyperlink{classns3_1_1aodv_1_1RequestQueue_ac48ac1f8e19e35f239176e1f3ff038ec}{Enqueue} (newEntry);
417   \textcolor{keywordflow}{if} (result)
418     \{
419       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Add packet "} << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->GetUid () << \textcolor{stringliteral}{" to queue. Protocol "} << (uint16\_t) 
      header.GetProtocol ());
420       RoutingTableEntry rt;
421       \textcolor{keywordtype}{bool} result = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a90cbc8a2c65cd68ccdaf768fcbb5d723}{LookupRoute} (header.GetDestination (), rt);
422       \textcolor{keywordflow}{if}(!result || ((rt.GetFlag () != \hyperlink{group__aodv_gga44216921a9c725a5ab8bc19059052a26aba44cda5a5df371b6567f70d7d8311fa}{IN\_SEARCH}) && result))
423         \{
424           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Send new RREQ for outbound packet to "} <<header.GetDestination ());
425           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a483f8df4d7855b2a71e506f665ca0828}{SendRequest} (header.GetDestination ());
426         \}
427     \}
428 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7




Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Do\+Dispose()}{DoDispose()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a338ef59a9193b074021d2ae41cd46c07}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a338ef59a9193b074021d2ae41cd46c07}
Destructor implementation.

This method is called by \hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose()} or by the \hyperlink{classns3_1_1Object}{Object}\textquotesingle{}s destructor, whichever comes first.

Subclasses are expected to implement their real destruction code in an overriden version of this method and chain up to their parent\textquotesingle{}s implementation once they are done. {\itshape i.\+e}, for simplicity, the destructor of every subclass should be empty and its content should be moved to the associated \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a338ef59a9193b074021d2ae41cd46c07}{Do\+Dispose()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.


\begin{DoxyCode}
303 \{
304   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4} = 0;
305   \textcolor{keywordflow}{for} (std::map<Ptr<Socket>, Ipv4InterfaceAddress>::iterator iter =
306          \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.begin (); iter != \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.end (); 
      iter++)
307     \{
308       iter->first->Close ();
309     \}
310   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.clear ();
311   \textcolor{keywordflow}{for} (std::map<Ptr<Socket>, Ipv4InterfaceAddress>::iterator iter =
312          \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a3516a9ee6cc1a0ebde0fdc08680dc7c4}{m\_socketSubnetBroadcastAddresses}.begin (); iter != 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a3516a9ee6cc1a0ebde0fdc08680dc7c4}{m\_socketSubnetBroadcastAddresses}.end (); iter++)
313     \{
314       iter->first->Close ();
315     \}
316   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a3516a9ee6cc1a0ebde0fdc08680dc7c4}{m\_socketSubnetBroadcastAddresses}.clear ();
317   \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{Ipv4RoutingProtocol::DoDispose} ();
318 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Do\+Initialize@{Do\+Initialize}}
\index{Do\+Initialize@{Do\+Initialize}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Do\+Initialize(void)}{DoInitialize(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Do\+Initialize (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_ae42c9385e8ede77f42fdb575e26ef880}{}\label{classns3_1_1aodv_1_1RoutingProtocol_ae42c9385e8ede77f42fdb575e26ef880}
\hyperlink{classns3_1_1Object_af4411cb29971772fcd09203474a95078}{Initialize()} implementation.

This method is called only once by \hyperlink{classns3_1_1Object_af4411cb29971772fcd09203474a95078}{Initialize()}. If the user calls \hyperlink{classns3_1_1Object_af4411cb29971772fcd09203474a95078}{Initialize()} multiple times, \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ae42c9385e8ede77f42fdb575e26ef880}{Do\+Initialize()} is called only the first time.

Subclasses are expected to override this method and chain up to their parent\textquotesingle{}s implementation once they are done. It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} and \hyperlink{classns3_1_1Object_a79dd435d300f3deca814553f561a2922}{Aggregate\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_af8482a521433409fb5c7f749398c9dbe}{ns3\+::\+Object}.


\begin{DoxyCode}
2053 \{
2054   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
2055   uint32\_t startTime;
2056   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac1cb4715e9ac42540c051268db368ae8}{m\_enableHello})
2057     \{
2058       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_af02203aca026cce1814848e0b025d212}{m\_htimer}.\hyperlink{classns3_1_1Timer_a044b29030c9de99298d51ac0ccfc104c}{SetFunction} (&
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4dc002f2942cbcf436d16183c1c71f10}{RoutingProtocol::HelloTimerExpire}, \textcolor{keyword}{this});
2059       startTime = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a62dd29f4ef02720f5c1c00214dfdd7f9}{m\_uniformRandomVariable}->\hyperlink{classns3_1_1RandomVariableStream_a66cd94e6305ce7f000f1a9ff0fcb9aef}{GetInteger} (0, 100);
2060       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Starting at time "} << startTime << \textcolor{stringliteral}{"ms"});
2061       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_af02203aca026cce1814848e0b025d212}{m\_htimer}.\hyperlink{classns3_1_1Timer_ac3345d696887578f518b19f359f7f94b}{Schedule} (\hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (startTime));
2062     \}
2063   \hyperlink{classns3_1_1Object_af8482a521433409fb5c7f749398c9dbe}{Ipv4RoutingProtocol::DoInitialize} ();
2064 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10




Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Find\+Socket\+With\+Interface\+Address@{Find\+Socket\+With\+Interface\+Address}}
\index{Find\+Socket\+With\+Interface\+Address@{Find\+Socket\+With\+Interface\+Address}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Find\+Socket\+With\+Interface\+Address(\+Ipv4\+Interface\+Address iface) const }{FindSocketWithInterfaceAddress(Ipv4InterfaceAddress iface) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Socket} $>$ ns3\+::aodv\+::\+Routing\+Protocol\+::\+Find\+Socket\+With\+Interface\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Interface\+Address}}]{iface}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a7cebc7baa398569f432ea2521310dffe}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a7cebc7baa398569f432ea2521310dffe}


Find unicast socket with local interface address iface. 


\begin{DoxyCode}
2021 \{
2022   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << addr);
2023   \textcolor{keywordflow}{for} (std::map<Ptr<Socket>, Ipv4InterfaceAddress>::const\_iterator j =
2024          \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.begin (); j != \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.end (); ++j)
2025     \{
2026       Ptr<Socket> socket = j->first;
2027       Ipv4InterfaceAddress iface = j->second;
2028       \textcolor{keywordflow}{if} (iface == addr)
2029         \textcolor{keywordflow}{return} socket;
2030     \}
2031   Ptr<Socket> socket;
2032   \textcolor{keywordflow}{return} socket;
2033 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 12


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Find\+Subnet\+Broadcast\+Socket\+With\+Interface\+Address@{Find\+Subnet\+Broadcast\+Socket\+With\+Interface\+Address}}
\index{Find\+Subnet\+Broadcast\+Socket\+With\+Interface\+Address@{Find\+Subnet\+Broadcast\+Socket\+With\+Interface\+Address}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Find\+Subnet\+Broadcast\+Socket\+With\+Interface\+Address(\+Ipv4\+Interface\+Address iface) const }{FindSubnetBroadcastSocketWithInterfaceAddress(Ipv4InterfaceAddress iface) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Socket} $>$ ns3\+::aodv\+::\+Routing\+Protocol\+::\+Find\+Subnet\+Broadcast\+Socket\+With\+Interface\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Interface\+Address}}]{iface}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_ac7263145b54db100e0adc56a06d94c6b}{}\label{classns3_1_1aodv_1_1RoutingProtocol_ac7263145b54db100e0adc56a06d94c6b}


Find subnet directed broadcast socket with local interface address iface. 


\begin{DoxyCode}
2037 \{
2038   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << addr);
2039   \textcolor{keywordflow}{for} (std::map<Ptr<Socket>, Ipv4InterfaceAddress>::const\_iterator j =
2040          \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a3516a9ee6cc1a0ebde0fdc08680dc7c4}{m\_socketSubnetBroadcastAddresses}.begin (); j != 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a3516a9ee6cc1a0ebde0fdc08680dc7c4}{m\_socketSubnetBroadcastAddresses}.end (); ++j)
2041     \{
2042       Ptr<Socket> socket = j->first;
2043       Ipv4InterfaceAddress iface = j->second;
2044       \textcolor{keywordflow}{if} (iface == addr)
2045         \textcolor{keywordflow}{return} socket;
2046     \}
2047   Ptr<Socket> socket;
2048   \textcolor{keywordflow}{return} socket;
2049 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 13


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Forwarding@{Forwarding}}
\index{Forwarding@{Forwarding}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Forwarding(\+Ptr$<$ const Packet $>$ p, const Ipv4\+Header \&header, Unicast\+Forward\+Callback ucb, Error\+Callback ecb)}{Forwarding(Ptr< const Packet > p, const Ipv4Header &header, UnicastForwardCallback ucb, ErrorCallback ecb)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::aodv\+::\+Routing\+Protocol\+::\+Forwarding (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv4\+Header} \&}]{header, }
\item[{{\bf Unicast\+Forward\+Callback}}]{ucb, }
\item[{{\bf Error\+Callback}}]{ecb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_ac2a8a2aa27dacd9fec657bcb3495bed3}{}\label{classns3_1_1aodv_1_1RoutingProtocol_ac2a8a2aa27dacd9fec657bcb3495bed3}


If route exists and valid, forward packet. 


\begin{DoxyCode}
571 \{
572   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
573   Ipv4Address dst = header.GetDestination ();
574   Ipv4Address origin = header.GetSource ();
575   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a2d0250f231e06733c06a43f5ec6a310b}{Purge} ();
576   RoutingTableEntry toDst;
577   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a90cbc8a2c65cd68ccdaf768fcbb5d723}{LookupRoute} (dst, toDst))
578     \{
579       \textcolor{keywordflow}{if} (toDst.GetFlag () == \hyperlink{group__aodv_gga44216921a9c725a5ab8bc19059052a26af5fecee96bb2650aa417994840b43c99}{VALID})
580         \{
581           Ptr<Ipv4Route> route = toDst.GetRoute ();
582           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (route->GetSource ()<<\textcolor{stringliteral}{" forwarding to "} << dst << \textcolor{stringliteral}{" from "} << origin << \textcolor{stringliteral}{
      " packet "} << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->GetUid ());
583 
584           \textcolor{comment}{/*}
585 \textcolor{comment}{           *  Each time a route is used to forward a data packet, its Active Route}
586 \textcolor{comment}{           *  Lifetime field of the source, destination and the next hop on the}
587 \textcolor{comment}{           *  path to the destination is updated to be no less than the current}
588 \textcolor{comment}{           *  time plus ActiveRouteTimeout.}
589 \textcolor{comment}{           */}
590           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a204c68e4ce5aa8dc799f9fd039f8cbc7}{UpdateRouteLifeTime} (origin, \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a37ec921ef1c48e4d8e7072fe989613d2}{m\_activeRouteTimeout});
591           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a204c68e4ce5aa8dc799f9fd039f8cbc7}{UpdateRouteLifeTime} (dst, \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a37ec921ef1c48e4d8e7072fe989613d2}{m\_activeRouteTimeout});
592           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a204c68e4ce5aa8dc799f9fd039f8cbc7}{UpdateRouteLifeTime} (route->GetGateway (), 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a37ec921ef1c48e4d8e7072fe989613d2}{m\_activeRouteTimeout});
593           \textcolor{comment}{/*}
594 \textcolor{comment}{           *  Since the route between each originator and destination pair is expected to be symmetric, the}
595 \textcolor{comment}{           *  Active Route Lifetime for the previous hop, along the reverse path back to the IP source, is
       also updated}
596 \textcolor{comment}{           *  to be no less than the current time plus ActiveRouteTimeout}
597 \textcolor{comment}{           */}
598           RoutingTableEntry toOrigin;
599           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a90cbc8a2c65cd68ccdaf768fcbb5d723}{LookupRoute} (origin, toOrigin);
600           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a204c68e4ce5aa8dc799f9fd039f8cbc7}{UpdateRouteLifeTime} (toOrigin.GetNextHop (), 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a37ec921ef1c48e4d8e7072fe989613d2}{m\_activeRouteTimeout});
601 
602           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac1f61cf6b680f2fe8c82983d18bfd3cd}{m\_nb}.\hyperlink{classns3_1_1aodv_1_1Neighbors_a88577f05c06fbff8cf9ed281e9077f6e}{Update} (route->GetGateway (), \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a37ec921ef1c48e4d8e7072fe989613d2}{m\_activeRouteTimeout});
603           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac1f61cf6b680f2fe8c82983d18bfd3cd}{m\_nb}.\hyperlink{classns3_1_1aodv_1_1Neighbors_a88577f05c06fbff8cf9ed281e9077f6e}{Update} (toOrigin.GetNextHop (), \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a37ec921ef1c48e4d8e7072fe989613d2}{m\_activeRouteTimeout});
604 
605           ucb (route, \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header);
606           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
607         \}
608       \textcolor{keywordflow}{else}
609         \{
610           \textcolor{keywordflow}{if} (toDst.GetValidSeqNo ())
611             \{
612               \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa8b4c8c3811348aa19e76218523796af}{SendRerrWhenNoRouteToForward} (dst, toDst.GetSeqNo (), origin);
613               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Drop packet "} << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->GetUid () << \textcolor{stringliteral}{" because no route to forward
       it."});
614               \textcolor{keywordflow}{return} \textcolor{keyword}{false};
615             \}
616         \}
617     \}
618   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"route not found to "}<< dst << \textcolor{stringliteral}{". Send RERR message."});
619   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Drop packet "} << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->GetUid () << \textcolor{stringliteral}{" because no route to forward it."});
620   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa8b4c8c3811348aa19e76218523796af}{SendRerrWhenNoRouteToForward} (dst, 0, origin);
621   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
622 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 14




Here is the caller graph for this function\+:
% FIG 15


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Get\+Broadcast\+Enable@{Get\+Broadcast\+Enable}}
\index{Get\+Broadcast\+Enable@{Get\+Broadcast\+Enable}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Broadcast\+Enable() const }{GetBroadcastEnable() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::aodv\+::\+Routing\+Protocol\+::\+Get\+Broadcast\+Enable (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_aabd68c3a12f1de9f3465e5025cdaa5bc}{}\label{classns3_1_1aodv_1_1RoutingProtocol_aabd68c3a12f1de9f3465e5025cdaa5bc}

\begin{DoxyCode}
88 \{ \textcolor{keywordflow}{return} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a15b6c0f3a19ecf251f4492a71e95d080}{m\_enableBroadcast}; \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 16




Here is the caller graph for this function\+:
% FIG 17


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Get\+Desination\+Only\+Flag@{Get\+Desination\+Only\+Flag}}
\index{Get\+Desination\+Only\+Flag@{Get\+Desination\+Only\+Flag}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Desination\+Only\+Flag() const }{GetDesinationOnlyFlag() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::aodv\+::\+Routing\+Protocol\+::\+Get\+Desination\+Only\+Flag (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_ae0852a1cb6bfda37aef7289a6df42582}{}\label{classns3_1_1aodv_1_1RoutingProtocol_ae0852a1cb6bfda37aef7289a6df42582}

\begin{DoxyCode}
81 \{ \textcolor{keywordflow}{return} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aad49f5618b2843a1ae43a9c50aabc54f}{m\_destinationOnly}; \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 18


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Get\+Gratuitous\+Reply\+Flag@{Get\+Gratuitous\+Reply\+Flag}}
\index{Get\+Gratuitous\+Reply\+Flag@{Get\+Gratuitous\+Reply\+Flag}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Gratuitous\+Reply\+Flag() const }{GetGratuitousReplyFlag() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::aodv\+::\+Routing\+Protocol\+::\+Get\+Gratuitous\+Reply\+Flag (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a06777e1e90af0bf8badbc6e8664dda2c}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a06777e1e90af0bf8badbc6e8664dda2c}

\begin{DoxyCode}
83 \{ \textcolor{keywordflow}{return} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a492b1b69b8f91b56ba3301006318a4f3}{m\_gratuitousReply}; \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 19


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Get\+Hello\+Enable@{Get\+Hello\+Enable}}
\index{Get\+Hello\+Enable@{Get\+Hello\+Enable}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Hello\+Enable() const }{GetHelloEnable() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::aodv\+::\+Routing\+Protocol\+::\+Get\+Hello\+Enable (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_ab1efe83b7bbc5c2b262a71c54000ddba}{}\label{classns3_1_1aodv_1_1RoutingProtocol_ab1efe83b7bbc5c2b262a71c54000ddba}

\begin{DoxyCode}
86 \{ \textcolor{keywordflow}{return} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac1cb4715e9ac42540c051268db368ae8}{m\_enableHello}; \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 20


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Get\+Max\+Queue\+Len@{Get\+Max\+Queue\+Len}}
\index{Get\+Max\+Queue\+Len@{Get\+Max\+Queue\+Len}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Max\+Queue\+Len() const }{GetMaxQueueLen() const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::aodv\+::\+Routing\+Protocol\+::\+Get\+Max\+Queue\+Len (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a083d3102e6470b92f3027bc771a9b454}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a083d3102e6470b92f3027bc771a9b454}

\begin{DoxyCode}
79 \{ \textcolor{keywordflow}{return} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a5ded249d42f2e6364728892f32c15d9b}{m\_maxQueueLen}; \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 21




Here is the caller graph for this function\+:
% FIG 22


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Get\+Max\+Queue\+Time@{Get\+Max\+Queue\+Time}}
\index{Get\+Max\+Queue\+Time@{Get\+Max\+Queue\+Time}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Max\+Queue\+Time() const }{GetMaxQueueTime() const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::aodv\+::\+Routing\+Protocol\+::\+Get\+Max\+Queue\+Time (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_acc957689cc3f248baaaf256b4f146a59}{}\label{classns3_1_1aodv_1_1RoutingProtocol_acc957689cc3f248baaaf256b4f146a59}

\begin{DoxyCode}
77 \{ \textcolor{keywordflow}{return} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a33caddd54ebe2e9c177b8986b5abb7ba}{m\_maxQueueTime}; \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 23




Here is the caller graph for this function\+:
% FIG 24


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::aodv\+::\+Routing\+Protocol\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a430a9cb799a51fc76e8e1580edf5f413}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a430a9cb799a51fc76e8e1580edf5f413}

\begin{DoxyCode}
165 \{
166   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::aodv::RoutingProtocol"})
167     .SetParent<Ipv4RoutingProtocol> ()
168     .SetGroupName(\textcolor{stringliteral}{"Aodv"})
169     .AddConstructor<\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ad27c1423db534d49ebbd616b189567ae}{RoutingProtocol}> ()
170     .AddAttribute (\textcolor{stringliteral}{"HelloInterval"}, \textcolor{stringliteral}{"HELLO messages emission interval."},
171                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (1)),
172                    MakeTimeAccessor (&\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa9750612eb154b537b1d7d0350cb8912}{RoutingProtocol::m\_helloInterval}),
173                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
174     .AddAttribute (\textcolor{stringliteral}{"TtlStart"}, \textcolor{stringliteral}{"Initial TTL value for RREQ."},
175                    UintegerValue (1),
176                    MakeUintegerAccessor (&\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_abc9bab73b39d584866faf18e95704e0f}{RoutingProtocol::m\_ttlStart}),
177                    MakeUintegerChecker<uint16\_t> ())
178     .AddAttribute (\textcolor{stringliteral}{"TtlIncrement"}, \textcolor{stringliteral}{"TTL increment for each attempt using the expanding ring search for RREQ
       dissemination."},
179                    UintegerValue (2),
180                    MakeUintegerAccessor (&\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a7155a27e029832bfd90448bd6ae831db}{RoutingProtocol::m\_ttlIncrement}),
181                    MakeUintegerChecker<uint16\_t> ())
182     .AddAttribute (\textcolor{stringliteral}{"TtlThreshold"}, \textcolor{stringliteral}{"Maximum TTL value for expanding ring search, TTL = NetDiameter is used
       beyond this value."},
183                    UintegerValue (7),
184                    MakeUintegerAccessor (&\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a5fa99f38d3f75c20e1a89f4f2e60c42f}{RoutingProtocol::m\_ttlThreshold}),
185                    MakeUintegerChecker<uint16\_t> ())
186     .AddAttribute (\textcolor{stringliteral}{"TimeoutBuffer"}, \textcolor{stringliteral}{"Provide a buffer for the timeout."},
187                    UintegerValue (2),
188                    MakeUintegerAccessor (&\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a7805d2b1f8e48f3609f8770255a71e47}{RoutingProtocol::m\_timeoutBuffer})
      ,
189                    MakeUintegerChecker<uint16\_t> ())
190     .AddAttribute (\textcolor{stringliteral}{"RreqRetries"}, \textcolor{stringliteral}{"Maximum number of retransmissions of RREQ to discover a route"},
191                    UintegerValue (2),
192                    MakeUintegerAccessor (&\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_abecbe245cb328bc299a47f9a8a89aa6e}{RoutingProtocol::m\_rreqRetries}),
193                    MakeUintegerChecker<uint32\_t> ())
194     .AddAttribute (\textcolor{stringliteral}{"RreqRateLimit"}, \textcolor{stringliteral}{"Maximum number of RREQ per second."},
195                    UintegerValue (10),
196                    MakeUintegerAccessor (&\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a543abca2b224dcde1362f1050f1887c7}{RoutingProtocol::m\_rreqRateLimit})
      ,
197                    MakeUintegerChecker<uint32\_t> ())
198     .AddAttribute (\textcolor{stringliteral}{"RerrRateLimit"}, \textcolor{stringliteral}{"Maximum number of RERR per second."},
199                    UintegerValue (10),
200                    MakeUintegerAccessor (&\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ad7a69761e61bcea41a2bc87ad8928e2d}{RoutingProtocol::m\_rerrRateLimit})
      ,
201                    MakeUintegerChecker<uint32\_t> ())
202     .AddAttribute (\textcolor{stringliteral}{"NodeTraversalTime"}, \textcolor{stringliteral}{"Conservative estimate of the average one hop traversal time for
       packets and should include "}
203                    \textcolor{stringliteral}{"queuing delays, interrupt processing times and transfer times."},
204                    TimeValue (\hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (40)),
205                    MakeTimeAccessor (&\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ad467863779ea1559ad5942ff6c24a706}{RoutingProtocol::m\_nodeTraversalTime}
      ),
206                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
207     .AddAttribute (\textcolor{stringliteral}{"NextHopWait"}, \textcolor{stringliteral}{"Period of our waiting for the neighbour's RREP\_ACK = 10 ms +
       NodeTraversalTime"},
208                    TimeValue (\hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (50)),
209                    MakeTimeAccessor (&\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aeac3f146e52514d060a69f1a2d62690b}{RoutingProtocol::m\_nextHopWait}),
210                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
211     .AddAttribute (\textcolor{stringliteral}{"ActiveRouteTimeout"}, \textcolor{stringliteral}{"Period of time during which the route is considered to be valid"},
212                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (3)),
213                    MakeTimeAccessor (&\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a37ec921ef1c48e4d8e7072fe989613d2}{RoutingProtocol::m\_activeRouteTimeout}
      ),
214                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
215     .AddAttribute (\textcolor{stringliteral}{"MyRouteTimeout"}, \textcolor{stringliteral}{"Value of lifetime field in RREP generating by this node = 2 *
       max(ActiveRouteTimeout, PathDiscoveryTime)"},
216                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (11.2)),
217                    MakeTimeAccessor (&\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a7681a59458486d0b7a61937a9a90b0a1}{RoutingProtocol::m\_myRouteTimeout}),
218                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
219     .AddAttribute (\textcolor{stringliteral}{"BlackListTimeout"}, \textcolor{stringliteral}{"Time for which the node is put into the blacklist = RreqRetries *
       NetTraversalTime"},
220                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (5.6)),
221                    MakeTimeAccessor (&\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a23de7759e9c26ded382a09a860b4f987}{RoutingProtocol::m\_blackListTimeout}
      ),
222                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
223     .AddAttribute (\textcolor{stringliteral}{"DeletePeriod"}, \textcolor{stringliteral}{"DeletePeriod is intended to provide an upper bound on the time for
       which an upstream node A "}
224                    \textcolor{stringliteral}{"can have a neighbor B as an active next hop for destination D, while B has invalidated
       the route to D."}
225                    \textcolor{stringliteral}{" = 5 * max (HelloInterval, ActiveRouteTimeout)"},
226                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (15)),
227                    MakeTimeAccessor (&\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa337fb24748eda19dda872f172e594a3}{RoutingProtocol::m\_deletePeriod}),
228                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
229     .AddAttribute (\textcolor{stringliteral}{"NetDiameter"}, \textcolor{stringliteral}{"Net diameter measures the maximum possible number of hops between two
       nodes in the network"},
230                    UintegerValue (35),
231                    MakeUintegerAccessor (&\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a563c2234b89a44628f8e71b38e7c60ec}{RoutingProtocol::m\_netDiameter}),
232                    MakeUintegerChecker<uint32\_t> ())
233     .AddAttribute (\textcolor{stringliteral}{"NetTraversalTime"}, \textcolor{stringliteral}{"Estimate of the average net traversal time = 2 * NodeTraversalTime
       * NetDiameter"},
234                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (2.8)),
235                    MakeTimeAccessor (&\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4642e67ba68a7ef40405f5773650ea1a}{RoutingProtocol::m\_netTraversalTime}
      ),
236                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
237     .AddAttribute (\textcolor{stringliteral}{"PathDiscoveryTime"}, \textcolor{stringliteral}{"Estimate of maximum time needed to find route in network = 2 *
       NetTraversalTime"},
238                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (5.6)),
239                    MakeTimeAccessor (&\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a491c2fe5559a8153343df590999b468f}{RoutingProtocol::m\_pathDiscoveryTime}
      ),
240                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
241     .AddAttribute (\textcolor{stringliteral}{"MaxQueueLen"}, \textcolor{stringliteral}{"Maximum number of packets that we allow a routing protocol to buffer."},
242                    UintegerValue (64),
243                    MakeUintegerAccessor (&\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a852b0099e96031ff62da030f773720ac}{RoutingProtocol::SetMaxQueueLen},
244                                          &\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a083d3102e6470b92f3027bc771a9b454}{RoutingProtocol::GetMaxQueueLen}),
245                    MakeUintegerChecker<uint32\_t> ())
246     .AddAttribute (\textcolor{stringliteral}{"MaxQueueTime"}, \textcolor{stringliteral}{"Maximum time packets can be queued (in seconds)"},
247                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (30)),
248                    MakeTimeAccessor (&\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a6da1de88e09c9f1fa1983713b5fdbac7}{RoutingProtocol::SetMaxQueueTime},
249                                      &\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_acc957689cc3f248baaaf256b4f146a59}{RoutingProtocol::GetMaxQueueTime}),
250                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
251     .AddAttribute (\textcolor{stringliteral}{"AllowedHelloLoss"}, \textcolor{stringliteral}{"Number of hello messages which may be loss for valid link."},
252                    UintegerValue (2),
253                    MakeUintegerAccessor (&\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a80e1dc9b9a640570ba5d5270846a2f6f}{RoutingProtocol::m\_allowedHelloLoss}
      ),
254                    MakeUintegerChecker<uint16\_t> ())
255     .AddAttribute (\textcolor{stringliteral}{"GratuitousReply"}, \textcolor{stringliteral}{"Indicates whether a gratuitous RREP should be unicast to the node
       originated route discovery."},
256                    BooleanValue (\textcolor{keyword}{true}),
257                    MakeBooleanAccessor (&\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a87d5d76fac11f8d674cc599d71e6d3aa}{RoutingProtocol::SetGratuitousReplyFlag}
      ,
258                                         &\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a06777e1e90af0bf8badbc6e8664dda2c}{RoutingProtocol::GetGratuitousReplyFlag}
      ),
259                    MakeBooleanChecker ())
260     .AddAttribute (\textcolor{stringliteral}{"DestinationOnly"}, \textcolor{stringliteral}{"Indicates only the destination may respond to this RREQ."},
261                    BooleanValue (\textcolor{keyword}{false}),
262                    MakeBooleanAccessor (&\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_accd8a8cfc59ed0990c938ddc630d2349}{RoutingProtocol::SetDesinationOnlyFlag}
      ,
263                                         &\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ae0852a1cb6bfda37aef7289a6df42582}{RoutingProtocol::GetDesinationOnlyFlag}
      ),
264                    MakeBooleanChecker ())
265     .AddAttribute (\textcolor{stringliteral}{"EnableHello"}, \textcolor{stringliteral}{"Indicates whether a hello messages enable."},
266                    BooleanValue (\textcolor{keyword}{true}),
267                    MakeBooleanAccessor (&\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aace3f902cf89b88cedd6cc64af35c912}{RoutingProtocol::SetHelloEnable},
268                                         &\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ab1efe83b7bbc5c2b262a71c54000ddba}{RoutingProtocol::GetHelloEnable}),
269                    MakeBooleanChecker ())
270     .AddAttribute (\textcolor{stringliteral}{"EnableBroadcast"}, \textcolor{stringliteral}{"Indicates whether a broadcast data packets forwarding enable."},
271                    BooleanValue (\textcolor{keyword}{true}),
272                    MakeBooleanAccessor (&\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a7b9ff3dbdf0a3cb34965fc271e311eff}{RoutingProtocol::SetBroadcastEnable}
      ,
273                                         &\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aabd68c3a12f1de9f3465e5025cdaa5bc}{RoutingProtocol::GetBroadcastEnable}
      ),
274                    MakeBooleanChecker ())
275     .AddAttribute (\textcolor{stringliteral}{"UniformRv"},
276                    \textcolor{stringliteral}{"Access to the underlying UniformRandomVariable"},
277                    StringValue (\textcolor{stringliteral}{"ns3::UniformRandomVariable"}),
278                    MakePointerAccessor (&
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a62dd29f4ef02720f5c1c00214dfdd7f9}{RoutingProtocol::m\_uniformRandomVariable}),
279                    MakePointerChecker<UniformRandomVariable> ())
280   ;
281   \textcolor{keywordflow}{return} tid;
282 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 25


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Hello\+Timer\+Expire@{Hello\+Timer\+Expire}}
\index{Hello\+Timer\+Expire@{Hello\+Timer\+Expire}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Hello\+Timer\+Expire()}{HelloTimerExpire()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Hello\+Timer\+Expire (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a4dc002f2942cbcf436d16183c1c71f10}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a4dc002f2942cbcf436d16183c1c71f10}


Schedule next send of hello message. 


\begin{DoxyCode}
1737 \{
1738   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1739   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} offset = \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (0));
1740   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a0edfc4673f09d0145efba15a1476bc15}{m\_lastBcastTime} > \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (0)))
1741     \{
1742       offset = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} () - \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a0edfc4673f09d0145efba15a1476bc15}{m\_lastBcastTime};
1743       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Hello deferred due to last bcast at:"} << 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a0edfc4673f09d0145efba15a1476bc15}{m\_lastBcastTime});
1744     \}
1745   \textcolor{keywordflow}{else}
1746     \{
1747       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a1b772ee4eda1d3dae376dac6926c0dcf}{SendHello} ();
1748     \}
1749   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_af02203aca026cce1814848e0b025d212}{m\_htimer}.\hyperlink{classns3_1_1Timer_ac8261489cfc3361ab869ea2387cfc841}{Cancel} ();
1750   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} diff = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa9750612eb154b537b1d7d0350cb8912}{m\_helloInterval} - offset;
1751   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_af02203aca026cce1814848e0b025d212}{m\_htimer}.\hyperlink{classns3_1_1Timer_ac3345d696887578f518b19f359f7f94b}{Schedule} (\hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{std::max} (\hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (0)), diff));
1752   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a0edfc4673f09d0145efba15a1476bc15}{m\_lastBcastTime} = \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (0));
1753 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 26




Here is the caller graph for this function\+:
% FIG 27


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Is\+My\+Own\+Address@{Is\+My\+Own\+Address}}
\index{Is\+My\+Own\+Address@{Is\+My\+Own\+Address}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Is\+My\+Own\+Address(\+Ipv4\+Address src)}{IsMyOwnAddress(Ipv4Address src)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::aodv\+::\+Routing\+Protocol\+::\+Is\+My\+Own\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{src}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a822621de276958cf1d22fb3be536bb49}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a822621de276958cf1d22fb3be536bb49}


Check that packet is send from own interface. 


\begin{DoxyCode}
865 \{
866   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << src);
867   \textcolor{keywordflow}{for} (std::map<Ptr<Socket>, Ipv4InterfaceAddress>::const\_iterator j =
868          \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.begin (); j != \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.end (); ++j)
869     \{
870       Ipv4InterfaceAddress iface = j->second;
871       \textcolor{keywordflow}{if} (src == iface.GetLocal ())
872         \{
873           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
874         \}
875     \}
876   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
877 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 28




Here is the caller graph for this function\+:
% FIG 29


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Loopback\+Route@{Loopback\+Route}}
\index{Loopback\+Route@{Loopback\+Route}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Loopback\+Route(const Ipv4\+Header \&header, Ptr$<$ Net\+Device $>$ oif) const }{LoopbackRoute(const Ipv4Header &header, Ptr< NetDevice > oif) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv4\+Route} $>$ ns3\+::aodv\+::\+Routing\+Protocol\+::\+Loopback\+Route (
\begin{DoxyParamCaption}
\item[{const {\bf Ipv4\+Header} \&}]{header, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{oif}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_aa5a41c2ee6ff24a85cfa394d2e061762}{}\label{classns3_1_1aodv_1_1RoutingProtocol_aa5a41c2ee6ff24a85cfa394d2e061762}


Create loopback route for given header. 


\begin{DoxyCode}
881 \{
882   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << hdr);
883   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a55d7e550c45e7a211ba8781f1b5b0015}{m\_lo} != 0);
884   Ptr<Ipv4Route> rt = Create<Ipv4Route> ();
885   rt->SetDestination (hdr.GetDestination ());
886   \textcolor{comment}{//}
887   \textcolor{comment}{// Source address selection here is tricky.  The loopback route is}
888   \textcolor{comment}{// returned when AODV does not have a route; this causes the packet}
889   \textcolor{comment}{// to be looped back and handled (cached) in RouteInput() method}
890   \textcolor{comment}{// while a route is found. However, connection-oriented protocols}
891   \textcolor{comment}{// like TCP need to create an endpoint four-tuple (src, src port,}
892   \textcolor{comment}{// dst, dst port) and create a pseudo-header for checksumming.  So,}
893   \textcolor{comment}{// AODV needs to guess correctly what the eventual source address}
894   \textcolor{comment}{// will be.}
895   \textcolor{comment}{//}
896   \textcolor{comment}{// For single interface, single address nodes, this is not a problem.}
897   \textcolor{comment}{// When there are possibly multiple outgoing interfaces, the policy}
898   \textcolor{comment}{// implemented here is to pick the first available AODV interface.}
899   \textcolor{comment}{// If RouteOutput() caller specified an outgoing interface, that }
900   \textcolor{comment}{// further constrains the selection of source address}
901   \textcolor{comment}{//}
902   std::map<Ptr<Socket>, Ipv4InterfaceAddress>::const\_iterator j = 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.begin ();
903   \textcolor{keywordflow}{if} (oif)
904     \{
905       \textcolor{comment}{// Iterate to find an address on the oif device}
906       \textcolor{keywordflow}{for} (j = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.begin (); j != 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.end (); ++j)
907         \{
908           Ipv4Address addr = j->second.GetLocal ();
909           int32\_t \textcolor{keyword}{interface }= \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetInterfaceForAddress (addr);
910           \textcolor{keywordflow}{if} (oif == \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetNetDevice (static\_cast<uint32\_t> (interface)))
911             \{
912               rt->SetSource (addr);
913               \textcolor{keywordflow}{break};
914             \}
915         \}
916     \}
917   \textcolor{keywordflow}{else}
918     \{
919       rt->SetSource (j->second.GetLocal ());
920     \}
921   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (rt->GetSource () != Ipv4Address (), \textcolor{stringliteral}{"Valid AODV source address not found"});
922   rt->SetGateway (Ipv4Address (\textcolor{stringliteral}{"127.0.0.1"}));
923   rt->SetOutputDevice (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a55d7e550c45e7a211ba8781f1b5b0015}{m\_lo});
924   \textcolor{keywordflow}{return} rt;
925 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 30




Here is the caller graph for this function\+:
% FIG 31


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Notify\+Add\+Address@{Notify\+Add\+Address}}
\index{Notify\+Add\+Address@{Notify\+Add\+Address}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Notify\+Add\+Address(uint32\+\_\+t interface, Ipv4\+Interface\+Address address)}{NotifyAddAddress(uint32_t interface, Ipv4InterfaceAddress address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Notify\+Add\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv4\+Interface\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a8d6ee1881856a557d8c051e40785e51b}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a8d6ee1881856a557d8c051e40785e51b}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
{\em address} & a new address being added to an interface\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified whenever a new address is added to an interface. Typically used to add a \textquotesingle{}network route\textquotesingle{} on an interface. Can be invoked on an up or down interface. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_aef12fcf9cc478536876b0281505d40aa}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
748 \{
749   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" interface "} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} << \textcolor{stringliteral}{" address "} << address);
750   Ptr<Ipv4L3Protocol> l3 = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetObject<Ipv4L3Protocol> ();
751   \textcolor{keywordflow}{if} (!l3->IsUp (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}))
752     \textcolor{keywordflow}{return};
753   \textcolor{keywordflow}{if} (l3->GetNAddresses (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) == 1)
754     \{
755       Ipv4InterfaceAddress iface = l3->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, 0);
756       Ptr<Socket> socket = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a7cebc7baa398569f432ea2521310dffe}{FindSocketWithInterfaceAddress} (iface);
757       \textcolor{keywordflow}{if} (!socket)
758         \{
759           \textcolor{keywordflow}{if} (iface.GetLocal () == Ipv4Address (\textcolor{stringliteral}{"127.0.0.1"}))
760             \textcolor{keywordflow}{return};
761           \textcolor{comment}{// Create a socket to listen only on this interface}
762           Ptr<Socket> socket = \hyperlink{classns3_1_1Socket_ad448a62bb50ad3dbac59c879a885a8d2}{Socket::CreateSocket} (GetObject<Node> (),
763                                                      \hyperlink{classns3_1_1UdpSocketFactory_ad5b47e944de8861e3dc2b6de1ccbdf5b}{UdpSocketFactory::GetTypeId}
       ());
764           \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (socket != 0);
765           socket->SetRecvCallback (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a08c44000f66533e69bde85d68d75c354}{RoutingProtocol::RecvAodv},\textcolor{keyword}{this}));
766           socket->Bind (InetSocketAddress (iface.GetLocal (), \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac4a3de99b49ad5f6efc9b71a700f7ec4}{AODV\_PORT}));
767           socket->BindToNetDevice (l3->GetNetDevice (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}));
768           socket->SetAllowBroadcast (\textcolor{keyword}{true});
769           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.insert (std::make\_pair (socket, iface));
770 
771           \textcolor{comment}{// create also a subnet directed broadcast socket}
772           socket = \hyperlink{classns3_1_1Socket_ad448a62bb50ad3dbac59c879a885a8d2}{Socket::CreateSocket} (GetObject<Node> (),
773                                                        
      \hyperlink{classns3_1_1UdpSocketFactory_ad5b47e944de8861e3dc2b6de1ccbdf5b}{UdpSocketFactory::GetTypeId} ());
774           \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (socket != 0);
775           socket->SetRecvCallback (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a08c44000f66533e69bde85d68d75c354}{RoutingProtocol::RecvAodv}, \textcolor{keyword}{this}));
776           socket->Bind (InetSocketAddress (iface.GetBroadcast (), \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac4a3de99b49ad5f6efc9b71a700f7ec4}{AODV\_PORT}));
777           socket->BindToNetDevice (l3->GetNetDevice (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}));
778           socket->SetAllowBroadcast (\textcolor{keyword}{true});
779           socket->SetIpRecvTtl (\textcolor{keyword}{true});
780           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a3516a9ee6cc1a0ebde0fdc08680dc7c4}{m\_socketSubnetBroadcastAddresses}.insert (std::make\_pair (socket, 
      iface));
781 
782           \textcolor{comment}{// Add local broadcast record to the routing table}
783           Ptr<NetDevice> dev = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetNetDevice (
784               \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetInterfaceForAddress (iface.GetLocal ()));
785           RoutingTableEntry rt (\textcolor{comment}{/*device=*/} dev, \textcolor{comment}{/*dst=*/} iface.GetBroadcast (), \textcolor{comment}{/*know seqno=*/} \textcolor{keyword}{true},
786                                             \textcolor{comment}{/*seqno=*/} 0, \textcolor{comment}{/*iface=*/} iface, \textcolor{comment}{/*hops=*/} 1,
787                                             \textcolor{comment}{/*next hop=*/} iface.GetBroadcast (), \textcolor{comment}{/*lifetime=*/} 
      \hyperlink{classns3_1_1Simulator_aa8dbab888dca7bf3528421d2c5e67f99}{Simulator::GetMaximumSimulationTime} ());
788           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a579e562e38e67d510de1ff2c87806c76}{AddRoute} (rt);
789         \}
790     \}
791   \textcolor{keywordflow}{else}
792     \{
793       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"AODV does not work with more then one address per each interface. Ignore
       added address"});
794     \}
795 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 32


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Notify\+Interface\+Down@{Notify\+Interface\+Down}}
\index{Notify\+Interface\+Down@{Notify\+Interface\+Down}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Notify\+Interface\+Down(uint32\+\_\+t interface)}{NotifyInterfaceDown(uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Notify\+Interface\+Down (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a26b018550c9d7195f00bc73b266cc821}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a26b018550c9d7195f00bc73b266cc821}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified of the state change of an interface in a node. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a90f728b73ccb1806e5a4093ff156f607}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
705 \{
706   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, 0).GetLocal ());
707 
708   \textcolor{comment}{// Disable layer 2 link state monitoring (if possible)}
709   Ptr<Ipv4L3Protocol> l3 = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetObject<Ipv4L3Protocol> ();
710   Ptr<NetDevice> dev = l3->GetNetDevice (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
711   Ptr<WifiNetDevice> wifi = dev->GetObject<WifiNetDevice> ();
712   \textcolor{keywordflow}{if} (wifi != 0)
713     \{
714       Ptr<WifiMac> mac = wifi->GetMac ()->GetObject<AdhocWifiMac> ();
715       \textcolor{keywordflow}{if} (mac != 0)
716         \{
717           mac->TraceDisconnectWithoutContext (\textcolor{stringliteral}{"TxErrHeader"},
718                                               \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac1f61cf6b680f2fe8c82983d18bfd3cd}{m\_nb}.\hyperlink{classns3_1_1aodv_1_1Neighbors_a967f02218f4806c5bbf9ba44ac396601}{GetTxErrorCallback} ());
719           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac1f61cf6b680f2fe8c82983d18bfd3cd}{m\_nb}.\hyperlink{classns3_1_1aodv_1_1Neighbors_a9d4cd87eff2d3287c3114c0ad8963b77}{DelArpCache} (l3->GetInterface (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})->GetArpCache ());
720         \}
721     \}
722 
723   \textcolor{comment}{// Close socket }
724   Ptr<Socket> socket = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a7cebc7baa398569f432ea2521310dffe}{FindSocketWithInterfaceAddress} (
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, 0));
725   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (socket);
726   socket->Close ();
727   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.erase (socket);
728 
729   \textcolor{comment}{// Close socket}
730   socket = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac7263145b54db100e0adc56a06d94c6b}{FindSubnetBroadcastSocketWithInterfaceAddress} (
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, 0));
731   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (socket);
732   socket->Close ();
733   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a3516a9ee6cc1a0ebde0fdc08680dc7c4}{m\_socketSubnetBroadcastAddresses}.erase (socket);
734 
735   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.empty ())
736     \{
737       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"No aodv interfaces"});
738       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_af02203aca026cce1814848e0b025d212}{m\_htimer}.\hyperlink{classns3_1_1Timer_ac8261489cfc3361ab869ea2387cfc841}{Cancel} ();
739       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac1f61cf6b680f2fe8c82983d18bfd3cd}{m\_nb}.\hyperlink{classns3_1_1aodv_1_1Neighbors_a467f3ea5a42d4e32b2fe3bf47bd51991}{Clear} ();
740       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_ab5ff83df58f2178615be8a8881dbbcd6}{Clear} ();
741       \textcolor{keywordflow}{return};
742     \}
743   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_aab31b6642a68709ff3453c72d979ba1a}{DeleteAllRoutesFromInterface} (
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, 0));
744 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 33


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Notify\+Interface\+Up@{Notify\+Interface\+Up}}
\index{Notify\+Interface\+Up@{Notify\+Interface\+Up}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Notify\+Interface\+Up(uint32\+\_\+t interface)}{NotifyInterfaceUp(uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Notify\+Interface\+Up (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a006b7deb41f4eb2dc1e0d69d50c5a284}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a006b7deb41f4eb2dc1e0d69d50c5a284}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified of the state change of an interface in a node. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_aabb99ce7a048e75ff4b36fa9af8745e4}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
648 \{
649   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, 0).GetLocal ());
650   Ptr<Ipv4L3Protocol> l3 = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetObject<Ipv4L3Protocol> ();
651   \textcolor{keywordflow}{if} (l3->GetNAddresses (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) > 1)
652     \{
653       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"AODV does not work with more then one address per each interface."});
654     \}
655   Ipv4InterfaceAddress iface = l3->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, 0);
656   \textcolor{keywordflow}{if} (iface.GetLocal () == Ipv4Address (\textcolor{stringliteral}{"127.0.0.1"}))
657     \textcolor{keywordflow}{return};
658  
659   \textcolor{comment}{// Create a socket to listen only on this interface}
660   Ptr<Socket> socket = \hyperlink{classns3_1_1Socket_ad448a62bb50ad3dbac59c879a885a8d2}{Socket::CreateSocket} (GetObject<Node> (),
661                                              \hyperlink{classns3_1_1UdpSocketFactory_ad5b47e944de8861e3dc2b6de1ccbdf5b}{UdpSocketFactory::GetTypeId} ());
662   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (socket != 0);
663   socket->SetRecvCallback (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a08c44000f66533e69bde85d68d75c354}{RoutingProtocol::RecvAodv}, \textcolor{keyword}{
      this}));
664   socket->Bind (InetSocketAddress (iface.GetLocal (), \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac4a3de99b49ad5f6efc9b71a700f7ec4}{AODV\_PORT}));
665   socket->BindToNetDevice (l3->GetNetDevice (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}));
666   socket->SetAllowBroadcast (\textcolor{keyword}{true});
667   socket->SetIpRecvTtl (\textcolor{keyword}{true});
668   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.insert (std::make\_pair (socket, iface));
669 
670   \textcolor{comment}{// create also a subnet broadcast socket}
671   socket = \hyperlink{classns3_1_1Socket_ad448a62bb50ad3dbac59c879a885a8d2}{Socket::CreateSocket} (GetObject<Node> (),
672                                  \hyperlink{classns3_1_1UdpSocketFactory_ad5b47e944de8861e3dc2b6de1ccbdf5b}{UdpSocketFactory::GetTypeId} ());
673   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (socket != 0);
674   socket->SetRecvCallback (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a08c44000f66533e69bde85d68d75c354}{RoutingProtocol::RecvAodv}, \textcolor{keyword}{
      this}));
675   socket->Bind (InetSocketAddress (iface.GetBroadcast (), \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac4a3de99b49ad5f6efc9b71a700f7ec4}{AODV\_PORT}));
676   socket->BindToNetDevice (l3->GetNetDevice (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}));
677   socket->SetAllowBroadcast (\textcolor{keyword}{true});
678   socket->SetIpRecvTtl (\textcolor{keyword}{true});
679   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a3516a9ee6cc1a0ebde0fdc08680dc7c4}{m\_socketSubnetBroadcastAddresses}.insert (std::make\_pair (socket, iface));
680 
681   \textcolor{comment}{// Add local broadcast record to the routing table}
682   Ptr<NetDevice> dev = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetNetDevice (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetInterfaceForAddress (iface.GetLocal ())
      );
683   RoutingTableEntry rt (\textcolor{comment}{/*device=*/} dev, \textcolor{comment}{/*dst=*/} iface.GetBroadcast (), \textcolor{comment}{/*know seqno=*/} \textcolor{keyword}{true}, \textcolor{comment}{/*seqno=*/} 0
      , \textcolor{comment}{/*iface=*/} iface,
684                                     \textcolor{comment}{/*hops=*/} 1, \textcolor{comment}{/*next hop=*/} iface.GetBroadcast (), \textcolor{comment}{/*lifetime=*/} 
      \hyperlink{classns3_1_1Simulator_aa8dbab888dca7bf3528421d2c5e67f99}{Simulator::GetMaximumSimulationTime} ());
685   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a579e562e38e67d510de1ff2c87806c76}{AddRoute} (rt);
686 
687   \textcolor{keywordflow}{if} (l3->GetInterface (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})->GetArpCache ())
688     \{
689       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac1f61cf6b680f2fe8c82983d18bfd3cd}{m\_nb}.\hyperlink{classns3_1_1aodv_1_1Neighbors_a6c8226b35d9047d9506d42046689ae94}{AddArpCache} (l3->GetInterface (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})->GetArpCache ());
690     \}
691 
692   \textcolor{comment}{// Allow neighbor manager use this interface for layer 2 feedback if possible}
693   Ptr<WifiNetDevice> wifi = dev->GetObject<WifiNetDevice> ();
694   \textcolor{keywordflow}{if} (wifi == 0)
695     \textcolor{keywordflow}{return};
696   Ptr<WifiMac> mac = wifi->GetMac ();
697   \textcolor{keywordflow}{if} (mac == 0)
698     \textcolor{keywordflow}{return};
699 
700   mac->TraceConnectWithoutContext (\textcolor{stringliteral}{"TxErrHeader"}, \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac1f61cf6b680f2fe8c82983d18bfd3cd}{m\_nb}.\hyperlink{classns3_1_1aodv_1_1Neighbors_a967f02218f4806c5bbf9ba44ac396601}{GetTxErrorCallback} ());
701 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 34


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Notify\+Remove\+Address@{Notify\+Remove\+Address}}
\index{Notify\+Remove\+Address@{Notify\+Remove\+Address}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Notify\+Remove\+Address(uint32\+\_\+t interface, Ipv4\+Interface\+Address address)}{NotifyRemoveAddress(uint32_t interface, Ipv4InterfaceAddress address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Notify\+Remove\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv4\+Interface\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_aa3ada55a69e945cc414d87566cca0388}{}\label{classns3_1_1aodv_1_1RoutingProtocol_aa3ada55a69e945cc414d87566cca0388}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
{\em address} & a new address being added to an interface\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified whenever a new address is removed from an interface. Typically used to remove the \textquotesingle{}network route\textquotesingle{} of an interface. Can be invoked on an up or down interface. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a0160e49e509d6699ec837e5485f65cd2}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
799 \{
800   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
801   Ptr<Socket> socket = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a7cebc7baa398569f432ea2521310dffe}{FindSocketWithInterfaceAddress} (address);
802   \textcolor{keywordflow}{if} (socket)
803     \{
804       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_aab31b6642a68709ff3453c72d979ba1a}{DeleteAllRoutesFromInterface} (address);
805       socket->Close ();
806       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.erase (socket);
807 
808       Ptr<Socket> unicastSocket = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac7263145b54db100e0adc56a06d94c6b}{FindSubnetBroadcastSocketWithInterfaceAddress}
       (address);
809       \textcolor{keywordflow}{if} (unicastSocket)
810         \{
811           unicastSocket->Close ();
812           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.erase (unicastSocket);
813         \}
814 
815       Ptr<Ipv4L3Protocol> l3 = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetObject<Ipv4L3Protocol> ();
816       \textcolor{keywordflow}{if} (l3->GetNAddresses (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}))
817         \{
818           Ipv4InterfaceAddress iface = l3->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, 0);
819           \textcolor{comment}{// Create a socket to listen only on this interface}
820           Ptr<Socket> socket = \hyperlink{classns3_1_1Socket_ad448a62bb50ad3dbac59c879a885a8d2}{Socket::CreateSocket} (GetObject<Node> (),
821                                                      \hyperlink{classns3_1_1UdpSocketFactory_ad5b47e944de8861e3dc2b6de1ccbdf5b}{UdpSocketFactory::GetTypeId}
       ());
822           \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (socket != 0);
823           socket->SetRecvCallback (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a08c44000f66533e69bde85d68d75c354}{RoutingProtocol::RecvAodv}, \textcolor{keyword}{this}));
824           \textcolor{comment}{// Bind to any IP address so that broadcasts can be received}
825           socket->Bind (InetSocketAddress (iface.GetLocal (), \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac4a3de99b49ad5f6efc9b71a700f7ec4}{AODV\_PORT}));
826           socket->BindToNetDevice (l3->GetNetDevice (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}));
827           socket->SetAllowBroadcast (\textcolor{keyword}{true});
828           socket->SetIpRecvTtl (\textcolor{keyword}{true});
829           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.insert (std::make\_pair (socket, iface));
830 
831           \textcolor{comment}{// create also a unicast socket}
832           socket = \hyperlink{classns3_1_1Socket_ad448a62bb50ad3dbac59c879a885a8d2}{Socket::CreateSocket} (GetObject<Node> (),
833                                                        
      \hyperlink{classns3_1_1UdpSocketFactory_ad5b47e944de8861e3dc2b6de1ccbdf5b}{UdpSocketFactory::GetTypeId} ());
834           \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (socket != 0);
835           socket->SetRecvCallback (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a08c44000f66533e69bde85d68d75c354}{RoutingProtocol::RecvAodv}, \textcolor{keyword}{this}));
836           socket->Bind (InetSocketAddress (iface.GetBroadcast (), \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac4a3de99b49ad5f6efc9b71a700f7ec4}{AODV\_PORT}));
837           socket->BindToNetDevice (l3->GetNetDevice (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}));
838           socket->SetAllowBroadcast (\textcolor{keyword}{true});
839           socket->SetIpRecvTtl (\textcolor{keyword}{true});
840           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a3516a9ee6cc1a0ebde0fdc08680dc7c4}{m\_socketSubnetBroadcastAddresses}.insert (std::make\_pair (socket, 
      iface));
841 
842           \textcolor{comment}{// Add local broadcast record to the routing table}
843           Ptr<NetDevice> dev = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetNetDevice (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetInterfaceForAddress (iface.
      GetLocal ()));
844           RoutingTableEntry rt (\textcolor{comment}{/*device=*/} dev, \textcolor{comment}{/*dst=*/} iface.GetBroadcast (), \textcolor{comment}{/*know seqno=*/} \textcolor{keyword}{true}, \textcolor{comment}{/*
      seqno=*/} 0, \textcolor{comment}{/*iface=*/} iface,
845                                             \textcolor{comment}{/*hops=*/} 1, \textcolor{comment}{/*next hop=*/} iface.GetBroadcast (), \textcolor{comment}{/*lifetime=*/}
       \hyperlink{classns3_1_1Simulator_aa8dbab888dca7bf3528421d2c5e67f99}{Simulator::GetMaximumSimulationTime} ());
846           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a579e562e38e67d510de1ff2c87806c76}{AddRoute} (rt);
847         \}
848       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.empty ())
849         \{
850           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"No aodv interfaces"});
851           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_af02203aca026cce1814848e0b025d212}{m\_htimer}.\hyperlink{classns3_1_1Timer_ac8261489cfc3361ab869ea2387cfc841}{Cancel} ();
852           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac1f61cf6b680f2fe8c82983d18bfd3cd}{m\_nb}.\hyperlink{classns3_1_1aodv_1_1Neighbors_a467f3ea5a42d4e32b2fe3bf47bd51991}{Clear} ();
853           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_ab5ff83df58f2178615be8a8881dbbcd6}{Clear} ();
854           \textcolor{keywordflow}{return};
855         \}
856     \}
857   \textcolor{keywordflow}{else}
858     \{
859       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Remove address not participating in AODV operation"});
860     \}
861 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 35


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Print\+Routing\+Table@{Print\+Routing\+Table}}
\index{Print\+Routing\+Table@{Print\+Routing\+Table}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Print\+Routing\+Table(\+Ptr$<$ Output\+Stream\+Wrapper $>$ stream, Time\+::\+Unit unit=\+Time\+::\+S) const }{PrintRoutingTable(Ptr< OutputStreamWrapper > stream, Time::Unit unit=Time::S) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Print\+Routing\+Table (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream, }
\item[{{\bf Time\+::\+Unit}}]{unit = {\ttfamily {\bf Time\+::S}}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a8c8226567e54cf4b98fa43349ed0725a}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a8c8226567e54cf4b98fa43349ed0725a}


Print the Routing Table entries. 


\begin{DoxyParams}{Parameters}
{\em stream} & The ostream the Routing table is printed to \\
\hline
{\em unit} & The time unit to be used in the report \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a86ad3fc1d17b06b6553a13b03d7e8cb4}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
322 \{
323   *stream->\hyperlink{classns3_1_1OutputStreamWrapper_a0cf30a4188ab6fdae2b2ab74db11acc2}{GetStream} () << \textcolor{stringliteral}{"Node: "} << \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetObject<Node> ()->GetId ()
324                         << \textcolor{stringliteral}{"; Time: "} << \hyperlink{group__simulator_gac3635e2e87f7ce316c89290ee1b01d0d}{Now}().\hyperlink{classns3_1_1Time_a0bb1110638ce9938248bd07865a328ab}{As} (unit)
325                         << \textcolor{stringliteral}{", Local time: "} << GetObject<Node> ()->GetLocalTime ().As (unit)
326                         << \textcolor{stringliteral}{", AODV Routing table"} << std::endl;
327 
328   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a96ea03f8cb07c9cdedb43e08bc000ae7}{Print} (stream);
329   *stream->\hyperlink{classns3_1_1OutputStreamWrapper_a0cf30a4188ab6fdae2b2ab74db11acc2}{GetStream} () << std::endl;
330 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 36


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Process\+Hello@{Process\+Hello}}
\index{Process\+Hello@{Process\+Hello}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Process\+Hello(\+Rrep\+Header const \&rrep\+Header, Ipv4\+Address receiver\+Iface\+Addr)}{ProcessHello(RrepHeader const &rrepHeader, Ipv4Address receiverIfaceAddr)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Process\+Hello (
\begin{DoxyParamCaption}
\item[{{\bf Rrep\+Header} const \&}]{rrep\+Header, }
\item[{{\bf Ipv4\+Address}}]{receiver\+Iface\+Addr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a5535371d9e72ee97a24be5b67eef982f}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a5535371d9e72ee97a24be5b67eef982f}


Process hello message. 


\begin{DoxyCode}
1601 \{
1602   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \textcolor{stringliteral}{"from "} << rrepHeader.GetDst ());
1603   \textcolor{comment}{/*}
1604 \textcolor{comment}{   *  Whenever a node receives a Hello message from a neighbor, the node}
1605 \textcolor{comment}{   * SHOULD make sure that it has an active route to the neighbor, and}
1606 \textcolor{comment}{   * create one if necessary.}
1607 \textcolor{comment}{   */}
1608   RoutingTableEntry toNeighbor;
1609   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a90cbc8a2c65cd68ccdaf768fcbb5d723}{LookupRoute} (rrepHeader.GetDst (), toNeighbor))
1610     \{
1611       Ptr<NetDevice> dev = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetNetDevice (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetInterfaceForAddress (receiver));
1612       RoutingTableEntry newEntry (\textcolor{comment}{/*device=*/} dev, \textcolor{comment}{/*dst=*/} rrepHeader.GetDst (), \textcolor{comment}{/*validSeqNo=*/} \textcolor{keyword}{true}, \textcolor{comment}{/*
      seqno=*/} rrepHeader.GetDstSeqno (),
1613                                               \textcolor{comment}{/*iface=*/} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetAddress (
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetInterfaceForAddress (receiver), 0),
1614                                               \textcolor{comment}{/*hop=*/} 1, \textcolor{comment}{/*nextHop=*/} rrepHeader.GetDst (), \textcolor{comment}{/*lifeTime=*/} 
      rrepHeader.GetLifeTime ());
1615       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a579e562e38e67d510de1ff2c87806c76}{AddRoute} (newEntry);
1616     \}
1617   \textcolor{keywordflow}{else}
1618     \{
1619       toNeighbor.SetLifeTime (\hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{std::max} (\hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a80e1dc9b9a640570ba5d5270846a2f6f}{m\_allowedHelloLoss} * 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa9750612eb154b537b1d7d0350cb8912}{m\_helloInterval}), toNeighbor.GetLifeTime ()));
1620       toNeighbor.SetSeqNo (rrepHeader.GetDstSeqno ());
1621       toNeighbor.SetValidSeqNo (\textcolor{keyword}{true});
1622       toNeighbor.SetFlag (\hyperlink{group__aodv_gga44216921a9c725a5ab8bc19059052a26af5fecee96bb2650aa417994840b43c99}{VALID});
1623       toNeighbor.SetOutputDevice (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetNetDevice (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetInterfaceForAddress (
      receiver)));
1624       toNeighbor.SetInterface (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetAddress (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetInterfaceForAddress (receiver), 0
      ));
1625       toNeighbor.SetHop (1);
1626       toNeighbor.SetNextHop (rrepHeader.GetDst ());
1627       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a39fb5335110164f4c1b97682a3812dc1}{Update} (toNeighbor);
1628     \}
1629   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac1cb4715e9ac42540c051268db368ae8}{m\_enableHello})
1630     \{
1631       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac1f61cf6b680f2fe8c82983d18bfd3cd}{m\_nb}.\hyperlink{classns3_1_1aodv_1_1Neighbors_a88577f05c06fbff8cf9ed281e9077f6e}{Update} (rrepHeader.GetDst (), \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a80e1dc9b9a640570ba5d5270846a2f6f}{m\_allowedHelloLoss} * 
      m\_helloInterval));
1632     \}
1633 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 37




Here is the caller graph for this function\+:
% FIG 38


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Recv\+Aodv@{Recv\+Aodv}}
\index{Recv\+Aodv@{Recv\+Aodv}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Recv\+Aodv(\+Ptr$<$ Socket $>$ socket)}{RecvAodv(Ptr< Socket > socket)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Recv\+Aodv (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Socket} $>$}]{socket}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a08c44000f66533e69bde85d68d75c354}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a08c44000f66533e69bde85d68d75c354}


Receive and process control packet. 


\begin{DoxyCode}
1064 \{
1065   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << socket);
1066   Address sourceAddress;
1067   Ptr<Packet> packet = socket->\hyperlink{classns3_1_1Socket_af22378d7af9a2745a9eada20210da215}{RecvFrom} (sourceAddress);
1068   InetSocketAddress inetSourceAddr = \hyperlink{classns3_1_1InetSocketAddress_ade776b1109e7b9a7be0b22ced49931e3}{InetSocketAddress::ConvertFrom} (
      sourceAddress);
1069   Ipv4Address sender = inetSourceAddr.GetIpv4 ();
1070   Ipv4Address receiver;
1071 
1072   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.find (socket) != \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.end ())
1073     \{
1074       receiver = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}[socket].GetLocal ();
1075     \}
1076   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a3516a9ee6cc1a0ebde0fdc08680dc7c4}{m\_socketSubnetBroadcastAddresses}.find (socket) != 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a3516a9ee6cc1a0ebde0fdc08680dc7c4}{m\_socketSubnetBroadcastAddresses}.end ())
1077     \{
1078       receiver = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a3516a9ee6cc1a0ebde0fdc08680dc7c4}{m\_socketSubnetBroadcastAddresses}[socket].GetLocal ();
1079     \}
1080   \textcolor{keywordflow}{else}
1081     \{
1082       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\textcolor{keyword}{false}, \textcolor{stringliteral}{"Received a packet from an unknown socket"});
1083     \}
1084   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"AODV node "} << \textcolor{keyword}{this} << \textcolor{stringliteral}{" received a AODV packet from "} << sender << \textcolor{stringliteral}{" to "} << 
      receiver);
1085 
1086   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a0df782358a389aadd46ceffab9535cef}{UpdateRouteToNeighbor} (sender, receiver);
1087   TypeHeader tHeader (\hyperlink{namespacens3_1_1aodv_a8cf417608302ba0ed75225c976944d44ad5f62dc18635d788b1a5b0dd834d46f0}{AODVTYPE\_RREQ});
1088   packet->RemoveHeader (tHeader);
1089   \textcolor{keywordflow}{if} (!tHeader.IsValid ())
1090     \{
1091       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"AODV message "} << packet->GetUid () << \textcolor{stringliteral}{" with unknown type received: "} << 
      tHeader.Get () << \textcolor{stringliteral}{". Drop"});
1092       \textcolor{keywordflow}{return}; \textcolor{comment}{// drop}
1093     \}
1094   \textcolor{keywordflow}{switch} (tHeader.Get ())
1095     \{
1096     \textcolor{keywordflow}{case} \hyperlink{namespacens3_1_1aodv_a8cf417608302ba0ed75225c976944d44ad5f62dc18635d788b1a5b0dd834d46f0}{AODVTYPE\_RREQ}:
1097       \{
1098         \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_adc8555f0e1e8ba05ea80a412b412d064}{RecvRequest} (packet, receiver, sender);
1099         \textcolor{keywordflow}{break};
1100       \}
1101     \textcolor{keywordflow}{case} \hyperlink{namespacens3_1_1aodv_a8cf417608302ba0ed75225c976944d44a034af3d66c569436a630b5ee35399e45}{AODVTYPE\_RREP}:
1102       \{
1103         \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a15459eff0cb816e8d03a73c78d9cdc9d}{RecvReply} (packet, receiver, sender);
1104         \textcolor{keywordflow}{break};
1105       \}
1106     \textcolor{keywordflow}{case} \hyperlink{namespacens3_1_1aodv_a8cf417608302ba0ed75225c976944d44a363aea0c29a02f5899cf088654c6d844}{AODVTYPE\_RERR}:
1107       \{
1108         \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ae93fba9dbcde4f1eb0f2d7a189e9ae54}{RecvError} (packet, sender);
1109         \textcolor{keywordflow}{break};
1110       \}
1111     \textcolor{keywordflow}{case} \hyperlink{namespacens3_1_1aodv_a8cf417608302ba0ed75225c976944d44a1bd445a537508666f448cc9f5a16f6a8}{AODVTYPE\_RREP\_ACK}:
1112       \{
1113         \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a25f07838b23ab376930c4338fa9fbe50}{RecvReplyAck} (sender);
1114         \textcolor{keywordflow}{break};
1115       \}
1116     \}
1117 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 39




Here is the caller graph for this function\+:
% FIG 40


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Recv\+Error@{Recv\+Error}}
\index{Recv\+Error@{Recv\+Error}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Recv\+Error(\+Ptr$<$ Packet $>$ p, Ipv4\+Address src)}{RecvError(Ptr< Packet > p, Ipv4Address src)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Recv\+Error (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{{\bf Ipv4\+Address}}]{src}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_ae93fba9dbcde4f1eb0f2d7a189e9ae54}{}\label{classns3_1_1aodv_1_1RoutingProtocol_ae93fba9dbcde4f1eb0f2d7a189e9ae54}


Receive R\+E\+RR from node with address src. 


\begin{DoxyCode}
1637 \{
1638   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" from "} << src);
1639   RerrHeader rerrHeader;
1640   p->\hyperlink{classns3_1_1Packet_a0961eccf975d75f902d40956c93ba63e}{RemoveHeader} (rerrHeader);
1641   std::map<Ipv4Address, uint32\_t> dstWithNextHopSrc;
1642   std::map<Ipv4Address, uint32\_t> unreachable;
1643   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a0315dabaf863f63cce72eed5c97bd423}{GetListOfDestinationWithNextHop} (src, 
      dstWithNextHopSrc);
1644   std::pair<Ipv4Address, uint32\_t> un;
1645   \textcolor{keywordflow}{while} (rerrHeader.RemoveUnDestination (un))
1646     \{
1647       \textcolor{keywordflow}{for} (std::map<Ipv4Address, uint32\_t>::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} =
1648            dstWithNextHopSrc.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != dstWithNextHopSrc.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
1649       \{
1650         \textcolor{keywordflow}{if} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->first == un.first)
1651           \{
1652             unreachable.insert (un);
1653           \}
1654       \}
1655     \}
1656 
1657   std::vector<Ipv4Address> precursors;
1658   \textcolor{keywordflow}{for} (std::map<Ipv4Address, uint32\_t>::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = unreachable.begin ();
1659        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != unreachable.end ();)
1660     \{
1661       \textcolor{keywordflow}{if} (!rerrHeader.AddUnDestination (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->first, \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second))
1662         \{
1663           TypeHeader typeHeader (\hyperlink{namespacens3_1_1aodv_a8cf417608302ba0ed75225c976944d44a363aea0c29a02f5899cf088654c6d844}{AODVTYPE\_RERR});
1664           Ptr<Packet> packet = Create<Packet> ();
1665           SocketIpTtlTag tag;
1666           tag.SetTtl (1);
1667           packet->AddPacketTag (tag);
1668           packet->AddHeader (rerrHeader);
1669           packet->AddHeader (typeHeader);
1670           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_abc216040fe7b7ac100ea7bf2ce9a0bdb}{SendRerrMessage} (packet, precursors);
1671           rerrHeader.Clear ();
1672         \}
1673       \textcolor{keywordflow}{else}
1674         \{
1675           RoutingTableEntry toDst;
1676           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a90cbc8a2c65cd68ccdaf768fcbb5d723}{LookupRoute} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->first, toDst);
1677           toDst.GetPrecursors (precursors);
1678           ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
1679         \}
1680     \}
1681   \textcolor{keywordflow}{if} (rerrHeader.GetDestCount () != 0)
1682     \{
1683       TypeHeader typeHeader (\hyperlink{namespacens3_1_1aodv_a8cf417608302ba0ed75225c976944d44a363aea0c29a02f5899cf088654c6d844}{AODVTYPE\_RERR});
1684       Ptr<Packet> packet = Create<Packet> ();
1685       SocketIpTtlTag tag;
1686       tag.SetTtl (1);
1687       packet->AddPacketTag (tag);
1688       packet->AddHeader (rerrHeader);
1689       packet->AddHeader (typeHeader);
1690       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_abc216040fe7b7ac100ea7bf2ce9a0bdb}{SendRerrMessage} (packet, precursors);
1691     \}
1692   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a18a8d2cfcba8e03de2a086e4dcaa7d2f}{InvalidateRoutesWithDst} (unreachable);
1693 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 41




Here is the caller graph for this function\+:
% FIG 42


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Recv\+Reply@{Recv\+Reply}}
\index{Recv\+Reply@{Recv\+Reply}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Recv\+Reply(\+Ptr$<$ Packet $>$ p, Ipv4\+Address my, Ipv4\+Address src)}{RecvReply(Ptr< Packet > p, Ipv4Address my, Ipv4Address src)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Recv\+Reply (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{{\bf Ipv4\+Address}}]{my, }
\item[{{\bf Ipv4\+Address}}]{src}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a15459eff0cb816e8d03a73c78d9cdc9d}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a15459eff0cb816e8d03a73c78d9cdc9d}


Receive R\+R\+EP. 


\begin{DoxyCode}
1452 \{
1453   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" src "} << sender);
1454   RrepHeader rrepHeader;
1455   p->\hyperlink{classns3_1_1Packet_a0961eccf975d75f902d40956c93ba63e}{RemoveHeader} (rrepHeader);
1456   Ipv4Address dst = rrepHeader.GetDst ();
1457   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"RREP destination "} << dst << \textcolor{stringliteral}{" RREP origin "} << rrepHeader.GetOrigin ());
1458 
1459   uint8\_t hop = rrepHeader.GetHopCount () + 1;
1460   rrepHeader.SetHopCount (hop);
1461 
1462   \textcolor{comment}{// If RREP is Hello message}
1463   \textcolor{keywordflow}{if} (dst == rrepHeader.GetOrigin ())
1464     \{
1465       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a5535371d9e72ee97a24be5b67eef982f}{ProcessHello} (rrepHeader, receiver);
1466       \textcolor{keywordflow}{return};
1467     \}
1468 
1469   \textcolor{comment}{/*}
1470 \textcolor{comment}{   * If the route table entry to the destination is created or updated, then the following actions occur:}
1471 \textcolor{comment}{   * -  the route is marked as active,}
1472 \textcolor{comment}{   * -  the destination sequence number is marked as valid,}
1473 \textcolor{comment}{   * -  the next hop in the route entry is assigned to be the node from which the RREP is received,}
1474 \textcolor{comment}{   *    which is indicated by the source IP address field in the IP header,}
1475 \textcolor{comment}{   * -  the hop count is set to the value of the hop count from RREP message + 1}
1476 \textcolor{comment}{   * -  the expiry time is set to the current time plus the value of the Lifetime in the RREP message,}
1477 \textcolor{comment}{   * -  and the destination sequence number is the Destination Sequence Number in the RREP message.}
1478 \textcolor{comment}{   */}
1479   Ptr<NetDevice> dev = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetNetDevice (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetInterfaceForAddress (receiver));
1480   RoutingTableEntry newEntry (\textcolor{comment}{/*device=*/} dev, \textcolor{comment}{/*dst=*/} dst, \textcolor{comment}{/*validSeqNo=*/} \textcolor{keyword}{true}, \textcolor{comment}{/*seqno=*/} rrepHeader.
      GetDstSeqno (),
1481                                           \textcolor{comment}{/*iface=*/} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetAddress (
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetInterfaceForAddress (receiver), 0),\textcolor{comment}{/*hop=*/} hop,
1482                                           \textcolor{comment}{/*nextHop=*/} sender, \textcolor{comment}{/*lifeTime=*/} rrepHeader.GetLifeTime ());
1483   RoutingTableEntry toDst;
1484   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a90cbc8a2c65cd68ccdaf768fcbb5d723}{LookupRoute} (dst, toDst))
1485     \{
1486       \textcolor{comment}{/*}
1487 \textcolor{comment}{       * The existing entry is updated only in the following circumstances:}
1488 \textcolor{comment}{       * (i) the sequence number in the routing table is marked as invalid in route table entry.}
1489 \textcolor{comment}{       */}
1490       \textcolor{keywordflow}{if} (!toDst.GetValidSeqNo ())
1491         \{
1492           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a39fb5335110164f4c1b97682a3812dc1}{Update} (newEntry);
1493         \}
1494       \textcolor{comment}{// (ii)the Destination Sequence Number in the RREP is greater than the node's copy of the destination
       sequence number and the known value is valid,}
1495       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((int32\_t (rrepHeader.GetDstSeqno ()) - int32\_t (toDst.GetSeqNo ())) > 0)
1496         \{
1497           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a39fb5335110164f4c1b97682a3812dc1}{Update} (newEntry);
1498         \}
1499       \textcolor{keywordflow}{else}
1500         \{
1501           \textcolor{comment}{// (iii) the sequence numbers are the same, but the route is marked as inactive.}
1502           \textcolor{keywordflow}{if} ((rrepHeader.GetDstSeqno () == toDst.GetSeqNo ()) && (toDst.GetFlag () != 
      \hyperlink{group__aodv_gga44216921a9c725a5ab8bc19059052a26af5fecee96bb2650aa417994840b43c99}{VALID}))
1503             \{
1504               \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a39fb5335110164f4c1b97682a3812dc1}{Update} (newEntry);
1505             \}
1506           \textcolor{comment}{// (iv)  the sequence numbers are the same, and the New Hop Count is smaller than the hop count
       in route table entry.}
1507           \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((rrepHeader.GetDstSeqno () == toDst.GetSeqNo ()) && (hop < toDst.GetHop ()))
1508             \{
1509               \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a39fb5335110164f4c1b97682a3812dc1}{Update} (newEntry);
1510             \}
1511         \}
1512     \}
1513   \textcolor{keywordflow}{else}
1514     \{
1515       \textcolor{comment}{// The forward route for this destination is created if it does not already exist.}
1516       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"add new route"});
1517       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a579e562e38e67d510de1ff2c87806c76}{AddRoute} (newEntry);
1518     \}
1519   \textcolor{comment}{// Acknowledge receipt of the RREP by sending a RREP-ACK message back}
1520   \textcolor{keywordflow}{if} (rrepHeader.GetAckRequired ())
1521     \{
1522       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aec193d679517de0a34d2e9d592b7bc77}{SendReplyAck} (sender);
1523       rrepHeader.SetAckRequired (\textcolor{keyword}{false});
1524     \}
1525   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"receiver "} << receiver << \textcolor{stringliteral}{" origin "} << rrepHeader.GetOrigin ());
1526   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a822621de276958cf1d22fb3be536bb49}{IsMyOwnAddress} (rrepHeader.GetOrigin ()))
1527     \{
1528       \textcolor{keywordflow}{if} (toDst.GetFlag () == \hyperlink{group__aodv_gga44216921a9c725a5ab8bc19059052a26aba44cda5a5df371b6567f70d7d8311fa}{IN\_SEARCH})
1529         \{
1530           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a39fb5335110164f4c1b97682a3812dc1}{Update} (newEntry);
1531           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a3e21cac8acb05e13339eb0cabf13ddcf}{m\_addressReqTimer}[dst].Remove ();
1532           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a3e21cac8acb05e13339eb0cabf13ddcf}{m\_addressReqTimer}.erase (dst);
1533         \}
1534       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a90cbc8a2c65cd68ccdaf768fcbb5d723}{LookupRoute} (dst, toDst);
1535       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a7cd2a3baf7b377fbbf85de4275164f2b}{SendPacketFromQueue} (dst, toDst.GetRoute ());
1536       \textcolor{keywordflow}{return};
1537     \}
1538 
1539   RoutingTableEntry toOrigin;
1540   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a90cbc8a2c65cd68ccdaf768fcbb5d723}{LookupRoute} (rrepHeader.GetOrigin (), toOrigin) || toOrigin.
      GetFlag () == \hyperlink{group__aodv_gga44216921a9c725a5ab8bc19059052a26aba44cda5a5df371b6567f70d7d8311fa}{IN\_SEARCH})
1541     \{
1542       \textcolor{keywordflow}{return}; \textcolor{comment}{// Impossible! drop.}
1543     \}
1544   toOrigin.SetLifeTime (\hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{std::max} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a37ec921ef1c48e4d8e7072fe989613d2}{m\_activeRouteTimeout}, toOrigin.GetLifeTime ()
      ));
1545   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a39fb5335110164f4c1b97682a3812dc1}{Update} (toOrigin);
1546 
1547   \textcolor{comment}{// Update information about precursors}
1548   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a2ca8c3757223d681d4cc39e2028fa7ad}{LookupValidRoute} (rrepHeader.GetDst (), toDst))
1549     \{
1550       toDst.InsertPrecursor (toOrigin.GetNextHop ());
1551       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a39fb5335110164f4c1b97682a3812dc1}{Update} (toDst);
1552 
1553       RoutingTableEntry toNextHopToDst;
1554       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a90cbc8a2c65cd68ccdaf768fcbb5d723}{LookupRoute} (toDst.GetNextHop (), toNextHopToDst);
1555       toNextHopToDst.InsertPrecursor (toOrigin.GetNextHop ());
1556       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a39fb5335110164f4c1b97682a3812dc1}{Update} (toNextHopToDst);
1557 
1558       toOrigin.InsertPrecursor (toDst.GetNextHop ());
1559       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a39fb5335110164f4c1b97682a3812dc1}{Update} (toOrigin);
1560 
1561       RoutingTableEntry toNextHopToOrigin;
1562       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a90cbc8a2c65cd68ccdaf768fcbb5d723}{LookupRoute} (toOrigin.GetNextHop (), toNextHopToOrigin);
1563       toNextHopToOrigin.InsertPrecursor (toDst.GetNextHop ());
1564       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a39fb5335110164f4c1b97682a3812dc1}{Update} (toNextHopToOrigin);
1565     \}
1566   SocketIpTtlTag tag;
1567   p->\hyperlink{classns3_1_1Packet_a078fe922d976a417ab25ba2f3c2fd667}{RemovePacketTag}(tag);
1568   \textcolor{keywordflow}{if} (tag.GetTtl () < 2)
1569     \{
1570       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"TTL exceeded. Drop RREP destination "} << dst << \textcolor{stringliteral}{" origin "} << rrepHeader.
      GetOrigin ());
1571       \textcolor{keywordflow}{return};
1572     \}
1573 
1574   Ptr<Packet> packet = Create<Packet> ();
1575   SocketIpTtlTag ttl;
1576   ttl.SetTtl (tag.GetTtl() - 1);
1577   packet->AddPacketTag (ttl);
1578   packet->AddHeader (rrepHeader);
1579   TypeHeader tHeader (\hyperlink{namespacens3_1_1aodv_a8cf417608302ba0ed75225c976944d44a034af3d66c569436a630b5ee35399e45}{AODVTYPE\_RREP});
1580   packet->AddHeader (tHeader);
1581   Ptr<Socket> socket = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a7cebc7baa398569f432ea2521310dffe}{FindSocketWithInterfaceAddress} (toOrigin.GetInterface 
      ());
1582   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (socket);
1583   socket->SendTo (packet, 0, InetSocketAddress (toOrigin.GetNextHop (), 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac4a3de99b49ad5f6efc9b71a700f7ec4}{AODV\_PORT}));
1584 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 43




Here is the caller graph for this function\+:
% FIG 44


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Recv\+Reply\+Ack@{Recv\+Reply\+Ack}}
\index{Recv\+Reply\+Ack@{Recv\+Reply\+Ack}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Recv\+Reply\+Ack(\+Ipv4\+Address neighbor)}{RecvReplyAck(Ipv4Address neighbor)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Recv\+Reply\+Ack (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{neighbor}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a25f07838b23ab376930c4338fa9fbe50}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a25f07838b23ab376930c4338fa9fbe50}


Receive R\+R\+E\+P\+\_\+\+A\+CK. 


\begin{DoxyCode}
1588 \{
1589   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1590   RoutingTableEntry rt;
1591   \textcolor{keywordflow}{if}(\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a90cbc8a2c65cd68ccdaf768fcbb5d723}{LookupRoute} (neighbor, rt))
1592     \{
1593       rt.m\_ackTimer.Cancel ();
1594       rt.SetFlag (\hyperlink{group__aodv_gga44216921a9c725a5ab8bc19059052a26af5fecee96bb2650aa417994840b43c99}{VALID});
1595       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a39fb5335110164f4c1b97682a3812dc1}{Update} (rt);
1596     \}
1597 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 45




Here is the caller graph for this function\+:
% FIG 46


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Recv\+Request@{Recv\+Request}}
\index{Recv\+Request@{Recv\+Request}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Recv\+Request(\+Ptr$<$ Packet $>$ p, Ipv4\+Address receiver, Ipv4\+Address src)}{RecvRequest(Ptr< Packet > p, Ipv4Address receiver, Ipv4Address src)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Recv\+Request (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{{\bf Ipv4\+Address}}]{receiver, }
\item[{{\bf Ipv4\+Address}}]{src}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_adc8555f0e1e8ba05ea80a412b412d064}{}\label{classns3_1_1aodv_1_1RoutingProtocol_adc8555f0e1e8ba05ea80a412b412d064}


Receive R\+R\+EQ. 


\begin{DoxyCode}
1171 \{
1172   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1173   RreqHeader rreqHeader;
1174   p->\hyperlink{classns3_1_1Packet_a0961eccf975d75f902d40956c93ba63e}{RemoveHeader} (rreqHeader);
1175 
1176   \textcolor{comment}{// A node ignores all RREQs received from any node in its blacklist}
1177   RoutingTableEntry toPrev;
1178   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a90cbc8a2c65cd68ccdaf768fcbb5d723}{LookupRoute} (src, toPrev))
1179     \{
1180       \textcolor{keywordflow}{if} (toPrev.IsUnidirectional ())
1181         \{
1182           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Ignoring RREQ from node in blacklist"});
1183           \textcolor{keywordflow}{return};
1184         \}
1185     \}
1186 
1187   uint32\_t \textcolor{keywordtype}{id} = rreqHeader.GetId ();
1188   Ipv4Address origin = rreqHeader.GetOrigin ();
1189 
1190   \textcolor{comment}{/*}
1191 \textcolor{comment}{   *  Node checks to determine whether it has received a RREQ with the same Originator IP Address and RREQ
       ID.}
1192 \textcolor{comment}{   *  If such a RREQ has been received, the node silently discards the newly received RREQ.}
1193 \textcolor{comment}{   */}
1194   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a96743ff957b0a878c23e55a84e209d5d}{m\_rreqIdCache}.\hyperlink{classns3_1_1aodv_1_1IdCache_a6f32458e4f47ab3d977d8c81742b172c}{IsDuplicate} (origin, \textcolor{keywordtype}{id}))
1195     \{
1196       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Ignoring RREQ due to duplicate"});
1197       \textcolor{keywordflow}{return};
1198     \}
1199 
1200   \textcolor{comment}{// Increment RREQ hop count}
1201   uint8\_t hop = rreqHeader.GetHopCount () + 1;
1202   rreqHeader.SetHopCount (hop);
1203 
1204   \textcolor{comment}{/*}
1205 \textcolor{comment}{   *  When the reverse route is created or updated, the following actions on the route are also carried
       out:}
1206 \textcolor{comment}{   *  1. the Originator Sequence Number from the RREQ is compared to the corresponding destination sequence
       number}
1207 \textcolor{comment}{   *     in the route table entry and copied if greater than the existing value there}
1208 \textcolor{comment}{   *  2. the valid sequence number field is set to true;}
1209 \textcolor{comment}{   *  3. the next hop in the routing table becomes the node from which the  RREQ was received}
1210 \textcolor{comment}{   *  4. the hop count is copied from the Hop Count in the RREQ message;}
1211 \textcolor{comment}{   *  5. the Lifetime is set to be the maximum of (ExistingLifetime, MinimalLifetime), where}
1212 \textcolor{comment}{   *     MinimalLifetime = current time + 2*NetTraversalTime - 2*HopCount*NodeTraversalTime}
1213 \textcolor{comment}{   */}
1214   RoutingTableEntry toOrigin;
1215   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a90cbc8a2c65cd68ccdaf768fcbb5d723}{LookupRoute} (origin, toOrigin))
1216     \{
1217       Ptr<NetDevice> dev = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetNetDevice (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetInterfaceForAddress (receiver));
1218       RoutingTableEntry newEntry (\textcolor{comment}{/*device=*/} dev, \textcolor{comment}{/*dst=*/} origin, \textcolor{comment}{/*validSeno=*/} \textcolor{keyword}{true}, \textcolor{comment}{/*seqNo=*/} 
      rreqHeader.GetOriginSeqno (),
1219                                               \textcolor{comment}{/*iface=*/} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetAddress (
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetInterfaceForAddress (receiver), 0), \textcolor{comment}{/*hops=*/} hop,
1220                                               \textcolor{comment}{/*nextHop*/} src, \textcolor{comment}{/*timeLife=*/} 
      \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} ((2 * \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4642e67ba68a7ef40405f5773650ea1a}{m\_netTraversalTime} - 2 * hop * 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ad467863779ea1559ad5942ff6c24a706}{m\_nodeTraversalTime})));
1221       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a579e562e38e67d510de1ff2c87806c76}{AddRoute} (newEntry);
1222     \}
1223   \textcolor{keywordflow}{else}
1224     \{
1225       \textcolor{keywordflow}{if} (toOrigin.GetValidSeqNo ())
1226         \{
1227           \textcolor{keywordflow}{if} (int32\_t (rreqHeader.GetOriginSeqno ()) - int32\_t (toOrigin.GetSeqNo ()) > 0)
1228             toOrigin.SetSeqNo (rreqHeader.GetOriginSeqno ());
1229         \}
1230       \textcolor{keywordflow}{else}
1231         toOrigin.SetSeqNo (rreqHeader.GetOriginSeqno ());
1232       toOrigin.SetValidSeqNo (\textcolor{keyword}{true});
1233       toOrigin.SetNextHop (src);
1234       toOrigin.SetOutputDevice (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetNetDevice (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetInterfaceForAddress (receiver)
      ));
1235       toOrigin.SetInterface (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetAddress (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetInterfaceForAddress (receiver), 0))
      ;
1236       toOrigin.SetHop (hop);
1237       toOrigin.SetLifeTime (\hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{std::max} (\hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (2 * \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4642e67ba68a7ef40405f5773650ea1a}{m\_netTraversalTime} - 2 * hop 
      * \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ad467863779ea1559ad5942ff6c24a706}{m\_nodeTraversalTime}),
1238                                       toOrigin.GetLifeTime ()));
1239       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a39fb5335110164f4c1b97682a3812dc1}{Update} (toOrigin);
1240       \textcolor{comment}{//m\_nb.Update (src, Time (AllowedHelloLoss * HelloInterval));}
1241     \}
1242 
1243 
1244   RoutingTableEntry toNeighbor;
1245   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a90cbc8a2c65cd68ccdaf768fcbb5d723}{LookupRoute} (src, toNeighbor))
1246     \{
1247       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Neighbor:"} << src << \textcolor{stringliteral}{" not found in routing table. Creating an entry"}); 
1248       Ptr<NetDevice> dev = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetNetDevice (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetInterfaceForAddress (receiver));
1249       RoutingTableEntry newEntry (dev, src, \textcolor{keyword}{false}, rreqHeader.GetOriginSeqno (),
1250                                               \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetAddress (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->
      GetInterfaceForAddress (receiver), 0),
1251                                               1, src, \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a37ec921ef1c48e4d8e7072fe989613d2}{m\_activeRouteTimeout});
1252       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a579e562e38e67d510de1ff2c87806c76}{AddRoute} (newEntry);
1253     \}
1254   \textcolor{keywordflow}{else}
1255     \{
1256       toNeighbor.SetLifeTime (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a37ec921ef1c48e4d8e7072fe989613d2}{m\_activeRouteTimeout});
1257       toNeighbor.SetValidSeqNo (\textcolor{keyword}{false});
1258       toNeighbor.SetSeqNo (rreqHeader.GetOriginSeqno ()); 
1259       toNeighbor.SetFlag (\hyperlink{group__aodv_gga44216921a9c725a5ab8bc19059052a26af5fecee96bb2650aa417994840b43c99}{VALID});
1260       toNeighbor.SetOutputDevice (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetNetDevice (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetInterfaceForAddress (
      receiver)));
1261       toNeighbor.SetInterface (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetAddress (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetInterfaceForAddress (receiver), 0
      ));
1262       toNeighbor.SetHop (1);
1263       toNeighbor.SetNextHop (src);
1264       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a39fb5335110164f4c1b97682a3812dc1}{Update} (toNeighbor);
1265     \}
1266   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac1f61cf6b680f2fe8c82983d18bfd3cd}{m\_nb}.\hyperlink{classns3_1_1aodv_1_1Neighbors_a88577f05c06fbff8cf9ed281e9077f6e}{Update} (src, \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a80e1dc9b9a640570ba5d5270846a2f6f}{m\_allowedHelloLoss} * 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa9750612eb154b537b1d7d0350cb8912}{m\_helloInterval}));
1267 
1268   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (receiver << \textcolor{stringliteral}{" receive RREQ with hop count "} << static\_cast<uint32\_t>(rreqHeader
      .GetHopCount ()) 
1269                          << \textcolor{stringliteral}{" ID "} << rreqHeader.GetId ()
1270                          << \textcolor{stringliteral}{" to destination "} << rreqHeader.GetDst ());
1271 
1272   \textcolor{comment}{//  A node generates a RREP if either:}
1273   \textcolor{comment}{//  (i)  it is itself the destination,}
1274   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a822621de276958cf1d22fb3be536bb49}{IsMyOwnAddress} (rreqHeader.GetDst ()))
1275     \{
1276       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a90cbc8a2c65cd68ccdaf768fcbb5d723}{LookupRoute} (origin, toOrigin);
1277       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Send reply since I am the destination"});
1278       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a39c60e597085c4abc690e6215d302a1f}{SendReply} (rreqHeader, toOrigin);
1279       \textcolor{keywordflow}{return};
1280     \}
1281   \textcolor{comment}{/*}
1282 \textcolor{comment}{   * (ii) or it has an active route to the destination, the destination sequence number in the node's
       existing route table entry for the destination}
1283 \textcolor{comment}{   *      is valid and greater than or equal to the Destination Sequence Number of the RREQ, and the
       "destination only" flag is NOT set.}
1284 \textcolor{comment}{   */}
1285   RoutingTableEntry toDst;
1286   Ipv4Address dst = rreqHeader.GetDst ();
1287   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a90cbc8a2c65cd68ccdaf768fcbb5d723}{LookupRoute} (dst, toDst))
1288     \{
1289       \textcolor{comment}{/*}
1290 \textcolor{comment}{       * Drop RREQ, This node RREP wil make a loop.}
1291 \textcolor{comment}{       */}
1292       \textcolor{keywordflow}{if} (toDst.GetNextHop () == src)
1293         \{
1294           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Drop RREQ from "} << src << \textcolor{stringliteral}{", dest next hop "} << toDst.GetNextHop ());
1295           \textcolor{keywordflow}{return};
1296         \}
1297       \textcolor{comment}{/*}
1298 \textcolor{comment}{       * The Destination Sequence number for the requested destination is set to the maximum of the
       corresponding value}
1299 \textcolor{comment}{       * received in the RREQ message, and the destination sequence value currently maintained by the node
       for the requested destination.}
1300 \textcolor{comment}{       * However, the forwarding node MUST NOT modify its maintained value for the destination sequence
       number, even if the value}
1301 \textcolor{comment}{       * received in the incoming RREQ is larger than the value currently maintained by the forwarding
       node.}
1302 \textcolor{comment}{       */}
1303       \textcolor{keywordflow}{if} ((rreqHeader.GetUnknownSeqno () || (int32\_t (toDst.GetSeqNo ()) - int32\_t (rreqHeader.GetDstSeqno 
      ()) >= 0))
1304           && toDst.GetValidSeqNo () )
1305         \{
1306           \textcolor{keywordflow}{if} (!rreqHeader.GetDestinationOnly () && toDst.GetFlag () == \hyperlink{group__aodv_gga44216921a9c725a5ab8bc19059052a26af5fecee96bb2650aa417994840b43c99}{VALID})
1307             \{
1308               \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a90cbc8a2c65cd68ccdaf768fcbb5d723}{LookupRoute} (origin, toOrigin);
1309               \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a862f551b61c45fb8de62bfbfa4c0a2ab}{SendReplyByIntermediateNode} (toDst, toOrigin, rreqHeader.
      GetGratiousRrep ());
1310               \textcolor{keywordflow}{return};
1311             \}
1312           rreqHeader.SetDstSeqno (toDst.GetSeqNo ());
1313           rreqHeader.SetUnknownSeqno (\textcolor{keyword}{false});
1314         \}
1315     \}
1316 
1317   SocketIpTtlTag tag;
1318   p->\hyperlink{classns3_1_1Packet_a078fe922d976a417ab25ba2f3c2fd667}{RemovePacketTag} (tag);
1319   \textcolor{keywordflow}{if} (tag.GetTtl () < 2)
1320     \{
1321       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"TTL exceeded. Drop RREQ origin "} << src << \textcolor{stringliteral}{" destination "} << dst );
1322       \textcolor{keywordflow}{return};
1323     \}
1324 
1325   \textcolor{keywordflow}{for} (std::map<Ptr<Socket>, Ipv4InterfaceAddress>::const\_iterator j =
1326          \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.begin (); j != \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.end (); ++j)
1327     \{
1328       Ptr<Socket> socket = j->first;
1329       Ipv4InterfaceAddress iface = j->second;
1330       Ptr<Packet> packet = Create<Packet> ();
1331       SocketIpTtlTag ttl;
1332       ttl.SetTtl (tag.GetTtl () - 1);
1333       packet->AddPacketTag (ttl);
1334       packet->AddHeader (rreqHeader);
1335       TypeHeader tHeader (\hyperlink{namespacens3_1_1aodv_a8cf417608302ba0ed75225c976944d44ad5f62dc18635d788b1a5b0dd834d46f0}{AODVTYPE\_RREQ});
1336       packet->AddHeader (tHeader);
1337       \textcolor{comment}{// Send to all-hosts broadcast if on /32 addr, subnet-directed otherwise}
1338       Ipv4Address destination;
1339       \textcolor{keywordflow}{if} (iface.GetMask () == \hyperlink{classns3_1_1Ipv4Mask_af712cbdf28c039025d4aa45fa7e243dd}{Ipv4Mask::GetOnes} ())
1340         \{
1341           destination = Ipv4Address (\textcolor{stringliteral}{"255.255.255.255"});
1342         \}
1343       \textcolor{keywordflow}{else}
1344         \{ 
1345           destination = iface.GetBroadcast ();
1346         \}
1347       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a0edfc4673f09d0145efba15a1476bc15}{m\_lastBcastTime} = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ();
1348       \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (\hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a62dd29f4ef02720f5c1c00214dfdd7f9}{m\_uniformRandomVariable}->\hyperlink{classns3_1_1RandomVariableStream_a66cd94e6305ce7f000f1a9ff0fcb9aef}{GetInteger} (0, 10))), &
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a41daaba7b2254917daa563575572c1ed}{RoutingProtocol::SendTo}, \textcolor{keyword}{this}, socket, packet, destination); 
1349 
1350     \}
1351 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 47




Here is the caller graph for this function\+:
% FIG 48


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Rerr\+Rate\+Limit\+Timer\+Expire@{Rerr\+Rate\+Limit\+Timer\+Expire}}
\index{Rerr\+Rate\+Limit\+Timer\+Expire@{Rerr\+Rate\+Limit\+Timer\+Expire}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Rerr\+Rate\+Limit\+Timer\+Expire()}{RerrRateLimitTimerExpire()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Rerr\+Rate\+Limit\+Timer\+Expire (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a224b04cf88ed78efbc44014502125b53}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a224b04cf88ed78efbc44014502125b53}


Reset R\+E\+RR count and schedule R\+E\+RR rate limit timer with delay 1 sec. 


\begin{DoxyCode}
1765 \{
1766   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1767   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4afc71535ffd2ea1bd7dcb03e3fd4233}{m\_rerrCount} = 0;
1768   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a0eaa679b6dea15e92c550591eabbccc1}{m\_rerrRateLimitTimer}.\hyperlink{classns3_1_1Timer_ac3345d696887578f518b19f359f7f94b}{Schedule} (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (1));
1769 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 49




Here is the caller graph for this function\+:
% FIG 50


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Route\+Input@{Route\+Input}}
\index{Route\+Input@{Route\+Input}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Route\+Input(\+Ptr$<$ const Packet $>$ p, const Ipv4\+Header \&header, Ptr$<$ const Net\+Device $>$ idev, Unicast\+Forward\+Callback ucb, Multicast\+Forward\+Callback mcb, Local\+Deliver\+Callback lcb, Error\+Callback ecb)}{RouteInput(Ptr< const Packet > p, const Ipv4Header &header, Ptr< const NetDevice > idev, UnicastForwardCallback ucb, MulticastForwardCallback mcb, LocalDeliverCallback lcb, ErrorCallback ecb)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::aodv\+::\+Routing\+Protocol\+::\+Route\+Input (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv4\+Header} \&}]{header, }
\item[{{\bf Ptr}$<$ const {\bf Net\+Device} $>$}]{idev, }
\item[{{\bf Unicast\+Forward\+Callback}}]{ucb, }
\item[{{\bf Multicast\+Forward\+Callback}}]{mcb, }
\item[{{\bf Local\+Deliver\+Callback}}]{lcb, }
\item[{{\bf Error\+Callback}}]{ecb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a2190605f405bf68aef54630652988163}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a2190605f405bf68aef54630652988163}


Route an input packet (to be forwarded or locally delivered) 

This lookup is used in the forwarding process. The packet is handed over to the \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol}, and will get forwarded onward by one of the callbacks. The Linux equivalent is ip\+\_\+route\+\_\+input(). There are four valid outcomes, and a matching callbacks to handle each.


\begin{DoxyParams}{Parameters}
{\em p} & received packet \\
\hline
{\em header} & input parameter used to form a search key for a route \\
\hline
{\em idev} & Pointer to ingress network device \\
\hline
{\em ucb} & \hyperlink{classns3_1_1Callback}{Callback} for the case in which the packet is to be forwarded as unicast \\
\hline
{\em mcb} & \hyperlink{classns3_1_1Callback}{Callback} for the case in which the packet is to be forwarded as multicast \\
\hline
{\em lcb} & \hyperlink{classns3_1_1Callback}{Callback} for the case in which the packet is to be locally delivered \\
\hline
{\em ecb} & \hyperlink{classns3_1_1Callback}{Callback} to call if there is an error in forwarding \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} takes responsibility for forwarding or delivering the packet, false otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a67e815ff40ebb9f5f4eec4e22e23132e}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
434 \{
435   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->GetUid () << header.GetDestination () << idev->GetAddress ())
      ;
436   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.empty ())
437     \{
438       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"No aodv interfaces"});
439       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
440     \}
441   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4} != 0);
442   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} != 0);
443   \textcolor{comment}{// Check if input device supports IP}
444   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetInterfaceForDevice (idev) >= 0);
445   int32\_t iif = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetInterfaceForDevice (idev);
446 
447   Ipv4Address dst = header.GetDestination ();
448   Ipv4Address origin = header.GetSource ();
449 
450   \textcolor{comment}{// Deferred route request}
451   \textcolor{keywordflow}{if} (idev == \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a55d7e550c45e7a211ba8781f1b5b0015}{m\_lo})
452     \{
453       DeferredRouteOutputTag tag;
454       \textcolor{keywordflow}{if} (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->PeekPacketTag (tag))
455         \{
456           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a3e53873fd2f4dad41aeba24b9a16ce48}{DeferredRouteOutput} (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header, ucb, ecb);
457           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
458         \}
459     \}
460 
461   \textcolor{comment}{// Duplicate of own packet}
462   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a822621de276958cf1d22fb3be536bb49}{IsMyOwnAddress} (origin))
463     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
464 
465   \textcolor{comment}{// AODV is not a multicast routing protocol}
466   \textcolor{keywordflow}{if} (dst.IsMulticast ())
467     \{
468       \textcolor{keywordflow}{return} \textcolor{keyword}{false}; 
469     \}
470 
471   \textcolor{comment}{// Broadcast local delivery/forwarding}
472   \textcolor{keywordflow}{for} (std::map<Ptr<Socket>, Ipv4InterfaceAddress>::const\_iterator j =
473          \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.begin (); j != \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.end (); ++j)
474     \{
475       Ipv4InterfaceAddress iface = j->second;
476       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetInterfaceForAddress (iface.GetLocal ()) == iif)
477         \textcolor{keywordflow}{if} (dst == iface.GetBroadcast () || dst.IsBroadcast ())
478           \{
479             \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a43361f0a08b0c538415910cd904d0af9}{m\_dpd}.\hyperlink{classns3_1_1aodv_1_1DuplicatePacketDetection_a997ef453692de951dad7485215985a6b}{IsDuplicate} (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header))
480               \{
481                 \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Duplicated packet "} << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->GetUid () << \textcolor{stringliteral}{" from "} << origin << \textcolor{stringliteral}{".
       Drop."});
482                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};
483               \}
484             \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a204c68e4ce5aa8dc799f9fd039f8cbc7}{UpdateRouteLifeTime} (origin, \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a37ec921ef1c48e4d8e7072fe989613d2}{m\_activeRouteTimeout});
485             Ptr<Packet> packet = \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->Copy ();
486             \textcolor{keywordflow}{if} (lcb.IsNull () == \textcolor{keyword}{false})
487               \{
488                 \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Broadcast local delivery to "} << iface.GetLocal ());
489                 lcb (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header, iif);
490                 \textcolor{comment}{// Fall through to additional processing}
491               \}
492             \textcolor{keywordflow}{else}
493               \{
494                 \hyperlink{group__logging_ga0261a8db1d4ac5f79417d117634fd455}{NS\_LOG\_ERROR} (\textcolor{stringliteral}{"Unable to deliver packet locally due to null callback "} << 
      \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->GetUid () << \textcolor{stringliteral}{" from "} << origin);
495                 ecb (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{Socket::ERROR\_NOROUTETOHOST});
496               \}
497             \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a15b6c0f3a19ecf251f4492a71e95d080}{m\_enableBroadcast})
498               \{
499                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};
500               \}
501             \textcolor{keywordflow}{if} (header.GetProtocol () == \hyperlink{classns3_1_1UdpL4Protocol_ad370801b3d1a166e831020a777c41047}{UdpL4Protocol::PROT\_NUMBER})
502               \{
503                 UdpHeader udpHeader;
504                 \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->PeekHeader (udpHeader);
505                 \textcolor{keywordflow}{if} (udpHeader.GetDestinationPort () == \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac4a3de99b49ad5f6efc9b71a700f7ec4}{AODV\_PORT})
506                   \{
507                     \textcolor{comment}{// AODV packets sent in broadcast are already managed}
508                     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
509                   \}
510               \}
511             \textcolor{keywordflow}{if} (header.GetTtl () > 1)
512               \{
513                 \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Forward broadcast. TTL "} << (uint16\_t) header.GetTtl ());
514                 RoutingTableEntry toBroadcast;
515                 \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a90cbc8a2c65cd68ccdaf768fcbb5d723}{LookupRoute} (dst, toBroadcast))
516                   \{
517                     Ptr<Ipv4Route> route = toBroadcast.GetRoute ();
518                     ucb (route, packet, header);
519                   \}
520                 \textcolor{keywordflow}{else}
521                   \{
522                     \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"No route to forward broadcast. Drop packet "} << 
      \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->GetUid ());
523                   \}
524               \}
525             \textcolor{keywordflow}{else}
526               \{
527                 \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"TTL exceeded. Drop packet "} << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->GetUid ());
528               \}
529             \textcolor{keywordflow}{return} \textcolor{keyword}{true};
530           \}
531     \}
532 
533   \textcolor{comment}{// Unicast local delivery}
534   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->IsDestinationAddress (dst, iif))
535     \{
536       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a204c68e4ce5aa8dc799f9fd039f8cbc7}{UpdateRouteLifeTime} (origin, \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a37ec921ef1c48e4d8e7072fe989613d2}{m\_activeRouteTimeout});
537       RoutingTableEntry toOrigin;
538       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a2ca8c3757223d681d4cc39e2028fa7ad}{LookupValidRoute} (origin, toOrigin))
539         \{
540           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a204c68e4ce5aa8dc799f9fd039f8cbc7}{UpdateRouteLifeTime} (toOrigin.GetNextHop (), 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a37ec921ef1c48e4d8e7072fe989613d2}{m\_activeRouteTimeout});
541           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac1f61cf6b680f2fe8c82983d18bfd3cd}{m\_nb}.\hyperlink{classns3_1_1aodv_1_1Neighbors_a88577f05c06fbff8cf9ed281e9077f6e}{Update} (toOrigin.GetNextHop (), \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a37ec921ef1c48e4d8e7072fe989613d2}{m\_activeRouteTimeout});
542         \}
543       \textcolor{keywordflow}{if} (lcb.IsNull () == \textcolor{keyword}{false})
544         \{
545           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Unicast local delivery to "} << dst);
546           lcb (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header, iif);
547         \}
548       \textcolor{keywordflow}{else}
549         \{
550           \hyperlink{group__logging_ga0261a8db1d4ac5f79417d117634fd455}{NS\_LOG\_ERROR} (\textcolor{stringliteral}{"Unable to deliver packet locally due to null callback "} << 
      \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->GetUid () << \textcolor{stringliteral}{" from "} << origin);
551           ecb (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{Socket::ERROR\_NOROUTETOHOST});
552         \}
553       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
554     \}
555 
556   \textcolor{comment}{// Check if input device supports IP forwarding}
557   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->IsForwarding (iif) == \textcolor{keyword}{false})
558     \{
559       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Forwarding disabled for this interface"});
560       ecb (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{Socket::ERROR\_NOROUTETOHOST});
561       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
562     \}
563 
564   \textcolor{comment}{// Forwarding}
565   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac2a8a2aa27dacd9fec657bcb3495bed3}{Forwarding} (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header, ucb, ecb);
566 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 51


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Route\+Output@{Route\+Output}}
\index{Route\+Output@{Route\+Output}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Route\+Output(\+Ptr$<$ Packet $>$ p, const Ipv4\+Header \&header, Ptr$<$ Net\+Device $>$ oif, Socket\+::\+Socket\+Errno \&sockerr)}{RouteOutput(Ptr< Packet > p, const Ipv4Header &header, Ptr< NetDevice > oif, Socket::SocketErrno &sockerr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv4\+Route} $>$ ns3\+::aodv\+::\+Routing\+Protocol\+::\+Route\+Output (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv4\+Header} \&}]{header, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{oif, }
\item[{{\bf Socket\+::\+Socket\+Errno} \&}]{sockerr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a71210f21868d71657400f6e616153c83}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a71210f21868d71657400f6e616153c83}


Query routing cache for an existing route, for an outbound packet. 

This lookup is used by transport protocols. It does not cause any packet to be forwarded, and is synchronous. Can be used for multicast or unicast. The Linux equivalent is ip\+\_\+route\+\_\+output()

The header input parameter may have an uninitialized value for the source address, but the destination address should always be properly set by the caller.


\begin{DoxyParams}{Parameters}
{\em p} & packet to be routed. Note that this method may modify the packet. Callers may also pass in a null pointer. \\
\hline
{\em header} & input parameter (used to form key to search for the route) \\
\hline
{\em oif} & Output interface Netdevice. May be zero, or may be bound via socket options to a particular output interface. \\
\hline
{\em sockerr} & Output parameter; socket errno\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a code that indicates what happened in the lookup 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a9c0e9b77772a4974c06ee4577fe60547}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
361 \{
362   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << header << (oif ? oif->GetIfIndex () : 0));
363   \textcolor{keywordflow}{if} (!p)
364     \{
365       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG}(\textcolor{stringliteral}{"Packet is == 0"});
366       \textcolor{keywordflow}{return} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa5a41c2ee6ff24a85cfa394d2e061762}{LoopbackRoute} (header, oif); \textcolor{comment}{// later}
367     \}
368   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.empty ())
369     \{
370       sockerr = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{Socket::ERROR\_NOROUTETOHOST};
371       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"No aodv interfaces"});
372       Ptr<Ipv4Route> route;
373       \textcolor{keywordflow}{return} route;
374     \}
375   sockerr = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaaa7eb006d73c5ad0117c5591fcb3469f7}{Socket::ERROR\_NOTERROR};
376   Ptr<Ipv4Route> route;
377   Ipv4Address dst = header.GetDestination ();
378   RoutingTableEntry rt;
379   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a2ca8c3757223d681d4cc39e2028fa7ad}{LookupValidRoute} (dst, rt))
380     \{
381       route = rt.GetRoute ();
382       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (route != 0);
383       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Exist route to "} << route->GetDestination () << \textcolor{stringliteral}{" from interface "} << 
      route->GetSource ());
384       \textcolor{keywordflow}{if} (oif != 0 && route->GetOutputDevice () != oif)
385         \{
386           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Output device doesn't match. Dropped."});
387           sockerr = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{Socket::ERROR\_NOROUTETOHOST};
388           \textcolor{keywordflow}{return} Ptr<Ipv4Route> ();
389         \}
390       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a204c68e4ce5aa8dc799f9fd039f8cbc7}{UpdateRouteLifeTime} (dst, \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a37ec921ef1c48e4d8e7072fe989613d2}{m\_activeRouteTimeout});
391       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a204c68e4ce5aa8dc799f9fd039f8cbc7}{UpdateRouteLifeTime} (route->GetGateway (), 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a37ec921ef1c48e4d8e7072fe989613d2}{m\_activeRouteTimeout});
392       \textcolor{keywordflow}{return} route;
393     \}
394 
395   \textcolor{comment}{// Valid route not found, in this case we return loopback. }
396   \textcolor{comment}{// Actual route request will be deferred until packet will be fully formed, }
397   \textcolor{comment}{// routed to loopback, received from loopback and passed to RouteInput (see below)}
398   uint32\_t iif = (oif ? \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetInterfaceForDevice (oif) : -1);
399   DeferredRouteOutputTag tag (iif);
400   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Valid Route not found"});
401   \textcolor{keywordflow}{if} (!p->\hyperlink{classns3_1_1Packet_a1734de11f2ca1e78a7872461a0625168}{PeekPacketTag} (tag))
402     \{
403       p->\hyperlink{classns3_1_1Packet_a7400b8655852f5271c5957250d0141af}{AddPacketTag} (tag);
404     \}
405   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa5a41c2ee6ff24a85cfa394d2e061762}{LoopbackRoute} (header, oif);
406 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 52


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Route\+Request\+Timer\+Expire@{Route\+Request\+Timer\+Expire}}
\index{Route\+Request\+Timer\+Expire@{Route\+Request\+Timer\+Expire}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Route\+Request\+Timer\+Expire(\+Ipv4\+Address dst)}{RouteRequestTimerExpire(Ipv4Address dst)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Route\+Request\+Timer\+Expire (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{dst}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_ae2ede2e919e00345ce1ba385c0527611}{}\label{classns3_1_1aodv_1_1RoutingProtocol_ae2ede2e919e00345ce1ba385c0527611}


Handle route discovery process. 


\begin{DoxyCode}
1697 \{
1698   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{keyword}{this});
1699   RoutingTableEntry toDst;
1700   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a2ca8c3757223d681d4cc39e2028fa7ad}{LookupValidRoute} (dst, toDst))
1701     \{
1702       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a7cd2a3baf7b377fbbf85de4275164f2b}{SendPacketFromQueue} (dst, toDst.GetRoute ());
1703       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"route to "} << dst << \textcolor{stringliteral}{" found"});
1704       \textcolor{keywordflow}{return};
1705     \}
1706   \textcolor{comment}{/*}
1707 \textcolor{comment}{   *  If a route discovery has been attempted RreqRetries times at the maximum TTL without}
1708 \textcolor{comment}{   *  receiving any RREP, all data packets destined for the corresponding destination SHOULD be}
1709 \textcolor{comment}{   *  dropped from the buffer and a Destination Unreachable message SHOULD be delivered to the application.}
1710 \textcolor{comment}{   */}
1711   \textcolor{keywordflow}{if} (toDst.GetRreqCnt () == \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_abecbe245cb328bc299a47f9a8a89aa6e}{m\_rreqRetries})
1712     \{
1713       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"route discovery to "} << dst << \textcolor{stringliteral}{" has been attempted RreqRetries ("} << 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_abecbe245cb328bc299a47f9a8a89aa6e}{m\_rreqRetries} << \textcolor{stringliteral}{") times with ttl "} << \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a563c2234b89a44628f8e71b38e7c60ec}{m\_netDiameter});
1714       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a3e21cac8acb05e13339eb0cabf13ddcf}{m\_addressReqTimer}.erase (dst);
1715       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_aec4efdf9faa7e90a825879bc86cc813a}{DeleteRoute} (dst);
1716       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Route not found. Drop all packets with dst "} << dst);
1717       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_afd2e6004e54cac8abd2d95cec3ee9580}{m\_queue}.\hyperlink{classns3_1_1aodv_1_1RequestQueue_ac133e18007238865cda0bc74b6b59f50}{DropPacketWithDst} (dst);
1718       \textcolor{keywordflow}{return};
1719     \}
1720 
1721   \textcolor{keywordflow}{if} (toDst.GetFlag () == \hyperlink{group__aodv_gga44216921a9c725a5ab8bc19059052a26aba44cda5a5df371b6567f70d7d8311fa}{IN\_SEARCH})
1722     \{
1723       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Resend RREQ to "} << dst << \textcolor{stringliteral}{" previous ttl "} << toDst.GetHop ());
1724       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a483f8df4d7855b2a71e506f665ca0828}{SendRequest} (dst);
1725     \}
1726   \textcolor{keywordflow}{else}
1727     \{
1728       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Route down. Stop search. Drop packet with destination "} << dst);
1729       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a3e21cac8acb05e13339eb0cabf13ddcf}{m\_addressReqTimer}.erase (dst);
1730       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_aec4efdf9faa7e90a825879bc86cc813a}{DeleteRoute} (dst);
1731       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_afd2e6004e54cac8abd2d95cec3ee9580}{m\_queue}.\hyperlink{classns3_1_1aodv_1_1RequestQueue_ac133e18007238865cda0bc74b6b59f50}{DropPacketWithDst} (dst);
1732     \}
1733 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 53




Here is the caller graph for this function\+:
% FIG 54


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Rreq\+Rate\+Limit\+Timer\+Expire@{Rreq\+Rate\+Limit\+Timer\+Expire}}
\index{Rreq\+Rate\+Limit\+Timer\+Expire@{Rreq\+Rate\+Limit\+Timer\+Expire}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Rreq\+Rate\+Limit\+Timer\+Expire()}{RreqRateLimitTimerExpire()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Rreq\+Rate\+Limit\+Timer\+Expire (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_aee7a58848233510a151f89c92488c0dd}{}\label{classns3_1_1aodv_1_1RoutingProtocol_aee7a58848233510a151f89c92488c0dd}


Reset R\+R\+EQ count and schedule R\+R\+EQ rate limit timer with delay 1 sec. 


\begin{DoxyCode}
1757 \{
1758   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1759   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a942f693d81f870c9ed9f155effae9577}{m\_rreqCount} = 0;
1760   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac8ad71cc3349d46b7740f59dd18b91b0}{m\_rreqRateLimitTimer}.\hyperlink{classns3_1_1Timer_ac3345d696887578f518b19f359f7f94b}{Schedule} (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (1));
1761 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 55




Here is the caller graph for this function\+:
% FIG 56


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Schedule\+Rreq\+Retry@{Schedule\+Rreq\+Retry}}
\index{Schedule\+Rreq\+Retry@{Schedule\+Rreq\+Retry}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Schedule\+Rreq\+Retry(\+Ipv4\+Address dst)}{ScheduleRreqRetry(Ipv4Address dst)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Schedule\+Rreq\+Retry (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{dst}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a85e17b36131d0582099347a4379bef11}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a85e17b36131d0582099347a4379bef11}
Repeated attempts by a source node at route discovery for a single destination use the expanding ring search technique. 
\begin{DoxyCode}
1036 \{
1037   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << dst);
1038   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a3e21cac8acb05e13339eb0cabf13ddcf}{m\_addressReqTimer}.find (dst) == \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a3e21cac8acb05e13339eb0cabf13ddcf}{m\_addressReqTimer}.end ())
1039     \{
1040       Timer timer (\hyperlink{classns3_1_1Timer_a816309b83cd2a35bea47d9bbc6bbf721a07a9dd5063b32fb6cf1f813c6ee7e28e}{Timer::CANCEL\_ON\_DESTROY});
1041       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a3e21cac8acb05e13339eb0cabf13ddcf}{m\_addressReqTimer}[dst] = timer;
1042     \}
1043   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a3e21cac8acb05e13339eb0cabf13ddcf}{m\_addressReqTimer}[dst].SetFunction (&
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ae2ede2e919e00345ce1ba385c0527611}{RoutingProtocol::RouteRequestTimerExpire}, \textcolor{keyword}{this});
1044   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a3e21cac8acb05e13339eb0cabf13ddcf}{m\_addressReqTimer}[dst].Remove ();
1045   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a3e21cac8acb05e13339eb0cabf13ddcf}{m\_addressReqTimer}[dst].SetArguments (dst);
1046   RoutingTableEntry rt;
1047   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a90cbc8a2c65cd68ccdaf768fcbb5d723}{LookupRoute} (dst, rt);
1048   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} retry;
1049   \textcolor{keywordflow}{if} (rt.GetHop () < \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a563c2234b89a44628f8e71b38e7c60ec}{m\_netDiameter})
1050     \{
1051       retry = 2 * \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ad467863779ea1559ad5942ff6c24a706}{m\_nodeTraversalTime} * (rt.GetHop () + 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a7805d2b1f8e48f3609f8770255a71e47}{m\_timeoutBuffer});
1052     \}
1053   \textcolor{keywordflow}{else}
1054     \{
1055       \textcolor{comment}{// Binary exponential backoff}
1056       retry = std::pow<uint16\_t> (2, rt.GetRreqCnt () - 1) * \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4642e67ba68a7ef40405f5773650ea1a}{m\_netTraversalTime};
1057     \}
1058   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a3e21cac8acb05e13339eb0cabf13ddcf}{m\_addressReqTimer}[dst].Schedule (retry);
1059   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Scheduled RREQ retry in "} << retry.GetSeconds () << \textcolor{stringliteral}{" seconds"});
1060 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 57




Here is the caller graph for this function\+:
% FIG 58


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Send\+Hello@{Send\+Hello}}
\index{Send\+Hello@{Send\+Hello}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Hello()}{SendHello()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Send\+Hello (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a1b772ee4eda1d3dae376dac6926c0dcf}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a1b772ee4eda1d3dae376dac6926c0dcf}


Send hello. 


\begin{DoxyCode}
1780 \{
1781   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1782   \textcolor{comment}{/* Broadcast a RREP with TTL = 1 with the RREP message fields set as follows:}
1783 \textcolor{comment}{   *   Destination IP Address         The node's IP address.}
1784 \textcolor{comment}{   *   Destination Sequence Number    The node's latest sequence number.}
1785 \textcolor{comment}{   *   Hop Count                      0}
1786 \textcolor{comment}{   *   Lifetime                       AllowedHelloLoss * HelloInterval}
1787 \textcolor{comment}{   */}
1788   \textcolor{keywordflow}{for} (std::map<Ptr<Socket>, Ipv4InterfaceAddress>::const\_iterator j = 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.begin (); j != \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.end (); ++j)
1789     \{
1790       Ptr<Socket> socket = j->first;
1791       Ipv4InterfaceAddress iface = j->second;
1792       RrepHeader helloHeader (\textcolor{comment}{/*prefix size=*/} 0, \textcolor{comment}{/*hops=*/} 0, \textcolor{comment}{/*dst=*/} iface.GetLocal (), \textcolor{comment}{/*dst seqno=*/} 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_abf5ef6b30d0ccf20b9b5ecf7918f67b2}{m\_seqNo},
1793                                                \textcolor{comment}{/*origin=*/} iface.GetLocal (),\textcolor{comment}{/*lifetime=*/} 
      \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a80e1dc9b9a640570ba5d5270846a2f6f}{m\_allowedHelloLoss} * \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa9750612eb154b537b1d7d0350cb8912}{m\_helloInterval}));
1794       Ptr<Packet> packet = Create<Packet> ();
1795       SocketIpTtlTag tag;
1796       tag.SetTtl (1);
1797       packet->AddPacketTag (tag);
1798       packet->AddHeader (helloHeader);
1799       TypeHeader tHeader (\hyperlink{namespacens3_1_1aodv_a8cf417608302ba0ed75225c976944d44a034af3d66c569436a630b5ee35399e45}{AODVTYPE\_RREP});
1800       packet->AddHeader (tHeader);
1801       \textcolor{comment}{// Send to all-hosts broadcast if on /32 addr, subnet-directed otherwise}
1802       Ipv4Address destination;
1803       \textcolor{keywordflow}{if} (iface.GetMask () == \hyperlink{classns3_1_1Ipv4Mask_af712cbdf28c039025d4aa45fa7e243dd}{Ipv4Mask::GetOnes} ())
1804         \{
1805           destination = Ipv4Address (\textcolor{stringliteral}{"255.255.255.255"});
1806         \}
1807       \textcolor{keywordflow}{else}
1808         \{ 
1809           destination = iface.GetBroadcast ();
1810         \}
1811       \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} jitter = \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (\hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a62dd29f4ef02720f5c1c00214dfdd7f9}{m\_uniformRandomVariable}->\hyperlink{classns3_1_1RandomVariableStream_a66cd94e6305ce7f000f1a9ff0fcb9aef}{GetInteger} (0, 10)));
1812       \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (jitter, &\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a41daaba7b2254917daa563575572c1ed}{RoutingProtocol::SendTo}, \textcolor{keyword}{this}
       , socket, packet, destination);
1813     \}
1814 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 59




Here is the caller graph for this function\+:
% FIG 60


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Send\+Packet\+From\+Queue@{Send\+Packet\+From\+Queue}}
\index{Send\+Packet\+From\+Queue@{Send\+Packet\+From\+Queue}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Packet\+From\+Queue(\+Ipv4\+Address dst, Ptr$<$ Ipv4\+Route $>$ route)}{SendPacketFromQueue(Ipv4Address dst, Ptr< Ipv4Route > route)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Send\+Packet\+From\+Queue (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{dst, }
\item[{{\bf Ptr}$<$ {\bf Ipv4\+Route} $>$}]{route}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a7cd2a3baf7b377fbbf85de4275164f2b}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a7cd2a3baf7b377fbbf85de4275164f2b}


Forward packet from route request queue. 


\begin{DoxyCode}
1818 \{
1819   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1820   QueueEntry queueEntry;
1821   \textcolor{keywordflow}{while} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_afd2e6004e54cac8abd2d95cec3ee9580}{m\_queue}.\hyperlink{classns3_1_1aodv_1_1RequestQueue_a1711433b4999cfd7ee30dd88103a2555}{Dequeue} (dst, queueEntry))
1822     \{
1823       DeferredRouteOutputTag tag;
1824       Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = ConstCast<Packet> (queueEntry.GetPacket ());
1825       \textcolor{keywordflow}{if} (p->RemovePacketTag (tag) && 
1826           tag.GetInterface() != -1 &&
1827           tag.GetInterface() != \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetInterfaceForDevice (route->GetOutputDevice ()))
1828         \{
1829           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Output device doesn't match. Dropped."});
1830           \textcolor{keywordflow}{return};
1831         \}
1832       \hyperlink{classns3_1_1Ipv4RoutingProtocol_a3453a85764cbbb1e704da7e919aa5d19}{UnicastForwardCallback} ucb = queueEntry.GetUnicastForwardCallback ();
1833       Ipv4Header header = queueEntry.GetIpv4Header ();
1834       header.SetSource (route->GetSource ());
1835       header.SetTtl (header.GetTtl () + 1); \textcolor{comment}{// compensate extra TTL decrement by fake loopback routing}
1836       ucb (route, p, header);
1837     \}
1838 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 61




Here is the caller graph for this function\+:
% FIG 62


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Send\+Reply@{Send\+Reply}}
\index{Send\+Reply@{Send\+Reply}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Reply(\+Rreq\+Header const \&rreq\+Header, Routing\+Table\+Entry const \&to\+Origin)}{SendReply(RreqHeader const &rreqHeader, RoutingTableEntry const &toOrigin)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Send\+Reply (
\begin{DoxyParamCaption}
\item[{{\bf Rreq\+Header} const \&}]{rreq\+Header, }
\item[{{\bf Routing\+Table\+Entry} const \&}]{to\+Origin}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a39c60e597085c4abc690e6215d302a1f}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a39c60e597085c4abc690e6215d302a1f}


Send R\+R\+EP. 


\begin{DoxyCode}
1355 \{
1356   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << toOrigin.GetDestination ());
1357   \textcolor{comment}{/*}
1358 \textcolor{comment}{   * Destination node MUST increment its own sequence number by one if the sequence number in the RREQ
       packet is equal to that}
1359 \textcolor{comment}{   * incremented value. Otherwise, the destination does not change its sequence number before generating
       the  RREP message.}
1360 \textcolor{comment}{   */}
1361   \textcolor{keywordflow}{if} (!rreqHeader.GetUnknownSeqno () && (rreqHeader.GetDstSeqno () == \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_abf5ef6b30d0ccf20b9b5ecf7918f67b2}{m\_seqNo} + 1))
1362     \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_abf5ef6b30d0ccf20b9b5ecf7918f67b2}{m\_seqNo}++;
1363   RrepHeader rrepHeader ( \textcolor{comment}{/*prefixSize=*/} 0, \textcolor{comment}{/*hops=*/} 0, \textcolor{comment}{/*dst=*/} rreqHeader.GetDst (),
1364                                           \textcolor{comment}{/*dstSeqNo=*/} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_abf5ef6b30d0ccf20b9b5ecf7918f67b2}{m\_seqNo}, \textcolor{comment}{/*origin=*/} toOrigin.GetDestination
       (), \textcolor{comment}{/*lifeTime=*/} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a7681a59458486d0b7a61937a9a90b0a1}{m\_myRouteTimeout});
1365   Ptr<Packet> packet = Create<Packet> ();
1366   SocketIpTtlTag tag;
1367   tag.SetTtl (toOrigin.GetHop ());
1368   packet->AddPacketTag (tag);
1369   packet->AddHeader (rrepHeader);
1370   TypeHeader tHeader (\hyperlink{namespacens3_1_1aodv_a8cf417608302ba0ed75225c976944d44a034af3d66c569436a630b5ee35399e45}{AODVTYPE\_RREP});
1371   packet->AddHeader (tHeader);
1372   Ptr<Socket> socket = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a7cebc7baa398569f432ea2521310dffe}{FindSocketWithInterfaceAddress} (toOrigin.GetInterface 
      ());
1373   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (socket);
1374   socket->SendTo (packet, 0, InetSocketAddress (toOrigin.GetNextHop (), 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac4a3de99b49ad5f6efc9b71a700f7ec4}{AODV\_PORT}));
1375 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 63




Here is the caller graph for this function\+:
% FIG 64


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Send\+Reply\+Ack@{Send\+Reply\+Ack}}
\index{Send\+Reply\+Ack@{Send\+Reply\+Ack}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Reply\+Ack(\+Ipv4\+Address neighbor)}{SendReplyAck(Ipv4Address neighbor)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Send\+Reply\+Ack (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{neighbor}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_aec193d679517de0a34d2e9d592b7bc77}{}\label{classns3_1_1aodv_1_1RoutingProtocol_aec193d679517de0a34d2e9d592b7bc77}


Send R\+R\+E\+P\+\_\+\+A\+CK. 


\begin{DoxyCode}
1433 \{
1434   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" to "} << neighbor);
1435   RrepAckHeader h;
1436   TypeHeader typeHeader (\hyperlink{namespacens3_1_1aodv_a8cf417608302ba0ed75225c976944d44a1bd445a537508666f448cc9f5a16f6a8}{AODVTYPE\_RREP\_ACK});
1437   Ptr<Packet> packet = Create<Packet> ();
1438   SocketIpTtlTag tag;
1439   tag.SetTtl (1);
1440   packet->AddPacketTag (tag);
1441   packet->AddHeader (h);
1442   packet->AddHeader (typeHeader);
1443   RoutingTableEntry toNeighbor;
1444   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a90cbc8a2c65cd68ccdaf768fcbb5d723}{LookupRoute} (neighbor, toNeighbor);
1445   Ptr<Socket> socket = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a7cebc7baa398569f432ea2521310dffe}{FindSocketWithInterfaceAddress} (toNeighbor.
      GetInterface ());
1446   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (socket);
1447   socket->SendTo (packet, 0, InetSocketAddress (neighbor, \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac4a3de99b49ad5f6efc9b71a700f7ec4}{AODV\_PORT}));
1448 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 65




Here is the caller graph for this function\+:
% FIG 66


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Send\+Reply\+By\+Intermediate\+Node@{Send\+Reply\+By\+Intermediate\+Node}}
\index{Send\+Reply\+By\+Intermediate\+Node@{Send\+Reply\+By\+Intermediate\+Node}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Reply\+By\+Intermediate\+Node(\+Routing\+Table\+Entry \&to\+Dst, Routing\+Table\+Entry \&to\+Origin, bool grat\+Rep)}{SendReplyByIntermediateNode(RoutingTableEntry &toDst, RoutingTableEntry &toOrigin, bool gratRep)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Send\+Reply\+By\+Intermediate\+Node (
\begin{DoxyParamCaption}
\item[{{\bf Routing\+Table\+Entry} \&}]{to\+Dst, }
\item[{{\bf Routing\+Table\+Entry} \&}]{to\+Origin, }
\item[{bool}]{grat\+Rep}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a862f551b61c45fb8de62bfbfa4c0a2ab}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a862f551b61c45fb8de62bfbfa4c0a2ab}
Send R\+R\+EP by intermediate node 
\begin{DoxyParams}{Parameters}
{\em to\+Dst} & routing table entry to destination \\
\hline
{\em to\+Origin} & routing table entry to originator \\
\hline
{\em grat\+Rep} & indicates whether a gratuitous R\+R\+EP should be unicast to destination \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1379 \{
1380   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1381   RrepHeader rrepHeader (\textcolor{comment}{/*prefix size=*/} 0, \textcolor{comment}{/*hops=*/} toDst.GetHop (), \textcolor{comment}{/*dst=*/} toDst.GetDestination (), \textcolor{comment}{
      /*dst seqno=*/} toDst.GetSeqNo (),
1382                                           \textcolor{comment}{/*origin=*/} toOrigin.GetDestination (), \textcolor{comment}{/*lifetime=*/} toDst.
      GetLifeTime ());
1383   \textcolor{comment}{/* If the node we received a RREQ for is a neighbor we are}
1384 \textcolor{comment}{   * probably facing a unidirectional link... Better request a RREP-ack}
1385 \textcolor{comment}{   */}
1386   \textcolor{keywordflow}{if} (toDst.GetHop () == 1)
1387     \{
1388       rrepHeader.SetAckRequired (\textcolor{keyword}{true});
1389       RoutingTableEntry toNextHop;
1390       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a90cbc8a2c65cd68ccdaf768fcbb5d723}{LookupRoute} (toOrigin.GetNextHop (), toNextHop);
1391       toNextHop.m\_ackTimer.SetFunction (&\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa98fb4cc6871a7f5e918c4992a05b813}{RoutingProtocol::AckTimerExpire}, \textcolor{keyword}{
      this});
1392       toNextHop.m\_ackTimer.SetArguments (toNextHop.GetDestination (), 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a23de7759e9c26ded382a09a860b4f987}{m\_blackListTimeout});
1393       toNextHop.m\_ackTimer.SetDelay (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aeac3f146e52514d060a69f1a2d62690b}{m\_nextHopWait});
1394     \}
1395   toDst.InsertPrecursor (toOrigin.GetNextHop ());
1396   toOrigin.InsertPrecursor (toDst.GetNextHop ());
1397   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a39fb5335110164f4c1b97682a3812dc1}{Update} (toDst);
1398   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a39fb5335110164f4c1b97682a3812dc1}{Update} (toOrigin);
1399 
1400   Ptr<Packet> packet = Create<Packet> ();
1401   SocketIpTtlTag tag;
1402   tag.SetTtl (toOrigin.GetHop ());
1403   packet->AddPacketTag (tag);
1404   packet->AddHeader (rrepHeader);
1405   TypeHeader tHeader (\hyperlink{namespacens3_1_1aodv_a8cf417608302ba0ed75225c976944d44a034af3d66c569436a630b5ee35399e45}{AODVTYPE\_RREP});
1406   packet->AddHeader (tHeader);
1407   Ptr<Socket> socket = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a7cebc7baa398569f432ea2521310dffe}{FindSocketWithInterfaceAddress} (toOrigin.GetInterface 
      ());
1408   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (socket);
1409   socket->SendTo (packet, 0, InetSocketAddress (toOrigin.GetNextHop (), 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac4a3de99b49ad5f6efc9b71a700f7ec4}{AODV\_PORT}));
1410 
1411   \textcolor{comment}{// Generating gratuitous RREPs}
1412   \textcolor{keywordflow}{if} (gratRep)
1413     \{
1414       RrepHeader gratRepHeader (\textcolor{comment}{/*prefix size=*/} 0, \textcolor{comment}{/*hops=*/} toOrigin.GetHop (), \textcolor{comment}{/*dst=*/} toOrigin.
      GetDestination (),
1415                                                  \textcolor{comment}{/*dst seqno=*/} toOrigin.GetSeqNo (), \textcolor{comment}{/*origin=*/} toDst.
      GetDestination (),
1416                                                  \textcolor{comment}{/*lifetime=*/} toOrigin.GetLifeTime ());
1417       Ptr<Packet> packetToDst = Create<Packet> ();
1418       SocketIpTtlTag gratTag;
1419       gratTag.SetTtl (toDst.GetHop ());
1420       packetToDst->AddPacketTag (gratTag);
1421       packetToDst->AddHeader (gratRepHeader);
1422       TypeHeader \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type} (\hyperlink{namespacens3_1_1aodv_a8cf417608302ba0ed75225c976944d44a034af3d66c569436a630b5ee35399e45}{AODVTYPE\_RREP});
1423       packetToDst->AddHeader (\hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type});
1424       Ptr<Socket> socket = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a7cebc7baa398569f432ea2521310dffe}{FindSocketWithInterfaceAddress} (toDst.GetInterface
       ());
1425       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (socket);
1426       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Send gratuitous RREP "} << packet->GetUid ());
1427       socket->SendTo (packetToDst, 0, InetSocketAddress (toDst.GetNextHop (), 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac4a3de99b49ad5f6efc9b71a700f7ec4}{AODV\_PORT}));
1428     \}
1429 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 67




Here is the caller graph for this function\+:
% FIG 68


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Send\+Request@{Send\+Request}}
\index{Send\+Request@{Send\+Request}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Request(\+Ipv4\+Address dst)}{SendRequest(Ipv4Address dst)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Send\+Request (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{dst}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a483f8df4d7855b2a71e506f665ca0828}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a483f8df4d7855b2a71e506f665ca0828}


Send R\+R\+EQ. 


\begin{DoxyCode}
929 \{
930   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} ( \textcolor{keyword}{this} << dst);
931   \textcolor{comment}{// A node SHOULD NOT originate more than RREQ\_RATELIMIT RREQ messages per second.}
932   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a942f693d81f870c9ed9f155effae9577}{m\_rreqCount} == \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a543abca2b224dcde1362f1050f1887c7}{m\_rreqRateLimit})
933     \{
934       \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac8ad71cc3349d46b7740f59dd18b91b0}{m\_rreqRateLimitTimer}.
      \hyperlink{classns3_1_1Timer_a0dc288dd3de21a524d088fc8a5a14a73}{GetDelayLeft} () + \hyperlink{group__timecivil_ga17465a639c8d1464e76538afdd78a9f0}{MicroSeconds} (100),
935                            &\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a483f8df4d7855b2a71e506f665ca0828}{RoutingProtocol::SendRequest}, \textcolor{keyword}{this}, dst);
936       \textcolor{keywordflow}{return};
937     \}
938   \textcolor{keywordflow}{else}
939     \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a942f693d81f870c9ed9f155effae9577}{m\_rreqCount}++;
940   \textcolor{comment}{// Create RREQ header}
941   RreqHeader rreqHeader;
942   rreqHeader.SetDst (dst);
943 
944   RoutingTableEntry rt;
945   \textcolor{comment}{// Using the Hop field in Routing Table to manage the expanding ring search}
946   uint16\_t ttl = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_abc9bab73b39d584866faf18e95704e0f}{m\_ttlStart};
947   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a90cbc8a2c65cd68ccdaf768fcbb5d723}{LookupRoute} (dst, rt))
948     \{
949       \textcolor{keywordflow}{if} (rt.GetFlag () != \hyperlink{group__aodv_gga44216921a9c725a5ab8bc19059052a26aba44cda5a5df371b6567f70d7d8311fa}{IN\_SEARCH})
950         \{
951           ttl = std::min<uint16\_t> (rt.GetHop () + \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a7155a27e029832bfd90448bd6ae831db}{m\_ttlIncrement}, 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a563c2234b89a44628f8e71b38e7c60ec}{m\_netDiameter});
952         \}
953       \textcolor{keywordflow}{else}
954         \{
955           ttl = rt.GetHop () + \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a7155a27e029832bfd90448bd6ae831db}{m\_ttlIncrement};
956           \textcolor{keywordflow}{if} (ttl > \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a5fa99f38d3f75c20e1a89f4f2e60c42f}{m\_ttlThreshold})
957             ttl = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a563c2234b89a44628f8e71b38e7c60ec}{m\_netDiameter};
958         \}
959       \textcolor{keywordflow}{if} (ttl == \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a563c2234b89a44628f8e71b38e7c60ec}{m\_netDiameter})
960         rt.IncrementRreqCnt ();
961       \textcolor{keywordflow}{if} (rt.GetValidSeqNo ())
962         rreqHeader.SetDstSeqno (rt.GetSeqNo ());
963       \textcolor{keywordflow}{else}
964         rreqHeader.SetUnknownSeqno (\textcolor{keyword}{true});
965       rt.SetHop (ttl);
966       rt.SetFlag (\hyperlink{group__aodv_gga44216921a9c725a5ab8bc19059052a26aba44cda5a5df371b6567f70d7d8311fa}{IN\_SEARCH});
967       rt.SetLifeTime (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a491c2fe5559a8153343df590999b468f}{m\_pathDiscoveryTime});
968       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a39fb5335110164f4c1b97682a3812dc1}{Update} (rt);
969     \}
970   \textcolor{keywordflow}{else}
971     \{
972       rreqHeader.SetUnknownSeqno (\textcolor{keyword}{true});
973       Ptr<NetDevice> dev = 0;
974       RoutingTableEntry newEntry (\textcolor{comment}{/*device=*/} dev, \textcolor{comment}{/*dst=*/} dst, \textcolor{comment}{/*validSeqNo=*/} \textcolor{keyword}{false}, \textcolor{comment}{/*seqno=*/} 0,
975                                               \textcolor{comment}{/*iface=*/} Ipv4InterfaceAddress (),\textcolor{comment}{/*hop=*/} ttl,
976                                               \textcolor{comment}{/*nextHop=*/} Ipv4Address (), \textcolor{comment}{/*lifeTime=*/} 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a491c2fe5559a8153343df590999b468f}{m\_pathDiscoveryTime});
977       \textcolor{comment}{// Check if TtlStart == NetDiameter}
978       \textcolor{keywordflow}{if} (ttl == \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a563c2234b89a44628f8e71b38e7c60ec}{m\_netDiameter})
979         newEntry.IncrementRreqCnt ();
980       newEntry.SetFlag (\hyperlink{group__aodv_gga44216921a9c725a5ab8bc19059052a26aba44cda5a5df371b6567f70d7d8311fa}{IN\_SEARCH});
981       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a579e562e38e67d510de1ff2c87806c76}{AddRoute} (newEntry);
982     \}
983 
984   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a492b1b69b8f91b56ba3301006318a4f3}{m\_gratuitousReply})
985     rreqHeader.SetGratiousRrep (\textcolor{keyword}{true});
986   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aad49f5618b2843a1ae43a9c50aabc54f}{m\_destinationOnly})
987     rreqHeader.SetDestinationOnly (\textcolor{keyword}{true});
988 
989   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_abf5ef6b30d0ccf20b9b5ecf7918f67b2}{m\_seqNo}++;
990   rreqHeader.SetOriginSeqno (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_abf5ef6b30d0ccf20b9b5ecf7918f67b2}{m\_seqNo});
991   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a0075a9d7db2eeb40aaa9066c0a073942}{m\_requestId}++;
992   rreqHeader.SetId (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a0075a9d7db2eeb40aaa9066c0a073942}{m\_requestId});
993 
994   \textcolor{comment}{// Send RREQ as subnet directed broadcast from each interface used by aodv}
995   \textcolor{keywordflow}{for} (std::map<Ptr<Socket>, Ipv4InterfaceAddress>::const\_iterator j =
996          \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.begin (); j != \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.end (); ++j)
997     \{
998       Ptr<Socket> socket = j->first;
999       Ipv4InterfaceAddress iface = j->second;
1000 
1001       rreqHeader.SetOrigin (iface.GetLocal ());
1002       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a96743ff957b0a878c23e55a84e209d5d}{m\_rreqIdCache}.\hyperlink{classns3_1_1aodv_1_1IdCache_a6f32458e4f47ab3d977d8c81742b172c}{IsDuplicate} (iface.GetLocal (), 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a0075a9d7db2eeb40aaa9066c0a073942}{m\_requestId});
1003 
1004       Ptr<Packet> packet = Create<Packet> ();
1005       SocketIpTtlTag tag;
1006       tag.SetTtl (ttl);
1007       packet->AddPacketTag (tag);
1008       packet->AddHeader (rreqHeader);
1009       TypeHeader tHeader (\hyperlink{namespacens3_1_1aodv_a8cf417608302ba0ed75225c976944d44ad5f62dc18635d788b1a5b0dd834d46f0}{AODVTYPE\_RREQ});
1010       packet->AddHeader (tHeader);
1011       \textcolor{comment}{// Send to all-hosts broadcast if on /32 addr, subnet-directed otherwise}
1012       Ipv4Address destination;
1013       \textcolor{keywordflow}{if} (iface.GetMask () == \hyperlink{classns3_1_1Ipv4Mask_af712cbdf28c039025d4aa45fa7e243dd}{Ipv4Mask::GetOnes} ())
1014         \{
1015           destination = Ipv4Address (\textcolor{stringliteral}{"255.255.255.255"});
1016         \}
1017       \textcolor{keywordflow}{else}
1018         \{ 
1019           destination = iface.GetBroadcast ();
1020         \}
1021       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Send RREQ with id "} << rreqHeader.GetId () << \textcolor{stringliteral}{" to socket"});
1022       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a0edfc4673f09d0145efba15a1476bc15}{m\_lastBcastTime} = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ();
1023       \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (\hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a62dd29f4ef02720f5c1c00214dfdd7f9}{m\_uniformRandomVariable}->\hyperlink{classns3_1_1RandomVariableStream_a66cd94e6305ce7f000f1a9ff0fcb9aef}{GetInteger} (0, 10))), &
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a41daaba7b2254917daa563575572c1ed}{RoutingProtocol::SendTo}, \textcolor{keyword}{this}, socket, packet, destination); 
1024     \}
1025   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a85e17b36131d0582099347a4379bef11}{ScheduleRreqRetry} (dst);
1026 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 69




Here is the caller graph for this function\+:
% FIG 70


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Send\+Rerr\+Message@{Send\+Rerr\+Message}}
\index{Send\+Rerr\+Message@{Send\+Rerr\+Message}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Rerr\+Message(\+Ptr$<$ Packet $>$ packet, std\+::vector$<$ Ipv4\+Address $>$ precursors)}{SendRerrMessage(Ptr< Packet > packet, std::vector< Ipv4Address > precursors)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Send\+Rerr\+Message (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{std\+::vector$<$ {\bf Ipv4\+Address} $>$}]{precursors}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_abc216040fe7b7ac100ea7bf2ce9a0bdb}{}\label{classns3_1_1aodv_1_1RoutingProtocol_abc216040fe7b7ac100ea7bf2ce9a0bdb}


Forward R\+E\+RR. 


\begin{DoxyCode}
1952 \{
1953   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1954 
1955   \textcolor{keywordflow}{if} (precursors.empty ())
1956     \{
1957       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"No precursors"});
1958       \textcolor{keywordflow}{return};
1959     \}
1960   \textcolor{comment}{// A node SHOULD NOT originate more than RERR\_RATELIMIT RERR messages per second.}
1961   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4afc71535ffd2ea1bd7dcb03e3fd4233}{m\_rerrCount} == \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ad7a69761e61bcea41a2bc87ad8928e2d}{m\_rerrRateLimit})
1962     \{
1963       \textcolor{comment}{// Just make sure that the RerrRateLimit timer is running and will expire}
1964       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a0eaa679b6dea15e92c550591eabbccc1}{m\_rerrRateLimitTimer}.\hyperlink{classns3_1_1Timer_addbc6c740f21ddeb6ad358557962b24c}{IsRunning} ());
1965       \textcolor{comment}{// discard the packet and return}
1966       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"RerrRateLimit reached at "} << \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds (
      ) << \textcolor{stringliteral}{" with timer delay left "} 
1967                                                 << \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a0eaa679b6dea15e92c550591eabbccc1}{m\_rerrRateLimitTimer}.
      \hyperlink{classns3_1_1Timer_a0dc288dd3de21a524d088fc8a5a14a73}{GetDelayLeft} ().\hyperlink{classns3_1_1Time_a8f20d5c3b0902d7b4320982f340b57c8}{GetSeconds} ()
1968                                                 << \textcolor{stringliteral}{"; suppressing RERR"});
1969       \textcolor{keywordflow}{return};
1970     \}
1971   \textcolor{comment}{// If there is only one precursor, RERR SHOULD be unicast toward that precursor}
1972   \textcolor{keywordflow}{if} (precursors.size () == 1)
1973     \{
1974       RoutingTableEntry toPrecursor;
1975       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a2ca8c3757223d681d4cc39e2028fa7ad}{LookupValidRoute} (precursors.front (), toPrecursor))
1976         \{
1977           Ptr<Socket> socket = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a7cebc7baa398569f432ea2521310dffe}{FindSocketWithInterfaceAddress} (toPrecursor.
      GetInterface ());
1978           \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (socket);
1979           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"one precursor => unicast RERR to "} << toPrecursor.GetDestination () <<
       \textcolor{stringliteral}{" from "} << toPrecursor.GetInterface ().GetLocal ());
1980           \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (\hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a62dd29f4ef02720f5c1c00214dfdd7f9}{m\_uniformRandomVariable}->\hyperlink{classns3_1_1RandomVariableStream_a66cd94e6305ce7f000f1a9ff0fcb9aef}{GetInteger} (0, 10))), &
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a41daaba7b2254917daa563575572c1ed}{RoutingProtocol::SendTo}, \textcolor{keyword}{this}, socket, packet, precursors.front ());
1981           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4afc71535ffd2ea1bd7dcb03e3fd4233}{m\_rerrCount}++;
1982         \}
1983       \textcolor{keywordflow}{return};
1984     \}
1985 
1986   \textcolor{comment}{//  Should only transmit RERR on those interfaces which have precursor nodes for the broken route}
1987   std::vector<Ipv4InterfaceAddress> ifaces;
1988   RoutingTableEntry toPrecursor;
1989   \textcolor{keywordflow}{for} (std::vector<Ipv4Address>::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = precursors.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != precursors.end (); ++
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
1990     \{
1991       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a2ca8c3757223d681d4cc39e2028fa7ad}{LookupValidRoute} (*\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, toPrecursor) && 
1992           std::find (ifaces.begin (), ifaces.end (), toPrecursor.GetInterface ()) == ifaces.end ())
1993         \{
1994           ifaces.push\_back (toPrecursor.GetInterface ());
1995         \}
1996     \}
1997 
1998   \textcolor{keywordflow}{for} (std::vector<Ipv4InterfaceAddress>::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = ifaces.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != ifaces.end (); ++
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
1999     \{
2000       Ptr<Socket> socket = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a7cebc7baa398569f432ea2521310dffe}{FindSocketWithInterfaceAddress} (*
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
2001       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (socket);
2002       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Broadcast RERR message from interface "} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetLocal ());
2003       \textcolor{comment}{// std::cout << "Broadcast RERR message from interface " << i->GetLocal () << std::endl;}
2004       \textcolor{comment}{// Send to all-hosts broadcast if on /32 addr, subnet-directed otherwise}
2005       Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = packet->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} ();
2006       Ipv4Address destination;
2007       \textcolor{keywordflow}{if} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetMask () == \hyperlink{classns3_1_1Ipv4Mask_af712cbdf28c039025d4aa45fa7e243dd}{Ipv4Mask::GetOnes} ())
2008         \{
2009           destination = Ipv4Address (\textcolor{stringliteral}{"255.255.255.255"});
2010         \}
2011       \textcolor{keywordflow}{else}
2012         \{ 
2013           destination = \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetBroadcast ();
2014         \}
2015       \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (\hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a62dd29f4ef02720f5c1c00214dfdd7f9}{m\_uniformRandomVariable}->\hyperlink{classns3_1_1RandomVariableStream_a66cd94e6305ce7f000f1a9ff0fcb9aef}{GetInteger} (0, 10))), &
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a41daaba7b2254917daa563575572c1ed}{RoutingProtocol::SendTo}, \textcolor{keyword}{this}, socket, \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, destination);
2016     \}
2017 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 71




Here is the caller graph for this function\+:
% FIG 72


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Send\+Rerr\+When\+Breaks\+Link\+To\+Next\+Hop@{Send\+Rerr\+When\+Breaks\+Link\+To\+Next\+Hop}}
\index{Send\+Rerr\+When\+Breaks\+Link\+To\+Next\+Hop@{Send\+Rerr\+When\+Breaks\+Link\+To\+Next\+Hop}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Rerr\+When\+Breaks\+Link\+To\+Next\+Hop(\+Ipv4\+Address next\+Hop)}{SendRerrWhenBreaksLinkToNextHop(Ipv4Address nextHop)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Send\+Rerr\+When\+Breaks\+Link\+To\+Next\+Hop (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{next\+Hop}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_ae2ab3a83b71210d82c458e5e680c1351}{}\label{classns3_1_1aodv_1_1RoutingProtocol_ae2ab3a83b71210d82c458e5e680c1351}


Initiate R\+E\+RR. 


\begin{DoxyCode}
1842 \{
1843   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << nextHop);
1844   RerrHeader rerrHeader;
1845   std::vector<Ipv4Address> precursors;
1846   std::map<Ipv4Address, uint32\_t> unreachable;
1847 
1848   RoutingTableEntry toNextHop;
1849   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a90cbc8a2c65cd68ccdaf768fcbb5d723}{LookupRoute} (nextHop, toNextHop))
1850     \textcolor{keywordflow}{return};
1851   toNextHop.GetPrecursors (precursors);
1852   rerrHeader.AddUnDestination (nextHop, toNextHop.GetSeqNo ());
1853   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a0315dabaf863f63cce72eed5c97bd423}{GetListOfDestinationWithNextHop} (nextHop, 
      unreachable);
1854   \textcolor{keywordflow}{for} (std::map<Ipv4Address, uint32\_t>::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = unreachable.begin (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}
1855        != unreachable.end ();)
1856     \{
1857       \textcolor{keywordflow}{if} (!rerrHeader.AddUnDestination (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->first, \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second))
1858         \{
1859           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Send RERR message with maximum size."});
1860           TypeHeader typeHeader (\hyperlink{namespacens3_1_1aodv_a8cf417608302ba0ed75225c976944d44a363aea0c29a02f5899cf088654c6d844}{AODVTYPE\_RERR});
1861           Ptr<Packet> packet = Create<Packet> ();
1862           SocketIpTtlTag tag;
1863           tag.SetTtl (1);
1864           packet->AddPacketTag (tag);
1865           packet->AddHeader (rerrHeader);
1866           packet->AddHeader (typeHeader);
1867           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_abc216040fe7b7ac100ea7bf2ce9a0bdb}{SendRerrMessage} (packet, precursors);
1868           rerrHeader.Clear ();
1869         \}
1870       \textcolor{keywordflow}{else}
1871         \{
1872           RoutingTableEntry toDst;
1873           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a90cbc8a2c65cd68ccdaf768fcbb5d723}{LookupRoute} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->first, toDst);
1874           toDst.GetPrecursors (precursors);
1875           ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
1876         \}
1877     \}
1878   \textcolor{keywordflow}{if} (rerrHeader.GetDestCount () != 0)
1879     \{
1880       TypeHeader typeHeader (\hyperlink{namespacens3_1_1aodv_a8cf417608302ba0ed75225c976944d44a363aea0c29a02f5899cf088654c6d844}{AODVTYPE\_RERR});
1881       Ptr<Packet> packet = Create<Packet> ();
1882       SocketIpTtlTag tag;
1883       tag.SetTtl (1);
1884       packet->AddPacketTag (tag);
1885       packet->AddHeader (rerrHeader);
1886       packet->AddHeader (typeHeader);
1887       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_abc216040fe7b7ac100ea7bf2ce9a0bdb}{SendRerrMessage} (packet, precursors);
1888     \}
1889   unreachable.insert (std::make\_pair (nextHop, toNextHop.GetSeqNo ()));
1890   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a18a8d2cfcba8e03de2a086e4dcaa7d2f}{InvalidateRoutesWithDst} (unreachable);
1891 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 73




Here is the caller graph for this function\+:
% FIG 74


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Send\+Rerr\+When\+No\+Route\+To\+Forward@{Send\+Rerr\+When\+No\+Route\+To\+Forward}}
\index{Send\+Rerr\+When\+No\+Route\+To\+Forward@{Send\+Rerr\+When\+No\+Route\+To\+Forward}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Rerr\+When\+No\+Route\+To\+Forward(\+Ipv4\+Address dst, uint32\+\_\+t dst\+Seq\+No, Ipv4\+Address origin)}{SendRerrWhenNoRouteToForward(Ipv4Address dst, uint32_t dstSeqNo, Ipv4Address origin)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Send\+Rerr\+When\+No\+Route\+To\+Forward (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{dst, }
\item[{uint32\+\_\+t}]{dst\+Seq\+No, }
\item[{{\bf Ipv4\+Address}}]{origin}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_aa8b4c8c3811348aa19e76218523796af}{}\label{classns3_1_1aodv_1_1RoutingProtocol_aa8b4c8c3811348aa19e76218523796af}
Send R\+E\+RR message when no route to forward input packet. Unicast if there is reverse route to originating node, broadcast otherwise. 
\begin{DoxyParams}{Parameters}
{\em dst} & -\/ destination node IP address \\
\hline
{\em dst\+Seq\+No} & -\/ destination node sequence number \\
\hline
{\em origin} & -\/ originating node IP address \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1896 \{
1897   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1898   \textcolor{comment}{// A node SHOULD NOT originate more than RERR\_RATELIMIT RERR messages per second.}
1899   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4afc71535ffd2ea1bd7dcb03e3fd4233}{m\_rerrCount} == \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ad7a69761e61bcea41a2bc87ad8928e2d}{m\_rerrRateLimit})
1900     \{
1901       \textcolor{comment}{// Just make sure that the RerrRateLimit timer is running and will expire}
1902       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a0eaa679b6dea15e92c550591eabbccc1}{m\_rerrRateLimitTimer}.\hyperlink{classns3_1_1Timer_addbc6c740f21ddeb6ad358557962b24c}{IsRunning} ());
1903       \textcolor{comment}{// discard the packet and return}
1904       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"RerrRateLimit reached at "} << \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds (
      ) << \textcolor{stringliteral}{" with timer delay left "} 
1905                                                 << \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a0eaa679b6dea15e92c550591eabbccc1}{m\_rerrRateLimitTimer}.
      \hyperlink{classns3_1_1Timer_a0dc288dd3de21a524d088fc8a5a14a73}{GetDelayLeft} ().\hyperlink{classns3_1_1Time_a8f20d5c3b0902d7b4320982f340b57c8}{GetSeconds} ()
1906                                                 << \textcolor{stringliteral}{"; suppressing RERR"});
1907       \textcolor{keywordflow}{return};
1908     \}
1909   RerrHeader rerrHeader;
1910   rerrHeader.AddUnDestination (dst, dstSeqNo);
1911   RoutingTableEntry toOrigin;
1912   Ptr<Packet> packet = Create<Packet> ();
1913   SocketIpTtlTag tag;
1914   tag.SetTtl (1);
1915   packet->AddPacketTag (tag);
1916   packet->AddHeader (rerrHeader);
1917   packet->AddHeader (TypeHeader (\hyperlink{namespacens3_1_1aodv_a8cf417608302ba0ed75225c976944d44a363aea0c29a02f5899cf088654c6d844}{AODVTYPE\_RERR}));
1918   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a2ca8c3757223d681d4cc39e2028fa7ad}{LookupValidRoute} (origin, toOrigin))
1919     \{
1920       Ptr<Socket> socket = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a7cebc7baa398569f432ea2521310dffe}{FindSocketWithInterfaceAddress} (
1921           toOrigin.GetInterface ());
1922       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (socket);
1923       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Unicast RERR to the source of the data transmission"});
1924       socket->SendTo (packet, 0, InetSocketAddress (toOrigin.GetNextHop (), 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac4a3de99b49ad5f6efc9b71a700f7ec4}{AODV\_PORT}));
1925     \}
1926   \textcolor{keywordflow}{else}
1927     \{
1928       \textcolor{keywordflow}{for} (std::map<Ptr<Socket>, Ipv4InterfaceAddress>::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} =
1929              \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{m\_socketAddresses}.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
1930         \{
1931           Ptr<Socket> socket = \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->first;
1932           Ipv4InterfaceAddress iface = \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second;
1933           \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (socket);
1934           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Broadcast RERR message from interface "} << iface.GetLocal ());
1935           \textcolor{comment}{// Send to all-hosts broadcast if on /32 addr, subnet-directed otherwise}
1936           Ipv4Address destination;
1937           \textcolor{keywordflow}{if} (iface.GetMask () == \hyperlink{classns3_1_1Ipv4Mask_af712cbdf28c039025d4aa45fa7e243dd}{Ipv4Mask::GetOnes} ())
1938             \{
1939               destination = Ipv4Address (\textcolor{stringliteral}{"255.255.255.255"});
1940             \}
1941           \textcolor{keywordflow}{else}
1942             \{ 
1943               destination = iface.GetBroadcast ();
1944             \}
1945           socket->SendTo (packet->Copy (), 0, InetSocketAddress (destination, 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac4a3de99b49ad5f6efc9b71a700f7ec4}{AODV\_PORT}));
1946         \}
1947     \}
1948 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 75




Here is the caller graph for this function\+:
% FIG 76


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Send\+To@{Send\+To}}
\index{Send\+To@{Send\+To}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+To(\+Ptr$<$ Socket $>$ socket, Ptr$<$ Packet $>$ packet, Ipv4\+Address destination)}{SendTo(Ptr< Socket > socket, Ptr< Packet > packet, Ipv4Address destination)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Send\+To (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Socket} $>$}]{socket, }
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Ipv4\+Address}}]{destination}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a41daaba7b2254917daa563575572c1ed}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a41daaba7b2254917daa563575572c1ed}

\begin{DoxyCode}
1030 \{
1031     socket->\hyperlink{classns3_1_1Socket_af898fce6a58e0dbba23c1c6de1d4220e}{SendTo} (packet, 0, InetSocketAddress (destination, \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac4a3de99b49ad5f6efc9b71a700f7ec4}{AODV\_PORT}));
1032 
1033 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 77




Here is the caller graph for this function\+:
% FIG 78


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Set\+Broadcast\+Enable@{Set\+Broadcast\+Enable}}
\index{Set\+Broadcast\+Enable@{Set\+Broadcast\+Enable}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Broadcast\+Enable(bool f)}{SetBroadcastEnable(bool f)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Set\+Broadcast\+Enable (
\begin{DoxyParamCaption}
\item[{bool}]{f}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a7b9ff3dbdf0a3cb34965fc271e311eff}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a7b9ff3dbdf0a3cb34965fc271e311eff}

\begin{DoxyCode}
87 \{ \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a15b6c0f3a19ecf251f4492a71e95d080}{m\_enableBroadcast} = \hyperlink{buildings__pathloss_8m_aa52d3a6e3de5a80a97c12364caeaa125}{f}; \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 79


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Set\+Desination\+Only\+Flag@{Set\+Desination\+Only\+Flag}}
\index{Set\+Desination\+Only\+Flag@{Set\+Desination\+Only\+Flag}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Desination\+Only\+Flag(bool f)}{SetDesinationOnlyFlag(bool f)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Set\+Desination\+Only\+Flag (
\begin{DoxyParamCaption}
\item[{bool}]{f}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_accd8a8cfc59ed0990c938ddc630d2349}{}\label{classns3_1_1aodv_1_1RoutingProtocol_accd8a8cfc59ed0990c938ddc630d2349}

\begin{DoxyCode}
82 \{ \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aad49f5618b2843a1ae43a9c50aabc54f}{m\_destinationOnly} = \hyperlink{buildings__pathloss_8m_aa52d3a6e3de5a80a97c12364caeaa125}{f}; \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 80


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Set\+Gratuitous\+Reply\+Flag@{Set\+Gratuitous\+Reply\+Flag}}
\index{Set\+Gratuitous\+Reply\+Flag@{Set\+Gratuitous\+Reply\+Flag}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Gratuitous\+Reply\+Flag(bool f)}{SetGratuitousReplyFlag(bool f)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Set\+Gratuitous\+Reply\+Flag (
\begin{DoxyParamCaption}
\item[{bool}]{f}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a87d5d76fac11f8d674cc599d71e6d3aa}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a87d5d76fac11f8d674cc599d71e6d3aa}

\begin{DoxyCode}
84 \{ \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a492b1b69b8f91b56ba3301006318a4f3}{m\_gratuitousReply} = \hyperlink{buildings__pathloss_8m_aa52d3a6e3de5a80a97c12364caeaa125}{f}; \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 81


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Set\+Hello\+Enable@{Set\+Hello\+Enable}}
\index{Set\+Hello\+Enable@{Set\+Hello\+Enable}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Hello\+Enable(bool f)}{SetHelloEnable(bool f)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Set\+Hello\+Enable (
\begin{DoxyParamCaption}
\item[{bool}]{f}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_aace3f902cf89b88cedd6cc64af35c912}{}\label{classns3_1_1aodv_1_1RoutingProtocol_aace3f902cf89b88cedd6cc64af35c912}

\begin{DoxyCode}
85 \{ \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac1cb4715e9ac42540c051268db368ae8}{m\_enableHello} = \hyperlink{buildings__pathloss_8m_aa52d3a6e3de5a80a97c12364caeaa125}{f}; \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 82


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Set\+Ipv4@{Set\+Ipv4}}
\index{Set\+Ipv4@{Set\+Ipv4}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Ipv4(\+Ptr$<$ Ipv4 $>$ ipv4)}{SetIpv4(Ptr< Ipv4 > ipv4)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Set\+Ipv4 (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv4} $>$}]{ipv4}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a34df0b3e287abea45d48ab7c8162e183}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a34df0b3e287abea45d48ab7c8162e183}

\begin{DoxyParams}{Parameters}
{\em ipv4} & the ipv4 object this routing protocol is being associated with\\
\hline
\end{DoxyParams}
Typically, invoked directly or indirectly from \hyperlink{classns3_1_1Ipv4_a2d165c3bafd4ca580f02a03536db80d3}{ns3\+::\+Ipv4\+::\+Set\+Routing\+Protocol} 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_af3947a05b912ea3f2a1ef0e9777f723e}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
626 \{
627   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (ipv4 != 0);
628   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4} == 0);
629 
630   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4} = ipv4;
631 
632   \textcolor{comment}{// Create lo route. It is asserted that the only one interface up for now is loopback}
633   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetNInterfaces () == 1 && \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetAddress (0, 0).GetLocal () =
      = Ipv4Address (\textcolor{stringliteral}{"127.0.0.1"}));
634   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a55d7e550c45e7a211ba8781f1b5b0015}{m\_lo} = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetNetDevice (0);
635   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (m\_lo != 0);
636   \textcolor{comment}{// Remember lo route}
637   RoutingTableEntry rt (\textcolor{comment}{/*device=*/} m\_lo, \textcolor{comment}{/*dst=*/} \hyperlink{classns3_1_1Ipv4Address_a583a93499e0d947439794d7bd0c6366d}{Ipv4Address::GetLoopback} (), \textcolor{comment}{/*
      know seqno=*/} \textcolor{keyword}{true}, \textcolor{comment}{/*seqno=*/} 0,
638                                     \textcolor{comment}{/*iface=*/} Ipv4InterfaceAddress (
      \hyperlink{classns3_1_1Ipv4Address_a583a93499e0d947439794d7bd0c6366d}{Ipv4Address::GetLoopback} (), Ipv4Mask (\textcolor{stringliteral}{"255.0.0.0"})),
639                                     \textcolor{comment}{/*hops=*/} 1, \textcolor{comment}{/*next hop=*/} 
      \hyperlink{classns3_1_1Ipv4Address_a583a93499e0d947439794d7bd0c6366d}{Ipv4Address::GetLoopback} (),
640                                     \textcolor{comment}{/*lifetime=*/} 
      \hyperlink{classns3_1_1Simulator_aa8dbab888dca7bf3528421d2c5e67f99}{Simulator::GetMaximumSimulationTime} ());
641   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a579e562e38e67d510de1ff2c87806c76}{AddRoute} (rt);
642 
643   \hyperlink{classns3_1_1Simulator_a2219ee02c0647adc83d1c918c3256266}{Simulator::ScheduleNow} (&\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a93dd1a9a127ebea592e06e3cf3f5cb11}{RoutingProtocol::Start}, \textcolor{keyword}{this});
644 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 83


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Set\+Max\+Queue\+Len@{Set\+Max\+Queue\+Len}}
\index{Set\+Max\+Queue\+Len@{Set\+Max\+Queue\+Len}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Max\+Queue\+Len(uint32\+\_\+t len)}{SetMaxQueueLen(uint32_t len)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Set\+Max\+Queue\+Len (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{len}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a852b0099e96031ff62da030f773720ac}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a852b0099e96031ff62da030f773720ac}

\begin{DoxyCode}
286 \{
287   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a5ded249d42f2e6364728892f32c15d9b}{m\_maxQueueLen} = len;
288   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_afd2e6004e54cac8abd2d95cec3ee9580}{m\_queue}.\hyperlink{classns3_1_1aodv_1_1RequestQueue_a4a71c31d25dfe0f97e970938076c00c5}{SetMaxQueueLen} (len);
289 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 84




Here is the caller graph for this function\+:
% FIG 85


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Set\+Max\+Queue\+Time@{Set\+Max\+Queue\+Time}}
\index{Set\+Max\+Queue\+Time@{Set\+Max\+Queue\+Time}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Max\+Queue\+Time(\+Time t)}{SetMaxQueueTime(Time t)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Set\+Max\+Queue\+Time (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{t}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a6da1de88e09c9f1fa1983713b5fdbac7}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a6da1de88e09c9f1fa1983713b5fdbac7}

\begin{DoxyCode}
292 \{
293   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a33caddd54ebe2e9c177b8986b5abb7ba}{m\_maxQueueTime} = t;
294   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_afd2e6004e54cac8abd2d95cec3ee9580}{m\_queue}.\hyperlink{classns3_1_1aodv_1_1RequestQueue_a9f81ff4709cfe0f0e88438a820c308f7}{SetQueueTimeout} (t);
295 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 86




Here is the caller graph for this function\+:
% FIG 87


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Start@{Start}}
\index{Start@{Start}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Start()}{Start()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Start (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a93dd1a9a127ebea592e06e3cf3f5cb11}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a93dd1a9a127ebea592e06e3cf3f5cb11}


Start protocol operation. 


\begin{DoxyCode}
342 \{
343   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
344   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac1cb4715e9ac42540c051268db368ae8}{m\_enableHello})
345     \{
346       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac1f61cf6b680f2fe8c82983d18bfd3cd}{m\_nb}.\hyperlink{classns3_1_1aodv_1_1Neighbors_a2eff3f9bda1412b0539c709acf0538cc}{ScheduleTimer} ();
347     \}
348   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac8ad71cc3349d46b7740f59dd18b91b0}{m\_rreqRateLimitTimer}.\hyperlink{classns3_1_1Timer_a044b29030c9de99298d51ac0ccfc104c}{SetFunction} (&
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee7a58848233510a151f89c92488c0dd}{RoutingProtocol::RreqRateLimitTimerExpire},
349                                     \textcolor{keyword}{this});
350   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_ac8ad71cc3349d46b7740f59dd18b91b0}{m\_rreqRateLimitTimer}.\hyperlink{classns3_1_1Timer_ac3345d696887578f518b19f359f7f94b}{Schedule} (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (1));
351 
352   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a0eaa679b6dea15e92c550591eabbccc1}{m\_rerrRateLimitTimer}.\hyperlink{classns3_1_1Timer_a044b29030c9de99298d51ac0ccfc104c}{SetFunction} (&
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a224b04cf88ed78efbc44014502125b53}{RoutingProtocol::RerrRateLimitTimerExpire},
353                                     \textcolor{keyword}{this});
354   \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a0eaa679b6dea15e92c550591eabbccc1}{m\_rerrRateLimitTimer}.\hyperlink{classns3_1_1Timer_ac3345d696887578f518b19f359f7f94b}{Schedule} (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (1));
355 
356 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 88




Here is the caller graph for this function\+:
% FIG 89


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Update\+Route\+Life\+Time@{Update\+Route\+Life\+Time}}
\index{Update\+Route\+Life\+Time@{Update\+Route\+Life\+Time}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Update\+Route\+Life\+Time(\+Ipv4\+Address addr, Time lt)}{UpdateRouteLifeTime(Ipv4Address addr, Time lt)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::aodv\+::\+Routing\+Protocol\+::\+Update\+Route\+Life\+Time (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{addr, }
\item[{{\bf Time}}]{lt}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a204c68e4ce5aa8dc799f9fd039f8cbc7}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a204c68e4ce5aa8dc799f9fd039f8cbc7}
Set lifetime field in routing table entry to the maximum of existing lifetime and lt, if the entry exists 
\begin{DoxyParams}{Parameters}
{\em addr} & -\/ destination address \\
\hline
{\em lt} & -\/ proposed time for lifetime field in routing table entry for destination with address addr. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if route to destination address addr exist 
\end{DoxyReturn}

\begin{DoxyCode}
1121 \{
1122   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << addr << lifetime);
1123   RoutingTableEntry rt;
1124   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a90cbc8a2c65cd68ccdaf768fcbb5d723}{LookupRoute} (addr, rt))
1125     \{
1126       \textcolor{keywordflow}{if} (rt.GetFlag () == \hyperlink{group__aodv_gga44216921a9c725a5ab8bc19059052a26af5fecee96bb2650aa417994840b43c99}{VALID})
1127         \{
1128           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Updating VALID route"});
1129           rt.SetRreqCnt (0);
1130           rt.SetLifeTime (\hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{std::max} (lifetime, rt.GetLifeTime ()));
1131           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a39fb5335110164f4c1b97682a3812dc1}{Update} (rt);
1132           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1133         \}
1134     \}
1135   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1136 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 90




Here is the caller graph for this function\+:
% FIG 91


\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!Update\+Route\+To\+Neighbor@{Update\+Route\+To\+Neighbor}}
\index{Update\+Route\+To\+Neighbor@{Update\+Route\+To\+Neighbor}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Update\+Route\+To\+Neighbor(\+Ipv4\+Address sender, Ipv4\+Address receiver)}{UpdateRouteToNeighbor(Ipv4Address sender, Ipv4Address receiver)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::aodv\+::\+Routing\+Protocol\+::\+Update\+Route\+To\+Neighbor (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{sender, }
\item[{{\bf Ipv4\+Address}}]{receiver}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a0df782358a389aadd46ceffab9535cef}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a0df782358a389aadd46ceffab9535cef}
Update neighbor record. 
\begin{DoxyParams}{Parameters}
{\em receiver} & is supposed to be my interface \\
\hline
{\em sender} & is supposed to be IP address of my neighbor. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1140 \{
1141   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \textcolor{stringliteral}{"sender "} << sender << \textcolor{stringliteral}{" receiver "} << receiver);
1142   RoutingTableEntry toNeighbor;
1143   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a90cbc8a2c65cd68ccdaf768fcbb5d723}{LookupRoute} (sender, toNeighbor))
1144     \{
1145       Ptr<NetDevice> dev = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetNetDevice (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetInterfaceForAddress (receiver));
1146       RoutingTableEntry newEntry (\textcolor{comment}{/*device=*/} dev, \textcolor{comment}{/*dst=*/} sender, \textcolor{comment}{/*know seqno=*/} \textcolor{keyword}{false}, \textcolor{comment}{/*seqno=*/} 0,
1147                                               \textcolor{comment}{/*iface=*/} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetAddress (
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetInterfaceForAddress (receiver), 0),
1148                                               \textcolor{comment}{/*hops=*/} 1, \textcolor{comment}{/*next hop=*/} sender, \textcolor{comment}{/*lifetime=*/} 
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a37ec921ef1c48e4d8e7072fe989613d2}{m\_activeRouteTimeout});
1149       \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a579e562e38e67d510de1ff2c87806c76}{AddRoute} (newEntry);
1150     \}
1151   \textcolor{keywordflow}{else}
1152     \{
1153       Ptr<NetDevice> dev = \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetNetDevice (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetInterfaceForAddress (receiver));
1154       \textcolor{keywordflow}{if} (toNeighbor.GetValidSeqNo () && (toNeighbor.GetHop () == 1) && (toNeighbor.GetOutputDevice () == 
      dev))
1155         \{
1156           toNeighbor.SetLifeTime (\hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{std::max} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a37ec921ef1c48e4d8e7072fe989613d2}{m\_activeRouteTimeout}, toNeighbor.
      GetLifeTime ()));
1157         \}
1158       \textcolor{keywordflow}{else}
1159         \{
1160           RoutingTableEntry newEntry (\textcolor{comment}{/*device=*/} dev, \textcolor{comment}{/*dst=*/} sender, \textcolor{comment}{/*know seqno=*/} \textcolor{keyword}{false}, \textcolor{comment}{/*seqno=*/} 0
      ,
1161                                                   \textcolor{comment}{/*iface=*/} \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetAddress (
      \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{m\_ipv4}->GetInterfaceForAddress (receiver), 0),
1162                                                   \textcolor{comment}{/*hops=*/} 1, \textcolor{comment}{/*next hop=*/} sender, \textcolor{comment}{/*lifetime=*/} 
      \hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{std::max} (\hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a37ec921ef1c48e4d8e7072fe989613d2}{m\_activeRouteTimeout}, toNeighbor.GetLifeTime ()));
1163           \hyperlink{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{m\_routingTable}.\hyperlink{classns3_1_1aodv_1_1RoutingTable_a39fb5335110164f4c1b97682a3812dc1}{Update} (newEntry);
1164         \}
1165     \}
1166 
1167 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 92




Here is the caller graph for this function\+:
% FIG 93




\subsection{Member Data Documentation}
\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!A\+O\+D\+V\+\_\+\+P\+O\+RT@{A\+O\+D\+V\+\_\+\+P\+O\+RT}}
\index{A\+O\+D\+V\+\_\+\+P\+O\+RT@{A\+O\+D\+V\+\_\+\+P\+O\+RT}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{A\+O\+D\+V\+\_\+\+P\+O\+RT}{AODV_PORT}}]{\setlength{\rightskip}{0pt plus 5cm}const uint32\+\_\+t ns3\+::aodv\+::\+Routing\+Protocol\+::\+A\+O\+D\+V\+\_\+\+P\+O\+RT = 654\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_ac4a3de99b49ad5f6efc9b71a700f7ec4}{}\label{classns3_1_1aodv_1_1RoutingProtocol_ac4a3de99b49ad5f6efc9b71a700f7ec4}


U\+DP Port for A\+O\+DV control traffic. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+active\+Route\+Timeout@{m\+\_\+active\+Route\+Timeout}}
\index{m\+\_\+active\+Route\+Timeout@{m\+\_\+active\+Route\+Timeout}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+active\+Route\+Timeout}{m_activeRouteTimeout}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+active\+Route\+Timeout\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a37ec921ef1c48e4d8e7072fe989613d2}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a37ec921ef1c48e4d8e7072fe989613d2}


Period of time during which the route is considered to be valid. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+address\+Req\+Timer@{m\+\_\+address\+Req\+Timer}}
\index{m\+\_\+address\+Req\+Timer@{m\+\_\+address\+Req\+Timer}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+address\+Req\+Timer}{m_addressReqTimer}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<${\bf Ipv4\+Address}, {\bf Timer}$>$ ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+address\+Req\+Timer\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a3e21cac8acb05e13339eb0cabf13ddcf}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a3e21cac8acb05e13339eb0cabf13ddcf}


Map IP address + R\+R\+EQ timer. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+allowed\+Hello\+Loss@{m\+\_\+allowed\+Hello\+Loss}}
\index{m\+\_\+allowed\+Hello\+Loss@{m\+\_\+allowed\+Hello\+Loss}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+allowed\+Hello\+Loss}{m_allowedHelloLoss}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+allowed\+Hello\+Loss\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a80e1dc9b9a640570ba5d5270846a2f6f}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a80e1dc9b9a640570ba5d5270846a2f6f}


Number of hello messages which may be loss for valid link. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+black\+List\+Timeout@{m\+\_\+black\+List\+Timeout}}
\index{m\+\_\+black\+List\+Timeout@{m\+\_\+black\+List\+Timeout}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+black\+List\+Timeout}{m_blackListTimeout}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+black\+List\+Timeout\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a23de7759e9c26ded382a09a860b4f987}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a23de7759e9c26ded382a09a860b4f987}


\hyperlink{classns3_1_1Time}{Time} for which the node is put into the blacklist. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+delete\+Period@{m\+\_\+delete\+Period}}
\index{m\+\_\+delete\+Period@{m\+\_\+delete\+Period}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+delete\+Period}{m_deletePeriod}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+delete\+Period\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_aa337fb24748eda19dda872f172e594a3}{}\label{classns3_1_1aodv_1_1RoutingProtocol_aa337fb24748eda19dda872f172e594a3}
Delete\+Period is intended to provide an upper bound on the time for which an upstream node A can have a neighbor B as an active next hop for destination D, while B has invalidated the route to D. \index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+destination\+Only@{m\+\_\+destination\+Only}}
\index{m\+\_\+destination\+Only@{m\+\_\+destination\+Only}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+destination\+Only}{m_destinationOnly}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+destination\+Only\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_aad49f5618b2843a1ae43a9c50aabc54f}{}\label{classns3_1_1aodv_1_1RoutingProtocol_aad49f5618b2843a1ae43a9c50aabc54f}


Indicates only the destination may respond to this R\+R\+EQ. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+dpd@{m\+\_\+dpd}}
\index{m\+\_\+dpd@{m\+\_\+dpd}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+dpd}{m_dpd}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Duplicate\+Packet\+Detection} ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+dpd\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a43361f0a08b0c538415910cd904d0af9}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a43361f0a08b0c538415910cd904d0af9}


Handle duplicated broadcast/multicast packets. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+enable\+Broadcast@{m\+\_\+enable\+Broadcast}}
\index{m\+\_\+enable\+Broadcast@{m\+\_\+enable\+Broadcast}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+enable\+Broadcast}{m_enableBroadcast}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+enable\+Broadcast\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a15b6c0f3a19ecf251f4492a71e95d080}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a15b6c0f3a19ecf251f4492a71e95d080}


Indicates whether a a broadcast data packets forwarding enable. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+enable\+Hello@{m\+\_\+enable\+Hello}}
\index{m\+\_\+enable\+Hello@{m\+\_\+enable\+Hello}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+enable\+Hello}{m_enableHello}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+enable\+Hello\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_ac1cb4715e9ac42540c051268db368ae8}{}\label{classns3_1_1aodv_1_1RoutingProtocol_ac1cb4715e9ac42540c051268db368ae8}


Indicates whether a hello messages enable. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+gratuitous\+Reply@{m\+\_\+gratuitous\+Reply}}
\index{m\+\_\+gratuitous\+Reply@{m\+\_\+gratuitous\+Reply}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+gratuitous\+Reply}{m_gratuitousReply}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+gratuitous\+Reply\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a492b1b69b8f91b56ba3301006318a4f3}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a492b1b69b8f91b56ba3301006318a4f3}


Indicates whether a gratuitous R\+R\+EP should be unicast to the node originated route discovery. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+hello\+Interval@{m\+\_\+hello\+Interval}}
\index{m\+\_\+hello\+Interval@{m\+\_\+hello\+Interval}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+hello\+Interval}{m_helloInterval}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+hello\+Interval\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_aa9750612eb154b537b1d7d0350cb8912}{}\label{classns3_1_1aodv_1_1RoutingProtocol_aa9750612eb154b537b1d7d0350cb8912}
Every Hello\+Interval the node checks whether it has sent a broadcast within the last Hello\+Interval. If it has not, it M\+AY broadcast a Hello message \index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+htimer@{m\+\_\+htimer}}
\index{m\+\_\+htimer@{m\+\_\+htimer}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+htimer}{m_htimer}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Timer} ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+htimer\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_af02203aca026cce1814848e0b025d212}{}\label{classns3_1_1aodv_1_1RoutingProtocol_af02203aca026cce1814848e0b025d212}


Hello timer. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+ipv4@{m\+\_\+ipv4}}
\index{m\+\_\+ipv4@{m\+\_\+ipv4}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+ipv4}{m_ipv4}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Ipv4}$>$ ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+ipv4\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}{}\label{classns3_1_1aodv_1_1RoutingProtocol_aee33006b1f9d8b24d4722037ff3fec98}


IP protocol. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+last\+Bcast\+Time@{m\+\_\+last\+Bcast\+Time}}
\index{m\+\_\+last\+Bcast\+Time@{m\+\_\+last\+Bcast\+Time}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+last\+Bcast\+Time}{m_lastBcastTime}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+last\+Bcast\+Time\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a0edfc4673f09d0145efba15a1476bc15}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a0edfc4673f09d0145efba15a1476bc15}


Keep track of the last bcast time. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+lo@{m\+\_\+lo}}
\index{m\+\_\+lo@{m\+\_\+lo}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+lo}{m_lo}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Net\+Device}$>$ ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+lo\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a55d7e550c45e7a211ba8781f1b5b0015}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a55d7e550c45e7a211ba8781f1b5b0015}


Loopback device used to defer R\+R\+EQ until packet will be fully formed. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+max\+Queue\+Len@{m\+\_\+max\+Queue\+Len}}
\index{m\+\_\+max\+Queue\+Len@{m\+\_\+max\+Queue\+Len}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Queue\+Len}{m_maxQueueLen}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+max\+Queue\+Len\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a5ded249d42f2e6364728892f32c15d9b}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a5ded249d42f2e6364728892f32c15d9b}


The maximum number of packets that we allow a routing protocol to buffer. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+max\+Queue\+Time@{m\+\_\+max\+Queue\+Time}}
\index{m\+\_\+max\+Queue\+Time@{m\+\_\+max\+Queue\+Time}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Queue\+Time}{m_maxQueueTime}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+max\+Queue\+Time\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a33caddd54ebe2e9c177b8986b5abb7ba}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a33caddd54ebe2e9c177b8986b5abb7ba}


The maximum period of time that a routing protocol is allowed to buffer a packet for. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+my\+Route\+Timeout@{m\+\_\+my\+Route\+Timeout}}
\index{m\+\_\+my\+Route\+Timeout@{m\+\_\+my\+Route\+Timeout}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+my\+Route\+Timeout}{m_myRouteTimeout}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+my\+Route\+Timeout\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a7681a59458486d0b7a61937a9a90b0a1}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a7681a59458486d0b7a61937a9a90b0a1}


Value of lifetime field in R\+R\+EP generating by this node. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+nb@{m\+\_\+nb}}
\index{m\+\_\+nb@{m\+\_\+nb}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+nb}{m_nb}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Neighbors} ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+nb\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_ac1f61cf6b680f2fe8c82983d18bfd3cd}{}\label{classns3_1_1aodv_1_1RoutingProtocol_ac1f61cf6b680f2fe8c82983d18bfd3cd}


Handle neighbors. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+net\+Diameter@{m\+\_\+net\+Diameter}}
\index{m\+\_\+net\+Diameter@{m\+\_\+net\+Diameter}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+net\+Diameter}{m_netDiameter}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+net\+Diameter\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a563c2234b89a44628f8e71b38e7c60ec}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a563c2234b89a44628f8e71b38e7c60ec}


Net diameter measures the maximum possible number of hops between two nodes in the network. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+net\+Traversal\+Time@{m\+\_\+net\+Traversal\+Time}}
\index{m\+\_\+net\+Traversal\+Time@{m\+\_\+net\+Traversal\+Time}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+net\+Traversal\+Time}{m_netTraversalTime}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+net\+Traversal\+Time\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a4642e67ba68a7ef40405f5773650ea1a}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a4642e67ba68a7ef40405f5773650ea1a}


Estimate of the average net traversal time. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+next\+Hop\+Wait@{m\+\_\+next\+Hop\+Wait}}
\index{m\+\_\+next\+Hop\+Wait@{m\+\_\+next\+Hop\+Wait}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+next\+Hop\+Wait}{m_nextHopWait}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+next\+Hop\+Wait\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_aeac3f146e52514d060a69f1a2d62690b}{}\label{classns3_1_1aodv_1_1RoutingProtocol_aeac3f146e52514d060a69f1a2d62690b}


Period of our waiting for the neighbour\textquotesingle{}s R\+R\+E\+P\+\_\+\+A\+CK. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+node\+Traversal\+Time@{m\+\_\+node\+Traversal\+Time}}
\index{m\+\_\+node\+Traversal\+Time@{m\+\_\+node\+Traversal\+Time}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+node\+Traversal\+Time}{m_nodeTraversalTime}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+node\+Traversal\+Time\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_ad467863779ea1559ad5942ff6c24a706}{}\label{classns3_1_1aodv_1_1RoutingProtocol_ad467863779ea1559ad5942ff6c24a706}
Node\+Traversal\+Time is a conservative estimate of the average one hop traversal time for packets and should include queuing delays, interrupt processing times and transfer times. \index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+path\+Discovery\+Time@{m\+\_\+path\+Discovery\+Time}}
\index{m\+\_\+path\+Discovery\+Time@{m\+\_\+path\+Discovery\+Time}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+path\+Discovery\+Time}{m_pathDiscoveryTime}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+path\+Discovery\+Time\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a491c2fe5559a8153343df590999b468f}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a491c2fe5559a8153343df590999b468f}


Estimate of maximum time needed to find route in network. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+queue@{m\+\_\+queue}}
\index{m\+\_\+queue@{m\+\_\+queue}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+queue}{m_queue}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Request\+Queue} ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+queue\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_afd2e6004e54cac8abd2d95cec3ee9580}{}\label{classns3_1_1aodv_1_1RoutingProtocol_afd2e6004e54cac8abd2d95cec3ee9580}


A \char`\"{}drop-\/front\char`\"{} queue used by the routing layer to buffer packets to which it does not have a route. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+request\+Id@{m\+\_\+request\+Id}}
\index{m\+\_\+request\+Id@{m\+\_\+request\+Id}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+request\+Id}{m_requestId}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+request\+Id\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a0075a9d7db2eeb40aaa9066c0a073942}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a0075a9d7db2eeb40aaa9066c0a073942}


Broadcast ID. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+rerr\+Count@{m\+\_\+rerr\+Count}}
\index{m\+\_\+rerr\+Count@{m\+\_\+rerr\+Count}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+rerr\+Count}{m_rerrCount}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+rerr\+Count\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a4afc71535ffd2ea1bd7dcb03e3fd4233}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a4afc71535ffd2ea1bd7dcb03e3fd4233}


Number of R\+E\+R\+Rs used for R\+E\+RR rate control. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+rerr\+Rate\+Limit@{m\+\_\+rerr\+Rate\+Limit}}
\index{m\+\_\+rerr\+Rate\+Limit@{m\+\_\+rerr\+Rate\+Limit}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+rerr\+Rate\+Limit}{m_rerrRateLimit}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+rerr\+Rate\+Limit\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_ad7a69761e61bcea41a2bc87ad8928e2d}{}\label{classns3_1_1aodv_1_1RoutingProtocol_ad7a69761e61bcea41a2bc87ad8928e2d}


Maximum number of R\+E\+ER per second. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+rerr\+Rate\+Limit\+Timer@{m\+\_\+rerr\+Rate\+Limit\+Timer}}
\index{m\+\_\+rerr\+Rate\+Limit\+Timer@{m\+\_\+rerr\+Rate\+Limit\+Timer}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+rerr\+Rate\+Limit\+Timer}{m_rerrRateLimitTimer}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Timer} ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+rerr\+Rate\+Limit\+Timer\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a0eaa679b6dea15e92c550591eabbccc1}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a0eaa679b6dea15e92c550591eabbccc1}


R\+E\+RR rate limit timer. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+routing\+Table@{m\+\_\+routing\+Table}}
\index{m\+\_\+routing\+Table@{m\+\_\+routing\+Table}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+routing\+Table}{m_routingTable}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Routing\+Table} ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+routing\+Table\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a4e1003a34c8adc96db71096d88c98ae0}


Routing table. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+rreq\+Count@{m\+\_\+rreq\+Count}}
\index{m\+\_\+rreq\+Count@{m\+\_\+rreq\+Count}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+rreq\+Count}{m_rreqCount}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+rreq\+Count\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a942f693d81f870c9ed9f155effae9577}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a942f693d81f870c9ed9f155effae9577}


Number of R\+R\+E\+Qs used for R\+R\+EQ rate control. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+rreq\+Id\+Cache@{m\+\_\+rreq\+Id\+Cache}}
\index{m\+\_\+rreq\+Id\+Cache@{m\+\_\+rreq\+Id\+Cache}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+rreq\+Id\+Cache}{m_rreqIdCache}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Id\+Cache} ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+rreq\+Id\+Cache\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a96743ff957b0a878c23e55a84e209d5d}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a96743ff957b0a878c23e55a84e209d5d}


Handle duplicated R\+R\+EQ. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+rreq\+Rate\+Limit@{m\+\_\+rreq\+Rate\+Limit}}
\index{m\+\_\+rreq\+Rate\+Limit@{m\+\_\+rreq\+Rate\+Limit}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+rreq\+Rate\+Limit}{m_rreqRateLimit}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+rreq\+Rate\+Limit\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a543abca2b224dcde1362f1050f1887c7}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a543abca2b224dcde1362f1050f1887c7}


Maximum number of R\+R\+EQ per second. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+rreq\+Rate\+Limit\+Timer@{m\+\_\+rreq\+Rate\+Limit\+Timer}}
\index{m\+\_\+rreq\+Rate\+Limit\+Timer@{m\+\_\+rreq\+Rate\+Limit\+Timer}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+rreq\+Rate\+Limit\+Timer}{m_rreqRateLimitTimer}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Timer} ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+rreq\+Rate\+Limit\+Timer\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_ac8ad71cc3349d46b7740f59dd18b91b0}{}\label{classns3_1_1aodv_1_1RoutingProtocol_ac8ad71cc3349d46b7740f59dd18b91b0}


R\+R\+EQ rate limit timer. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+rreq\+Retries@{m\+\_\+rreq\+Retries}}
\index{m\+\_\+rreq\+Retries@{m\+\_\+rreq\+Retries}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+rreq\+Retries}{m_rreqRetries}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+rreq\+Retries\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_abecbe245cb328bc299a47f9a8a89aa6e}{}\label{classns3_1_1aodv_1_1RoutingProtocol_abecbe245cb328bc299a47f9a8a89aa6e}


Maximum number of retransmissions of R\+R\+EQ with T\+TL = Net\+Diameter to discover a route. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+seq\+No@{m\+\_\+seq\+No}}
\index{m\+\_\+seq\+No@{m\+\_\+seq\+No}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+seq\+No}{m_seqNo}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+seq\+No\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_abf5ef6b30d0ccf20b9b5ecf7918f67b2}{}\label{classns3_1_1aodv_1_1RoutingProtocol_abf5ef6b30d0ccf20b9b5ecf7918f67b2}


Request sequence number. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+socket\+Addresses@{m\+\_\+socket\+Addresses}}
\index{m\+\_\+socket\+Addresses@{m\+\_\+socket\+Addresses}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+socket\+Addresses}{m_socketAddresses}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<$ {\bf Ptr}$<${\bf Socket}$>$, {\bf Ipv4\+Interface\+Address} $>$ ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+socket\+Addresses\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}{}\label{classns3_1_1aodv_1_1RoutingProtocol_aa3263563cbbd735faafbf17fd4e28a10}


Raw unicast socket per each IP interface, map socket -\/$>$ iface address (IP + mask) 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+socket\+Subnet\+Broadcast\+Addresses@{m\+\_\+socket\+Subnet\+Broadcast\+Addresses}}
\index{m\+\_\+socket\+Subnet\+Broadcast\+Addresses@{m\+\_\+socket\+Subnet\+Broadcast\+Addresses}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+socket\+Subnet\+Broadcast\+Addresses}{m_socketSubnetBroadcastAddresses}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<$ {\bf Ptr}$<${\bf Socket}$>$, {\bf Ipv4\+Interface\+Address} $>$ ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+socket\+Subnet\+Broadcast\+Addresses\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a3516a9ee6cc1a0ebde0fdc08680dc7c4}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a3516a9ee6cc1a0ebde0fdc08680dc7c4}


Raw subnet directed broadcast socket per each IP interface, map socket -\/$>$ iface address (IP + mask) 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+timeout\+Buffer@{m\+\_\+timeout\+Buffer}}
\index{m\+\_\+timeout\+Buffer@{m\+\_\+timeout\+Buffer}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+timeout\+Buffer}{m_timeoutBuffer}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+timeout\+Buffer\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a7805d2b1f8e48f3609f8770255a71e47}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a7805d2b1f8e48f3609f8770255a71e47}


Provide a buffer for the timeout. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+ttl\+Increment@{m\+\_\+ttl\+Increment}}
\index{m\+\_\+ttl\+Increment@{m\+\_\+ttl\+Increment}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+ttl\+Increment}{m_ttlIncrement}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+ttl\+Increment\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a7155a27e029832bfd90448bd6ae831db}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a7155a27e029832bfd90448bd6ae831db}


T\+TL increment for each attempt using the expanding ring search for R\+R\+EQ dissemination. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+ttl\+Start@{m\+\_\+ttl\+Start}}
\index{m\+\_\+ttl\+Start@{m\+\_\+ttl\+Start}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+ttl\+Start}{m_ttlStart}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+ttl\+Start\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_abc9bab73b39d584866faf18e95704e0f}{}\label{classns3_1_1aodv_1_1RoutingProtocol_abc9bab73b39d584866faf18e95704e0f}


Initial T\+TL value for R\+R\+EQ. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+ttl\+Threshold@{m\+\_\+ttl\+Threshold}}
\index{m\+\_\+ttl\+Threshold@{m\+\_\+ttl\+Threshold}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+ttl\+Threshold}{m_ttlThreshold}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+ttl\+Threshold\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a5fa99f38d3f75c20e1a89f4f2e60c42f}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a5fa99f38d3f75c20e1a89f4f2e60c42f}


Maximum T\+TL value for expanding ring search, T\+TL = Net\+Diameter is used beyond this value. 

\index{ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}!m\+\_\+uniform\+Random\+Variable@{m\+\_\+uniform\+Random\+Variable}}
\index{m\+\_\+uniform\+Random\+Variable@{m\+\_\+uniform\+Random\+Variable}!ns3\+::aodv\+::\+Routing\+Protocol@{ns3\+::aodv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+uniform\+Random\+Variable}{m_uniformRandomVariable}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Uniform\+Random\+Variable}$>$ ns3\+::aodv\+::\+Routing\+Protocol\+::m\+\_\+uniform\+Random\+Variable\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1aodv_1_1RoutingProtocol_a62dd29f4ef02720f5c1c00214dfdd7f9}{}\label{classns3_1_1aodv_1_1RoutingProtocol_a62dd29f4ef02720f5c1c00214dfdd7f9}


Provides uniform random variables. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
aodv/model/\hyperlink{aodv-routing-protocol_8h}{aodv-\/routing-\/protocol.\+h}\item 
aodv/model/\hyperlink{aodv-routing-protocol_8cc}{aodv-\/routing-\/protocol.\+cc}\end{DoxyCompactItemize}
