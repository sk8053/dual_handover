\hypertarget{classns3_1_1PacketSocket}{}\section{ns3\+:\+:Packet\+Socket Class Reference}
\label{classns3_1_1PacketSocket}\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}


A \hyperlink{classns3_1_1PacketSocket}{Packet\+Socket} is a link between an application and a net device.  




{\ttfamily \#include $<$packet-\/socket.\+h$>$}



Inheritance diagram for ns3\+:\+:Packet\+Socket\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Packet\+Socket\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1PacketSocket_aa9ad19e9cbfaa8330e2786612c7721d1}{Packet\+Socket} ()
\item 
virtual \hyperlink{classns3_1_1PacketSocket_ac758e4960755dc9eea9f2ec938bc2bb4}{$\sim$\+Packet\+Socket} ()
\item 
void \hyperlink{classns3_1_1PacketSocket_ac3b622ebee97e4b5cc78ed69c1e74bc5}{Set\+Node} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node)
\begin{DoxyCompactList}\small\item\em Set the associated node. \end{DoxyCompactList}\item 
virtual enum \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket\+Errno} \hyperlink{classns3_1_1PacketSocket_ad172bfb7074b6bc631d32698b5055570}{Get\+Errno} (void) const 
\begin{DoxyCompactList}\small\item\em Get last error number. \end{DoxyCompactList}\item 
virtual enum \hyperlink{classns3_1_1Socket_a698fbcc486a48b7a0d2b0e4ab863d571}{Socket\+Type} \hyperlink{classns3_1_1PacketSocket_ab9e1551e23008f93983bc22f7a4e1579}{Get\+Socket\+Type} (void) const 
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1PacketSocket_a247e66e20667d10c1aab2d3cb9158ba8}{Get\+Node} (void) const 
\begin{DoxyCompactList}\small\item\em Return the node this socket is associated with. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1PacketSocket_a1c05582ce254f43c42d91dec28957e75}{Bind} (void)
\begin{DoxyCompactList}\small\item\em Bind the socket to the \hyperlink{classns3_1_1NetDevice}{Net\+Device} and register the protocol handler. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1PacketSocket_a830ab9b76cfd7668d80564b142c276d1}{Bind6} (void)
\begin{DoxyCompactList}\small\item\em Bind the socket to the \hyperlink{classns3_1_1NetDevice}{Net\+Device} and register the protocol handler. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1PacketSocket_a1c50ba1bd9d23186d1c09f60d298095f}{Bind} (const \hyperlink{classns3_1_1Address}{Address} \&address)
\begin{DoxyCompactList}\small\item\em Bind the socket to the \hyperlink{classns3_1_1NetDevice}{Net\+Device} and register the protocol handler specified in the address. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1PacketSocket_acd416d93105815a2d2d2089d342efdd7}{Close} (void)
\begin{DoxyCompactList}\small\item\em Close a socket. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1PacketSocket_a4eb90477fd557de26e6da3ae5e47ccc7}{Shutdown\+Send} (void)
\item 
virtual int \hyperlink{classns3_1_1PacketSocket_a62cc0eda133c88406a3d5f0296d4436c}{Shutdown\+Recv} (void)
\item 
virtual int \hyperlink{classns3_1_1PacketSocket_a31cb58ed8f925fcc962e0ae78b31fe91}{Connect} (const \hyperlink{classns3_1_1Address}{Address} \&address)
\begin{DoxyCompactList}\small\item\em Initiate a connection to a remote host. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1PacketSocket_a263c5cd1fee6744bd79d997cdcbc7ef4}{Listen} (void)
\begin{DoxyCompactList}\small\item\em Listen for incoming connections. \end{DoxyCompactList}\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1PacketSocket_a11bf40b37d8cecd2067c880244be5de4}{Get\+Tx\+Available} (void) const 
\begin{DoxyCompactList}\small\item\em Returns the number of bytes which can be sent in a single call to Send. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1PacketSocket_a1fd81b9271758334d6abad658580b1a0}{Send} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, uint32\+\_\+t flags)
\begin{DoxyCompactList}\small\item\em Send data (or dummy data) to the remote host. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1PacketSocket_a66dc5b7e29ad76f07ff46368f75b9165}{Send\+To} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, uint32\+\_\+t flags, const \hyperlink{classns3_1_1Address}{Address} \&to\+Address)
\begin{DoxyCompactList}\small\item\em Send data to a specified peer. \end{DoxyCompactList}\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1PacketSocket_a088f17e0f260b028521b9ef230016a86}{Get\+Rx\+Available} (void) const 
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{classns3_1_1PacketSocket_a8f19cc86b32a0a80a2738be64e05b202}{Recv} (uint32\+\_\+t max\+Size, uint32\+\_\+t flags)
\begin{DoxyCompactList}\small\item\em Read data from the socket. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{classns3_1_1PacketSocket_a03c078024aa5ab71c8d0b6d951a740dc}{Recv\+From} (uint32\+\_\+t max\+Size, uint32\+\_\+t flags, \hyperlink{classns3_1_1Address}{Address} \&from\+Address)
\begin{DoxyCompactList}\small\item\em Read a single packet from the socket and retrieve the sender address. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1PacketSocket_a78d52c70c989f0473e64cb51301b2379}{Get\+Sock\+Name} (\hyperlink{classns3_1_1Address}{Address} \&address) const 
\begin{DoxyCompactList}\small\item\em Get socket address. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1PacketSocket_a2a8bd0a6624593cb7d6b4171dd173049}{Get\+Peer\+Name} (\hyperlink{classns3_1_1Address}{Address} \&address) const 
\begin{DoxyCompactList}\small\item\em Get the peer address of a connected socket. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1PacketSocket_a0d903ba3ca9ad905a9c347254ae6a9b9}{Set\+Allow\+Broadcast} (bool allow\+Broadcast)
\begin{DoxyCompactList}\small\item\em Configure whether broadcast datagram transmissions are allowed. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1PacketSocket_a831b498999fd1d3852512009df3e7cba}{Get\+Allow\+Broadcast} () const 
\begin{DoxyCompactList}\small\item\em Query whether broadcast datagram transmissions are allowed. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1PacketSocket_aa6d6009b60e1d9b8b6af64446bb68282}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5}{State} \{ \hyperlink{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5af534e442cba41165df3d12c889608f03}{S\+T\+A\+T\+E\+\_\+\+O\+P\+EN}, 
\hyperlink{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5a22a3caeaebc3bfbb85d13fc9a807162a}{S\+T\+A\+T\+E\+\_\+\+B\+O\+U\+ND}, 
\hyperlink{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5abba9e14603bb16ef4fa03ddfc1224641}{S\+T\+A\+T\+E\+\_\+\+C\+O\+N\+N\+E\+C\+T\+ED}, 
\hyperlink{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5a6fe4f17ed49f9a87aba67738af434437}{S\+T\+A\+T\+E\+\_\+\+C\+L\+O\+S\+ED}
 \}\begin{DoxyCompactList}\small\item\em States of the socket. \end{DoxyCompactList}
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classns3_1_1PacketSocket_a889f1446a549aecd23e6f442791ae6b7}{Forward\+Up} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, uint16\+\_\+t protocol, const \hyperlink{classns3_1_1Address}{Address} \&\hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from}, const \hyperlink{classns3_1_1Address}{Address} \&to, \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2}{Net\+Device\+::\+Packet\+Type} packet\+Type)
\begin{DoxyCompactList}\small\item\em Called by the L3 protocol when it received a packet to pass on to T\+CP. \end{DoxyCompactList}\item 
int \hyperlink{classns3_1_1PacketSocket_a53aa1ab0fc18ef2d3389585f0440e181}{Do\+Bind} (const \hyperlink{classns3_1_1PacketSocketAddress}{Packet\+Socket\+Address} \&address)
\begin{DoxyCompactList}\small\item\em Bind the socket to the \hyperlink{classns3_1_1NetDevice}{Net\+Device} and register the protocol handler specified in the address. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1PacketSocket_a3601a739034d0d2e46ccc45f2073e02f}{Get\+Min\+Mtu} (\hyperlink{classns3_1_1PacketSocketAddress}{Packet\+Socket\+Address} ad) const 
\begin{DoxyCompactList}\small\item\em Get the minimum M\+TU supported by the Net\+Devices bound to a specific address. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1PacketSocket_a1137ff2a8fcc74682b220c059642ee28}{Do\+Dispose} (void)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1PacketSocket_a1d16a7bb40df82877d5b6b257861d566}{m\+\_\+node}
\begin{DoxyCompactList}\small\item\em the associated node \end{DoxyCompactList}\item 
enum \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket\+Errno} \hyperlink{classns3_1_1PacketSocket_ac1da4372f719a7fb20b8d7fa426f21cc}{m\+\_\+errno}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Socket}{Socket} error code. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1PacketSocket_ad16347ae79f47e980085db3a2674dc40}{m\+\_\+shutdown\+Send}
\begin{DoxyCompactList}\small\item\em Send no longer allowed. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1PacketSocket_af766986fa3298b3156972c0559fb8fa5}{m\+\_\+shutdown\+Recv}
\begin{DoxyCompactList}\small\item\em Receive no longer allowed. \end{DoxyCompactList}\item 
enum \hyperlink{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5}{State} \hyperlink{classns3_1_1PacketSocket_adbf0f1f9b0a0bed7169ecdcb5a1ef66a}{m\+\_\+state}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Socket}{Socket} state. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1PacketSocket_ab563605d15111f7caef9a0c9ca18167c}{m\+\_\+protocol}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Socket}{Socket} protocol. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1PacketSocket_a8d45062d8bdc229074cfc45e4abb77ec}{m\+\_\+is\+Single\+Device}
\begin{DoxyCompactList}\small\item\em Is bound to a single net\+Device. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1PacketSocket_ad55c1b060ff4bce8e74e874c83cf88d3}{m\+\_\+device}
\begin{DoxyCompactList}\small\item\em index of the bound \hyperlink{classns3_1_1NetDevice}{Net\+Device} \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1PacketSocket_a22323e0871995f6f217d647301923ceb}{m\+\_\+dest\+Addr}
\begin{DoxyCompactList}\small\item\em Default destination address. \end{DoxyCompactList}\item 
std\+::queue$<$ std\+::pair$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$, \hyperlink{classns3_1_1Address}{Address} $>$ $>$ \hyperlink{classns3_1_1PacketSocket_a436086ef3cbe575138ad46c14e58aa56}{m\+\_\+delivery\+Queue}
\begin{DoxyCompactList}\small\item\em Rx queue. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1PacketSocket_a3afd17f0f1692c887648d0c2cb6d406c}{m\+\_\+rx\+Available}
\begin{DoxyCompactList}\small\item\em Rx queue size \mbox{[}Bytes\mbox{]}. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1PacketSocket_ae962e642085d93dadd3832a0355a10ad}{m\+\_\+drop\+Trace}
\begin{DoxyCompactList}\small\item\em Traced callback\+: dropped packets. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1PacketSocket_a77f51ae1c17685fee11e5e10d90bd2f4}{m\+\_\+rcv\+Buf\+Size}
\begin{DoxyCompactList}\small\item\em Rx buffer size \mbox{[}Bytes\mbox{]}. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
A \hyperlink{classns3_1_1PacketSocket}{Packet\+Socket} is a link between an application and a net device. 

A \hyperlink{classns3_1_1PacketSocket}{Packet\+Socket} can be used to connect an application to a net device. The application provides the buffers of data, the socket converts them to a raw packet and the net device then adds the protocol specific headers and trailers. This socket type is very similar to the linux and B\+SD \char`\"{}packet\char`\"{} sockets.

Here is a summary of the semantics of this class\+:
\begin{DoxyItemize}
\item Bind\+: Bind uses only the protocol and device fields of the \hyperlink{classns3_1_1PacketSocketAddress}{Packet\+Socket\+Address}. If none are provided, Bind uses zero for both, which means that the socket is bound to all protocols on all devices on the node.
\item Connect\+: uses only the protocol, device and \char`\"{}physical address\char`\"{} field of the \hyperlink{classns3_1_1PacketSocketAddress}{Packet\+Socket\+Address}. It is used to set the default destination address for outgoing packets.
\item Send\+: send the input packet to the underlying Net\+Devices with the default destination address. The socket must be bound and connected.
\item Send\+To\+: uses the protocol, device, and \char`\"{}physical address\char`\"{} fields of the \hyperlink{classns3_1_1PacketSocketAddress}{Packet\+Socket\+Address}. The device value is used to specialize the packet transmission to a single device, the protocol value specifies the protocol of this packet only and the \char`\"{}physical address\char`\"{} field is used to override the default destination address. The socket must be bound.
\item Recv\+: The address represents the address of the packer originator. The fields \char`\"{}physical address\char`\"{}, device, and protocol are filled.
\item Accept\+: not allowed
\item Listen\+: returns -\/1 (O\+P\+N\+O\+T\+S\+U\+PP)
\end{DoxyItemize}

\hyperlink{classns3_1_1Socket}{Socket} data that is read from this socket using the methods returning an \hyperlink{classns3_1_1Packet}{ns3\+::\+Packet} object (i.\+e., Recv (), Recv\+Msg (), Recv\+From ()) will return \hyperlink{classns3_1_1Packet}{Packet} objects with three Packet\+Tag objects attached. Applications may wish to read the extra out-\/of-\/band data provided in these tags, and may safely remove the tags from the \hyperlink{classns3_1_1Packet}{Packet}.


\begin{DoxyItemize}
\item \hyperlink{classns3_1_1PacketSocketTag}{Packet\+Socket\+Tag}\+: contains destination address (type \hyperlink{classns3_1_1PacketSocketAddress}{Packet\+Socket\+Address}) and packet type of the received packet
\item \hyperlink{classns3_1_1DeviceNameTag}{Device\+Name\+Tag}\+: contains the \hyperlink{classns3_1_1TypeId}{Type\+Id} string of the relevant \hyperlink{classns3_1_1NetDevice}{Net\+Device}
\end{DoxyItemize}

\begin{DoxySeeAlso}{See also}
class \hyperlink{classns3_1_1PacketSocketTag}{Packet\+Socket\+Tag} 

class \hyperlink{classns3_1_1DeviceNameTag}{Device\+Name\+Tag} 
\end{DoxySeeAlso}


\subsection{Member Enumeration Documentation}
\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!State@{State}}
\index{State@{State}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{State}{State}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf ns3\+::\+Packet\+Socket\+::\+State}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5}{}\label{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5}


States of the socket. 

\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{S\+T\+A\+T\+E\+\_\+\+O\+P\+EN@{S\+T\+A\+T\+E\+\_\+\+O\+P\+EN}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!S\+T\+A\+T\+E\+\_\+\+O\+P\+EN@{S\+T\+A\+T\+E\+\_\+\+O\+P\+EN}}\item[{\em 
S\+T\+A\+T\+E\+\_\+\+O\+P\+EN\hypertarget{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5af534e442cba41165df3d12c889608f03}{}\label{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5af534e442cba41165df3d12c889608f03}
}]\index{S\+T\+A\+T\+E\+\_\+\+B\+O\+U\+ND@{S\+T\+A\+T\+E\+\_\+\+B\+O\+U\+ND}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!S\+T\+A\+T\+E\+\_\+\+B\+O\+U\+ND@{S\+T\+A\+T\+E\+\_\+\+B\+O\+U\+ND}}\item[{\em 
S\+T\+A\+T\+E\+\_\+\+B\+O\+U\+ND\hypertarget{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5a22a3caeaebc3bfbb85d13fc9a807162a}{}\label{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5a22a3caeaebc3bfbb85d13fc9a807162a}
}]\index{S\+T\+A\+T\+E\+\_\+\+C\+O\+N\+N\+E\+C\+T\+ED@{S\+T\+A\+T\+E\+\_\+\+C\+O\+N\+N\+E\+C\+T\+ED}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!S\+T\+A\+T\+E\+\_\+\+C\+O\+N\+N\+E\+C\+T\+ED@{S\+T\+A\+T\+E\+\_\+\+C\+O\+N\+N\+E\+C\+T\+ED}}\item[{\em 
S\+T\+A\+T\+E\+\_\+\+C\+O\+N\+N\+E\+C\+T\+ED\hypertarget{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5abba9e14603bb16ef4fa03ddfc1224641}{}\label{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5abba9e14603bb16ef4fa03ddfc1224641}
}]\index{S\+T\+A\+T\+E\+\_\+\+C\+L\+O\+S\+ED@{S\+T\+A\+T\+E\+\_\+\+C\+L\+O\+S\+ED}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!S\+T\+A\+T\+E\+\_\+\+C\+L\+O\+S\+ED@{S\+T\+A\+T\+E\+\_\+\+C\+L\+O\+S\+ED}}\item[{\em 
S\+T\+A\+T\+E\+\_\+\+C\+L\+O\+S\+ED\hypertarget{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5a6fe4f17ed49f9a87aba67738af434437}{}\label{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5a6fe4f17ed49f9a87aba67738af434437}
}]\end{description}
\end{Desc}

\begin{DoxyCode}
188              \{
189     \hyperlink{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5af534e442cba41165df3d12c889608f03}{STATE\_OPEN},
190     \hyperlink{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5a22a3caeaebc3bfbb85d13fc9a807162a}{STATE\_BOUND},     \textcolor{comment}{// open and bound}
191     \hyperlink{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5abba9e14603bb16ef4fa03ddfc1224641}{STATE\_CONNECTED}, \textcolor{comment}{// open, bound and connected}
192     \hyperlink{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5a6fe4f17ed49f9a87aba67738af434437}{STATE\_CLOSED}
193   \};
\end{DoxyCode}


\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!Packet\+Socket@{Packet\+Socket}}
\index{Packet\+Socket@{Packet\+Socket}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{Packet\+Socket()}{PacketSocket()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Packet\+Socket\+::\+Packet\+Socket (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PacketSocket_aa9ad19e9cbfaa8330e2786612c7721d1}{}\label{classns3_1_1PacketSocket_aa9ad19e9cbfaa8330e2786612c7721d1}

\begin{DoxyCode}
57                             : \hyperlink{classns3_1_1PacketSocket_a3afd17f0f1692c887648d0c2cb6d406c}{m\_rxAvailable} (0)
58 \{
59   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
60   \hyperlink{classns3_1_1PacketSocket_adbf0f1f9b0a0bed7169ecdcb5a1ef66a}{m\_state} = \hyperlink{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5af534e442cba41165df3d12c889608f03}{STATE\_OPEN};
61   \hyperlink{classns3_1_1PacketSocket_ad16347ae79f47e980085db3a2674dc40}{m\_shutdownSend} = \textcolor{keyword}{false};
62   \hyperlink{classns3_1_1PacketSocket_af766986fa3298b3156972c0559fb8fa5}{m\_shutdownRecv} = \textcolor{keyword}{false};
63   \hyperlink{classns3_1_1PacketSocket_ac1da4372f719a7fb20b8d7fa426f21cc}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaaa7eb006d73c5ad0117c5591fcb3469f7}{ERROR\_NOTERROR};
64   \hyperlink{classns3_1_1PacketSocket_a8d45062d8bdc229074cfc45e4abb77ec}{m\_isSingleDevice} = \textcolor{keyword}{false};
65   \hyperlink{classns3_1_1PacketSocket_ad55c1b060ff4bce8e74e874c83cf88d3}{m\_device} = 0;
66 \}
\end{DoxyCode}
\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!````~Packet\+Socket@{$\sim$\+Packet\+Socket}}
\index{````~Packet\+Socket@{$\sim$\+Packet\+Socket}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{$\sim$\+Packet\+Socket()}{~PacketSocket()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Packet\+Socket\+::$\sim$\+Packet\+Socket (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1PacketSocket_ac758e4960755dc9eea9f2ec938bc2bb4}{}\label{classns3_1_1PacketSocket_ac758e4960755dc9eea9f2ec938bc2bb4}

\begin{DoxyCode}
76 \{
77   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
78 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!Bind@{Bind}}
\index{Bind@{Bind}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{Bind(void)}{Bind(void)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Packet\+Socket\+::\+Bind (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1PacketSocket_a1c05582ce254f43c42d91dec28957e75}{}\label{classns3_1_1PacketSocket_a1c05582ce254f43c42d91dec28957e75}


Bind the socket to the \hyperlink{classns3_1_1NetDevice}{Net\+Device} and register the protocol handler. 

\begin{DoxyWarning}{Warning}
this will actually bind protocol \char`\"{}0\char`\"{}.
\end{DoxyWarning}
\begin{DoxyReturn}{Returns}
0 on success, -\/1 on failure. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_a680c1edd8b3ec3adf4085e1ded1e8a0d}{ns3\+::\+Socket}.


\begin{DoxyCode}
110 \{
111   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
112   PacketSocketAddress address;
113   address.SetProtocol (0);
114   address.SetAllDevices ();
115   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1PacketSocket_a53aa1ab0fc18ef2d3389585f0440e181}{DoBind} (address);
116 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2




Here is the caller graph for this function\+:
% FIG 3


\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!Bind@{Bind}}
\index{Bind@{Bind}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{Bind(const Address \&address)}{Bind(const Address &address)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Packet\+Socket\+::\+Bind (
\begin{DoxyParamCaption}
\item[{const {\bf Address} \&}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1PacketSocket_a1c50ba1bd9d23186d1c09f60d298095f}{}\label{classns3_1_1PacketSocket_a1c50ba1bd9d23186d1c09f60d298095f}


Bind the socket to the \hyperlink{classns3_1_1NetDevice}{Net\+Device} and register the protocol handler specified in the address. 


\begin{DoxyParams}{Parameters}
{\em address} & the packet socket address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, -\/1 on failure. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_ada93439a43de2028b5a8fc6621dad482}{ns3\+::\+Socket}.


\begin{DoxyCode}
127 \{ 
128   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << address);
129   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1PacketSocketAddress_a9426c99ec2c26c22d3920ca5c63ae1cd}{PacketSocketAddress::IsMatchingType} (address))
130     \{
131       \hyperlink{classns3_1_1PacketSocket_ac1da4372f719a7fb20b8d7fa426f21cc}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa4b98dd50740861229f8e03bcc36d379b}{ERROR\_INVAL};
132       \textcolor{keywordflow}{return} -1;
133     \}
134   PacketSocketAddress ad = \hyperlink{classns3_1_1PacketSocketAddress_ab90d0401de757d2da5bf1ad07af2ecf5}{PacketSocketAddress::ConvertFrom} (address);
135   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1PacketSocket_a53aa1ab0fc18ef2d3389585f0440e181}{DoBind} (ad);
136 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4


\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!Bind6@{Bind6}}
\index{Bind6@{Bind6}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{Bind6(void)}{Bind6(void)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Packet\+Socket\+::\+Bind6 (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1PacketSocket_a830ab9b76cfd7668d80564b142c276d1}{}\label{classns3_1_1PacketSocket_a830ab9b76cfd7668d80564b142c276d1}


Bind the socket to the \hyperlink{classns3_1_1NetDevice}{Net\+Device} and register the protocol handler. 

\begin{DoxyWarning}{Warning}
this will actually bind protocol \char`\"{}0\char`\"{}.
\end{DoxyWarning}
\begin{DoxyReturn}{Returns}
0 on success, -\/1 on failure. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_a68a4f2bcd38dec94d5a6fd4d867a1f19}{ns3\+::\+Socket}.


\begin{DoxyCode}
120 \{
121   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
122   \textcolor{keywordflow}{return}(\hyperlink{classns3_1_1PacketSocket_a1c05582ce254f43c42d91dec28957e75}{Bind}());
123 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5


\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!Close@{Close}}
\index{Close@{Close}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{Close(void)}{Close(void)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Packet\+Socket\+::\+Close (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1PacketSocket_acd416d93105815a2d2d2089d342efdd7}{}\label{classns3_1_1PacketSocket_acd416d93105815a2d2d2089d342efdd7}


Close a socket. 

\begin{DoxyReturn}{Returns}
zero on success, -\/1 on failure.
\end{DoxyReturn}
After the Close call, the socket is no longer valid, and cannot safely be used for subsequent operations. 

Implements \hyperlink{classns3_1_1Socket_abdac6e2498c5aa2963ef361d4200ddf3}{ns3\+::\+Socket}.


\begin{DoxyCode}
200 \{
201   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
202   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PacketSocket_adbf0f1f9b0a0bed7169ecdcb5a1ef66a}{m\_state} == \hyperlink{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5a6fe4f17ed49f9a87aba67738af434437}{STATE\_CLOSED})
203     \{
204       \hyperlink{classns3_1_1PacketSocket_ac1da4372f719a7fb20b8d7fa426f21cc}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa9d232a0dd40ca7e637e974b88b973db9}{ERROR\_BADF};
205       \textcolor{keywordflow}{return} -1;
206     \}
207   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PacketSocket_adbf0f1f9b0a0bed7169ecdcb5a1ef66a}{m\_state} == \hyperlink{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5a22a3caeaebc3bfbb85d13fc9a807162a}{STATE\_BOUND} || \hyperlink{classns3_1_1PacketSocket_adbf0f1f9b0a0bed7169ecdcb5a1ef66a}{m\_state} == 
      \hyperlink{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5abba9e14603bb16ef4fa03ddfc1224641}{STATE\_CONNECTED})
208     \{
209       \hyperlink{classns3_1_1PacketSocket_a1d16a7bb40df82877d5b6b257861d566}{m\_node}->\hyperlink{classns3_1_1Node_a059495453e24a8fc768daea91732984b}{UnregisterProtocolHandler} (
      \hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&\hyperlink{classns3_1_1PacketSocket_a889f1446a549aecd23e6f442791ae6b7}{PacketSocket::ForwardUp}, \textcolor{keyword}{this}));
210     \}
211   \hyperlink{classns3_1_1PacketSocket_adbf0f1f9b0a0bed7169ecdcb5a1ef66a}{m\_state} = \hyperlink{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5a6fe4f17ed49f9a87aba67738af434437}{STATE\_CLOSED};
212   \hyperlink{classns3_1_1PacketSocket_ad16347ae79f47e980085db3a2674dc40}{m\_shutdownSend} = \textcolor{keyword}{true};
213   \hyperlink{classns3_1_1PacketSocket_af766986fa3298b3156972c0559fb8fa5}{m\_shutdownRecv} = \textcolor{keyword}{true};
214   \textcolor{keywordflow}{return} 0;
215 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6


\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!Connect@{Connect}}
\index{Connect@{Connect}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{Connect(const Address \&address)}{Connect(const Address &address)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Packet\+Socket\+::\+Connect (
\begin{DoxyParamCaption}
\item[{const {\bf Address} \&}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1PacketSocket_a31cb58ed8f925fcc962e0ae78b31fe91}{}\label{classns3_1_1PacketSocket_a31cb58ed8f925fcc962e0ae78b31fe91}


Initiate a connection to a remote host. 


\begin{DoxyParams}{Parameters}
{\em address} & \hyperlink{classns3_1_1Address}{Address} of remote. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, -\/1 on error (in which case errno is set). 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_a97f08aaf37b8fd7d4b5cad4dfdd4022a}{ns3\+::\+Socket}.


\begin{DoxyCode}
219 \{
220   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << ad);
221   PacketSocketAddress address;
222   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PacketSocket_adbf0f1f9b0a0bed7169ecdcb5a1ef66a}{m\_state} == \hyperlink{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5a6fe4f17ed49f9a87aba67738af434437}{STATE\_CLOSED})
223     \{
224       \hyperlink{classns3_1_1PacketSocket_ac1da4372f719a7fb20b8d7fa426f21cc}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa9d232a0dd40ca7e637e974b88b973db9}{ERROR\_BADF};
225       \textcolor{keywordflow}{goto} error;
226     \}
227   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PacketSocket_adbf0f1f9b0a0bed7169ecdcb5a1ef66a}{m\_state} == \hyperlink{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5af534e442cba41165df3d12c889608f03}{STATE\_OPEN})
228     \{
229       \textcolor{comment}{// connect should happen \_after\_ bind.}
230       \hyperlink{classns3_1_1PacketSocket_ac1da4372f719a7fb20b8d7fa426f21cc}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa4b98dd50740861229f8e03bcc36d379b}{ERROR\_INVAL}; \textcolor{comment}{// generic error condition.}
231       \textcolor{keywordflow}{goto} error;
232     \}
233   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PacketSocket_adbf0f1f9b0a0bed7169ecdcb5a1ef66a}{m\_state} == \hyperlink{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5abba9e14603bb16ef4fa03ddfc1224641}{STATE\_CONNECTED})
234     \{
235       \hyperlink{classns3_1_1PacketSocket_ac1da4372f719a7fb20b8d7fa426f21cc}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaab22886c569f1ba155c63e5c31bd0e77a}{ERROR\_ISCONN};
236       \textcolor{keywordflow}{goto} error;
237     \}
238   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1PacketSocketAddress_a9426c99ec2c26c22d3920ca5c63ae1cd}{PacketSocketAddress::IsMatchingType} (ad))
239     \{
240       \hyperlink{classns3_1_1PacketSocket_ac1da4372f719a7fb20b8d7fa426f21cc}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa7f4cc7185e365fb30fc5e2a4ec9f1c24}{ERROR\_AFNOSUPPORT};
241       \textcolor{keywordflow}{goto} error;
242     \}
243   \hyperlink{classns3_1_1PacketSocket_a22323e0871995f6f217d647301923ceb}{m\_destAddr} = ad;
244   \hyperlink{classns3_1_1PacketSocket_adbf0f1f9b0a0bed7169ecdcb5a1ef66a}{m\_state} = \hyperlink{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5abba9e14603bb16ef4fa03ddfc1224641}{STATE\_CONNECTED};
245   \hyperlink{classns3_1_1Socket_a2f55d195304131b356818bc74134c5a7}{NotifyConnectionSucceeded} ();
246   \textcolor{keywordflow}{return} 0;
247 error:
248   \hyperlink{classns3_1_1Socket_a34f83cdc8fb487ac8ea5436d184827c4}{NotifyConnectionFailed} ();
249   \textcolor{keywordflow}{return} -1;
250 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7


\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!Do\+Bind@{Do\+Bind}}
\index{Do\+Bind@{Do\+Bind}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{Do\+Bind(const Packet\+Socket\+Address \&address)}{DoBind(const PacketSocketAddress &address)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Packet\+Socket\+::\+Do\+Bind (
\begin{DoxyParamCaption}
\item[{const {\bf Packet\+Socket\+Address} \&}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PacketSocket_a53aa1ab0fc18ef2d3389585f0440e181}{}\label{classns3_1_1PacketSocket_a53aa1ab0fc18ef2d3389585f0440e181}


Bind the socket to the \hyperlink{classns3_1_1NetDevice}{Net\+Device} and register the protocol handler specified in the address. 


\begin{DoxyParams}{Parameters}
{\em address} & the packet socket address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, -\/1 on failure. 
\end{DoxyReturn}

\begin{DoxyCode}
140 \{
141   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << address);
142   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PacketSocket_adbf0f1f9b0a0bed7169ecdcb5a1ef66a}{m\_state} == \hyperlink{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5a22a3caeaebc3bfbb85d13fc9a807162a}{STATE\_BOUND} ||
143       \hyperlink{classns3_1_1PacketSocket_adbf0f1f9b0a0bed7169ecdcb5a1ef66a}{m\_state} == \hyperlink{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5abba9e14603bb16ef4fa03ddfc1224641}{STATE\_CONNECTED})
144     \{
145       \hyperlink{classns3_1_1PacketSocket_ac1da4372f719a7fb20b8d7fa426f21cc}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa4b98dd50740861229f8e03bcc36d379b}{ERROR\_INVAL};
146       \textcolor{keywordflow}{return} -1;
147     \}
148   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PacketSocket_adbf0f1f9b0a0bed7169ecdcb5a1ef66a}{m\_state} == \hyperlink{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5a6fe4f17ed49f9a87aba67738af434437}{STATE\_CLOSED})
149     \{
150       \hyperlink{classns3_1_1PacketSocket_ac1da4372f719a7fb20b8d7fa426f21cc}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa9d232a0dd40ca7e637e974b88b973db9}{ERROR\_BADF};
151       \textcolor{keywordflow}{return} -1;
152     \}
153   Ptr<NetDevice> dev;
154   \textcolor{keywordflow}{if} (address.IsSingleDevice ())
155     \{
156       dev = \hyperlink{classns3_1_1PacketSocket_a1d16a7bb40df82877d5b6b257861d566}{m\_node}->\hyperlink{classns3_1_1Node_a5918dfd24ef632efc9a83a5f6561c76e}{GetDevice} (address.GetSingleDevice ());
157     \}
158   \textcolor{keywordflow}{else}
159     \{
160       dev = 0;
161     \}
162   \hyperlink{classns3_1_1PacketSocket_a1d16a7bb40df82877d5b6b257861d566}{m\_node}->\hyperlink{classns3_1_1Node_af713f0e7ea5c49b4fa0b3613405c45fa}{RegisterProtocolHandler} (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1PacketSocket_a889f1446a549aecd23e6f442791ae6b7}{PacketSocket::ForwardUp}, \textcolor{keyword}{this}),
163                                    address.GetProtocol (), dev);
164   \hyperlink{classns3_1_1PacketSocket_adbf0f1f9b0a0bed7169ecdcb5a1ef66a}{m\_state} = \hyperlink{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5a22a3caeaebc3bfbb85d13fc9a807162a}{STATE\_BOUND};
165   \hyperlink{classns3_1_1PacketSocket_ab563605d15111f7caef9a0c9ca18167c}{m\_protocol} = address.GetProtocol ();
166   \hyperlink{classns3_1_1PacketSocket_a8d45062d8bdc229074cfc45e4abb77ec}{m\_isSingleDevice} = address.IsSingleDevice ();
167   \hyperlink{classns3_1_1PacketSocket_ad55c1b060ff4bce8e74e874c83cf88d3}{m\_device} = address.GetSingleDevice ();
168   \hyperlink{classns3_1_1Socket_a9781d8dfdb5e9364d5dce8f53b768bb5}{m\_boundnetdevice} = dev;
169   \textcolor{keywordflow}{return} 0;
170 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8




Here is the caller graph for this function\+:
% FIG 9


\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{Do\+Dispose(void)}{DoDispose(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Packet\+Socket\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1PacketSocket_a1137ff2a8fcc74682b220c059642ee28}{}\label{classns3_1_1PacketSocket_a1137ff2a8fcc74682b220c059642ee28}
Destructor implementation.

This method is called by \hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose()} or by the \hyperlink{classns3_1_1Object}{Object}\textquotesingle{}s destructor, whichever comes first.

Subclasses are expected to implement their real destruction code in an overriden version of this method and chain up to their parent\textquotesingle{}s implementation once they are done. {\itshape i.\+e}, for simplicity, the destructor of every subclass should be empty and its content should be moved to the associated \hyperlink{classns3_1_1PacketSocket_a1137ff2a8fcc74682b220c059642ee28}{Do\+Dispose()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Socket_a5498f836b9b551dd7069562d05382e83}{ns3\+::\+Socket}.


\begin{DoxyCode}
82 \{
83   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
84   \hyperlink{classns3_1_1PacketSocket_ad55c1b060ff4bce8e74e874c83cf88d3}{m\_device} = 0;
85 \}
\end{DoxyCode}
\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!Forward\+Up@{Forward\+Up}}
\index{Forward\+Up@{Forward\+Up}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{Forward\+Up(\+Ptr$<$ Net\+Device $>$ device, Ptr$<$ const Packet $>$ packet, uint16\+\_\+t protocol, const Address \&from, const Address \&to, Net\+Device\+::\+Packet\+Type packet\+Type)}{ForwardUp(Ptr< NetDevice > device, Ptr< const Packet > packet, uint16_t protocol, const Address &from, const Address &to, NetDevice::PacketType packetType)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Packet\+Socket\+::\+Forward\+Up (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{device, }
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{packet, }
\item[{uint16\+\_\+t}]{protocol, }
\item[{const {\bf Address} \&}]{from, }
\item[{const {\bf Address} \&}]{to, }
\item[{{\bf Net\+Device\+::\+Packet\+Type}}]{packet\+Type}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PacketSocket_a889f1446a549aecd23e6f442791ae6b7}{}\label{classns3_1_1PacketSocket_a889f1446a549aecd23e6f442791ae6b7}


Called by the L3 protocol when it received a packet to pass on to T\+CP. 


\begin{DoxyParams}{Parameters}
{\em device} & the incoming \hyperlink{classns3_1_1NetDevice}{Net\+Device} \\
\hline
{\em packet} & the incoming packet \\
\hline
{\em protocol} & the protocol \\
\hline
{\em from} & sender address \\
\hline
{\em to} & destination address \\
\hline
{\em packet\+Type} & packet type \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
389 \{
390   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << device << packet << protocol << \hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from} << to << packetType);
391   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PacketSocket_af766986fa3298b3156972c0559fb8fa5}{m\_shutdownRecv})
392     \{
393       \textcolor{keywordflow}{return};
394     \}
395   PacketSocketAddress address;
396   address.SetPhysicalAddress (\hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from});
397   address.SetSingleDevice (device->GetIfIndex ());
398   address.SetProtocol (protocol);
399 
400   \textcolor{keywordflow}{if} ((\hyperlink{classns3_1_1PacketSocket_a3afd17f0f1692c887648d0c2cb6d406c}{m\_rxAvailable} + packet->GetSize ()) <= \hyperlink{classns3_1_1PacketSocket_a77f51ae1c17685fee11e5e10d90bd2f4}{m\_rcvBufSize})
401     \{
402       Ptr<Packet> copy = packet->Copy ();
403       DeviceNameTag dnt;
404       dnt.SetDeviceName (device->GetTypeId ().GetName ());
405       PacketSocketTag pst;
406       pst.SetPacketType (packetType);
407       pst.SetDestAddress (to);
408       copy->AddPacketTag (pst); \textcolor{comment}{// Attach Packet Type and Dest Address}
409       copy->AddPacketTag (dnt); \textcolor{comment}{// Attach device source name}
410       \textcolor{comment}{// in case the packet still has a priority tag, remove it}
411       SocketPriorityTag priorityTag;
412       copy->RemovePacketTag (priorityTag);
413       \hyperlink{classns3_1_1PacketSocket_a436086ef3cbe575138ad46c14e58aa56}{m\_deliveryQueue}.push (std::make\_pair (copy, address));
414       \hyperlink{classns3_1_1PacketSocket_a3afd17f0f1692c887648d0c2cb6d406c}{m\_rxAvailable} += packet->GetSize ();
415       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"UID is "} << packet->GetUid () << \textcolor{stringliteral}{" PacketSocket "} << \textcolor{keyword}{this});
416       \hyperlink{classns3_1_1Socket_a91fa3046bbd0a7644381f1d2481bdfef}{NotifyDataRecv} ();
417     \}
418   \textcolor{keywordflow}{else}
419     \{
420       \textcolor{comment}{// In general, this case should not occur unless the}
421       \textcolor{comment}{// receiving application reads data from this socket slowly}
422       \textcolor{comment}{// in comparison to the arrival rate}
423       \textcolor{comment}{//}
424       \textcolor{comment}{// drop and trace packet}
425       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"No receive buffer space available.  Drop."});
426       \hyperlink{classns3_1_1PacketSocket_ae962e642085d93dadd3832a0355a10ad}{m\_dropTrace} (packet);
427     \}
428 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10




Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!Get\+Allow\+Broadcast@{Get\+Allow\+Broadcast}}
\index{Get\+Allow\+Broadcast@{Get\+Allow\+Broadcast}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{Get\+Allow\+Broadcast() const }{GetAllowBroadcast() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Packet\+Socket\+::\+Get\+Allow\+Broadcast (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1PacketSocket_a831b498999fd1d3852512009df3e7cba}{}\label{classns3_1_1PacketSocket_a831b498999fd1d3852512009df3e7cba}


Query whether broadcast datagram transmissions are allowed. 

This method corresponds to using getsockopt() S\+O\+\_\+\+B\+R\+O\+A\+D\+C\+A\+ST of real network or B\+SD sockets.

\begin{DoxyReturn}{Returns}
true if broadcast is allowed, false otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_a95338a1ac89330a492d6af5b4e172d34}{ns3\+::\+Socket}.


\begin{DoxyCode}
525 \{
526   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
527   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
528 \}
\end{DoxyCode}
\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!Get\+Errno@{Get\+Errno}}
\index{Get\+Errno@{Get\+Errno}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{Get\+Errno(void) const }{GetErrno(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Socket\+::\+Socket\+Errno} ns3\+::\+Packet\+Socket\+::\+Get\+Errno (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1PacketSocket_ad172bfb7074b6bc631d32698b5055570}{}\label{classns3_1_1PacketSocket_ad172bfb7074b6bc631d32698b5055570}


Get last error number. 

\begin{DoxyReturn}{Returns}
the errno associated to the last call which failed in this socket. Each socket\textquotesingle{}s errno is initialized to zero when the socket is created. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_ae489616249d946f3c0dc831c05d0d711}{ns3\+::\+Socket}.


\begin{DoxyCode}
89 \{
90   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
91   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1PacketSocket_ac1da4372f719a7fb20b8d7fa426f21cc}{m\_errno};
92 \}
\end{DoxyCode}
\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!Get\+Min\+Mtu@{Get\+Min\+Mtu}}
\index{Get\+Min\+Mtu@{Get\+Min\+Mtu}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{Get\+Min\+Mtu(\+Packet\+Socket\+Address ad) const }{GetMinMtu(PacketSocketAddress ad) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Packet\+Socket\+::\+Get\+Min\+Mtu (
\begin{DoxyParamCaption}
\item[{{\bf Packet\+Socket\+Address}}]{ad}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PacketSocket_a3601a739034d0d2e46ccc45f2073e02f}{}\label{classns3_1_1PacketSocket_a3601a739034d0d2e46ccc45f2073e02f}


Get the minimum M\+TU supported by the Net\+Devices bound to a specific address. 


\begin{DoxyParams}{Parameters}
{\em ad} & the socket address to check for \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The minimum M\+TU 
\end{DoxyReturn}

\begin{DoxyCode}
274 \{
275   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << ad);
276   \textcolor{keywordflow}{if} (ad.IsSingleDevice ())
277     \{
278       Ptr<NetDevice> device = \hyperlink{classns3_1_1PacketSocket_a1d16a7bb40df82877d5b6b257861d566}{m\_node}->\hyperlink{classns3_1_1Node_a5918dfd24ef632efc9a83a5f6561c76e}{GetDevice} (ad.GetSingleDevice ());
279       \textcolor{keywordflow}{return} device->GetMtu ();
280     \}
281   \textcolor{keywordflow}{else}
282     \{
283       uint32\_t minMtu = 0xffff;
284       \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1PacketSocket_a1d16a7bb40df82877d5b6b257861d566}{m\_node}->\hyperlink{classns3_1_1Node_a531554d2241ba4fa1cd74e3360be6bce}{GetNDevices} (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
285         \{
286           Ptr<NetDevice> device = \hyperlink{classns3_1_1PacketSocket_a1d16a7bb40df82877d5b6b257861d566}{m\_node}->\hyperlink{classns3_1_1Node_a5918dfd24ef632efc9a83a5f6561c76e}{GetDevice} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
287           minMtu = \hyperlink{80211b_8c_ac6afabdc09a49a433ee19d8a9486056d}{std::min} (minMtu, (uint32\_t)device->GetMtu ());
288         \}
289       \textcolor{keywordflow}{return} minMtu;
290     \}
291 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12




Here is the caller graph for this function\+:
% FIG 13


\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!Get\+Node@{Get\+Node}}
\index{Get\+Node@{Get\+Node}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{Get\+Node(void) const }{GetNode(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Node} $>$ ns3\+::\+Packet\+Socket\+::\+Get\+Node (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1PacketSocket_a247e66e20667d10c1aab2d3cb9158ba8}{}\label{classns3_1_1PacketSocket_a247e66e20667d10c1aab2d3cb9158ba8}


Return the node this socket is associated with. 

\begin{DoxyReturn}{Returns}
the node 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_aba642ad4301c1df47befc0aa9afa2e48}{ns3\+::\+Socket}.


\begin{DoxyCode}
103 \{
104   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
105   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1PacketSocket_a1d16a7bb40df82877d5b6b257861d566}{m\_node};
106 \}
\end{DoxyCode}
\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!Get\+Peer\+Name@{Get\+Peer\+Name}}
\index{Get\+Peer\+Name@{Get\+Peer\+Name}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{Get\+Peer\+Name(\+Address \&address) const }{GetPeerName(Address &address) const }}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Packet\+Socket\+::\+Get\+Peer\+Name (
\begin{DoxyParamCaption}
\item[{{\bf Address} \&}]{address}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1PacketSocket_a2a8bd0a6624593cb7d6b4171dd173049}{}\label{classns3_1_1PacketSocket_a2a8bd0a6624593cb7d6b4171dd173049}


Get the peer address of a connected socket. 


\begin{DoxyParams}{Parameters}
{\em address} & the address this socket is connected to. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if success, -\/1 otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_a78a3c37a539d2e70869bb82cc60fbb09}{ns3\+::\+Socket}.


\begin{DoxyCode}
498 \{
499   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << address);
500 
501   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PacketSocket_adbf0f1f9b0a0bed7169ecdcb5a1ef66a}{m\_state} != \hyperlink{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5abba9e14603bb16ef4fa03ddfc1224641}{STATE\_CONNECTED})
502     \{
503       \hyperlink{classns3_1_1PacketSocket_ac1da4372f719a7fb20b8d7fa426f21cc}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaaeb1fd23c1f4965b496786597125bf0f6}{ERROR\_NOTCONN};
504       \textcolor{keywordflow}{return} -1;
505     \}
506 
507   address = \hyperlink{classns3_1_1PacketSocket_a22323e0871995f6f217d647301923ceb}{m\_destAddr};
508 
509   \textcolor{keywordflow}{return} 0;
510 \}
\end{DoxyCode}
\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!Get\+Rx\+Available@{Get\+Rx\+Available}}
\index{Get\+Rx\+Available@{Get\+Rx\+Available}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{Get\+Rx\+Available(void) const }{GetRxAvailable(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Packet\+Socket\+::\+Get\+Rx\+Available (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1PacketSocket_a088f17e0f260b028521b9ef230016a86}{}\label{classns3_1_1PacketSocket_a088f17e0f260b028521b9ef230016a86}
Return number of bytes which can be returned from one or multiple calls to Recv. Must be possible to call this method from the Recv callback.

\begin{DoxyReturn}{Returns}
the number of bytes which can be returned from one or multiple Recv calls. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_ad35d8931e53ae0754ee864acb1cecd0e}{ns3\+::\+Socket}.


\begin{DoxyCode}
432 \{
433   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
434   \textcolor{comment}{// We separately maintain this state to avoid walking the queue }
435   \textcolor{comment}{// every time this might be called}
436   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1PacketSocket_a3afd17f0f1692c887648d0c2cb6d406c}{m\_rxAvailable};
437 \}
\end{DoxyCode}
\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!Get\+Socket\+Type@{Get\+Socket\+Type}}
\index{Get\+Socket\+Type@{Get\+Socket\+Type}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{Get\+Socket\+Type(void) const }{GetSocketType(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Socket\+::\+Socket\+Type} ns3\+::\+Packet\+Socket\+::\+Get\+Socket\+Type (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1PacketSocket_ab9e1551e23008f93983bc22f7a4e1579}{}\label{classns3_1_1PacketSocket_ab9e1551e23008f93983bc22f7a4e1579}
\begin{DoxyReturn}{Returns}
the socket type, analogous to getsockopt (S\+O\+\_\+\+T\+Y\+PE) 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_af9333cfc006d6ed9363f20d3822fedcb}{ns3\+::\+Socket}.


\begin{DoxyCode}
96 \{
97   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
98   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Socket_a698fbcc486a48b7a0d2b0e4ab863d571aa97c397d36e85f30278a64ef94d40e03}{NS3\_SOCK\_RAW};
99 \}
\end{DoxyCode}
\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!Get\+Sock\+Name@{Get\+Sock\+Name}}
\index{Get\+Sock\+Name@{Get\+Sock\+Name}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{Get\+Sock\+Name(\+Address \&address) const }{GetSockName(Address &address) const }}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Packet\+Socket\+::\+Get\+Sock\+Name (
\begin{DoxyParamCaption}
\item[{{\bf Address} \&}]{address}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1PacketSocket_a78d52c70c989f0473e64cb51301b2379}{}\label{classns3_1_1PacketSocket_a78d52c70c989f0473e64cb51301b2379}


Get socket address. 


\begin{DoxyParams}{Parameters}
{\em address} & the address name this socket is associated with. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if success, -\/1 otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_aa982ca9baab28bea412b0d9710e63b43}{ns3\+::\+Socket}.


\begin{DoxyCode}
475 \{
476   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << address);
477   PacketSocketAddress ad;
478 
479   ad.SetProtocol (\hyperlink{classns3_1_1PacketSocket_ab563605d15111f7caef9a0c9ca18167c}{m\_protocol});
480   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PacketSocket_a8d45062d8bdc229074cfc45e4abb77ec}{m\_isSingleDevice})
481     \{
482       Ptr<NetDevice> device = \hyperlink{classns3_1_1PacketSocket_a1d16a7bb40df82877d5b6b257861d566}{m\_node}->\hyperlink{classns3_1_1Node_a5918dfd24ef632efc9a83a5f6561c76e}{GetDevice} (\hyperlink{classns3_1_1PacketSocket_ad55c1b060ff4bce8e74e874c83cf88d3}{m\_device});
483       ad.SetPhysicalAddress (device->GetAddress ());
484       ad.SetSingleDevice (\hyperlink{classns3_1_1PacketSocket_ad55c1b060ff4bce8e74e874c83cf88d3}{m\_device});
485     \}
486   \textcolor{keywordflow}{else}
487     \{
488       ad.SetPhysicalAddress (Address ());
489       ad.SetAllDevices ();
490     \}
491   address = ad;
492 
493   \textcolor{keywordflow}{return} 0;
494 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 14


\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!Get\+Tx\+Available@{Get\+Tx\+Available}}
\index{Get\+Tx\+Available@{Get\+Tx\+Available}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{Get\+Tx\+Available(void) const }{GetTxAvailable(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Packet\+Socket\+::\+Get\+Tx\+Available (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1PacketSocket_a11bf40b37d8cecd2067c880244be5de4}{}\label{classns3_1_1PacketSocket_a11bf40b37d8cecd2067c880244be5de4}


Returns the number of bytes which can be sent in a single call to Send. 

For datagram sockets, this returns the number of bytes that can be passed atomically through the underlying protocol.

For stream sockets, this returns the available space in bytes left in the transmit buffer.

\begin{DoxyReturn}{Returns}
The number of bytes which can be sent in a single Send call. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_ae7cf62e3acf44106bfa1d40eaeaec151}{ns3\+::\+Socket}.


\begin{DoxyCode}
295 \{
296   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
297   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PacketSocket_adbf0f1f9b0a0bed7169ecdcb5a1ef66a}{m\_state} == \hyperlink{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5abba9e14603bb16ef4fa03ddfc1224641}{STATE\_CONNECTED})
298     \{
299       PacketSocketAddress ad = \hyperlink{classns3_1_1PacketSocketAddress_ab90d0401de757d2da5bf1ad07af2ecf5}{PacketSocketAddress::ConvertFrom} (
      \hyperlink{classns3_1_1PacketSocket_a22323e0871995f6f217d647301923ceb}{m\_destAddr});
300       \textcolor{keywordflow}{return} \hyperlink{classns3_1_1PacketSocket_a3601a739034d0d2e46ccc45f2073e02f}{GetMinMtu} (ad);
301     \}
302   \textcolor{comment}{// If we are not connected, we return a 'safe' value by default.}
303   \textcolor{keywordflow}{return} 0xffff;
304 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 15




Here is the caller graph for this function\+:
% FIG 16


\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Packet\+Socket\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1PacketSocket_aa6d6009b60e1d9b8b6af64446bb68282}{}\label{classns3_1_1PacketSocket_aa6d6009b60e1d9b8b6af64446bb68282}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
40 \{
41   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::PacketSocket"})
42     .SetParent<\hyperlink{classns3_1_1Socket_a1e22267afc490a4b15b8a764289a4000}{Socket}> ()
43     .SetGroupName(\textcolor{stringliteral}{"Network"})
44     .AddConstructor<\hyperlink{classns3_1_1PacketSocket_aa9ad19e9cbfaa8330e2786612c7721d1}{PacketSocket}> ()
45     .AddTraceSource (\textcolor{stringliteral}{"Drop"}, \textcolor{stringliteral}{"Drop packet due to receive buffer overflow"},
46                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1PacketSocket_ae962e642085d93dadd3832a0355a10ad}{PacketSocket::m\_dropTrace}),
47                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
48     .AddAttribute (\textcolor{stringliteral}{"RcvBufSize"},
49                    \textcolor{stringliteral}{"PacketSocket maximum receive buffer size (bytes)"},
50                    UintegerValue (131072),
51                    MakeUintegerAccessor (&\hyperlink{classns3_1_1PacketSocket_a77f51ae1c17685fee11e5e10d90bd2f4}{PacketSocket::m\_rcvBufSize}),
52                    MakeUintegerChecker<uint32\_t> ())
53   ;
54   \textcolor{keywordflow}{return} tid;
55 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 17




Here is the caller graph for this function\+:
% FIG 18


\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!Listen@{Listen}}
\index{Listen@{Listen}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{Listen(void)}{Listen(void)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Packet\+Socket\+::\+Listen (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1PacketSocket_a263c5cd1fee6744bd79d997cdcbc7ef4}{}\label{classns3_1_1PacketSocket_a263c5cd1fee6744bd79d997cdcbc7ef4}


Listen for incoming connections. 

\begin{DoxyReturn}{Returns}
0 on success, -\/1 on error (in which case errno is set). 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_a6b3529a32632cf1a56debf5f79e56c54}{ns3\+::\+Socket}.


\begin{DoxyCode}
253 \{
254   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
255   \hyperlink{classns3_1_1PacketSocket_ac1da4372f719a7fb20b8d7fa426f21cc}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa777b6c9712ef5485ebecfb96d5de4d54}{Socket::ERROR\_OPNOTSUPP};
256   \textcolor{keywordflow}{return} -1;
257 \}
\end{DoxyCode}
\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!Recv@{Recv}}
\index{Recv@{Recv}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{Recv(uint32\+\_\+t max\+Size, uint32\+\_\+t flags)}{Recv(uint32_t maxSize, uint32_t flags)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Packet} $>$ ns3\+::\+Packet\+Socket\+::\+Recv (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{max\+Size, }
\item[{uint32\+\_\+t}]{flags}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1PacketSocket_a8f19cc86b32a0a80a2738be64e05b202}{}\label{classns3_1_1PacketSocket_a8f19cc86b32a0a80a2738be64e05b202}


Read data from the socket. 

This function matches closely in semantics to the recv() function call in the standard C library (libc)\+: ssize\+\_\+t recv (int s, void $\ast$buf, size\+\_\+t len, int flags); except that the receive I/O is asynchronous. This is the primary Recv method at this low-\/level A\+PI and must be implemented by subclasses.

This method is normally used only on a connected socket. In a typical blocking sockets model, this call would block until at least one byte is returned or the connection closes. In ns-\/3 at this A\+PI, the call returns immediately in such a case and returns 0 if nothing is available to be read. However, an application can set a callback, ns3\+::\+Set\+Recv\+Callback, to be notified of data being available to be read (when it conceptually unblocks); this is an asynchronous I/O model for recv().

This variant of \hyperlink{classns3_1_1Socket_afb4e211a54a3f63ac3f79624a3a964f7}{Recv()} uses class \hyperlink{classns3_1_1Packet}{ns3\+::\+Packet} to encapsulate data, rather than providing a raw pointer and length field. This allows an ns-\/3 application to attach tags if desired (such as a flow ID) and may allow the simulator to avoid some data copies. Despite the appearance of receiving Packets on a stream socket, just think of it as a fancy byte buffer with streaming semantics.

The semantics depend on the type of socket. For a datagram socket, each \hyperlink{classns3_1_1Socket_afb4e211a54a3f63ac3f79624a3a964f7}{Recv()} returns the data from at most one \hyperlink{classns3_1_1PacketSocket_a1fd81b9271758334d6abad658580b1a0}{Send()}, and order is not necessarily preserved. For a stream socket, the bytes are delivered in order, and on-\/the-\/wire packet boundaries are not preserved.

The flags argument is formed by or\textquotesingle{}ing one or more of the values\+: M\+S\+G\+\_\+\+O\+OB process out-\/of-\/band data M\+S\+G\+\_\+\+P\+E\+EK peek at incoming message None of these flags are supported for now.

Some variants of \hyperlink{classns3_1_1Socket_afb4e211a54a3f63ac3f79624a3a964f7}{Recv()} are supported as additional A\+PI, including \hyperlink{classns3_1_1PacketSocket_a03c078024aa5ab71c8d0b6d951a740dc}{Recv\+From()}, overloaded \hyperlink{classns3_1_1Socket_afb4e211a54a3f63ac3f79624a3a964f7}{Recv()} without arguments, and variants that use raw character buffers.


\begin{DoxyParams}{Parameters}
{\em max\+Size} & reader will accept packet up to max\+Size \\
\hline
{\em flags} & \hyperlink{classns3_1_1Socket}{Socket} control flags \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{classns3_1_1Ptr}{Ptr$<$\+Packet$>$} of the next in-\/sequence packet. Returns 0 if the socket cannot return a next in-\/sequence packet conforming to the max\+Size and flags.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Socket_a243f7835ef1a85f9270fd3577e3a40da}{Set\+Recv\+Callback} 
\end{DoxySeeAlso}


Implements \hyperlink{classns3_1_1Socket_a8949b1f844aae563446f2f4c5be8827a}{ns3\+::\+Socket}.


\begin{DoxyCode}
441 \{
442   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << maxSize << flags);
443 
444   Address fromAddress;
445   Ptr<Packet> packet = \hyperlink{classns3_1_1PacketSocket_a03c078024aa5ab71c8d0b6d951a740dc}{RecvFrom} (maxSize, flags, fromAddress);
446   \textcolor{keywordflow}{return} packet;
447 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 19


\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!Recv\+From@{Recv\+From}}
\index{Recv\+From@{Recv\+From}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{Recv\+From(uint32\+\_\+t max\+Size, uint32\+\_\+t flags, Address \&from\+Address)}{RecvFrom(uint32_t maxSize, uint32_t flags, Address &fromAddress)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Packet} $>$ ns3\+::\+Packet\+Socket\+::\+Recv\+From (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{max\+Size, }
\item[{uint32\+\_\+t}]{flags, }
\item[{{\bf Address} \&}]{from\+Address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1PacketSocket_a03c078024aa5ab71c8d0b6d951a740dc}{}\label{classns3_1_1PacketSocket_a03c078024aa5ab71c8d0b6d951a740dc}


Read a single packet from the socket and retrieve the sender address. 

Calls Recv(max\+Size, flags) with max\+Size implicitly set to maximum sized integer, and flags set to zero.

This method has similar semantics to Recv () but subclasses may want to provide checks on socket state, so the implementation is pushed to subclasses.


\begin{DoxyParams}{Parameters}
{\em max\+Size} & reader will accept packet up to max\+Size \\
\hline
{\em flags} & \hyperlink{classns3_1_1Socket}{Socket} control flags \\
\hline
{\em from\+Address} & output parameter that will return the address of the sender of the received packet, if any. Remains untouched if no packet is received. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{classns3_1_1Ptr}{Ptr$<$\+Packet$>$} of the next in-\/sequence packet. Returns 0 if the socket cannot return a next in-\/sequence packet. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_af22378d7af9a2745a9eada20210da215}{ns3\+::\+Socket}.


\begin{DoxyCode}
451 \{
452   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << maxSize << flags);
453 
454   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PacketSocket_a436086ef3cbe575138ad46c14e58aa56}{m\_deliveryQueue}.empty () )
455     \{
456       \textcolor{keywordflow}{return} 0;
457     \}
458   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = \hyperlink{classns3_1_1PacketSocket_a436086ef3cbe575138ad46c14e58aa56}{m\_deliveryQueue}.front ().first;
459   fromAddress = \hyperlink{classns3_1_1PacketSocket_a436086ef3cbe575138ad46c14e58aa56}{m\_deliveryQueue}.front ().second;
460 
461   \textcolor{keywordflow}{if} (p->GetSize () <= maxSize)
462     \{
463       \hyperlink{classns3_1_1PacketSocket_a436086ef3cbe575138ad46c14e58aa56}{m\_deliveryQueue}.pop ();
464       \hyperlink{classns3_1_1PacketSocket_a3afd17f0f1692c887648d0c2cb6d406c}{m\_rxAvailable} -= p->GetSize ();
465     \}
466   \textcolor{keywordflow}{else}
467     \{
468       p = 0;
469     \}
470   \textcolor{keywordflow}{return} \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p};
471 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 20




Here is the caller graph for this function\+:
% FIG 21


\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!Send@{Send}}
\index{Send@{Send}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{Send(\+Ptr$<$ Packet $>$ p, uint32\+\_\+t flags)}{Send(Ptr< Packet > p, uint32_t flags)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Packet\+Socket\+::\+Send (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{uint32\+\_\+t}]{flags}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1PacketSocket_a1fd81b9271758334d6abad658580b1a0}{}\label{classns3_1_1PacketSocket_a1fd81b9271758334d6abad658580b1a0}


Send data (or dummy data) to the remote host. 

This function matches closely in semantics to the send() function call in the standard C library (libc)\+: ssize\+\_\+t send (int s, const void $\ast$msg, size\+\_\+t len, int flags); except that the send I/O is asynchronous. This is the primary Send method at this low-\/level A\+PI and must be implemented by subclasses.

In a typical blocking sockets model, this call would block upon lack of space to hold the message to be sent. In ns-\/3 at this A\+PI, the call returns immediately in such a case, but the callback registered with \hyperlink{classns3_1_1Socket_a85ff5c8cc7d242823f301b49264c68a4}{Set\+Send\+Callback()} is invoked when the socket has space (when it conceptually unblocks); this is an asynchronous I/O model for send().

This variant of \hyperlink{classns3_1_1PacketSocket_a1fd81b9271758334d6abad658580b1a0}{Send()} uses class \hyperlink{classns3_1_1Packet}{ns3\+::\+Packet} to encapsulate data, rather than providing a raw pointer and length field. This allows an ns-\/3 application to attach tags if desired (such as a flow ID) and may allow the simulator to avoid some data copies. Despite the appearance of sending Packets on a stream socket, just think of it as a fancy byte buffer with streaming semantics.

If either the message buffer within the \hyperlink{classns3_1_1Packet}{Packet} is too long to pass atomically through the underlying protocol (for datagram sockets), or the message buffer cannot entirely fit in the transmit buffer (for stream sockets), -\/1 is returned and Socket\+Errno is set to E\+R\+R\+O\+R\+\_\+\+M\+S\+G\+S\+I\+ZE. If the packet does not fit, the caller can split the \hyperlink{classns3_1_1Packet}{Packet} (based on information obtained from Get\+Tx\+Available) and reattempt to send the data.

The flags argument is formed by or\textquotesingle{}ing one or more of the values\+: M\+S\+G\+\_\+\+O\+OB process out-\/of-\/band data M\+S\+G\+\_\+\+D\+O\+N\+T\+R\+O\+U\+TE bypass routing, use direct interface These flags are {\itshape unsupported} as of ns-\/3.\+1.


\begin{DoxyParams}{Parameters}
{\em p} & \hyperlink{classns3_1_1Packet}{ns3\+::\+Packet} to send \\
\hline
{\em flags} & \hyperlink{classns3_1_1Socket}{Socket} control flags \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of bytes accepted for transmission if no error occurs, and -\/1 otherwise.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Socket_a85ff5c8cc7d242823f301b49264c68a4}{Set\+Send\+Callback} 
\end{DoxySeeAlso}


Implements \hyperlink{classns3_1_1Socket_a036901c8f485fe5b6eab93b7f2ec289d}{ns3\+::\+Socket}.


\begin{DoxyCode}
261 \{
262   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << p << flags);
263   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PacketSocket_adbf0f1f9b0a0bed7169ecdcb5a1ef66a}{m\_state} == \hyperlink{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5af534e442cba41165df3d12c889608f03}{STATE\_OPEN} ||
264       \hyperlink{classns3_1_1PacketSocket_adbf0f1f9b0a0bed7169ecdcb5a1ef66a}{m\_state} == \hyperlink{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5a22a3caeaebc3bfbb85d13fc9a807162a}{STATE\_BOUND})
265     \{
266       \hyperlink{classns3_1_1PacketSocket_ac1da4372f719a7fb20b8d7fa426f21cc}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaaeb1fd23c1f4965b496786597125bf0f6}{ERROR\_NOTCONN};
267       \textcolor{keywordflow}{return} -1;
268     \}
269   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1PacketSocket_a66dc5b7e29ad76f07ff46368f75b9165}{SendTo} (p, flags, \hyperlink{classns3_1_1PacketSocket_a22323e0871995f6f217d647301923ceb}{m\_destAddr});
270 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 22


\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!Send\+To@{Send\+To}}
\index{Send\+To@{Send\+To}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{Send\+To(\+Ptr$<$ Packet $>$ p, uint32\+\_\+t flags, const Address \&to\+Address)}{SendTo(Ptr< Packet > p, uint32_t flags, const Address &toAddress)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Packet\+Socket\+::\+Send\+To (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{uint32\+\_\+t}]{flags, }
\item[{const {\bf Address} \&}]{to\+Address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1PacketSocket_a66dc5b7e29ad76f07ff46368f75b9165}{}\label{classns3_1_1PacketSocket_a66dc5b7e29ad76f07ff46368f75b9165}


Send data to a specified peer. 

This method has similar semantics to Send () but subclasses may want to provide checks on socket state, so the implementation is pushed to subclasses.


\begin{DoxyParams}{Parameters}
{\em p} & packet to send \\
\hline
{\em flags} & \hyperlink{classns3_1_1Socket}{Socket} control flags \\
\hline
{\em to\+Address} & IP \hyperlink{classns3_1_1Address}{Address} of remote host \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
-\/1 in case of error or the number of bytes copied in the internal buffer and accepted for transmission. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_af898fce6a58e0dbba23c1c6de1d4220e}{ns3\+::\+Socket}.


\begin{DoxyCode}
308 \{
309   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << p << flags << address);
310   PacketSocketAddress ad;
311   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PacketSocket_adbf0f1f9b0a0bed7169ecdcb5a1ef66a}{m\_state} == \hyperlink{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5a6fe4f17ed49f9a87aba67738af434437}{STATE\_CLOSED})
312     \{
313       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"ERROR\_BADF"});
314       \hyperlink{classns3_1_1PacketSocket_ac1da4372f719a7fb20b8d7fa426f21cc}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa9d232a0dd40ca7e637e974b88b973db9}{ERROR\_BADF};
315       \textcolor{keywordflow}{return} -1;
316     \}
317   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PacketSocket_ad16347ae79f47e980085db3a2674dc40}{m\_shutdownSend})
318     \{
319       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"ERROR\_SHUTDOWN"});
320       \hyperlink{classns3_1_1PacketSocket_ac1da4372f719a7fb20b8d7fa426f21cc}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa471b853a7aed4ec0c5c64b0c5ad8e521}{ERROR\_SHUTDOWN};
321       \textcolor{keywordflow}{return} -1;
322     \}
323   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1PacketSocketAddress_a9426c99ec2c26c22d3920ca5c63ae1cd}{PacketSocketAddress::IsMatchingType} (address))
324     \{
325       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"ERROR\_AFNOSUPPORT"});
326       \hyperlink{classns3_1_1PacketSocket_ac1da4372f719a7fb20b8d7fa426f21cc}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa7f4cc7185e365fb30fc5e2a4ec9f1c24}{ERROR\_AFNOSUPPORT};
327       \textcolor{keywordflow}{return} -1;
328     \}
329   ad = \hyperlink{classns3_1_1PacketSocketAddress_ab90d0401de757d2da5bf1ad07af2ecf5}{PacketSocketAddress::ConvertFrom} (address);
330   \textcolor{keywordflow}{if} (p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} () > \hyperlink{classns3_1_1PacketSocket_a3601a739034d0d2e46ccc45f2073e02f}{GetMinMtu} (ad))
331     \{
332       \hyperlink{classns3_1_1PacketSocket_ac1da4372f719a7fb20b8d7fa426f21cc}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaaeba174dbfeaed34194ce9463f6a469f1}{ERROR\_MSGSIZE};
333       \textcolor{keywordflow}{return} -1;
334     \}
335 
336   uint8\_t priority = \hyperlink{classns3_1_1Socket_a3e4788d61c0e841ccaa1c7fce6fda2c1}{GetPriority} ();
337   \textcolor{keywordflow}{if} (priority)
338     \{
339       SocketPriorityTag priorityTag;
340       priorityTag.SetPriority (priority);
341       p->\hyperlink{classns3_1_1Packet_afb014ae9f4adddbfc51c64b085bfd405}{ReplacePacketTag} (priorityTag);
342     \}
343 
344   \textcolor{keywordtype}{bool} error = \textcolor{keyword}{false};
345   Address dest = ad.GetPhysicalAddress ();
346   \textcolor{keywordflow}{if} (ad.IsSingleDevice ())
347     \{
348       Ptr<NetDevice> device = \hyperlink{classns3_1_1PacketSocket_a1d16a7bb40df82877d5b6b257861d566}{m\_node}->\hyperlink{classns3_1_1Node_a5918dfd24ef632efc9a83a5f6561c76e}{GetDevice} (ad.GetSingleDevice ());
349       \textcolor{keywordflow}{if} (!device->Send (p, dest, ad.GetProtocol ()))
350         \{
351           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"error: NetDevice::Send error"});
352           error = \textcolor{keyword}{true};
353         \}
354     \}
355   \textcolor{keywordflow}{else}
356     \{
357       \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1PacketSocket_a1d16a7bb40df82877d5b6b257861d566}{m\_node}->\hyperlink{classns3_1_1Node_a531554d2241ba4fa1cd74e3360be6bce}{GetNDevices} (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
358         \{
359           Ptr<NetDevice> device = \hyperlink{classns3_1_1PacketSocket_a1d16a7bb40df82877d5b6b257861d566}{m\_node}->\hyperlink{classns3_1_1Node_a5918dfd24ef632efc9a83a5f6561c76e}{GetDevice} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
360           \textcolor{keywordflow}{if} (!device->Send (p, dest, ad.GetProtocol ()))
361             \{
362               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"error: NetDevice::Send error"});
363               error = \textcolor{keyword}{true};
364             \}
365         \}
366     \}
367   \textcolor{keywordflow}{if} (!error)
368     \{
369       \hyperlink{classns3_1_1Socket_ae478fc503f7041a1da5e9db361f1ae20}{NotifyDataSent} (p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ());
370       \hyperlink{classns3_1_1Socket_a34cd5de5b9feeadd6ba8973b954c3d5f}{NotifySend} (\hyperlink{classns3_1_1PacketSocket_a11bf40b37d8cecd2067c880244be5de4}{GetTxAvailable} ());
371     \}
372 
373   \textcolor{keywordflow}{if} (error)
374     \{
375       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"ERROR\_INVAL 2"});
376       \hyperlink{classns3_1_1PacketSocket_ac1da4372f719a7fb20b8d7fa426f21cc}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa4b98dd50740861229f8e03bcc36d379b}{ERROR\_INVAL};
377       \textcolor{keywordflow}{return} -1;
378     \}
379   \textcolor{keywordflow}{else}
380     \{
381       \textcolor{keywordflow}{return} p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ();
382     \}
383 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 23




Here is the caller graph for this function\+:
% FIG 24


\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!Set\+Allow\+Broadcast@{Set\+Allow\+Broadcast}}
\index{Set\+Allow\+Broadcast@{Set\+Allow\+Broadcast}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{Set\+Allow\+Broadcast(bool allow\+Broadcast)}{SetAllowBroadcast(bool allowBroadcast)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Packet\+Socket\+::\+Set\+Allow\+Broadcast (
\begin{DoxyParamCaption}
\item[{bool}]{allow\+Broadcast}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1PacketSocket_a0d903ba3ca9ad905a9c347254ae6a9b9}{}\label{classns3_1_1PacketSocket_a0d903ba3ca9ad905a9c347254ae6a9b9}


Configure whether broadcast datagram transmissions are allowed. 

This method corresponds to using setsockopt() S\+O\+\_\+\+B\+R\+O\+A\+D\+C\+A\+ST of real network or B\+SD sockets. If set on a socket, this option will enable or disable packets to be transmitted to broadcast destination addresses.


\begin{DoxyParams}{Parameters}
{\em allow\+Broadcast} & Whether broadcast is allowed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if operation succeeds 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_a32b4fa27b732a63207c8d9054a817ed5}{ns3\+::\+Socket}.


\begin{DoxyCode}
514 \{
515   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << allowBroadcast);
516   \textcolor{keywordflow}{if} (allowBroadcast)
517     \{
518       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
519     \}
520   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
521 \}
\end{DoxyCode}
\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!Set\+Node@{Set\+Node}}
\index{Set\+Node@{Set\+Node}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{Set\+Node(\+Ptr$<$ Node $>$ node)}{SetNode(Ptr< Node > node)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Packet\+Socket\+::\+Set\+Node (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PacketSocket_ac3b622ebee97e4b5cc78ed69c1e74bc5}{}\label{classns3_1_1PacketSocket_ac3b622ebee97e4b5cc78ed69c1e74bc5}


Set the associated node. 


\begin{DoxyParams}{Parameters}
{\em node} & the node \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
70 \{
71   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << node);
72   \hyperlink{classns3_1_1PacketSocket_a1d16a7bb40df82877d5b6b257861d566}{m\_node} = node;
73 \}
\end{DoxyCode}
\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!Shutdown\+Recv@{Shutdown\+Recv}}
\index{Shutdown\+Recv@{Shutdown\+Recv}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{Shutdown\+Recv(void)}{ShutdownRecv(void)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Packet\+Socket\+::\+Shutdown\+Recv (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1PacketSocket_a62cc0eda133c88406a3d5f0296d4436c}{}\label{classns3_1_1PacketSocket_a62cc0eda133c88406a3d5f0296d4436c}
\begin{DoxyReturn}{Returns}
zero on success, -\/1 on failure.
\end{DoxyReturn}
Do not allow any further Recv calls. This method is typically implemented for Tcp sockets by a half close. 

Implements \hyperlink{classns3_1_1Socket_a5a6b835bb7ccf2cf43b54912e7cae600}{ns3\+::\+Socket}.


\begin{DoxyCode}
187 \{
188   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
189   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PacketSocket_adbf0f1f9b0a0bed7169ecdcb5a1ef66a}{m\_state} == \hyperlink{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5a6fe4f17ed49f9a87aba67738af434437}{STATE\_CLOSED})
190     \{
191       \hyperlink{classns3_1_1PacketSocket_ac1da4372f719a7fb20b8d7fa426f21cc}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa9d232a0dd40ca7e637e974b88b973db9}{ERROR\_BADF};
192       \textcolor{keywordflow}{return} -1;
193     \}
194   \hyperlink{classns3_1_1PacketSocket_af766986fa3298b3156972c0559fb8fa5}{m\_shutdownRecv} = \textcolor{keyword}{true};
195   \textcolor{keywordflow}{return} 0;
196 \}
\end{DoxyCode}
\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!Shutdown\+Send@{Shutdown\+Send}}
\index{Shutdown\+Send@{Shutdown\+Send}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{Shutdown\+Send(void)}{ShutdownSend(void)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Packet\+Socket\+::\+Shutdown\+Send (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1PacketSocket_a4eb90477fd557de26e6da3ae5e47ccc7}{}\label{classns3_1_1PacketSocket_a4eb90477fd557de26e6da3ae5e47ccc7}
\begin{DoxyReturn}{Returns}
zero on success, -\/1 on failure.
\end{DoxyReturn}
Do not allow any further Send calls. This method is typically implemented for Tcp sockets by a half close. 

Implements \hyperlink{classns3_1_1Socket_a8186c87627fa3ece326d8f1c822d7f95}{ns3\+::\+Socket}.


\begin{DoxyCode}
174 \{
175   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
176   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PacketSocket_adbf0f1f9b0a0bed7169ecdcb5a1ef66a}{m\_state} == \hyperlink{classns3_1_1PacketSocket_a376c65cdab494c41bd65f9aaeef543e5a6fe4f17ed49f9a87aba67738af434437}{STATE\_CLOSED})
177     \{
178       \hyperlink{classns3_1_1PacketSocket_ac1da4372f719a7fb20b8d7fa426f21cc}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa9d232a0dd40ca7e637e974b88b973db9}{ERROR\_BADF};
179       \textcolor{keywordflow}{return} -1;
180     \}
181   \hyperlink{classns3_1_1PacketSocket_ad16347ae79f47e980085db3a2674dc40}{m\_shutdownSend} = \textcolor{keyword}{true};
182   \textcolor{keywordflow}{return} 0;
183 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!m\+\_\+delivery\+Queue@{m\+\_\+delivery\+Queue}}
\index{m\+\_\+delivery\+Queue@{m\+\_\+delivery\+Queue}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{m\+\_\+delivery\+Queue}{m_deliveryQueue}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::queue$<$std\+::pair$<${\bf Ptr}$<${\bf Packet}$>$, {\bf Address}$>$ $>$ ns3\+::\+Packet\+Socket\+::m\+\_\+delivery\+Queue\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PacketSocket_a436086ef3cbe575138ad46c14e58aa56}{}\label{classns3_1_1PacketSocket_a436086ef3cbe575138ad46c14e58aa56}


Rx queue. 

\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!m\+\_\+dest\+Addr@{m\+\_\+dest\+Addr}}
\index{m\+\_\+dest\+Addr@{m\+\_\+dest\+Addr}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{m\+\_\+dest\+Addr}{m_destAddr}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Packet\+Socket\+::m\+\_\+dest\+Addr\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PacketSocket_a22323e0871995f6f217d647301923ceb}{}\label{classns3_1_1PacketSocket_a22323e0871995f6f217d647301923ceb}


Default destination address. 

\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!m\+\_\+device@{m\+\_\+device}}
\index{m\+\_\+device@{m\+\_\+device}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{m\+\_\+device}{m_device}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Packet\+Socket\+::m\+\_\+device\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PacketSocket_ad55c1b060ff4bce8e74e874c83cf88d3}{}\label{classns3_1_1PacketSocket_ad55c1b060ff4bce8e74e874c83cf88d3}


index of the bound \hyperlink{classns3_1_1NetDevice}{Net\+Device} 

\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!m\+\_\+drop\+Trace@{m\+\_\+drop\+Trace}}
\index{m\+\_\+drop\+Trace@{m\+\_\+drop\+Trace}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{m\+\_\+drop\+Trace}{m_dropTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Packet\+Socket\+::m\+\_\+drop\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PacketSocket_ae962e642085d93dadd3832a0355a10ad}{}\label{classns3_1_1PacketSocket_ae962e642085d93dadd3832a0355a10ad}


Traced callback\+: dropped packets. 

\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!m\+\_\+errno@{m\+\_\+errno}}
\index{m\+\_\+errno@{m\+\_\+errno}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{m\+\_\+errno}{m_errno}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Socket\+Errno} ns3\+::\+Packet\+Socket\+::m\+\_\+errno\hspace{0.3cm}{\ttfamily [mutable]}, {\ttfamily [private]}}\hypertarget{classns3_1_1PacketSocket_ac1da4372f719a7fb20b8d7fa426f21cc}{}\label{classns3_1_1PacketSocket_ac1da4372f719a7fb20b8d7fa426f21cc}


\hyperlink{classns3_1_1Socket}{Socket} error code. 

\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!m\+\_\+is\+Single\+Device@{m\+\_\+is\+Single\+Device}}
\index{m\+\_\+is\+Single\+Device@{m\+\_\+is\+Single\+Device}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{m\+\_\+is\+Single\+Device}{m_isSingleDevice}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Packet\+Socket\+::m\+\_\+is\+Single\+Device\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PacketSocket_a8d45062d8bdc229074cfc45e4abb77ec}{}\label{classns3_1_1PacketSocket_a8d45062d8bdc229074cfc45e4abb77ec}


Is bound to a single net\+Device. 

\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!m\+\_\+node@{m\+\_\+node}}
\index{m\+\_\+node@{m\+\_\+node}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{m\+\_\+node}{m_node}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Node}$>$ ns3\+::\+Packet\+Socket\+::m\+\_\+node\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PacketSocket_a1d16a7bb40df82877d5b6b257861d566}{}\label{classns3_1_1PacketSocket_a1d16a7bb40df82877d5b6b257861d566}


the associated node 

\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!m\+\_\+protocol@{m\+\_\+protocol}}
\index{m\+\_\+protocol@{m\+\_\+protocol}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{m\+\_\+protocol}{m_protocol}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Packet\+Socket\+::m\+\_\+protocol\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PacketSocket_ab563605d15111f7caef9a0c9ca18167c}{}\label{classns3_1_1PacketSocket_ab563605d15111f7caef9a0c9ca18167c}


\hyperlink{classns3_1_1Socket}{Socket} protocol. 

\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!m\+\_\+rcv\+Buf\+Size@{m\+\_\+rcv\+Buf\+Size}}
\index{m\+\_\+rcv\+Buf\+Size@{m\+\_\+rcv\+Buf\+Size}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{m\+\_\+rcv\+Buf\+Size}{m_rcvBufSize}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Packet\+Socket\+::m\+\_\+rcv\+Buf\+Size\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PacketSocket_a77f51ae1c17685fee11e5e10d90bd2f4}{}\label{classns3_1_1PacketSocket_a77f51ae1c17685fee11e5e10d90bd2f4}


Rx buffer size \mbox{[}Bytes\mbox{]}. 

\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!m\+\_\+rx\+Available@{m\+\_\+rx\+Available}}
\index{m\+\_\+rx\+Available@{m\+\_\+rx\+Available}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{m\+\_\+rx\+Available}{m_rxAvailable}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Packet\+Socket\+::m\+\_\+rx\+Available\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PacketSocket_a3afd17f0f1692c887648d0c2cb6d406c}{}\label{classns3_1_1PacketSocket_a3afd17f0f1692c887648d0c2cb6d406c}


Rx queue size \mbox{[}Bytes\mbox{]}. 

\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!m\+\_\+shutdown\+Recv@{m\+\_\+shutdown\+Recv}}
\index{m\+\_\+shutdown\+Recv@{m\+\_\+shutdown\+Recv}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{m\+\_\+shutdown\+Recv}{m_shutdownRecv}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Packet\+Socket\+::m\+\_\+shutdown\+Recv\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PacketSocket_af766986fa3298b3156972c0559fb8fa5}{}\label{classns3_1_1PacketSocket_af766986fa3298b3156972c0559fb8fa5}


Receive no longer allowed. 

\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!m\+\_\+shutdown\+Send@{m\+\_\+shutdown\+Send}}
\index{m\+\_\+shutdown\+Send@{m\+\_\+shutdown\+Send}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{m\+\_\+shutdown\+Send}{m_shutdownSend}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Packet\+Socket\+::m\+\_\+shutdown\+Send\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PacketSocket_ad16347ae79f47e980085db3a2674dc40}{}\label{classns3_1_1PacketSocket_ad16347ae79f47e980085db3a2674dc40}


Send no longer allowed. 

\index{ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}!m\+\_\+state@{m\+\_\+state}}
\index{m\+\_\+state@{m\+\_\+state}!ns3\+::\+Packet\+Socket@{ns3\+::\+Packet\+Socket}}
\subsubsection[{\texorpdfstring{m\+\_\+state}{m_state}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf State} ns3\+::\+Packet\+Socket\+::m\+\_\+state\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PacketSocket_adbf0f1f9b0a0bed7169ecdcb5a1ef66a}{}\label{classns3_1_1PacketSocket_adbf0f1f9b0a0bed7169ecdcb5a1ef66a}


\hyperlink{classns3_1_1Socket}{Socket} state. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
network/utils/\hyperlink{packet-socket_8h}{packet-\/socket.\+h}\item 
network/utils/\hyperlink{packet-socket_8cc}{packet-\/socket.\+cc}\end{DoxyCompactItemize}
