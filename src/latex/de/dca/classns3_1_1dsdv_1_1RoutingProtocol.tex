\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol}{}\section{ns3\+:\+:dsdv\+:\+:Routing\+Protocol Class Reference}
\label{classns3_1_1dsdv_1_1RoutingProtocol}\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}


D\+S\+DV routing protocol.  




{\ttfamily \#include $<$dsdv-\/routing-\/protocol.\+h$>$}



Inheritance diagram for ns3\+:\+:dsdv\+:\+:Routing\+Protocol\+:
% FIG 0


Collaboration diagram for ns3\+:\+:dsdv\+:\+:Routing\+Protocol\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_aa8c190cce6e43e2f664e662054afa94f}{Routing\+Protocol} ()
\begin{DoxyCompactList}\small\item\em c-\/tor \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a14451f07a4642d59bf0989dd0ff2a793}{$\sim$\+Routing\+Protocol} ()
\item 
virtual void \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_ad3c32f6593de0fbdbaf2fea4a4c1dfba}{Do\+Dispose} ()
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_af025a37dfb12829be3a1f484c5c926c0}{Route\+Output} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ oif, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket\+::\+Socket\+Errno} \&sockerr)
\begin{DoxyCompactList}\small\item\em Query routing cache for an existing route, for an outbound packet. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_af4cf2f9bed3afc8be2ccbb3a07d703b4}{Route\+Input} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ idev, \hyperlink{classns3_1_1Ipv4RoutingProtocol_a3453a85764cbbb1e704da7e919aa5d19}{Unicast\+Forward\+Callback} ucb, \hyperlink{classns3_1_1Ipv4RoutingProtocol_a26e76f7a555462e6c08fceda64a99d58}{Multicast\+Forward\+Callback} mcb, \hyperlink{classns3_1_1Ipv4RoutingProtocol_aa6ffa0159cb143daa3c46d2ba69bb1b9}{Local\+Deliver\+Callback} lcb, \hyperlink{classns3_1_1Ipv4RoutingProtocol_a0348285418c30d5021b08f7a68af21ea}{Error\+Callback} ecb)
\item 
virtual void \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_ac13b00f0a73404bebf2a6fccfea987d9}{Print\+Routing\+Table} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream, \hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295a}{Time\+::\+Unit} unit=\hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295aade8622b06524a328cd3a59db6ccf76af}{Time\+::S}) const 
\begin{DoxyCompactList}\small\item\em Print the Routing Table entries. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9a3edd95b3a0714d5aff5293e96883d2}{Notify\+Interface\+Up} (uint32\+\_\+t interface)
\item 
virtual void \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a4c9154c20c88647918a2c0e144be6b4f}{Notify\+Interface\+Down} (uint32\+\_\+t interface)
\item 
virtual void \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_aaf6b464336448d3cf4e6370b00943253}{Notify\+Add\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} address)
\item 
virtual void \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a27292ecea0925d440a272b57f1b96aab}{Notify\+Remove\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} address)
\item 
virtual void \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_aab88c62fbd0567cf31d185cb58b23a44}{Set\+Ipv4} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$ ipv4)
\item 
void \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a4a3de094f750c655b3119a0111184b67}{Set\+Enable\+Buffer\+Flag} (bool \hyperlink{80211b_8c_ae7ffc1a8f84fa47a0812b2f2b9627132}{f})
\item 
bool \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_ac3de22557834f8656657afe95f2f523f}{Get\+Enable\+Buffer\+Flag} () const 
\item 
void \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a7dc8bc0bba2c84dc1e50613d2f84f124}{Set\+W\+S\+T\+Flag} (bool \hyperlink{80211b_8c_ae7ffc1a8f84fa47a0812b2f2b9627132}{f})
\item 
bool \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_aa44017be461c04c8abf8ab04d5016d5e}{Get\+W\+S\+T\+Flag} () const 
\item 
void \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a2c0b24d0c86af1c4d3d58cc0bea5c201}{Set\+Enable\+R\+A\+Flag} (bool \hyperlink{80211b_8c_ae7ffc1a8f84fa47a0812b2f2b9627132}{f})
\item 
bool \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a7bee3dce5e8ef323300971c4e45e3d30}{Get\+Enable\+R\+A\+Flag} () const 
\item 
int64\+\_\+t \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_ad019a8702f1606a6a4c93d81af2aad64}{Assign\+Streams} (int64\+\_\+t stream)
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a94877c474548735fa3764b89a86db709}{Get\+Type\+Id} (void)
\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const uint32\+\_\+t \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a14b063286a3c34efb9537f6456af3271}{D\+S\+D\+V\+\_\+\+P\+O\+RT} = 269
\begin{DoxyCompactList}\small\item\em U\+DP Port for D\+S\+DV control traffic. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a1e6145b4ecb927243c4758012036c45a}{Start} ()
\begin{DoxyCompactList}\small\item\em Start protocol operation. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a69ada1af49e7f09f91199062e14fb75f}{Deferred\+Route\+Output} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&header, \hyperlink{classns3_1_1Ipv4RoutingProtocol_a3453a85764cbbb1e704da7e919aa5d19}{Unicast\+Forward\+Callback} ucb, \hyperlink{classns3_1_1Ipv4RoutingProtocol_a0348285418c30d5021b08f7a68af21ea}{Error\+Callback} ecb)
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Queue}{Queue} packet untill we find a route. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a775bb168f6e8c4feb854aba73326681e}{Look\+For\+Queued\+Packets} (void)
\begin{DoxyCompactList}\small\item\em Look for any queued packets to send them out. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9359912928dc5b8dc851366a78c0cc8c}{Send\+Packet\+From\+Queue} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} dst, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ route)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$ \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_ab87d72bcdb89e0ff1034912db8868c01}{Find\+Socket\+With\+Interface\+Address} (\hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} iface) const 
\begin{DoxyCompactList}\small\item\em Find socket with local interface address iface. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_ad27475d64bfd478b57d73f3cc08d4c99}{Recv\+Dsdv} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$ socket)
\begin{DoxyCompactList}\small\item\em Receive and process dsdv control packet. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a7b4ba195edb9521642be588fb4f0576e}{Send} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$, const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_aadc3f2072721211ad452bcbe49762420}{Loopback\+Route} (const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ oif) const 
\begin{DoxyCompactList}\small\item\em Create loopback route for given header. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a83244927636fd12b775ebdbe0b334e68}{Get\+Settling\+Time} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} dst)
\item 
void \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adc414310ddaa5e69520a176c0dac59cc}{Send\+Triggered\+Update} ()
\begin{DoxyCompactList}\small\item\em Sends trigger update from a node. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a370e3ca262a505ec0fd30456f82b2aed}{Send\+Periodic\+Update} ()
\begin{DoxyCompactList}\small\item\em Broadcasts the entire routing table for every Periodic\+Update\+Interval. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_afcf1903d16fb9d303805fbe07986bb06}{Merge\+Trigger\+Periodic\+Updates} ()
\item 
void \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_ac761f05ae1c90cc3a4a7b9a6e540132e}{Drop} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$, const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket\+::\+Socket\+Errno})
\begin{DoxyCompactList}\small\item\em Notify that packet is dropped for some reason. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
uint32\+\_\+t \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acdadd6be395f15827ec7c8531797b6e0}{Holdtimes}
\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a1951a29aaca9beebdff3abd5c7d00ef0}{m\+\_\+periodic\+Update\+Interval}
\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_ac00a3214f64eddbab1fbf039aa293ae9}{m\+\_\+settling\+Time}
\item 
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_af7cb076b88eb5ff20a1c146e3f5849f6}{m\+\_\+main\+Address}
\begin{DoxyCompactList}\small\item\em Nodes IP address. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$ \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\+\_\+ipv4}
\begin{DoxyCompactList}\small\item\em IP protocol. \end{DoxyCompactList}\item 
std\+::map$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$, \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} $>$ \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9f3be507604655079b145f063cf036fd}{m\+\_\+socket\+Addresses}
\begin{DoxyCompactList}\small\item\em Raw socket per each IP interface, map socket -\/$>$ iface address (IP + mask) \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a793deb930065a91d037ed2930e756528}{m\+\_\+lo}
\begin{DoxyCompactList}\small\item\em Loopback device used to defer route requests until a route is found. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1dsdv_1_1RoutingTable}{Routing\+Table} \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\+\_\+routing\+Table}
\begin{DoxyCompactList}\small\item\em Main Routing table for the node. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1dsdv_1_1RoutingTable}{Routing\+Table} \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\+\_\+adv\+Routing\+Table}
\begin{DoxyCompactList}\small\item\em Advertised Routing table for the node. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_aedf19d36f43f8c0bed80d22b2eec343c}{m\+\_\+max\+Queue\+Len}
\begin{DoxyCompactList}\small\item\em The maximum number of packets that we allow a routing protocol to buffer. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a2bfab14f96b69300b5b86aeaca2b6f64}{m\+\_\+max\+Queued\+Packets\+Per\+Dst}
\begin{DoxyCompactList}\small\item\em The maximum number of packets that we allow per destination to buffer. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a99d9a7c27e476c4f0a2c93f889ab8e13}{m\+\_\+max\+Queue\+Time}
\begin{DoxyCompactList}\small\item\em The maximum period of time that a routing protocol is allowed to buffer a packet for. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1dsdv_1_1PacketQueue}{Packet\+Queue} \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a3ed623ade7d7244ed1ff5e0f6a399a68}{m\+\_\+queue}
\begin{DoxyCompactList}\small\item\em A \char`\"{}drop front on full\char`\"{} queue used by the routing layer to buffer packets to which it does not have a route. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a257bf2eb6e7eff700d12f00f2d9ec0e3}{Enable\+Buffering}
\begin{DoxyCompactList}\small\item\em Flag that is used to enable or disable buffering. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_abf3b9f8c78278e4d2faf177146359d19}{Enable\+W\+ST}
\begin{DoxyCompactList}\small\item\em Flag that is used to enable or disable Weighted Settling \hyperlink{classns3_1_1Time}{Time}. \end{DoxyCompactList}\item 
double \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_afd15e37062d937b28ba081fc515f3a77}{m\+\_\+weighted\+Factor}
\begin{DoxyCompactList}\small\item\em This is the wighted factor to determine the weighted settling time. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a91fada0798359d72bfaf88bf33b1e62d}{Enable\+Route\+Aggregation}
\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a8d7bef939cd3872c1821fc4bce884f8d}{m\+\_\+route\+Aggregation\+Time}
\begin{DoxyCompactList}\small\item\em Parameter that holds the route aggregation time interval. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4RoutingProtocol_a3453a85764cbbb1e704da7e919aa5d19}{Unicast\+Forward\+Callback} \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a2ffc78a04da837daca7d5012373ef905}{m\+\_\+scb}
\begin{DoxyCompactList}\small\item\em Unicast callback for own packets. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4RoutingProtocol_a0348285418c30d5021b08f7a68af21ea}{Error\+Callback} \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a99588cc0468d174969bd6a66670286ee}{m\+\_\+ecb}
\begin{DoxyCompactList}\small\item\em Error callback for own packets. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Timer}{Timer} \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a851fbb5569e6681fd1c42f47d2a79ee8}{m\+\_\+periodic\+Update\+Timer}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Timer}{Timer} to trigger periodic updates from a node. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Timer}{Timer} \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a013fc28f0c7cd0e5a001165ec6c7c899}{m\+\_\+triggered\+Expire\+Timer}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Timer}{Timer} used by the trigger updates in case of Weighted Settling \hyperlink{classns3_1_1Time}{Time} is used. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UniformRandomVariable}{Uniform\+Random\+Variable} $>$ \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a2d5efde0680b47457d0b94d0493c9eec}{m\+\_\+uniform\+Random\+Variable}
\begin{DoxyCompactList}\small\item\em Provides uniform random variables. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
D\+S\+DV routing protocol. 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Routing\+Protocol@{Routing\+Protocol}}
\index{Routing\+Protocol@{Routing\+Protocol}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Routing\+Protocol()}{RoutingProtocol()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Routing\+Protocol (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_aa8c190cce6e43e2f664e662054afa94f}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_aa8c190cce6e43e2f664e662054afa94f}


c-\/tor 


\begin{DoxyCode}
206   : \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable} (),
207     \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable} (),
208     \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a3ed623ade7d7244ed1ff5e0f6a399a68}{m\_queue} (),
209     \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a851fbb5569e6681fd1c42f47d2a79ee8}{m\_periodicUpdateTimer} (\hyperlink{classns3_1_1Timer_a816309b83cd2a35bea47d9bbc6bbf721a07a9dd5063b32fb6cf1f813c6ee7e28e}{Timer::CANCEL\_ON\_DESTROY})
210 \{
211   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a2d5efde0680b47457d0b94d0493c9eec}{m\_uniformRandomVariable} = CreateObject<UniformRandomVariable> ();
212 \}
\end{DoxyCode}
\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!````~Routing\+Protocol@{$\sim$\+Routing\+Protocol}}
\index{````~Routing\+Protocol@{$\sim$\+Routing\+Protocol}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{$\sim$\+Routing\+Protocol()}{~RoutingProtocol()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::dsdv\+::\+Routing\+Protocol\+::$\sim$\+Routing\+Protocol (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a14451f07a4642d59bf0989dd0ff2a793}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a14451f07a4642d59bf0989dd0ff2a793}

\begin{DoxyCode}
215 \{
216 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Assign\+Streams@{Assign\+Streams}}
\index{Assign\+Streams@{Assign\+Streams}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Assign\+Streams(int64\+\_\+t stream)}{AssignStreams(int64_t stream)}}]{\setlength{\rightskip}{0pt plus 5cm}int64\+\_\+t ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Assign\+Streams (
\begin{DoxyParamCaption}
\item[{int64\+\_\+t}]{stream}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_ad019a8702f1606a6a4c93d81af2aad64}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_ad019a8702f1606a6a4c93d81af2aad64}
Assign a fixed random variable stream number to the random variables used by this model. Return the number of streams (possibly zero) that have been assigned.


\begin{DoxyParams}{Parameters}
{\em stream} & first stream index to use \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of stream indices assigned by this model 
\end{DoxyReturn}

\begin{DoxyCode}
199 \{
200   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << stream);
201   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a2d5efde0680b47457d0b94d0493c9eec}{m\_uniformRandomVariable}->\hyperlink{classns3_1_1RandomVariableStream_add11aaf975607746b7e271d300659a94}{SetStream} (stream);
202   \textcolor{keywordflow}{return} 1;
203 \}
\end{DoxyCode}
\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Deferred\+Route\+Output@{Deferred\+Route\+Output}}
\index{Deferred\+Route\+Output@{Deferred\+Route\+Output}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Deferred\+Route\+Output(\+Ptr$<$ const Packet $>$ p, const Ipv4\+Header \&header, Unicast\+Forward\+Callback ucb, Error\+Callback ecb)}{DeferredRouteOutput(Ptr< const Packet > p, const Ipv4Header &header, UnicastForwardCallback ucb, ErrorCallback ecb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Deferred\+Route\+Output (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv4\+Header} \&}]{header, }
\item[{{\bf Unicast\+Forward\+Callback}}]{ucb, }
\item[{{\bf Error\+Callback}}]{ecb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a69ada1af49e7f09f91199062e14fb75f}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a69ada1af49e7f09f91199062e14fb75f}


\hyperlink{classns3_1_1Queue}{Queue} packet untill we find a route. 


\begin{DoxyCode}
354 \{
355   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} << header);
356   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} != 0 && \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} != Ptr<Packet> ());
357   QueueEntry newEntry (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p},header,ucb,ecb);
358   \textcolor{keywordtype}{bool} result = \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a3ed623ade7d7244ed1ff5e0f6a399a68}{m\_queue}.\hyperlink{classns3_1_1dsdv_1_1PacketQueue_a21df29a3811016d2a8b45adead771410}{Enqueue} (newEntry);
359   \textcolor{keywordflow}{if} (result)
360     \{
361       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Added packet "} << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->GetUid () << \textcolor{stringliteral}{" to queue."});
362     \}
363 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2




Here is the caller graph for this function\+:
% FIG 3


\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Do\+Dispose()}{DoDispose()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_ad3c32f6593de0fbdbaf2fea4a4c1dfba}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_ad3c32f6593de0fbdbaf2fea4a4c1dfba}
Destructor implementation.

This method is called by \hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose()} or by the \hyperlink{classns3_1_1Object}{Object}\textquotesingle{}s destructor, whichever comes first.

Subclasses are expected to implement their real destruction code in an overriden version of this method and chain up to their parent\textquotesingle{}s implementation once they are done. {\itshape i.\+e}, for simplicity, the destructor of every subclass should be empty and its content should be moved to the associated \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_ad3c32f6593de0fbdbaf2fea4a4c1dfba}{Do\+Dispose()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.


\begin{DoxyCode}
220 \{
221   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4} = 0;
222   \textcolor{keywordflow}{for} (std::map<Ptr<Socket>, Ipv4InterfaceAddress>::iterator iter = 
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9f3be507604655079b145f063cf036fd}{m\_socketAddresses}.begin (); iter
223        != \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9f3be507604655079b145f063cf036fd}{m\_socketAddresses}.end (); iter++)
224     \{
225       iter->first->Close ();
226     \}
227   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9f3be507604655079b145f063cf036fd}{m\_socketAddresses}.clear ();
228   \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{Ipv4RoutingProtocol::DoDispose} ();
229 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4


\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Drop@{Drop}}
\index{Drop@{Drop}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Drop(\+Ptr$<$ const Packet $>$, const Ipv4\+Header \&, Socket\+::\+Socket\+Errno)}{Drop(Ptr< const Packet >, const Ipv4Header &, Socket::SocketErrno)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Drop (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{packet, }
\item[{const {\bf Ipv4\+Header} \&}]{header, }
\item[{{\bf Socket\+::\+Socket\+Errno}}]{err}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_ac761f05ae1c90cc3a4a7b9a6e540132e}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_ac761f05ae1c90cc3a4a7b9a6e540132e}


Notify that packet is dropped for some reason. 


\begin{DoxyCode}
1104 \{
1105   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_af7cb076b88eb5ff20a1c146e3f5849f6}{m\_mainAddress} << \textcolor{stringliteral}{" drop packet "} << packet->GetUid () << \textcolor{stringliteral}{" to "}
1106                               << header.GetDestination () << \textcolor{stringliteral}{" from queue. Error "} << err);
1107 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5




Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Find\+Socket\+With\+Interface\+Address@{Find\+Socket\+With\+Interface\+Address}}
\index{Find\+Socket\+With\+Interface\+Address@{Find\+Socket\+With\+Interface\+Address}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Find\+Socket\+With\+Interface\+Address(\+Ipv4\+Interface\+Address iface) const }{FindSocketWithInterfaceAddress(Ipv4InterfaceAddress iface) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Socket} $>$ ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Find\+Socket\+With\+Interface\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Interface\+Address}}]{iface}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_ab87d72bcdb89e0ff1034912db8868c01}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_ab87d72bcdb89e0ff1034912db8868c01}


Find socket with local interface address iface. 


\begin{DoxyCode}
1074 \{
1075   \textcolor{keywordflow}{for} (std::map<Ptr<Socket>, Ipv4InterfaceAddress>::const\_iterator j = 
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9f3be507604655079b145f063cf036fd}{m\_socketAddresses}.begin (); j
1076        != \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9f3be507604655079b145f063cf036fd}{m\_socketAddresses}.end (); ++j)
1077     \{
1078       Ptr<Socket> socket = j->first;
1079       Ipv4InterfaceAddress iface = j->second;
1080       \textcolor{keywordflow}{if} (iface == addr)
1081         \{
1082           \textcolor{keywordflow}{return} socket;
1083         \}
1084     \}
1085   Ptr<Socket> socket;
1086   \textcolor{keywordflow}{return} socket;
1087 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Get\+Enable\+Buffer\+Flag@{Get\+Enable\+Buffer\+Flag}}
\index{Get\+Enable\+Buffer\+Flag@{Get\+Enable\+Buffer\+Flag}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Enable\+Buffer\+Flag() const }{GetEnableBufferFlag() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Get\+Enable\+Buffer\+Flag (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_ac3de22557834f8656657afe95f2f523f}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_ac3de22557834f8656657afe95f2f523f}

\begin{DoxyCode}
173 \{
174   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a257bf2eb6e7eff700d12f00f2d9ec0e3}{EnableBuffering};
175 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Get\+Enable\+R\+A\+Flag@{Get\+Enable\+R\+A\+Flag}}
\index{Get\+Enable\+R\+A\+Flag@{Get\+Enable\+R\+A\+Flag}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Enable\+R\+A\+Flag() const }{GetEnableRAFlag() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Get\+Enable\+R\+A\+Flag (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a7bee3dce5e8ef323300971c4e45e3d30}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a7bee3dce5e8ef323300971c4e45e3d30}

\begin{DoxyCode}
193 \{
194   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a91fada0798359d72bfaf88bf33b1e62d}{EnableRouteAggregation};
195 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 9


\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Get\+Settling\+Time@{Get\+Settling\+Time}}
\index{Get\+Settling\+Time@{Get\+Settling\+Time}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Settling\+Time(\+Ipv4\+Address dst)}{GetSettlingTime(Ipv4Address dst)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Get\+Settling\+Time (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{dst}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a83244927636fd12b775ebdbe0b334e68}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a83244927636fd12b775ebdbe0b334e68}
Get settling\+Time for a destination 
\begin{DoxyParams}{Parameters}
{\em dst} & -\/ destination address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
settling\+Time for the destination if found 
\end{DoxyReturn}

\begin{DoxyCode}
1178 \{
1179   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{stringliteral}{"Calculating the settling time for "} << address);
1180   RoutingTableEntry mainrt;
1181   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} weightedTime;
1182   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a0bfb9dc677f02bd740973865e38df763}{LookupRoute} (address,mainrt);
1183   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_abf3b9f8c78278e4d2faf177146359d19}{EnableWST})
1184     \{
1185       \textcolor{keywordflow}{if} (mainrt.GetSettlingTime () == \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (0))
1186         \{
1187           \textcolor{keywordflow}{return} \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (0);
1188         \}
1189       \textcolor{keywordflow}{else}
1190         \{
1191           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Route SettlingTime: "} << mainrt.GetSettlingTime ().GetSeconds ()
1192                                                << \textcolor{stringliteral}{" and LifeTime:"} << mainrt.GetLifeTime ().GetSeconds ());
1193           weightedTime = \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_afd15e37062d937b28ba081fc515f3a77}{m\_weightedFactor} * mainrt.GetSettlingTime ().GetSeconds 
      () + (1.0 - \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_afd15e37062d937b28ba081fc515f3a77}{m\_weightedFactor})
1194                                * mainrt.GetLifeTime ().GetSeconds ());
1195           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Calculated weightedTime:"} << weightedTime.GetSeconds ());
1196           \textcolor{keywordflow}{return} weightedTime;
1197         \}
1198     \}
1199   \textcolor{keywordflow}{return} mainrt.GetSettlingTime ();
1200 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10




Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a94877c474548735fa3764b89a86db709}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a94877c474548735fa3764b89a86db709}

\begin{DoxyCode}
110 \{
111   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::dsdv::RoutingProtocol"})
112     .SetParent<Ipv4RoutingProtocol> ()
113     .SetGroupName (\textcolor{stringliteral}{"Dsdv"})
114     .AddConstructor<\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_aa8c190cce6e43e2f664e662054afa94f}{RoutingProtocol}> ()
115     .AddAttribute (\textcolor{stringliteral}{"PeriodicUpdateInterval"},\textcolor{stringliteral}{"Periodic interval between exchange of full routing tables
       among nodes. "},
116                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (15)),
117                    MakeTimeAccessor (&\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a1951a29aaca9beebdff3abd5c7d00ef0}{RoutingProtocol::m\_periodicUpdateInterval}
      ),
118                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
119     .AddAttribute (\textcolor{stringliteral}{"SettlingTime"}, \textcolor{stringliteral}{"Minimum time an update is to be stored in adv table before sending out"}
120                    \textcolor{stringliteral}{"in case of change in metric (in seconds)"},
121                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (5)),
122                    MakeTimeAccessor (&\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_ac00a3214f64eddbab1fbf039aa293ae9}{RoutingProtocol::m\_settlingTime}),
123                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
124     .AddAttribute (\textcolor{stringliteral}{"MaxQueueLen"}, \textcolor{stringliteral}{"Maximum number of packets that we allow a routing protocol to buffer."},
125                    UintegerValue (500 \textcolor{comment}{/*assuming maximum nodes in simulation is 100*/}),
126                    MakeUintegerAccessor (&\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_aedf19d36f43f8c0bed80d22b2eec343c}{RoutingProtocol::m\_maxQueueLen}),
127                    MakeUintegerChecker<uint32\_t> ())
128     .AddAttribute (\textcolor{stringliteral}{"MaxQueuedPacketsPerDst"}, \textcolor{stringliteral}{"Maximum number of packets that we allow per destination to
       buffer."},
129                    UintegerValue (5),
130                    MakeUintegerAccessor (&
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a2bfab14f96b69300b5b86aeaca2b6f64}{RoutingProtocol::m\_maxQueuedPacketsPerDst}),
131                    MakeUintegerChecker<uint32\_t> ())
132     .AddAttribute (\textcolor{stringliteral}{"MaxQueueTime"},\textcolor{stringliteral}{"Maximum time packets can be queued (in seconds)"},
133                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (30)),
134                    MakeTimeAccessor (&\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a99d9a7c27e476c4f0a2c93f889ab8e13}{RoutingProtocol::m\_maxQueueTime}),
135                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
136     .AddAttribute (\textcolor{stringliteral}{"EnableBuffering"},\textcolor{stringliteral}{"Enables buffering of data packets if no route to destination is
       available"},
137                    BooleanValue (\textcolor{keyword}{true}),
138                    MakeBooleanAccessor (&\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a4a3de094f750c655b3119a0111184b67}{RoutingProtocol::SetEnableBufferFlag}
      ,
139                                         &\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_ac3de22557834f8656657afe95f2f523f}{RoutingProtocol::GetEnableBufferFlag}
      ),
140                    MakeBooleanChecker ())
141     .AddAttribute (\textcolor{stringliteral}{"EnableWST"},\textcolor{stringliteral}{"Enables Weighted Settling Time for the updates before advertising"},
142                    BooleanValue (\textcolor{keyword}{true}),
143                    MakeBooleanAccessor (&\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a7dc8bc0bba2c84dc1e50613d2f84f124}{RoutingProtocol::SetWSTFlag},
144                                         &\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_aa44017be461c04c8abf8ab04d5016d5e}{RoutingProtocol::GetWSTFlag}),
145                    MakeBooleanChecker ())
146     .AddAttribute (\textcolor{stringliteral}{"Holdtimes"},\textcolor{stringliteral}{"Times the forwarding Interval to purge the route."},
147                    UintegerValue (3),
148                    MakeUintegerAccessor (&\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acdadd6be395f15827ec7c8531797b6e0}{RoutingProtocol::Holdtimes}),
149                    MakeUintegerChecker<uint32\_t> ())
150     .AddAttribute (\textcolor{stringliteral}{"WeightedFactor"},\textcolor{stringliteral}{"WeightedFactor for the settling time if Weighted Settling Time is
       enabled"},
151                    DoubleValue (0.875),
152                    MakeDoubleAccessor (&\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_afd15e37062d937b28ba081fc515f3a77}{RoutingProtocol::m\_weightedFactor})
      ,
153                    MakeDoubleChecker<double> ())
154     .AddAttribute (\textcolor{stringliteral}{"EnableRouteAggregation"},\textcolor{stringliteral}{"Enables Weighted Settling Time for the updates before
       advertising"},
155                    BooleanValue (\textcolor{keyword}{false}),
156                    MakeBooleanAccessor (&\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a2c0b24d0c86af1c4d3d58cc0bea5c201}{RoutingProtocol::SetEnableRAFlag},
157                                         &\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a7bee3dce5e8ef323300971c4e45e3d30}{RoutingProtocol::GetEnableRAFlag}),
158                    MakeBooleanChecker ())
159     .AddAttribute (\textcolor{stringliteral}{"RouteAggregationTime"},\textcolor{stringliteral}{"Time to aggregate updates before sending them out (in seconds)"},
160                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (1)),
161                    MakeTimeAccessor (&\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a8d7bef939cd3872c1821fc4bce884f8d}{RoutingProtocol::m\_routeAggregationTime}
      ),
162                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ());
163   \textcolor{keywordflow}{return} tid;
164 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12


\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Get\+W\+S\+T\+Flag@{Get\+W\+S\+T\+Flag}}
\index{Get\+W\+S\+T\+Flag@{Get\+W\+S\+T\+Flag}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+W\+S\+T\+Flag() const }{GetWSTFlag() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Get\+W\+S\+T\+Flag (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_aa44017be461c04c8abf8ab04d5016d5e}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_aa44017be461c04c8abf8ab04d5016d5e}

\begin{DoxyCode}
183 \{
184   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_abf3b9f8c78278e4d2faf177146359d19}{EnableWST};
185 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 13


\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Look\+For\+Queued\+Packets@{Look\+For\+Queued\+Packets}}
\index{Look\+For\+Queued\+Packets@{Look\+For\+Queued\+Packets}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Look\+For\+Queued\+Packets(void)}{LookForQueuedPackets(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Look\+For\+Queued\+Packets (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a775bb168f6e8c4feb854aba73326681e}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a775bb168f6e8c4feb854aba73326681e}


Look for any queued packets to send them out. 


\begin{DoxyCode}
1111 \{
1112   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1113   Ptr<Ipv4Route> route;
1114   std::map<Ipv4Address, RoutingTableEntry> allRoutes;
1115   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_af980697df819d8a00ee8782c705e3dac}{GetListOfAllRoutes} (allRoutes);
1116   \textcolor{keywordflow}{for} (std::map<Ipv4Address, RoutingTableEntry>::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = allRoutes.begin (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != allRoutes.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
1117     \{
1118       RoutingTableEntry rt;
1119       rt = \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second;
1120       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a3ed623ade7d7244ed1ff5e0f6a399a68}{m\_queue}.\hyperlink{classns3_1_1dsdv_1_1PacketQueue_a13a16f813e0f9a67b2ab4ee3b1f10c70}{Find} (rt.GetDestination ()))
1121         \{
1122           \textcolor{keywordflow}{if} (rt.GetHop () == 1)
1123             \{
1124               route = rt.GetRoute ();
1125               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"A route exists from "} << route->GetSource ()
1126                                                    << \textcolor{stringliteral}{" to neighboring destination "}
1127                                                    << route->GetDestination ());
1128               \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (route != 0);
1129             \}
1130           \textcolor{keywordflow}{else}
1131             \{
1132               RoutingTableEntry newrt;
1133               \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a0bfb9dc677f02bd740973865e38df763}{LookupRoute} (rt.GetNextHop (),newrt);
1134               route = newrt.GetRoute ();
1135               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"A route exists from "} << route->GetSource ()
1136                                                    << \textcolor{stringliteral}{" to destination "} << route->GetDestination () << \textcolor{stringliteral}{"
       via "}
1137                                                    << rt.GetNextHop ());
1138               \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (route != 0);
1139             \}
1140           \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9359912928dc5b8dc851366a78c0cc8c}{SendPacketFromQueue} (rt.GetDestination (),route);
1141         \}
1142     \}
1143 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 14




Here is the caller graph for this function\+:
% FIG 15


\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Loopback\+Route@{Loopback\+Route}}
\index{Loopback\+Route@{Loopback\+Route}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Loopback\+Route(const Ipv4\+Header \&header, Ptr$<$ Net\+Device $>$ oif) const }{LoopbackRoute(const Ipv4Header &header, Ptr< NetDevice > oif) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv4\+Route} $>$ ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Loopback\+Route (
\begin{DoxyParamCaption}
\item[{const {\bf Ipv4\+Header} \&}]{header, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{oif}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_aadc3f2072721211ad452bcbe49762420}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_aadc3f2072721211ad452bcbe49762420}


Create loopback route for given header. 


\begin{DoxyCode}
501 \{
502   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a793deb930065a91d037ed2930e756528}{m\_lo} != 0);
503   Ptr<Ipv4Route> rt = Create<Ipv4Route> ();
504   rt->SetDestination (hdr.GetDestination ());
505   \textcolor{comment}{// rt->SetSource (hdr.GetSource ());}
506   \textcolor{comment}{//}
507   \textcolor{comment}{// Source address selection here is tricky.  The loopback route is}
508   \textcolor{comment}{// returned when DSDV does not have a route; this causes the packet}
509   \textcolor{comment}{// to be looped back and handled (cached) in RouteInput() method}
510   \textcolor{comment}{// while a route is found. However, connection-oriented protocols}
511   \textcolor{comment}{// like TCP need to create an endpoint four-tuple (src, src port,}
512   \textcolor{comment}{// dst, dst port) and create a pseudo-header for checksumming.  So,}
513   \textcolor{comment}{// DSDV needs to guess correctly what the eventual source address}
514   \textcolor{comment}{// will be.}
515   \textcolor{comment}{//}
516   \textcolor{comment}{// For single interface, single address nodes, this is not a problem.}
517   \textcolor{comment}{// When there are possibly multiple outgoing interfaces, the policy}
518   \textcolor{comment}{// implemented here is to pick the first available DSDV interface.}
519   \textcolor{comment}{// If RouteOutput() caller specified an outgoing interface, that}
520   \textcolor{comment}{// further constrains the selection of source address}
521   \textcolor{comment}{//}
522   std::map<Ptr<Socket>, Ipv4InterfaceAddress>::const\_iterator j = 
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9f3be507604655079b145f063cf036fd}{m\_socketAddresses}.begin ();
523   \textcolor{keywordflow}{if} (oif)
524     \{
525       \textcolor{comment}{// Iterate to find an address on the oif device}
526       \textcolor{keywordflow}{for} (j = \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9f3be507604655079b145f063cf036fd}{m\_socketAddresses}.begin (); j != 
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9f3be507604655079b145f063cf036fd}{m\_socketAddresses}.end (); ++j)
527         \{
528           Ipv4Address addr = j->second.GetLocal ();
529           int32\_t \textcolor{keyword}{interface }= \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetInterfaceForAddress (addr);
530           \textcolor{keywordflow}{if} (oif == \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetNetDevice (static\_cast<uint32\_t> (interface)))
531             \{
532               rt->SetSource (addr);
533               \textcolor{keywordflow}{break};
534             \}
535         \}
536     \}
537   \textcolor{keywordflow}{else}
538     \{
539       rt->SetSource (j->second.GetLocal ());
540     \}
541   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (rt->GetSource () != Ipv4Address (), \textcolor{stringliteral}{"Valid DSDV source address not found"});
542   rt->SetGateway (Ipv4Address (\textcolor{stringliteral}{"127.0.0.1"}));
543   rt->SetOutputDevice (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a793deb930065a91d037ed2930e756528}{m\_lo});
544   \textcolor{keywordflow}{return} rt;
545 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 16




Here is the caller graph for this function\+:
% FIG 17


\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Merge\+Trigger\+Periodic\+Updates@{Merge\+Trigger\+Periodic\+Updates}}
\index{Merge\+Trigger\+Periodic\+Updates@{Merge\+Trigger\+Periodic\+Updates}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Merge\+Trigger\+Periodic\+Updates()}{MergeTriggerPeriodicUpdates()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Merge\+Trigger\+Periodic\+Updates (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_afcf1903d16fb9d303805fbe07986bb06}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_afcf1903d16fb9d303805fbe07986bb06}

\begin{DoxyCode}
1204 \{
1205   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{stringliteral}{"Merging advertised table changes with main table before sending out
       periodic update"});
1206   std::map<Ipv4Address, RoutingTableEntry> allRoutes;
1207   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_af980697df819d8a00ee8782c705e3dac}{GetListOfAllRoutes} (allRoutes);
1208   \textcolor{keywordflow}{if} (allRoutes.size () > 0)
1209     \{
1210       \textcolor{keywordflow}{for} (std::map<Ipv4Address, RoutingTableEntry>::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = allRoutes.begin (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != allRoutes.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
1211         \{
1212           RoutingTableEntry advEntry = \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second;
1213           \textcolor{keywordflow}{if} ((advEntry.GetEntriesChanged () == \textcolor{keyword}{true}) && (!\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.
      \hyperlink{classns3_1_1dsdv_1_1RoutingTable_acb9f117332351347f8345d4591991e6b}{AnyRunningEvent} (advEntry.GetDestination ())))
1214             \{
1215               \textcolor{keywordflow}{if} (!(advEntry.GetSeqNo () % 2))
1216                 \{
1217                   advEntry.SetFlag (\hyperlink{namespacens3_1_1dsdv_aa1c39555b993cc6f56f2c8c6c31e2c3baf2cbf3d202d1c7338230c662e6822e65}{VALID});
1218                   advEntry.SetEntriesChanged (\textcolor{keyword}{false});
1219                   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a651762730975f809c720313b1332cb99}{Update} (advEntry);
1220                   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Merged update for "} << advEntry.GetDestination () << \textcolor{stringliteral}{" with
       main routing Table"});
1221                 \}
1222               \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a384f271a1393c513c4ae7ba4476c3e08}{DeleteRoute} (advEntry.GetDestination ());
1223             \}
1224           \textcolor{keywordflow}{else}
1225             \{
1226               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Event currently running. Cannot Merge Routing Tables"});
1227             \}
1228         \}
1229     \}
1230 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 18




Here is the caller graph for this function\+:
% FIG 19


\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Notify\+Add\+Address@{Notify\+Add\+Address}}
\index{Notify\+Add\+Address@{Notify\+Add\+Address}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Notify\+Add\+Address(uint32\+\_\+t interface, Ipv4\+Interface\+Address address)}{NotifyAddAddress(uint32_t interface, Ipv4InterfaceAddress address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Notify\+Add\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv4\+Interface\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_aaf6b464336448d3cf4e6370b00943253}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_aaf6b464336448d3cf4e6370b00943253}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
{\em address} & a new address being added to an interface\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified whenever a new address is added to an interface. Typically used to add a \textquotesingle{}network route\textquotesingle{} on an interface. Can be invoked on an up or down interface. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_aef12fcf9cc478536876b0281505d40aa}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
1018 \{
1019   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" interface "} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} << \textcolor{stringliteral}{" address "} << address);
1020   Ptr<Ipv4L3Protocol> l3 = \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetObject<Ipv4L3Protocol> ();
1021   \textcolor{keywordflow}{if} (!l3->IsUp (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}))
1022     \{
1023       \textcolor{keywordflow}{return};
1024     \}
1025   Ipv4InterfaceAddress iface = l3->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i},0);
1026   Ptr<Socket> socket = \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_ab87d72bcdb89e0ff1034912db8868c01}{FindSocketWithInterfaceAddress} (iface);
1027   \textcolor{keywordflow}{if} (!socket)
1028     \{
1029       \textcolor{keywordflow}{if} (iface.GetLocal () == Ipv4Address (\textcolor{stringliteral}{"127.0.0.1"}))
1030         \{
1031           \textcolor{keywordflow}{return};
1032         \}
1033       Ptr<Socket> socket = \hyperlink{classns3_1_1Socket_ad448a62bb50ad3dbac59c879a885a8d2}{Socket::CreateSocket} (GetObject<Node> (),
      \hyperlink{classns3_1_1UdpSocketFactory_ad5b47e944de8861e3dc2b6de1ccbdf5b}{UdpSocketFactory::GetTypeId} ());
1034       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (socket != 0);
1035       socket->SetRecvCallback (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_ad27475d64bfd478b57d73f3cc08d4c99}{RoutingProtocol::RecvDsdv},\textcolor{keyword}{this}));
1036       \textcolor{comment}{// Bind to any IP address so that broadcasts can be received}
1037       socket->Bind (InetSocketAddress (\hyperlink{classns3_1_1Ipv4Address_a7a39b330c8e701183a411d5779fca1a4}{Ipv4Address::GetAny} (), 
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a14b063286a3c34efb9537f6456af3271}{DSDV\_PORT}));
1038       socket->BindToNetDevice (l3->GetNetDevice (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}));
1039       socket->SetAllowBroadcast (\textcolor{keyword}{true});
1040       \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9f3be507604655079b145f063cf036fd}{m\_socketAddresses}.insert (std::make\_pair (socket,iface));
1041       Ptr<NetDevice> dev = \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetNetDevice (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetInterfaceForAddress (iface.GetLocal
       ()));
1042       RoutingTableEntry rt (\textcolor{comment}{/*device=*/} dev, \textcolor{comment}{/*dst=*/} iface.GetBroadcast (),\textcolor{comment}{/*seqno=*/} 0, \textcolor{comment}{/*iface=*/} iface,\textcolor{comment}{
      /*hops=*/} 0,
1043                                         \textcolor{comment}{/*next hop=*/} iface.GetBroadcast (), \textcolor{comment}{/*lifetime=*/} 
      \hyperlink{classns3_1_1Simulator_aa8dbab888dca7bf3528421d2c5e67f99}{Simulator::GetMaximumSimulationTime} ());
1044       \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a4eed9bac83e90f1db01e414892e10b9b}{AddRoute} (rt);
1045     \}
1046 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 20


\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Notify\+Interface\+Down@{Notify\+Interface\+Down}}
\index{Notify\+Interface\+Down@{Notify\+Interface\+Down}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Notify\+Interface\+Down(uint32\+\_\+t interface)}{NotifyInterfaceDown(uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Notify\+Interface\+Down (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a4c9154c20c88647918a2c0e144be6b4f}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a4c9154c20c88647918a2c0e144be6b4f}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified of the state change of an interface in a node. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a90f728b73ccb1806e5a4093ff156f607}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
998 \{
999   Ptr<Ipv4L3Protocol> l3 = \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetObject<Ipv4L3Protocol> ();
1000   Ptr<NetDevice> dev = l3->GetNetDevice (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
1001   Ptr<Socket> socket = \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_ab87d72bcdb89e0ff1034912db8868c01}{FindSocketWithInterfaceAddress} (
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i},0));
1002   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (socket);
1003   socket->Close ();
1004   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9f3be507604655079b145f063cf036fd}{m\_socketAddresses}.erase (socket);
1005   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9f3be507604655079b145f063cf036fd}{m\_socketAddresses}.empty ())
1006     \{
1007       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"No dsdv interfaces"});
1008       \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a4b082df912185628706b93ddbe1eeefb}{Clear} ();
1009       \textcolor{keywordflow}{return};
1010     \}
1011   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a910728601836ce9beb169b6a4e489cf1}{DeleteAllRoutesFromInterface} (
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i},0));
1012   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a910728601836ce9beb169b6a4e489cf1}{DeleteAllRoutesFromInterface} (
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i},0));
1013 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 21


\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Notify\+Interface\+Up@{Notify\+Interface\+Up}}
\index{Notify\+Interface\+Up@{Notify\+Interface\+Up}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Notify\+Interface\+Up(uint32\+\_\+t interface)}{NotifyInterfaceUp(uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Notify\+Interface\+Up (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a9a3edd95b3a0714d5aff5293e96883d2}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a9a3edd95b3a0714d5aff5293e96883d2}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified of the state change of an interface in a node. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_aabb99ce7a048e75ff4b36fa9af8745e4}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
966 \{
967   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, 0).GetLocal ()
968                         << \textcolor{stringliteral}{" interface is up"});
969   Ptr<Ipv4L3Protocol> l3 = \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetObject<Ipv4L3Protocol> ();
970   Ipv4InterfaceAddress iface = l3->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i},0);
971   \textcolor{keywordflow}{if} (iface.GetLocal () == Ipv4Address (\textcolor{stringliteral}{"127.0.0.1"}))
972     \{
973       \textcolor{keywordflow}{return};
974     \}
975   \textcolor{comment}{// Create a socket to listen only on this interface}
976   Ptr<Socket> socket = \hyperlink{classns3_1_1Socket_ad448a62bb50ad3dbac59c879a885a8d2}{Socket::CreateSocket} (GetObject<Node> (),
      \hyperlink{classns3_1_1UdpSocketFactory_ad5b47e944de8861e3dc2b6de1ccbdf5b}{UdpSocketFactory::GetTypeId} ());
977   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (socket != 0);
978   socket->SetRecvCallback (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_ad27475d64bfd478b57d73f3cc08d4c99}{RoutingProtocol::RecvDsdv},\textcolor{keyword}{
      this}));
979   socket->Bind (InetSocketAddress (\hyperlink{classns3_1_1Ipv4Address_a7a39b330c8e701183a411d5779fca1a4}{Ipv4Address::GetAny} (), 
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a14b063286a3c34efb9537f6456af3271}{DSDV\_PORT}));
980   socket->BindToNetDevice (l3->GetNetDevice (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}));
981   socket->SetAllowBroadcast (\textcolor{keyword}{true});
982   socket->SetAttribute (\textcolor{stringliteral}{"IpTtl"},UintegerValue (1));
983   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9f3be507604655079b145f063cf036fd}{m\_socketAddresses}.insert (std::make\_pair (socket,iface));
984   \textcolor{comment}{// Add local broadcast record to the routing table}
985   Ptr<NetDevice> dev = \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetNetDevice (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetInterfaceForAddress (iface.GetLocal ())
      );
986   RoutingTableEntry rt (\textcolor{comment}{/*device=*/} dev, \textcolor{comment}{/*dst=*/} iface.GetBroadcast (), \textcolor{comment}{/*seqno=*/} 0,\textcolor{comment}{/*iface=*/} iface,\textcolor{comment}{/*
      hops=*/} 0,
987                                     \textcolor{comment}{/*next hop=*/} iface.GetBroadcast (), \textcolor{comment}{/*lifetime=*/} 
      \hyperlink{classns3_1_1Simulator_aa8dbab888dca7bf3528421d2c5e67f99}{Simulator::GetMaximumSimulationTime} ());
988   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a4eed9bac83e90f1db01e414892e10b9b}{AddRoute} (rt);
989   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_af7cb076b88eb5ff20a1c146e3f5849f6}{m\_mainAddress} == Ipv4Address ())
990     \{
991       \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_af7cb076b88eb5ff20a1c146e3f5849f6}{m\_mainAddress} = iface.GetLocal ();
992     \}
993   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_af7cb076b88eb5ff20a1c146e3f5849f6}{m\_mainAddress} != Ipv4Address ());
994 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 22


\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Notify\+Remove\+Address@{Notify\+Remove\+Address}}
\index{Notify\+Remove\+Address@{Notify\+Remove\+Address}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Notify\+Remove\+Address(uint32\+\_\+t interface, Ipv4\+Interface\+Address address)}{NotifyRemoveAddress(uint32_t interface, Ipv4InterfaceAddress address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Notify\+Remove\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv4\+Interface\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a27292ecea0925d440a272b57f1b96aab}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a27292ecea0925d440a272b57f1b96aab}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
{\em address} & a new address being added to an interface\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified whenever a new address is removed from an interface. Typically used to remove the \textquotesingle{}network route\textquotesingle{} of an interface. Can be invoked on an up or down interface. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a0160e49e509d6699ec837e5485f65cd2}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
1051 \{
1052   Ptr<Socket> socket = \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_ab87d72bcdb89e0ff1034912db8868c01}{FindSocketWithInterfaceAddress} (address);
1053   \textcolor{keywordflow}{if} (socket)
1054     \{
1055       \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9f3be507604655079b145f063cf036fd}{m\_socketAddresses}.erase (socket);
1056       Ptr<Ipv4L3Protocol> l3 = \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetObject<Ipv4L3Protocol> ();
1057       \textcolor{keywordflow}{if} (l3->GetNAddresses (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}))
1058         \{
1059           Ipv4InterfaceAddress iface = l3->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i},0);
1060           \textcolor{comment}{// Create a socket to listen only on this interface}
1061           Ptr<Socket> socket = \hyperlink{classns3_1_1Socket_ad448a62bb50ad3dbac59c879a885a8d2}{Socket::CreateSocket} (GetObject<Node> (),
      \hyperlink{classns3_1_1UdpSocketFactory_ad5b47e944de8861e3dc2b6de1ccbdf5b}{UdpSocketFactory::GetTypeId} ());
1062           \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (socket != 0);
1063           socket->SetRecvCallback (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_ad27475d64bfd478b57d73f3cc08d4c99}{RoutingProtocol::RecvDsdv},\textcolor{keyword}{this}));
1064           \textcolor{comment}{// Bind to any IP address so that broadcasts can be received}
1065           socket->Bind (InetSocketAddress (\hyperlink{classns3_1_1Ipv4Address_a7a39b330c8e701183a411d5779fca1a4}{Ipv4Address::GetAny} (), 
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a14b063286a3c34efb9537f6456af3271}{DSDV\_PORT}));
1066           socket->SetAllowBroadcast (\textcolor{keyword}{true});
1067           \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9f3be507604655079b145f063cf036fd}{m\_socketAddresses}.insert (std::make\_pair (socket,iface));
1068         \}
1069     \}
1070 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 23


\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Print\+Routing\+Table@{Print\+Routing\+Table}}
\index{Print\+Routing\+Table@{Print\+Routing\+Table}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Print\+Routing\+Table(\+Ptr$<$ Output\+Stream\+Wrapper $>$ stream, Time\+::\+Unit unit=\+Time\+::\+S) const }{PrintRoutingTable(Ptr< OutputStreamWrapper > stream, Time::Unit unit=Time::S) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Print\+Routing\+Table (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream, }
\item[{{\bf Time\+::\+Unit}}]{unit = {\ttfamily {\bf Time\+::S}}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_ac13b00f0a73404bebf2a6fccfea987d9}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_ac13b00f0a73404bebf2a6fccfea987d9}


Print the Routing Table entries. 


\begin{DoxyParams}{Parameters}
{\em stream} & The ostream the Routing table is printed to \\
\hline
{\em unit} & The time unit to be used in the report \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a86ad3fc1d17b06b6553a13b03d7e8cb4}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
233 \{
234   *stream->\hyperlink{classns3_1_1OutputStreamWrapper_a0cf30a4188ab6fdae2b2ab74db11acc2}{GetStream} () << \textcolor{stringliteral}{"Node: "} << \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetObject<Node> ()->GetId ()
235                         << \textcolor{stringliteral}{", Time: "} << \hyperlink{group__simulator_gac3635e2e87f7ce316c89290ee1b01d0d}{Now}().\hyperlink{classns3_1_1Time_a0bb1110638ce9938248bd07865a328ab}{As} (unit)
236                         << \textcolor{stringliteral}{", Local time: "} << GetObject<Node> ()->GetLocalTime ().As (unit)
237                         << \textcolor{stringliteral}{", DSDV Routing table"} << std::endl;
238 
239   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a12577457ac58fcc4ab12b44f26955878}{Print} (stream);
240   *stream->\hyperlink{classns3_1_1OutputStreamWrapper_a0cf30a4188ab6fdae2b2ab74db11acc2}{GetStream} () << std::endl;
241 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 24


\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Recv\+Dsdv@{Recv\+Dsdv}}
\index{Recv\+Dsdv@{Recv\+Dsdv}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Recv\+Dsdv(\+Ptr$<$ Socket $>$ socket)}{RecvDsdv(Ptr< Socket > socket)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Recv\+Dsdv (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Socket} $>$}]{socket}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_ad27475d64bfd478b57d73f3cc08d4c99}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_ad27475d64bfd478b57d73f3cc08d4c99}


Receive and process dsdv control packet. 


\begin{DoxyCode}
549 \{
550   Address sourceAddress;
551   Ptr<Packet> advpacket = Create<Packet> ();
552   Ptr<Packet> packet = socket->\hyperlink{classns3_1_1Socket_af22378d7af9a2745a9eada20210da215}{RecvFrom} (sourceAddress);
553   InetSocketAddress inetSourceAddr = \hyperlink{classns3_1_1InetSocketAddress_ade776b1109e7b9a7be0b22ced49931e3}{InetSocketAddress::ConvertFrom} (
      sourceAddress);
554   Ipv4Address sender = inetSourceAddr.GetIpv4 ();
555   Ipv4Address receiver = \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9f3be507604655079b145f063cf036fd}{m\_socketAddresses}[socket].GetLocal ();
556   Ptr<NetDevice> dev = \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetNetDevice (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetInterfaceForAddress (receiver));
557   uint32\_t packetSize = packet->GetSize ();
558   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_af7cb076b88eb5ff20a1c146e3f5849f6}{m\_mainAddress} << \textcolor{stringliteral}{" received dsdv packet of size: "} << 
      packetSize
559                                  << \textcolor{stringliteral}{" and packet id: "} << packet->GetUid ());
560   uint32\_t count = 0;
561   \textcolor{keywordflow}{for} (; packetSize > 0; packetSize = packetSize - 12)
562     \{
563       count = 0;
564       DsdvHeader dsdvHeader, tempDsdvHeader;
565       packet->RemoveHeader (dsdvHeader);
566       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Processing new update for "} << dsdvHeader.GetDst ());
567       \textcolor{comment}{/*Verifying if the packets sent by me were returned back to me. If yes, discarding them!*/}
568       \textcolor{keywordflow}{for} (std::map<Ptr<Socket>, Ipv4InterfaceAddress>::const\_iterator j = 
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9f3be507604655079b145f063cf036fd}{m\_socketAddresses}.begin (); j
569            != \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9f3be507604655079b145f063cf036fd}{m\_socketAddresses}.end (); ++j)
570         \{
571           Ipv4InterfaceAddress \textcolor{keyword}{interface }= j->second;
572           \textcolor{keywordflow}{if} (dsdvHeader.GetDst () == interface.GetLocal ())
573             \{
574               \textcolor{keywordflow}{if} (dsdvHeader.GetDstSeqno () % 2 == 1)
575                 \{
576                   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Sent Dsdv update back to the same Destination, "}
577                                 \textcolor{stringliteral}{"with infinite metric. Time left to send fwd update: "}
578                                 << \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a851fbb5569e6681fd1c42f47d2a79ee8}{m\_periodicUpdateTimer}.
      \hyperlink{classns3_1_1Timer_a0dc288dd3de21a524d088fc8a5a14a73}{GetDelayLeft} ());
579                   count++;
580                 \}
581               \textcolor{keywordflow}{else}
582                 \{
583                   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Received update for my address. Discarding this."});
584                   count++;
585                 \}
586             \}
587         \}
588       \textcolor{keywordflow}{if} (count > 0)
589         \{
590           \textcolor{keywordflow}{continue};
591         \}
592       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Received a DSDV packet from "}
593                     << sender << \textcolor{stringliteral}{" to "} << receiver << \textcolor{stringliteral}{". Details are: Destination: "} << dsdvHeader.GetDst 
      () << \textcolor{stringliteral}{", Seq No: "}
594                     << dsdvHeader.GetDstSeqno () << \textcolor{stringliteral}{", HopCount: "} << dsdvHeader.GetHopCount ());
595       RoutingTableEntry fwdTableEntry, advTableEntry;
596       EventId event;
597       \textcolor{keywordtype}{bool} permanentTableVerifier = \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a0bfb9dc677f02bd740973865e38df763}{LookupRoute} (dsdvHeader.GetDst 
      (),fwdTableEntry);
598       \textcolor{keywordflow}{if} (permanentTableVerifier == \textcolor{keyword}{false})
599         \{
600           \textcolor{keywordflow}{if} (dsdvHeader.GetDstSeqno () % 2 != 1)
601             \{
602               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Received New Route!"});
603               RoutingTableEntry newEntry (
604                 \textcolor{comment}{/*device=*/} dev, \textcolor{comment}{/*dst=*/}
605                 dsdvHeader.GetDst (), \textcolor{comment}{/*seqno=*/}
606                 dsdvHeader.GetDstSeqno (),
607                 \textcolor{comment}{/*iface=*/} \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetAddress (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetInterfaceForAddress (receiver), 0),
608                 \textcolor{comment}{/*hops=*/} dsdvHeader.GetHopCount (), \textcolor{comment}{/*next hop=*/}
609                 sender, \textcolor{comment}{/*lifetime=*/}
610                 \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} (), \textcolor{comment}{/*settlingTime*/}
611                 \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_ac00a3214f64eddbab1fbf039aa293ae9}{m\_settlingTime}, \textcolor{comment}{/*entries changed*/}
612                 \textcolor{keyword}{true});
613               newEntry.SetFlag (\hyperlink{namespacens3_1_1dsdv_aa1c39555b993cc6f56f2c8c6c31e2c3baf2cbf3d202d1c7338230c662e6822e65}{VALID});
614               \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a4eed9bac83e90f1db01e414892e10b9b}{AddRoute} (newEntry);
615               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"New Route added to both tables"});
616               \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a4eed9bac83e90f1db01e414892e10b9b}{AddRoute} (newEntry);
617             \}
618           \textcolor{keywordflow}{else}
619             \{
620               \textcolor{comment}{// received update not present in main routing table and also with infinite metric}
621               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Discarding this update as this route is not present in "}
622                             \textcolor{stringliteral}{"main routing table and received with infinite metric"});
623             \}
624         \}
625       \textcolor{keywordflow}{else}
626         \{
627           \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a0bfb9dc677f02bd740973865e38df763}{LookupRoute} (dsdvHeader.GetDst (),
      advTableEntry))
628             \{
629               RoutingTableEntry tr;
630               std::map<Ipv4Address, RoutingTableEntry> allRoutes;
631               \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_af980697df819d8a00ee8782c705e3dac}{GetListOfAllRoutes} (allRoutes);
632               \textcolor{keywordflow}{for} (std::map<Ipv4Address, RoutingTableEntry>::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = allRoutes.begin (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != allRoutes.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
633                 \{
634                   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"ADV table routes are:"} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second.GetDestination ());
635                 \}
636               \textcolor{comment}{// present in fwd table and not in advtable}
637               \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a4eed9bac83e90f1db01e414892e10b9b}{AddRoute} (fwdTableEntry);
638               \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a0bfb9dc677f02bd740973865e38df763}{LookupRoute} (dsdvHeader.GetDst (),advTableEntry
      );
639             \}
640           \textcolor{keywordflow}{if} (dsdvHeader.GetDstSeqno () % 2 != 1)
641             \{
642               \textcolor{keywordflow}{if} (dsdvHeader.GetDstSeqno () > advTableEntry.GetSeqNo ())
643                 \{
644                   \textcolor{comment}{// Received update with better seq number. Clear any old events that are running}
645                   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a39f4b7725caafbc6cd9f7c5821470d51}{ForceDeleteIpv4Event} (
      dsdvHeader.GetDst ()))
646                     \{
647                       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Canceling the timer to update route with better seq number
      "});
648                     \}
649                   \textcolor{comment}{// if its a changed metric *nomatter* where the update came from, wait  for WST}
650                   \textcolor{keywordflow}{if} (dsdvHeader.GetHopCount () != advTableEntry.GetHop ())
651                     \{
652                       advTableEntry.SetSeqNo (dsdvHeader.GetDstSeqno ());
653                       advTableEntry.SetLifeTime (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ());
654                       advTableEntry.SetFlag (\hyperlink{namespacens3_1_1dsdv_aa1c39555b993cc6f56f2c8c6c31e2c3baf2cbf3d202d1c7338230c662e6822e65}{VALID});
655                       advTableEntry.SetEntriesChanged (\textcolor{keyword}{true});
656                       advTableEntry.SetNextHop (sender);
657                       advTableEntry.SetHop (dsdvHeader.GetHopCount ());
658                       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Received update with better sequence number and changed
       metric.Waiting for WST"});
659                       \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} tempSettlingtime = \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a83244927636fd12b775ebdbe0b334e68}{GetSettlingTime} (dsdvHeader.GetDst ());
660                       advTableEntry.SetSettlingTime (tempSettlingtime);
661                       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Added Settling Time:"} << tempSettlingtime.GetSeconds ()
662                                                            << \textcolor{stringliteral}{"s as there is no event running for this
       route"});
663                       \textcolor{keyword}{event} = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (tempSettlingtime,&
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adc414310ddaa5e69520a176c0dac59cc}{RoutingProtocol::SendTriggeredUpdate},\textcolor{keyword}{this});
664                       \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_aa9757950491f7aba7c1db83b2d62df67}{AddIpv4Event} (dsdvHeader.GetDst (),
      event);
665                       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"EventCreated EventUID: "} << event.GetUid ());
666                       \textcolor{comment}{// if received changed metric, use it but adv it only after wst}
667                       \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a651762730975f809c720313b1332cb99}{Update} (advTableEntry);
668                       \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a651762730975f809c720313b1332cb99}{Update} (advTableEntry);
669                     \}
670                   \textcolor{keywordflow}{else}
671                     \{
672                       \textcolor{comment}{// Received update with better seq number and same metric.}
673                       advTableEntry.SetSeqNo (dsdvHeader.GetDstSeqno ());
674                       advTableEntry.SetLifeTime (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ());
675                       advTableEntry.SetFlag (\hyperlink{namespacens3_1_1dsdv_aa1c39555b993cc6f56f2c8c6c31e2c3baf2cbf3d202d1c7338230c662e6822e65}{VALID});
676                       advTableEntry.SetEntriesChanged (\textcolor{keyword}{true});
677                       advTableEntry.SetNextHop (sender);
678                       advTableEntry.SetHop (dsdvHeader.GetHopCount ());
679                       \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a651762730975f809c720313b1332cb99}{Update} (advTableEntry);
680                       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Route with better sequence number and same metric
       received. Advertised without WST"});
681                     \}
682                 \}
683               \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (dsdvHeader.GetDstSeqno () == advTableEntry.GetSeqNo ())
684                 \{
685                   \textcolor{keywordflow}{if} (dsdvHeader.GetHopCount () < advTableEntry.GetHop ())
686                     \{
687                       \textcolor{comment}{/*Received update with same seq number and better hop count.}
688 \textcolor{comment}{                       * As the metric is changed, we will have to wait for WST before sending out this
       update.}
689 \textcolor{comment}{                       */}
690                       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Canceling any existing timer to update route with same
       sequence number "}
691                                     \textcolor{stringliteral}{"and better hop count"});
692                       \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a39f4b7725caafbc6cd9f7c5821470d51}{ForceDeleteIpv4Event} (
      dsdvHeader.GetDst ());
693                       advTableEntry.SetSeqNo (dsdvHeader.GetDstSeqno ());
694                       advTableEntry.SetLifeTime (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ());
695                       advTableEntry.SetFlag (\hyperlink{namespacens3_1_1dsdv_aa1c39555b993cc6f56f2c8c6c31e2c3baf2cbf3d202d1c7338230c662e6822e65}{VALID});
696                       advTableEntry.SetEntriesChanged (\textcolor{keyword}{true});
697                       advTableEntry.SetNextHop (sender);
698                       advTableEntry.SetHop (dsdvHeader.GetHopCount ());
699                       \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} tempSettlingtime = \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a83244927636fd12b775ebdbe0b334e68}{GetSettlingTime} (dsdvHeader.GetDst ());
700                       advTableEntry.SetSettlingTime (tempSettlingtime);
701                       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Added Settling Time,"} << tempSettlingtime.GetSeconds ()
702                                                            << \textcolor{stringliteral}{" as there is no current event running for
       this route"});
703                       \textcolor{keyword}{event} = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (tempSettlingtime,&
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adc414310ddaa5e69520a176c0dac59cc}{RoutingProtocol::SendTriggeredUpdate},\textcolor{keyword}{this});
704                       \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_aa9757950491f7aba7c1db83b2d62df67}{AddIpv4Event} (dsdvHeader.GetDst (),
      event);
705                       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"EventCreated EventUID: "} << event.GetUid ());
706                       \textcolor{comment}{// if received changed metric, use it but adv it only after wst}
707                       \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a651762730975f809c720313b1332cb99}{Update} (advTableEntry);
708                       \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a651762730975f809c720313b1332cb99}{Update} (advTableEntry);
709                     \}
710                   \textcolor{keywordflow}{else}
711                     \{
712                       \textcolor{comment}{/*Received update with same seq number but with same or greater hop count.}
713 \textcolor{comment}{                       * Discard that update.}
714 \textcolor{comment}{                       */}
715                       \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_acb9f117332351347f8345d4591991e6b}{AnyRunningEvent} (dsdvHeader.
      GetDst ()))
716                         \{
717                           \textcolor{comment}{/*update the timer only if nexthop address matches thus discarding}
718 \textcolor{comment}{                           * updates to that destination from other nodes.}
719 \textcolor{comment}{                           */}
720                           \textcolor{keywordflow}{if} (advTableEntry.GetNextHop () == sender)
721                             \{
722                               advTableEntry.SetLifeTime (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ());
723                               \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a651762730975f809c720313b1332cb99}{Update} (advTableEntry);
724                             \}
725                           \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a384f271a1393c513c4ae7ba4476c3e08}{DeleteRoute} (
726                             dsdvHeader.GetDst ());
727                         \}
728                       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Received update with same seq number and "}
729                                     \textcolor{stringliteral}{"same/worst metric for, "} << dsdvHeader.GetDst () << \textcolor{stringliteral}{". Discarding the
       update."});
730                     \}
731                 \}
732               \textcolor{keywordflow}{else}
733                 \{
734                   \textcolor{comment}{// Received update with an old sequence number. Discard the update}
735                   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_acb9f117332351347f8345d4591991e6b}{AnyRunningEvent} (dsdvHeader.GetDst
       ()))
736                     \{
737                       \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a384f271a1393c513c4ae7ba4476c3e08}{DeleteRoute} (dsdvHeader.GetDst ());
738                     \}
739                   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (dsdvHeader.GetDst () << \textcolor{stringliteral}{" : Received update with old seq
       number. Discarding the update."});
740                 \}
741             \}
742           \textcolor{keywordflow}{else}
743             \{
744               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Route with infinite metric received for "}
745                             << dsdvHeader.GetDst () << \textcolor{stringliteral}{" from "} << sender);
746               \textcolor{comment}{// Delete route only if update was received from my nexthop neighbor}
747               \textcolor{keywordflow}{if} (sender == advTableEntry.GetNextHop ())
748                 \{
749                   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Triggering an update for this unreachable route:"});
750                   std::map<Ipv4Address, RoutingTableEntry> dstsWithNextHopSrc;
751                   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a7efb980be4e4f556b73905038483c154}{GetListOfDestinationWithNextHop}
       (dsdvHeader.GetDst (),dstsWithNextHopSrc);
752                   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a384f271a1393c513c4ae7ba4476c3e08}{DeleteRoute} (dsdvHeader.GetDst ());
753                   advTableEntry.SetSeqNo (dsdvHeader.GetDstSeqno ());
754                   advTableEntry.SetEntriesChanged (\textcolor{keyword}{true});
755                   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a651762730975f809c720313b1332cb99}{Update} (advTableEntry);
756                   \textcolor{keywordflow}{for} (std::map<Ipv4Address, RoutingTableEntry>::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = dstsWithNextHopSrc.begin ();
       \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}
757                        != dstsWithNextHopSrc.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
758                     \{
759                       \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second.SetSeqNo (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second.GetSeqNo () + 1);
760                       \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second.SetEntriesChanged (\textcolor{keyword}{true});
761                       \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a4eed9bac83e90f1db01e414892e10b9b}{AddRoute} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second);
762                       \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a384f271a1393c513c4ae7ba4476c3e08}{DeleteRoute} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second.GetDestination ());
763                     \}
764                 \}
765               \textcolor{keywordflow}{else}
766                 \{
767                   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_acb9f117332351347f8345d4591991e6b}{AnyRunningEvent} (dsdvHeader.GetDst
       ()))
768                     \{
769                       \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a384f271a1393c513c4ae7ba4476c3e08}{DeleteRoute} (dsdvHeader.GetDst ());
770                     \}
771                   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (dsdvHeader.GetDst () <<
772                                 \textcolor{stringliteral}{" : Discard this link break update as it was received from a different
       neighbor "}
773                                 \textcolor{stringliteral}{"and I can reach the destination"});
774                 \}
775             \}
776         \}
777     \}
778   std::map<Ipv4Address, RoutingTableEntry> allRoutes;
779   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_af980697df819d8a00ee8782c705e3dac}{GetListOfAllRoutes} (allRoutes);
780   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a91fada0798359d72bfaf88bf33b1e62d}{EnableRouteAggregation} && allRoutes.size () > 0)
781     \{
782       \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a8d7bef939cd3872c1821fc4bce884f8d}{m\_routeAggregationTime},&
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adc414310ddaa5e69520a176c0dac59cc}{RoutingProtocol::SendTriggeredUpdate},\textcolor{keyword}{this});
783     \}
784   \textcolor{keywordflow}{else}
785     \{
786       \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{group__timecivil_ga17465a639c8d1464e76538afdd78a9f0}{MicroSeconds} (
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a2d5efde0680b47457d0b94d0493c9eec}{m\_uniformRandomVariable}->\hyperlink{classns3_1_1RandomVariableStream_a66cd94e6305ce7f000f1a9ff0fcb9aef}{GetInteger} (0,1000)),&
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adc414310ddaa5e69520a176c0dac59cc}{RoutingProtocol::SendTriggeredUpdate},\textcolor{keyword}{this});
787     \}
788 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 25




Here is the caller graph for this function\+:
% FIG 26


\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Route\+Input@{Route\+Input}}
\index{Route\+Input@{Route\+Input}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Route\+Input(\+Ptr$<$ const Packet $>$ p, const Ipv4\+Header \&header, Ptr$<$ const Net\+Device $>$ idev, Unicast\+Forward\+Callback ucb, Multicast\+Forward\+Callback mcb, Local\+Deliver\+Callback lcb, Error\+Callback ecb)}{RouteInput(Ptr< const Packet > p, const Ipv4Header &header, Ptr< const NetDevice > idev, UnicastForwardCallback ucb, MulticastForwardCallback mcb, LocalDeliverCallback lcb, ErrorCallback ecb)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Route\+Input (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv4\+Header} \&}]{header, }
\item[{{\bf Ptr}$<$ const {\bf Net\+Device} $>$}]{idev, }
\item[{{\bf Unicast\+Forward\+Callback}}]{ucb, }
\item[{{\bf Multicast\+Forward\+Callback}}]{mcb, }
\item[{{\bf Local\+Deliver\+Callback}}]{lcb, }
\item[{{\bf Error\+Callback}}]{ecb}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_af4cf2f9bed3afc8be2ccbb3a07d703b4}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_af4cf2f9bed3afc8be2ccbb3a07d703b4}

\begin{DoxyCode}
373 \{
374   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_af7cb076b88eb5ff20a1c146e3f5849f6}{m\_mainAddress} << \textcolor{stringliteral}{" received packet "} << 
      \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->GetUid ()
375                                  << \textcolor{stringliteral}{" from "} << header.GetSource ()
376                                  << \textcolor{stringliteral}{" on interface "} << idev->GetAddress ()
377                                  << \textcolor{stringliteral}{" to destination "} << header.GetDestination ());
378   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9f3be507604655079b145f063cf036fd}{m\_socketAddresses}.empty ())
379     \{
380       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"No dsdv interfaces"});
381       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
382     \}
383   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4} != 0);
384   \textcolor{comment}{// Check if input device supports IP}
385   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetInterfaceForDevice (idev) >= 0);
386   int32\_t iif = \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetInterfaceForDevice (idev);
387 
388   Ipv4Address dst = header.GetDestination ();
389   Ipv4Address origin = header.GetSource ();
390 
391   \textcolor{comment}{// DSDV is not a multicast routing protocol}
392   \textcolor{keywordflow}{if} (dst.IsMulticast ())
393     \{
394       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
395     \}
396 
397   \textcolor{comment}{// Deferred route request}
398   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a257bf2eb6e7eff700d12f00f2d9ec0e3}{EnableBuffering} == \textcolor{keyword}{true} && idev == \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a793deb930065a91d037ed2930e756528}{m\_lo})
399     \{
400       DeferredRouteOutputTag tag;
401       \textcolor{keywordflow}{if} (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->PeekPacketTag (tag))
402         \{
403           \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a69ada1af49e7f09f91199062e14fb75f}{DeferredRouteOutput} (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p},header,ucb,ecb);
404           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
405         \}
406     \}
407   \textcolor{keywordflow}{for} (std::map<Ptr<Socket>, Ipv4InterfaceAddress>::const\_iterator j =
408          \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9f3be507604655079b145f063cf036fd}{m\_socketAddresses}.begin (); j != \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9f3be507604655079b145f063cf036fd}{m\_socketAddresses}.end (); ++j)
409     \{
410       Ipv4InterfaceAddress iface = j->second;
411       \textcolor{keywordflow}{if} (origin == iface.GetLocal ())
412         \{
413           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
414         \}
415     \}
416   \textcolor{comment}{// LOCAL DELIVARY TO DSDV INTERFACES}
417   \textcolor{keywordflow}{for} (std::map<Ptr<Socket>, Ipv4InterfaceAddress>::const\_iterator j = 
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9f3be507604655079b145f063cf036fd}{m\_socketAddresses}.begin (); j
418        != \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9f3be507604655079b145f063cf036fd}{m\_socketAddresses}.end (); ++j)
419     \{
420       Ipv4InterfaceAddress iface = j->second;
421       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetInterfaceForAddress (iface.GetLocal ()) == iif)
422         \{
423           \textcolor{keywordflow}{if} (dst == iface.GetBroadcast () || dst.IsBroadcast ())
424             \{
425               Ptr<Packet> packet = \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->Copy ();
426               \textcolor{keywordflow}{if} (lcb.IsNull () == \textcolor{keyword}{false})
427                 \{
428                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Broadcast local delivery to "} << iface.GetLocal ());
429                   lcb (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header, iif);
430                   \textcolor{comment}{// Fall through to additional processing}
431                 \}
432               \textcolor{keywordflow}{else}
433                 \{
434                   \hyperlink{group__logging_ga0261a8db1d4ac5f79417d117634fd455}{NS\_LOG\_ERROR} (\textcolor{stringliteral}{"Unable to deliver packet locally due to null callback "} << 
      \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->GetUid () << \textcolor{stringliteral}{" from "} << origin);
435                   ecb (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{Socket::ERROR\_NOROUTETOHOST});
436                 \}
437               \textcolor{keywordflow}{if} (header.GetTtl () > 1)
438                 \{
439                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Forward broadcast. TTL "} << (uint16\_t) header.GetTtl ());
440                   RoutingTableEntry toBroadcast;
441                   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a0bfb9dc677f02bd740973865e38df763}{LookupRoute} (dst,toBroadcast,\textcolor{keyword}{true}))
442                     \{
443                       Ptr<Ipv4Route> route = toBroadcast.GetRoute ();
444                       ucb (route,packet,header);
445                     \}
446                   \textcolor{keywordflow}{else}
447                     \{
448                       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"No route to forward. Drop packet "} << 
      \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->GetUid ());
449                     \}
450                 \}
451               \textcolor{keywordflow}{return} \textcolor{keyword}{true};
452             \}
453         \}
454     \}
455 
456   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->IsDestinationAddress (dst, iif))
457     \{
458       \textcolor{keywordflow}{if} (lcb.IsNull () == \textcolor{keyword}{false})
459         \{
460           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Unicast local delivery to "} << dst);
461           lcb (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header, iif);
462         \}
463       \textcolor{keywordflow}{else}
464         \{
465           \hyperlink{group__logging_ga0261a8db1d4ac5f79417d117634fd455}{NS\_LOG\_ERROR} (\textcolor{stringliteral}{"Unable to deliver packet locally due to null callback "} << 
      \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->GetUid () << \textcolor{stringliteral}{" from "} << origin);
466           ecb (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{Socket::ERROR\_NOROUTETOHOST});
467         \}
468       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
469     \}
470 
471   \textcolor{comment}{// Check if input device supports IP forwarding}
472   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->IsForwarding (iif) == \textcolor{keyword}{false})
473     \{
474       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Forwarding disabled for this interface"});
475       ecb (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{Socket::ERROR\_NOROUTETOHOST});
476       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
477     \}
478 
479   RoutingTableEntry toDst;
480   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a0bfb9dc677f02bd740973865e38df763}{LookupRoute} (dst,toDst))
481     \{
482       RoutingTableEntry ne;
483       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a0bfb9dc677f02bd740973865e38df763}{LookupRoute} (toDst.GetNextHop (),ne))
484         \{
485           Ptr<Ipv4Route> route = ne.GetRoute ();
486           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_af7cb076b88eb5ff20a1c146e3f5849f6}{m\_mainAddress} << \textcolor{stringliteral}{" is forwarding packet "} << 
      \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->GetUid ()
487                                       << \textcolor{stringliteral}{" to "} << dst
488                                       << \textcolor{stringliteral}{" from "} << header.GetSource ()
489                                       << \textcolor{stringliteral}{" via nexthop neighbor "} << toDst.GetNextHop ());
490           ucb (route,\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p},header);
491           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
492         \}
493     \}
494   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Drop packet "} << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->GetUid ()
495                                << \textcolor{stringliteral}{" as there is no route to forward it."});
496   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
497 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 27


\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Route\+Output@{Route\+Output}}
\index{Route\+Output@{Route\+Output}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Route\+Output(\+Ptr$<$ Packet $>$ p, const Ipv4\+Header \&header, Ptr$<$ Net\+Device $>$ oif, Socket\+::\+Socket\+Errno \&sockerr)}{RouteOutput(Ptr< Packet > p, const Ipv4Header &header, Ptr< NetDevice > oif, Socket::SocketErrno &sockerr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv4\+Route} $>$ ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Route\+Output (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv4\+Header} \&}]{header, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{oif, }
\item[{{\bf Socket\+::\+Socket\+Errno} \&}]{sockerr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_af025a37dfb12829be3a1f484c5c926c0}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_af025a37dfb12829be3a1f484c5c926c0}


Query routing cache for an existing route, for an outbound packet. 

This lookup is used by transport protocols. It does not cause any packet to be forwarded, and is synchronous. Can be used for multicast or unicast. The Linux equivalent is ip\+\_\+route\+\_\+output()

The header input parameter may have an uninitialized value for the source address, but the destination address should always be properly set by the caller.


\begin{DoxyParams}{Parameters}
{\em p} & packet to be routed. Note that this method may modify the packet. Callers may also pass in a null pointer. \\
\hline
{\em header} & input parameter (used to form key to search for the route) \\
\hline
{\em oif} & Output interface Netdevice. May be zero, or may be bound via socket options to a particular output interface. \\
\hline
{\em sockerr} & Output parameter; socket errno\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a code that indicates what happened in the lookup 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a9c0e9b77772a4974c06ee4577fe60547}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
262 \{
263   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << header << (oif ? oif->GetIfIndex () : 0));
264 
265   \textcolor{keywordflow}{if} (!p)
266     \{
267       \textcolor{keywordflow}{return} \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_aadc3f2072721211ad452bcbe49762420}{LoopbackRoute} (header,oif);
268     \}
269   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9f3be507604655079b145f063cf036fd}{m\_socketAddresses}.empty ())
270     \{
271       sockerr = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{Socket::ERROR\_NOROUTETOHOST};
272       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"No dsdv interfaces"});
273       Ptr<Ipv4Route> route;
274       \textcolor{keywordflow}{return} route;
275     \}
276   std::map<Ipv4Address, RoutingTableEntry> removedAddresses;
277   sockerr = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaaa7eb006d73c5ad0117c5591fcb3469f7}{Socket::ERROR\_NOTERROR};
278   Ptr<Ipv4Route> route;
279   Ipv4Address dst = header.GetDestination ();
280   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Packet Size: "} << p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ()
281                                 << \textcolor{stringliteral}{", Packet id: "} << p->\hyperlink{classns3_1_1Packet_a1f212c825b50e54d94f5b9ae99592e6a}{GetUid} () << \textcolor{stringliteral}{", Destination address in
       Packet: "} << dst);
282   RoutingTableEntry rt;
283   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_ad4e2b213772381511453c5ec8c968e68}{Purge} (removedAddresses);
284   \textcolor{keywordflow}{for} (std::map<Ipv4Address, RoutingTableEntry>::iterator rmItr = removedAddresses.begin ();
285        rmItr != removedAddresses.end (); ++rmItr)
286     \{
287       rmItr->second.SetEntriesChanged (\textcolor{keyword}{true});
288       rmItr->second.SetSeqNo (rmItr->second.GetSeqNo () + 1);
289       \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a4eed9bac83e90f1db01e414892e10b9b}{AddRoute} (rmItr->second);
290     \}
291   \textcolor{keywordflow}{if} (!removedAddresses.empty ())
292     \{
293       \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{group__timecivil_ga17465a639c8d1464e76538afdd78a9f0}{MicroSeconds} (
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a2d5efde0680b47457d0b94d0493c9eec}{m\_uniformRandomVariable}->\hyperlink{classns3_1_1RandomVariableStream_a66cd94e6305ce7f000f1a9ff0fcb9aef}{GetInteger} (0,1000)),&
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adc414310ddaa5e69520a176c0dac59cc}{RoutingProtocol::SendTriggeredUpdate},\textcolor{keyword}{this});
294     \}
295   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a0bfb9dc677f02bd740973865e38df763}{LookupRoute} (dst,rt))
296     \{
297       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a257bf2eb6e7eff700d12f00f2d9ec0e3}{EnableBuffering})
298         \{
299           \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a775bb168f6e8c4feb854aba73326681e}{LookForQueuedPackets} ();
300         \}
301       \textcolor{keywordflow}{if} (rt.GetHop () == 1)
302         \{
303           route = rt.GetRoute ();
304           \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (route != 0);
305           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"A route exists from "} << route->GetSource ()
306                                                << \textcolor{stringliteral}{" to neighboring destination "}
307                                                << route->GetDestination ());
308           \textcolor{keywordflow}{if} (oif != 0 && route->GetOutputDevice () != oif)
309             \{
310               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Output device doesn't match. Dropped."});
311               sockerr = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{Socket::ERROR\_NOROUTETOHOST};
312               \textcolor{keywordflow}{return} Ptr<Ipv4Route> ();
313             \}
314           \textcolor{keywordflow}{return} route;
315         \}
316       \textcolor{keywordflow}{else}
317         \{
318           RoutingTableEntry newrt;
319           \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a0bfb9dc677f02bd740973865e38df763}{LookupRoute} (rt.GetNextHop (),newrt))
320             \{
321               route = newrt.GetRoute ();
322               \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (route != 0);
323               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"A route exists from "} << route->GetSource ()
324                                                    << \textcolor{stringliteral}{" to destination "} << dst << \textcolor{stringliteral}{" via "}
325                                                    << rt.GetNextHop ());
326               \textcolor{keywordflow}{if} (oif != 0 && route->GetOutputDevice () != oif)
327                 \{
328                   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Output device doesn't match. Dropped."});
329                   sockerr = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{Socket::ERROR\_NOROUTETOHOST};
330                   \textcolor{keywordflow}{return} Ptr<Ipv4Route> ();
331                 \}
332               \textcolor{keywordflow}{return} route;
333             \}
334         \}
335     \}
336 
337   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a257bf2eb6e7eff700d12f00f2d9ec0e3}{EnableBuffering})
338     \{
339       uint32\_t iif = (oif ? \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetInterfaceForDevice (oif) : -1);
340       DeferredRouteOutputTag tag (iif);
341       \textcolor{keywordflow}{if} (!p->\hyperlink{classns3_1_1Packet_a1734de11f2ca1e78a7872461a0625168}{PeekPacketTag} (tag))
342         \{
343           p->\hyperlink{classns3_1_1Packet_a7400b8655852f5271c5957250d0141af}{AddPacketTag} (tag);
344         \}
345     \}
346   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_aadc3f2072721211ad452bcbe49762420}{LoopbackRoute} (header,oif);
347 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 28


\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Send@{Send}}
\index{Send@{Send}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Send(\+Ptr$<$ Ipv4\+Route $>$, Ptr$<$ const Packet $>$, const Ipv4\+Header \&)}{Send(Ptr< Ipv4Route >, Ptr< const Packet >, const Ipv4Header &)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Send (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv4\+Route} $>$}]{route, }
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{packet, }
\item[{const {\bf Ipv4\+Header} \&}]{header}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a7b4ba195edb9521642be588fb4f0576e}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a7b4ba195edb9521642be588fb4f0576e}

\begin{DoxyCode}
1093 \{
1094   Ptr<Ipv4L3Protocol> l3 = \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetObject<Ipv4L3Protocol> ();
1095   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (l3 != 0);
1096   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = packet->Copy ();
1097   l3->Send (p,route->GetSource (),header.GetDestination (),header.GetProtocol (),route);
1098 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 29




Here is the caller graph for this function\+:
% FIG 30


\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Send\+Packet\+From\+Queue@{Send\+Packet\+From\+Queue}}
\index{Send\+Packet\+From\+Queue@{Send\+Packet\+From\+Queue}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Packet\+From\+Queue(\+Ipv4\+Address dst, Ptr$<$ Ipv4\+Route $>$ route)}{SendPacketFromQueue(Ipv4Address dst, Ptr< Ipv4Route > route)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Send\+Packet\+From\+Queue (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{dst, }
\item[{{\bf Ptr}$<$ {\bf Ipv4\+Route} $>$}]{route}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a9359912928dc5b8dc851366a78c0cc8c}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a9359912928dc5b8dc851366a78c0cc8c}
Send packet from queue 
\begin{DoxyParams}{Parameters}
{\em dst} & -\/ destination address to which we are sending the packet to \\
\hline
{\em route} & -\/ route identified for this packet \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1148 \{
1149   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_af7cb076b88eb5ff20a1c146e3f5849f6}{m\_mainAddress} << \textcolor{stringliteral}{" is sending a queued packet to destination "} << 
      dst);
1150   QueueEntry queueEntry;
1151   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a3ed623ade7d7244ed1ff5e0f6a399a68}{m\_queue}.\hyperlink{classns3_1_1dsdv_1_1PacketQueue_a3eea5dcab62c438f2eb7d48e33869284}{Dequeue} (dst,queueEntry))
1152     \{
1153       DeferredRouteOutputTag tag;
1154       Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = ConstCast<Packet> (queueEntry.GetPacket ());
1155       \textcolor{keywordflow}{if} (p->RemovePacketTag (tag))
1156         \{
1157           \textcolor{keywordflow}{if} (tag.oif != -1 && tag.oif != \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetInterfaceForDevice (route->GetOutputDevice ()))
1158             \{
1159               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Output device doesn't match. Dropped."});
1160               \textcolor{keywordflow}{return};
1161             \}
1162         \}
1163       \hyperlink{classns3_1_1Ipv4RoutingProtocol_a3453a85764cbbb1e704da7e919aa5d19}{UnicastForwardCallback} ucb = queueEntry.GetUnicastForwardCallback ();
1164       Ipv4Header header = queueEntry.GetIpv4Header ();
1165       header.SetSource (route->GetSource ());
1166       header.SetTtl (header.GetTtl () + 1); \textcolor{comment}{// compensate extra TTL decrement by fake loopback routing}
1167       ucb (route,p,header);
1168       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a3ed623ade7d7244ed1ff5e0f6a399a68}{m\_queue}.\hyperlink{classns3_1_1dsdv_1_1PacketQueue_a750099896a013a01a1c1093db34808bb}{GetSize} () != 0 && \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a3ed623ade7d7244ed1ff5e0f6a399a68}{m\_queue}.\hyperlink{classns3_1_1dsdv_1_1PacketQueue_a13a16f813e0f9a67b2ab4ee3b1f10c70}{Find} (dst))
1169         \{
1170           \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a2d5efde0680b47457d0b94d0493c9eec}{m\_uniformRandomVariable}->\hyperlink{classns3_1_1RandomVariableStream_a66cd94e6305ce7f000f1a9ff0fcb9aef}{GetInteger} (0,100)),
1171                                &\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9359912928dc5b8dc851366a78c0cc8c}{RoutingProtocol::SendPacketFromQueue},\textcolor{keyword}{
      this},dst,route);
1172         \}
1173     \}
1174 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 31




Here is the caller graph for this function\+:
% FIG 32


\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Send\+Periodic\+Update@{Send\+Periodic\+Update}}
\index{Send\+Periodic\+Update@{Send\+Periodic\+Update}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Periodic\+Update()}{SendPeriodicUpdate()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Send\+Periodic\+Update (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a370e3ca262a505ec0fd30456f82b2aed}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a370e3ca262a505ec0fd30456f82b2aed}


Broadcasts the entire routing table for every Periodic\+Update\+Interval. 


\begin{DoxyCode}
867 \{
868   std::map<Ipv4Address, RoutingTableEntry> removedAddresses, allRoutes;
869   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_ad4e2b213772381511453c5ec8c968e68}{Purge} (removedAddresses);
870   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_afcf1903d16fb9d303805fbe07986bb06}{MergeTriggerPeriodicUpdates} ();
871   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_af980697df819d8a00ee8782c705e3dac}{GetListOfAllRoutes} (allRoutes);
872   \textcolor{keywordflow}{if} (allRoutes.empty ())
873     \{
874       \textcolor{keywordflow}{return};
875     \}
876   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_af7cb076b88eb5ff20a1c146e3f5849f6}{m\_mainAddress} << \textcolor{stringliteral}{" is sending out its periodic update"});
877   \textcolor{keywordflow}{for} (std::map<Ptr<Socket>, Ipv4InterfaceAddress>::const\_iterator j = 
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9f3be507604655079b145f063cf036fd}{m\_socketAddresses}.begin (); j
878        != \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9f3be507604655079b145f063cf036fd}{m\_socketAddresses}.end (); ++j)
879     \{
880       Ptr<Socket> socket = j->first;
881       Ipv4InterfaceAddress iface = j->second;
882       Ptr<Packet> packet = Create<Packet> ();
883       \textcolor{keywordflow}{for} (std::map<Ipv4Address, RoutingTableEntry>::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = allRoutes.begin (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != allRoutes.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
884         \{
885           DsdvHeader dsdvHeader;
886           \textcolor{keywordflow}{if} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second.GetHop () == 0)
887             \{
888               RoutingTableEntry ownEntry;
889               dsdvHeader.SetDst (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetAddress (1,0).GetLocal ());
890               dsdvHeader.SetDstSeqno (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second.GetSeqNo () + 2);
891               dsdvHeader.SetHopCount (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second.GetHop () + 1);
892               \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a0bfb9dc677f02bd740973865e38df763}{LookupRoute} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetAddress (1,0).
      GetBroadcast (),ownEntry);
893               ownEntry.SetSeqNo (dsdvHeader.GetDstSeqno ());
894               \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a651762730975f809c720313b1332cb99}{Update} (ownEntry);
895               packet->AddHeader (dsdvHeader);
896             \}
897           \textcolor{keywordflow}{else}
898             \{
899               dsdvHeader.SetDst (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second.GetDestination ());
900               dsdvHeader.SetDstSeqno ((\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second.GetSeqNo ()));
901               dsdvHeader.SetHopCount (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second.GetHop () + 1);
902               packet->AddHeader (dsdvHeader);
903             \}
904           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Forwarding the update for "} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->first);
905           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Forwarding details are, Destination: "} << dsdvHeader.GetDst ()
906                                                                 << \textcolor{stringliteral}{", SeqNo:"} << dsdvHeader.GetDstSeqno ()
907                                                                 << \textcolor{stringliteral}{", HopCount:"} << dsdvHeader.GetHopCount 
      ()
908                                                                 << \textcolor{stringliteral}{", LifeTime: "} << 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second.GetLifeTime ().GetSeconds ());
909         \}
910       \textcolor{keywordflow}{for} (std::map<Ipv4Address, RoutingTableEntry>::const\_iterator rmItr = removedAddresses.begin (); 
      rmItr
911            != removedAddresses.end (); ++rmItr)
912         \{
913           DsdvHeader removedHeader;
914           removedHeader.SetDst (rmItr->second.GetDestination ());
915           removedHeader.SetDstSeqno (rmItr->second.GetSeqNo () + 1);
916           removedHeader.SetHopCount (rmItr->second.GetHop () + 1);
917           packet->AddHeader (removedHeader);
918           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Update for removed record is: Destination: "} << removedHeader.GetDst (
      )
919                                                                       << \textcolor{stringliteral}{" SeqNo:"} << removedHeader.
      GetDstSeqno ()
920                                                                       << \textcolor{stringliteral}{" HopCount:"} << removedHeader.
      GetHopCount ());
921         \}
922       socket->Send (packet);
923       \textcolor{comment}{// Send to all-hosts broadcast if on /32 addr, subnet-directed otherwise}
924       Ipv4Address destination;
925       \textcolor{keywordflow}{if} (iface.GetMask () == \hyperlink{classns3_1_1Ipv4Mask_af712cbdf28c039025d4aa45fa7e243dd}{Ipv4Mask::GetOnes} ())
926         \{
927           destination = Ipv4Address (\textcolor{stringliteral}{"255.255.255.255"});
928         \}
929       \textcolor{keywordflow}{else}
930         \{
931           destination = iface.GetBroadcast ();
932         \}
933       socket->SendTo (packet, 0, InetSocketAddress (destination, \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a14b063286a3c34efb9537f6456af3271}{DSDV\_PORT}));
934       \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{stringliteral}{"PeriodicUpdate Packet UID is : "} << packet->GetUid ());
935     \}
936   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a851fbb5569e6681fd1c42f47d2a79ee8}{m\_periodicUpdateTimer}.\hyperlink{classns3_1_1Timer_ac3345d696887578f518b19f359f7f94b}{Schedule} (
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a1951a29aaca9beebdff3abd5c7d00ef0}{m\_periodicUpdateInterval} + \hyperlink{group__timecivil_ga17465a639c8d1464e76538afdd78a9f0}{MicroSeconds} (25 * 
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a2d5efde0680b47457d0b94d0493c9eec}{m\_uniformRandomVariable}->\hyperlink{classns3_1_1RandomVariableStream_a66cd94e6305ce7f000f1a9ff0fcb9aef}{GetInteger} (0,1000)));
937 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 33




Here is the caller graph for this function\+:
% FIG 34


\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Send\+Triggered\+Update@{Send\+Triggered\+Update}}
\index{Send\+Triggered\+Update@{Send\+Triggered\+Update}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Triggered\+Update()}{SendTriggeredUpdate()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Send\+Triggered\+Update (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_adc414310ddaa5e69520a176c0dac59cc}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_adc414310ddaa5e69520a176c0dac59cc}


Sends trigger update from a node. 


\begin{DoxyCode}
793 \{
794   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_af7cb076b88eb5ff20a1c146e3f5849f6}{m\_mainAddress} << \textcolor{stringliteral}{" is sending a triggered update"});
795   std::map<Ipv4Address, RoutingTableEntry> allRoutes;
796   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_af980697df819d8a00ee8782c705e3dac}{GetListOfAllRoutes} (allRoutes);
797   \textcolor{keywordflow}{for} (std::map<Ptr<Socket>, Ipv4InterfaceAddress>::const\_iterator j = 
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9f3be507604655079b145f063cf036fd}{m\_socketAddresses}.begin (); j
798        != \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a9f3be507604655079b145f063cf036fd}{m\_socketAddresses}.end (); ++j)
799     \{
800       DsdvHeader dsdvHeader;
801       Ptr<Socket> socket = j->first;
802       Ipv4InterfaceAddress iface = j->second;
803       Ptr<Packet> packet = Create<Packet> ();
804       \textcolor{keywordflow}{for} (std::map<Ipv4Address, RoutingTableEntry>::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = allRoutes.begin (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != allRoutes.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
805         \{
806           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Destination: "} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second.GetDestination ()
807                                         << \textcolor{stringliteral}{" SeqNo:"} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second.GetSeqNo () << \textcolor{stringliteral}{" HopCount:"}
808                                         << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second.GetHop () + 1);
809           RoutingTableEntry temp = \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second;
810           \textcolor{keywordflow}{if} ((\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second.GetEntriesChanged () == \textcolor{keyword}{true}) && (!\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.
      \hyperlink{classns3_1_1dsdv_1_1RoutingTable_acb9f117332351347f8345d4591991e6b}{AnyRunningEvent} (temp.GetDestination ())))
811             \{
812               dsdvHeader.SetDst (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second.GetDestination ());
813               dsdvHeader.SetDstSeqno (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second.GetSeqNo ());
814               dsdvHeader.SetHopCount (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second.GetHop () + 1);
815               temp.SetFlag (\hyperlink{namespacens3_1_1dsdv_aa1c39555b993cc6f56f2c8c6c31e2c3baf2cbf3d202d1c7338230c662e6822e65}{VALID});
816               temp.SetEntriesChanged (\textcolor{keyword}{false});
817               \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a64caf377cd234d84f77215885d8b1967}{DeleteIpv4Event} (temp.GetDestination ());
818               \textcolor{keywordflow}{if} (!(temp.GetSeqNo () % 2))
819                 \{
820                   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a651762730975f809c720313b1332cb99}{Update} (temp);
821                 \}
822               packet->AddHeader (dsdvHeader);
823               \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a384f271a1393c513c4ae7ba4476c3e08}{DeleteRoute} (temp.GetDestination ());
824               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Deleted this route from the advertised table"});
825             \}
826           \textcolor{keywordflow}{else}
827             \{
828               EventId \textcolor{keyword}{event} = \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_aa7d334052c89ba061285d2a207a12cfe}{GetEventId} (temp.GetDestination 
      ());
829               \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (event.GetUid () != 0);
830               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"EventID "} << event.GetUid () << \textcolor{stringliteral}{" associated with "}
831                                        << temp.GetDestination () << \textcolor{stringliteral}{" has not expired, waiting in adv table
      "});
832             \}
833         \}
834       \textcolor{keywordflow}{if} (packet->GetSize () >= 12)
835         \{
836           RoutingTableEntry temp2;
837           \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a0bfb9dc677f02bd740973865e38df763}{LookupRoute} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetAddress (1, 0).GetBroadcast
       (), temp2);
838           dsdvHeader.SetDst (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetAddress (1, 0).GetLocal ());
839           dsdvHeader.SetDstSeqno (temp2.GetSeqNo ());
840           dsdvHeader.SetHopCount (temp2.GetHop () + 1);
841           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Adding my update as well to the packet"});
842           packet->AddHeader (dsdvHeader);
843           \textcolor{comment}{// Send to all-hosts broadcast if on /32 addr, subnet-directed otherwise}
844           Ipv4Address destination;
845           \textcolor{keywordflow}{if} (iface.GetMask () == \hyperlink{classns3_1_1Ipv4Mask_af712cbdf28c039025d4aa45fa7e243dd}{Ipv4Mask::GetOnes} ())
846             \{
847               destination = Ipv4Address (\textcolor{stringliteral}{"255.255.255.255"});
848             \}
849           \textcolor{keywordflow}{else}
850             \{
851               destination = iface.GetBroadcast ();
852             \}
853           socket->SendTo (packet, 0, InetSocketAddress (destination, \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a14b063286a3c34efb9537f6456af3271}{DSDV\_PORT}));
854           \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{stringliteral}{"Sent Triggered Update from "}
855                            << dsdvHeader.GetDst ()
856                            << \textcolor{stringliteral}{" with packet id : "} << packet->GetUid () << \textcolor{stringliteral}{" and packet Size: "} << packet->
      GetSize ());
857         \}
858       \textcolor{keywordflow}{else}
859         \{
860           \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{stringliteral}{"Update not sent as there are no updates to be triggered"});
861         \}
862     \}
863 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 35




Here is the caller graph for this function\+:
% FIG 36


\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Set\+Enable\+Buffer\+Flag@{Set\+Enable\+Buffer\+Flag}}
\index{Set\+Enable\+Buffer\+Flag@{Set\+Enable\+Buffer\+Flag}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Enable\+Buffer\+Flag(bool f)}{SetEnableBufferFlag(bool f)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Set\+Enable\+Buffer\+Flag (
\begin{DoxyParamCaption}
\item[{bool}]{f}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a4a3de094f750c655b3119a0111184b67}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a4a3de094f750c655b3119a0111184b67}

\begin{DoxyCode}
168 \{
169   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a257bf2eb6e7eff700d12f00f2d9ec0e3}{EnableBuffering} = \hyperlink{buildings__pathloss_8m_aa52d3a6e3de5a80a97c12364caeaa125}{f};
170 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 37


\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Set\+Enable\+R\+A\+Flag@{Set\+Enable\+R\+A\+Flag}}
\index{Set\+Enable\+R\+A\+Flag@{Set\+Enable\+R\+A\+Flag}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Enable\+R\+A\+Flag(bool f)}{SetEnableRAFlag(bool f)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Set\+Enable\+R\+A\+Flag (
\begin{DoxyParamCaption}
\item[{bool}]{f}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a2c0b24d0c86af1c4d3d58cc0bea5c201}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a2c0b24d0c86af1c4d3d58cc0bea5c201}

\begin{DoxyCode}
188 \{
189   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a91fada0798359d72bfaf88bf33b1e62d}{EnableRouteAggregation} = \hyperlink{buildings__pathloss_8m_aa52d3a6e3de5a80a97c12364caeaa125}{f};
190 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 38


\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Set\+Ipv4@{Set\+Ipv4}}
\index{Set\+Ipv4@{Set\+Ipv4}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Ipv4(\+Ptr$<$ Ipv4 $>$ ipv4)}{SetIpv4(Ptr< Ipv4 > ipv4)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Set\+Ipv4 (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv4} $>$}]{ipv4}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_aab88c62fbd0567cf31d185cb58b23a44}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_aab88c62fbd0567cf31d185cb58b23a44}

\begin{DoxyParams}{Parameters}
{\em ipv4} & the ipv4 object this routing protocol is being associated with\\
\hline
\end{DoxyParams}
Typically, invoked directly or indirectly from \hyperlink{classns3_1_1Ipv4_a2d165c3bafd4ca580f02a03536db80d3}{ns3\+::\+Ipv4\+::\+Set\+Routing\+Protocol} 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_af3947a05b912ea3f2a1ef0e9777f723e}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
941 \{
942   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (ipv4 != 0);
943   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4} == 0);
944   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4} = ipv4;
945   \textcolor{comment}{// Create lo route. It is asserted that the only one interface up for now is loopback}
946   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetNInterfaces () == 1 && \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetAddress (0, 0).GetLocal () =
      = Ipv4Address (\textcolor{stringliteral}{"127.0.0.1"}));
947   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a793deb930065a91d037ed2930e756528}{m\_lo} = \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{m\_ipv4}->GetNetDevice (0);
948   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (m\_lo != 0);
949   \textcolor{comment}{// Remember lo route}
950   RoutingTableEntry rt (
951     \textcolor{comment}{/*device=*/} m\_lo,  \textcolor{comment}{/*dst=*/}
952     \hyperlink{classns3_1_1Ipv4Address_a583a93499e0d947439794d7bd0c6366d}{Ipv4Address::GetLoopback} (), \textcolor{comment}{/*seqno=*/}
953     0,
954     \textcolor{comment}{/*iface=*/} Ipv4InterfaceAddress (\hyperlink{classns3_1_1Ipv4Address_a583a93499e0d947439794d7bd0c6366d}{Ipv4Address::GetLoopback} (),Ipv4Mask (\textcolor{stringliteral}{"
      255.0.0.0"})),
955     \textcolor{comment}{/*hops=*/} 0,  \textcolor{comment}{/*next hop=*/}
956     \hyperlink{classns3_1_1Ipv4Address_a583a93499e0d947439794d7bd0c6366d}{Ipv4Address::GetLoopback} (),
957     \textcolor{comment}{/*lifetime=*/} \hyperlink{classns3_1_1Simulator_aa8dbab888dca7bf3528421d2c5e67f99}{Simulator::GetMaximumSimulationTime} ());
958   rt.SetFlag (\hyperlink{namespacens3_1_1dsdv_aa1c39555b993cc6f56f2c8c6c31e2c3ba2dbd3930b34b55bfe8d1a3617eabb9de}{INVALID});
959   rt.SetEntriesChanged (\textcolor{keyword}{false});
960   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a4eed9bac83e90f1db01e414892e10b9b}{AddRoute} (rt);
961   \hyperlink{classns3_1_1Simulator_a2219ee02c0647adc83d1c918c3256266}{Simulator::ScheduleNow} (&\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a1e6145b4ecb927243c4758012036c45a}{RoutingProtocol::Start},\textcolor{keyword}{this});
962 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 39


\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Set\+W\+S\+T\+Flag@{Set\+W\+S\+T\+Flag}}
\index{Set\+W\+S\+T\+Flag@{Set\+W\+S\+T\+Flag}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+W\+S\+T\+Flag(bool f)}{SetWSTFlag(bool f)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Set\+W\+S\+T\+Flag (
\begin{DoxyParamCaption}
\item[{bool}]{f}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a7dc8bc0bba2c84dc1e50613d2f84f124}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a7dc8bc0bba2c84dc1e50613d2f84f124}

\begin{DoxyCode}
178 \{
179   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_abf3b9f8c78278e4d2faf177146359d19}{EnableWST} = \hyperlink{buildings__pathloss_8m_aa52d3a6e3de5a80a97c12364caeaa125}{f};
180 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 40


\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Start@{Start}}
\index{Start@{Start}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Start()}{Start()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Start (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a1e6145b4ecb927243c4758012036c45a}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a1e6145b4ecb927243c4758012036c45a}


Start protocol operation. 


\begin{DoxyCode}
245 \{
246   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a3ed623ade7d7244ed1ff5e0f6a399a68}{m\_queue}.\hyperlink{classns3_1_1dsdv_1_1PacketQueue_a431b04e4c8babfd1b87b4a522ec4df52}{SetMaxPacketsPerDst} (
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a2bfab14f96b69300b5b86aeaca2b6f64}{m\_maxQueuedPacketsPerDst});
247   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a3ed623ade7d7244ed1ff5e0f6a399a68}{m\_queue}.\hyperlink{classns3_1_1dsdv_1_1PacketQueue_ae85d6e3fc35f328c409e36085bd00a89}{SetMaxQueueLen} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_aedf19d36f43f8c0bed80d22b2eec343c}{m\_maxQueueLen});
248   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a3ed623ade7d7244ed1ff5e0f6a399a68}{m\_queue}.\hyperlink{classns3_1_1dsdv_1_1PacketQueue_a3810ab4e1688dc7ea8fe09675b1fd603}{SetQueueTimeout} (\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a99d9a7c27e476c4f0a2c93f889ab8e13}{m\_maxQueueTime});
249   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{m\_routingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a5243e09b9ec6fe4e5fc8f9f362830a46}{Setholddowntime} (\hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acdadd6be395f15827ec7c8531797b6e0}{Holdtimes} * \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a1951a29aaca9beebdff3abd5c7d00ef0}{m\_periodicUpdateInterval}));
250   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{m\_advRoutingTable}.\hyperlink{classns3_1_1dsdv_1_1RoutingTable_a5243e09b9ec6fe4e5fc8f9f362830a46}{Setholddowntime} (\hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_acdadd6be395f15827ec7c8531797b6e0}{Holdtimes} * m\_periodicUpdateInterval));
251   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a2ffc78a04da837daca7d5012373ef905}{m\_scb} = \hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a7b4ba195edb9521642be588fb4f0576e}{RoutingProtocol::Send},\textcolor{keyword}{this});
252   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a99588cc0468d174969bd6a66670286ee}{m\_ecb} = \hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&\hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_ac761f05ae1c90cc3a4a7b9a6e540132e}{RoutingProtocol::Drop},\textcolor{keyword}{this});
253   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a851fbb5569e6681fd1c42f47d2a79ee8}{m\_periodicUpdateTimer}.\hyperlink{classns3_1_1Timer_a044b29030c9de99298d51ac0ccfc104c}{SetFunction} (&
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a370e3ca262a505ec0fd30456f82b2aed}{RoutingProtocol::SendPeriodicUpdate},\textcolor{keyword}{this});
254   \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a851fbb5569e6681fd1c42f47d2a79ee8}{m\_periodicUpdateTimer}.\hyperlink{classns3_1_1Timer_ac3345d696887578f518b19f359f7f94b}{Schedule} (\hyperlink{group__timecivil_ga17465a639c8d1464e76538afdd78a9f0}{MicroSeconds} (
      \hyperlink{classns3_1_1dsdv_1_1RoutingProtocol_a2d5efde0680b47457d0b94d0493c9eec}{m\_uniformRandomVariable}->\hyperlink{classns3_1_1RandomVariableStream_a66cd94e6305ce7f000f1a9ff0fcb9aef}{GetInteger} (0,1000)));
255 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 41




Here is the caller graph for this function\+:
% FIG 42




\subsection{Member Data Documentation}
\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!D\+S\+D\+V\+\_\+\+P\+O\+RT@{D\+S\+D\+V\+\_\+\+P\+O\+RT}}
\index{D\+S\+D\+V\+\_\+\+P\+O\+RT@{D\+S\+D\+V\+\_\+\+P\+O\+RT}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{D\+S\+D\+V\+\_\+\+P\+O\+RT}{DSDV_PORT}}]{\setlength{\rightskip}{0pt plus 5cm}const uint32\+\_\+t ns3\+::dsdv\+::\+Routing\+Protocol\+::\+D\+S\+D\+V\+\_\+\+P\+O\+RT = 269\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a14b063286a3c34efb9537f6456af3271}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a14b063286a3c34efb9537f6456af3271}


U\+DP Port for D\+S\+DV control traffic. 

\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Enable\+Buffering@{Enable\+Buffering}}
\index{Enable\+Buffering@{Enable\+Buffering}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Enable\+Buffering}{EnableBuffering}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Enable\+Buffering\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a257bf2eb6e7eff700d12f00f2d9ec0e3}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a257bf2eb6e7eff700d12f00f2d9ec0e3}


Flag that is used to enable or disable buffering. 

\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Enable\+Route\+Aggregation@{Enable\+Route\+Aggregation}}
\index{Enable\+Route\+Aggregation@{Enable\+Route\+Aggregation}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Enable\+Route\+Aggregation}{EnableRouteAggregation}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Enable\+Route\+Aggregation\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a91fada0798359d72bfaf88bf33b1e62d}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a91fada0798359d72bfaf88bf33b1e62d}
This is a flag to enable route aggregation. Route aggregation will aggregate all routes for \textquotesingle{}Route\+Aggregation\+Time\textquotesingle{} from the time an update is received by a node and sends them as a single update . \index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Enable\+W\+ST@{Enable\+W\+ST}}
\index{Enable\+W\+ST@{Enable\+W\+ST}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Enable\+W\+ST}{EnableWST}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Enable\+W\+ST\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_abf3b9f8c78278e4d2faf177146359d19}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_abf3b9f8c78278e4d2faf177146359d19}


Flag that is used to enable or disable Weighted Settling \hyperlink{classns3_1_1Time}{Time}. 

\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!Holdtimes@{Holdtimes}}
\index{Holdtimes@{Holdtimes}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Holdtimes}{Holdtimes}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::dsdv\+::\+Routing\+Protocol\+::\+Holdtimes\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_acdadd6be395f15827ec7c8531797b6e0}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_acdadd6be395f15827ec7c8531797b6e0}
Holdtimes is the multiplicative factor of Periodic\+Update\+Interval for which the node waits since the last update before flushing a route from the routing table. If Periodic\+Update\+Interval is 8s and Holdtimes is 3, the node waits for 24s since the last update to flush this route from its routing table. \index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!m\+\_\+adv\+Routing\+Table@{m\+\_\+adv\+Routing\+Table}}
\index{m\+\_\+adv\+Routing\+Table@{m\+\_\+adv\+Routing\+Table}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+adv\+Routing\+Table}{m_advRoutingTable}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Routing\+Table} ns3\+::dsdv\+::\+Routing\+Protocol\+::m\+\_\+adv\+Routing\+Table\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_adce3cf63777d6099e58caa1cb198282c}


Advertised Routing table for the node. 

\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!m\+\_\+ecb@{m\+\_\+ecb}}
\index{m\+\_\+ecb@{m\+\_\+ecb}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+ecb}{m_ecb}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Callback} ns3\+::dsdv\+::\+Routing\+Protocol\+::m\+\_\+ecb\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a99588cc0468d174969bd6a66670286ee}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a99588cc0468d174969bd6a66670286ee}


Error callback for own packets. 

\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!m\+\_\+ipv4@{m\+\_\+ipv4}}
\index{m\+\_\+ipv4@{m\+\_\+ipv4}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+ipv4}{m_ipv4}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Ipv4}$>$ ns3\+::dsdv\+::\+Routing\+Protocol\+::m\+\_\+ipv4\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a955477c7f38e64762a264c24e3762af6}


IP protocol. 

\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!m\+\_\+lo@{m\+\_\+lo}}
\index{m\+\_\+lo@{m\+\_\+lo}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+lo}{m_lo}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Net\+Device}$>$ ns3\+::dsdv\+::\+Routing\+Protocol\+::m\+\_\+lo\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a793deb930065a91d037ed2930e756528}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a793deb930065a91d037ed2930e756528}


Loopback device used to defer route requests until a route is found. 

\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!m\+\_\+main\+Address@{m\+\_\+main\+Address}}
\index{m\+\_\+main\+Address@{m\+\_\+main\+Address}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+main\+Address}{m_mainAddress}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Address} ns3\+::dsdv\+::\+Routing\+Protocol\+::m\+\_\+main\+Address\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_af7cb076b88eb5ff20a1c146e3f5849f6}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_af7cb076b88eb5ff20a1c146e3f5849f6}


Nodes IP address. 

\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!m\+\_\+max\+Queued\+Packets\+Per\+Dst@{m\+\_\+max\+Queued\+Packets\+Per\+Dst}}
\index{m\+\_\+max\+Queued\+Packets\+Per\+Dst@{m\+\_\+max\+Queued\+Packets\+Per\+Dst}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Queued\+Packets\+Per\+Dst}{m_maxQueuedPacketsPerDst}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::dsdv\+::\+Routing\+Protocol\+::m\+\_\+max\+Queued\+Packets\+Per\+Dst\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a2bfab14f96b69300b5b86aeaca2b6f64}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a2bfab14f96b69300b5b86aeaca2b6f64}


The maximum number of packets that we allow per destination to buffer. 

\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!m\+\_\+max\+Queue\+Len@{m\+\_\+max\+Queue\+Len}}
\index{m\+\_\+max\+Queue\+Len@{m\+\_\+max\+Queue\+Len}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Queue\+Len}{m_maxQueueLen}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::dsdv\+::\+Routing\+Protocol\+::m\+\_\+max\+Queue\+Len\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_aedf19d36f43f8c0bed80d22b2eec343c}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_aedf19d36f43f8c0bed80d22b2eec343c}


The maximum number of packets that we allow a routing protocol to buffer. 

\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!m\+\_\+max\+Queue\+Time@{m\+\_\+max\+Queue\+Time}}
\index{m\+\_\+max\+Queue\+Time@{m\+\_\+max\+Queue\+Time}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Queue\+Time}{m_maxQueueTime}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::dsdv\+::\+Routing\+Protocol\+::m\+\_\+max\+Queue\+Time\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a99d9a7c27e476c4f0a2c93f889ab8e13}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a99d9a7c27e476c4f0a2c93f889ab8e13}


The maximum period of time that a routing protocol is allowed to buffer a packet for. 

\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!m\+\_\+periodic\+Update\+Interval@{m\+\_\+periodic\+Update\+Interval}}
\index{m\+\_\+periodic\+Update\+Interval@{m\+\_\+periodic\+Update\+Interval}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+periodic\+Update\+Interval}{m_periodicUpdateInterval}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::dsdv\+::\+Routing\+Protocol\+::m\+\_\+periodic\+Update\+Interval\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a1951a29aaca9beebdff3abd5c7d00ef0}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a1951a29aaca9beebdff3abd5c7d00ef0}
Periodic\+Update\+Interval specifies the periodic time interval between which the a node broadcasts its entire routing table. \index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!m\+\_\+periodic\+Update\+Timer@{m\+\_\+periodic\+Update\+Timer}}
\index{m\+\_\+periodic\+Update\+Timer@{m\+\_\+periodic\+Update\+Timer}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+periodic\+Update\+Timer}{m_periodicUpdateTimer}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Timer} ns3\+::dsdv\+::\+Routing\+Protocol\+::m\+\_\+periodic\+Update\+Timer\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a851fbb5569e6681fd1c42f47d2a79ee8}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a851fbb5569e6681fd1c42f47d2a79ee8}


\hyperlink{classns3_1_1Timer}{Timer} to trigger periodic updates from a node. 

\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!m\+\_\+queue@{m\+\_\+queue}}
\index{m\+\_\+queue@{m\+\_\+queue}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+queue}{m_queue}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Packet\+Queue} ns3\+::dsdv\+::\+Routing\+Protocol\+::m\+\_\+queue\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a3ed623ade7d7244ed1ff5e0f6a399a68}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a3ed623ade7d7244ed1ff5e0f6a399a68}


A \char`\"{}drop front on full\char`\"{} queue used by the routing layer to buffer packets to which it does not have a route. 

\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!m\+\_\+route\+Aggregation\+Time@{m\+\_\+route\+Aggregation\+Time}}
\index{m\+\_\+route\+Aggregation\+Time@{m\+\_\+route\+Aggregation\+Time}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+route\+Aggregation\+Time}{m_routeAggregationTime}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::dsdv\+::\+Routing\+Protocol\+::m\+\_\+route\+Aggregation\+Time\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a8d7bef939cd3872c1821fc4bce884f8d}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a8d7bef939cd3872c1821fc4bce884f8d}


Parameter that holds the route aggregation time interval. 

\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!m\+\_\+routing\+Table@{m\+\_\+routing\+Table}}
\index{m\+\_\+routing\+Table@{m\+\_\+routing\+Table}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+routing\+Table}{m_routingTable}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Routing\+Table} ns3\+::dsdv\+::\+Routing\+Protocol\+::m\+\_\+routing\+Table\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_acc4cee466c2591e35f508ce58097a00e}


Main Routing table for the node. 

\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!m\+\_\+scb@{m\+\_\+scb}}
\index{m\+\_\+scb@{m\+\_\+scb}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+scb}{m_scb}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Unicast\+Forward\+Callback} ns3\+::dsdv\+::\+Routing\+Protocol\+::m\+\_\+scb\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a2ffc78a04da837daca7d5012373ef905}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a2ffc78a04da837daca7d5012373ef905}


Unicast callback for own packets. 

\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!m\+\_\+settling\+Time@{m\+\_\+settling\+Time}}
\index{m\+\_\+settling\+Time@{m\+\_\+settling\+Time}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+settling\+Time}{m_settlingTime}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::dsdv\+::\+Routing\+Protocol\+::m\+\_\+settling\+Time\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_ac00a3214f64eddbab1fbf039aa293ae9}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_ac00a3214f64eddbab1fbf039aa293ae9}
Settling\+Time specifies the time for which a node waits before propagating an update. It waits for this time interval in hope of receiving an update with a better metric. \index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!m\+\_\+socket\+Addresses@{m\+\_\+socket\+Addresses}}
\index{m\+\_\+socket\+Addresses@{m\+\_\+socket\+Addresses}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+socket\+Addresses}{m_socketAddresses}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<${\bf Ptr}$<${\bf Socket}$>$, {\bf Ipv4\+Interface\+Address}$>$ ns3\+::dsdv\+::\+Routing\+Protocol\+::m\+\_\+socket\+Addresses\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a9f3be507604655079b145f063cf036fd}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a9f3be507604655079b145f063cf036fd}


Raw socket per each IP interface, map socket -\/$>$ iface address (IP + mask) 

\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!m\+\_\+triggered\+Expire\+Timer@{m\+\_\+triggered\+Expire\+Timer}}
\index{m\+\_\+triggered\+Expire\+Timer@{m\+\_\+triggered\+Expire\+Timer}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+triggered\+Expire\+Timer}{m_triggeredExpireTimer}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Timer} ns3\+::dsdv\+::\+Routing\+Protocol\+::m\+\_\+triggered\+Expire\+Timer\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a013fc28f0c7cd0e5a001165ec6c7c899}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a013fc28f0c7cd0e5a001165ec6c7c899}


\hyperlink{classns3_1_1Timer}{Timer} used by the trigger updates in case of Weighted Settling \hyperlink{classns3_1_1Time}{Time} is used. 

\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!m\+\_\+uniform\+Random\+Variable@{m\+\_\+uniform\+Random\+Variable}}
\index{m\+\_\+uniform\+Random\+Variable@{m\+\_\+uniform\+Random\+Variable}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+uniform\+Random\+Variable}{m_uniformRandomVariable}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Uniform\+Random\+Variable}$>$ ns3\+::dsdv\+::\+Routing\+Protocol\+::m\+\_\+uniform\+Random\+Variable\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_a2d5efde0680b47457d0b94d0493c9eec}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_a2d5efde0680b47457d0b94d0493c9eec}


Provides uniform random variables. 

\index{ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}!m\+\_\+weighted\+Factor@{m\+\_\+weighted\+Factor}}
\index{m\+\_\+weighted\+Factor@{m\+\_\+weighted\+Factor}!ns3\+::dsdv\+::\+Routing\+Protocol@{ns3\+::dsdv\+::\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+weighted\+Factor}{m_weightedFactor}}]{\setlength{\rightskip}{0pt plus 5cm}double ns3\+::dsdv\+::\+Routing\+Protocol\+::m\+\_\+weighted\+Factor\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsdv_1_1RoutingProtocol_afd15e37062d937b28ba081fc515f3a77}{}\label{classns3_1_1dsdv_1_1RoutingProtocol_afd15e37062d937b28ba081fc515f3a77}


This is the wighted factor to determine the weighted settling time. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
dsdv/model/\hyperlink{dsdv-routing-protocol_8h}{dsdv-\/routing-\/protocol.\+h}\item 
dsdv/model/\hyperlink{dsdv-routing-protocol_8cc}{dsdv-\/routing-\/protocol.\+cc}\end{DoxyCompactItemize}
