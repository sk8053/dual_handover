\hypertarget{classns3_1_1VsaManager}{}\section{ns3\+:\+:Vsa\+Manager Class Reference}
\label{classns3_1_1VsaManager}\index{ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}}


{\ttfamily \#include $<$vsa-\/manager.\+h$>$}



Inheritance diagram for ns3\+:\+:Vsa\+Manager\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Vsa\+Manager\+:
% FIG 1
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structns3_1_1VsaManager_1_1VsaWork}{Vsa\+Work}
\begin{DoxyCompactList}\small\item\em \hyperlink{structns3_1_1VsaManager_1_1VsaWork}{Vsa\+Work} structure. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1VsaManager_a283a4c9945639bb4fe32133024ee52bc}{Vsa\+Manager} (void)
\item 
virtual \hyperlink{classns3_1_1VsaManager_adb3a9a1ecbab2d9e4ac9ef318ce179a6}{$\sim$\+Vsa\+Manager} (void)
\item 
void \hyperlink{classns3_1_1VsaManager_a73647933b1d7efe2fd5c50d313aa11db}{Set\+Wave\+Net\+Device} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1WaveNetDevice}{Wave\+Net\+Device} $>$ device)
\item 
void \hyperlink{classns3_1_1VsaManager_a1d51c2011ec5e0ee0d3ea812b0ccd189}{Set\+Wave\+Vsa\+Callback} (\hyperlink{classns3_1_1Callback}{Callback}$<$ bool, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$, const \hyperlink{classns3_1_1Address}{Address} \&, uint32\+\_\+t, uint32\+\_\+t $>$ vsa\+Callback)
\begin{DoxyCompactList}\small\item\em set wave vsa callback function \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1VsaManager_af896634c89ed0725215aa5da43445295}{Send\+Vsa} (const \hyperlink{structns3_1_1VsaInfo}{Vsa\+Info} \&vsa\+Info)
\item 
void \hyperlink{classns3_1_1VsaManager_ac27455a3d1a998d8ddd69029cd9a73cf}{Remove\+All} (void)
\item 
void \hyperlink{classns3_1_1VsaManager_ad526912b634fd876c98b6d2695bea1e9}{Remove\+By\+Channel} (uint32\+\_\+t channel\+Number)
\item 
void \hyperlink{classns3_1_1VsaManager_ae158c6a30d3d971b6dae5ac58263dffa}{Remove\+By\+Organization\+Identifier} (const \hyperlink{classns3_1_1OrganizationIdentifier}{Organization\+Identifier} \&oi)
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1VsaManager_a9a6cfa45b3cf63f019a2eb868dcf365d}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classns3_1_1VsaManager_a36e46be212cd99de74d78ec1494f8476}{Do\+Dispose} (void)
\item 
void \hyperlink{classns3_1_1VsaManager_a05e003d4c898eda681aeb6c2a4339e2a}{Do\+Initialize} (void)
\item 
bool \hyperlink{classns3_1_1VsaManager_a5dd6b3883b8e57ed8cc7f7cc7afa5601}{Receive\+Vsc} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1WifiMac}{Wifi\+Mac} $>$ mac, const \hyperlink{classns3_1_1OrganizationIdentifier}{Organization\+Identifier} \&oi, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ vsc, const \hyperlink{classns3_1_1Address}{Address} \&src)
\item 
void \hyperlink{classns3_1_1VsaManager_a5731f78c47436e8cb495052b1fe42f65}{Do\+Repeat} (\hyperlink{structns3_1_1VsaManager_1_1VsaWork}{Vsa\+Work} $\ast$vsa)
\item 
void \hyperlink{classns3_1_1VsaManager_a3d56f68f3b98bd45ccc6c56c9a6244db}{Do\+Send\+Vsa} (enum \hyperlink{namespacens3_a417ab130a77d452a8b5014090665bcc1}{Vsa\+Transmit\+Interval} interval, uint32\+\_\+t channel, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ vsc, \hyperlink{classns3_1_1OrganizationIdentifier}{Organization\+Identifier} oi, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} peer)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Callback}{Callback}$<$ bool, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$, const \hyperlink{classns3_1_1Address}{Address} \&, uint32\+\_\+t, uint32\+\_\+t $>$ \hyperlink{classns3_1_1VsaManager_aeccc82895aa122c2625aaf564987034b}{m\+\_\+vsa\+Received}
\begin{DoxyCompactList}\small\item\em V\+SA received callback. \end{DoxyCompactList}\item 
std\+::vector$<$ \hyperlink{structns3_1_1VsaManager_1_1VsaWork}{Vsa\+Work} $\ast$ $>$ \hyperlink{classns3_1_1VsaManager_aee890e87ec25f92c31c8afd8666f3031}{m\+\_\+vsas}
\begin{DoxyCompactList}\small\item\em V\+S\+As. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1WaveNetDevice}{Wave\+Net\+Device} $>$ \hyperlink{classns3_1_1VsaManager_a52ae414f7b31a4d8b9c572689b7a7108}{m\+\_\+device}
\begin{DoxyCompactList}\small\item\em the device \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Private Attributes}
\begin{DoxyCompactItemize}
\item 
static const uint32\+\_\+t \hyperlink{classns3_1_1VsaManager_a552deee2b7263756fad4f3e95f4ef777}{V\+S\+A\+\_\+\+R\+E\+P\+E\+A\+T\+\_\+\+P\+E\+R\+I\+OD} = 5
\begin{DoxyCompactList}\small\item\em A number of V\+SA frames will be transmitted repeatedly during the period of 5s. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
refer to 1609.\+4-\/2010 chapter 6.\+4 Vendor Specific Action (V\+SA) frames transmission.

The channel interval and channel number indicating how to transmit V\+SA frames. However making the V\+SA transmitted strictly in required channel interval and channel number is hard to achieve. For example, if current channel is assigned “\+Alternating Access” and higher layer wants V\+SA transmitted only in C\+C\+HI (V\+S\+A\+\_\+\+T\+R\+A\+N\+S\+M\+I\+T\+\_\+\+I\+N\+\_\+\+C\+C\+HI), but when packet is dequeued from the internal queue of M\+AC layer in S\+C\+HI and can contend for channel access, how to deal with this case? Reinserting into the head of the queue and dequeuing the second packet is not a good choice, because it will require queue traversal. Reinserting the packet into the tail of the queue is worse, because it will make queue not in order. And both solutions may affect many M\+AC classes of Wifi module. Current approach is to guarantee packets can be inserted into the M\+AC internal queue strictly in channel interval and channel number required by higher layers. This solution will result in high probability that packets will be sent in channel interval as higher layer wants, while some packet may be sent practically in other channel interval that not follows the requirement of higher layer request due to queue delay of M\+AC layer. Therefore, we suggest users assign alternating access for sending V\+S\+As in C\+CH Interval (V\+S\+A\+\_\+\+T\+R\+A\+N\+S\+M\+I\+T\+\_\+\+I\+N\+\_\+\+C\+C\+HI) or S\+CH Interval (V\+S\+A\+\_\+\+T\+R\+A\+N\+S\+M\+I\+T\+\_\+\+I\+N\+\_\+\+S\+C\+HI), and assign continuous access or extended access for sending V\+S\+As in both interval (V\+S\+A\+\_\+\+T\+R\+A\+N\+S\+M\+I\+T\+\_\+\+I\+N\+\_\+\+B\+O\+T\+HI) to avoid the above cases. 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}!Vsa\+Manager@{Vsa\+Manager}}
\index{Vsa\+Manager@{Vsa\+Manager}!ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}}
\subsubsection[{\texorpdfstring{Vsa\+Manager(void)}{VsaManager(void)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Vsa\+Manager\+::\+Vsa\+Manager (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1VsaManager_a283a4c9945639bb4fe32133024ee52bc}{}\label{classns3_1_1VsaManager_a283a4c9945639bb4fe32133024ee52bc}

\begin{DoxyCode}
49   : \hyperlink{classns3_1_1VsaManager_a52ae414f7b31a4d8b9c572689b7a7108}{m\_device} (0)
50 \{
51   \hyperlink{classns3_1_1VsaManager_aeccc82895aa122c2625aaf564987034b}{m\_vsaReceived} = MakeNullCallback<bool, Ptr<const Packet>,\textcolor{keyword}{const} Address &, uint32\_t, uint32\_t
      > ();
52 \}
\end{DoxyCode}
\index{ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}!````~Vsa\+Manager@{$\sim$\+Vsa\+Manager}}
\index{````~Vsa\+Manager@{$\sim$\+Vsa\+Manager}!ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}}
\subsubsection[{\texorpdfstring{$\sim$\+Vsa\+Manager(void)}{~VsaManager(void)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Vsa\+Manager\+::$\sim$\+Vsa\+Manager (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1VsaManager_adb3a9a1ecbab2d9e4ac9ef318ce179a6}{}\label{classns3_1_1VsaManager_adb3a9a1ecbab2d9e4ac9ef318ce179a6}

\begin{DoxyCode}
55 \{
56 
57 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}}
\subsubsection[{\texorpdfstring{Do\+Dispose(void)}{DoDispose(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Vsa\+Manager\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1VsaManager_a36e46be212cd99de74d78ec1494f8476}{}\label{classns3_1_1VsaManager_a36e46be212cd99de74d78ec1494f8476}
Destructor implementation.

This method is called by \hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose()} or by the \hyperlink{classns3_1_1Object}{Object}\textquotesingle{}s destructor, whichever comes first.

Subclasses are expected to implement their real destruction code in an overriden version of this method and chain up to their parent\textquotesingle{}s implementation once they are done. {\itshape i.\+e}, for simplicity, the destructor of every subclass should be empty and its content should be moved to the associated \hyperlink{classns3_1_1VsaManager_a36e46be212cd99de74d78ec1494f8476}{Do\+Dispose()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.


\begin{DoxyCode}
61 \{
62   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
63   \hyperlink{classns3_1_1VsaManager_ac27455a3d1a998d8ddd69029cd9a73cf}{RemoveAll} ();
64   \hyperlink{classns3_1_1VsaManager_a52ae414f7b31a4d8b9c572689b7a7108}{m\_device} = 0;
65 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}!Do\+Initialize@{Do\+Initialize}}
\index{Do\+Initialize@{Do\+Initialize}!ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}}
\subsubsection[{\texorpdfstring{Do\+Initialize(void)}{DoInitialize(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Vsa\+Manager\+::\+Do\+Initialize (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1VsaManager_a05e003d4c898eda681aeb6c2a4339e2a}{}\label{classns3_1_1VsaManager_a05e003d4c898eda681aeb6c2a4339e2a}
\hyperlink{classns3_1_1Object_af4411cb29971772fcd09203474a95078}{Initialize()} implementation.

This method is called only once by \hyperlink{classns3_1_1Object_af4411cb29971772fcd09203474a95078}{Initialize()}. If the user calls \hyperlink{classns3_1_1Object_af4411cb29971772fcd09203474a95078}{Initialize()} multiple times, \hyperlink{classns3_1_1VsaManager_a05e003d4c898eda681aeb6c2a4339e2a}{Do\+Initialize()} is called only the first time.

Subclasses are expected to override this method and chain up to their parent\textquotesingle{}s implementation once they are done. It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} and \hyperlink{classns3_1_1Object_a79dd435d300f3deca814553f561a2922}{Aggregate\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_af8482a521433409fb5c7f749398c9dbe}{ns3\+::\+Object}.


\begin{DoxyCode}
69 \{
70   std::map<uint32\_t, Ptr<OcbWifiMac> > macs = \hyperlink{classns3_1_1VsaManager_a52ae414f7b31a4d8b9c572689b7a7108}{m\_device}->\hyperlink{classns3_1_1WaveNetDevice_a48869fef4b065ccb39d2210a22bbe437}{GetMacs} ();
71   \textcolor{keywordflow}{for} (std::map<uint32\_t, Ptr<OcbWifiMac> >::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = macs.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != macs.end (); ++
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
72     \{
73       \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second->AddReceiveVscCallback (\hyperlink{namespacens3_a5bafcf217bb35178539e621dc8ba0aa2}{oi\_1609}, \hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1VsaManager_a5dd6b3883b8e57ed8cc7f7cc7afa5601}{VsaManager::ReceiveVsc}, \textcolor{keyword}{this}));
74     \}
75 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}!Do\+Repeat@{Do\+Repeat}}
\index{Do\+Repeat@{Do\+Repeat}!ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}}
\subsubsection[{\texorpdfstring{Do\+Repeat(\+Vsa\+Work $\ast$vsa)}{DoRepeat(VsaWork *vsa)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Vsa\+Manager\+::\+Do\+Repeat (
\begin{DoxyParamCaption}
\item[{{\bf Vsa\+Work} $\ast$}]{vsa}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1VsaManager_a5731f78c47436e8cb495052b1fe42f65}{}\label{classns3_1_1VsaManager_a5731f78c47436e8cb495052b1fe42f65}

\begin{DoxyParams}{Parameters}
{\em vsa} & the specific V\+SA repeat work\\
\hline
\end{DoxyParams}
Repeat to send V\+SA frames 
\begin{DoxyCode}
120 \{
121   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << vsa);
122   vsa->repeat =  \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (vsa->repeatPeriod, &
      \hyperlink{classns3_1_1VsaManager_a5731f78c47436e8cb495052b1fe42f65}{VsaManager::DoRepeat}, \textcolor{keyword}{this}, vsa);
123   \hyperlink{classns3_1_1VsaManager_a3d56f68f3b98bd45ccc6c56c9a6244db}{DoSendVsa} (vsa->sentInterval, vsa->channelNumber, vsa->vsc->Copy (), vsa->oi, vsa->peer);
124 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4




Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}!Do\+Send\+Vsa@{Do\+Send\+Vsa}}
\index{Do\+Send\+Vsa@{Do\+Send\+Vsa}!ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}}
\subsubsection[{\texorpdfstring{Do\+Send\+Vsa(enum Vsa\+Transmit\+Interval interval, uint32\+\_\+t channel, Ptr$<$ Packet $>$ vsc, Organization\+Identifier oi, Mac48\+Address peer)}{DoSendVsa(enum VsaTransmitInterval interval, uint32_t channel, Ptr< Packet > vsc, OrganizationIdentifier oi, Mac48Address peer)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Vsa\+Manager\+::\+Do\+Send\+Vsa (
\begin{DoxyParamCaption}
\item[{enum {\bf Vsa\+Transmit\+Interval}}]{interval, }
\item[{uint32\+\_\+t}]{channel, }
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{vsc, }
\item[{{\bf Organization\+Identifier}}]{oi, }
\item[{{\bf Mac48\+Address}}]{peer}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1VsaManager_a3d56f68f3b98bd45ccc6c56c9a6244db}{}\label{classns3_1_1VsaManager_a3d56f68f3b98bd45ccc6c56c9a6244db}

\begin{DoxyParams}{Parameters}
{\em interval} & the specific channel interval for V\+SA transmission \\
\hline
{\em channel} & the specific channel number for V\+SA transmission \\
\hline
{\em vsc} & the data field of V\+SA frame that contains vendor specific content \\
\hline
{\em oi} & the Organization Identifier for V\+SA frame \\
\hline
{\em peer} & the destination address \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
129 \{
130   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << interval << channel << vsc << oi << peer);
131   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1VsaManager_a52ae414f7b31a4d8b9c572689b7a7108}{m\_device} != 0);
132   Ptr<ChannelCoordinator> coordinator = \hyperlink{classns3_1_1VsaManager_a52ae414f7b31a4d8b9c572689b7a7108}{m\_device}->\hyperlink{classns3_1_1WaveNetDevice_af2995fc465c490ae033e98c5beabd7f1}{GetChannelCoordinator} ();
133   Ptr<ChannelScheduler> scheduler = \hyperlink{classns3_1_1VsaManager_a52ae414f7b31a4d8b9c572689b7a7108}{m\_device}->\hyperlink{classns3_1_1WaveNetDevice_abae0924be9be442fa0b234c82047e368}{GetChannelScheduler} ();
134   Ptr<ChannelManager> manager = \hyperlink{classns3_1_1VsaManager_a52ae414f7b31a4d8b9c572689b7a7108}{m\_device}->\hyperlink{classns3_1_1WaveNetDevice_a4c0b3d018ff1ade5c8c9375d9e43f5ad}{GetChannelManager} ();
135 
136   \textcolor{comment}{// if the request is for transmitting in SCH Interval (or CCH Interval), but currently}
137   \textcolor{comment}{// is not in SCH Interval (or CCH Interval) and , then the WAVE device  will wait}
138   \textcolor{comment}{// some time to insert this VSA frame into MAC internal queue.}
139   \textcolor{comment}{// if the request is for transmitting in any channel interval, then the WAVE device}
140   \textcolor{comment}{// insert this VSA frame into MAC internal queue immediately.}
141   \textcolor{keywordflow}{if} (interval == \hyperlink{namespacens3_a417ab130a77d452a8b5014090665bcc1ad75f8ae4d4ec6a1ded6834e982a7149d}{VSA\_TRANSMIT\_IN\_SCHI})
142     \{
143       \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} wait = coordinator->NeedTimeToSchInterval ();
144       \textcolor{keywordflow}{if} (wait != \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (0))
145         \{
146           \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (wait, &\hyperlink{classns3_1_1VsaManager_a3d56f68f3b98bd45ccc6c56c9a6244db}{VsaManager::DoSendVsa}, \textcolor{keyword}{this},
147                                interval, channel, vsc, oi, peer);
148           \textcolor{keywordflow}{return};
149         \}
150     \}
151   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (interval == \hyperlink{namespacens3_a417ab130a77d452a8b5014090665bcc1a2892e80beed7d3cc2ec6a4b8acf05676}{VSA\_TRANSMIT\_IN\_CCHI})
152     \{
153       \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} wait = coordinator->NeedTimeToCchInterval ();
154       \textcolor{keywordflow}{if} (wait != \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (0))
155         \{
156           \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (wait, &\hyperlink{classns3_1_1VsaManager_a3d56f68f3b98bd45ccc6c56c9a6244db}{VsaManager::DoSendVsa}, \textcolor{keyword}{this},
157                                interval, channel, vsc, oi, peer);
158           \textcolor{keywordflow}{return};
159         \}
160     \}
161   \textcolor{keywordflow}{else}
162     \{
163       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (interval == \hyperlink{namespacens3_a417ab130a77d452a8b5014090665bcc1aae42365483bb4ad44a43f5e31f4a3495}{VSA\_TRANSMIT\_IN\_BOTHI});
164       \textcolor{comment}{// do nothing here, since VSA\_IN\_BOTHI allows to sent VSA frames in any interval.}
165     \}
166 
167   \textcolor{keywordflow}{if} (!scheduler->IsChannelAccessAssigned (channel))
168     \{
169       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"there is no channel access assigned for channel "} << channel);
170       \textcolor{keywordflow}{return};
171     \}
172 
173   \textcolor{comment}{// refer to 1609.4-2010 chapter 5.4.1}
174   \textcolor{comment}{// Management frames are assigned the highest AC (AC\_VO).}
175   SocketPriorityTag priorityTag;
176   priorityTag.SetPriority (7);
177   vsc->\hyperlink{classns3_1_1Packet_a7400b8655852f5271c5957250d0141af}{AddPacketTag} (priorityTag);
178 
179   WifiTxVector txVector;
180   txVector.SetChannelWidth (10);
181   txVector.SetTxPowerLevel (manager->GetManagementPowerLevel (channel));
182   txVector.SetMode (manager->GetManagementDataRate (channel));
183   txVector.SetPreambleType (manager->GetManagementPreamble (channel));
184   HigherLayerTxVectorTag tag = HigherLayerTxVectorTag (txVector, manager->GetManagementAdaptable (channel))
      ;
185   vsc->\hyperlink{classns3_1_1Packet_a7400b8655852f5271c5957250d0141af}{AddPacketTag} (tag);
186 
187   Ptr<OcbWifiMac> mac = \hyperlink{classns3_1_1VsaManager_a52ae414f7b31a4d8b9c572689b7a7108}{m\_device}->\hyperlink{classns3_1_1WaveNetDevice_a899f670dd8eb023f0e40f19b536724eb}{GetMac} (channel);
188   mac->SendVsc (vsc, peer, oi);
189 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6




Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Vsa\+Manager\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1VsaManager_a9a6cfa45b3cf63f019a2eb868dcf365d}{}\label{classns3_1_1VsaManager_a9a6cfa45b3cf63f019a2eb868dcf365d}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
39 \{
40   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::VsaManager"})
41     .SetParent<\hyperlink{classns3_1_1Object_a40860402e64d8008fb42329df7097cdb}{Object}> ()
42     .SetGroupName (\textcolor{stringliteral}{"Wave"})
43     .AddConstructor<\hyperlink{classns3_1_1VsaManager_a283a4c9945639bb4fe32133024ee52bc}{VsaManager}> ()
44   ;
45   \textcolor{keywordflow}{return} tid;
46 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8


\index{ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}!Receive\+Vsc@{Receive\+Vsc}}
\index{Receive\+Vsc@{Receive\+Vsc}!ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}}
\subsubsection[{\texorpdfstring{Receive\+Vsc(\+Ptr$<$ Wifi\+Mac $>$ mac, const Organization\+Identifier \&oi, Ptr$<$ const Packet $>$ vsc, const Address \&src)}{ReceiveVsc(Ptr< WifiMac > mac, const OrganizationIdentifier &oi, Ptr< const Packet > vsc, const Address &src)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Vsa\+Manager\+::\+Receive\+Vsc (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Wifi\+Mac} $>$}]{mac, }
\item[{const {\bf Organization\+Identifier} \&}]{oi, }
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{vsc, }
\item[{const {\bf Address} \&}]{src}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1VsaManager_a5dd6b3883b8e57ed8cc7f7cc7afa5601}{}\label{classns3_1_1VsaManager_a5dd6b3883b8e57ed8cc7f7cc7afa5601}

\begin{DoxyParams}{Parameters}
{\em mac} & the M\+AC entity which receives V\+SA frame \\
\hline
{\em oi} & the Organization Identifier of received V\+SA frame \\
\hline
{\em vsc} & the vendor specific content of received V\+SA frame \\
\hline
{\em src} & the source address of received V\+SA frame \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if successful 
\end{DoxyReturn}

\begin{DoxyCode}
266 \{
267   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << mac << oi << vsc << src);
268   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (oi == \hyperlink{namespacens3_a5bafcf217bb35178539e621dc8ba0aa2}{oi\_1609});
269   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1VsaManager_aeccc82895aa122c2625aaf564987034b}{m\_vsaReceived}.IsNull ())
270     \{
271       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
272     \}
273   uint32\_t channelNumber = mac->GetWifiPhy ()->GetChannelNumber ();
274   uint32\_t managementId = oi.GetManagementId ();
275   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1VsaManager_aeccc82895aa122c2625aaf564987034b}{m\_vsaReceived} (vsc, src, managementId, channelNumber);
276 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9




Here is the caller graph for this function\+:
% FIG 10


\index{ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}!Remove\+All@{Remove\+All}}
\index{Remove\+All@{Remove\+All}!ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}}
\subsubsection[{\texorpdfstring{Remove\+All(void)}{RemoveAll(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Vsa\+Manager\+::\+Remove\+All (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1VsaManager_ac27455a3d1a998d8ddd69029cd9a73cf}{}\label{classns3_1_1VsaManager_ac27455a3d1a998d8ddd69029cd9a73cf}
cancel all V\+SA transmissions 
\begin{DoxyCode}
193 \{
194   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
195   \textcolor{keywordflow}{for} (std::vector<VsaWork *>::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1VsaManager_aee890e87ec25f92c31c8afd8666f3031}{m\_vsas}.begin ();
196        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1VsaManager_aee890e87ec25f92c31c8afd8666f3031}{m\_vsas}.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
197     \{
198       \textcolor{keywordflow}{if} (!(*i)->repeat.IsExpired ())
199         \{
200           (*i)->repeat.Cancel ();
201         \}
202       (*i)->vsc = 0;
203       \textcolor{keyword}{delete} (*i);
204     \}
205   \hyperlink{classns3_1_1VsaManager_aee890e87ec25f92c31c8afd8666f3031}{m\_vsas}.clear ();
206 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}!Remove\+By\+Channel@{Remove\+By\+Channel}}
\index{Remove\+By\+Channel@{Remove\+By\+Channel}!ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}}
\subsubsection[{\texorpdfstring{Remove\+By\+Channel(uint32\+\_\+t channel\+Number)}{RemoveByChannel(uint32_t channelNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Vsa\+Manager\+::\+Remove\+By\+Channel (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{channel\+Number}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1VsaManager_ad526912b634fd876c98b6d2695bea1e9}{}\label{classns3_1_1VsaManager_ad526912b634fd876c98b6d2695bea1e9}

\begin{DoxyParams}{Parameters}
{\em channel\+Number} & cancel V\+SA transmission specified by channel number \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
210 \{
211   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << channelNumber);
212   \textcolor{keywordflow}{for} (std::vector<VsaWork *>::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1VsaManager_aee890e87ec25f92c31c8afd8666f3031}{m\_vsas}.begin ();
213        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1VsaManager_aee890e87ec25f92c31c8afd8666f3031}{m\_vsas}.end (); )
214     \{
215       \textcolor{keywordflow}{if} ((*i)->channelNumber == channelNumber)
216         \{
217           \textcolor{keywordflow}{if} (!(*i)->repeat.IsExpired ())
218             \{
219               (*i)->repeat.Cancel ();
220             \}
221           (*i)->vsc = 0;
222           \textcolor{keyword}{delete} (*i);
223           \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1VsaManager_aee890e87ec25f92c31c8afd8666f3031}{m\_vsas}.erase (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
224         \}
225       \textcolor{keywordflow}{else}
226         \{
227           ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
228         \}
229     \}
230 \}
\end{DoxyCode}
\index{ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}!Remove\+By\+Organization\+Identifier@{Remove\+By\+Organization\+Identifier}}
\index{Remove\+By\+Organization\+Identifier@{Remove\+By\+Organization\+Identifier}!ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}}
\subsubsection[{\texorpdfstring{Remove\+By\+Organization\+Identifier(const Organization\+Identifier \&oi)}{RemoveByOrganizationIdentifier(const OrganizationIdentifier &oi)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Vsa\+Manager\+::\+Remove\+By\+Organization\+Identifier (
\begin{DoxyParamCaption}
\item[{const {\bf Organization\+Identifier} \&}]{oi}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1VsaManager_ae158c6a30d3d971b6dae5ac58263dffa}{}\label{classns3_1_1VsaManager_ae158c6a30d3d971b6dae5ac58263dffa}

\begin{DoxyParams}{Parameters}
{\em oi} & cancel V\+SA transmission specified by organization identifier \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
235 \{
236   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << oi);
237   \textcolor{keywordflow}{for} (std::vector<VsaWork *>::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1VsaManager_aee890e87ec25f92c31c8afd8666f3031}{m\_vsas}.begin ();
238        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1VsaManager_aee890e87ec25f92c31c8afd8666f3031}{m\_vsas}.end (); )
239     \{
240       \textcolor{keywordflow}{if} ((*i)->oi == oi)
241         \{
242           \textcolor{keywordflow}{if} (!(*i)->repeat.IsExpired ())
243             \{
244               (*i)->repeat.Cancel ();
245             \}
246           (*i)->vsc = 0;
247           \textcolor{keyword}{delete} (*i);
248           \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1VsaManager_aee890e87ec25f92c31c8afd8666f3031}{m\_vsas}.erase (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
249         \}
250       \textcolor{keywordflow}{else}
251         \{
252           ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
253         \}
254     \}
255 \}
\end{DoxyCode}
\index{ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}!Send\+Vsa@{Send\+Vsa}}
\index{Send\+Vsa@{Send\+Vsa}!ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}}
\subsubsection[{\texorpdfstring{Send\+Vsa(const Vsa\+Info \&vsa\+Info)}{SendVsa(const VsaInfo &vsaInfo)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Vsa\+Manager\+::\+Send\+Vsa (
\begin{DoxyParamCaption}
\item[{const {\bf Vsa\+Info} \&}]{vsa\+Info}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1VsaManager_af896634c89ed0725215aa5da43445295}{}\label{classns3_1_1VsaManager_af896634c89ed0725215aa5da43445295}

\begin{DoxyParams}{Parameters}
{\em vsa\+Info} & the tx information for V\+SA transmissions \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
86 \{
87   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << &vsaInfo);
88   OrganizationIdentifier oi;
89   \textcolor{keywordflow}{if} (vsaInfo.oi.IsNull ())
90     \{
91       \textcolor{comment}{// refer to 1609.4-2010 chapter 6.4.1.1}
92       uint8\_t oibytes[5] = \{0x00, 0x50, 0xC2, 0x4A, 0x40\};
93       oibytes[4] |= (vsaInfo.managementId & 0x0f);
94       oi = OrganizationIdentifier (oibytes, 5);
95     \}
96   \textcolor{keywordflow}{else}
97     \{
98       oi = vsaInfo.oi;
99     \}
100 
101   \textcolor{comment}{// if destination MAC address is the unicast address or  repeat rate is 0,}
102   \textcolor{comment}{// then only single one VSA frame is to be sent.}
103   \textcolor{keywordflow}{if} (vsaInfo.peer.IsGroup () && (vsaInfo.repeatRate != 0))
104     \{
105       VsaWork *vsa = \textcolor{keyword}{new} VsaWork ();
106       vsa->sentInterval = vsaInfo.sendInterval;
107       vsa->channelNumber = vsaInfo.channelNumber;
108       vsa->peer = vsaInfo.peer;
109       vsa->repeatPeriod = \hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (\hyperlink{classns3_1_1VsaManager_a552deee2b7263756fad4f3e95f4ef777}{VSA\_REPEAT\_PERIOD} * 1000 / vsaInfo.
      repeatRate);
110       vsa->vsc = vsaInfo.vsc;
111       vsa->oi = oi;
112       vsa->repeat =  \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (vsa->repeatPeriod, &
      \hyperlink{classns3_1_1VsaManager_a5731f78c47436e8cb495052b1fe42f65}{VsaManager::DoRepeat}, \textcolor{keyword}{this}, vsa);
113       \hyperlink{classns3_1_1VsaManager_aee890e87ec25f92c31c8afd8666f3031}{m\_vsas}.push\_back (vsa);
114     \}
115   \hyperlink{classns3_1_1VsaManager_a3d56f68f3b98bd45ccc6c56c9a6244db}{DoSendVsa} (vsaInfo.sendInterval, vsaInfo.channelNumber, vsaInfo.vsc->Copy (), oi, vsaInfo.peer);
116 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12


\index{ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}!Set\+Wave\+Net\+Device@{Set\+Wave\+Net\+Device}}
\index{Set\+Wave\+Net\+Device@{Set\+Wave\+Net\+Device}!ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}}
\subsubsection[{\texorpdfstring{Set\+Wave\+Net\+Device(\+Ptr$<$ Wave\+Net\+Device $>$ device)}{SetWaveNetDevice(Ptr< WaveNetDevice > device)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Vsa\+Manager\+::\+Set\+Wave\+Net\+Device (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Wave\+Net\+Device} $>$}]{device}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1VsaManager_a73647933b1d7efe2fd5c50d313aa11db}{}\label{classns3_1_1VsaManager_a73647933b1d7efe2fd5c50d313aa11db}

\begin{DoxyParams}{Parameters}
{\em device} & \hyperlink{classns3_1_1WaveNetDevice}{Wave\+Net\+Device} associated with \hyperlink{classns3_1_1VsaManager}{Vsa\+Manager} \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
79 \{
80   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << device);
81   \hyperlink{classns3_1_1VsaManager_a52ae414f7b31a4d8b9c572689b7a7108}{m\_device} = device;
82 \}
\end{DoxyCode}
\index{ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}!Set\+Wave\+Vsa\+Callback@{Set\+Wave\+Vsa\+Callback}}
\index{Set\+Wave\+Vsa\+Callback@{Set\+Wave\+Vsa\+Callback}!ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}}
\subsubsection[{\texorpdfstring{Set\+Wave\+Vsa\+Callback(\+Callback$<$ bool, Ptr$<$ const Packet $>$, const Address \&, uint32\+\_\+t, uint32\+\_\+t $>$ vsa\+Callback)}{SetWaveVsaCallback(Callback< bool, Ptr< const Packet >, const Address &, uint32_t, uint32_t > vsaCallback)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Vsa\+Manager\+::\+Set\+Wave\+Vsa\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Callback}$<$ bool, {\bf Ptr}$<$ const {\bf Packet} $>$, const {\bf Address} \&, uint32\+\_\+t, uint32\+\_\+t $>$}]{vsa\+Callback}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1VsaManager_a1d51c2011ec5e0ee0d3ea812b0ccd189}{}\label{classns3_1_1VsaManager_a1d51c2011ec5e0ee0d3ea812b0ccd189}


set wave vsa callback function 


\begin{DoxyCode}
259 \{
260   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
261   \hyperlink{classns3_1_1VsaManager_aeccc82895aa122c2625aaf564987034b}{m\_vsaReceived} = vsaCallback;
262 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}!m\+\_\+device@{m\+\_\+device}}
\index{m\+\_\+device@{m\+\_\+device}!ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}}
\subsubsection[{\texorpdfstring{m\+\_\+device}{m_device}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Wave\+Net\+Device}$>$ ns3\+::\+Vsa\+Manager\+::m\+\_\+device\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1VsaManager_a52ae414f7b31a4d8b9c572689b7a7108}{}\label{classns3_1_1VsaManager_a52ae414f7b31a4d8b9c572689b7a7108}


the device 

\index{ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}!m\+\_\+vsa\+Received@{m\+\_\+vsa\+Received}}
\index{m\+\_\+vsa\+Received@{m\+\_\+vsa\+Received}!ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}}
\subsubsection[{\texorpdfstring{m\+\_\+vsa\+Received}{m_vsaReceived}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Callback}$<$bool, {\bf Ptr}$<$const {\bf Packet}$>$,const {\bf Address} \&, uint32\+\_\+t, uint32\+\_\+t$>$ ns3\+::\+Vsa\+Manager\+::m\+\_\+vsa\+Received\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1VsaManager_aeccc82895aa122c2625aaf564987034b}{}\label{classns3_1_1VsaManager_aeccc82895aa122c2625aaf564987034b}


V\+SA received callback. 

\index{ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}!m\+\_\+vsas@{m\+\_\+vsas}}
\index{m\+\_\+vsas@{m\+\_\+vsas}!ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}}
\subsubsection[{\texorpdfstring{m\+\_\+vsas}{m_vsas}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<${\bf Vsa\+Work} $\ast$$>$ ns3\+::\+Vsa\+Manager\+::m\+\_\+vsas\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1VsaManager_aee890e87ec25f92c31c8afd8666f3031}{}\label{classns3_1_1VsaManager_aee890e87ec25f92c31c8afd8666f3031}


V\+S\+As. 

\index{ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}!V\+S\+A\+\_\+\+R\+E\+P\+E\+A\+T\+\_\+\+P\+E\+R\+I\+OD@{V\+S\+A\+\_\+\+R\+E\+P\+E\+A\+T\+\_\+\+P\+E\+R\+I\+OD}}
\index{V\+S\+A\+\_\+\+R\+E\+P\+E\+A\+T\+\_\+\+P\+E\+R\+I\+OD@{V\+S\+A\+\_\+\+R\+E\+P\+E\+A\+T\+\_\+\+P\+E\+R\+I\+OD}!ns3\+::\+Vsa\+Manager@{ns3\+::\+Vsa\+Manager}}
\subsubsection[{\texorpdfstring{V\+S\+A\+\_\+\+R\+E\+P\+E\+A\+T\+\_\+\+P\+E\+R\+I\+OD}{VSA_REPEAT_PERIOD}}]{\setlength{\rightskip}{0pt plus 5cm}const uint32\+\_\+t ns3\+::\+Vsa\+Manager\+::\+V\+S\+A\+\_\+\+R\+E\+P\+E\+A\+T\+\_\+\+P\+E\+R\+I\+OD = 5\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\hypertarget{classns3_1_1VsaManager_a552deee2b7263756fad4f3e95f4ef777}{}\label{classns3_1_1VsaManager_a552deee2b7263756fad4f3e95f4ef777}


A number of V\+SA frames will be transmitted repeatedly during the period of 5s. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
wave/model/\hyperlink{vsa-manager_8h}{vsa-\/manager.\+h}\item 
wave/model/\hyperlink{vsa-manager_8cc}{vsa-\/manager.\+cc}\end{DoxyCompactItemize}
