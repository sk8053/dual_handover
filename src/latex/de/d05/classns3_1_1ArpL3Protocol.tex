\hypertarget{classns3_1_1ArpL3Protocol}{}\section{ns3\+:\+:Arp\+L3\+Protocol Class Reference}
\label{classns3_1_1ArpL3Protocol}\index{ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}}


An implementation of the A\+RP protocol.  




{\ttfamily \#include $<$arp-\/l3-\/protocol.\+h$>$}



Inheritance diagram for ns3\+:\+:Arp\+L3\+Protocol\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Arp\+L3\+Protocol\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1ArpL3Protocol_abc71e344dd3155928525b90c61835402}{Arp\+L3\+Protocol} ()
\item 
virtual \hyperlink{classns3_1_1ArpL3Protocol_a62dad25a855cc99875c1f99ad36511b5}{$\sim$\+Arp\+L3\+Protocol} ()
\item 
void \hyperlink{classns3_1_1ArpL3Protocol_a7100d6daf253d51bef7a49d9ea74446f}{Set\+Node} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node)
\begin{DoxyCompactList}\small\item\em Set the node the A\+RP L3 protocol is associated with. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1ArpCache}{Arp\+Cache} $>$ \hyperlink{classns3_1_1ArpL3Protocol_a8edf6394f07185b1637295a79239c2ac}{Create\+Cache} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} $>$ interface)
\begin{DoxyCompactList}\small\item\em Create an A\+RP cache for the device/interface. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1ArpL3Protocol_a277509da885e127fb384f296f3858fef}{Receive} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, uint16\+\_\+t protocol, const \hyperlink{classns3_1_1Address}{Address} \&\hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from}, const \hyperlink{classns3_1_1Address}{Address} \&to, \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2}{Net\+Device\+::\+Packet\+Type} packet\+Type)
\begin{DoxyCompactList}\small\item\em Receive a packet. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1ArpL3Protocol_a11df282c1ae9cd812160b309fafc73d1}{Lookup} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&ip\+Header, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} destination, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1ArpCache}{Arp\+Cache} $>$ cache, \hyperlink{classns3_1_1Address}{Address} $\ast$hardware\+Destination)
\begin{DoxyCompactList}\small\item\em Perform an A\+RP lookup. \end{DoxyCompactList}\item 
int64\+\_\+t \hyperlink{classns3_1_1ArpL3Protocol_a07ef806847944cc7a463e2db33d59681}{Assign\+Streams} (int64\+\_\+t stream)
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1ArpL3Protocol_a2733879f637c220b7876ff5edaaefcdf}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const uint16\+\_\+t \hyperlink{classns3_1_1ArpL3Protocol_a836aec5bc5e5a8ea1d7f46609dc9cc2c}{P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER} = 0x0806
\begin{DoxyCompactList}\small\item\em A\+RP protocol number (0x0806) \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1ArpL3Protocol_a090a5c1267fc1008cdefbca6473e5316}{Do\+Dispose} (void)
\item 
virtual void \hyperlink{classns3_1_1ArpL3Protocol_a6c0bd0b14a514f5abd0b0eff34020283}{Notify\+New\+Aggregate} ()
\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1ArpCache}{Arp\+Cache} $>$ $>$ \hyperlink{classns3_1_1ArpL3Protocol_aae51f1ae2eb4bda375fb2f1fa4cc864a}{Cache\+List}
\begin{DoxyCompactList}\small\item\em container of the A\+RP caches \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1ArpL3Protocol_a6078c7624ad881b99b9978e09120e9eb}{Arp\+L3\+Protocol} (const \hyperlink{classns3_1_1ArpL3Protocol}{Arp\+L3\+Protocol} \&o)
\begin{DoxyCompactList}\small\item\em Copy constructor. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1ArpL3Protocol}{Arp\+L3\+Protocol} \& \hyperlink{classns3_1_1ArpL3Protocol_a946112f849f17835faa7e3b017fc6dc6}{operator=} (const \hyperlink{classns3_1_1ArpL3Protocol}{Arp\+L3\+Protocol} \&o)
\begin{DoxyCompactList}\small\item\em Copy constructor. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1ArpCache}{Arp\+Cache} $>$ \hyperlink{classns3_1_1ArpL3Protocol_a428dd13241d63395a5efbe68d6d9e667}{Find\+Cache} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device)
\begin{DoxyCompactList}\small\item\em Finds the cache associated with a \hyperlink{classns3_1_1NetDevice}{Net\+Device}. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1ArpL3Protocol_a9fe6faf0f82536ba2c14d5bdbf7469db}{Send\+Arp\+Request} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1ArpCache}{Arp\+Cache} $>$cache, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} to)
\begin{DoxyCompactList}\small\item\em Send an A\+RP request to an host. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1ArpL3Protocol_a2e1f058ec7982637902e91cb2e63b12c}{Send\+Arp\+Reply} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1ArpCache}{Arp\+Cache} $>$ cache, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} my\+Ip, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} to\+Ip, \hyperlink{classns3_1_1Address}{Address} to\+Mac)
\begin{DoxyCompactList}\small\item\em Send an A\+RP reply to an host. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1ArpL3Protocol_aae51f1ae2eb4bda375fb2f1fa4cc864a}{Cache\+List} \hyperlink{classns3_1_1ArpL3Protocol_a369682dd4e6568e6e5731d61147596c7}{m\+\_\+cache\+List}
\begin{DoxyCompactList}\small\item\em A\+RP cache container. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1ArpL3Protocol_aa1a2d173cfb3fd7e2f8eff8504a114da}{m\+\_\+node}
\begin{DoxyCompactList}\small\item\em node the A\+RP L3 protocol is associated with \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1ArpL3Protocol_ac719ebd2b108a4d342741706669d74ad}{m\+\_\+drop\+Trace}
\begin{DoxyCompactList}\small\item\em trace for packets dropped by A\+RP \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1RandomVariableStream}{Random\+Variable\+Stream} $>$ \hyperlink{classns3_1_1ArpL3Protocol_a0d5144a236473eb6d7153600fdd7c5ee}{m\+\_\+request\+Jitter}
\begin{DoxyCompactList}\small\item\em jitter to de-\/sync A\+RP requests \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
An implementation of the A\+RP protocol. 

\subsection{Member Typedef Documentation}
\index{ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}!Cache\+List@{Cache\+List}}
\index{Cache\+List@{Cache\+List}!ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Cache\+List}{CacheList}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Ptr}$<${\bf Arp\+Cache}$>$ $>$ {\bf ns3\+::\+Arp\+L3\+Protocol\+::\+Cache\+List}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1ArpL3Protocol_aae51f1ae2eb4bda375fb2f1fa4cc864a}{}\label{classns3_1_1ArpL3Protocol_aae51f1ae2eb4bda375fb2f1fa4cc864a}


container of the A\+RP caches 



\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}!Arp\+L3\+Protocol@{Arp\+L3\+Protocol}}
\index{Arp\+L3\+Protocol@{Arp\+L3\+Protocol}!ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Arp\+L3\+Protocol()}{ArpL3Protocol()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Arp\+L3\+Protocol\+::\+Arp\+L3\+Protocol (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1ArpL3Protocol_abc71e344dd3155928525b90c61835402}{}\label{classns3_1_1ArpL3Protocol_abc71e344dd3155928525b90c61835402}

\begin{DoxyCode}
74 \{
75   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
76 \}
\end{DoxyCode}
\index{ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}!````~Arp\+L3\+Protocol@{$\sim$\+Arp\+L3\+Protocol}}
\index{````~Arp\+L3\+Protocol@{$\sim$\+Arp\+L3\+Protocol}!ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{$\sim$\+Arp\+L3\+Protocol()}{~ArpL3Protocol()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Arp\+L3\+Protocol\+::$\sim$\+Arp\+L3\+Protocol (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1ArpL3Protocol_a62dad25a855cc99875c1f99ad36511b5}{}\label{classns3_1_1ArpL3Protocol_a62dad25a855cc99875c1f99ad36511b5}

\begin{DoxyCode}
79 \{
80   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
81 \}
\end{DoxyCode}
\index{ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}!Arp\+L3\+Protocol@{Arp\+L3\+Protocol}}
\index{Arp\+L3\+Protocol@{Arp\+L3\+Protocol}!ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Arp\+L3\+Protocol(const Arp\+L3\+Protocol \&o)}{ArpL3Protocol(const ArpL3Protocol &o)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Arp\+L3\+Protocol\+::\+Arp\+L3\+Protocol (
\begin{DoxyParamCaption}
\item[{const {\bf Arp\+L3\+Protocol} \&}]{o}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1ArpL3Protocol_a6078c7624ad881b99b9978e09120e9eb}{}\label{classns3_1_1ArpL3Protocol_a6078c7624ad881b99b9978e09120e9eb}


Copy constructor. 

Defined and unimplemented to avoid misuse 
\begin{DoxyParams}{Parameters}
{\em o} & \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\index{ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}!Assign\+Streams@{Assign\+Streams}}
\index{Assign\+Streams@{Assign\+Streams}!ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Assign\+Streams(int64\+\_\+t stream)}{AssignStreams(int64_t stream)}}]{\setlength{\rightskip}{0pt plus 5cm}int64\+\_\+t ns3\+::\+Arp\+L3\+Protocol\+::\+Assign\+Streams (
\begin{DoxyParamCaption}
\item[{int64\+\_\+t}]{stream}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1ArpL3Protocol_a07ef806847944cc7a463e2db33d59681}{}\label{classns3_1_1ArpL3Protocol_a07ef806847944cc7a463e2db33d59681}
Assign a fixed random variable stream number to the random variables used by this model. Return the number of streams (possibly zero) that have been assigned.


\begin{DoxyParams}{Parameters}
{\em stream} & first stream index to use \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of stream indices assigned by this model 
\end{DoxyReturn}

\begin{DoxyCode}
85 \{
86   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << stream);
87   \hyperlink{classns3_1_1ArpL3Protocol_a0d5144a236473eb6d7153600fdd7c5ee}{m\_requestJitter}->\hyperlink{classns3_1_1RandomVariableStream_add11aaf975607746b7e271d300659a94}{SetStream} (stream);
88   \textcolor{keywordflow}{return} 1;
89 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}!Create\+Cache@{Create\+Cache}}
\index{Create\+Cache@{Create\+Cache}!ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Create\+Cache(\+Ptr$<$ Net\+Device $>$ device, Ptr$<$ Ipv4\+Interface $>$ interface)}{CreateCache(Ptr< NetDevice > device, Ptr< Ipv4Interface > interface)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Arp\+Cache} $>$ ns3\+::\+Arp\+L3\+Protocol\+::\+Create\+Cache (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{device, }
\item[{{\bf Ptr}$<$ {\bf Ipv4\+Interface} $>$}]{interface}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1ArpL3Protocol_a8edf6394f07185b1637295a79239c2ac}{}\label{classns3_1_1ArpL3Protocol_a8edf6394f07185b1637295a79239c2ac}


Create an A\+RP cache for the device/interface. 


\begin{DoxyParams}{Parameters}
{\em device} & the \hyperlink{classns3_1_1NetDevice}{Net\+Device} \\
\hline
{\em interface} & the \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a smart pointer to the A\+RP cache 
\end{DoxyReturn}

\begin{DoxyCode}
135 \{
136   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << device << interface);
137   Ptr<Ipv4L3Protocol> ipv4 = \hyperlink{classns3_1_1ArpL3Protocol_aa1a2d173cfb3fd7e2f8eff8504a114da}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv4L3Protocol> ();
138   Ptr<ArpCache> cache = CreateObject<ArpCache> ();
139   cache->SetDevice (device, interface);
140   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (device->IsBroadcast ());
141   device->AddLinkChangeCallback (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&\hyperlink{classns3_1_1ArpCache_a7feb098de790b3ed4383dd73a11d856c}{ArpCache::Flush}, cache));
142   cache->SetArpRequestCallback (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1ArpL3Protocol_a9fe6faf0f82536ba2c14d5bdbf7469db}{ArpL3Protocol::SendArpRequest}, \textcolor{keyword}{this}));
143   \hyperlink{classns3_1_1ArpL3Protocol_a369682dd4e6568e6e5731d61147596c7}{m\_cacheList}.push\_back (cache);
144   \textcolor{keywordflow}{return} cache;
145 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Do\+Dispose(void)}{DoDispose(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Arp\+L3\+Protocol\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1ArpL3Protocol_a090a5c1267fc1008cdefbca6473e5316}{}\label{classns3_1_1ArpL3Protocol_a090a5c1267fc1008cdefbca6473e5316}
Destructor implementation.

This method is called by \hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose()} or by the \hyperlink{classns3_1_1Object}{Object}\textquotesingle{}s destructor, whichever comes first.

Subclasses are expected to implement their real destruction code in an overriden version of this method and chain up to their parent\textquotesingle{}s implementation once they are done. {\itshape i.\+e}, for simplicity, the destructor of every subclass should be empty and its content should be moved to the associated \hyperlink{classns3_1_1ArpL3Protocol_a090a5c1267fc1008cdefbca6473e5316}{Do\+Dispose()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.


\begin{DoxyCode}
121 \{
122   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
123   \textcolor{keywordflow}{for} (CacheList::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1ArpL3Protocol_a369682dd4e6568e6e5731d61147596c7}{m\_cacheList}.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != 
      \hyperlink{classns3_1_1ArpL3Protocol_a369682dd4e6568e6e5731d61147596c7}{m\_cacheList}.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
124     \{
125       Ptr<ArpCache> cache = *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
126       cache->Dispose ();
127     \}
128   \hyperlink{classns3_1_1ArpL3Protocol_a369682dd4e6568e6e5731d61147596c7}{m\_cacheList}.clear ();
129   \hyperlink{classns3_1_1ArpL3Protocol_aa1a2d173cfb3fd7e2f8eff8504a114da}{m\_node} = 0;
130   \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{Object::DoDispose} ();
131 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4


\index{ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}!Find\+Cache@{Find\+Cache}}
\index{Find\+Cache@{Find\+Cache}!ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Find\+Cache(\+Ptr$<$ Net\+Device $>$ device)}{FindCache(Ptr< NetDevice > device)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Arp\+Cache} $>$ ns3\+::\+Arp\+L3\+Protocol\+::\+Find\+Cache (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{device}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1ArpL3Protocol_a428dd13241d63395a5efbe68d6d9e667}{}\label{classns3_1_1ArpL3Protocol_a428dd13241d63395a5efbe68d6d9e667}


Finds the cache associated with a \hyperlink{classns3_1_1NetDevice}{Net\+Device}. 


\begin{DoxyParams}{Parameters}
{\em device} & the \hyperlink{classns3_1_1NetDevice}{Net\+Device} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the A\+RP cache, or null if no cache is found 
\end{DoxyReturn}

\begin{DoxyCode}
149 \{
150   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << device);
151   \textcolor{keywordflow}{for} (CacheList::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1ArpL3Protocol_a369682dd4e6568e6e5731d61147596c7}{m\_cacheList}.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != 
      \hyperlink{classns3_1_1ArpL3Protocol_a369682dd4e6568e6e5731d61147596c7}{m\_cacheList}.end (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
152     \{
153       \textcolor{keywordflow}{if} ((*i)->GetDevice () == device)
154         \{
155           \textcolor{keywordflow}{return} *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
156         \}
157     \}
158   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\textcolor{keyword}{false});
159   \textcolor{comment}{// quiet compiler}
160   \textcolor{keywordflow}{return} 0;
161 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Arp\+L3\+Protocol\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1ArpL3Protocol_a2733879f637c220b7876ff5edaaefcdf}{}\label{classns3_1_1ArpL3Protocol_a2733879f637c220b7876ff5edaaefcdf}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
45 \{
46   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::ArpL3Protocol"})
47     .SetParent<\hyperlink{classns3_1_1Object_a40860402e64d8008fb42329df7097cdb}{Object}> ()
48     .AddConstructor<ArpL3Protocol> ()
49     .SetGroupName (\textcolor{stringliteral}{"Internet"})
50     .AddAttribute (\textcolor{stringliteral}{"CacheList"},
51                    \textcolor{stringliteral}{"The list of ARP caches"},
52                    \hyperlink{namespacens3_a5de726d8bcea7a51fd68ce5167a66713}{ObjectVectorValue} (),
53                    \hyperlink{namespacens3_a6ad5b3621a5dc72b7030cbb07c73adf6}{MakeObjectVectorAccessor} (&
      \hyperlink{classns3_1_1ArpL3Protocol_a369682dd4e6568e6e5731d61147596c7}{ArpL3Protocol::m\_cacheList}),
54                    MakeObjectVectorChecker<ArpCache> ())
55     .AddAttribute (\textcolor{stringliteral}{"RequestJitter"},
56                    \textcolor{stringliteral}{"The jitter in ms a node is allowed to wait "}
57                    \textcolor{stringliteral}{"before sending an ARP request.  Some jitter aims "}
58                    \textcolor{stringliteral}{"to prevent collisions. By default, the model "}
59                    \textcolor{stringliteral}{"will wait for a duration in ms defined by "}
60                    \textcolor{stringliteral}{"a uniform random-variable between 0 and RequestJitter"},
61                    StringValue (\textcolor{stringliteral}{"ns3::UniformRandomVariable[Min=0.0|Max=10.0]"}),
62                    MakePointerAccessor (&\hyperlink{classns3_1_1ArpL3Protocol_a0d5144a236473eb6d7153600fdd7c5ee}{ArpL3Protocol::m\_requestJitter}),
63                    MakePointerChecker<RandomVariableStream> ())
64     .AddTraceSource (\textcolor{stringliteral}{"Drop"},
65                      \textcolor{stringliteral}{"Packet dropped because not enough room "}
66                      \textcolor{stringliteral}{"in pending queue for a specific cache entry."},
67                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1ArpL3Protocol_ac719ebd2b108a4d342741706669d74ad}{ArpL3Protocol::m\_dropTrace}),
68                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
69   ;
70   \textcolor{keywordflow}{return} tid;
71 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6


\index{ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}!Lookup@{Lookup}}
\index{Lookup@{Lookup}!ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Lookup(\+Ptr$<$ Packet $>$ p, const Ipv4\+Header \&ip\+Header, Ipv4\+Address destination, Ptr$<$ Net\+Device $>$ device, Ptr$<$ Arp\+Cache $>$ cache, Address $\ast$hardware\+Destination)}{Lookup(Ptr< Packet > p, const Ipv4Header &ipHeader, Ipv4Address destination, Ptr< NetDevice > device, Ptr< ArpCache > cache, Address *hardwareDestination)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Arp\+L3\+Protocol\+::\+Lookup (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv4\+Header} \&}]{ip\+Header, }
\item[{{\bf Ipv4\+Address}}]{destination, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{device, }
\item[{{\bf Ptr}$<$ {\bf Arp\+Cache} $>$}]{cache, }
\item[{{\bf Address} $\ast$}]{hardware\+Destination}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1ArpL3Protocol_a11df282c1ae9cd812160b309fafc73d1}{}\label{classns3_1_1ArpL3Protocol_a11df282c1ae9cd812160b309fafc73d1}


Perform an A\+RP lookup. 


\begin{DoxyParams}{Parameters}
{\em p} & the packet \\
\hline
{\em ip\+Header} & the I\+Pv4 header \\
\hline
{\em destination} & destination IP address \\
\hline
{\em device} & outgoing device \\
\hline
{\em cache} & A\+RP cache \\
\hline
{\em hardware\+Destination} & filled with the destination M\+AC address (if the entry exists) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if there is a matching A\+RP Entry 
\end{DoxyReturn}

\begin{DoxyCode}
274 \{
275   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << destination << device << cache << hardwareDestination);
276   ArpCache::Entry *entry = cache->Lookup (destination);
277   \textcolor{keywordflow}{if} (entry != 0)
278     \{
279       \textcolor{keywordflow}{if} (entry->IsExpired ()) 
280         \{
281           \textcolor{keywordflow}{if} (entry->IsDead ()) 
282             \{
283               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"node="}<<\hyperlink{classns3_1_1ArpL3Protocol_aa1a2d173cfb3fd7e2f8eff8504a114da}{m\_node}->\hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} ()<<
284                             \textcolor{stringliteral}{", dead entry for "} << destination << \textcolor{stringliteral}{" expired -- send arp request"});
285               entry->MarkWaitReply (\hyperlink{classns3_1_1ArpCache_ad018741a53ccc6cdb8b05fdd4873ef3d}{ArpCache::Ipv4PayloadHeaderPair} (packet,
       ipHeader));
286               \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (\hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (
      \hyperlink{classns3_1_1ArpL3Protocol_a0d5144a236473eb6d7153600fdd7c5ee}{m\_requestJitter}->\hyperlink{classns3_1_1RandomVariableStream_a4fa5944dc4cb11544e661ed23072b36c}{GetValue} ())), &
      \hyperlink{classns3_1_1ArpL3Protocol_a9fe6faf0f82536ba2c14d5bdbf7469db}{ArpL3Protocol::SendArpRequest}, \textcolor{keyword}{this}, cache, destination);
287             \} 
288           \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (entry->IsAlive ()) 
289             \{
290               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"node="}<<\hyperlink{classns3_1_1ArpL3Protocol_aa1a2d173cfb3fd7e2f8eff8504a114da}{m\_node}->\hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} ()<<
291                             \textcolor{stringliteral}{", alive entry for "} << destination << \textcolor{stringliteral}{" expired -- send arp request"});
292               entry->MarkWaitReply (\hyperlink{classns3_1_1ArpCache_ad018741a53ccc6cdb8b05fdd4873ef3d}{ArpCache::Ipv4PayloadHeaderPair} (packet,
       ipHeader));
293               \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (\hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (
      \hyperlink{classns3_1_1ArpL3Protocol_a0d5144a236473eb6d7153600fdd7c5ee}{m\_requestJitter}->\hyperlink{classns3_1_1RandomVariableStream_a4fa5944dc4cb11544e661ed23072b36c}{GetValue} ())), &
      \hyperlink{classns3_1_1ArpL3Protocol_a9fe6faf0f82536ba2c14d5bdbf7469db}{ArpL3Protocol::SendArpRequest}, \textcolor{keyword}{this}, cache, destination);
294             \} 
295           \textcolor{keywordflow}{else}
296             \{
297               \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Test for possibly unreachable code-- please file a bug report,
       with a test case, if this is ever hit"});
298             \}
299         \} 
300       \textcolor{keywordflow}{else} 
301         \{
302           \textcolor{keywordflow}{if} (entry->IsDead ()) 
303             \{
304               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"node="}<<\hyperlink{classns3_1_1ArpL3Protocol_aa1a2d173cfb3fd7e2f8eff8504a114da}{m\_node}->\hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} ()<<
305                             \textcolor{stringliteral}{", dead entry for "} << destination << \textcolor{stringliteral}{" valid -- drop"});
306               \textcolor{comment}{// add the Ipv4 header for tracing purposes}
307               packet->AddHeader (ipHeader);
308               \hyperlink{classns3_1_1ArpL3Protocol_ac719ebd2b108a4d342741706669d74ad}{m\_dropTrace} (packet);
309             \} 
310           \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (entry->IsAlive ()) 
311             \{
312               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"node="}<<\hyperlink{classns3_1_1ArpL3Protocol_aa1a2d173cfb3fd7e2f8eff8504a114da}{m\_node}->\hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} ()<<
313                             \textcolor{stringliteral}{", alive entry for "} << destination << \textcolor{stringliteral}{" valid -- send"});
314               *hardwareDestination = entry->GetMacAddress ();
315               \textcolor{keywordflow}{return} \textcolor{keyword}{true};
316             \} 
317           \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (entry->IsWaitReply ()) 
318             \{
319               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"node="}<<\hyperlink{classns3_1_1ArpL3Protocol_aa1a2d173cfb3fd7e2f8eff8504a114da}{m\_node}->\hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} ()<<
320                             \textcolor{stringliteral}{", wait reply for "} << destination << \textcolor{stringliteral}{" valid -- drop previous"});
321               \textcolor{keywordflow}{if} (!entry->UpdateWaitReply (\hyperlink{classns3_1_1ArpCache_ad018741a53ccc6cdb8b05fdd4873ef3d}{ArpCache::Ipv4PayloadHeaderPair} (
      packet, ipHeader)))
322                 \{
323                   \textcolor{comment}{// add the Ipv4 header for tracing purposes}
324                   packet->AddHeader (ipHeader);
325                   \hyperlink{classns3_1_1ArpL3Protocol_ac719ebd2b108a4d342741706669d74ad}{m\_dropTrace} (packet);
326                 \}
327             \}
328           \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (entry-> IsPermanent ())
329             \{
330               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"node="}<<\hyperlink{classns3_1_1ArpL3Protocol_aa1a2d173cfb3fd7e2f8eff8504a114da}{m\_node}->\hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} ()<<
331                             \textcolor{stringliteral}{", permanent for "} << destination << \textcolor{stringliteral}{"valid -- send"});
332               *hardwareDestination = entry->GetMacAddress ();
333               \textcolor{keywordflow}{return} \textcolor{keyword}{true};
334             \}
335           \textcolor{keywordflow}{else}
336             \{
337               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Test for possibly unreachable code-- please file a bug report,
       with a test case, if this is ever hit"});
338             \}
339         \}
340     \}
341   \textcolor{keywordflow}{else}
342     \{
343       \textcolor{comment}{// This is our first attempt to transmit data to this destination.}
344       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"node="}<<\hyperlink{classns3_1_1ArpL3Protocol_aa1a2d173cfb3fd7e2f8eff8504a114da}{m\_node}->\hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} ()<<
345                     \textcolor{stringliteral}{", no entry for "} << destination << \textcolor{stringliteral}{" -- send arp request"});
346       entry = cache->Add (destination);
347       entry->MarkWaitReply (\hyperlink{classns3_1_1ArpCache_ad018741a53ccc6cdb8b05fdd4873ef3d}{ArpCache::Ipv4PayloadHeaderPair} (packet, 
      ipHeader));
348       \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (\hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (
      \hyperlink{classns3_1_1ArpL3Protocol_a0d5144a236473eb6d7153600fdd7c5ee}{m\_requestJitter}->\hyperlink{classns3_1_1RandomVariableStream_a4fa5944dc4cb11544e661ed23072b36c}{GetValue} ())), &
      \hyperlink{classns3_1_1ArpL3Protocol_a9fe6faf0f82536ba2c14d5bdbf7469db}{ArpL3Protocol::SendArpRequest}, \textcolor{keyword}{this}, cache, destination);
349     \}
350   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
351 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7


\index{ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}!Notify\+New\+Aggregate@{Notify\+New\+Aggregate}}
\index{Notify\+New\+Aggregate@{Notify\+New\+Aggregate}!ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Notify\+New\+Aggregate()}{NotifyNewAggregate()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Arp\+L3\+Protocol\+::\+Notify\+New\+Aggregate (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1ArpL3Protocol_a6c0bd0b14a514f5abd0b0eff34020283}{}\label{classns3_1_1ArpL3Protocol_a6c0bd0b14a514f5abd0b0eff34020283}
Notify all Objects aggregated to this one of a new \hyperlink{classns3_1_1Object}{Object} being aggregated.

This method is invoked whenever two sets of Objects are aggregated together. It is invoked exactly once for each \hyperlink{classns3_1_1Object}{Object} in both sets. This method can be overriden by subclasses who wish to be notified of aggregation events. These subclasses must chain up to their base class \hyperlink{classns3_1_1ArpL3Protocol_a6c0bd0b14a514f5abd0b0eff34020283}{Notify\+New\+Aggregate()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} and \hyperlink{classns3_1_1Object_a79dd435d300f3deca814553f561a2922}{Aggregate\+Object()} from within this method.

This function must be implemented in the stack that needs to notify other stacks connected to the node of their presence in the node. 

Reimplemented from \hyperlink{classns3_1_1Object_a1bd7211125185a6cd511c35fea4e500f}{ns3\+::\+Object}.


\begin{DoxyCode}
104 \{
105   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
106   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1ArpL3Protocol_aa1a2d173cfb3fd7e2f8eff8504a114da}{m\_node} == 0)
107     \{
108       Ptr<Node>node = this->GetObject<Node> ();
109       \textcolor{comment}{//verify that it's a valid node and that}
110       \textcolor{comment}{//the node was not set before}
111       \textcolor{keywordflow}{if} (node != 0)
112         \{
113           this->\hyperlink{classns3_1_1ArpL3Protocol_a7100d6daf253d51bef7a49d9ea74446f}{SetNode} (node);
114         \}
115     \}
116   \hyperlink{classns3_1_1Object_a1bd7211125185a6cd511c35fea4e500f}{Object::NotifyNewAggregate} ();
117 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8


\index{ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}!operator=@{operator=}}
\index{operator=@{operator=}!ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{operator=(const Arp\+L3\+Protocol \&o)}{operator=(const ArpL3Protocol &o)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Arp\+L3\+Protocol}\& ns3\+::\+Arp\+L3\+Protocol\+::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf Arp\+L3\+Protocol} \&}]{o}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1ArpL3Protocol_a946112f849f17835faa7e3b017fc6dc6}{}\label{classns3_1_1ArpL3Protocol_a946112f849f17835faa7e3b017fc6dc6}


Copy constructor. 

Defined and unimplemented to avoid misuse 
\begin{DoxyParams}{Parameters}
{\em o} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\index{ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}!Receive@{Receive}}
\index{Receive@{Receive}!ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Receive(\+Ptr$<$ Net\+Device $>$ device, Ptr$<$ const Packet $>$ p, uint16\+\_\+t protocol, const Address \&from, const Address \&to, Net\+Device\+::\+Packet\+Type packet\+Type)}{Receive(Ptr< NetDevice > device, Ptr< const Packet > p, uint16_t protocol, const Address &from, const Address &to, NetDevice::PacketType packetType)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Arp\+L3\+Protocol\+::\+Receive (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{device, }
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p, }
\item[{uint16\+\_\+t}]{protocol, }
\item[{const {\bf Address} \&}]{from, }
\item[{const {\bf Address} \&}]{to, }
\item[{{\bf Net\+Device\+::\+Packet\+Type}}]{packet\+Type}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1ArpL3Protocol_a277509da885e127fb384f296f3858fef}{}\label{classns3_1_1ArpL3Protocol_a277509da885e127fb384f296f3858fef}


Receive a packet. 


\begin{DoxyParams}{Parameters}
{\em device} & the source \hyperlink{classns3_1_1NetDevice}{Net\+Device} \\
\hline
{\em p} & the packet \\
\hline
{\em protocol} & the protocol \\
\hline
{\em from} & the source address \\
\hline
{\em to} & the destination address \\
\hline
{\em packet\+Type} & type of packet (i.\+e., unicast, multicast, etc.) \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
166 \{
167   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << device << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->GetSize () << protocol << 
      \hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from} << to << packetType);
168 
169   Ptr<Packet> packet = \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->Copy ();
170 
171   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"ARP: received packet of size "}<< packet->GetSize ());
172 
173   Ptr<ArpCache> cache = \hyperlink{classns3_1_1ArpL3Protocol_a428dd13241d63395a5efbe68d6d9e667}{FindCache} (device);
174 
175   \textcolor{comment}{// }
176   \textcolor{comment}{// If we're connected to a real world network, then some of the fields sizes }
177   \textcolor{comment}{// in an ARP packet can vary in ways not seen in simulations.  We need to be}
178   \textcolor{comment}{// able to detect ARP packets with headers we don't recongnize and not process}
179   \textcolor{comment}{// them instead of crashing.  The ArpHeader will return 0 if it can't deal}
180   \textcolor{comment}{// with the received header.}
181   \textcolor{comment}{//}
182   ArpHeader arp;
183   uint32\_t size = packet->RemoveHeader (arp);
184   \textcolor{keywordflow}{if} (size == 0)
185     \{
186       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"ARP: Cannot remove ARP header"});
187       \textcolor{keywordflow}{return};
188     \}
189   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"ARP: received "} << (arp.IsRequest () ? \textcolor{stringliteral}{"request"} : \textcolor{stringliteral}{"reply"}) <<
190                 \textcolor{stringliteral}{" node="} << \hyperlink{classns3_1_1ArpL3Protocol_aa1a2d173cfb3fd7e2f8eff8504a114da}{m\_node}->\hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} () <<
191                 \textcolor{stringliteral}{", got "} <<
192                 (arp.IsRequest () ? \textcolor{stringliteral}{"request"} : \textcolor{stringliteral}{"reply"}) <<
193                 \textcolor{stringliteral}{" from "} << arp.GetSourceIpv4Address () <<
194                 \textcolor{stringliteral}{" for address "} << arp.GetDestinationIpv4Address () <<
195                 \textcolor{stringliteral}{"; we have addresses: "});
196   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < cache->GetInterface ()->GetNAddresses (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
197     \{
198       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (cache->GetInterface ()->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}).GetLocal () << \textcolor{stringliteral}{", "});
199     \}
200 
206   \textcolor{keywordtype}{bool} found = \textcolor{keyword}{false};
207   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < cache->GetInterface ()->GetNAddresses (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
208     \{
209       \textcolor{keywordflow}{if} (arp.IsRequest () && arp.GetDestinationIpv4Address () == 
210           cache->GetInterface ()->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}).GetLocal ())
211         \{
212           found = \textcolor{keyword}{true};
213           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"node="}<<\hyperlink{classns3_1_1ArpL3Protocol_aa1a2d173cfb3fd7e2f8eff8504a114da}{m\_node}->\hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} () <<\textcolor{stringliteral}{", got request from "} << 
214                         arp.GetSourceIpv4Address () << \textcolor{stringliteral}{" -- send reply"});
215           \hyperlink{classns3_1_1ArpL3Protocol_a2e1f058ec7982637902e91cb2e63b12c}{SendArpReply} (cache, arp.GetDestinationIpv4Address (), arp.GetSourceIpv4Address (),
216                         arp.GetSourceHardwareAddress ());
217           \textcolor{keywordflow}{break};
218         \} 
219       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arp.IsReply () && 
220                arp.GetDestinationIpv4Address ().IsEqual (cache->GetInterface ()->GetAddress (
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}).GetLocal ()) &&
221                arp.GetDestinationHardwareAddress () == device->GetAddress ())
222         \{
223           found = \textcolor{keyword}{true};
224           Ipv4Address \hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from} = arp.GetSourceIpv4Address ();
225           ArpCache::Entry *entry = cache->Lookup (from);
226           \textcolor{keywordflow}{if} (entry != 0)
227             \{
228               \textcolor{keywordflow}{if} (entry->IsWaitReply ()) 
229                 \{
230                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"node="}<< \hyperlink{classns3_1_1ArpL3Protocol_aa1a2d173cfb3fd7e2f8eff8504a114da}{m\_node}->\hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} () << 
231                                 \textcolor{stringliteral}{", got reply from "} << arp.GetSourceIpv4Address ()
232                                        << \textcolor{stringliteral}{" for waiting entry -- flush"});
233                   Address from\_mac = arp.GetSourceHardwareAddress ();
234                   entry->MarkAlive (from\_mac);
235                   \hyperlink{classns3_1_1ArpCache_ad018741a53ccc6cdb8b05fdd4873ef3d}{ArpCache::Ipv4PayloadHeaderPair} pending = entry->
      DequeuePending ();
236                   \textcolor{keywordflow}{while} (pending.first != 0)
237                     \{
238                       cache->GetInterface ()->Send (pending.first, pending.second,
239                                                     arp.GetSourceIpv4Address ());
240                       pending = entry->DequeuePending ();
241                     \}
242                 \} 
243               \textcolor{keywordflow}{else} 
244                 \{
245                   \textcolor{comment}{// ignore this reply which might well be an attempt }
246                   \textcolor{comment}{// at poisening my arp cache.}
247                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"node="}<<\hyperlink{classns3_1_1ArpL3Protocol_aa1a2d173cfb3fd7e2f8eff8504a114da}{m\_node}->\hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} ()<<\textcolor{stringliteral}{", got reply from "} <<
248                                 arp.GetSourceIpv4Address () <<
249                                 \textcolor{stringliteral}{" for non-waiting entry -- drop"});
250                   \hyperlink{classns3_1_1ArpL3Protocol_ac719ebd2b108a4d342741706669d74ad}{m\_dropTrace} (packet);
251                 \}
252             \} 
253           \textcolor{keywordflow}{else} 
254             \{
255               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"node="}<<\hyperlink{classns3_1_1ArpL3Protocol_aa1a2d173cfb3fd7e2f8eff8504a114da}{m\_node}->\hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} ()<<\textcolor{stringliteral}{", got reply for unknown
       entry -- drop"});
256               \hyperlink{classns3_1_1ArpL3Protocol_ac719ebd2b108a4d342741706669d74ad}{m\_dropTrace} (packet);
257             \}
258           \textcolor{keywordflow}{break};
259         \}
260     \}
261   \textcolor{keywordflow}{if} (found == \textcolor{keyword}{false})
262     \{
263       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"node="}<<\hyperlink{classns3_1_1ArpL3Protocol_aa1a2d173cfb3fd7e2f8eff8504a114da}{m\_node}->\hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} ()<<\textcolor{stringliteral}{", got request from "} <<
264                     arp.GetSourceIpv4Address () << \textcolor{stringliteral}{" for unknown address "} <<
265                     arp.GetDestinationIpv4Address () << \textcolor{stringliteral}{" -- drop"});
266     \}
267 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9




Here is the caller graph for this function\+:
% FIG 10


\index{ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}!Send\+Arp\+Reply@{Send\+Arp\+Reply}}
\index{Send\+Arp\+Reply@{Send\+Arp\+Reply}!ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Arp\+Reply(\+Ptr$<$ const Arp\+Cache $>$ cache, Ipv4\+Address my\+Ip, Ipv4\+Address to\+Ip, Address to\+Mac)}{SendArpReply(Ptr< const ArpCache > cache, Ipv4Address myIp, Ipv4Address toIp, Address toMac)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Arp\+L3\+Protocol\+::\+Send\+Arp\+Reply (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Arp\+Cache} $>$}]{cache, }
\item[{{\bf Ipv4\+Address}}]{my\+Ip, }
\item[{{\bf Ipv4\+Address}}]{to\+Ip, }
\item[{{\bf Address}}]{to\+Mac}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1ArpL3Protocol_a2e1f058ec7982637902e91cb2e63b12c}{}\label{classns3_1_1ArpL3Protocol_a2e1f058ec7982637902e91cb2e63b12c}


Send an A\+RP reply to an host. 


\begin{DoxyParams}{Parameters}
{\em cache} & the A\+RP cache to use \\
\hline
{\em my\+Ip} & the source IP address \\
\hline
{\em to\+Ip} & the destination IP \\
\hline
{\em to\+Mac} & the destination M\+AC address \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
376 \{
377   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << cache << myIp << toIp << toMac);
378   ArpHeader arp;
379   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"ARP: sending reply from node "}<<\hyperlink{classns3_1_1ArpL3Protocol_aa1a2d173cfb3fd7e2f8eff8504a114da}{m\_node}->\hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} ()<<
380                 \textcolor{stringliteral}{"|| src: "} << cache->GetDevice ()->GetAddress () <<
381                 \textcolor{stringliteral}{" / "} << myIp <<
382                 \textcolor{stringliteral}{" || dst: "} << toMac << \textcolor{stringliteral}{" / "} << toIp);
383   arp.SetReply (cache->GetDevice ()->GetAddress (), myIp, toMac, toIp);
384   Ptr<Packet> packet = Create<Packet> ();
385   packet->AddHeader (arp);
386   cache->GetDevice ()->Send (packet, toMac, \hyperlink{classns3_1_1ArpL3Protocol_a836aec5bc5e5a8ea1d7f46609dc9cc2c}{PROT\_NUMBER});
387 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 11




Here is the caller graph for this function\+:
% FIG 12


\index{ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}!Send\+Arp\+Request@{Send\+Arp\+Request}}
\index{Send\+Arp\+Request@{Send\+Arp\+Request}!ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Arp\+Request(\+Ptr$<$ const Arp\+Cache $>$cache, Ipv4\+Address to)}{SendArpRequest(Ptr< const ArpCache >cache, Ipv4Address to)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Arp\+L3\+Protocol\+::\+Send\+Arp\+Request (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Arp\+Cache} $>$}]{cache, }
\item[{{\bf Ipv4\+Address}}]{to}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1ArpL3Protocol_a9fe6faf0f82536ba2c14d5bdbf7469db}{}\label{classns3_1_1ArpL3Protocol_a9fe6faf0f82536ba2c14d5bdbf7469db}


Send an A\+RP request to an host. 


\begin{DoxyParams}{Parameters}
{\em cache} & the A\+RP cache to use \\
\hline
{\em to} & the destination IP \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
355 \{
356   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << cache << to);
357   ArpHeader arp;
358   \textcolor{comment}{// need to pick a source address; use routing implementation to select}
359   Ptr<Ipv4L3Protocol> ipv4 = \hyperlink{classns3_1_1ArpL3Protocol_aa1a2d173cfb3fd7e2f8eff8504a114da}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv4L3Protocol> ();
360   Ptr<NetDevice> device = cache->GetDevice ();
361   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (device != 0);
362   Ipv4Header header;
363   header.SetDestination (to);
364   Ptr<Packet> packet = Create<Packet> ();
365   Ipv4Address source = ipv4->SelectSourceAddress (device,  to, 
      \hyperlink{classns3_1_1Ipv4InterfaceAddress_a329cea433e74f717c26c9e51c4fcd3d8ae144856017bcfb529872c91204d462b2}{Ipv4InterfaceAddress::GLOBAL});
366   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"ARP: sending request from node "}<<\hyperlink{classns3_1_1ArpL3Protocol_aa1a2d173cfb3fd7e2f8eff8504a114da}{m\_node}->
      \hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} ()<<
367                 \textcolor{stringliteral}{" || src: "} << device->GetAddress () << \textcolor{stringliteral}{" / "} << source <<
368                 \textcolor{stringliteral}{" || dst: "} << device->GetBroadcast () << \textcolor{stringliteral}{" / "} << to);
369   arp.SetRequest (device->GetAddress (), source, device->GetBroadcast (), to);
370   packet->AddHeader (arp);
371   cache->GetDevice ()->Send (packet, device->GetBroadcast (), \hyperlink{classns3_1_1ArpL3Protocol_a836aec5bc5e5a8ea1d7f46609dc9cc2c}{PROT\_NUMBER});
372 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13




Here is the caller graph for this function\+:
% FIG 14


\index{ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}!Set\+Node@{Set\+Node}}
\index{Set\+Node@{Set\+Node}!ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Node(\+Ptr$<$ Node $>$ node)}{SetNode(Ptr< Node > node)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Arp\+L3\+Protocol\+::\+Set\+Node (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1ArpL3Protocol_a7100d6daf253d51bef7a49d9ea74446f}{}\label{classns3_1_1ArpL3Protocol_a7100d6daf253d51bef7a49d9ea74446f}


Set the node the A\+RP L3 protocol is associated with. 


\begin{DoxyParams}{Parameters}
{\em node} & the node \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
93 \{
94   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << node);
95   \hyperlink{classns3_1_1ArpL3Protocol_aa1a2d173cfb3fd7e2f8eff8504a114da}{m\_node} = node;
96 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 15




\subsection{Member Data Documentation}
\index{ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}!m\+\_\+cache\+List@{m\+\_\+cache\+List}}
\index{m\+\_\+cache\+List@{m\+\_\+cache\+List}!ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+cache\+List}{m_cacheList}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cache\+List} ns3\+::\+Arp\+L3\+Protocol\+::m\+\_\+cache\+List\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1ArpL3Protocol_a369682dd4e6568e6e5731d61147596c7}{}\label{classns3_1_1ArpL3Protocol_a369682dd4e6568e6e5731d61147596c7}


A\+RP cache container. 

\index{ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}!m\+\_\+drop\+Trace@{m\+\_\+drop\+Trace}}
\index{m\+\_\+drop\+Trace@{m\+\_\+drop\+Trace}!ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+drop\+Trace}{m_dropTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Arp\+L3\+Protocol\+::m\+\_\+drop\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1ArpL3Protocol_ac719ebd2b108a4d342741706669d74ad}{}\label{classns3_1_1ArpL3Protocol_ac719ebd2b108a4d342741706669d74ad}


trace for packets dropped by A\+RP 

\index{ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}!m\+\_\+node@{m\+\_\+node}}
\index{m\+\_\+node@{m\+\_\+node}!ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+node}{m_node}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Node}$>$ ns3\+::\+Arp\+L3\+Protocol\+::m\+\_\+node\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1ArpL3Protocol_aa1a2d173cfb3fd7e2f8eff8504a114da}{}\label{classns3_1_1ArpL3Protocol_aa1a2d173cfb3fd7e2f8eff8504a114da}


node the A\+RP L3 protocol is associated with 

\index{ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}!m\+\_\+request\+Jitter@{m\+\_\+request\+Jitter}}
\index{m\+\_\+request\+Jitter@{m\+\_\+request\+Jitter}!ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+request\+Jitter}{m_requestJitter}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Random\+Variable\+Stream}$>$ ns3\+::\+Arp\+L3\+Protocol\+::m\+\_\+request\+Jitter\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1ArpL3Protocol_a0d5144a236473eb6d7153600fdd7c5ee}{}\label{classns3_1_1ArpL3Protocol_a0d5144a236473eb6d7153600fdd7c5ee}


jitter to de-\/sync A\+RP requests 

\index{ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}!P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER@{P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER}}
\index{P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER@{P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER}!ns3\+::\+Arp\+L3\+Protocol@{ns3\+::\+Arp\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER}{PROT_NUMBER}}]{\setlength{\rightskip}{0pt plus 5cm}const uint16\+\_\+t ns3\+::\+Arp\+L3\+Protocol\+::\+P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER = 0x0806\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1ArpL3Protocol_a836aec5bc5e5a8ea1d7f46609dc9cc2c}{}\label{classns3_1_1ArpL3Protocol_a836aec5bc5e5a8ea1d7f46609dc9cc2c}


A\+RP protocol number (0x0806) 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/model/\hyperlink{arp-l3-protocol_8h}{arp-\/l3-\/protocol.\+h}\item 
internet/model/\hyperlink{arp-l3-protocol_8cc}{arp-\/l3-\/protocol.\+cc}\end{DoxyCompactItemize}
