\hypertarget{classns3_1_1Ipv4RawSocketImpl}{}\section{ns3\+:\+:Ipv4\+Raw\+Socket\+Impl Class Reference}
\label{classns3_1_1Ipv4RawSocketImpl}\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}


I\+Pv4 raw socket.  




{\ttfamily \#include $<$ipv4-\/raw-\/socket-\/impl.\+h$>$}



Inheritance diagram for ns3\+:\+:Ipv4\+Raw\+Socket\+Impl\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Ipv4\+Raw\+Socket\+Impl\+:
% FIG 1
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structns3_1_1Ipv4RawSocketImpl_1_1Data}{Data}
\begin{DoxyCompactList}\small\item\em I\+Pv4 raw data and additional information. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ipv4RawSocketImpl_a05d9647c8aa25b5092c79f5efc3a056c}{Ipv4\+Raw\+Socket\+Impl} ()
\item 
void \hyperlink{classns3_1_1Ipv4RawSocketImpl_ac850bf9f93f91f53ed184c09d95cf371}{Set\+Node} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node)
\begin{DoxyCompactList}\small\item\em Set the node associated with this socket. \end{DoxyCompactList}\item 
virtual enum \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket\+::\+Socket\+Errno} \hyperlink{classns3_1_1Ipv4RawSocketImpl_acfda80b470cc0359b70363f5dbc89a5a}{Get\+Errno} () const 
\begin{DoxyCompactList}\small\item\em Get last error number. \end{DoxyCompactList}\item 
virtual enum \hyperlink{classns3_1_1Socket_a698fbcc486a48b7a0d2b0e4ab863d571}{Socket\+::\+Socket\+Type} \hyperlink{classns3_1_1Ipv4RawSocketImpl_a38d738344a763f0aea530327034dc035}{Get\+Socket\+Type} (void) const 
\begin{DoxyCompactList}\small\item\em Get socket type (N\+S3\+\_\+\+S\+O\+C\+K\+\_\+\+R\+AW) \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1Ipv4RawSocketImpl_a7965179773962e28a388a1601e435d74}{Get\+Node} (void) const 
\begin{DoxyCompactList}\small\item\em Return the node this socket is associated with. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1Ipv4RawSocketImpl_a6edf52089c447383a89757569764d106}{Bind} (const \hyperlink{classns3_1_1Address}{Address} \&address)
\begin{DoxyCompactList}\small\item\em Allocate a local endpoint for this socket. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1Ipv4RawSocketImpl_a27cdb0c4cb9eb66cce01994bee87e3f5}{Bind} ()
\begin{DoxyCompactList}\small\item\em Allocate a local I\+Pv4 endpoint for this socket. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1Ipv4RawSocketImpl_acf7c964361e76d56b075187218ce2f79}{Bind6} ()
\begin{DoxyCompactList}\small\item\em Allocate a local I\+Pv6 endpoint for this socket. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1Ipv4RawSocketImpl_a4ac52521f511da9302c945d02ef07e23}{Get\+Sock\+Name} (\hyperlink{classns3_1_1Address}{Address} \&address) const 
\begin{DoxyCompactList}\small\item\em Get socket address. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1Ipv4RawSocketImpl_a04075494f8324b8b3ab2009d5a1d1544}{Get\+Peer\+Name} (\hyperlink{classns3_1_1Address}{Address} \&address) const 
\begin{DoxyCompactList}\small\item\em Get the peer address of a connected socket. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1Ipv4RawSocketImpl_a88af5a05d05f4fdfb38e1822040805e3}{Close} (void)
\begin{DoxyCompactList}\small\item\em Close a socket. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1Ipv4RawSocketImpl_a0d2cac5efa380545ea53036caf95eceb}{Shutdown\+Send} (void)
\item 
virtual int \hyperlink{classns3_1_1Ipv4RawSocketImpl_a196a3b1bc9339211fcaedb7ead4c5039}{Shutdown\+Recv} (void)
\item 
virtual int \hyperlink{classns3_1_1Ipv4RawSocketImpl_a2bcbab838c6120e3e8ac70fac807c168}{Connect} (const \hyperlink{classns3_1_1Address}{Address} \&address)
\begin{DoxyCompactList}\small\item\em Initiate a connection to a remote host. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1Ipv4RawSocketImpl_aa72df8f117a1d5ba69b7591b2bd9245e}{Listen} (void)
\begin{DoxyCompactList}\small\item\em Listen for incoming connections. \end{DoxyCompactList}\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1Ipv4RawSocketImpl_afa925ad3c6fef990ec72b4ee5c0cbc2b}{Get\+Tx\+Available} (void) const 
\begin{DoxyCompactList}\small\item\em Returns the number of bytes which can be sent in a single call to Send. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1Ipv4RawSocketImpl_ae43d27d4aa516a4cacbe8f0f4f688110}{Send} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, uint32\+\_\+t flags)
\begin{DoxyCompactList}\small\item\em Send data (or dummy data) to the remote host. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1Ipv4RawSocketImpl_a06fd568d5988700a423fb2203e0aa0bf}{Send\+To} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, uint32\+\_\+t flags, const \hyperlink{classns3_1_1Address}{Address} \&to\+Address)
\begin{DoxyCompactList}\small\item\em Send data to a specified peer. \end{DoxyCompactList}\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1Ipv4RawSocketImpl_aecf377d782a4109f15952c7cccfb6f2c}{Get\+Rx\+Available} (void) const 
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{classns3_1_1Ipv4RawSocketImpl_a4716d2ee63765d9b4a35592800a20d35}{Recv} (uint32\+\_\+t max\+Size, uint32\+\_\+t flags)
\begin{DoxyCompactList}\small\item\em Read data from the socket. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{classns3_1_1Ipv4RawSocketImpl_a4a004b1ebdcb92d83ee083cdd5543a56}{Recv\+From} (uint32\+\_\+t max\+Size, uint32\+\_\+t flags, \hyperlink{classns3_1_1Address}{Address} \&from\+Address)
\begin{DoxyCompactList}\small\item\em Read a single packet from the socket and retrieve the sender address. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4RawSocketImpl_a7c5a00ba94fee5acefd972c71517062b}{Set\+Protocol} (uint16\+\_\+t protocol)
\begin{DoxyCompactList}\small\item\em Set protocol field. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Ipv4RawSocketImpl_ab4fc4f9979027503156102d42ec62e9b}{Forward\+Up} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} ip\+Header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} $>$ incoming\+Interface)
\begin{DoxyCompactList}\small\item\em Forward up to receive method. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1Ipv4RawSocketImpl_aa7089a120a9c1b5bbb2cb19ff204b5de}{Set\+Allow\+Broadcast} (bool allow\+Broadcast)
\begin{DoxyCompactList}\small\item\em Configure whether broadcast datagram transmissions are allowed. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1Ipv4RawSocketImpl_ac1345101c6fd1f1ba8f7c05a326faab3}{Get\+Allow\+Broadcast} () const 
\begin{DoxyCompactList}\small\item\em Query whether broadcast datagram transmissions are allowed. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1Ipv4RawSocketImpl_a3d0791fa8fd3fb01db1e860ad259e21b}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID of this class. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1Ipv4RawSocketImpl_a31afca0d33e216abc3077b76880b47e7}{Do\+Dispose} (void)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket\+::\+Socket\+Errno} \hyperlink{classns3_1_1Ipv4RawSocketImpl_aae08c8798140ad6193ad2fc7ab1efbed}{m\+\_\+err}
\begin{DoxyCompactList}\small\item\em Last error number. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1Ipv4RawSocketImpl_af8cdf6f27af43b69c0616b90e9f3af98}{m\+\_\+node}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Node}{Node}. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \hyperlink{classns3_1_1Ipv4RawSocketImpl_a1881de88180f919a385b14db64b93932}{m\+\_\+src}
\begin{DoxyCompactList}\small\item\em Source address. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \hyperlink{classns3_1_1Ipv4RawSocketImpl_a36a7c8ea8152272b055706247b97bef2}{m\+\_\+dst}
\begin{DoxyCompactList}\small\item\em Destination address. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1Ipv4RawSocketImpl_a924effb0eb9a6cbbf1daeb3a7b7ffc94}{m\+\_\+protocol}
\begin{DoxyCompactList}\small\item\em Protocol. \end{DoxyCompactList}\item 
\hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ struct \hyperlink{structns3_1_1Ipv4RawSocketImpl_1_1Data}{Data} $>$ \hyperlink{classns3_1_1Ipv4RawSocketImpl_a460de0afa7bc2d11b5e54cf23e361173}{m\+\_\+recv}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Packet}{Packet} waiting to be processed. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Ipv4RawSocketImpl_adc89037fdb02fa149e063882c499dfb8}{m\+\_\+shutdown\+Send}
\begin{DoxyCompactList}\small\item\em Flag to shutdown send capability. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Ipv4RawSocketImpl_abb193a17208627ab4f74a9a95e0ef6e9}{m\+\_\+shutdown\+Recv}
\begin{DoxyCompactList}\small\item\em Flag to shutdown receive capability. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1Ipv4RawSocketImpl_ab80bb1194c37a7489b342156a7bfcb92}{m\+\_\+icmp\+Filter}
\begin{DoxyCompactList}\small\item\em I\+C\+M\+Pv4 filter specification. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Ipv4RawSocketImpl_a895d0929c6fb2c111f99e83a8b7516fc}{m\+\_\+iphdrincl}
\begin{DoxyCompactList}\small\item\em Include IP \hyperlink{classns3_1_1Header}{Header} information (a.\+k.\+a setsockopt (I\+P\+\_\+\+H\+D\+R\+I\+N\+CL)) \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
I\+Pv4 raw socket. 

A R\+AW \hyperlink{classns3_1_1Socket}{Socket} typically is used to access specific IP layers not usually available through L4 sockets, e.\+g., I\+C\+MP. The implementer should take particular care to define the \hyperlink{classns3_1_1Ipv4RawSocketImpl}{Ipv4\+Raw\+Socket\+Impl} Attributes, and in particular the Protocol attribute. 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!Ipv4\+Raw\+Socket\+Impl@{Ipv4\+Raw\+Socket\+Impl}}
\index{Ipv4\+Raw\+Socket\+Impl@{Ipv4\+Raw\+Socket\+Impl}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Ipv4\+Raw\+Socket\+Impl()}{Ipv4RawSocketImpl()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::\+Ipv4\+Raw\+Socket\+Impl (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4RawSocketImpl_a05d9647c8aa25b5092c79f5efc3a056c}{}\label{classns3_1_1Ipv4RawSocketImpl_a05d9647c8aa25b5092c79f5efc3a056c}

\begin{DoxyCode}
55 \{
56   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
57   \hyperlink{classns3_1_1Ipv4RawSocketImpl_aae08c8798140ad6193ad2fc7ab1efbed}{m\_err} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaaa7eb006d73c5ad0117c5591fcb3469f7}{Socket::ERROR\_NOTERROR};
58   \hyperlink{classns3_1_1Ipv4RawSocketImpl_af8cdf6f27af43b69c0616b90e9f3af98}{m\_node} = 0;
59   \hyperlink{classns3_1_1Ipv4RawSocketImpl_a1881de88180f919a385b14db64b93932}{m\_src} = \hyperlink{classns3_1_1Ipv4Address_a7a39b330c8e701183a411d5779fca1a4}{Ipv4Address::GetAny} ();
60   \hyperlink{classns3_1_1Ipv4RawSocketImpl_a36a7c8ea8152272b055706247b97bef2}{m\_dst} = \hyperlink{classns3_1_1Ipv4Address_a7a39b330c8e701183a411d5779fca1a4}{Ipv4Address::GetAny} ();
61   \hyperlink{classns3_1_1Ipv4RawSocketImpl_a924effb0eb9a6cbbf1daeb3a7b7ffc94}{m\_protocol} = 0;
62   \hyperlink{classns3_1_1Ipv4RawSocketImpl_adc89037fdb02fa149e063882c499dfb8}{m\_shutdownSend} = \textcolor{keyword}{false};
63   \hyperlink{classns3_1_1Ipv4RawSocketImpl_abb193a17208627ab4f74a9a95e0ef6e9}{m\_shutdownRecv} = \textcolor{keyword}{false};
64 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2




\subsection{Member Function Documentation}
\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!Bind@{Bind}}
\index{Bind@{Bind}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Bind(const Address \&address)}{Bind(const Address &address)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::\+Bind (
\begin{DoxyParamCaption}
\item[{const {\bf Address} \&}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_a6edf52089c447383a89757569764d106}{}\label{classns3_1_1Ipv4RawSocketImpl_a6edf52089c447383a89757569764d106}


Allocate a local endpoint for this socket. 


\begin{DoxyParams}{Parameters}
{\em address} & the address to try to allocate \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, -\/1 on failure. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_ada93439a43de2028b5a8fc6621dad482}{ns3\+::\+Socket}.


\begin{DoxyCode}
103 \{
104   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << address);
105   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1InetSocketAddress_a9426766e34e928ce5dbdbeb9563a10df}{InetSocketAddress::IsMatchingType} (address))
106     \{
107       \hyperlink{classns3_1_1Ipv4RawSocketImpl_aae08c8798140ad6193ad2fc7ab1efbed}{m\_err} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa4b98dd50740861229f8e03bcc36d379b}{Socket::ERROR\_INVAL};
108       \textcolor{keywordflow}{return} -1;
109     \}
110   InetSocketAddress ad = \hyperlink{classns3_1_1InetSocketAddress_ade776b1109e7b9a7be0b22ced49931e3}{InetSocketAddress::ConvertFrom} (address);
111   \hyperlink{classns3_1_1Ipv4RawSocketImpl_a1881de88180f919a385b14db64b93932}{m\_src} = ad.GetIpv4 ();
112   \textcolor{keywordflow}{return} 0;
113 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!Bind@{Bind}}
\index{Bind@{Bind}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Bind()}{Bind()}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::\+Bind (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_a27cdb0c4cb9eb66cce01994bee87e3f5}{}\label{classns3_1_1Ipv4RawSocketImpl_a27cdb0c4cb9eb66cce01994bee87e3f5}


Allocate a local I\+Pv4 endpoint for this socket. 

\begin{DoxyReturn}{Returns}
0 on success, -\/1 on failure. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_a680c1edd8b3ec3adf4085e1ded1e8a0d}{ns3\+::\+Socket}.


\begin{DoxyCode}
116 \{
117   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
118   \hyperlink{classns3_1_1Ipv4RawSocketImpl_a1881de88180f919a385b14db64b93932}{m\_src} = \hyperlink{classns3_1_1Ipv4Address_a7a39b330c8e701183a411d5779fca1a4}{Ipv4Address::GetAny} ();
119   \textcolor{keywordflow}{return} 0;
120 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4


\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!Bind6@{Bind6}}
\index{Bind6@{Bind6}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Bind6()}{Bind6()}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::\+Bind6 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_acf7c964361e76d56b075187218ce2f79}{}\label{classns3_1_1Ipv4RawSocketImpl_acf7c964361e76d56b075187218ce2f79}


Allocate a local I\+Pv6 endpoint for this socket. 

\begin{DoxyReturn}{Returns}
0 on success, -\/1 on failure. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_a68a4f2bcd38dec94d5a6fd4d867a1f19}{ns3\+::\+Socket}.


\begin{DoxyCode}
123 \{
124   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
125   \textcolor{keywordflow}{return} (-1);
126 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!Close@{Close}}
\index{Close@{Close}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Close(void)}{Close(void)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::\+Close (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_a88af5a05d05f4fdfb38e1822040805e3}{}\label{classns3_1_1Ipv4RawSocketImpl_a88af5a05d05f4fdfb38e1822040805e3}


Close a socket. 

\begin{DoxyReturn}{Returns}
zero on success, -\/1 on failure.
\end{DoxyReturn}
After the Close call, the socket is no longer valid, and cannot safely be used for subsequent operations. 

Implements \hyperlink{classns3_1_1Socket_abdac6e2498c5aa2963ef361d4200ddf3}{ns3\+::\+Socket}.


\begin{DoxyCode}
151 \{
152   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
153   Ptr<Ipv4> ipv4 = \hyperlink{classns3_1_1Ipv4RawSocketImpl_af8cdf6f27af43b69c0616b90e9f3af98}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv4> ();
154   \textcolor{keywordflow}{if} (ipv4 != 0)
155     \{
156       ipv4->DeleteRawSocket (\textcolor{keyword}{this});
157     \}
158   \textcolor{keywordflow}{return} 0;
159 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5


\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!Connect@{Connect}}
\index{Connect@{Connect}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Connect(const Address \&address)}{Connect(const Address &address)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::\+Connect (
\begin{DoxyParamCaption}
\item[{const {\bf Address} \&}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_a2bcbab838c6120e3e8ac70fac807c168}{}\label{classns3_1_1Ipv4RawSocketImpl_a2bcbab838c6120e3e8ac70fac807c168}


Initiate a connection to a remote host. 


\begin{DoxyParams}{Parameters}
{\em address} & \hyperlink{classns3_1_1Address}{Address} of remote. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, -\/1 on error (in which case errno is set). 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_a97f08aaf37b8fd7d4b5cad4dfdd4022a}{ns3\+::\+Socket}.


\begin{DoxyCode}
176 \{
177   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << address);
178   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1InetSocketAddress_a9426766e34e928ce5dbdbeb9563a10df}{InetSocketAddress::IsMatchingType} (address))
179     \{
180       \hyperlink{classns3_1_1Ipv4RawSocketImpl_aae08c8798140ad6193ad2fc7ab1efbed}{m\_err} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa4b98dd50740861229f8e03bcc36d379b}{Socket::ERROR\_INVAL};
181       \textcolor{keywordflow}{return} -1;
182     \}
183   InetSocketAddress ad = \hyperlink{classns3_1_1InetSocketAddress_ade776b1109e7b9a7be0b22ced49931e3}{InetSocketAddress::ConvertFrom} (address);
184   \hyperlink{classns3_1_1Ipv4RawSocketImpl_a36a7c8ea8152272b055706247b97bef2}{m\_dst} = ad.GetIpv4 ();
185   \hyperlink{classns3_1_1Socket_a2a21a2d166ec2adf766b84d984d1cf65}{SetIpTos} (ad.GetTos ());
186 
187   \textcolor{keywordflow}{return} 0;
188 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6


\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Do\+Dispose(void)}{DoDispose(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_a31afca0d33e216abc3077b76880b47e7}{}\label{classns3_1_1Ipv4RawSocketImpl_a31afca0d33e216abc3077b76880b47e7}
Destructor implementation.

This method is called by \hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose()} or by the \hyperlink{classns3_1_1Object}{Object}\textquotesingle{}s destructor, whichever comes first.

Subclasses are expected to implement their real destruction code in an overriden version of this method and chain up to their parent\textquotesingle{}s implementation once they are done. {\itshape i.\+e}, for simplicity, the destructor of every subclass should be empty and its content should be moved to the associated \hyperlink{classns3_1_1Ipv4RawSocketImpl_a31afca0d33e216abc3077b76880b47e7}{Do\+Dispose()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Socket_a5498f836b9b551dd7069562d05382e83}{ns3\+::\+Socket}.


\begin{DoxyCode}
75 \{
76   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
77   \hyperlink{classns3_1_1Ipv4RawSocketImpl_af8cdf6f27af43b69c0616b90e9f3af98}{m\_node} = 0;
78   \hyperlink{classns3_1_1Socket_a5498f836b9b551dd7069562d05382e83}{Socket::DoDispose} ();
79 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7


\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!Forward\+Up@{Forward\+Up}}
\index{Forward\+Up@{Forward\+Up}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Forward\+Up(\+Ptr$<$ const Packet $>$ p, Ipv4\+Header ip\+Header, Ptr$<$ Ipv4\+Interface $>$ incoming\+Interface)}{ForwardUp(Ptr< const Packet > p, Ipv4Header ipHeader, Ptr< Ipv4Interface > incomingInterface)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::\+Forward\+Up (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p, }
\item[{{\bf Ipv4\+Header}}]{ip\+Header, }
\item[{{\bf Ptr}$<$ {\bf Ipv4\+Interface} $>$}]{incoming\+Interface}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4RawSocketImpl_ab4fc4f9979027503156102d42ec62e9b}{}\label{classns3_1_1Ipv4RawSocketImpl_ab4fc4f9979027503156102d42ec62e9b}


Forward up to receive method. 


\begin{DoxyParams}{Parameters}
{\em p} & packet \\
\hline
{\em ip\+Header} & I\+Pv4 header \\
\hline
{\em incoming\+Interface} & incoming interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if forwarded, false otherwise 
\end{DoxyReturn}

\begin{DoxyCode}
416 \{
417   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << *\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} << ipHeader << incomingInterface);
418   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4RawSocketImpl_abb193a17208627ab4f74a9a95e0ef6e9}{m\_shutdownRecv})
419     \{
420       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
421     \}
422 
423   Ptr<NetDevice> boundNetDevice = \hyperlink{classns3_1_1Socket_a04ae6be2aded03caaa262e274dc8a2fd}{Socket::GetBoundNetDevice}();
424   \textcolor{keywordflow}{if} (boundNetDevice)
425     \{
426       \textcolor{keywordflow}{if} (boundNetDevice != incomingInterface->GetDevice())
427         \{
428           \textcolor{keywordflow}{return} \textcolor{keyword}{false};
429         \}
430     \}
431 
432   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"src = "} << \hyperlink{classns3_1_1Ipv4RawSocketImpl_a1881de88180f919a385b14db64b93932}{m\_src} << \textcolor{stringliteral}{" dst = "} << \hyperlink{classns3_1_1Ipv4RawSocketImpl_a36a7c8ea8152272b055706247b97bef2}{m\_dst});
433   \textcolor{keywordflow}{if} ((\hyperlink{classns3_1_1Ipv4RawSocketImpl_a1881de88180f919a385b14db64b93932}{m\_src} == \hyperlink{classns3_1_1Ipv4Address_a7a39b330c8e701183a411d5779fca1a4}{Ipv4Address::GetAny} () || ipHeader.GetDestination () == 
      \hyperlink{classns3_1_1Ipv4RawSocketImpl_a1881de88180f919a385b14db64b93932}{m\_src}) &&
434       (\hyperlink{classns3_1_1Ipv4RawSocketImpl_a36a7c8ea8152272b055706247b97bef2}{m\_dst} == \hyperlink{classns3_1_1Ipv4Address_a7a39b330c8e701183a411d5779fca1a4}{Ipv4Address::GetAny} () || ipHeader.GetSource () == 
      \hyperlink{classns3_1_1Ipv4RawSocketImpl_a36a7c8ea8152272b055706247b97bef2}{m\_dst}) &&
435       ipHeader.GetProtocol () == \hyperlink{classns3_1_1Ipv4RawSocketImpl_a924effb0eb9a6cbbf1daeb3a7b7ffc94}{m\_protocol})
436     \{
437       Ptr<Packet> copy = \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->Copy ();
438       \textcolor{comment}{// Should check via getsockopt ()..}
439       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Socket_a104a42cdf0290b4e8867b4c0a77aadc2}{IsRecvPktInfo} ())
440         \{
441           Ipv4PacketInfoTag tag;
442           copy->RemovePacketTag (tag);
443           tag.SetRecvIf (incomingInterface->GetDevice ()->GetIfIndex ());
444           copy->AddPacketTag (tag);
445         \}
446 
447       \textcolor{comment}{//Check only version 4 options}
448       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Socket_a5b5addd1a33e306c3113c547705835f9}{IsIpRecvTos} ())
449         \{
450           SocketIpTosTag ipTosTag;
451           ipTosTag.SetTos (ipHeader.GetTos ());
452           copy->AddPacketTag (ipTosTag);
453         \}
454 
455       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Socket_abc87245c3eec89fc043d4f043b0be35f}{IsIpRecvTtl} ())
456         \{
457           SocketIpTtlTag ipTtlTag;
458           ipTtlTag.SetTtl (ipHeader.GetTtl ());
459           copy->AddPacketTag (ipTtlTag);
460         \}
461 
462      \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4RawSocketImpl_a924effb0eb9a6cbbf1daeb3a7b7ffc94}{m\_protocol} == 1)
463         \{
464           Icmpv4Header icmpHeader;
465           copy->PeekHeader (icmpHeader);
466           uint8\_t \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type} = icmpHeader.GetType ();
467           \textcolor{keywordflow}{if} (type < 32 &&
468               ((uint32\_t(1) << type) & \hyperlink{classns3_1_1Ipv4RawSocketImpl_ab80bb1194c37a7489b342156a7bfcb92}{m\_icmpFilter}))
469             \{
470               \textcolor{comment}{// filter out icmp packet.}
471               \textcolor{keywordflow}{return} \textcolor{keyword}{false};
472             \}
473         \}
474       copy->AddHeader (ipHeader);
475       \textcolor{keyword}{struct }Data \hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data};
476       \hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data}.packet = copy;
477       \hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data}.fromIp = ipHeader.GetSource ();
478       \hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data}.fromProtocol = ipHeader.GetProtocol ();
479       \hyperlink{classns3_1_1Ipv4RawSocketImpl_a460de0afa7bc2d11b5e54cf23e361173}{m\_recv}.push\_back (\hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data});
480       \hyperlink{classns3_1_1Socket_a91fa3046bbd0a7644381f1d2481bdfef}{NotifyDataRecv} ();
481       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
482     \}
483   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
484 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8


\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!Get\+Allow\+Broadcast@{Get\+Allow\+Broadcast}}
\index{Get\+Allow\+Broadcast@{Get\+Allow\+Broadcast}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Allow\+Broadcast() const }{GetAllowBroadcast() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::\+Get\+Allow\+Broadcast (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_ac1345101c6fd1f1ba8f7c05a326faab3}{}\label{classns3_1_1Ipv4RawSocketImpl_ac1345101c6fd1f1ba8f7c05a326faab3}


Query whether broadcast datagram transmissions are allowed. 

This method corresponds to using getsockopt() S\+O\+\_\+\+B\+R\+O\+A\+D\+C\+A\+ST of real network or B\+SD sockets.

\begin{DoxyReturn}{Returns}
true if broadcast is allowed, false otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_a95338a1ac89330a492d6af5b4e172d34}{ns3\+::\+Socket}.


\begin{DoxyCode}
499 \{
500   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
501   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
502 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!Get\+Errno@{Get\+Errno}}
\index{Get\+Errno@{Get\+Errno}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Errno() const }{GetErrno() const }}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Socket\+::\+Socket\+Errno} ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::\+Get\+Errno (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_acfda80b470cc0359b70363f5dbc89a5a}{}\label{classns3_1_1Ipv4RawSocketImpl_acfda80b470cc0359b70363f5dbc89a5a}


Get last error number. 

\begin{DoxyReturn}{Returns}
the errno associated to the last call which failed in this socket. Each socket\textquotesingle{}s errno is initialized to zero when the socket is created. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_ae489616249d946f3c0dc831c05d0d711}{ns3\+::\+Socket}.


\begin{DoxyCode}
83 \{
84   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
85   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv4RawSocketImpl_aae08c8798140ad6193ad2fc7ab1efbed}{m\_err};
86 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!Get\+Node@{Get\+Node}}
\index{Get\+Node@{Get\+Node}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Node(void) const }{GetNode(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Node} $>$ ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::\+Get\+Node (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_a7965179773962e28a388a1601e435d74}{}\label{classns3_1_1Ipv4RawSocketImpl_a7965179773962e28a388a1601e435d74}


Return the node this socket is associated with. 

\begin{DoxyReturn}{Returns}
the node 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_aba642ad4301c1df47befc0aa9afa2e48}{ns3\+::\+Socket}.


\begin{DoxyCode}
97 \{
98   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
99   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv4RawSocketImpl_af8cdf6f27af43b69c0616b90e9f3af98}{m\_node};
100 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!Get\+Peer\+Name@{Get\+Peer\+Name}}
\index{Get\+Peer\+Name@{Get\+Peer\+Name}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Peer\+Name(\+Address \&address) const }{GetPeerName(Address &address) const }}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::\+Get\+Peer\+Name (
\begin{DoxyParamCaption}
\item[{{\bf Address} \&}]{address}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_a04075494f8324b8b3ab2009d5a1d1544}{}\label{classns3_1_1Ipv4RawSocketImpl_a04075494f8324b8b3ab2009d5a1d1544}


Get the peer address of a connected socket. 


\begin{DoxyParams}{Parameters}
{\em address} & the address this socket is connected to. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if success, -\/1 otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_a78a3c37a539d2e70869bb82cc60fbb09}{ns3\+::\+Socket}.


\begin{DoxyCode}
136 \{
137   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << address);
138 
139   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4RawSocketImpl_a36a7c8ea8152272b055706247b97bef2}{m\_dst} == \hyperlink{classns3_1_1Ipv4Address_a7a39b330c8e701183a411d5779fca1a4}{Ipv4Address::GetAny} ())
140     \{
141       \hyperlink{classns3_1_1Ipv4RawSocketImpl_aae08c8798140ad6193ad2fc7ab1efbed}{m\_err} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaaeb1fd23c1f4965b496786597125bf0f6}{ERROR\_NOTCONN};
142       \textcolor{keywordflow}{return} -1;
143     \}
144 
145   address = InetSocketAddress (\hyperlink{classns3_1_1Ipv4RawSocketImpl_a36a7c8ea8152272b055706247b97bef2}{m\_dst}, 0);
146 
147   \textcolor{keywordflow}{return} 0;
148 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9


\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!Get\+Rx\+Available@{Get\+Rx\+Available}}
\index{Get\+Rx\+Available@{Get\+Rx\+Available}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Rx\+Available(void) const }{GetRxAvailable(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::\+Get\+Rx\+Available (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_aecf377d782a4109f15952c7cccfb6f2c}{}\label{classns3_1_1Ipv4RawSocketImpl_aecf377d782a4109f15952c7cccfb6f2c}
Return number of bytes which can be returned from one or multiple calls to Recv. Must be possible to call this method from the Recv callback.

\begin{DoxyReturn}{Returns}
the number of bytes which can be returned from one or multiple Recv calls. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_ad35d8931e53ae0754ee864acb1cecd0e}{ns3\+::\+Socket}.


\begin{DoxyCode}
365 \{
366   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
367   uint32\_t rx = 0;
368   \textcolor{keywordflow}{for} (std::list<Data>::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Ipv4RawSocketImpl_a460de0afa7bc2d11b5e54cf23e361173}{m\_recv}.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1Ipv4RawSocketImpl_a460de0afa7bc2d11b5e54cf23e361173}{m\_recv}.end (); ++
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
369     \{
370       rx += (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->packet)->GetSize ();
371     \}
372   \textcolor{keywordflow}{return} rx;
373 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!Get\+Socket\+Type@{Get\+Socket\+Type}}
\index{Get\+Socket\+Type@{Get\+Socket\+Type}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Socket\+Type(void) const }{GetSocketType(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Socket\+::\+Socket\+Type} ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::\+Get\+Socket\+Type (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_a38d738344a763f0aea530327034dc035}{}\label{classns3_1_1Ipv4RawSocketImpl_a38d738344a763f0aea530327034dc035}


Get socket type (N\+S3\+\_\+\+S\+O\+C\+K\+\_\+\+R\+AW) 

\begin{DoxyReturn}{Returns}
socket type 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_af9333cfc006d6ed9363f20d3822fedcb}{ns3\+::\+Socket}.


\begin{DoxyCode}
90 \{
91   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
92   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Socket_a698fbcc486a48b7a0d2b0e4ab863d571aa97c397d36e85f30278a64ef94d40e03}{NS3\_SOCK\_RAW};
93 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!Get\+Sock\+Name@{Get\+Sock\+Name}}
\index{Get\+Sock\+Name@{Get\+Sock\+Name}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Sock\+Name(\+Address \&address) const }{GetSockName(Address &address) const }}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::\+Get\+Sock\+Name (
\begin{DoxyParamCaption}
\item[{{\bf Address} \&}]{address}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_a4ac52521f511da9302c945d02ef07e23}{}\label{classns3_1_1Ipv4RawSocketImpl_a4ac52521f511da9302c945d02ef07e23}


Get socket address. 


\begin{DoxyParams}{Parameters}
{\em address} & the address name this socket is associated with. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if success, -\/1 otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_aa982ca9baab28bea412b0d9710e63b43}{ns3\+::\+Socket}.


\begin{DoxyCode}
129 \{
130   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << address);
131   address = InetSocketAddress (\hyperlink{classns3_1_1Ipv4RawSocketImpl_a1881de88180f919a385b14db64b93932}{m\_src}, 0);
132   \textcolor{keywordflow}{return} 0;
133 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!Get\+Tx\+Available@{Get\+Tx\+Available}}
\index{Get\+Tx\+Available@{Get\+Tx\+Available}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Tx\+Available(void) const }{GetTxAvailable(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::\+Get\+Tx\+Available (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_afa925ad3c6fef990ec72b4ee5c0cbc2b}{}\label{classns3_1_1Ipv4RawSocketImpl_afa925ad3c6fef990ec72b4ee5c0cbc2b}


Returns the number of bytes which can be sent in a single call to Send. 

For datagram sockets, this returns the number of bytes that can be passed atomically through the underlying protocol.

For stream sockets, this returns the available space in bytes left in the transmit buffer.

\begin{DoxyReturn}{Returns}
The number of bytes which can be sent in a single Send call. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_ae7cf62e3acf44106bfa1d40eaeaec151}{ns3\+::\+Socket}.


\begin{DoxyCode}
198 \{
199   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
200   \textcolor{keywordflow}{return} 0xffffffff;
201 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 10


\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_a3d0791fa8fd3fb01db1e860ad259e21b}{}\label{classns3_1_1Ipv4RawSocketImpl_a3d0791fa8fd3fb01db1e860ad259e21b}


Get the type ID of this class. 

\begin{DoxyReturn}{Returns}
type ID 
\end{DoxyReturn}

\begin{DoxyCode}
24 \{
25   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::Ipv4RawSocketImpl"})
26     .SetParent<\hyperlink{classns3_1_1Socket_a1e22267afc490a4b15b8a764289a4000}{Socket}> ()
27     .SetGroupName (\textcolor{stringliteral}{"Internet"})
28     .AddAttribute (\textcolor{stringliteral}{"Protocol"}, \textcolor{stringliteral}{"Protocol number to match."},
29                    UintegerValue (0),
30                    MakeUintegerAccessor (&\hyperlink{classns3_1_1Ipv4RawSocketImpl_a924effb0eb9a6cbbf1daeb3a7b7ffc94}{Ipv4RawSocketImpl::m\_protocol}),
31                    MakeUintegerChecker<uint16\_t> ())
32     .AddAttribute (\textcolor{stringliteral}{"IcmpFilter"}, 
33                    \textcolor{stringliteral}{"Any icmp header whose type field matches a bit in this filter is dropped. Type must be
       less than 32."},
34                    UintegerValue (0),
35                    MakeUintegerAccessor (&\hyperlink{classns3_1_1Ipv4RawSocketImpl_ab80bb1194c37a7489b342156a7bfcb92}{Ipv4RawSocketImpl::m\_icmpFilter}),
36                    MakeUintegerChecker<uint32\_t> ())
37     \textcolor{comment}{// }
38     \textcolor{comment}{//  from raw (7), linux, returned length of Send/Recv should be}
39     \textcolor{comment}{// }
40     \textcolor{comment}{//            | IP\_HDRINC on  |      off    |}
41     \textcolor{comment}{//  ----------+---------------+-------------+-}
42     \textcolor{comment}{//  Send(Ipv4)| hdr + payload | payload     |}
43     \textcolor{comment}{//  Recv(Ipv4)| hdr + payload | hdr+payload |}
44     \textcolor{comment}{//  ----------+---------------+-------------+-}
45     .AddAttribute (\textcolor{stringliteral}{"IpHeaderInclude"}, 
46                    \textcolor{stringliteral}{"Include IP Header information (a.k.a setsockopt (IP\_HDRINCL))."},
47                    BooleanValue (\textcolor{keyword}{false}),
48                    MakeBooleanAccessor (&\hyperlink{classns3_1_1Ipv4RawSocketImpl_a895d0929c6fb2c111f99e83a8b7516fc}{Ipv4RawSocketImpl::m\_iphdrincl}),
49                    MakeBooleanChecker ())
50   ;
51   \textcolor{keywordflow}{return} tid;
52 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 11


\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!Listen@{Listen}}
\index{Listen@{Listen}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Listen(void)}{Listen(void)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::\+Listen (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_aa72df8f117a1d5ba69b7591b2bd9245e}{}\label{classns3_1_1Ipv4RawSocketImpl_aa72df8f117a1d5ba69b7591b2bd9245e}


Listen for incoming connections. 

\begin{DoxyReturn}{Returns}
0 on success, -\/1 on error (in which case errno is set). 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_a6b3529a32632cf1a56debf5f79e56c54}{ns3\+::\+Socket}.


\begin{DoxyCode}
191 \{
192   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
193   \hyperlink{classns3_1_1Ipv4RawSocketImpl_aae08c8798140ad6193ad2fc7ab1efbed}{m\_err} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa777b6c9712ef5485ebecfb96d5de4d54}{Socket::ERROR\_OPNOTSUPP};
194   \textcolor{keywordflow}{return} -1;
195 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!Recv@{Recv}}
\index{Recv@{Recv}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Recv(uint32\+\_\+t max\+Size, uint32\+\_\+t flags)}{Recv(uint32_t maxSize, uint32_t flags)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Packet} $>$ ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::\+Recv (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{max\+Size, }
\item[{uint32\+\_\+t}]{flags}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_a4716d2ee63765d9b4a35592800a20d35}{}\label{classns3_1_1Ipv4RawSocketImpl_a4716d2ee63765d9b4a35592800a20d35}


Read data from the socket. 

This function matches closely in semantics to the recv() function call in the standard C library (libc)\+: ssize\+\_\+t recv (int s, void $\ast$buf, size\+\_\+t len, int flags); except that the receive I/O is asynchronous. This is the primary Recv method at this low-\/level A\+PI and must be implemented by subclasses.

This method is normally used only on a connected socket. In a typical blocking sockets model, this call would block until at least one byte is returned or the connection closes. In ns-\/3 at this A\+PI, the call returns immediately in such a case and returns 0 if nothing is available to be read. However, an application can set a callback, ns3\+::\+Set\+Recv\+Callback, to be notified of data being available to be read (when it conceptually unblocks); this is an asynchronous I/O model for recv().

This variant of \hyperlink{classns3_1_1Socket_afb4e211a54a3f63ac3f79624a3a964f7}{Recv()} uses class \hyperlink{classns3_1_1Packet}{ns3\+::\+Packet} to encapsulate data, rather than providing a raw pointer and length field. This allows an ns-\/3 application to attach tags if desired (such as a flow ID) and may allow the simulator to avoid some data copies. Despite the appearance of receiving Packets on a stream socket, just think of it as a fancy byte buffer with streaming semantics.

The semantics depend on the type of socket. For a datagram socket, each \hyperlink{classns3_1_1Socket_afb4e211a54a3f63ac3f79624a3a964f7}{Recv()} returns the data from at most one \hyperlink{classns3_1_1Ipv4RawSocketImpl_ae43d27d4aa516a4cacbe8f0f4f688110}{Send()}, and order is not necessarily preserved. For a stream socket, the bytes are delivered in order, and on-\/the-\/wire packet boundaries are not preserved.

The flags argument is formed by or\textquotesingle{}ing one or more of the values\+: M\+S\+G\+\_\+\+O\+OB process out-\/of-\/band data M\+S\+G\+\_\+\+P\+E\+EK peek at incoming message None of these flags are supported for now.

Some variants of \hyperlink{classns3_1_1Socket_afb4e211a54a3f63ac3f79624a3a964f7}{Recv()} are supported as additional A\+PI, including \hyperlink{classns3_1_1Ipv4RawSocketImpl_a4a004b1ebdcb92d83ee083cdd5543a56}{Recv\+From()}, overloaded \hyperlink{classns3_1_1Socket_afb4e211a54a3f63ac3f79624a3a964f7}{Recv()} without arguments, and variants that use raw character buffers.


\begin{DoxyParams}{Parameters}
{\em max\+Size} & reader will accept packet up to max\+Size \\
\hline
{\em flags} & \hyperlink{classns3_1_1Socket}{Socket} control flags \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{classns3_1_1Ptr}{Ptr$<$\+Packet$>$} of the next in-\/sequence packet. Returns 0 if the socket cannot return a next in-\/sequence packet conforming to the max\+Size and flags.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Socket_a243f7835ef1a85f9270fd3577e3a40da}{Set\+Recv\+Callback} 
\end{DoxySeeAlso}


Implements \hyperlink{classns3_1_1Socket_a8949b1f844aae563446f2f4c5be8827a}{ns3\+::\+Socket}.


\begin{DoxyCode}
376 \{
377   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << maxSize << flags);
378   Address tmp;
379   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv4RawSocketImpl_a4a004b1ebdcb92d83ee083cdd5543a56}{RecvFrom} (maxSize, flags, tmp);
380 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12


\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!Recv\+From@{Recv\+From}}
\index{Recv\+From@{Recv\+From}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Recv\+From(uint32\+\_\+t max\+Size, uint32\+\_\+t flags, Address \&from\+Address)}{RecvFrom(uint32_t maxSize, uint32_t flags, Address &fromAddress)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Packet} $>$ ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::\+Recv\+From (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{max\+Size, }
\item[{uint32\+\_\+t}]{flags, }
\item[{{\bf Address} \&}]{from\+Address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_a4a004b1ebdcb92d83ee083cdd5543a56}{}\label{classns3_1_1Ipv4RawSocketImpl_a4a004b1ebdcb92d83ee083cdd5543a56}


Read a single packet from the socket and retrieve the sender address. 

Calls Recv(max\+Size, flags) with max\+Size implicitly set to maximum sized integer, and flags set to zero.

This method has similar semantics to Recv () but subclasses may want to provide checks on socket state, so the implementation is pushed to subclasses.


\begin{DoxyParams}{Parameters}
{\em max\+Size} & reader will accept packet up to max\+Size \\
\hline
{\em flags} & \hyperlink{classns3_1_1Socket}{Socket} control flags \\
\hline
{\em from\+Address} & output parameter that will return the address of the sender of the received packet, if any. Remains untouched if no packet is received. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{classns3_1_1Ptr}{Ptr$<$\+Packet$>$} of the next in-\/sequence packet. Returns 0 if the socket cannot return a next in-\/sequence packet. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_af22378d7af9a2745a9eada20210da215}{ns3\+::\+Socket}.


\begin{DoxyCode}
384 \{
385   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << maxSize << flags << fromAddress);
386   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4RawSocketImpl_a460de0afa7bc2d11b5e54cf23e361173}{m\_recv}.empty ())
387     \{
388       \textcolor{keywordflow}{return} 0;
389     \}
390   \textcolor{keyword}{struct }Data \hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data} = \hyperlink{classns3_1_1Ipv4RawSocketImpl_a460de0afa7bc2d11b5e54cf23e361173}{m\_recv}.front ();
391   \hyperlink{classns3_1_1Ipv4RawSocketImpl_a460de0afa7bc2d11b5e54cf23e361173}{m\_recv}.pop\_front ();
392   InetSocketAddress inet = InetSocketAddress (data.fromIp, data.fromProtocol);
393   fromAddress = inet;
394   \textcolor{keywordflow}{if} (data.packet->GetSize () > maxSize)
395     \{
396       Ptr<Packet> first = data.packet->CreateFragment (0, maxSize);
397       \textcolor{keywordflow}{if} (!(flags & MSG\_PEEK))
398         \{
399           data.packet->RemoveAtStart (maxSize);
400         \}
401       \hyperlink{classns3_1_1Ipv4RawSocketImpl_a460de0afa7bc2d11b5e54cf23e361173}{m\_recv}.push\_front (data);
402       \textcolor{keywordflow}{return} first;
403     \}
404   \textcolor{keywordflow}{return} data.packet;
405 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13




Here is the caller graph for this function\+:
% FIG 14


\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!Send@{Send}}
\index{Send@{Send}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Send(\+Ptr$<$ Packet $>$ p, uint32\+\_\+t flags)}{Send(Ptr< Packet > p, uint32_t flags)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::\+Send (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{uint32\+\_\+t}]{flags}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_ae43d27d4aa516a4cacbe8f0f4f688110}{}\label{classns3_1_1Ipv4RawSocketImpl_ae43d27d4aa516a4cacbe8f0f4f688110}


Send data (or dummy data) to the remote host. 

This function matches closely in semantics to the send() function call in the standard C library (libc)\+: ssize\+\_\+t send (int s, const void $\ast$msg, size\+\_\+t len, int flags); except that the send I/O is asynchronous. This is the primary Send method at this low-\/level A\+PI and must be implemented by subclasses.

In a typical blocking sockets model, this call would block upon lack of space to hold the message to be sent. In ns-\/3 at this A\+PI, the call returns immediately in such a case, but the callback registered with \hyperlink{classns3_1_1Socket_a85ff5c8cc7d242823f301b49264c68a4}{Set\+Send\+Callback()} is invoked when the socket has space (when it conceptually unblocks); this is an asynchronous I/O model for send().

This variant of \hyperlink{classns3_1_1Ipv4RawSocketImpl_ae43d27d4aa516a4cacbe8f0f4f688110}{Send()} uses class \hyperlink{classns3_1_1Packet}{ns3\+::\+Packet} to encapsulate data, rather than providing a raw pointer and length field. This allows an ns-\/3 application to attach tags if desired (such as a flow ID) and may allow the simulator to avoid some data copies. Despite the appearance of sending Packets on a stream socket, just think of it as a fancy byte buffer with streaming semantics.

If either the message buffer within the \hyperlink{classns3_1_1Packet}{Packet} is too long to pass atomically through the underlying protocol (for datagram sockets), or the message buffer cannot entirely fit in the transmit buffer (for stream sockets), -\/1 is returned and Socket\+Errno is set to E\+R\+R\+O\+R\+\_\+\+M\+S\+G\+S\+I\+ZE. If the packet does not fit, the caller can split the \hyperlink{classns3_1_1Packet}{Packet} (based on information obtained from Get\+Tx\+Available) and reattempt to send the data.

The flags argument is formed by or\textquotesingle{}ing one or more of the values\+: M\+S\+G\+\_\+\+O\+OB process out-\/of-\/band data M\+S\+G\+\_\+\+D\+O\+N\+T\+R\+O\+U\+TE bypass routing, use direct interface These flags are {\itshape unsupported} as of ns-\/3.\+1.


\begin{DoxyParams}{Parameters}
{\em p} & \hyperlink{classns3_1_1Packet}{ns3\+::\+Packet} to send \\
\hline
{\em flags} & \hyperlink{classns3_1_1Socket}{Socket} control flags \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of bytes accepted for transmission if no error occurs, and -\/1 otherwise.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Socket_a85ff5c8cc7d242823f301b49264c68a4}{Set\+Send\+Callback} 
\end{DoxySeeAlso}


Implements \hyperlink{classns3_1_1Socket_a036901c8f485fe5b6eab93b7f2ec289d}{ns3\+::\+Socket}.


\begin{DoxyCode}
204 \{
205   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << p << flags);
206   InetSocketAddress to = InetSocketAddress (\hyperlink{classns3_1_1Ipv4RawSocketImpl_a36a7c8ea8152272b055706247b97bef2}{m\_dst}, \hyperlink{classns3_1_1Ipv4RawSocketImpl_a924effb0eb9a6cbbf1daeb3a7b7ffc94}{m\_protocol});
207   to.SetTos (\hyperlink{classns3_1_1Socket_a95bd4732074d3d26d4a6949fc3499ccb}{GetIpTos} ());
208   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv4RawSocketImpl_a06fd568d5988700a423fb2203e0aa0bf}{SendTo} (p, flags, to);
209 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 15


\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!Send\+To@{Send\+To}}
\index{Send\+To@{Send\+To}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Send\+To(\+Ptr$<$ Packet $>$ p, uint32\+\_\+t flags, const Address \&to\+Address)}{SendTo(Ptr< Packet > p, uint32_t flags, const Address &toAddress)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::\+Send\+To (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{uint32\+\_\+t}]{flags, }
\item[{const {\bf Address} \&}]{to\+Address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_a06fd568d5988700a423fb2203e0aa0bf}{}\label{classns3_1_1Ipv4RawSocketImpl_a06fd568d5988700a423fb2203e0aa0bf}


Send data to a specified peer. 

This method has similar semantics to Send () but subclasses may want to provide checks on socket state, so the implementation is pushed to subclasses.


\begin{DoxyParams}{Parameters}
{\em p} & packet to send \\
\hline
{\em flags} & \hyperlink{classns3_1_1Socket}{Socket} control flags \\
\hline
{\em to\+Address} & IP \hyperlink{classns3_1_1Address}{Address} of remote host \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
-\/1 in case of error or the number of bytes copied in the internal buffer and accepted for transmission. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_af898fce6a58e0dbba23c1c6de1d4220e}{ns3\+::\+Socket}.


\begin{DoxyCode}
213 \{
214   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << p << flags << toAddress);
215   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1InetSocketAddress_a9426766e34e928ce5dbdbeb9563a10df}{InetSocketAddress::IsMatchingType} (toAddress))
216     \{
217       \hyperlink{classns3_1_1Ipv4RawSocketImpl_aae08c8798140ad6193ad2fc7ab1efbed}{m\_err} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa4b98dd50740861229f8e03bcc36d379b}{Socket::ERROR\_INVAL};
218       \textcolor{keywordflow}{return} -1;
219     \}
220   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4RawSocketImpl_adc89037fdb02fa149e063882c499dfb8}{m\_shutdownSend})
221     \{
222       \textcolor{keywordflow}{return} 0;
223     \}
224 
225   InetSocketAddress ad = \hyperlink{classns3_1_1InetSocketAddress_ade776b1109e7b9a7be0b22ced49931e3}{InetSocketAddress::ConvertFrom} (toAddress);
226   Ptr<Ipv4> ipv4 = \hyperlink{classns3_1_1Ipv4RawSocketImpl_af8cdf6f27af43b69c0616b90e9f3af98}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv4> ();
227   Ipv4Address dst = ad.GetIpv4 ();
228   Ipv4Address src = \hyperlink{classns3_1_1Ipv4RawSocketImpl_a1881de88180f919a385b14db64b93932}{m\_src};
229   uint8\_t tos = ad.GetTos ();
230 
231   uint8\_t priority = \hyperlink{classns3_1_1Socket_a3e4788d61c0e841ccaa1c7fce6fda2c1}{GetPriority} ();
232   \textcolor{keywordflow}{if} (tos)
233     \{
234       SocketIpTosTag ipTosTag;
235       ipTosTag.SetTos (tos);
236       \textcolor{comment}{// This packet may already have a SocketIpTosTag (see BUG 2440)}
237       p->\hyperlink{classns3_1_1Packet_afb014ae9f4adddbfc51c64b085bfd405}{ReplacePacketTag} (ipTosTag);
238       priority = \hyperlink{classns3_1_1Socket_a81564620cc94d291f1dc5d79b2f13b4a}{IpTos2Priority} (tos);
239     \}
240   \textcolor{keywordflow}{if} (priority)
241     \{
242       SocketPriorityTag priorityTag;
243       priorityTag.SetPriority (priority);
244       p->\hyperlink{classns3_1_1Packet_afb014ae9f4adddbfc51c64b085bfd405}{ReplacePacketTag} (priorityTag);
245     \}
246 
247   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Socket_afbbd0ecd7cda631cafc80eda33aa0b2c}{IsManualIpTtl} () && \hyperlink{classns3_1_1Socket_adf6420d12b8a0b6a20e46c37fe48830d}{GetIpTtl} () != 0 && !dst.IsMulticast () && !dst.IsBroadcast 
      ())
248     \{
249       SocketIpTtlTag tag;
250       tag.SetTtl (\hyperlink{classns3_1_1Socket_adf6420d12b8a0b6a20e46c37fe48830d}{GetIpTtl} ());
251       p->\hyperlink{classns3_1_1Packet_a7400b8655852f5271c5957250d0141af}{AddPacketTag} (tag);
252     \}
253 
254   \textcolor{keywordtype}{bool} subnetDirectedBroadcast = \textcolor{keyword}{false};
255   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Socket_a9781d8dfdb5e9364d5dce8f53b768bb5}{m\_boundnetdevice})
256     \{
257       uint32\_t iif = ipv4->GetInterfaceForDevice (\hyperlink{classns3_1_1Socket_a9781d8dfdb5e9364d5dce8f53b768bb5}{m\_boundnetdevice});
258       \textcolor{keywordflow}{for} (uint32\_t j = 0; j < ipv4->GetNAddresses (iif); j++)
259         \{
260           Ipv4InterfaceAddress ifAddr = ipv4->GetAddress (iif, j);
261           \textcolor{keywordflow}{if} (dst.IsSubnetDirectedBroadcast (ifAddr.GetMask ()))
262             \{
263               subnetDirectedBroadcast = \textcolor{keyword}{true};
264             \}
265         \}
266     \}
267 
268   \textcolor{keywordflow}{if} (dst.IsBroadcast () || subnetDirectedBroadcast)
269     \{
270       Ptr <NetDevice> boundNetDevice = \hyperlink{classns3_1_1Socket_a9781d8dfdb5e9364d5dce8f53b768bb5}{m\_boundnetdevice};
271       \textcolor{keywordflow}{if} (ipv4->GetNInterfaces () == 1)
272         \{
273           boundNetDevice = ipv4->GetNetDevice (0);
274         \}
275       \textcolor{keywordflow}{if} (boundNetDevice == 0)
276         \{
277           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"dropped because no outgoing route."});
278           \textcolor{keywordflow}{return} -1;
279         \}
280 
281       Ipv4Header header;
282       uint32\_t pktSize = p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ();
283       \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1Ipv4RawSocketImpl_a895d0929c6fb2c111f99e83a8b7516fc}{m\_iphdrincl})
284         \{
285           header.SetDestination (dst);
286           header.SetProtocol (\hyperlink{classns3_1_1Ipv4RawSocketImpl_a924effb0eb9a6cbbf1daeb3a7b7ffc94}{m\_protocol});
287           Ptr<Ipv4Route> route = Create <Ipv4Route> ();
288           route->SetSource (src);
289           route->SetDestination (dst);
290           route->SetOutputDevice (boundNetDevice);
291           ipv4->Send (p, route->GetSource (), dst, \hyperlink{classns3_1_1Ipv4RawSocketImpl_a924effb0eb9a6cbbf1daeb3a7b7ffc94}{m\_protocol}, route);
292         \}
293       \textcolor{keywordflow}{else}
294         \{
295           p->\hyperlink{classns3_1_1Packet_a0961eccf975d75f902d40956c93ba63e}{RemoveHeader} (header);
296           dst = header.GetDestination ();
297           src = header.GetSource ();
298           pktSize += header.GetSerializedSize ();
299           Ptr<Ipv4Route> route = Create <Ipv4Route> ();
300           route->SetSource (src);
301           route->SetDestination (dst);
302           route->SetOutputDevice (boundNetDevice);
303           ipv4->SendWithHeader (p, header, route);
304         \}
305       \hyperlink{classns3_1_1Socket_ae478fc503f7041a1da5e9db361f1ae20}{NotifyDataSent} (pktSize);
306       \hyperlink{classns3_1_1Socket_a34cd5de5b9feeadd6ba8973b954c3d5f}{NotifySend} (\hyperlink{classns3_1_1Ipv4RawSocketImpl_afa925ad3c6fef990ec72b4ee5c0cbc2b}{GetTxAvailable} ());
307       \textcolor{keywordflow}{return} pktSize;
308     \}
309 
310 
311   \textcolor{keywordflow}{if} (ipv4->GetRoutingProtocol ())
312     \{
313       Ipv4Header header;
314       \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1Ipv4RawSocketImpl_a895d0929c6fb2c111f99e83a8b7516fc}{m\_iphdrincl})
315         \{
316           header.SetDestination (dst);
317           header.SetProtocol (\hyperlink{classns3_1_1Ipv4RawSocketImpl_a924effb0eb9a6cbbf1daeb3a7b7ffc94}{m\_protocol});
318         \}
319       \textcolor{keywordflow}{else}
320         \{
321           p->\hyperlink{classns3_1_1Packet_a0961eccf975d75f902d40956c93ba63e}{RemoveHeader} (header);
322           dst = header.GetDestination ();
323           src = header.GetSource ();
324         \}
325       \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{SocketErrno} errno\_ = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaaa7eb006d73c5ad0117c5591fcb3469f7}{ERROR\_NOTERROR}; \textcolor{comment}{//do not use errno as it is the
       standard C last error number}
326       Ptr<Ipv4Route> route;
327       Ptr<NetDevice> oif = \hyperlink{classns3_1_1Socket_a9781d8dfdb5e9364d5dce8f53b768bb5}{m\_boundnetdevice}; \textcolor{comment}{//specify non-zero if bound to a source
       address}
328       \textcolor{keywordflow}{if} (!oif && src != \hyperlink{classns3_1_1Ipv4Address_a7a39b330c8e701183a411d5779fca1a4}{Ipv4Address::GetAny} ())
329         \{
330           int32\_t index = ipv4->GetInterfaceForAddress (src);
331           \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (index >= 0);
332           oif = ipv4->GetNetDevice (index);
333           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Set index "} << oif << \textcolor{stringliteral}{"from source "} << src);
334         \}
335 
336       \textcolor{comment}{// TBD-- we could cache the route and just check its validity}
337       route = ipv4->GetRoutingProtocol ()->RouteOutput (p, header, oif, errno\_);
338       \textcolor{keywordflow}{if} (route != 0)
339         \{
340           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Route exists"});
341           uint32\_t pktSize = p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ();
342           \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1Ipv4RawSocketImpl_a895d0929c6fb2c111f99e83a8b7516fc}{m\_iphdrincl})
343             \{
344               ipv4->Send (p, route->GetSource (), dst, \hyperlink{classns3_1_1Ipv4RawSocketImpl_a924effb0eb9a6cbbf1daeb3a7b7ffc94}{m\_protocol}, route);
345             \}
346           \textcolor{keywordflow}{else}
347             \{
348               pktSize += header.GetSerializedSize ();
349               ipv4->SendWithHeader (p, header, route);
350             \}
351           \hyperlink{classns3_1_1Socket_ae478fc503f7041a1da5e9db361f1ae20}{NotifyDataSent} (pktSize);
352           \hyperlink{classns3_1_1Socket_a34cd5de5b9feeadd6ba8973b954c3d5f}{NotifySend} (\hyperlink{classns3_1_1Ipv4RawSocketImpl_afa925ad3c6fef990ec72b4ee5c0cbc2b}{GetTxAvailable} ());
353           \textcolor{keywordflow}{return} pktSize;
354         \}
355       \textcolor{keywordflow}{else}
356         \{
357           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"dropped because no outgoing route."});
358           \textcolor{keywordflow}{return} -1;
359         \}
360     \}
361   \textcolor{keywordflow}{return} 0;
362 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 16




Here is the caller graph for this function\+:
% FIG 17


\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!Set\+Allow\+Broadcast@{Set\+Allow\+Broadcast}}
\index{Set\+Allow\+Broadcast@{Set\+Allow\+Broadcast}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Set\+Allow\+Broadcast(bool allow\+Broadcast)}{SetAllowBroadcast(bool allowBroadcast)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::\+Set\+Allow\+Broadcast (
\begin{DoxyParamCaption}
\item[{bool}]{allow\+Broadcast}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_aa7089a120a9c1b5bbb2cb19ff204b5de}{}\label{classns3_1_1Ipv4RawSocketImpl_aa7089a120a9c1b5bbb2cb19ff204b5de}


Configure whether broadcast datagram transmissions are allowed. 

This method corresponds to using setsockopt() S\+O\+\_\+\+B\+R\+O\+A\+D\+C\+A\+ST of real network or B\+SD sockets. If set on a socket, this option will enable or disable packets to be transmitted to broadcast destination addresses.


\begin{DoxyParams}{Parameters}
{\em allow\+Broadcast} & Whether broadcast is allowed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if operation succeeds 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_a32b4fa27b732a63207c8d9054a817ed5}{ns3\+::\+Socket}.


\begin{DoxyCode}
488 \{
489   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << allowBroadcast);
490   \textcolor{keywordflow}{if} (!allowBroadcast)
491     \{
492       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
493     \}
494   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
495 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!Set\+Node@{Set\+Node}}
\index{Set\+Node@{Set\+Node}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Set\+Node(\+Ptr$<$ Node $>$ node)}{SetNode(Ptr< Node > node)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::\+Set\+Node (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4RawSocketImpl_ac850bf9f93f91f53ed184c09d95cf371}{}\label{classns3_1_1Ipv4RawSocketImpl_ac850bf9f93f91f53ed184c09d95cf371}


Set the node associated with this socket. 


\begin{DoxyParams}{Parameters}
{\em node} & node to set \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
68 \{
69   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << node);
70   \hyperlink{classns3_1_1Ipv4RawSocketImpl_af8cdf6f27af43b69c0616b90e9f3af98}{m\_node} = node;
71 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!Set\+Protocol@{Set\+Protocol}}
\index{Set\+Protocol@{Set\+Protocol}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Set\+Protocol(uint16\+\_\+t protocol)}{SetProtocol(uint16_t protocol)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::\+Set\+Protocol (
\begin{DoxyParamCaption}
\item[{uint16\+\_\+t}]{protocol}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4RawSocketImpl_a7c5a00ba94fee5acefd972c71517062b}{}\label{classns3_1_1Ipv4RawSocketImpl_a7c5a00ba94fee5acefd972c71517062b}


Set protocol field. 


\begin{DoxyParams}{Parameters}
{\em protocol} & protocol to set \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
409 \{
410   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << protocol);
411   \hyperlink{classns3_1_1Ipv4RawSocketImpl_a924effb0eb9a6cbbf1daeb3a7b7ffc94}{m\_protocol} = protocol;
412 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!Shutdown\+Recv@{Shutdown\+Recv}}
\index{Shutdown\+Recv@{Shutdown\+Recv}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Shutdown\+Recv(void)}{ShutdownRecv(void)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::\+Shutdown\+Recv (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_a196a3b1bc9339211fcaedb7ead4c5039}{}\label{classns3_1_1Ipv4RawSocketImpl_a196a3b1bc9339211fcaedb7ead4c5039}
\begin{DoxyReturn}{Returns}
zero on success, -\/1 on failure.
\end{DoxyReturn}
Do not allow any further Recv calls. This method is typically implemented for Tcp sockets by a half close. 

Implements \hyperlink{classns3_1_1Socket_a5a6b835bb7ccf2cf43b54912e7cae600}{ns3\+::\+Socket}.


\begin{DoxyCode}
169 \{
170   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
171   \hyperlink{classns3_1_1Ipv4RawSocketImpl_abb193a17208627ab4f74a9a95e0ef6e9}{m\_shutdownRecv} = \textcolor{keyword}{true};
172   \textcolor{keywordflow}{return} 0;
173 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!Shutdown\+Send@{Shutdown\+Send}}
\index{Shutdown\+Send@{Shutdown\+Send}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Shutdown\+Send(void)}{ShutdownSend(void)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::\+Shutdown\+Send (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_a0d2cac5efa380545ea53036caf95eceb}{}\label{classns3_1_1Ipv4RawSocketImpl_a0d2cac5efa380545ea53036caf95eceb}
\begin{DoxyReturn}{Returns}
zero on success, -\/1 on failure.
\end{DoxyReturn}
Do not allow any further Send calls. This method is typically implemented for Tcp sockets by a half close. 

Implements \hyperlink{classns3_1_1Socket_a8186c87627fa3ece326d8f1c822d7f95}{ns3\+::\+Socket}.


\begin{DoxyCode}
162 \{
163   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
164   \hyperlink{classns3_1_1Ipv4RawSocketImpl_adc89037fdb02fa149e063882c499dfb8}{m\_shutdownSend} = \textcolor{keyword}{true};
165   \textcolor{keywordflow}{return} 0;
166 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!m\+\_\+dst@{m\+\_\+dst}}
\index{m\+\_\+dst@{m\+\_\+dst}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+dst}{m_dst}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Address} ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::m\+\_\+dst\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_a36a7c8ea8152272b055706247b97bef2}{}\label{classns3_1_1Ipv4RawSocketImpl_a36a7c8ea8152272b055706247b97bef2}


Destination address. 

\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!m\+\_\+err@{m\+\_\+err}}
\index{m\+\_\+err@{m\+\_\+err}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+err}{m_err}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Socket\+::\+Socket\+Errno} ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::m\+\_\+err\hspace{0.3cm}{\ttfamily [mutable]}, {\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_aae08c8798140ad6193ad2fc7ab1efbed}{}\label{classns3_1_1Ipv4RawSocketImpl_aae08c8798140ad6193ad2fc7ab1efbed}


Last error number. 

\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!m\+\_\+icmp\+Filter@{m\+\_\+icmp\+Filter}}
\index{m\+\_\+icmp\+Filter@{m\+\_\+icmp\+Filter}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+icmp\+Filter}{m_icmpFilter}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::m\+\_\+icmp\+Filter\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_ab80bb1194c37a7489b342156a7bfcb92}{}\label{classns3_1_1Ipv4RawSocketImpl_ab80bb1194c37a7489b342156a7bfcb92}


I\+C\+M\+Pv4 filter specification. 

\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!m\+\_\+iphdrincl@{m\+\_\+iphdrincl}}
\index{m\+\_\+iphdrincl@{m\+\_\+iphdrincl}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+iphdrincl}{m_iphdrincl}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::m\+\_\+iphdrincl\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_a895d0929c6fb2c111f99e83a8b7516fc}{}\label{classns3_1_1Ipv4RawSocketImpl_a895d0929c6fb2c111f99e83a8b7516fc}


Include IP \hyperlink{classns3_1_1Header}{Header} information (a.\+k.\+a setsockopt (I\+P\+\_\+\+H\+D\+R\+I\+N\+CL)) 

\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!m\+\_\+node@{m\+\_\+node}}
\index{m\+\_\+node@{m\+\_\+node}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+node}{m_node}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Node}$>$ ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::m\+\_\+node\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_af8cdf6f27af43b69c0616b90e9f3af98}{}\label{classns3_1_1Ipv4RawSocketImpl_af8cdf6f27af43b69c0616b90e9f3af98}


\hyperlink{classns3_1_1Node}{Node}. 

\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!m\+\_\+protocol@{m\+\_\+protocol}}
\index{m\+\_\+protocol@{m\+\_\+protocol}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+protocol}{m_protocol}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::m\+\_\+protocol\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_a924effb0eb9a6cbbf1daeb3a7b7ffc94}{}\label{classns3_1_1Ipv4RawSocketImpl_a924effb0eb9a6cbbf1daeb3a7b7ffc94}


Protocol. 

\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!m\+\_\+recv@{m\+\_\+recv}}
\index{m\+\_\+recv@{m\+\_\+recv}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+recv}{m_recv}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std\+::list}$<$struct {\bf Data}$>$ ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::m\+\_\+recv\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_a460de0afa7bc2d11b5e54cf23e361173}{}\label{classns3_1_1Ipv4RawSocketImpl_a460de0afa7bc2d11b5e54cf23e361173}


\hyperlink{classns3_1_1Packet}{Packet} waiting to be processed. 

\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!m\+\_\+shutdown\+Recv@{m\+\_\+shutdown\+Recv}}
\index{m\+\_\+shutdown\+Recv@{m\+\_\+shutdown\+Recv}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+shutdown\+Recv}{m_shutdownRecv}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::m\+\_\+shutdown\+Recv\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_abb193a17208627ab4f74a9a95e0ef6e9}{}\label{classns3_1_1Ipv4RawSocketImpl_abb193a17208627ab4f74a9a95e0ef6e9}


Flag to shutdown receive capability. 

\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!m\+\_\+shutdown\+Send@{m\+\_\+shutdown\+Send}}
\index{m\+\_\+shutdown\+Send@{m\+\_\+shutdown\+Send}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+shutdown\+Send}{m_shutdownSend}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::m\+\_\+shutdown\+Send\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_adc89037fdb02fa149e063882c499dfb8}{}\label{classns3_1_1Ipv4RawSocketImpl_adc89037fdb02fa149e063882c499dfb8}


Flag to shutdown send capability. 

\index{ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}!m\+\_\+src@{m\+\_\+src}}
\index{m\+\_\+src@{m\+\_\+src}!ns3\+::\+Ipv4\+Raw\+Socket\+Impl@{ns3\+::\+Ipv4\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+src}{m_src}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Address} ns3\+::\+Ipv4\+Raw\+Socket\+Impl\+::m\+\_\+src\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4RawSocketImpl_a1881de88180f919a385b14db64b93932}{}\label{classns3_1_1Ipv4RawSocketImpl_a1881de88180f919a385b14db64b93932}


Source address. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/model/\hyperlink{ipv4-raw-socket-impl_8h}{ipv4-\/raw-\/socket-\/impl.\+h}\item 
internet/model/\hyperlink{ipv4-raw-socket-impl_8cc}{ipv4-\/raw-\/socket-\/impl.\+cc}\end{DoxyCompactItemize}
