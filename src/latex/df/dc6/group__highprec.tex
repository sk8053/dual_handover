\hypertarget{group__highprec}{}\section{High Precision Q64.64}
\label{group__highprec}\index{High Precision Q64.\+64@{High Precision Q64.\+64}}
\subsection*{Files}
\begin{DoxyCompactItemize}
\item 
file \hyperlink{cairo-wideint-private_8h}{cairo-\/wideint-\/private.\+h}
\item 
file \hyperlink{cairo-wideint_8c}{cairo-\/wideint.\+c}
\item 
file \hyperlink{int64x64-128_8cc}{int64x64-\/128.\+cc}
\item 
file \hyperlink{int64x64-cairo_8cc}{int64x64-\/cairo.\+cc}
\item 
file \hyperlink{int64x64_8cc}{int64x64.\+cc}
\item 
file \hyperlink{int64x64_8h}{int64x64.\+h}
\end{DoxyCompactItemize}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classint64x64__t}{int64x64\+\_\+t}
\end{DoxyCompactItemize}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{group__highprec_gab4ef18031edb07b2d7cb6197583f3c51}{H\+E\+X\+H\+I\+L\+OW}(hi,  lo)
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static bool \hyperlink{group__highprec_gaeeaaf0f56a7e311cabc5db7213d91779}{ns3\+::output\+\_\+sign} (const int128\+\_\+t sa, const int128\+\_\+t sb, uint128\+\_\+t \&ua, uint128\+\_\+t \&ub)
\item 
static bool \hyperlink{group__highprec_gabc1eadf47a990215c1b0b131d4f52cf9}{ns3\+::output\+\_\+sign} (const \hyperlink{cairo-wideint-private_8h_adb77a91a0053b771957b37c1a822a228}{cairo\+\_\+int128\+\_\+t} sa, const \hyperlink{cairo-wideint-private_8h_adb77a91a0053b771957b37c1a822a228}{cairo\+\_\+int128\+\_\+t} sb, \hyperlink{cairo-wideint-private_8h_ab99b9c539c5f08b381ec3797b3fcd872}{cairo\+\_\+uint128\+\_\+t} \&ua, \hyperlink{cairo-wideint-private_8h_ab99b9c539c5f08b381ec3797b3fcd872}{cairo\+\_\+uint128\+\_\+t} \&ub)
\item 
static uint64\+\_\+t \hyperlink{group__highprec_gaa469dde0cf73e354d1e44a7501c53a53}{ns3\+::\+Read\+Hi\+Digits} (std\+::string str)
\item 
static uint64\+\_\+t \hyperlink{group__highprec_gab93a9afd92c0bdab641e9bd5f8d7fd1a}{ns3\+::\+Read\+Lo\+Digits} (std\+::string str)
\item 
\hyperlink{classint64x64__t}{int64x64\+\_\+t} \hyperlink{group__highprec_gabf48acdbe8e677584a67e4b34f896fd8}{ns3\+::operator+} (const \hyperlink{classint64x64__t}{int64x64\+\_\+t} \&lhs, const \hyperlink{classint64x64__t}{int64x64\+\_\+t} \&rhs)
\item 
\hyperlink{classint64x64__t}{int64x64\+\_\+t} \hyperlink{group__highprec_ga93f56e20943fd7ba3c1d45515a58432c}{ns3\+::operator-\/} (const \hyperlink{classint64x64__t}{int64x64\+\_\+t} \&lhs, const \hyperlink{classint64x64__t}{int64x64\+\_\+t} \&rhs)
\item 
\hyperlink{classint64x64__t}{int64x64\+\_\+t} \hyperlink{group__highprec_gad1ce534b470c0bddc3bc679d93161728}{ns3\+::operator$\ast$} (const \hyperlink{classint64x64__t}{int64x64\+\_\+t} \&lhs, const \hyperlink{classint64x64__t}{int64x64\+\_\+t} \&rhs)
\item 
\hyperlink{classint64x64__t}{int64x64\+\_\+t} \hyperlink{group__highprec_ga3a9ee0daa263697c2128076b242f65d4}{ns3\+::operator/} (const \hyperlink{classint64x64__t}{int64x64\+\_\+t} \&lhs, const \hyperlink{classint64x64__t}{int64x64\+\_\+t} \&rhs)
\item 
bool \hyperlink{group__highprec_gad876786cb1dfba302360a73649bbd8b2}{ns3\+::operator!=} (const \hyperlink{classint64x64__t}{int64x64\+\_\+t} \&lhs, const \hyperlink{classint64x64__t}{int64x64\+\_\+t} \&rhs)
\item 
bool \hyperlink{group__highprec_ga484976d59a10b4aac98c32a3e656ca6c}{ns3\+::operator$<$=} (const \hyperlink{classint64x64__t}{int64x64\+\_\+t} \&lhs, const \hyperlink{classint64x64__t}{int64x64\+\_\+t} \&rhs)
\item 
bool \hyperlink{group__highprec_ga45ce0494cfd96e6cb2e6f7b0a3118922}{ns3\+::operator$>$=} (const \hyperlink{classint64x64__t}{int64x64\+\_\+t} \&lhs, const \hyperlink{classint64x64__t}{int64x64\+\_\+t} \&rhs)
\item 
std\+::ostream \& \hyperlink{group__highprec_gacfc7789be6cdaac56adb76c0d0354d13}{ns3\+::operator$<$$<$} (std\+::ostream \&os, const \hyperlink{classint64x64__t}{int64x64\+\_\+t} \&value)
\item 
std\+::istream \& \hyperlink{group__highprec_gabf6ecbf5acccc352c1b1c0835cac66f2}{ns3\+::operator$>$$>$} (std\+::istream \&is, \hyperlink{classint64x64__t}{int64x64\+\_\+t} \&value)
\item 
\hyperlink{classint64x64__t}{int64x64\+\_\+t} \hyperlink{group__highprec_gabf87260a0ba68d152ae95568b2ef58fe}{ns3\+::\+Abs} (const \hyperlink{classint64x64__t}{int64x64\+\_\+t} \&value)
\item 
\hyperlink{classint64x64__t}{int64x64\+\_\+t} \hyperlink{group__highprec_gacb0b89d5f4363bf77747ff1212f27430}{ns3\+::\+Min} (const \hyperlink{classint64x64__t}{int64x64\+\_\+t} \&a, const \hyperlink{classint64x64__t}{int64x64\+\_\+t} \&\hyperlink{lte__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b})
\item 
\hyperlink{classint64x64__t}{int64x64\+\_\+t} \hyperlink{group__highprec_ga0d35bb9363c0da4cc2557158b95dbca0}{ns3\+::\+Max} (const \hyperlink{classint64x64__t}{int64x64\+\_\+t} \&a, const \hyperlink{classint64x64__t}{int64x64\+\_\+t} \&\hyperlink{lte__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b})
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Functions and class for high precision Q64.\+64 fixed point arithmetic.

A Q64.\+64 fixed precision number consists of\+:

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*2{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}{\bf Bits }&{\bf Function  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}{\bf Bits }&{\bf Function  }\\\cline{1-2}
\endhead
1 &Sign bit \\\cline{1-2}
63 &Integer portion \\\cline{1-2}
64 &Fractional portion \\\cline{1-2}
\end{longtabu}
The {\ttfamily high} word consists of the sign bit and integer value; the {\ttfamily low} word is the fractional part, unscaled.

All standard arithmetic operations are supported\+:

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*2{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}{\bf Category }&{\bf Operators  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}{\bf Category }&{\bf Operators  }\\\cline{1-2}
\endhead
Computation &{\ttfamily +}, {\ttfamily +=}, {\ttfamily -\/}, {\ttfamily -\/=}, {\ttfamily $\ast$}, {\ttfamily $\ast$=}, {\ttfamily /}, {\ttfamily /=} \\\cline{1-2}
Comparison &{\ttfamily ==}, {\ttfamily !=}, {\ttfamily $<$}, {\ttfamily $<$=}, {\ttfamily $>$}, {\ttfamily $>$=} \\\cline{1-2}
Unary &{\ttfamily +}, {\ttfamily -\/}, {\ttfamily !} \\\cline{1-2}
\end{longtabu}


\subsection{Macro Definition Documentation}
\index{High Precision Q64.\+64@{High Precision Q64.\+64}!H\+E\+X\+H\+I\+L\+OW@{H\+E\+X\+H\+I\+L\+OW}}
\index{H\+E\+X\+H\+I\+L\+OW@{H\+E\+X\+H\+I\+L\+OW}!High Precision Q64.\+64@{High Precision Q64.\+64}}
\subsubsection[{\texorpdfstring{H\+E\+X\+H\+I\+L\+OW}{HEXHILOW}}]{\setlength{\rightskip}{0pt plus 5cm}\#define H\+E\+X\+H\+I\+L\+OW(
\begin{DoxyParamCaption}
\item[{}]{hi, }
\item[{}]{lo}
\end{DoxyParamCaption}
)}\hypertarget{group__highprec_gab4ef18031edb07b2d7cb6197583f3c51}{}\label{group__highprec_gab4ef18031edb07b2d7cb6197583f3c51}
{\bfseries Value\+:}
\begin{DoxyCode}
std::hex << std::setfill (\textcolor{charliteral}{'0'}) << std::right << \textcolor{stringliteral}{" (0x"}                \(\backslash\)
           << std::setw (16) << hi << \textcolor{stringliteral}{" "}                               \(\backslash\)
           << std::setw (16) << lo                                      \(\backslash\)
           << std::dec << std::setfill (\textcolor{charliteral}{' '}) << std::left << \textcolor{stringliteral}{")"}
\end{DoxyCode}
Print the high and low words of an int64x64 in hex, for debugging.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em hi} & The high (integer) word. \\
\hline
\mbox{\tt in}  & {\em lo} & The low (fractional) work. \\
\hline
\end{DoxyParams}


\subsection{Function Documentation}
\index{High Precision Q64.\+64@{High Precision Q64.\+64}!Abs@{Abs}}
\index{Abs@{Abs}!High Precision Q64.\+64@{High Precision Q64.\+64}}
\subsubsection[{\texorpdfstring{Abs(const int64x64\+\_\+t \&value)}{Abs(const int64x64_t &value)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf int64x64\+\_\+t} ns3\+::\+Abs (
\begin{DoxyParamCaption}
\item[{const {\bf int64x64\+\_\+t} \&}]{value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{group__highprec_gabf87260a0ba68d152ae95568b2ef58fe}{}\label{group__highprec_gabf87260a0ba68d152ae95568b2ef58fe}
Absolute value. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em value} & The value to operate on. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The absolute value of {\ttfamily value}. 
\end{DoxyReturn}

\begin{DoxyCode}
185 \{
186   \textcolor{keywordflow}{return} (value < 0) ? -value : value;
187 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 0


\index{High Precision Q64.\+64@{High Precision Q64.\+64}!Max@{Max}}
\index{Max@{Max}!High Precision Q64.\+64@{High Precision Q64.\+64}}
\subsubsection[{\texorpdfstring{Max(const int64x64\+\_\+t \&a, const int64x64\+\_\+t \&b)}{Max(const int64x64_t &a, const int64x64_t &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf int64x64\+\_\+t} ns3\+::\+Max (
\begin{DoxyParamCaption}
\item[{const {\bf int64x64\+\_\+t} \&}]{a, }
\item[{const {\bf int64x64\+\_\+t} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{group__highprec_ga0d35bb9363c0da4cc2557158b95dbca0}{}\label{group__highprec_ga0d35bb9363c0da4cc2557158b95dbca0}
Maximum.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em a} & The first value. \\
\hline
\mbox{\tt in}  & {\em b} & The second value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The larger of the arguments. 
\end{DoxyReturn}

\begin{DoxyCode}
210 \{
211   \textcolor{keywordflow}{return} (a > b) ? a : \hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b};
212 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 1


\index{High Precision Q64.\+64@{High Precision Q64.\+64}!Min@{Min}}
\index{Min@{Min}!High Precision Q64.\+64@{High Precision Q64.\+64}}
\subsubsection[{\texorpdfstring{Min(const int64x64\+\_\+t \&a, const int64x64\+\_\+t \&b)}{Min(const int64x64_t &a, const int64x64_t &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf int64x64\+\_\+t} ns3\+::\+Min (
\begin{DoxyParamCaption}
\item[{const {\bf int64x64\+\_\+t} \&}]{a, }
\item[{const {\bf int64x64\+\_\+t} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{group__highprec_gacb0b89d5f4363bf77747ff1212f27430}{}\label{group__highprec_gacb0b89d5f4363bf77747ff1212f27430}
Minimum.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em a} & The first value. \\
\hline
\mbox{\tt in}  & {\em b} & The second value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The smaller of the arguments. 
\end{DoxyReturn}

\begin{DoxyCode}
198 \{
199   \textcolor{keywordflow}{return} (a < b) ? a : \hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b};
200 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 2


\index{High Precision Q64.\+64@{High Precision Q64.\+64}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!High Precision Q64.\+64@{High Precision Q64.\+64}}
\subsubsection[{\texorpdfstring{operator"!=(const int64x64\+\_\+t \&lhs, const int64x64\+\_\+t \&rhs)}{operator!=(const int64x64_t &lhs, const int64x64_t &rhs)}}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf ns3\+::operator!}= (
\begin{DoxyParamCaption}
\item[{const {\bf int64x64\+\_\+t} \&}]{lhs, }
\item[{const {\bf int64x64\+\_\+t} \&}]{rhs}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{group__highprec_gad876786cb1dfba302360a73649bbd8b2}{}\label{group__highprec_gad876786cb1dfba302360a73649bbd8b2}
Inequality operator 
\begin{DoxyCode}
130 \{
131   \textcolor{keywordflow}{return} !(lhs == rhs);
132 \}
\end{DoxyCode}
\index{High Precision Q64.\+64@{High Precision Q64.\+64}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!High Precision Q64.\+64@{High Precision Q64.\+64}}
\subsubsection[{\texorpdfstring{operator$\ast$(const int64x64\+\_\+t \&lhs, const int64x64\+\_\+t \&rhs)}{operator*(const int64x64_t &lhs, const int64x64_t &rhs)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf int64x64\+\_\+t} ns3\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf int64x64\+\_\+t} \&}]{lhs, }
\item[{const {\bf int64x64\+\_\+t} \&}]{rhs}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{group__highprec_gad1ce534b470c0bddc3bc679d93161728}{}\label{group__highprec_gad1ce534b470c0bddc3bc679d93161728}
Multiplication operator. 
\begin{DoxyCode}
109 \{
110   \hyperlink{classint64x64__t}{int64x64\_t} tmp = lhs;
111   tmp *= rhs;
112   \textcolor{keywordflow}{return} tmp;
113 \}
\end{DoxyCode}
\index{High Precision Q64.\+64@{High Precision Q64.\+64}!operator+@{operator+}}
\index{operator+@{operator+}!High Precision Q64.\+64@{High Precision Q64.\+64}}
\subsubsection[{\texorpdfstring{operator+(const int64x64\+\_\+t \&lhs, const int64x64\+\_\+t \&rhs)}{operator+(const int64x64_t &lhs, const int64x64_t &rhs)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf int64x64\+\_\+t} ns3\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf int64x64\+\_\+t} \&}]{lhs, }
\item[{const {\bf int64x64\+\_\+t} \&}]{rhs}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{group__highprec_gabf48acdbe8e677584a67e4b34f896fd8}{}\label{group__highprec_gabf48acdbe8e677584a67e4b34f896fd8}
Addition operator. 
\begin{DoxyCode}
87 \{
88   \hyperlink{classint64x64__t}{int64x64\_t} tmp = lhs;
89   tmp += rhs;
90   \textcolor{keywordflow}{return} tmp;
91 \}
\end{DoxyCode}
\index{High Precision Q64.\+64@{High Precision Q64.\+64}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!High Precision Q64.\+64@{High Precision Q64.\+64}}
\subsubsection[{\texorpdfstring{operator-\/(const int64x64\+\_\+t \&lhs, const int64x64\+\_\+t \&rhs)}{operator-(const int64x64_t &lhs, const int64x64_t &rhs)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf int64x64\+\_\+t} ns3\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf int64x64\+\_\+t} \&}]{lhs, }
\item[{const {\bf int64x64\+\_\+t} \&}]{rhs}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{group__highprec_ga93f56e20943fd7ba3c1d45515a58432c}{}\label{group__highprec_ga93f56e20943fd7ba3c1d45515a58432c}
Subtraction operator. 
\begin{DoxyCode}
98 \{
99   \hyperlink{classint64x64__t}{int64x64\_t} tmp = lhs;
100   tmp -= rhs;
101   \textcolor{keywordflow}{return} tmp;
102 \}
\end{DoxyCode}
\index{High Precision Q64.\+64@{High Precision Q64.\+64}!operator/@{operator/}}
\index{operator/@{operator/}!High Precision Q64.\+64@{High Precision Q64.\+64}}
\subsubsection[{\texorpdfstring{operator/(const int64x64\+\_\+t \&lhs, const int64x64\+\_\+t \&rhs)}{operator/(const int64x64_t &lhs, const int64x64_t &rhs)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf int64x64\+\_\+t} ns3\+::operator/ (
\begin{DoxyParamCaption}
\item[{const {\bf int64x64\+\_\+t} \&}]{lhs, }
\item[{const {\bf int64x64\+\_\+t} \&}]{rhs}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{group__highprec_ga3a9ee0daa263697c2128076b242f65d4}{}\label{group__highprec_ga3a9ee0daa263697c2128076b242f65d4}
Division operator. 
\begin{DoxyCode}
120 \{
121   \hyperlink{classint64x64__t}{int64x64\_t} tmp = lhs;
122   tmp /= rhs;
123   \textcolor{keywordflow}{return} tmp;
124 \}
\end{DoxyCode}
\index{High Precision Q64.\+64@{High Precision Q64.\+64}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!High Precision Q64.\+64@{High Precision Q64.\+64}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&os, const int64x64\+\_\+t \&value)}{operator<<(std::ostream &os, const int64x64_t &value)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream \& ns3\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os, }
\item[{const {\bf int64x64\+\_\+t} \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{group__highprec_gacfc7789be6cdaac56adb76c0d0354d13}{}\label{group__highprec_gacfc7789be6cdaac56adb76c0d0354d13}
Output streamer for \hyperlink{classint64x64__t}{int64x64\+\_\+t}.

Values are printed with the following format flags (independent of the the stream flags)\+:
\begin{DoxyItemize}
\item {\ttfamily showpos}
\item {\ttfamily left}
\end{DoxyItemize}

The stream {\ttfamily width} is ignored. If {\ttfamily floatfield} is set, {\ttfamily precision} decimal places are printed. If {\ttfamily floatfield} is not set, all digits of the fractional part are printed, up to the representation limit of 20 digits; trailing zeros are omitted.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em os} & The output stream. \\
\hline
\mbox{\tt in}  & {\em value} & The numerical value to print. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The stream. 
\end{DoxyReturn}

\begin{DoxyCode}
70 \{
71   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} negative = (value < 0);
72   \textcolor{keyword}{const} \hyperlink{classint64x64__t}{int64x64\_t} absVal = (negative ? -value : value);
73 
74   int64\_t hi = absVal.GetHigh ();
75 
76   \textcolor{comment}{// Save stream format flags}
77   std::size\_t precision = \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>} (os.precision ());
78   std::ios\_base::fmtflags ff = os.flags ();
79   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} floatfield = os.flags () & std::ios\_base::floatfield;
80   os << std::setw (1) << std::noshowpos;
81 
82   os << std::right << (negative ? \textcolor{stringliteral}{"-"} : \textcolor{stringliteral}{"+"});
83 
84   std::ostringstream oss;
85   oss << hi << \textcolor{stringliteral}{"."};  \textcolor{comment}{// collect the digits here so we can round properly}
86 
87 
88   \hyperlink{classint64x64__t}{int64x64\_t} low(0, absVal.GetLow ());
89   std::size\_t places = 0;    \textcolor{comment}{// Number of decimal places printed so far}
90   \textcolor{keywordtype}{bool} more = \textcolor{keyword}{true};  \textcolor{comment}{// Should we print more digits?}
91 
92   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (std::endl
93                 << (floatfield ? \textcolor{stringliteral}{" f"} : \textcolor{stringliteral}{"  "})
94                 << \textcolor{stringliteral}{"["} << precision << \textcolor{stringliteral}{"] "} << hi << \textcolor{stringliteral}{". "}
95                 << \hyperlink{group__highprec_gab4ef18031edb07b2d7cb6197583f3c51}{HEXHILOW} (hi, low.GetLow ())
96                 );
97 
98   int64\_t digit;
99   \textcolor{keywordflow}{do}
100     \{
101       low *= 10;
102       digit = low.GetHigh ();
103       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} ( (0 <= digit) && (digit <= 9),
104                       \textcolor{stringliteral}{"digit "} << digit << \textcolor{stringliteral}{" out of range [0,9] "}
105                       << \textcolor{stringliteral}{" streaming out "}
106                       << \hyperlink{group__highprec_gab4ef18031edb07b2d7cb6197583f3c51}{HEXHILOW} (value.GetHigh (), value.GetLow ()) );
107       low -= digit;
108 
109       oss << std::setw (1) << digit;
110 
111       ++places;
112       \textcolor{keywordflow}{if} (floatfield)
113         \{
114           more = places < precision;
115         \}
116       \textcolor{keywordflow}{else}  \textcolor{comment}{// default}
117         \{
118           \textcolor{comment}{// Full resolution is 20 decimal digits}
119           more = low.GetLow () && (places < 20);
120         \}
121 
122       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} ((more ? \textcolor{stringliteral}{"+"} : \textcolor{stringliteral}{" "})
123                     << (floatfield ? \textcolor{stringliteral}{"f"} : \textcolor{stringliteral}{" "})
124                     << \textcolor{stringliteral}{"["} << places << \textcolor{stringliteral}{"] "} << digit
125                     << \hyperlink{group__highprec_gab4ef18031edb07b2d7cb6197583f3c51}{HEXHILOW} (low.GetHigh (), low.GetLow ())
126                     << std::dec << std::setfill (\textcolor{charliteral}{' '} ) << std::left);
127 
128     \} \textcolor{keywordflow}{while} (more);
129 
130   \textcolor{comment}{// Check if we need to round the last printed digit,}
131   \textcolor{comment}{// based on the first unprinted digit}
132   std::string digits = oss.str ();
133   low *= 10;
134   int64\_t nextDigit = low.GetHigh ();
135   \textcolor{keywordflow}{if} ( (nextDigit > 5) || ((nextDigit == 5) && (digit % 2 == 1)) )
136     \{
137       \textcolor{comment}{// Walk backwards with the carry}
138       \textcolor{keywordtype}{bool} carry = \textcolor{keyword}{true};
139       \textcolor{keywordflow}{for} (std::string::reverse\_iterator rit = digits.rbegin ();
140            rit != digits.rend ();
141            ++rit)
142         \{
143           \textcolor{keywordflow}{if} (*rit == \textcolor{charliteral}{'.'})  \textcolor{comment}{// Skip over the decimal point}
144             \{
145               continue ;
146             \}
147 
148           ++(*rit);         \textcolor{comment}{// Add the carry}
149           \textcolor{keywordflow}{if} (*rit <= \textcolor{charliteral}{'9'})  \textcolor{comment}{// Relies on character order...}
150             \{
151               carry = \textcolor{keyword}{false};
152               break ;       \textcolor{comment}{// Carry complete}
153             \}
154           \textcolor{keywordflow}{else}
155             \{
156               *rit = \textcolor{charliteral}{'0'};     \textcolor{comment}{// Continue carry to next higher digit}
157             \}
158         \}
159       \textcolor{keywordflow}{if} (carry)            \textcolor{comment}{// If we still have a carry...}
160         \{
161           digits.insert (digits.begin (), \textcolor{charliteral}{'1'});
162         \}
163     \}
164   os << digits;
165 
166   os.flags (ff);  \textcolor{comment}{// Restore stream flags}
167   \textcolor{keywordflow}{return} os;
168 \}
\end{DoxyCode}
\index{High Precision Q64.\+64@{High Precision Q64.\+64}!operator$<$=@{operator$<$=}}
\index{operator$<$=@{operator$<$=}!High Precision Q64.\+64@{High Precision Q64.\+64}}
\subsubsection[{\texorpdfstring{operator$<$=(const int64x64\+\_\+t \&lhs, const int64x64\+\_\+t \&rhs)}{operator<=(const int64x64_t &lhs, const int64x64_t &rhs)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::operator$<$= (
\begin{DoxyParamCaption}
\item[{const {\bf int64x64\+\_\+t} \&}]{lhs, }
\item[{const {\bf int64x64\+\_\+t} \&}]{rhs}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{group__highprec_ga484976d59a10b4aac98c32a3e656ca6c}{}\label{group__highprec_ga484976d59a10b4aac98c32a3e656ca6c}
Less or equal operator. 
\begin{DoxyCode}
138 \{
139   \textcolor{keywordflow}{return} !(lhs > rhs);
140 \}
\end{DoxyCode}
\index{High Precision Q64.\+64@{High Precision Q64.\+64}!operator$>$=@{operator$>$=}}
\index{operator$>$=@{operator$>$=}!High Precision Q64.\+64@{High Precision Q64.\+64}}
\subsubsection[{\texorpdfstring{operator$>$=(const int64x64\+\_\+t \&lhs, const int64x64\+\_\+t \&rhs)}{operator>=(const int64x64_t &lhs, const int64x64_t &rhs)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::operator$>$= (
\begin{DoxyParamCaption}
\item[{const {\bf int64x64\+\_\+t} \&}]{lhs, }
\item[{const {\bf int64x64\+\_\+t} \&}]{rhs}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{group__highprec_ga45ce0494cfd96e6cb2e6f7b0a3118922}{}\label{group__highprec_ga45ce0494cfd96e6cb2e6f7b0a3118922}
Greater or equal operator. 
\begin{DoxyCode}
146 \{
147   \textcolor{keywordflow}{return} !(lhs < rhs);
148 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{High Precision Q64.\+64@{High Precision Q64.\+64}!operator$>$$>$@{operator$>$$>$}}
\index{operator$>$$>$@{operator$>$$>$}!High Precision Q64.\+64@{High Precision Q64.\+64}}
\subsubsection[{\texorpdfstring{operator$>$$>$(std\+::istream \&is, int64x64\+\_\+t \&value)}{operator>>(std::istream &is, int64x64_t &value)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::istream \& ns3\+::operator$>$$>$ (
\begin{DoxyParamCaption}
\item[{std\+::istream \&}]{is, }
\item[{{\bf int64x64\+\_\+t} \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{group__highprec_gabf6ecbf5acccc352c1b1c0835cac66f2}{}\label{group__highprec_gabf6ecbf5acccc352c1b1c0835cac66f2}
Input streamer for \hyperlink{classint64x64__t}{int64x64\+\_\+t}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em is} & The input stream. \\
\hline
\mbox{\tt out}  & {\em value} & The numerical value to set. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The stream. 
\end{DoxyReturn}

\begin{DoxyCode}
222 \{
223   std::string str;
224 
225   is >> str;
226   \textcolor{keywordtype}{bool} negative;
227   \textcolor{comment}{// skip heading spaces}
228   std::string::size\_type cur;
229   cur = str.find\_first\_not\_of (\textcolor{stringliteral}{" "});
230   std::string::size\_type next;
231   \textcolor{comment}{// first, remove the sign.}
232   next = str.find (\textcolor{stringliteral}{"-"}, cur);
233   \textcolor{keywordflow}{if} (next != std::string::npos)
234     \{
235       negative = \textcolor{keyword}{true};
236       next++;
237     \}
238   \textcolor{keywordflow}{else}
239     \{
240       next = str.find (\textcolor{stringliteral}{"+"}, cur);
241       \textcolor{keywordflow}{if} (next != std::string::npos)
242         \{
243           next++;
244         \}
245       \textcolor{keywordflow}{else}
246         \{
247           next = cur;
248         \}
249       negative = \textcolor{keyword}{false};
250     \}
251   cur = next;
252   int64\_t hi;
253   uint64\_t lo;
254   next = str.find (\textcolor{stringliteral}{"."}, cur);
255   \textcolor{keywordflow}{if} (next != std::string::npos)
256     \{
257       hi = \hyperlink{group__highprec_gaa469dde0cf73e354d1e44a7501c53a53}{ReadHiDigits} (str.substr (cur, next-cur));
258       lo = \hyperlink{group__highprec_gab93a9afd92c0bdab641e9bd5f8d7fd1a}{ReadLoDigits} (str.substr (next+1, str.size ()-(next+1)));
259     \}
260   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (cur != std::string::npos)
261     \{
262       hi = \hyperlink{group__highprec_gaa469dde0cf73e354d1e44a7501c53a53}{ReadHiDigits} (str.substr (cur, str.size ()-cur));
263       lo = 0;
264     \}
265   \textcolor{keywordflow}{else}
266     \{
267       hi = 0;
268       lo = 0;
269     \}
270 
271   value = \hyperlink{classint64x64__t}{int64x64\_t} (hi, lo);
272   value = negative ? -value : value;
273 
274   \textcolor{keywordflow}{return} is;
275 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4


\index{High Precision Q64.\+64@{High Precision Q64.\+64}!output\+\_\+sign@{output\+\_\+sign}}
\index{output\+\_\+sign@{output\+\_\+sign}!High Precision Q64.\+64@{High Precision Q64.\+64}}
\subsubsection[{\texorpdfstring{output\+\_\+sign(const int128\+\_\+t sa, const int128\+\_\+t sb, uint128\+\_\+t \&ua, uint128\+\_\+t \&ub)}{output_sign(const int128_t sa, const int128_t sb, uint128_t &ua, uint128_t &ub)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool ns3\+::output\+\_\+sign (
\begin{DoxyParamCaption}
\item[{const int128\+\_\+t}]{sa, }
\item[{const int128\+\_\+t}]{sb, }
\item[{uint128\+\_\+t \&}]{ua, }
\item[{uint128\+\_\+t \&}]{ub}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{group__highprec_gaeeaaf0f56a7e311cabc5db7213d91779}{}\label{group__highprec_gaeeaaf0f56a7e311cabc5db7213d91779}
Compute the sign of the result of multiplying or dividing Q64.\+64 fixed precision operands.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em sa} & The signed value of the first operand. \\
\hline
\mbox{\tt in}  & {\em sb} & The signed value of the second operand. \\
\hline
\mbox{\tt out}  & {\em ua} & The unsigned magnitude of the first operand. \\
\hline
\mbox{\tt out}  & {\em ub} & The unsigned magnitude of the second operand. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily true} if the result will be negative. 
\end{DoxyReturn}

\begin{DoxyCode}
55 \{
56   \textcolor{keywordtype}{bool} negA = sa < 0;
57   \textcolor{keywordtype}{bool} negB = sb < 0;
58   ua = negA ? -sa : sa;
59   ub = negB ? -sb : sb;
60   \textcolor{keywordflow}{return} (negA && !negB) || (!negA && negB);
61 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 5


\index{High Precision Q64.\+64@{High Precision Q64.\+64}!output\+\_\+sign@{output\+\_\+sign}}
\index{output\+\_\+sign@{output\+\_\+sign}!High Precision Q64.\+64@{High Precision Q64.\+64}}
\subsubsection[{\texorpdfstring{output\+\_\+sign(const cairo\+\_\+int128\+\_\+t sa, const cairo\+\_\+int128\+\_\+t sb, cairo\+\_\+uint128\+\_\+t \&ua, cairo\+\_\+uint128\+\_\+t \&ub)}{output_sign(const cairo_int128_t sa, const cairo_int128_t sb, cairo_uint128_t &ua, cairo_uint128_t &ub)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool ns3\+::output\+\_\+sign (
\begin{DoxyParamCaption}
\item[{const {\bf cairo\+\_\+int128\+\_\+t}}]{sa, }
\item[{const {\bf cairo\+\_\+int128\+\_\+t}}]{sb, }
\item[{{\bf cairo\+\_\+uint128\+\_\+t} \&}]{ua, }
\item[{{\bf cairo\+\_\+uint128\+\_\+t} \&}]{ub}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{group__highprec_gabc1eadf47a990215c1b0b131d4f52cf9}{}\label{group__highprec_gabc1eadf47a990215c1b0b131d4f52cf9}
Compute the sign of the result of multiplying or dividing Q64.\+64 fixed precision operands.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em sa} & The signed value of the first operand. \\
\hline
\mbox{\tt in}  & {\em sb} & The signed value of the second operand. \\
\hline
\mbox{\tt out}  & {\em ua} & The unsigned magnitude of the first operand. \\
\hline
\mbox{\tt out}  & {\em ub} & The unsigned magnitude of the second operand. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the result will be negative. 
\end{DoxyReturn}

\begin{DoxyCode}
63 \{
64   \textcolor{keywordtype}{bool} negA = \hyperlink{cairo-wideint-private_8h_abe9f5985fa35ff60c53c8e3f163be3af}{\_cairo\_int128\_negative} (sa);
65   \textcolor{keywordtype}{bool} negB = \hyperlink{cairo-wideint-private_8h_abe9f5985fa35ff60c53c8e3f163be3af}{\_cairo\_int128\_negative} (sb);
66   ua = \hyperlink{cairo-wideint-private_8h_a5225ab944759b13e769c7e9edecfc6aa}{\_cairo\_int128\_to\_uint128} (sa);
67   ub = \hyperlink{cairo-wideint-private_8h_a5225ab944759b13e769c7e9edecfc6aa}{\_cairo\_int128\_to\_uint128} (sb);
68   ua = negA ? \hyperlink{cairo-wideint-private_8h_a8a956d8a7c9aae561c5d2440c8f3ba1d}{\_cairo\_uint128\_negate} (ua) : ua;
69   ub = negB ? \hyperlink{cairo-wideint-private_8h_a8a956d8a7c9aae561c5d2440c8f3ba1d}{\_cairo\_uint128\_negate} (ub) : ub;
70   \textcolor{keywordflow}{return} (negA && !negB) || (!negA && negB);
71 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6


\index{High Precision Q64.\+64@{High Precision Q64.\+64}!Read\+Hi\+Digits@{Read\+Hi\+Digits}}
\index{Read\+Hi\+Digits@{Read\+Hi\+Digits}!High Precision Q64.\+64@{High Precision Q64.\+64}}
\subsubsection[{\texorpdfstring{Read\+Hi\+Digits(std\+::string str)}{ReadHiDigits(std::string str)}}]{\setlength{\rightskip}{0pt plus 5cm}static uint64\+\_\+t ns3\+::\+Read\+Hi\+Digits (
\begin{DoxyParamCaption}
\item[{std\+::string}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{group__highprec_gaa469dde0cf73e354d1e44a7501c53a53}{}\label{group__highprec_gaa469dde0cf73e354d1e44a7501c53a53}
Read the integer portion of a number from a string containing just the integral digits (no decimal point or fractional part).


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & The string representation of the integral part of a number, with no fractional part or decimal point. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The integer. 
\end{DoxyReturn}

\begin{DoxyCode}
180 \{
181   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *buf = str.c\_str ();
182   uint64\_t retval = 0;
183   \textcolor{keywordflow}{while} (*buf != 0)
184     \{
185       retval *= 10;
186       retval += *buf - \textcolor{charliteral}{'0'};
187       buf++;
188     \}
189   \textcolor{keywordflow}{return} retval;
190 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 7


\index{High Precision Q64.\+64@{High Precision Q64.\+64}!Read\+Lo\+Digits@{Read\+Lo\+Digits}}
\index{Read\+Lo\+Digits@{Read\+Lo\+Digits}!High Precision Q64.\+64@{High Precision Q64.\+64}}
\subsubsection[{\texorpdfstring{Read\+Lo\+Digits(std\+::string str)}{ReadLoDigits(std::string str)}}]{\setlength{\rightskip}{0pt plus 5cm}static uint64\+\_\+t ns3\+::\+Read\+Lo\+Digits (
\begin{DoxyParamCaption}
\item[{std\+::string}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{group__highprec_gab93a9afd92c0bdab641e9bd5f8d7fd1a}{}\label{group__highprec_gab93a9afd92c0bdab641e9bd5f8d7fd1a}
Read the fractional part of a number from a string containing just the decimal digits of the fractional part (no integral part or decimal point).


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & The string representation of the fractional part of a number, without integral part or decimal point. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The decimal portion of the input number. 
\end{DoxyReturn}

\begin{DoxyCode}
203 \{
204   \hyperlink{classint64x64__t}{int64x64\_t} low;
205   \textcolor{keyword}{const} \hyperlink{classint64x64__t}{int64x64\_t} round (0, 5);  \textcolor{comment}{// Round last place in division}
206 
207   \textcolor{keywordflow}{for} (std::string::const\_reverse\_iterator rit = str.rbegin ();
208        rit != str.rend ();
209        ++rit)
210     \{
211       \textcolor{keywordtype}{int} digit = *rit - \textcolor{charliteral}{'0'};
212       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} ( (0 <= digit) && (digit <= 9),
213                       \textcolor{stringliteral}{"digit "} << digit << \textcolor{stringliteral}{" out of range [0,9]"}
214                       << \textcolor{stringliteral}{" streaming in low digits \(\backslash\)""} << str << \textcolor{stringliteral}{"\(\backslash\)""});
215       low = (low + digit + round) / 10;
216     \}
217 
218   \textcolor{keywordflow}{return} low.GetLow ();
219 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 8


