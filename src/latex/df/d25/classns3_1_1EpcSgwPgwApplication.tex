\hypertarget{classns3_1_1EpcSgwPgwApplication}{}\section{ns3\+:\+:Epc\+Sgw\+Pgw\+Application Class Reference}
\label{classns3_1_1EpcSgwPgwApplication}\index{ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}}


{\ttfamily \#include $<$epc-\/sgw-\/pgw-\/application.\+h$>$}



Inheritance diagram for ns3\+:\+:Epc\+Sgw\+Pgw\+Application\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Epc\+Sgw\+Pgw\+Application\+:
% FIG 1
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structns3_1_1EpcSgwPgwApplication_1_1EnbInfo}{Enb\+Info}
\item 
class \hyperlink{classns3_1_1EpcSgwPgwApplication_1_1UeInfo}{Ue\+Info}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1EpcSgwPgwApplication_a8cec25fb185f15c9862a1f1e31c66525}{Do\+Dispose} ()
\item 
\hyperlink{classns3_1_1EpcSgwPgwApplication_a0e8cdb651b4f5327d32d9a5bc52d6717}{Epc\+Sgw\+Pgw\+Application} (const \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1VirtualNetDevice}{Virtual\+Net\+Device} $>$ tun\+Device, const \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$ s1u\+Socket)
\item 
virtual \hyperlink{classns3_1_1EpcSgwPgwApplication_a0ca75fd4a63ac1a7f4875f7ca7e2ffdf}{$\sim$\+Epc\+Sgw\+Pgw\+Application} (void)
\item 
bool \hyperlink{classns3_1_1EpcSgwPgwApplication_aeea285ccd04a4350e4ddb77a359e97ca}{Recv\+From\+Tun\+Device} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, const \hyperlink{classns3_1_1Address}{Address} \&source, const \hyperlink{classns3_1_1Address}{Address} \&dest, uint16\+\_\+t protocol\+Number)
\item 
void \hyperlink{classns3_1_1EpcSgwPgwApplication_adab529c65e1174c5568016cc91e5dedd}{Recv\+From\+S1u\+Socket} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$ socket)
\item 
void \hyperlink{classns3_1_1EpcSgwPgwApplication_a7c2922506ab9a7d14ebb83d8887c9faf}{Send\+To\+Tun\+Device} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, uint32\+\_\+t teid)
\item 
void \hyperlink{classns3_1_1EpcSgwPgwApplication_a32232c4e589789e118db44c4883cebb1}{Send\+To\+S1u\+Socket} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} enb\+S1u\+Address, uint32\+\_\+t teid)
\item 
void \hyperlink{classns3_1_1EpcSgwPgwApplication_af135dedf794394760179db0de9ba47ea}{Set\+S11\+Sap\+Mme} (\hyperlink{classns3_1_1EpcS11SapMme}{Epc\+S11\+Sap\+Mme} $\ast$\hyperlink{generate__test__data__lte__sinr_8m_ad83eeb3a142285d1243a08c6b7026df8}{s})
\item 
\hyperlink{classns3_1_1EpcS11SapSgw}{Epc\+S11\+Sap\+Sgw} $\ast$ \hyperlink{classns3_1_1EpcSgwPgwApplication_af709794f4a8bfbdccd451261d4525570}{Get\+S11\+Sap\+Sgw} ()
\item 
void \hyperlink{classns3_1_1EpcSgwPgwApplication_af59a96aed58de1ac0adefe13ec6a3fa4}{Add\+Enb} (uint16\+\_\+t cell\+Id, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} enb\+Addr, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} sgw\+Addr)
\item 
void \hyperlink{classns3_1_1EpcSgwPgwApplication_adce905cafa429fbd0625c6018b68abd6}{Add\+Ue} (uint64\+\_\+t imsi)
\item 
void \hyperlink{classns3_1_1EpcSgwPgwApplication_aef71dc53ba3d67850a5e98810a6f2961}{Set\+Ue\+Address} (uint64\+\_\+t imsi, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} ue\+Addr)
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1EpcSgwPgwApplication_a2cf6a61dcdb46991e2a19cf44626f2e9}{Get\+Type\+Id} (void)
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classns3_1_1EpcSgwPgwApplication_a994ec0a8365d89b589bf2ed4d2051e2d}{Do\+Create\+Session\+Request} (\hyperlink{structns3_1_1EpcS11SapSgw_1_1CreateSessionRequestMessage}{Epc\+S11\+Sap\+Sgw\+::\+Create\+Session\+Request\+Message} msg)
\item 
void \hyperlink{classns3_1_1EpcSgwPgwApplication_a90fb12acb1c198b0bb13196c9f620f8b}{Do\+Modify\+Bearer\+Request} (\hyperlink{structns3_1_1EpcS11SapSgw_1_1ModifyBearerRequestMessage}{Epc\+S11\+Sap\+Sgw\+::\+Modify\+Bearer\+Request\+Message} msg)
\item 
void \hyperlink{classns3_1_1EpcSgwPgwApplication_a4eb98a93b6353fb24f0d821ecc1055a2}{Do\+Delete\+Bearer\+Command} (\hyperlink{structns3_1_1EpcS11SapSgw_1_1DeleteBearerCommandMessage}{Epc\+S11\+Sap\+Sgw\+::\+Delete\+Bearer\+Command\+Message} req)
\item 
void \hyperlink{classns3_1_1EpcSgwPgwApplication_a8e8dde46ca31002ef4da8cae64140e68}{Do\+Delete\+Bearer\+Response} (\hyperlink{structns3_1_1EpcS11SapSgw_1_1DeleteBearerResponseMessage}{Epc\+S11\+Sap\+Sgw\+::\+Delete\+Bearer\+Response\+Message} req)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$ \hyperlink{classns3_1_1EpcSgwPgwApplication_a2a36f49986d4851e3c184007c6480a90}{m\+\_\+s1u\+Socket}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1VirtualNetDevice}{Virtual\+Net\+Device} $>$ \hyperlink{classns3_1_1EpcSgwPgwApplication_abfd29706464464933ddc5a72469a97e1}{m\+\_\+tun\+Device}
\item 
std\+::map$<$ \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address}, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1EpcSgwPgwApplication_1_1UeInfo}{Ue\+Info} $>$ $>$ \hyperlink{classns3_1_1EpcSgwPgwApplication_ac5d167ff997bd9618e832a371f45cba0}{m\+\_\+ue\+Info\+By\+Addr\+Map}
\item 
std\+::map$<$ uint64\+\_\+t, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1EpcSgwPgwApplication_1_1UeInfo}{Ue\+Info} $>$ $>$ \hyperlink{classns3_1_1EpcSgwPgwApplication_ac026923e4b06703faf659f0584573531}{m\+\_\+ue\+Info\+By\+Imsi\+Map}
\item 
uint16\+\_\+t \hyperlink{classns3_1_1EpcSgwPgwApplication_aaf54b6467029f7c3f038da709da10a09}{m\+\_\+gtpu\+Udp\+Port}
\item 
uint32\+\_\+t \hyperlink{classns3_1_1EpcSgwPgwApplication_a160d5f7d28ef531f5fc9bd9bdd5ac9ff}{m\+\_\+teid\+Count}
\item 
\hyperlink{classns3_1_1EpcS11SapMme}{Epc\+S11\+Sap\+Mme} $\ast$ \hyperlink{classns3_1_1EpcSgwPgwApplication_a37809771f2d925005b7deab8c5a2de3c}{m\+\_\+s11\+Sap\+Mme}
\item 
\hyperlink{classns3_1_1EpcS11SapSgw}{Epc\+S11\+Sap\+Sgw} $\ast$ \hyperlink{classns3_1_1EpcSgwPgwApplication_ac405e7e4e2e29f747b60a145a14d0b7c}{m\+\_\+s11\+Sap\+Sgw}
\item 
std\+::map$<$ uint16\+\_\+t, \hyperlink{structns3_1_1EpcSgwPgwApplication_1_1EnbInfo}{Enb\+Info} $>$ \hyperlink{classns3_1_1EpcSgwPgwApplication_afa8f803a667fc1c54fc855a8a3d8e550}{m\+\_\+enb\+Info\+By\+Cell\+Id}
\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classns3_1_1EpcSgwPgwApplication_a577f7e07cc928bffffc8fc7e445c0acc}{Member\+Epc\+S11\+Sap\+Sgw$<$ Epc\+Sgw\+Pgw\+Application $>$}
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
This application implements the S\+G\+W/\+P\+GW functionality. 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}!Epc\+Sgw\+Pgw\+Application@{Epc\+Sgw\+Pgw\+Application}}
\index{Epc\+Sgw\+Pgw\+Application@{Epc\+Sgw\+Pgw\+Application}!ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}}
\subsubsection[{\texorpdfstring{Epc\+Sgw\+Pgw\+Application(const Ptr$<$ Virtual\+Net\+Device $>$ tun\+Device, const Ptr$<$ Socket $>$ s1u\+Socket)}{EpcSgwPgwApplication(const Ptr< VirtualNetDevice > tunDevice, const Ptr< Socket > s1uSocket)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Epc\+Sgw\+Pgw\+Application\+::\+Epc\+Sgw\+Pgw\+Application (
\begin{DoxyParamCaption}
\item[{const {\bf Ptr}$<$ {\bf Virtual\+Net\+Device} $>$}]{tun\+Device, }
\item[{const {\bf Ptr}$<$ {\bf Socket} $>$}]{s1u\+Socket}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1EpcSgwPgwApplication_a0e8cdb651b4f5327d32d9a5bc52d6717}{}\label{classns3_1_1EpcSgwPgwApplication_a0e8cdb651b4f5327d32d9a5bc52d6717}
Constructor that binds the tap device to the callback methods.


\begin{DoxyParams}{Parameters}
{\em tun\+Device} & T\+UN \hyperlink{classns3_1_1VirtualNetDevice}{Virtual\+Net\+Device} used to tunnel IP packets from the Gi interface of the P\+G\+W/\+S\+GW over the internet over G\+T\+P-\/\+U/\+U\+D\+P/\+IP on the S1-\/U interface \\
\hline
{\em s1u\+Socket} & socket used to send G\+T\+P-\/U packets to the e\+N\+Bs \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
124   : \hyperlink{classns3_1_1EpcSgwPgwApplication_a2a36f49986d4851e3c184007c6480a90}{m\_s1uSocket} (s1uSocket),
125     \hyperlink{classns3_1_1EpcSgwPgwApplication_abfd29706464464933ddc5a72469a97e1}{m\_tunDevice} (tunDevice),
126     \hyperlink{classns3_1_1EpcSgwPgwApplication_aaf54b6467029f7c3f038da709da10a09}{m\_gtpuUdpPort} (2152), \textcolor{comment}{// fixed by the standard}
127     \hyperlink{classns3_1_1EpcSgwPgwApplication_a160d5f7d28ef531f5fc9bd9bdd5ac9ff}{m\_teidCount} (0),
128     \hyperlink{classns3_1_1EpcSgwPgwApplication_a37809771f2d925005b7deab8c5a2de3c}{m\_s11SapMme} (0)
129 \{
130   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << tunDevice << s1uSocket);
131   \hyperlink{classns3_1_1EpcSgwPgwApplication_a2a36f49986d4851e3c184007c6480a90}{m\_s1uSocket}->\hyperlink{classns3_1_1Socket_a243f7835ef1a85f9270fd3577e3a40da}{SetRecvCallback} (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1EpcSgwPgwApplication_adab529c65e1174c5568016cc91e5dedd}{EpcSgwPgwApplication::RecvFromS1uSocket}, \textcolor{keyword}{this}));
132   \hyperlink{classns3_1_1EpcSgwPgwApplication_ac405e7e4e2e29f747b60a145a14d0b7c}{m\_s11SapSgw} = \textcolor{keyword}{new} \hyperlink{classns3_1_1EpcSgwPgwApplication_a577f7e07cc928bffffc8fc7e445c0acc}{MemberEpcS11SapSgw<EpcSgwPgwApplication>}
       (\textcolor{keyword}{this});
133 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}!````~Epc\+Sgw\+Pgw\+Application@{$\sim$\+Epc\+Sgw\+Pgw\+Application}}
\index{````~Epc\+Sgw\+Pgw\+Application@{$\sim$\+Epc\+Sgw\+Pgw\+Application}!ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}}
\subsubsection[{\texorpdfstring{$\sim$\+Epc\+Sgw\+Pgw\+Application(void)}{~EpcSgwPgwApplication(void)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Epc\+Sgw\+Pgw\+Application\+::$\sim$\+Epc\+Sgw\+Pgw\+Application (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1EpcSgwPgwApplication_a0ca75fd4a63ac1a7f4875f7ca7e2ffdf}{}\label{classns3_1_1EpcSgwPgwApplication_a0ca75fd4a63ac1a7f4875f7ca7e2ffdf}
Destructor 
\begin{DoxyCode}
137 \{
138   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
139 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}!Add\+Enb@{Add\+Enb}}
\index{Add\+Enb@{Add\+Enb}!ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}}
\subsubsection[{\texorpdfstring{Add\+Enb(uint16\+\_\+t cell\+Id, Ipv4\+Address enb\+Addr, Ipv4\+Address sgw\+Addr)}{AddEnb(uint16_t cellId, Ipv4Address enbAddr, Ipv4Address sgwAddr)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Epc\+Sgw\+Pgw\+Application\+::\+Add\+Enb (
\begin{DoxyParamCaption}
\item[{uint16\+\_\+t}]{cell\+Id, }
\item[{{\bf Ipv4\+Address}}]{enb\+Addr, }
\item[{{\bf Ipv4\+Address}}]{sgw\+Addr}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1EpcSgwPgwApplication_af59a96aed58de1ac0adefe13ec6a3fa4}{}\label{classns3_1_1EpcSgwPgwApplication_af59a96aed58de1ac0adefe13ec6a3fa4}
Let the S\+GW be aware of a new e\+NB


\begin{DoxyParams}{Parameters}
{\em cell\+Id} & the cell identifier \\
\hline
{\em enb\+Addr} & the address of the e\+NB \\
\hline
{\em sgw\+Addr} & the address of the S\+GW \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
236 \{
237   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << cellId << enbAddr << sgwAddr);
238   EnbInfo enbInfo;
239   enbInfo.enbAddr = enbAddr;
240   enbInfo.sgwAddr = sgwAddr;
241   \hyperlink{classns3_1_1EpcSgwPgwApplication_afa8f803a667fc1c54fc855a8a3d8e550}{m\_enbInfoByCellId}[cellId] = enbInfo;
242 \}
\end{DoxyCode}
\index{ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}!Add\+Ue@{Add\+Ue}}
\index{Add\+Ue@{Add\+Ue}!ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}}
\subsubsection[{\texorpdfstring{Add\+Ue(uint64\+\_\+t imsi)}{AddUe(uint64_t imsi)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Epc\+Sgw\+Pgw\+Application\+::\+Add\+Ue (
\begin{DoxyParamCaption}
\item[{uint64\+\_\+t}]{imsi}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1EpcSgwPgwApplication_adce905cafa429fbd0625c6018b68abd6}{}\label{classns3_1_1EpcSgwPgwApplication_adce905cafa429fbd0625c6018b68abd6}
Let the S\+GW be aware of a new UE


\begin{DoxyParams}{Parameters}
{\em imsi} & the unique identifier of the UE \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
246 \{
247   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << imsi);
248   Ptr<UeInfo> ueInfo = Create<UeInfo> ();
249   \hyperlink{classns3_1_1EpcSgwPgwApplication_ac026923e4b06703faf659f0584573531}{m\_ueInfoByImsiMap}[imsi] = ueInfo;
250 \}
\end{DoxyCode}
\index{ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}!Do\+Create\+Session\+Request@{Do\+Create\+Session\+Request}}
\index{Do\+Create\+Session\+Request@{Do\+Create\+Session\+Request}!ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}}
\subsubsection[{\texorpdfstring{Do\+Create\+Session\+Request(\+Epc\+S11\+Sap\+Sgw\+::\+Create\+Session\+Request\+Message msg)}{DoCreateSessionRequest(EpcS11SapSgw::CreateSessionRequestMessage msg)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Epc\+Sgw\+Pgw\+Application\+::\+Do\+Create\+Session\+Request (
\begin{DoxyParamCaption}
\item[{{\bf Epc\+S11\+Sap\+Sgw\+::\+Create\+Session\+Request\+Message}}]{msg}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EpcSgwPgwApplication_a994ec0a8365d89b589bf2ed4d2051e2d}{}\label{classns3_1_1EpcSgwPgwApplication_a994ec0a8365d89b589bf2ed4d2051e2d}

\begin{DoxyCode}
264 \{
265   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << req.imsi);
266   std::map<uint64\_t, Ptr<UeInfo> >::iterator ueit = \hyperlink{classns3_1_1EpcSgwPgwApplication_ac026923e4b06703faf659f0584573531}{m\_ueInfoByImsiMap}.find (req.imsi);
267   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (ueit != \hyperlink{classns3_1_1EpcSgwPgwApplication_ac026923e4b06703faf659f0584573531}{m\_ueInfoByImsiMap}.end (), \textcolor{stringliteral}{"unknown IMSI "} << req.
      imsi); 
268   uint16\_t cellId = req.uli.gci;
269   std::map<uint16\_t, EnbInfo>::iterator enbit = \hyperlink{classns3_1_1EpcSgwPgwApplication_afa8f803a667fc1c54fc855a8a3d8e550}{m\_enbInfoByCellId}.find (cellId);
270   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (enbit != \hyperlink{classns3_1_1EpcSgwPgwApplication_afa8f803a667fc1c54fc855a8a3d8e550}{m\_enbInfoByCellId}.end (), \textcolor{stringliteral}{"unknown CellId "} << 
      cellId); 
271   Ipv4Address enbAddr = enbit->second.enbAddr;
272   ueit->second->SetEnbAddr (enbAddr);
273 
274   EpcS11SapMme::CreateSessionResponseMessage res;
275   res.teid = req.imsi; \textcolor{comment}{// trick to avoid the need for allocating TEIDs on the S11 interface}
276 
277   \textcolor{keywordflow}{for} (std::list<EpcS11SapSgw::BearerContextToBeCreated>::iterator bit = req.bearerContextsToBeCreated.
      begin ();
278        bit != req.bearerContextsToBeCreated.end ();
279        ++bit)
280     \{
281       \textcolor{comment}{// simple sanity check. If you ever need more than 4M teids}
282       \textcolor{comment}{// throughout your simulation, you'll need to implement a smarter teid}
283       \textcolor{comment}{// management algorithm. }
284       \hyperlink{group__fatal_ga979468222aa80366c2c98aa1554f3eec}{NS\_ABORT\_IF} (\hyperlink{classns3_1_1EpcSgwPgwApplication_a160d5f7d28ef531f5fc9bd9bdd5ac9ff}{m\_teidCount} == 0xFFFFFFFF);
285       uint32\_t teid = ++\hyperlink{classns3_1_1EpcSgwPgwApplication_a160d5f7d28ef531f5fc9bd9bdd5ac9ff}{m\_teidCount};  
286       ueit->second->AddBearer (bit->tft, bit->epsBearerId, teid);
287 
288       EpcS11SapMme::BearerContextCreated bearerContext;
289       bearerContext.sgwFteid.teid = teid;
290       bearerContext.sgwFteid.address = enbit->second.sgwAddr;
291       bearerContext.epsBearerId =  bit->epsBearerId; 
292       bearerContext.bearerLevelQos = bit->bearerLevelQos; 
293       bearerContext.tft = bit->tft;
294       res.bearerContextsCreated.push\_back (bearerContext);
295     \}
296   \hyperlink{classns3_1_1EpcSgwPgwApplication_a37809771f2d925005b7deab8c5a2de3c}{m\_s11SapMme}->\hyperlink{classns3_1_1EpcS11SapMme_a844a9c2d1b8a5e3c5d61cb6b44d50c75}{CreateSessionResponse} (res);
297   
298 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}!Do\+Delete\+Bearer\+Command@{Do\+Delete\+Bearer\+Command}}
\index{Do\+Delete\+Bearer\+Command@{Do\+Delete\+Bearer\+Command}!ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}}
\subsubsection[{\texorpdfstring{Do\+Delete\+Bearer\+Command(\+Epc\+S11\+Sap\+Sgw\+::\+Delete\+Bearer\+Command\+Message req)}{DoDeleteBearerCommand(EpcS11SapSgw::DeleteBearerCommandMessage req)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Epc\+Sgw\+Pgw\+Application\+::\+Do\+Delete\+Bearer\+Command (
\begin{DoxyParamCaption}
\item[{{\bf Epc\+S11\+Sap\+Sgw\+::\+Delete\+Bearer\+Command\+Message}}]{req}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EpcSgwPgwApplication_a4eb98a93b6353fb24f0d821ecc1055a2}{}\label{classns3_1_1EpcSgwPgwApplication_a4eb98a93b6353fb24f0d821ecc1055a2}

\begin{DoxyCode}
321 \{
322   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << req.teid);
323   uint64\_t imsi = req.teid; \textcolor{comment}{// trick to avoid the need for allocating TEIDs on the S11 interface}
324   std::map<uint64\_t, Ptr<UeInfo> >::iterator ueit = \hyperlink{classns3_1_1EpcSgwPgwApplication_ac026923e4b06703faf659f0584573531}{m\_ueInfoByImsiMap}.find (imsi);
325   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (ueit != \hyperlink{classns3_1_1EpcSgwPgwApplication_ac026923e4b06703faf659f0584573531}{m\_ueInfoByImsiMap}.end (), \textcolor{stringliteral}{"unknown IMSI "} << imsi);
326 
327   EpcS11SapMme::DeleteBearerRequestMessage res;
328   res.teid = imsi;
329 
330   \textcolor{keywordflow}{for} (std::list<EpcS11SapSgw::BearerContextToBeRemoved>::iterator bit = req.bearerContextsToBeRemoved.
      begin ();
331        bit != req.bearerContextsToBeRemoved.end ();
332        ++bit)
333     \{
334       EpcS11SapMme::BearerContextRemoved bearerContext;
335       bearerContext.epsBearerId =  bit->epsBearerId;
336       res.bearerContextsRemoved.push\_back (bearerContext);
337     \}
338   \textcolor{comment}{//schedules Delete Bearer Request towards MME}
339   \hyperlink{classns3_1_1EpcSgwPgwApplication_a37809771f2d925005b7deab8c5a2de3c}{m\_s11SapMme}->\hyperlink{classns3_1_1EpcS11SapMme_a18ebb205bd46492fa9136dfc1e2ca1b2}{DeleteBearerRequest} (res);
340 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4


\index{ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}!Do\+Delete\+Bearer\+Response@{Do\+Delete\+Bearer\+Response}}
\index{Do\+Delete\+Bearer\+Response@{Do\+Delete\+Bearer\+Response}!ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}}
\subsubsection[{\texorpdfstring{Do\+Delete\+Bearer\+Response(\+Epc\+S11\+Sap\+Sgw\+::\+Delete\+Bearer\+Response\+Message req)}{DoDeleteBearerResponse(EpcS11SapSgw::DeleteBearerResponseMessage req)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Epc\+Sgw\+Pgw\+Application\+::\+Do\+Delete\+Bearer\+Response (
\begin{DoxyParamCaption}
\item[{{\bf Epc\+S11\+Sap\+Sgw\+::\+Delete\+Bearer\+Response\+Message}}]{req}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EpcSgwPgwApplication_a8e8dde46ca31002ef4da8cae64140e68}{}\label{classns3_1_1EpcSgwPgwApplication_a8e8dde46ca31002ef4da8cae64140e68}

\begin{DoxyCode}
344 \{
345   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << req.teid);
346   uint64\_t imsi = req.teid; \textcolor{comment}{// trick to avoid the need for allocating TEIDs on the S11 interface}
347   std::map<uint64\_t, Ptr<UeInfo> >::iterator ueit = \hyperlink{classns3_1_1EpcSgwPgwApplication_ac026923e4b06703faf659f0584573531}{m\_ueInfoByImsiMap}.find (imsi);
348   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (ueit != \hyperlink{classns3_1_1EpcSgwPgwApplication_ac026923e4b06703faf659f0584573531}{m\_ueInfoByImsiMap}.end (), \textcolor{stringliteral}{"unknown IMSI "} << imsi);
349 
350   \textcolor{keywordflow}{for} (std::list<EpcS11SapSgw::BearerContextRemovedSgwPgw>::iterator bit = req.bearerContextsRemoved.begin 
      ();
351        bit != req.bearerContextsRemoved.end ();
352        ++bit)
353     \{
354       \textcolor{comment}{//Function to remove de-activated bearer contexts from S-Gw and P-Gw side}
355       ueit->second->RemoveBearer (bit->epsBearerId);
356     \}
357 \}
\end{DoxyCode}
\index{ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}}
\subsubsection[{\texorpdfstring{Do\+Dispose()}{DoDispose()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Epc\+Sgw\+Pgw\+Application\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1EpcSgwPgwApplication_a8cec25fb185f15c9862a1f1e31c66525}{}\label{classns3_1_1EpcSgwPgwApplication_a8cec25fb185f15c9862a1f1e31c66525}
Destructor implementation.

This method is called by \hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose()} or by the \hyperlink{classns3_1_1Object}{Object}\textquotesingle{}s destructor, whichever comes first.

Subclasses are expected to implement their real destruction code in an overriden version of this method and chain up to their parent\textquotesingle{}s implementation once they are done. {\itshape i.\+e}, for simplicity, the destructor of every subclass should be empty and its content should be moved to the associated \hyperlink{classns3_1_1EpcSgwPgwApplication_a8cec25fb185f15c9862a1f1e31c66525}{Do\+Dispose()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Application_a89f6c9454532d62600251872bede6d04}{ns3\+::\+Application}.


\begin{DoxyCode}
114 \{
115   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
116   \hyperlink{classns3_1_1EpcSgwPgwApplication_a2a36f49986d4851e3c184007c6480a90}{m\_s1uSocket}->\hyperlink{classns3_1_1Socket_a243f7835ef1a85f9270fd3577e3a40da}{SetRecvCallback} (\hyperlink{group__makenullcallback_ga7e3cd6816f63ea9112c04b0086c2c65a}{MakeNullCallback}<\textcolor{keywordtype}{void}, 
      Ptr<Socket> > ());
117   \hyperlink{classns3_1_1EpcSgwPgwApplication_a2a36f49986d4851e3c184007c6480a90}{m\_s1uSocket} = 0;
118   \textcolor{keyword}{delete} (\hyperlink{classns3_1_1EpcSgwPgwApplication_ac405e7e4e2e29f747b60a145a14d0b7c}{m\_s11SapSgw});
119 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5


\index{ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}!Do\+Modify\+Bearer\+Request@{Do\+Modify\+Bearer\+Request}}
\index{Do\+Modify\+Bearer\+Request@{Do\+Modify\+Bearer\+Request}!ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}}
\subsubsection[{\texorpdfstring{Do\+Modify\+Bearer\+Request(\+Epc\+S11\+Sap\+Sgw\+::\+Modify\+Bearer\+Request\+Message msg)}{DoModifyBearerRequest(EpcS11SapSgw::ModifyBearerRequestMessage msg)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Epc\+Sgw\+Pgw\+Application\+::\+Do\+Modify\+Bearer\+Request (
\begin{DoxyParamCaption}
\item[{{\bf Epc\+S11\+Sap\+Sgw\+::\+Modify\+Bearer\+Request\+Message}}]{msg}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EpcSgwPgwApplication_a90fb12acb1c198b0bb13196c9f620f8b}{}\label{classns3_1_1EpcSgwPgwApplication_a90fb12acb1c198b0bb13196c9f620f8b}

\begin{DoxyCode}
302 \{
303   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << req.teid);
304   uint64\_t imsi = req.teid; \textcolor{comment}{// trick to avoid the need for allocating TEIDs on the S11 interface}
305   std::map<uint64\_t, Ptr<UeInfo> >::iterator ueit = \hyperlink{classns3_1_1EpcSgwPgwApplication_ac026923e4b06703faf659f0584573531}{m\_ueInfoByImsiMap}.find (imsi);
306   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (ueit != \hyperlink{classns3_1_1EpcSgwPgwApplication_ac026923e4b06703faf659f0584573531}{m\_ueInfoByImsiMap}.end (), \textcolor{stringliteral}{"unknown IMSI "} << imsi); 
307   uint16\_t cellId = req.uli.gci;
308   std::map<uint16\_t, EnbInfo>::iterator enbit = \hyperlink{classns3_1_1EpcSgwPgwApplication_afa8f803a667fc1c54fc855a8a3d8e550}{m\_enbInfoByCellId}.find (cellId);
309   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (enbit != \hyperlink{classns3_1_1EpcSgwPgwApplication_afa8f803a667fc1c54fc855a8a3d8e550}{m\_enbInfoByCellId}.end (), \textcolor{stringliteral}{"unknown CellId "} << 
      cellId); 
310   Ipv4Address enbAddr = enbit->second.enbAddr;
311   ueit->second->SetEnbAddr (enbAddr);
312   \textcolor{comment}{// no actual bearer modification: for now we just support the minimum needed for path switch request
       (handover)}
313   EpcS11SapMme::ModifyBearerResponseMessage res;
314   res.teid = imsi; \textcolor{comment}{// trick to avoid the need for allocating TEIDs on the S11 interface}
315   res.cause = \hyperlink{structns3_1_1EpcS11SapMme_1_1ModifyBearerResponseMessage_a0f5caf9b54d24e8298ba8878ef1f773ca13e4573acd6716004d421a969b43e50c}{EpcS11SapMme::ModifyBearerResponseMessage::REQUEST\_ACCEPTED}
      ;
316   \hyperlink{classns3_1_1EpcSgwPgwApplication_a37809771f2d925005b7deab8c5a2de3c}{m\_s11SapMme}->\hyperlink{classns3_1_1EpcS11SapMme_affb4585dc5d2a880f628ea043e627a66}{ModifyBearerResponse} (res);
317 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6


\index{ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}!Get\+S11\+Sap\+Sgw@{Get\+S11\+Sap\+Sgw}}
\index{Get\+S11\+Sap\+Sgw@{Get\+S11\+Sap\+Sgw}!ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}}
\subsubsection[{\texorpdfstring{Get\+S11\+Sap\+Sgw()}{GetS11SapSgw()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Epc\+S11\+Sap\+Sgw} $\ast$ ns3\+::\+Epc\+Sgw\+Pgw\+Application\+::\+Get\+S11\+Sap\+Sgw (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1EpcSgwPgwApplication_af709794f4a8bfbdccd451261d4525570}{}\label{classns3_1_1EpcSgwPgwApplication_af709794f4a8bfbdccd451261d4525570}
\begin{DoxyReturn}{Returns}
the S\+GW side of the S11 S\+AP 
\end{DoxyReturn}

\begin{DoxyCode}
230 \{
231   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1EpcSgwPgwApplication_ac405e7e4e2e29f747b60a145a14d0b7c}{m\_s11SapSgw};
232 \}
\end{DoxyCode}
\index{ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Epc\+Sgw\+Pgw\+Application\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1EpcSgwPgwApplication_a2cf6a61dcdb46991e2a19cf44626f2e9}{}\label{classns3_1_1EpcSgwPgwApplication_a2cf6a61dcdb46991e2a19cf44626f2e9}

\begin{DoxyCode}
105 \{
106   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::EpcSgwPgwApplication"})
107     .SetParent<\hyperlink{classns3_1_1Object_a40860402e64d8008fb42329df7097cdb}{Object}> ()
108     .SetGroupName(\textcolor{stringliteral}{"Lte"});
109   \textcolor{keywordflow}{return} tid;
110 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7


\index{ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}!Recv\+From\+S1u\+Socket@{Recv\+From\+S1u\+Socket}}
\index{Recv\+From\+S1u\+Socket@{Recv\+From\+S1u\+Socket}!ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}}
\subsubsection[{\texorpdfstring{Recv\+From\+S1u\+Socket(\+Ptr$<$ Socket $>$ socket)}{RecvFromS1uSocket(Ptr< Socket > socket)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Epc\+Sgw\+Pgw\+Application\+::\+Recv\+From\+S1u\+Socket (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Socket} $>$}]{socket}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1EpcSgwPgwApplication_adab529c65e1174c5568016cc91e5dedd}{}\label{classns3_1_1EpcSgwPgwApplication_adab529c65e1174c5568016cc91e5dedd}
Method to be assigned to the recv callback of the S1-\/U socket. It is called when the S\+G\+W/\+P\+GW receives a data packet from the e\+NB that is to be forwarded to the internet.


\begin{DoxyParams}{Parameters}
{\em socket} & pointer to the S1-\/U socket \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
182 \{
183   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << socket);  
184   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (socket == \hyperlink{classns3_1_1EpcSgwPgwApplication_a2a36f49986d4851e3c184007c6480a90}{m\_s1uSocket});
185   Ptr<Packet> packet = socket->\hyperlink{classns3_1_1Socket_a8949b1f844aae563446f2f4c5be8827a}{Recv} ();
186   GtpuHeader gtpu;
187   packet->\hyperlink{classns3_1_1Packet_a0961eccf975d75f902d40956c93ba63e}{RemoveHeader} (gtpu);
188   uint32\_t teid = gtpu.GetTeid ();
189 
192   \textcolor{comment}{//SocketAddressTag tag;}
193   \textcolor{comment}{//packet->RemovePacketTag (tag);}
194 
195   \hyperlink{classns3_1_1EpcSgwPgwApplication_a7c2922506ab9a7d14ebb83d8887c9faf}{SendToTunDevice} (packet, teid);
196 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8




Here is the caller graph for this function\+:
% FIG 9


\index{ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}!Recv\+From\+Tun\+Device@{Recv\+From\+Tun\+Device}}
\index{Recv\+From\+Tun\+Device@{Recv\+From\+Tun\+Device}!ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}}
\subsubsection[{\texorpdfstring{Recv\+From\+Tun\+Device(\+Ptr$<$ Packet $>$ packet, const Address \&source, const Address \&dest, uint16\+\_\+t protocol\+Number)}{RecvFromTunDevice(Ptr< Packet > packet, const Address &source, const Address &dest, uint16_t protocolNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Epc\+Sgw\+Pgw\+Application\+::\+Recv\+From\+Tun\+Device (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{const {\bf Address} \&}]{source, }
\item[{const {\bf Address} \&}]{dest, }
\item[{uint16\+\_\+t}]{protocol\+Number}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1EpcSgwPgwApplication_aeea285ccd04a4350e4ddb77a359e97ca}{}\label{classns3_1_1EpcSgwPgwApplication_aeea285ccd04a4350e4ddb77a359e97ca}
Method to be assigned to the callback of the Gi T\+UN \hyperlink{classns3_1_1VirtualNetDevice}{Virtual\+Net\+Device}. It is called when the S\+G\+W/\+P\+GW receives a data packet from the internet (including IP headers) that is to be sent to the UE via its associated e\+NB, tunneling IP over G\+T\+P-\/\+U/\+U\+D\+P/\+IP.


\begin{DoxyParams}{Parameters}
{\em packet} & \\
\hline
{\em source} & \\
\hline
{\em dest} & \\
\hline
{\em protocol\+Number} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true always 
\end{DoxyReturn}

\begin{DoxyCode}
144 \{
145   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << source << dest << packet << packet->
      \hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ());
146 
147   \textcolor{comment}{// get IP address of UE}
148   Ptr<Packet> pCopy = packet->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} ();
149   Ipv4Header ipv4Header;
150   pCopy->\hyperlink{classns3_1_1Packet_a0961eccf975d75f902d40956c93ba63e}{RemoveHeader} (ipv4Header);
151   Ipv4Address ueAddr =  ipv4Header.GetDestination ();
152   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"packet addressed to UE "} << ueAddr);
153 
154   \textcolor{comment}{// find corresponding UeInfo address}
155   std::map<Ipv4Address, Ptr<UeInfo> >::iterator it = \hyperlink{classns3_1_1EpcSgwPgwApplication_ac5d167ff997bd9618e832a371f45cba0}{m\_ueInfoByAddrMap}.find (ueAddr);
156   \textcolor{keywordflow}{if} (it == \hyperlink{classns3_1_1EpcSgwPgwApplication_ac5d167ff997bd9618e832a371f45cba0}{m\_ueInfoByAddrMap}.end ())
157     \{        
158       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"unknown UE address "} << ueAddr);
159     \}
160   \textcolor{keywordflow}{else}
161     \{
162       Ipv4Address enbAddr = it->second->GetEnbAddr ();      
163       uint32\_t teid = it->second->Classify (packet);   
164       \textcolor{keywordflow}{if} (teid == 0)
165         \{
166           \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"no matching bearer for this packet"});                   
167         \}
168       \textcolor{keywordflow}{else}
169         \{
170           \hyperlink{classns3_1_1EpcSgwPgwApplication_a32232c4e589789e118db44c4883cebb1}{SendToS1uSocket} (packet, enbAddr, teid);
171         \}
172     \}
173   \textcolor{comment}{// there is no reason why we should notify the TUN}
174   \textcolor{comment}{// VirtualNetDevice that he failed to send the packet: if we receive}
175   \textcolor{comment}{// any bogus packet, it will just be silently discarded.}
176   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} succeeded = \textcolor{keyword}{true};
177   \textcolor{keywordflow}{return} succeeded;
178 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10




Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}!Send\+To\+S1u\+Socket@{Send\+To\+S1u\+Socket}}
\index{Send\+To\+S1u\+Socket@{Send\+To\+S1u\+Socket}!ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}}
\subsubsection[{\texorpdfstring{Send\+To\+S1u\+Socket(\+Ptr$<$ Packet $>$ packet, Ipv4\+Address enb\+S1u\+Address, uint32\+\_\+t teid)}{SendToS1uSocket(Ptr< Packet > packet, Ipv4Address enbS1uAddress, uint32_t teid)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Epc\+Sgw\+Pgw\+Application\+::\+Send\+To\+S1u\+Socket (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Ipv4\+Address}}]{enb\+S1u\+Address, }
\item[{uint32\+\_\+t}]{teid}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1EpcSgwPgwApplication_a32232c4e589789e118db44c4883cebb1}{}\label{classns3_1_1EpcSgwPgwApplication_a32232c4e589789e118db44c4883cebb1}
Send a packet to the S\+GW via the S1-\/U interface


\begin{DoxyParams}{Parameters}
{\em packet} & packet to be sent \\
\hline
{\em enb\+S1u\+Address} & the address of the e\+NB \\
\hline
{\em teid} & the \hyperlink{classTunnel}{Tunnel} Enpoint I\+Dentifier \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
208 \{
209   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << enbAddr << teid);
210 
211   GtpuHeader gtpu;
212   gtpu.SetTeid (teid);
213   \textcolor{comment}{// From 3GPP TS 29.281 v10.0.0 Section 5.1}
214   \textcolor{comment}{// Length of the payload + the non obligatory GTP-U header}
215   gtpu.SetLength (packet->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} () + gtpu.GetSerializedSize () - 8);  
216   packet->\hyperlink{classns3_1_1Packet_a465108c595a0bc592095cbcab1832ed8}{AddHeader} (gtpu);
217   uint32\_t flags = 0;
218   \hyperlink{classns3_1_1EpcSgwPgwApplication_a2a36f49986d4851e3c184007c6480a90}{m\_s1uSocket}->\hyperlink{classns3_1_1Socket_af898fce6a58e0dbba23c1c6de1d4220e}{SendTo} (packet, flags, InetSocketAddress (enbAddr, 
      \hyperlink{classns3_1_1EpcSgwPgwApplication_aaf54b6467029f7c3f038da709da10a09}{m\_gtpuUdpPort}));
219 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12




Here is the caller graph for this function\+:
% FIG 13


\index{ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}!Send\+To\+Tun\+Device@{Send\+To\+Tun\+Device}}
\index{Send\+To\+Tun\+Device@{Send\+To\+Tun\+Device}!ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}}
\subsubsection[{\texorpdfstring{Send\+To\+Tun\+Device(\+Ptr$<$ Packet $>$ packet, uint32\+\_\+t teid)}{SendToTunDevice(Ptr< Packet > packet, uint32_t teid)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Epc\+Sgw\+Pgw\+Application\+::\+Send\+To\+Tun\+Device (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{uint32\+\_\+t}]{teid}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1EpcSgwPgwApplication_a7c2922506ab9a7d14ebb83d8887c9faf}{}\label{classns3_1_1EpcSgwPgwApplication_a7c2922506ab9a7d14ebb83d8887c9faf}
Send a packet to the internet via the Gi interface of the S\+G\+W/\+P\+GW


\begin{DoxyParams}{Parameters}
{\em packet} & \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
200 \{
201   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << teid);
202   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{" packet size: "} << packet->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} () << \textcolor{stringliteral}{" bytes"});
203   \hyperlink{classns3_1_1EpcSgwPgwApplication_abfd29706464464933ddc5a72469a97e1}{m\_tunDevice}->\hyperlink{classns3_1_1VirtualNetDevice_a4e13d506dae86955be99116c23034e28}{Receive} (packet, 0x0800, \hyperlink{classns3_1_1EpcSgwPgwApplication_abfd29706464464933ddc5a72469a97e1}{m\_tunDevice}->
      \hyperlink{classns3_1_1VirtualNetDevice_a8c8219e4244461ea705b3829a599931c}{GetAddress} (), \hyperlink{classns3_1_1EpcSgwPgwApplication_abfd29706464464933ddc5a72469a97e1}{m\_tunDevice}->\hyperlink{classns3_1_1VirtualNetDevice_a8c8219e4244461ea705b3829a599931c}{GetAddress} (), 
      \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2a60835731aced24ac0c712ba61e62462e}{NetDevice::PACKET\_HOST});
204 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 14




Here is the caller graph for this function\+:
% FIG 15


\index{ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}!Set\+S11\+Sap\+Mme@{Set\+S11\+Sap\+Mme}}
\index{Set\+S11\+Sap\+Mme@{Set\+S11\+Sap\+Mme}!ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}}
\subsubsection[{\texorpdfstring{Set\+S11\+Sap\+Mme(\+Epc\+S11\+Sap\+Mme $\ast$s)}{SetS11SapMme(EpcS11SapMme *s)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Epc\+Sgw\+Pgw\+Application\+::\+Set\+S11\+Sap\+Mme (
\begin{DoxyParamCaption}
\item[{{\bf Epc\+S11\+Sap\+Mme} $\ast$}]{s}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1EpcSgwPgwApplication_af135dedf794394760179db0de9ba47ea}{}\label{classns3_1_1EpcSgwPgwApplication_af135dedf794394760179db0de9ba47ea}
Set the M\+ME side of the S11 S\+AP


\begin{DoxyParams}{Parameters}
{\em s} & the M\+ME side of the S11 S\+AP \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
224 \{
225   \hyperlink{classns3_1_1EpcSgwPgwApplication_a37809771f2d925005b7deab8c5a2de3c}{m\_s11SapMme} = \hyperlink{generate__test__data__lte__sinr_8m_ad83eeb3a142285d1243a08c6b7026df8}{s};
226 \}
\end{DoxyCode}
\index{ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}!Set\+Ue\+Address@{Set\+Ue\+Address}}
\index{Set\+Ue\+Address@{Set\+Ue\+Address}!ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}}
\subsubsection[{\texorpdfstring{Set\+Ue\+Address(uint64\+\_\+t imsi, Ipv4\+Address ue\+Addr)}{SetUeAddress(uint64_t imsi, Ipv4Address ueAddr)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Epc\+Sgw\+Pgw\+Application\+::\+Set\+Ue\+Address (
\begin{DoxyParamCaption}
\item[{uint64\+\_\+t}]{imsi, }
\item[{{\bf Ipv4\+Address}}]{ue\+Addr}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1EpcSgwPgwApplication_aef71dc53ba3d67850a5e98810a6f2961}{}\label{classns3_1_1EpcSgwPgwApplication_aef71dc53ba3d67850a5e98810a6f2961}
set the address of a previously added UE


\begin{DoxyParams}{Parameters}
{\em imsi} & the unique identifier of the UE \\
\hline
{\em ue\+Addr} & the I\+Pv4 address of the UE \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
254 \{
255   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << imsi << ueAddr);
256   std::map<uint64\_t, Ptr<UeInfo> >::iterator ueit = \hyperlink{classns3_1_1EpcSgwPgwApplication_ac026923e4b06703faf659f0584573531}{m\_ueInfoByImsiMap}.find (imsi);
257   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (ueit != \hyperlink{classns3_1_1EpcSgwPgwApplication_ac026923e4b06703faf659f0584573531}{m\_ueInfoByImsiMap}.end (), \textcolor{stringliteral}{"unknown IMSI "} << imsi); 
258   \hyperlink{classns3_1_1EpcSgwPgwApplication_ac5d167ff997bd9618e832a371f45cba0}{m\_ueInfoByAddrMap}[ueAddr] = ueit->second;
259   ueit->second->SetUeAddr (ueAddr);
260 \}
\end{DoxyCode}


\subsection{Friends And Related Function Documentation}
\index{ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}!Member\+Epc\+S11\+Sap\+Sgw$<$ Epc\+Sgw\+Pgw\+Application $>$@{Member\+Epc\+S11\+Sap\+Sgw$<$ Epc\+Sgw\+Pgw\+Application $>$}}
\index{Member\+Epc\+S11\+Sap\+Sgw$<$ Epc\+Sgw\+Pgw\+Application $>$@{Member\+Epc\+S11\+Sap\+Sgw$<$ Epc\+Sgw\+Pgw\+Application $>$}!ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}}
\subsubsection[{\texorpdfstring{Member\+Epc\+S11\+Sap\+Sgw$<$ Epc\+Sgw\+Pgw\+Application $>$}{MemberEpcS11SapSgw< EpcSgwPgwApplication >}}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf Member\+Epc\+S11\+Sap\+Sgw}$<$ {\bf Epc\+Sgw\+Pgw\+Application} $>$\hspace{0.3cm}{\ttfamily [friend]}}\hypertarget{classns3_1_1EpcSgwPgwApplication_a577f7e07cc928bffffc8fc7e445c0acc}{}\label{classns3_1_1EpcSgwPgwApplication_a577f7e07cc928bffffc8fc7e445c0acc}


\subsection{Member Data Documentation}
\index{ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}!m\+\_\+enb\+Info\+By\+Cell\+Id@{m\+\_\+enb\+Info\+By\+Cell\+Id}}
\index{m\+\_\+enb\+Info\+By\+Cell\+Id@{m\+\_\+enb\+Info\+By\+Cell\+Id}!ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}}
\subsubsection[{\texorpdfstring{m\+\_\+enb\+Info\+By\+Cell\+Id}{m_enbInfoByCellId}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<$uint16\+\_\+t, {\bf Enb\+Info}$>$ ns3\+::\+Epc\+Sgw\+Pgw\+Application\+::m\+\_\+enb\+Info\+By\+Cell\+Id\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EpcSgwPgwApplication_afa8f803a667fc1c54fc855a8a3d8e550}{}\label{classns3_1_1EpcSgwPgwApplication_afa8f803a667fc1c54fc855a8a3d8e550}
\index{ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}!m\+\_\+gtpu\+Udp\+Port@{m\+\_\+gtpu\+Udp\+Port}}
\index{m\+\_\+gtpu\+Udp\+Port@{m\+\_\+gtpu\+Udp\+Port}!ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}}
\subsubsection[{\texorpdfstring{m\+\_\+gtpu\+Udp\+Port}{m_gtpuUdpPort}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Epc\+Sgw\+Pgw\+Application\+::m\+\_\+gtpu\+Udp\+Port\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EpcSgwPgwApplication_aaf54b6467029f7c3f038da709da10a09}{}\label{classns3_1_1EpcSgwPgwApplication_aaf54b6467029f7c3f038da709da10a09}
U\+DP port to be used for G\+TP \index{ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}!m\+\_\+s11\+Sap\+Mme@{m\+\_\+s11\+Sap\+Mme}}
\index{m\+\_\+s11\+Sap\+Mme@{m\+\_\+s11\+Sap\+Mme}!ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}}
\subsubsection[{\texorpdfstring{m\+\_\+s11\+Sap\+Mme}{m_s11SapMme}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Epc\+S11\+Sap\+Mme}$\ast$ ns3\+::\+Epc\+Sgw\+Pgw\+Application\+::m\+\_\+s11\+Sap\+Mme\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EpcSgwPgwApplication_a37809771f2d925005b7deab8c5a2de3c}{}\label{classns3_1_1EpcSgwPgwApplication_a37809771f2d925005b7deab8c5a2de3c}
M\+ME side of the S11 S\+AP \index{ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}!m\+\_\+s11\+Sap\+Sgw@{m\+\_\+s11\+Sap\+Sgw}}
\index{m\+\_\+s11\+Sap\+Sgw@{m\+\_\+s11\+Sap\+Sgw}!ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}}
\subsubsection[{\texorpdfstring{m\+\_\+s11\+Sap\+Sgw}{m_s11SapSgw}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Epc\+S11\+Sap\+Sgw}$\ast$ ns3\+::\+Epc\+Sgw\+Pgw\+Application\+::m\+\_\+s11\+Sap\+Sgw\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EpcSgwPgwApplication_ac405e7e4e2e29f747b60a145a14d0b7c}{}\label{classns3_1_1EpcSgwPgwApplication_ac405e7e4e2e29f747b60a145a14d0b7c}
S\+GW side of the S11 S\+AP \index{ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}!m\+\_\+s1u\+Socket@{m\+\_\+s1u\+Socket}}
\index{m\+\_\+s1u\+Socket@{m\+\_\+s1u\+Socket}!ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}}
\subsubsection[{\texorpdfstring{m\+\_\+s1u\+Socket}{m_s1uSocket}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Socket}$>$ ns3\+::\+Epc\+Sgw\+Pgw\+Application\+::m\+\_\+s1u\+Socket\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EpcSgwPgwApplication_a2a36f49986d4851e3c184007c6480a90}{}\label{classns3_1_1EpcSgwPgwApplication_a2a36f49986d4851e3c184007c6480a90}
U\+DP socket to send and receive G\+T\+P-\/U packets to and from the S1-\/U interface \index{ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}!m\+\_\+teid\+Count@{m\+\_\+teid\+Count}}
\index{m\+\_\+teid\+Count@{m\+\_\+teid\+Count}!ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}}
\subsubsection[{\texorpdfstring{m\+\_\+teid\+Count}{m_teidCount}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Epc\+Sgw\+Pgw\+Application\+::m\+\_\+teid\+Count\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EpcSgwPgwApplication_a160d5f7d28ef531f5fc9bd9bdd5ac9ff}{}\label{classns3_1_1EpcSgwPgwApplication_a160d5f7d28ef531f5fc9bd9bdd5ac9ff}
\index{ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}!m\+\_\+tun\+Device@{m\+\_\+tun\+Device}}
\index{m\+\_\+tun\+Device@{m\+\_\+tun\+Device}!ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}}
\subsubsection[{\texorpdfstring{m\+\_\+tun\+Device}{m_tunDevice}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Virtual\+Net\+Device}$>$ ns3\+::\+Epc\+Sgw\+Pgw\+Application\+::m\+\_\+tun\+Device\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EpcSgwPgwApplication_abfd29706464464933ddc5a72469a97e1}{}\label{classns3_1_1EpcSgwPgwApplication_abfd29706464464933ddc5a72469a97e1}
T\+UN \hyperlink{classns3_1_1VirtualNetDevice}{Virtual\+Net\+Device} used for tunneling/detunneling IP packets from/to the internet over G\+T\+P-\/\+U/\+U\+D\+P/\+IP on the S1 interface \index{ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}!m\+\_\+ue\+Info\+By\+Addr\+Map@{m\+\_\+ue\+Info\+By\+Addr\+Map}}
\index{m\+\_\+ue\+Info\+By\+Addr\+Map@{m\+\_\+ue\+Info\+By\+Addr\+Map}!ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}}
\subsubsection[{\texorpdfstring{m\+\_\+ue\+Info\+By\+Addr\+Map}{m_ueInfoByAddrMap}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<${\bf Ipv4\+Address}, {\bf Ptr}$<${\bf Ue\+Info}$>$ $>$ ns3\+::\+Epc\+Sgw\+Pgw\+Application\+::m\+\_\+ue\+Info\+By\+Addr\+Map\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EpcSgwPgwApplication_ac5d167ff997bd9618e832a371f45cba0}{}\label{classns3_1_1EpcSgwPgwApplication_ac5d167ff997bd9618e832a371f45cba0}
Map telling for each UE address the corresponding UE info \index{ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}!m\+\_\+ue\+Info\+By\+Imsi\+Map@{m\+\_\+ue\+Info\+By\+Imsi\+Map}}
\index{m\+\_\+ue\+Info\+By\+Imsi\+Map@{m\+\_\+ue\+Info\+By\+Imsi\+Map}!ns3\+::\+Epc\+Sgw\+Pgw\+Application@{ns3\+::\+Epc\+Sgw\+Pgw\+Application}}
\subsubsection[{\texorpdfstring{m\+\_\+ue\+Info\+By\+Imsi\+Map}{m_ueInfoByImsiMap}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<$uint64\+\_\+t, {\bf Ptr}$<${\bf Ue\+Info}$>$ $>$ ns3\+::\+Epc\+Sgw\+Pgw\+Application\+::m\+\_\+ue\+Info\+By\+Imsi\+Map\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EpcSgwPgwApplication_ac026923e4b06703faf659f0584573531}{}\label{classns3_1_1EpcSgwPgwApplication_ac026923e4b06703faf659f0584573531}
Map telling for each I\+M\+SI the corresponding UE info 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
lte/model/\hyperlink{epc-sgw-pgw-application_8h}{epc-\/sgw-\/pgw-\/application.\+h}\item 
lte/model/\hyperlink{epc-sgw-pgw-application_8cc}{epc-\/sgw-\/pgw-\/application.\+cc}\end{DoxyCompactItemize}
