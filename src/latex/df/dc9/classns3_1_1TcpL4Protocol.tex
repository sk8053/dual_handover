\hypertarget{classns3_1_1TcpL4Protocol}{}\section{ns3\+:\+:Tcp\+L4\+Protocol Class Reference}
\label{classns3_1_1TcpL4Protocol}\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}


T\+CP socket creation and multiplexing/demultiplexing.  




{\ttfamily \#include $<$tcp-\/l4-\/protocol.\+h$>$}



Inheritance diagram for ns3\+:\+:Tcp\+L4\+Protocol\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Tcp\+L4\+Protocol\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1TcpL4Protocol_a56aa36e10a43fbdc7b0765562498fa10}{Tcp\+L4\+Protocol} ()
\item 
virtual \hyperlink{classns3_1_1TcpL4Protocol_af9b9b6731ad1df044ef4416ff88bdc85}{$\sim$\+Tcp\+L4\+Protocol} ()
\item 
void \hyperlink{classns3_1_1TcpL4Protocol_a092de53315ed89dfa2080ef0d92ccd56}{Set\+Node} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$ \hyperlink{classns3_1_1TcpL4Protocol_a896ad7a5e3959180dce59e81897f131c}{Create\+Socket} (void)
\begin{DoxyCompactList}\small\item\em Create a T\+CP socket using the \hyperlink{classns3_1_1TypeId}{Type\+Id} set by Socket\+Type attribute. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$ \hyperlink{classns3_1_1TcpL4Protocol_ae5d3e3fd9fa44cc80d3ae5f62e4dfb82}{Create\+Socket} (\hyperlink{classns3_1_1TypeId}{Type\+Id} congestion\+Type\+Id)
\begin{DoxyCompactList}\small\item\em Create a T\+CP socket using the specified congestion control algorithm \hyperlink{classns3_1_1TypeId}{Type\+Id}. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4EndPoint}{Ipv4\+End\+Point} $\ast$ \hyperlink{classns3_1_1TcpL4Protocol_a9e0180270b7b8106263b1b3660e71094}{Allocate} (void)
\begin{DoxyCompactList}\small\item\em Allocate an I\+Pv4 Endpoint. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4EndPoint}{Ipv4\+End\+Point} $\ast$ \hyperlink{classns3_1_1TcpL4Protocol_ad3e4b59d30097e97f69a1d2dcf1455ab}{Allocate} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} address)
\begin{DoxyCompactList}\small\item\em Allocate an I\+Pv4 Endpoint. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4EndPoint}{Ipv4\+End\+Point} $\ast$ \hyperlink{classns3_1_1TcpL4Protocol_a6ab346a592abf0bcbd008822aa06a395}{Allocate} (uint16\+\_\+t \hyperlink{visualizer-ideas_8txt_a21ff1c530daf8435e00048b7fc2c58e3}{port})
\begin{DoxyCompactList}\small\item\em Allocate an I\+Pv4 Endpoint. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4EndPoint}{Ipv4\+End\+Point} $\ast$ \hyperlink{classns3_1_1TcpL4Protocol_aefbec4064ad275ba7c75d49e672951c1}{Allocate} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} address, uint16\+\_\+t \hyperlink{visualizer-ideas_8txt_a21ff1c530daf8435e00048b7fc2c58e3}{port})
\begin{DoxyCompactList}\small\item\em Allocate an I\+Pv4 Endpoint. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4EndPoint}{Ipv4\+End\+Point} $\ast$ \hyperlink{classns3_1_1TcpL4Protocol_a8db77eeebb3b4e6728137f8f0dfeb947}{Allocate} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} local\+Address, uint16\+\_\+t local\+Port, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} peer\+Address, uint16\+\_\+t peer\+Port)
\begin{DoxyCompactList}\small\item\em Allocate an I\+Pv4 Endpoint. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6EndPoint}{Ipv6\+End\+Point} $\ast$ \hyperlink{classns3_1_1TcpL4Protocol_ad893d914b5fa45d29bd5a66ab29e9b9b}{Allocate6} (void)
\begin{DoxyCompactList}\small\item\em Allocate an I\+Pv6 Endpoint. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6EndPoint}{Ipv6\+End\+Point} $\ast$ \hyperlink{classns3_1_1TcpL4Protocol_aacb7472f9a2089f315e3163d81c9decc}{Allocate6} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} address)
\begin{DoxyCompactList}\small\item\em Allocate an I\+Pv6 Endpoint. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6EndPoint}{Ipv6\+End\+Point} $\ast$ \hyperlink{classns3_1_1TcpL4Protocol_a39a60c2a0542afed9081e2bdf2b44e70}{Allocate6} (uint16\+\_\+t \hyperlink{visualizer-ideas_8txt_a21ff1c530daf8435e00048b7fc2c58e3}{port})
\begin{DoxyCompactList}\small\item\em Allocate an I\+Pv6 Endpoint. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6EndPoint}{Ipv6\+End\+Point} $\ast$ \hyperlink{classns3_1_1TcpL4Protocol_a4fa3c137089dc8f15ba7d920d1670cb2}{Allocate6} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} address, uint16\+\_\+t \hyperlink{visualizer-ideas_8txt_a21ff1c530daf8435e00048b7fc2c58e3}{port})
\begin{DoxyCompactList}\small\item\em Allocate an I\+Pv6 Endpoint. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6EndPoint}{Ipv6\+End\+Point} $\ast$ \hyperlink{classns3_1_1TcpL4Protocol_a67227b5ea7384706647dd4d8a920c128}{Allocate6} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} local\+Address, uint16\+\_\+t local\+Port, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} peer\+Address, uint16\+\_\+t peer\+Port)
\begin{DoxyCompactList}\small\item\em Allocate an I\+Pv6 Endpoint. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1TcpL4Protocol_a622217854cad6fdfd562f42a6731ba6c}{Send\+Packet} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ pkt, const \hyperlink{classns3_1_1TcpHeader}{Tcp\+Header} \&outgoing, const \hyperlink{classns3_1_1Address}{Address} \&saddr, const \hyperlink{classns3_1_1Address}{Address} \&daddr, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ oif=0) const 
\begin{DoxyCompactList}\small\item\em Send a packet via T\+CP (I\+P-\/agnostic) \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1TcpL4Protocol_ae095cd8ab417acd8eba1fb0385720292}{Add\+Socket} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1TcpSocketBase}{Tcp\+Socket\+Base} $>$ socket)
\begin{DoxyCompactList}\small\item\em Make a socket fully operational. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1TcpL4Protocol_a1d5f0e4067f225e35e0b73ad2e80c5a9}{Remove\+Socket} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1TcpSocketBase}{Tcp\+Socket\+Base} $>$ socket)
\begin{DoxyCompactList}\small\item\em Remove a socket from the internal list. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1TcpL4Protocol_ab538121d6641110ce20e68e9e4ab5fce}{De\+Allocate} (\hyperlink{classns3_1_1Ipv4EndPoint}{Ipv4\+End\+Point} $\ast$end\+Point)
\begin{DoxyCompactList}\small\item\em Remove an I\+Pv4 Endpoint. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1TcpL4Protocol_aa0b65ccf2bd4f41738446f1990f97bbf}{De\+Allocate} (\hyperlink{classns3_1_1Ipv6EndPoint}{Ipv6\+End\+Point} $\ast$end\+Point)
\begin{DoxyCompactList}\small\item\em Remove an I\+Pv6 Endpoint. \end{DoxyCompactList}\item 
virtual enum \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80e}{Ip\+L4\+Protocol\+::\+Rx\+Status} \hyperlink{classns3_1_1TcpL4Protocol_a73a9498522829954684a7b4fabd6bf3e}{Receive} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} const \&incoming\+Ip\+Header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} $>$ incoming\+Interface)
\begin{DoxyCompactList}\small\item\em Called from lower-\/level layers to send the packet up in the stack. \end{DoxyCompactList}\item 
virtual enum \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80e}{Ip\+L4\+Protocol\+::\+Rx\+Status} \hyperlink{classns3_1_1TcpL4Protocol_a47f392dce81978c0c2f3e7b46d1a9024}{Receive} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} const \&incoming\+Ip\+Header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Interface}{Ipv6\+Interface} $>$ incoming\+Interface)
\begin{DoxyCompactList}\small\item\em Called from lower-\/level layers to send the packet up in the stack. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1TcpL4Protocol_aa78a842105c7a60f09eda4a0980c7458}{Receive\+Icmp} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} icmp\+Source, uint8\+\_\+t icmp\+Ttl, uint8\+\_\+t icmp\+Type, uint8\+\_\+t icmp\+Code, uint32\+\_\+t icmp\+Info, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} payload\+Source, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} payload\+Destination, const uint8\+\_\+t payload\mbox{[}8\mbox{]})
\begin{DoxyCompactList}\small\item\em Called from lower-\/level layers to send the I\+C\+MP packet up in the stack. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1TcpL4Protocol_a8643c5c8926d6e21dfaabf472b5652d3}{Receive\+Icmp} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} icmp\+Source, uint8\+\_\+t icmp\+Ttl, uint8\+\_\+t icmp\+Type, uint8\+\_\+t icmp\+Code, uint32\+\_\+t icmp\+Info, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} payload\+Source, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} payload\+Destination, const uint8\+\_\+t payload\mbox{[}8\mbox{]})
\begin{DoxyCompactList}\small\item\em Called from lower-\/level layers to send the I\+C\+M\+Pv6 packet up in the stack. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1TcpL4Protocol_aa29220d10741bf33a6d95ce9a985971f}{Set\+Down\+Target} (\hyperlink{classns3_1_1IpL4Protocol_ae3ba76c0a48fbaa90529c528a15f12b6}{Ip\+L4\+Protocol\+::\+Down\+Target\+Callback} cb)
\item 
virtual void \hyperlink{classns3_1_1TcpL4Protocol_ae35e768fcbb81c201c695ba4fbbeab1d}{Set\+Down\+Target6} (\hyperlink{classns3_1_1IpL4Protocol_a039f3d1883632ab922fa958fc9ecd97f}{Ip\+L4\+Protocol\+::\+Down\+Target\+Callback6} cb)
\item 
virtual int \hyperlink{classns3_1_1TcpL4Protocol_aa92b0762011f084a4115e2802a90b651}{Get\+Protocol\+Number} (void) const 
\begin{DoxyCompactList}\small\item\em Returns the protocol number of this protocol. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1IpL4Protocol_ae3ba76c0a48fbaa90529c528a15f12b6}{Ip\+L4\+Protocol\+::\+Down\+Target\+Callback} \hyperlink{classns3_1_1TcpL4Protocol_a609446282ae721c149d67d9015411def}{Get\+Down\+Target} (void) const 
\item 
virtual \hyperlink{classns3_1_1IpL4Protocol_a039f3d1883632ab922fa958fc9ecd97f}{Ip\+L4\+Protocol\+::\+Down\+Target\+Callback6} \hyperlink{classns3_1_1TcpL4Protocol_a5a196acbab733f671ab678e3d59d1a00}{Get\+Down\+Target6} (void) const 
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1TcpL4Protocol_ad5c8be6d4a2f790b4a095d97ad35f6f9}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const uint8\+\_\+t \hyperlink{classns3_1_1TcpL4Protocol_ac6c1cee44ae21227e755678bb52dbc89}{P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER} = 6
\begin{DoxyCompactList}\small\item\em protocol number (0x6) \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1TcpL4Protocol_a9d2286b9af7437138f6c1c8ecdaa048d}{Do\+Dispose} (void)
\item 
virtual void \hyperlink{classns3_1_1TcpL4Protocol_ace34214dade5d0c0c2220ad01866111c}{Notify\+New\+Aggregate} ()
\begin{DoxyCompactList}\small\item\em Setup socket factory and callbacks when aggregated to a node. \end{DoxyCompactList}\item 
enum \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80e}{Ip\+L4\+Protocol\+::\+Rx\+Status} \hyperlink{classns3_1_1TcpL4Protocol_a3ff49ecbf02516282f7b8158819f432b}{Packet\+Received} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1TcpHeader}{Tcp\+Header} \&incoming\+Tcp\+Header, const \hyperlink{classns3_1_1Address}{Address} \&source, const \hyperlink{classns3_1_1Address}{Address} \&destination)
\begin{DoxyCompactList}\small\item\em Get the tcp header of the incoming packet and checks its checksum if needed. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1TcpL4Protocol_a16c65189190c60da860bc60681c01324}{No\+End\+Points\+Found} (const \hyperlink{classns3_1_1TcpHeader}{Tcp\+Header} \&incoming\+Header, const \hyperlink{classns3_1_1Address}{Address} \&incoming\+S\+Addr, const \hyperlink{classns3_1_1Address}{Address} \&incoming\+D\+Addr)
\begin{DoxyCompactList}\small\item\em Check if R\+ST packet should be sent, and in case, send it. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1TcpL4Protocol_af48062ff2edb07fba859cfc9a863beaa}{Tcp\+L4\+Protocol} (const \hyperlink{classns3_1_1TcpL4Protocol}{Tcp\+L4\+Protocol} \&)
\begin{DoxyCompactList}\small\item\em Copy constructor. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TcpL4Protocol}{Tcp\+L4\+Protocol} \& \hyperlink{classns3_1_1TcpL4Protocol_abe87d24c55bfbd6c6c2753725e239cca}{operator=} (const \hyperlink{classns3_1_1TcpL4Protocol}{Tcp\+L4\+Protocol} \&)
\begin{DoxyCompactList}\small\item\em Copy constructor. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1TcpL4Protocol_ae57806dce4847383a27e329656e77e14}{Send\+Packet\+V4} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ pkt, const \hyperlink{classns3_1_1TcpHeader}{Tcp\+Header} \&outgoing, const \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \&saddr, const \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \&daddr, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ oif=0) const 
\begin{DoxyCompactList}\small\item\em Send a packet via T\+CP (I\+Pv4) \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1TcpL4Protocol_a12831eb88c02c37b3cf42cdda814cd19}{Send\+Packet\+V6} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ pkt, const \hyperlink{classns3_1_1TcpHeader}{Tcp\+Header} \&outgoing, const \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} \&saddr, const \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} \&daddr, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ oif=0) const 
\begin{DoxyCompactList}\small\item\em Send a packet via T\+CP (I\+Pv6) \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1TcpL4Protocol_a89e39fd5367f8ce22565f69e224de189}{m\+\_\+node}
\begin{DoxyCompactList}\small\item\em the node this stack is associated with \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4EndPointDemux}{Ipv4\+End\+Point\+Demux} $\ast$ \hyperlink{classns3_1_1TcpL4Protocol_a7ca53708bd7d91191af64a290095ebe7}{m\+\_\+end\+Points}
\begin{DoxyCompactList}\small\item\em A list of I\+Pv4 end points. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6EndPointDemux}{Ipv6\+End\+Point\+Demux} $\ast$ \hyperlink{classns3_1_1TcpL4Protocol_a88deacf73247133fccfe64179ad665e3}{m\+\_\+end\+Points6}
\begin{DoxyCompactList}\small\item\em A list of I\+Pv6 end points. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1TcpL4Protocol_aff3e46318717dcbce5f222e94b8345cd}{m\+\_\+rtt\+Type\+Id}
\begin{DoxyCompactList}\small\item\em The R\+TT Estimator \hyperlink{classns3_1_1TypeId}{Type\+Id}. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1TcpL4Protocol_a2c724fd042748420d8a8df49e7ef28d7}{m\+\_\+congestion\+Type\+Id}
\begin{DoxyCompactList}\small\item\em The socket \hyperlink{classns3_1_1TypeId}{Type\+Id}. \end{DoxyCompactList}\item 
std\+::vector$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1TcpSocketBase}{Tcp\+Socket\+Base} $>$ $>$ \hyperlink{classns3_1_1TcpL4Protocol_a7f0bde5144a1bb7594e4cf366669bcbc}{m\+\_\+sockets}
\begin{DoxyCompactList}\small\item\em list of sockets \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1IpL4Protocol_ae3ba76c0a48fbaa90529c528a15f12b6}{Ip\+L4\+Protocol\+::\+Down\+Target\+Callback} \hyperlink{classns3_1_1TcpL4Protocol_a6624133b0d5072cacbd77c9dc90aee75}{m\+\_\+down\+Target}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Callback}{Callback} to send packets over I\+Pv4. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1IpL4Protocol_a039f3d1883632ab922fa958fc9ecd97f}{Ip\+L4\+Protocol\+::\+Down\+Target\+Callback6} \hyperlink{classns3_1_1TcpL4Protocol_ae4447ef1e9b58f1352b819a9c6fff496}{m\+\_\+down\+Target6}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Callback}{Callback} to send packets over I\+Pv6. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
T\+CP socket creation and multiplexing/demultiplexing. 

A single instance of this class is held by one instance of class \hyperlink{classns3_1_1Node}{Node}.

The creation of \hyperlink{classns3_1_1TcpSocket}{Tcp\+Socket} are handled in the method Create\+Socket, which is called by \hyperlink{classns3_1_1TcpSocketFactory}{Tcp\+Socket\+Factory}. Upon creation, this class is responsible to the socket initialization and handle multiplexing/demultiplexing of data between node\textquotesingle{}s T\+CP sockets. Demultiplexing is done by receiving packets from IP, and forwards them up to the right socket. Multiplexing is done through the Send\+Packet function, which sends the packet down the stack.

Moreover, this class allocates \char`\"{}endpoint\char`\"{} objects (\hyperlink{classns3_1_1Ipv4EndPoint}{ns3\+::\+Ipv4\+End\+Point}) for T\+CP, and S\+H\+O\+U\+LD checksum packets its receives from the socket layer going down the stack, but currently checksumming is disabled.

\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1TcpL4Protocol_a896ad7a5e3959180dce59e81897f131c}{Create\+Socket} 

\hyperlink{classns3_1_1TcpL4Protocol_ace34214dade5d0c0c2220ad01866111c}{Notify\+New\+Aggregate} 

\hyperlink{classns3_1_1TcpL4Protocol_a622217854cad6fdfd562f42a6731ba6c}{Send\+Packet} 
\end{DoxySeeAlso}


\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Tcp\+L4\+Protocol@{Tcp\+L4\+Protocol}}
\index{Tcp\+L4\+Protocol@{Tcp\+L4\+Protocol}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Tcp\+L4\+Protocol()}{TcpL4Protocol()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Tcp\+L4\+Protocol\+::\+Tcp\+L4\+Protocol (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpL4Protocol_a56aa36e10a43fbdc7b0765562498fa10}{}\label{classns3_1_1TcpL4Protocol_a56aa36e10a43fbdc7b0765562498fa10}

\begin{DoxyCode}
92   : \hyperlink{classns3_1_1TcpL4Protocol_a7ca53708bd7d91191af64a290095ebe7}{m\_endPoints} (\textcolor{keyword}{new} Ipv4EndPointDemux ()), \hyperlink{classns3_1_1TcpL4Protocol_a88deacf73247133fccfe64179ad665e3}{m\_endPoints6} (\textcolor{keyword}{new} Ipv6EndPointDemux ())
93 \{
94   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
95   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Made a TcpL4Protocol "} << \textcolor{keyword}{this});
96 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!````~Tcp\+L4\+Protocol@{$\sim$\+Tcp\+L4\+Protocol}}
\index{````~Tcp\+L4\+Protocol@{$\sim$\+Tcp\+L4\+Protocol}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{$\sim$\+Tcp\+L4\+Protocol()}{~TcpL4Protocol()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Tcp\+L4\+Protocol\+::$\sim$\+Tcp\+L4\+Protocol (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TcpL4Protocol_af9b9b6731ad1df044ef4416ff88bdc85}{}\label{classns3_1_1TcpL4Protocol_af9b9b6731ad1df044ef4416ff88bdc85}

\begin{DoxyCode}
99 \{
100   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
101 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Tcp\+L4\+Protocol@{Tcp\+L4\+Protocol}}
\index{Tcp\+L4\+Protocol@{Tcp\+L4\+Protocol}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Tcp\+L4\+Protocol(const Tcp\+L4\+Protocol \&)}{TcpL4Protocol(const TcpL4Protocol &)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Tcp\+L4\+Protocol\+::\+Tcp\+L4\+Protocol (
\begin{DoxyParamCaption}
\item[{const {\bf Tcp\+L4\+Protocol} \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpL4Protocol_af48062ff2edb07fba859cfc9a863beaa}{}\label{classns3_1_1TcpL4Protocol_af48062ff2edb07fba859cfc9a863beaa}


Copy constructor. 

Defined and not implemented to avoid misuse 

\subsection{Member Function Documentation}
\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Add\+Socket@{Add\+Socket}}
\index{Add\+Socket@{Add\+Socket}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Add\+Socket(\+Ptr$<$ Tcp\+Socket\+Base $>$ socket)}{AddSocket(Ptr< TcpSocketBase > socket)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+L4\+Protocol\+::\+Add\+Socket (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Tcp\+Socket\+Base} $>$}]{socket}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpL4Protocol_ae095cd8ab417acd8eba1fb0385720292}{}\label{classns3_1_1TcpL4Protocol_ae095cd8ab417acd8eba1fb0385720292}


Make a socket fully operational. 

Called after a socket has been bound, it is inserted in an internal vector.


\begin{DoxyParams}{Parameters}
{\em socket} & \hyperlink{classns3_1_1Socket}{Socket} to be added \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
687 \{
688   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << socket);
689   std::vector<Ptr<TcpSocketBase> >::iterator it = \hyperlink{classns3_1_1TcpL4Protocol_a7f0bde5144a1bb7594e4cf366669bcbc}{m\_sockets}.begin ();
690 
691   \textcolor{keywordflow}{while} (it != \hyperlink{classns3_1_1TcpL4Protocol_a7f0bde5144a1bb7594e4cf366669bcbc}{m\_sockets}.end ())
692     \{
693       \textcolor{keywordflow}{if} (*it == socket)
694         \{
695           \textcolor{keywordflow}{return};
696         \}
697 
698       ++it;
699     \}
700 
701   \hyperlink{classns3_1_1TcpL4Protocol_a7f0bde5144a1bb7594e4cf366669bcbc}{m\_sockets}.push\_back (socket);
702 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Allocate@{Allocate}}
\index{Allocate@{Allocate}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Allocate(void)}{Allocate(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+End\+Point} $\ast$ ns3\+::\+Tcp\+L4\+Protocol\+::\+Allocate (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpL4Protocol_a9e0180270b7b8106263b1b3660e71094}{}\label{classns3_1_1TcpL4Protocol_a9e0180270b7b8106263b1b3660e71094}


Allocate an I\+Pv4 Endpoint. 

\begin{DoxyReturn}{Returns}
the Endpoint 
\end{DoxyReturn}

\begin{DoxyCode}
207 \{
208   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
209   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpL4Protocol_a7ca53708bd7d91191af64a290095ebe7}{m\_endPoints}->\hyperlink{classns3_1_1Ipv4EndPointDemux_a95eef225abf664ea72523730e00e621e}{Allocate} ();
210 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Allocate@{Allocate}}
\index{Allocate@{Allocate}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Allocate(\+Ipv4\+Address address)}{Allocate(Ipv4Address address)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+End\+Point} $\ast$ ns3\+::\+Tcp\+L4\+Protocol\+::\+Allocate (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{address}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpL4Protocol_ad3e4b59d30097e97f69a1d2dcf1455ab}{}\label{classns3_1_1TcpL4Protocol_ad3e4b59d30097e97f69a1d2dcf1455ab}


Allocate an I\+Pv4 Endpoint. 


\begin{DoxyParams}{Parameters}
{\em address} & address to use \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the Endpoint 
\end{DoxyReturn}

\begin{DoxyCode}
214 \{
215   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << address);
216   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpL4Protocol_a7ca53708bd7d91191af64a290095ebe7}{m\_endPoints}->\hyperlink{classns3_1_1Ipv4EndPointDemux_a95eef225abf664ea72523730e00e621e}{Allocate} (address);
217 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Allocate@{Allocate}}
\index{Allocate@{Allocate}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Allocate(uint16\+\_\+t port)}{Allocate(uint16_t port)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+End\+Point} $\ast$ ns3\+::\+Tcp\+L4\+Protocol\+::\+Allocate (
\begin{DoxyParamCaption}
\item[{uint16\+\_\+t}]{port}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpL4Protocol_a6ab346a592abf0bcbd008822aa06a395}{}\label{classns3_1_1TcpL4Protocol_a6ab346a592abf0bcbd008822aa06a395}


Allocate an I\+Pv4 Endpoint. 


\begin{DoxyParams}{Parameters}
{\em port} & port to use \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the Endpoint 
\end{DoxyReturn}

\begin{DoxyCode}
221 \{
222   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{dsdv-manet_8cc_a8e0798404bf2cf5dabb84c5ba9a4f236}{port});
223   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpL4Protocol_a7ca53708bd7d91191af64a290095ebe7}{m\_endPoints}->\hyperlink{classns3_1_1Ipv4EndPointDemux_a95eef225abf664ea72523730e00e621e}{Allocate} (\hyperlink{dsdv-manet_8cc_a8e0798404bf2cf5dabb84c5ba9a4f236}{port});
224 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4


\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Allocate@{Allocate}}
\index{Allocate@{Allocate}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Allocate(\+Ipv4\+Address address, uint16\+\_\+t port)}{Allocate(Ipv4Address address, uint16_t port)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+End\+Point} $\ast$ ns3\+::\+Tcp\+L4\+Protocol\+::\+Allocate (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{address, }
\item[{uint16\+\_\+t}]{port}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpL4Protocol_aefbec4064ad275ba7c75d49e672951c1}{}\label{classns3_1_1TcpL4Protocol_aefbec4064ad275ba7c75d49e672951c1}


Allocate an I\+Pv4 Endpoint. 


\begin{DoxyParams}{Parameters}
{\em address} & address to use \\
\hline
{\em port} & port to use \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the Endpoint 
\end{DoxyReturn}

\begin{DoxyCode}
228 \{
229   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << address << \hyperlink{dsdv-manet_8cc_a8e0798404bf2cf5dabb84c5ba9a4f236}{port});
230   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpL4Protocol_a7ca53708bd7d91191af64a290095ebe7}{m\_endPoints}->\hyperlink{classns3_1_1Ipv4EndPointDemux_a95eef225abf664ea72523730e00e621e}{Allocate} (address, \hyperlink{dsdv-manet_8cc_a8e0798404bf2cf5dabb84c5ba9a4f236}{port});
231 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5


\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Allocate@{Allocate}}
\index{Allocate@{Allocate}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Allocate(\+Ipv4\+Address local\+Address, uint16\+\_\+t local\+Port, Ipv4\+Address peer\+Address, uint16\+\_\+t peer\+Port)}{Allocate(Ipv4Address localAddress, uint16_t localPort, Ipv4Address peerAddress, uint16_t peerPort)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+End\+Point} $\ast$ ns3\+::\+Tcp\+L4\+Protocol\+::\+Allocate (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{local\+Address, }
\item[{uint16\+\_\+t}]{local\+Port, }
\item[{{\bf Ipv4\+Address}}]{peer\+Address, }
\item[{uint16\+\_\+t}]{peer\+Port}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpL4Protocol_a8db77eeebb3b4e6728137f8f0dfeb947}{}\label{classns3_1_1TcpL4Protocol_a8db77eeebb3b4e6728137f8f0dfeb947}


Allocate an I\+Pv4 Endpoint. 


\begin{DoxyParams}{Parameters}
{\em local\+Address} & local address to use \\
\hline
{\em local\+Port} & local port to use \\
\hline
{\em peer\+Address} & remote address to use \\
\hline
{\em peer\+Port} & remote port to use \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the Endpoint 
\end{DoxyReturn}

\begin{DoxyCode}
236 \{
237   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << localAddress << localPort << peerAddress << peerPort);
238   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpL4Protocol_a7ca53708bd7d91191af64a290095ebe7}{m\_endPoints}->\hyperlink{classns3_1_1Ipv4EndPointDemux_a95eef225abf664ea72523730e00e621e}{Allocate} (localAddress, localPort,
239                                 peerAddress, peerPort);
240 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6


\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Allocate6@{Allocate6}}
\index{Allocate6@{Allocate6}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Allocate6(void)}{Allocate6(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+End\+Point} $\ast$ ns3\+::\+Tcp\+L4\+Protocol\+::\+Allocate6 (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpL4Protocol_ad893d914b5fa45d29bd5a66ab29e9b9b}{}\label{classns3_1_1TcpL4Protocol_ad893d914b5fa45d29bd5a66ab29e9b9b}


Allocate an I\+Pv6 Endpoint. 

\begin{DoxyReturn}{Returns}
the Endpoint 
\end{DoxyReturn}

\begin{DoxyCode}
251 \{
252   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
253   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpL4Protocol_a88deacf73247133fccfe64179ad665e3}{m\_endPoints6}->\hyperlink{classns3_1_1Ipv6EndPointDemux_a586cf13b626d18745734faf36ecdd158}{Allocate} ();
254 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7


\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Allocate6@{Allocate6}}
\index{Allocate6@{Allocate6}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Allocate6(\+Ipv6\+Address address)}{Allocate6(Ipv6Address address)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+End\+Point} $\ast$ ns3\+::\+Tcp\+L4\+Protocol\+::\+Allocate6 (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{address}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpL4Protocol_aacb7472f9a2089f315e3163d81c9decc}{}\label{classns3_1_1TcpL4Protocol_aacb7472f9a2089f315e3163d81c9decc}


Allocate an I\+Pv6 Endpoint. 


\begin{DoxyParams}{Parameters}
{\em address} & address to use \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the Endpoint 
\end{DoxyReturn}

\begin{DoxyCode}
258 \{
259   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << address);
260   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpL4Protocol_a88deacf73247133fccfe64179ad665e3}{m\_endPoints6}->\hyperlink{classns3_1_1Ipv6EndPointDemux_a586cf13b626d18745734faf36ecdd158}{Allocate} (address);
261 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8


\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Allocate6@{Allocate6}}
\index{Allocate6@{Allocate6}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Allocate6(uint16\+\_\+t port)}{Allocate6(uint16_t port)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+End\+Point} $\ast$ ns3\+::\+Tcp\+L4\+Protocol\+::\+Allocate6 (
\begin{DoxyParamCaption}
\item[{uint16\+\_\+t}]{port}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpL4Protocol_a39a60c2a0542afed9081e2bdf2b44e70}{}\label{classns3_1_1TcpL4Protocol_a39a60c2a0542afed9081e2bdf2b44e70}


Allocate an I\+Pv6 Endpoint. 


\begin{DoxyParams}{Parameters}
{\em port} & port to use \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the Endpoint 
\end{DoxyReturn}

\begin{DoxyCode}
265 \{
266   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{dsdv-manet_8cc_a8e0798404bf2cf5dabb84c5ba9a4f236}{port});
267   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpL4Protocol_a88deacf73247133fccfe64179ad665e3}{m\_endPoints6}->\hyperlink{classns3_1_1Ipv6EndPointDemux_a586cf13b626d18745734faf36ecdd158}{Allocate} (\hyperlink{dsdv-manet_8cc_a8e0798404bf2cf5dabb84c5ba9a4f236}{port});
268 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9


\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Allocate6@{Allocate6}}
\index{Allocate6@{Allocate6}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Allocate6(\+Ipv6\+Address address, uint16\+\_\+t port)}{Allocate6(Ipv6Address address, uint16_t port)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+End\+Point} $\ast$ ns3\+::\+Tcp\+L4\+Protocol\+::\+Allocate6 (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{address, }
\item[{uint16\+\_\+t}]{port}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpL4Protocol_a4fa3c137089dc8f15ba7d920d1670cb2}{}\label{classns3_1_1TcpL4Protocol_a4fa3c137089dc8f15ba7d920d1670cb2}


Allocate an I\+Pv6 Endpoint. 


\begin{DoxyParams}{Parameters}
{\em address} & address to use \\
\hline
{\em port} & port to use \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the Endpoint 
\end{DoxyReturn}

\begin{DoxyCode}
272 \{
273   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << address << \hyperlink{dsdv-manet_8cc_a8e0798404bf2cf5dabb84c5ba9a4f236}{port});
274   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpL4Protocol_a88deacf73247133fccfe64179ad665e3}{m\_endPoints6}->\hyperlink{classns3_1_1Ipv6EndPointDemux_a586cf13b626d18745734faf36ecdd158}{Allocate} (address, \hyperlink{dsdv-manet_8cc_a8e0798404bf2cf5dabb84c5ba9a4f236}{port});
275 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10


\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Allocate6@{Allocate6}}
\index{Allocate6@{Allocate6}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Allocate6(\+Ipv6\+Address local\+Address, uint16\+\_\+t local\+Port, Ipv6\+Address peer\+Address, uint16\+\_\+t peer\+Port)}{Allocate6(Ipv6Address localAddress, uint16_t localPort, Ipv6Address peerAddress, uint16_t peerPort)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+End\+Point} $\ast$ ns3\+::\+Tcp\+L4\+Protocol\+::\+Allocate6 (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{local\+Address, }
\item[{uint16\+\_\+t}]{local\+Port, }
\item[{{\bf Ipv6\+Address}}]{peer\+Address, }
\item[{uint16\+\_\+t}]{peer\+Port}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpL4Protocol_a67227b5ea7384706647dd4d8a920c128}{}\label{classns3_1_1TcpL4Protocol_a67227b5ea7384706647dd4d8a920c128}


Allocate an I\+Pv6 Endpoint. 


\begin{DoxyParams}{Parameters}
{\em local\+Address} & local address to use \\
\hline
{\em local\+Port} & local port to use \\
\hline
{\em peer\+Address} & remote address to use \\
\hline
{\em peer\+Port} & remote port to use \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the Endpoint 
\end{DoxyReturn}

\begin{DoxyCode}
280 \{
281   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << localAddress << localPort << peerAddress << peerPort);
282   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpL4Protocol_a88deacf73247133fccfe64179ad665e3}{m\_endPoints6}->\hyperlink{classns3_1_1Ipv6EndPointDemux_a586cf13b626d18745734faf36ecdd158}{Allocate} (localAddress, localPort,
283                                  peerAddress, peerPort);
284 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 11


\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Create\+Socket@{Create\+Socket}}
\index{Create\+Socket@{Create\+Socket}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Create\+Socket(void)}{CreateSocket(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Socket} $>$ ns3\+::\+Tcp\+L4\+Protocol\+::\+Create\+Socket (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpL4Protocol_a896ad7a5e3959180dce59e81897f131c}{}\label{classns3_1_1TcpL4Protocol_a896ad7a5e3959180dce59e81897f131c}


Create a T\+CP socket using the \hyperlink{classns3_1_1TypeId}{Type\+Id} set by Socket\+Type attribute. 

\begin{DoxyReturn}{Returns}
A smart \hyperlink{classns3_1_1Socket}{Socket} pointer to a \hyperlink{classns3_1_1TcpSocket}{Tcp\+Socket} allocated by this instance of the T\+CP protocol 
\end{DoxyReturn}

\begin{DoxyCode}
201 \{
202   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpL4Protocol_a896ad7a5e3959180dce59e81897f131c}{CreateSocket} (\hyperlink{classns3_1_1TcpL4Protocol_a2c724fd042748420d8a8df49e7ef28d7}{m\_congestionTypeId});
203 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Create\+Socket@{Create\+Socket}}
\index{Create\+Socket@{Create\+Socket}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Create\+Socket(\+Type\+Id congestion\+Type\+Id)}{CreateSocket(TypeId congestionTypeId)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Socket} $>$ ns3\+::\+Tcp\+L4\+Protocol\+::\+Create\+Socket (
\begin{DoxyParamCaption}
\item[{{\bf Type\+Id}}]{congestion\+Type\+Id}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpL4Protocol_ae5d3e3fd9fa44cc80d3ae5f62e4dfb82}{}\label{classns3_1_1TcpL4Protocol_ae5d3e3fd9fa44cc80d3ae5f62e4dfb82}


Create a T\+CP socket using the specified congestion control algorithm \hyperlink{classns3_1_1TypeId}{Type\+Id}. 

\begin{DoxyReturn}{Returns}
A smart \hyperlink{classns3_1_1Socket}{Socket} pointer to a \hyperlink{classns3_1_1TcpSocket}{Tcp\+Socket} allocated by this instance of the T\+CP protocol
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
using a congestion\+Type\+Id other than T\+CP is a bad idea.
\end{DoxyWarning}

\begin{DoxyParams}{Parameters}
{\em congestion\+Type\+Id} & the congestion control algorithm \hyperlink{classns3_1_1TypeId}{Type\+Id} \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
179 \{
180   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << congestionTypeId.GetName ());
181   \hyperlink{classns3_1_1Object_a2810e70b8c8377aa8617138fc0f65e92}{ObjectFactory} rttFactory;
182   \hyperlink{classns3_1_1Object_a2810e70b8c8377aa8617138fc0f65e92}{ObjectFactory} congestionAlgorithmFactory;
183   rttFactory.SetTypeId (\hyperlink{classns3_1_1TcpL4Protocol_aff3e46318717dcbce5f222e94b8345cd}{m\_rttTypeId});
184   congestionAlgorithmFactory.SetTypeId (congestionTypeId);
185 
186   Ptr<RttEstimator> rtt = rttFactory.Create<RttEstimator> ();
187   Ptr<TcpSocketBase> socket = CreateObject<TcpSocketBase> ();
188   Ptr<TcpCongestionOps> algo = congestionAlgorithmFactory.Create<TcpCongestionOps> ();
189 
190   socket->SetNode (\hyperlink{classns3_1_1TcpL4Protocol_a89e39fd5367f8ce22565f69e224de189}{m\_node});
191   socket->SetTcp (\textcolor{keyword}{this});
192   socket->SetRtt (rtt);
193   socket->SetCongestionControlAlgorithm (algo);
194 
195   \hyperlink{classns3_1_1TcpL4Protocol_a7f0bde5144a1bb7594e4cf366669bcbc}{m\_sockets}.push\_back (socket);
196   \textcolor{keywordflow}{return} socket;
197 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12


\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!De\+Allocate@{De\+Allocate}}
\index{De\+Allocate@{De\+Allocate}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{De\+Allocate(\+Ipv4\+End\+Point $\ast$end\+Point)}{DeAllocate(Ipv4EndPoint *endPoint)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+L4\+Protocol\+::\+De\+Allocate (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+End\+Point} $\ast$}]{end\+Point}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpL4Protocol_ab538121d6641110ce20e68e9e4ab5fce}{}\label{classns3_1_1TcpL4Protocol_ab538121d6641110ce20e68e9e4ab5fce}


Remove an I\+Pv4 Endpoint. 


\begin{DoxyParams}{Parameters}
{\em end\+Point} & the end point to remove \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
244 \{
245   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << endPoint);
246   \hyperlink{classns3_1_1TcpL4Protocol_a7ca53708bd7d91191af64a290095ebe7}{m\_endPoints}->\hyperlink{classns3_1_1Ipv4EndPointDemux_aef987a05ce248887200d14525b8daaec}{DeAllocate} (endPoint);
247 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13


\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!De\+Allocate@{De\+Allocate}}
\index{De\+Allocate@{De\+Allocate}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{De\+Allocate(\+Ipv6\+End\+Point $\ast$end\+Point)}{DeAllocate(Ipv6EndPoint *endPoint)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+L4\+Protocol\+::\+De\+Allocate (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+End\+Point} $\ast$}]{end\+Point}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpL4Protocol_aa0b65ccf2bd4f41738446f1990f97bbf}{}\label{classns3_1_1TcpL4Protocol_aa0b65ccf2bd4f41738446f1990f97bbf}


Remove an I\+Pv6 Endpoint. 


\begin{DoxyParams}{Parameters}
{\em end\+Point} & the end point to remove \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
288 \{
289   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << endPoint);
290   \hyperlink{classns3_1_1TcpL4Protocol_a88deacf73247133fccfe64179ad665e3}{m\_endPoints6}->\hyperlink{classns3_1_1Ipv6EndPointDemux_ae3824e04716c63ceaca1de60c68f0834}{DeAllocate} (endPoint);
291 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 14


\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Do\+Dispose(void)}{DoDispose(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+L4\+Protocol\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1TcpL4Protocol_a9d2286b9af7437138f6c1c8ecdaa048d}{}\label{classns3_1_1TcpL4Protocol_a9d2286b9af7437138f6c1c8ecdaa048d}
Destructor implementation.

This method is called by \hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose()} or by the \hyperlink{classns3_1_1Object}{Object}\textquotesingle{}s destructor, whichever comes first.

Subclasses are expected to implement their real destruction code in an overriden version of this method and chain up to their parent\textquotesingle{}s implementation once they are done. {\itshape i.\+e}, for simplicity, the destructor of every subclass should be empty and its content should be moved to the associated \hyperlink{classns3_1_1TcpL4Protocol_a9d2286b9af7437138f6c1c8ecdaa048d}{Do\+Dispose()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.


\begin{DoxyCode}
155 \{
156   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
157   \hyperlink{classns3_1_1TcpL4Protocol_a7f0bde5144a1bb7594e4cf366669bcbc}{m\_sockets}.clear ();
158 
159   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TcpL4Protocol_a7ca53708bd7d91191af64a290095ebe7}{m\_endPoints} != 0)
160     \{
161       \textcolor{keyword}{delete} \hyperlink{classns3_1_1TcpL4Protocol_a7ca53708bd7d91191af64a290095ebe7}{m\_endPoints};
162       \hyperlink{classns3_1_1TcpL4Protocol_a7ca53708bd7d91191af64a290095ebe7}{m\_endPoints} = 0;
163     \}
164 
165   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TcpL4Protocol_a88deacf73247133fccfe64179ad665e3}{m\_endPoints6} != 0)
166     \{
167       \textcolor{keyword}{delete} \hyperlink{classns3_1_1TcpL4Protocol_a88deacf73247133fccfe64179ad665e3}{m\_endPoints6};
168       \hyperlink{classns3_1_1TcpL4Protocol_a88deacf73247133fccfe64179ad665e3}{m\_endPoints6} = 0;
169     \}
170 
171   \hyperlink{classns3_1_1TcpL4Protocol_a89e39fd5367f8ce22565f69e224de189}{m\_node} = 0;
172   \hyperlink{classns3_1_1TcpL4Protocol_a6624133b0d5072cacbd77c9dc90aee75}{m\_downTarget}.\hyperlink{classns3_1_1Callback_ab24de4ac458fc5b1ac6f7a672c4c6cea}{Nullify} ();
173   \hyperlink{classns3_1_1TcpL4Protocol_ae4447ef1e9b58f1352b819a9c6fff496}{m\_downTarget6}.\hyperlink{classns3_1_1Callback_ab24de4ac458fc5b1ac6f7a672c4c6cea}{Nullify} ();
174   \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{IpL4Protocol::DoDispose} ();
175 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 15


\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Get\+Down\+Target@{Get\+Down\+Target}}
\index{Get\+Down\+Target@{Get\+Down\+Target}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Down\+Target(void) const }{GetDownTarget(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ip\+L4\+Protocol\+::\+Down\+Target\+Callback} ns3\+::\+Tcp\+L4\+Protocol\+::\+Get\+Down\+Target (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TcpL4Protocol_a609446282ae721c149d67d9015411def}{}\label{classns3_1_1TcpL4Protocol_a609446282ae721c149d67d9015411def}
This method allows a caller to get the current down target callback set for this L4 protocol (I\+Pv4 case)

\begin{DoxyReturn}{Returns}
current \hyperlink{classns3_1_1Callback}{Callback} for the L4 protocol 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1IpL4Protocol_ac0689deffbf226af223668bca54870d0}{ns3\+::\+Ip\+L4\+Protocol}.


\begin{DoxyCode}
732 \{
733   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpL4Protocol_a6624133b0d5072cacbd77c9dc90aee75}{m\_downTarget};
734 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Get\+Down\+Target6@{Get\+Down\+Target6}}
\index{Get\+Down\+Target6@{Get\+Down\+Target6}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Down\+Target6(void) const }{GetDownTarget6(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ip\+L4\+Protocol\+::\+Down\+Target\+Callback6} ns3\+::\+Tcp\+L4\+Protocol\+::\+Get\+Down\+Target6 (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TcpL4Protocol_a5a196acbab733f671ab678e3d59d1a00}{}\label{classns3_1_1TcpL4Protocol_a5a196acbab733f671ab678e3d59d1a00}
This method allows a caller to get the current down target callback set for this L4 protocol (I\+Pv6 case)

\begin{DoxyReturn}{Returns}
current \hyperlink{classns3_1_1Callback}{Callback} for the L4 protocol 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1IpL4Protocol_a208389e5d6362765a58c50264b13b18d}{ns3\+::\+Ip\+L4\+Protocol}.


\begin{DoxyCode}
744 \{
745   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpL4Protocol_ae4447ef1e9b58f1352b819a9c6fff496}{m\_downTarget6};
746 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Get\+Protocol\+Number@{Get\+Protocol\+Number}}
\index{Get\+Protocol\+Number@{Get\+Protocol\+Number}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Protocol\+Number(void) const }{GetProtocolNumber(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Tcp\+L4\+Protocol\+::\+Get\+Protocol\+Number (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TcpL4Protocol_aa92b0762011f084a4115e2802a90b651}{}\label{classns3_1_1TcpL4Protocol_aa92b0762011f084a4115e2802a90b651}


Returns the protocol number of this protocol. 

\begin{DoxyReturn}{Returns}
the protocol number. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1IpL4Protocol_aa5b2c5a670f5304b1a36b890ea858977}{ns3\+::\+Ip\+L4\+Protocol}.


\begin{DoxyCode}
149 \{
150   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpL4Protocol_ac6c1cee44ae21227e755678bb52dbc89}{PROT\_NUMBER};
151 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Tcp\+L4\+Protocol\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1TcpL4Protocol_ad5c8be6d4a2f790b4a095d97ad35f6f9}{}\label{classns3_1_1TcpL4Protocol_ad5c8be6d4a2f790b4a095d97ad35f6f9}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
68 \{
69   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::TcpL4Protocol"})
70     .SetParent<IpL4Protocol> ()
71     .SetGroupName (\textcolor{stringliteral}{"Internet"})
72     .AddConstructor<\hyperlink{classns3_1_1TcpL4Protocol_a56aa36e10a43fbdc7b0765562498fa10}{TcpL4Protocol}> ()
73     .AddAttribute (\textcolor{stringliteral}{"RttEstimatorType"},
74                    \textcolor{stringliteral}{"Type of RttEstimator objects."},
75                    TypeIdValue (\hyperlink{classns3_1_1RttMeanDeviation_a23fc3e702e6d7290bf5fcd53d36e0aa2}{RttMeanDeviation::GetTypeId} ()),
76                    MakeTypeIdAccessor (&\hyperlink{classns3_1_1TcpL4Protocol_aff3e46318717dcbce5f222e94b8345cd}{TcpL4Protocol::m\_rttTypeId}),
77                    MakeTypeIdChecker ())
78     .AddAttribute (\textcolor{stringliteral}{"SocketType"},
79                    \textcolor{stringliteral}{"Socket type of TCP objects."},
80                    TypeIdValue (\hyperlink{classns3_1_1TcpNewReno_af4f4778f724f72a8a441ac0af4cdd8fe}{TcpNewReno::GetTypeId} ()),
81                    MakeTypeIdAccessor (&\hyperlink{classns3_1_1TcpL4Protocol_a2c724fd042748420d8a8df49e7ef28d7}{TcpL4Protocol::m\_congestionTypeId})
      ,
82                    MakeTypeIdChecker ())
83     .AddAttribute (\textcolor{stringliteral}{"SocketList"}, \textcolor{stringliteral}{"The list of sockets associated to this protocol."},
84                    \hyperlink{namespacens3_a5de726d8bcea7a51fd68ce5167a66713}{ObjectVectorValue} (),
85                    \hyperlink{namespacens3_a6ad5b3621a5dc72b7030cbb07c73adf6}{MakeObjectVectorAccessor} (&
      \hyperlink{classns3_1_1TcpL4Protocol_a7f0bde5144a1bb7594e4cf366669bcbc}{TcpL4Protocol::m\_sockets}),
86                    MakeObjectVectorChecker<TcpSocketBase> ())
87   ;
88   \textcolor{keywordflow}{return} tid;
89 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 16


\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!No\+End\+Points\+Found@{No\+End\+Points\+Found}}
\index{No\+End\+Points\+Found@{No\+End\+Points\+Found}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{No\+End\+Points\+Found(const Tcp\+Header \&incoming\+Header, const Address \&incoming\+S\+Addr, const Address \&incoming\+D\+Addr)}{NoEndPointsFound(const TcpHeader &incomingHeader, const Address &incomingSAddr, const Address &incomingDAddr)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+L4\+Protocol\+::\+No\+End\+Points\+Found (
\begin{DoxyParamCaption}
\item[{const {\bf Tcp\+Header} \&}]{incoming\+Header, }
\item[{const {\bf Address} \&}]{incoming\+S\+Addr, }
\item[{const {\bf Address} \&}]{incoming\+D\+Addr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classns3_1_1TcpL4Protocol_a16c65189190c60da860bc60681c01324}{}\label{classns3_1_1TcpL4Protocol_a16c65189190c60da860bc60681c01324}


Check if R\+ST packet should be sent, and in case, send it. 

The function is called when no endpoint is found for the received packet. So \hyperlink{classns3_1_1TcpL4Protocol}{Tcp\+L4\+Protocol} do not know to who the packet should be given to. An R\+ST packet is sent out as reply unless the received packet has the R\+ST flag set.


\begin{DoxyParams}{Parameters}
{\em incoming\+Header} & T\+CP header of the incoming packet \\
\hline
{\em incoming\+S\+Addr} & Source address of the incoming packet \\
\hline
{\em incoming\+D\+Addr} & Destination address of the incoming packet \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
380 \{
381   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << incomingHeader << incomingSAddr << incomingDAddr);
382 
383   \textcolor{keywordflow}{if} (!(incomingHeader.GetFlags () & \hyperlink{classns3_1_1TcpHeader_a5f3d432941327854b5ad621e467479c6ace24c1738ff6e0ae9348ca913b9d10d8}{TcpHeader::RST}))
384     \{
385       \textcolor{comment}{// build a RST packet and send}
386       Ptr<Packet> rstPacket = Create<Packet> ();
387       TcpHeader outgoingTcpHeader;
388 
389       \textcolor{keywordflow}{if} (incomingHeader.GetFlags () & \hyperlink{classns3_1_1TcpHeader_a5f3d432941327854b5ad621e467479c6a1182e63050402c9f49208c62c1ec2d5c}{TcpHeader::ACK})
390         \{
391           \textcolor{comment}{// ACK bit was set}
392           outgoingTcpHeader.SetFlags (\hyperlink{classns3_1_1TcpHeader_a5f3d432941327854b5ad621e467479c6ace24c1738ff6e0ae9348ca913b9d10d8}{TcpHeader::RST});
393           outgoingTcpHeader.SetSequenceNumber (incomingHeader.GetAckNumber ());
394         \}
395       \textcolor{keywordflow}{else}
396         \{
397           outgoingTcpHeader.SetFlags (\hyperlink{classns3_1_1TcpHeader_a5f3d432941327854b5ad621e467479c6ace24c1738ff6e0ae9348ca913b9d10d8}{TcpHeader::RST} | 
      \hyperlink{classns3_1_1TcpHeader_a5f3d432941327854b5ad621e467479c6a1182e63050402c9f49208c62c1ec2d5c}{TcpHeader::ACK});
398           outgoingTcpHeader.SetSequenceNumber (\hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} (0));
399           outgoingTcpHeader.SetAckNumber (incomingHeader.GetSequenceNumber () +
400                                           \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} (1));
401         \}
402 
403       \textcolor{comment}{// Remember that parameters refer to the incoming packet; in reply,}
404       \textcolor{comment}{// we need to swap src/dst}
405 
406       outgoingTcpHeader.SetSourcePort (incomingHeader.GetDestinationPort ());
407       outgoingTcpHeader.SetDestinationPort (incomingHeader.GetSourcePort ());
408 
409       \hyperlink{classns3_1_1TcpL4Protocol_a622217854cad6fdfd562f42a6731ba6c}{SendPacket} (rstPacket, outgoingTcpHeader, incomingDAddr, incomingSAddr);
410     \}
411 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 17




Here is the caller graph for this function\+:
% FIG 18


\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Notify\+New\+Aggregate@{Notify\+New\+Aggregate}}
\index{Notify\+New\+Aggregate@{Notify\+New\+Aggregate}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Notify\+New\+Aggregate()}{NotifyNewAggregate()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+L4\+Protocol\+::\+Notify\+New\+Aggregate (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1TcpL4Protocol_ace34214dade5d0c0c2220ad01866111c}{}\label{classns3_1_1TcpL4Protocol_ace34214dade5d0c0c2220ad01866111c}


Setup socket factory and callbacks when aggregated to a node. 

This function will notify other components connected to the node that a new stack member is now connected. This will be used to notify Layer 3 protocol of layer 4 protocol stack to connect them together. The aggregation is completed by setting the node in the T\+CP stack, link it to the ipv4 or ipv6 stack and adding T\+CP socket factory to the node. 

Reimplemented from \hyperlink{classns3_1_1Object_a1bd7211125185a6cd511c35fea4e500f}{ns3\+::\+Object}.


\begin{DoxyCode}
112 \{
113   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
114   Ptr<Node> node = this->GetObject<Node> ();
115   Ptr<Ipv4> ipv4 = this->GetObject<Ipv4> ();
116   Ptr<Ipv6> ipv6 = node->GetObject<Ipv6> ();
117 
118   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TcpL4Protocol_a89e39fd5367f8ce22565f69e224de189}{m\_node} == 0)
119     \{
120       \textcolor{keywordflow}{if} ((node != 0) && (ipv4 != 0 || ipv6 != 0))
121         \{
122           this->\hyperlink{classns3_1_1TcpL4Protocol_a092de53315ed89dfa2080ef0d92ccd56}{SetNode} (node);
123           Ptr<TcpSocketFactoryImpl> tcpFactory = CreateObject<TcpSocketFactoryImpl> ();
124           tcpFactory->SetTcp (\textcolor{keyword}{this});
125           node->AggregateObject (tcpFactory);
126         \}
127     \}
128 
129   \textcolor{comment}{// We set at least one of our 2 down targets to the IPv4/IPv6 send}
130   \textcolor{comment}{// functions.  Since these functions have different prototypes, we}
131   \textcolor{comment}{// need to keep track of whether we are connected to an IPv4 or}
132   \textcolor{comment}{// IPv6 lower layer and call the appropriate one.}
133 
134   \textcolor{keywordflow}{if} (ipv4 != 0 && \hyperlink{classns3_1_1TcpL4Protocol_a6624133b0d5072cacbd77c9dc90aee75}{m\_downTarget}.\hyperlink{classns3_1_1Callback_aa8e27826badbf37f84763f36f70d9b54}{IsNull} ())
135     \{
136       ipv4->Insert (\textcolor{keyword}{this});
137       this->\hyperlink{classns3_1_1TcpL4Protocol_aa29220d10741bf33a6d95ce9a985971f}{SetDownTarget} (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&\hyperlink{classns3_1_1Ipv4_a81f6cbb774cdc255e3e49490e0960539}{Ipv4::Send}, ipv4));
138     \}
139   \textcolor{keywordflow}{if} (ipv6 != 0 && \hyperlink{classns3_1_1TcpL4Protocol_ae4447ef1e9b58f1352b819a9c6fff496}{m\_downTarget6}.\hyperlink{classns3_1_1Callback_aa8e27826badbf37f84763f36f70d9b54}{IsNull} ())
140     \{
141       ipv6->Insert (\textcolor{keyword}{this});
142       this->\hyperlink{classns3_1_1TcpL4Protocol_ae35e768fcbb81c201c695ba4fbbeab1d}{SetDownTarget6} (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&\hyperlink{classns3_1_1Ipv6_a2aad308983b20eb54334bb0d3db31004}{Ipv6::Send}, ipv6));
143     \}
144   \hyperlink{classns3_1_1Object_a1bd7211125185a6cd511c35fea4e500f}{IpL4Protocol::NotifyNewAggregate} ();
145 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 19


\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!operator=@{operator=}}
\index{operator=@{operator=}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{operator=(const Tcp\+L4\+Protocol \&)}{operator=(const TcpL4Protocol &)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tcp\+L4\+Protocol}\& ns3\+::\+Tcp\+L4\+Protocol\+::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf Tcp\+L4\+Protocol} \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpL4Protocol_abe87d24c55bfbd6c6c2753725e239cca}{}\label{classns3_1_1TcpL4Protocol_abe87d24c55bfbd6c6c2753725e239cca}


Copy constructor. 

Defined and not implemented to avoid misuse \begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Packet\+Received@{Packet\+Received}}
\index{Packet\+Received@{Packet\+Received}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Packet\+Received(\+Ptr$<$ Packet $>$ packet, Tcp\+Header \&incoming\+Tcp\+Header, const Address \&source, const Address \&destination)}{PacketReceived(Ptr< Packet > packet, TcpHeader &incomingTcpHeader, const Address &source, const Address &destination)}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Ip\+L4\+Protocol\+::\+Rx\+Status} ns3\+::\+Tcp\+L4\+Protocol\+::\+Packet\+Received (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Tcp\+Header} \&}]{incoming\+Tcp\+Header, }
\item[{const {\bf Address} \&}]{source, }
\item[{const {\bf Address} \&}]{destination}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classns3_1_1TcpL4Protocol_a3ff49ecbf02516282f7b8158819f432b}{}\label{classns3_1_1TcpL4Protocol_a3ff49ecbf02516282f7b8158819f432b}


Get the tcp header of the incoming packet and checks its checksum if needed. 


\begin{DoxyParams}{Parameters}
{\em packet} & Received packet \\
\hline
{\em incoming\+Tcp\+Header} & Overwritten with the tcp header of the packet \\
\hline
{\em source} & Source address (an underlying \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} or \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address}) \\
\hline
{\em destination} & Destination address (an underlying \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} or \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address})\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
R\+X\+\_\+\+C\+S\+U\+M\+\_\+\+F\+A\+I\+L\+ED if the checksum check fails, R\+X\+\_\+\+OK otherwise 
\end{DoxyReturn}

\begin{DoxyCode}
350 \{
351   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << incomingTcpHeader << source << destination);
352 
353   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Node_a0515bfe9a3aeb6605d657ba855699815}{Node::ChecksumEnabled} ())
354     \{
355       incomingTcpHeader.EnableChecksums ();
356       incomingTcpHeader.InitializeChecksum (source, destination, \hyperlink{classns3_1_1TcpL4Protocol_ac6c1cee44ae21227e755678bb52dbc89}{PROT\_NUMBER});
357     \}
358 
359   packet->\hyperlink{classns3_1_1Packet_aadc63487bea70945c418f4c3e9b81964}{PeekHeader} (incomingTcpHeader);
360 
361   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"TcpL4Protocol "} << \textcolor{keyword}{this}
362                                  << \textcolor{stringliteral}{" receiving seq "} << incomingTcpHeader.GetSequenceNumber ()
363                                  << \textcolor{stringliteral}{" ack "} << incomingTcpHeader.GetAckNumber ()
364                                  << \textcolor{stringliteral}{" flags "}<< \hyperlink{classns3_1_1TcpHeader_aaaa261ca12b0fb50e45c7083cec88cff}{TcpHeader::FlagsToString} (
      incomingTcpHeader.GetFlags ())
365                                  << \textcolor{stringliteral}{" data size "} << packet->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ());
366 
367   \textcolor{keywordflow}{if} (!incomingTcpHeader.IsChecksumOk ())
368     \{
369       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Bad checksum, dropping packet!"});
370       \textcolor{keywordflow}{return} \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80eaba0111c02656760e18ca30479e297b07}{IpL4Protocol::RX\_CSUM\_FAILED};
371     \}
372 
373   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80eabd979bce2f3b22521c81c4115c66317e}{IpL4Protocol::RX\_OK};
374 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 20




Here is the caller graph for this function\+:
% FIG 21


\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Receive@{Receive}}
\index{Receive@{Receive}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Receive(\+Ptr$<$ Packet $>$ p, Ipv4\+Header const \&incoming\+Ip\+Header, Ptr$<$ Ipv4\+Interface $>$ incoming\+Interface)}{Receive(Ptr< Packet > p, Ipv4Header const &incomingIpHeader, Ptr< Ipv4Interface > incomingInterface)}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Ip\+L4\+Protocol\+::\+Rx\+Status} ns3\+::\+Tcp\+L4\+Protocol\+::\+Receive (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{{\bf Ipv4\+Header} const \&}]{header, }
\item[{{\bf Ptr}$<$ {\bf Ipv4\+Interface} $>$}]{incoming\+Interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TcpL4Protocol_a73a9498522829954684a7b4fabd6bf3e}{}\label{classns3_1_1TcpL4Protocol_a73a9498522829954684a7b4fabd6bf3e}


Called from lower-\/level layers to send the packet up in the stack. 


\begin{DoxyParams}{Parameters}
{\em p} & packet to forward up \\
\hline
{\em header} & I\+Pv4 \hyperlink{classns3_1_1Header}{Header} information \\
\hline
{\em incoming\+Interface} & the \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} on which the packet arrived \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Rx status code 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1IpL4Protocol_ad184969a1d9fd630f09e61d15ccad19d}{ns3\+::\+Ip\+L4\+Protocol}.


\begin{DoxyCode}
417 \{
418   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << incomingIpHeader << incomingInterface);
419 
420   TcpHeader incomingTcpHeader;
421   \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80e}{IpL4Protocol::RxStatus} checksumControl;
422 
423   checksumControl = \hyperlink{classns3_1_1TcpL4Protocol_a3ff49ecbf02516282f7b8158819f432b}{PacketReceived} (packet, incomingTcpHeader,
424                                     incomingIpHeader.GetSource (),
425                                     incomingIpHeader.GetDestination ());
426 
427   \textcolor{keywordflow}{if} (checksumControl != \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80eabd979bce2f3b22521c81c4115c66317e}{IpL4Protocol::RX\_OK})
428     \{
429       \textcolor{keywordflow}{return} checksumControl;
430     \}
431 
432   \hyperlink{classns3_1_1Ipv4EndPointDemux_a506a9661c08e2a64dab09ad6613d3b45}{Ipv4EndPointDemux::EndPoints} endPoints;
433   endPoints = \hyperlink{classns3_1_1TcpL4Protocol_a7ca53708bd7d91191af64a290095ebe7}{m\_endPoints}->\hyperlink{classns3_1_1Ipv4EndPointDemux_acd458004b74ea330e9025ab874f2c1b1}{Lookup} (incomingIpHeader.GetDestination (),
434                                    incomingTcpHeader.GetDestinationPort (),
435                                    incomingIpHeader.GetSource (),
436                                    incomingTcpHeader.GetSourcePort (),
437                                    incomingInterface);
438 
439   \textcolor{keywordflow}{if} (endPoints.empty ())
440     \{
441       \textcolor{keywordflow}{if} (this->GetObject<Ipv6L3Protocol> () != 0)
442         \{
443           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"  No Ipv4 endpoints matched on TcpL4Protocol, trying Ipv6 "} << \textcolor{keyword}{this});
444           Ptr<Ipv6Interface> fakeInterface;
445           Ipv6Header ipv6Header;
446           Ipv6Address src, dst;
447 
448           src = \hyperlink{classns3_1_1Ipv6Address_ae2db372827002d9791dec4edb6925021}{Ipv6Address::MakeIpv4MappedAddress} (incomingIpHeader.
      GetSource ());
449           dst = \hyperlink{classns3_1_1Ipv6Address_ae2db372827002d9791dec4edb6925021}{Ipv6Address::MakeIpv4MappedAddress} (incomingIpHeader.
      GetDestination ());
450           ipv6Header.SetSourceAddress (src);
451           ipv6Header.SetDestinationAddress (dst);
452           \textcolor{keywordflow}{return} (this->\hyperlink{classns3_1_1TcpL4Protocol_a73a9498522829954684a7b4fabd6bf3e}{Receive} (packet, ipv6Header, fakeInterface));
453         \}
454 
455       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"TcpL4Protocol "} << \textcolor{keyword}{this} << \textcolor{stringliteral}{" received a packet but"}
456                     \textcolor{stringliteral}{" no endpoints matched."} <<
457                     \textcolor{stringliteral}{" destination IP: "} << incomingIpHeader.GetDestination () <<
458                     \textcolor{stringliteral}{" destination port: "}<< incomingTcpHeader.GetDestinationPort () <<
459                     \textcolor{stringliteral}{" source IP: "} << incomingIpHeader.GetSource () <<
460                     \textcolor{stringliteral}{" source port: "}<< incomingTcpHeader.GetSourcePort ());
461 
462       \hyperlink{classns3_1_1TcpL4Protocol_a16c65189190c60da860bc60681c01324}{NoEndPointsFound} (incomingTcpHeader, incomingIpHeader.GetSource (),
463                         incomingIpHeader.GetDestination ());
464 
465       \textcolor{keywordflow}{return} \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80eac7f4577d3ab1a219d6cb2b6964c49afd}{IpL4Protocol::RX\_ENDPOINT\_CLOSED};
466 
467     \}
468 
469   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (endPoints.size () == 1, \textcolor{stringliteral}{"Demux returned more than one endpoint"});
470   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"TcpL4Protocol "} << \textcolor{keyword}{this} << \textcolor{stringliteral}{" received a packet and"}
471                 \textcolor{stringliteral}{" now forwarding it up to endpoint/socket"});
472 
473   (*endPoints.begin ())->ForwardUp (packet, incomingIpHeader,
474                                     incomingTcpHeader.GetSourcePort (),
475                                     incomingInterface);
476 
477   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80eabd979bce2f3b22521c81c4115c66317e}{IpL4Protocol::RX\_OK};
478 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 22


\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Receive@{Receive}}
\index{Receive@{Receive}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Receive(\+Ptr$<$ Packet $>$ p, Ipv6\+Header const \&incoming\+Ip\+Header, Ptr$<$ Ipv6\+Interface $>$ incoming\+Interface)}{Receive(Ptr< Packet > p, Ipv6Header const &incomingIpHeader, Ptr< Ipv6Interface > incomingInterface)}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Ip\+L4\+Protocol\+::\+Rx\+Status} ns3\+::\+Tcp\+L4\+Protocol\+::\+Receive (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{{\bf Ipv6\+Header} const \&}]{header, }
\item[{{\bf Ptr}$<$ {\bf Ipv6\+Interface} $>$}]{incoming\+Interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TcpL4Protocol_a47f392dce81978c0c2f3e7b46d1a9024}{}\label{classns3_1_1TcpL4Protocol_a47f392dce81978c0c2f3e7b46d1a9024}


Called from lower-\/level layers to send the packet up in the stack. 


\begin{DoxyParams}{Parameters}
{\em p} & packet to forward up \\
\hline
{\em header} & I\+Pv6 \hyperlink{classns3_1_1Header}{Header} information \\
\hline
{\em incoming\+Interface} & the \hyperlink{classns3_1_1Ipv6Interface}{Ipv6\+Interface} on which the packet arrived \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Rx status code 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1IpL4Protocol_a1722da521b414c28875cb2a4f4aaf242}{ns3\+::\+Ip\+L4\+Protocol}.


\begin{DoxyCode}
484 \{
485   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << incomingIpHeader.GetSourceAddress () <<
486                    incomingIpHeader.GetDestinationAddress ());
487 
488   TcpHeader incomingTcpHeader;
489   \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80e}{IpL4Protocol::RxStatus} checksumControl;
490 
491   \textcolor{comment}{// If we are receving a v4-mapped packet, we will re-calculate the TCP checksum}
492   \textcolor{comment}{// Is it worth checking every received "v6" packet to see if it is v4-mapped in}
493   \textcolor{comment}{// order to avoid re-calculating TCP checksums for v4-mapped packets?}
494 
495   checksumControl = \hyperlink{classns3_1_1TcpL4Protocol_a3ff49ecbf02516282f7b8158819f432b}{PacketReceived} (packet, incomingTcpHeader,
496                                     incomingIpHeader.GetSourceAddress (),
497                                     incomingIpHeader.GetDestinationAddress ());
498 
499   \textcolor{keywordflow}{if} (checksumControl != \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80eabd979bce2f3b22521c81c4115c66317e}{IpL4Protocol::RX\_OK})
500     \{
501       \textcolor{keywordflow}{return} checksumControl;
502     \}
503 
504   \hyperlink{classns3_1_1Ipv6EndPointDemux_a40c1d59189759e1e7f5cabe7cd01c0fa}{Ipv6EndPointDemux::EndPoints} endPoints =
505     \hyperlink{classns3_1_1TcpL4Protocol_a88deacf73247133fccfe64179ad665e3}{m\_endPoints6}->\hyperlink{classns3_1_1Ipv6EndPointDemux_a14fd788471bcde832d3f125bdfabc24b}{Lookup} (incomingIpHeader.GetDestinationAddress (),
506                           incomingTcpHeader.GetDestinationPort (),
507                           incomingIpHeader.GetSourceAddress (),
508                           incomingTcpHeader.GetSourcePort (), interface);
509   \textcolor{keywordflow}{if} (endPoints.empty ())
510     \{
511       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"TcpL4Protocol "} << \textcolor{keyword}{this} << \textcolor{stringliteral}{" received a packet but"}
512                     \textcolor{stringliteral}{" no endpoints matched."} <<
513                     \textcolor{stringliteral}{" destination IP: "} << incomingIpHeader.GetDestinationAddress () <<
514                     \textcolor{stringliteral}{" destination port: "}<< incomingTcpHeader.GetDestinationPort () <<
515                     \textcolor{stringliteral}{" source IP: "} << incomingIpHeader.GetSourceAddress () <<
516                     \textcolor{stringliteral}{" source port: "}<< incomingTcpHeader.GetSourcePort ());
517 
518       \hyperlink{classns3_1_1TcpL4Protocol_a16c65189190c60da860bc60681c01324}{NoEndPointsFound} (incomingTcpHeader, incomingIpHeader.GetSourceAddress (),
519                         incomingIpHeader.GetDestinationAddress ());
520 
521       \textcolor{keywordflow}{return} \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80eac7f4577d3ab1a219d6cb2b6964c49afd}{IpL4Protocol::RX\_ENDPOINT\_CLOSED};
522     \}
523 
524   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (endPoints.size () == 1, \textcolor{stringliteral}{"Demux returned more than one endpoint"});
525   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"TcpL4Protocol "} << \textcolor{keyword}{this} << \textcolor{stringliteral}{" received a packet and"}
526                 \textcolor{stringliteral}{" now forwarding it up to endpoint/socket"});
527 
528   (*endPoints.begin ())->ForwardUp (packet, incomingIpHeader,
529                                     incomingTcpHeader.GetSourcePort (), interface);
530 
531   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80eabd979bce2f3b22521c81c4115c66317e}{IpL4Protocol::RX\_OK};
532 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 23


\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Receive\+Icmp@{Receive\+Icmp}}
\index{Receive\+Icmp@{Receive\+Icmp}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Receive\+Icmp(\+Ipv4\+Address icmp\+Source, uint8\+\_\+t icmp\+Ttl, uint8\+\_\+t icmp\+Type, uint8\+\_\+t icmp\+Code, uint32\+\_\+t icmp\+Info, Ipv4\+Address payload\+Source, Ipv4\+Address payload\+Destination, const uint8\+\_\+t payload[8])}{ReceiveIcmp(Ipv4Address icmpSource, uint8_t icmpTtl, uint8_t icmpType, uint8_t icmpCode, uint32_t icmpInfo, Ipv4Address payloadSource, Ipv4Address payloadDestination, const uint8_t payload[8])}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+L4\+Protocol\+::\+Receive\+Icmp (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{icmp\+Source, }
\item[{uint8\+\_\+t}]{icmp\+Ttl, }
\item[{uint8\+\_\+t}]{icmp\+Type, }
\item[{uint8\+\_\+t}]{icmp\+Code, }
\item[{uint32\+\_\+t}]{icmp\+Info, }
\item[{{\bf Ipv4\+Address}}]{payload\+Source, }
\item[{{\bf Ipv4\+Address}}]{payload\+Destination, }
\item[{const uint8\+\_\+t}]{payload\mbox{[}8\mbox{]}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TcpL4Protocol_aa78a842105c7a60f09eda4a0980c7458}{}\label{classns3_1_1TcpL4Protocol_aa78a842105c7a60f09eda4a0980c7458}


Called from lower-\/level layers to send the I\+C\+MP packet up in the stack. 


\begin{DoxyParams}{Parameters}
{\em icmp\+Source} & the source address of the icmp message \\
\hline
{\em icmp\+Ttl} & the ttl of the icmp message \\
\hline
{\em icmp\+Type} & the \textquotesingle{}type\textquotesingle{} field of the icmp message \\
\hline
{\em icmp\+Code} & the \textquotesingle{}code\textquotesingle{} field of the icmp message \\
\hline
{\em icmp\+Info} & extra information dependent on the icmp message generated by \hyperlink{classns3_1_1Icmpv4L4Protocol}{Icmpv4\+L4\+Protocol} \\
\hline
{\em payload\+Source} & the source address of the packet which triggered the icmp message \\
\hline
{\em payload\+Destination} & the destination address of the packet which triggered the icmp message. \\
\hline
{\em payload} & the first 8 bytes of the packet payload which triggered the icmp message. \\
\hline
\end{DoxyParams}


Reimplemented from \hyperlink{classns3_1_1IpL4Protocol_a4859731c656d5309c07d2d47bacd4121}{ns3\+::\+Ip\+L4\+Protocol}.


\begin{DoxyCode}
298 \{
299   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << icmpSource << (uint16\_t) icmpTtl << (uint16\_t) icmpType << (
      uint16\_t) icmpCode << icmpInfo
300                         << payloadSource << payloadDestination);
301   uint16\_t src, dst;
302   src = payload[0] << 8;
303   src |= payload[1];
304   dst = payload[2] << 8;
305   dst |= payload[3];
306 
307   Ipv4EndPoint *endPoint = \hyperlink{classns3_1_1TcpL4Protocol_a7ca53708bd7d91191af64a290095ebe7}{m\_endPoints}->\hyperlink{classns3_1_1Ipv4EndPointDemux_a524bb724e8bbd40648172938758860ec}{SimpleLookup} (payloadSource, src, 
      payloadDestination, dst);
308   \textcolor{keywordflow}{if} (endPoint != 0)
309     \{
310       endPoint->\hyperlink{classns3_1_1Ipv4EndPoint_a53cc03159a64a6aa2eed49382dc42381}{ForwardIcmp} (icmpSource, icmpTtl, icmpType, icmpCode, icmpInfo);
311     \}
312   \textcolor{keywordflow}{else}
313     \{
314       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"no endpoint found source="} << payloadSource <<
315                     \textcolor{stringliteral}{", destination="} << payloadDestination <<
316                     \textcolor{stringliteral}{", src="} << src << \textcolor{stringliteral}{", dst="} << dst);
317     \}
318 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 24


\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Receive\+Icmp@{Receive\+Icmp}}
\index{Receive\+Icmp@{Receive\+Icmp}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Receive\+Icmp(\+Ipv6\+Address icmp\+Source, uint8\+\_\+t icmp\+Ttl, uint8\+\_\+t icmp\+Type, uint8\+\_\+t icmp\+Code, uint32\+\_\+t icmp\+Info, Ipv6\+Address payload\+Source, Ipv6\+Address payload\+Destination, const uint8\+\_\+t payload[8])}{ReceiveIcmp(Ipv6Address icmpSource, uint8_t icmpTtl, uint8_t icmpType, uint8_t icmpCode, uint32_t icmpInfo, Ipv6Address payloadSource, Ipv6Address payloadDestination, const uint8_t payload[8])}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+L4\+Protocol\+::\+Receive\+Icmp (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{icmp\+Source, }
\item[{uint8\+\_\+t}]{icmp\+Ttl, }
\item[{uint8\+\_\+t}]{icmp\+Type, }
\item[{uint8\+\_\+t}]{icmp\+Code, }
\item[{uint32\+\_\+t}]{icmp\+Info, }
\item[{{\bf Ipv6\+Address}}]{payload\+Source, }
\item[{{\bf Ipv6\+Address}}]{payload\+Destination, }
\item[{const uint8\+\_\+t}]{payload\mbox{[}8\mbox{]}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TcpL4Protocol_a8643c5c8926d6e21dfaabf472b5652d3}{}\label{classns3_1_1TcpL4Protocol_a8643c5c8926d6e21dfaabf472b5652d3}


Called from lower-\/level layers to send the I\+C\+M\+Pv6 packet up in the stack. 


\begin{DoxyParams}{Parameters}
{\em icmp\+Source} & the source address of the icmp message \\
\hline
{\em icmp\+Ttl} & the ttl of the icmp message \\
\hline
{\em icmp\+Type} & the \textquotesingle{}type\textquotesingle{} field of the icmp message \\
\hline
{\em icmp\+Code} & the \textquotesingle{}code\textquotesingle{} field of the icmp message \\
\hline
{\em icmp\+Info} & extra information dependent on the icmp message generated by \hyperlink{classns3_1_1Icmpv6L4Protocol}{Icmpv6\+L4\+Protocol} \\
\hline
{\em payload\+Source} & the source address of the packet which triggered the icmp message \\
\hline
{\em payload\+Destination} & the destination address of the packet which triggered the icmp message. \\
\hline
{\em payload} & the first 8 bytes of the packet payload which triggered the icmp message. \\
\hline
\end{DoxyParams}


Reimplemented from \hyperlink{classns3_1_1IpL4Protocol_a8f5ccf55cde8c20f9b73f9181eae6f80}{ns3\+::\+Ip\+L4\+Protocol}.


\begin{DoxyCode}
325 \{
326   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << icmpSource << (uint16\_t) icmpTtl << (uint16\_t) icmpType << (
      uint16\_t) icmpCode << icmpInfo
327                         << payloadSource << payloadDestination);
328   uint16\_t src, dst;
329   src = payload[0] << 8;
330   src |= payload[1];
331   dst = payload[2] << 8;
332   dst |= payload[3];
333 
334   Ipv6EndPoint *endPoint = \hyperlink{classns3_1_1TcpL4Protocol_a88deacf73247133fccfe64179ad665e3}{m\_endPoints6}->\hyperlink{classns3_1_1Ipv6EndPointDemux_aa6fa6603f213bd48e6b03e68d6cef80b}{SimpleLookup} (payloadSource, src, 
      payloadDestination, dst);
335   \textcolor{keywordflow}{if} (endPoint != 0)
336     \{
337       endPoint->\hyperlink{classns3_1_1Ipv6EndPoint_ac5995f5c6c1f15fc8ef7d8daf76167ad}{ForwardIcmp} (icmpSource, icmpTtl, icmpType, icmpCode, icmpInfo);
338     \}
339   \textcolor{keywordflow}{else}
340     \{
341       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"no endpoint found source="} << payloadSource <<
342                     \textcolor{stringliteral}{", destination="} << payloadDestination <<
343                     \textcolor{stringliteral}{", src="} << src << \textcolor{stringliteral}{", dst="} << dst);
344     \}
345 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 25


\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Remove\+Socket@{Remove\+Socket}}
\index{Remove\+Socket@{Remove\+Socket}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Remove\+Socket(\+Ptr$<$ Tcp\+Socket\+Base $>$ socket)}{RemoveSocket(Ptr< TcpSocketBase > socket)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Tcp\+L4\+Protocol\+::\+Remove\+Socket (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Tcp\+Socket\+Base} $>$}]{socket}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpL4Protocol_a1d5f0e4067f225e35e0b73ad2e80c5a9}{}\label{classns3_1_1TcpL4Protocol_a1d5f0e4067f225e35e0b73ad2e80c5a9}


Remove a socket from the internal list. 


\begin{DoxyParams}{Parameters}
{\em socket} & socket to Remove \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the socket has been removed 
\end{DoxyReturn}

\begin{DoxyCode}
706 \{
707   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << socket);
708   std::vector<Ptr<TcpSocketBase> >::iterator it = \hyperlink{classns3_1_1TcpL4Protocol_a7f0bde5144a1bb7594e4cf366669bcbc}{m\_sockets}.begin ();
709 
710   \textcolor{keywordflow}{while} (it != \hyperlink{classns3_1_1TcpL4Protocol_a7f0bde5144a1bb7594e4cf366669bcbc}{m\_sockets}.end ())
711     \{
712       \textcolor{keywordflow}{if} (*it == socket)
713         \{
714           \hyperlink{classns3_1_1TcpL4Protocol_a7f0bde5144a1bb7594e4cf366669bcbc}{m\_sockets}.erase (it);
715           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
716         \}
717 
718       ++it;
719     \}
720 
721   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
722 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Send\+Packet@{Send\+Packet}}
\index{Send\+Packet@{Send\+Packet}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Packet(\+Ptr$<$ Packet $>$ pkt, const Tcp\+Header \&outgoing, const Address \&saddr, const Address \&daddr, Ptr$<$ Net\+Device $>$ oif=0) const }{SendPacket(Ptr< Packet > pkt, const TcpHeader &outgoing, const Address &saddr, const Address &daddr, Ptr< NetDevice > oif=0) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+L4\+Protocol\+::\+Send\+Packet (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{pkt, }
\item[{const {\bf Tcp\+Header} \&}]{outgoing, }
\item[{const {\bf Address} \&}]{saddr, }
\item[{const {\bf Address} \&}]{daddr, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{oif = {\ttfamily 0}}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1TcpL4Protocol_a622217854cad6fdfd562f42a6731ba6c}{}\label{classns3_1_1TcpL4Protocol_a622217854cad6fdfd562f42a6731ba6c}


Send a packet via T\+CP (I\+P-\/agnostic) 


\begin{DoxyParams}{Parameters}
{\em pkt} & The packet to send \\
\hline
{\em outgoing} & The packet header \\
\hline
{\em saddr} & The source \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \\
\hline
{\em daddr} & The destination \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \\
\hline
{\em oif} & The output interface bound. Defaults to null (unspecified). \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
643 \{
644   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << pkt << outgoing << saddr << daddr << oif);
645   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4Address_a7129db5e08739783b300976d28c0ced3}{Ipv4Address::IsMatchingType} (saddr))
646     \{
647       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1Ipv4Address_a7129db5e08739783b300976d28c0ced3}{Ipv4Address::IsMatchingType} (daddr));
648 
649       \hyperlink{classns3_1_1TcpL4Protocol_ae57806dce4847383a27e329656e77e14}{SendPacketV4} (pkt, outgoing, \hyperlink{classns3_1_1Ipv4Address_a5fd4a8f0f7bb75e35dad3d401ef4cbc1}{Ipv4Address::ConvertFrom} (saddr),
650                     \hyperlink{classns3_1_1Ipv4Address_a5fd4a8f0f7bb75e35dad3d401ef4cbc1}{Ipv4Address::ConvertFrom} (daddr), oif);
651 
652       \textcolor{keywordflow}{return};
653     \}
654   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6Address_adbe329370b5a8f7c0f48659d6439dfd1}{Ipv6Address::IsMatchingType} (saddr))
655     \{
656       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1Ipv6Address_adbe329370b5a8f7c0f48659d6439dfd1}{Ipv6Address::IsMatchingType} (daddr));
657 
658       \hyperlink{classns3_1_1TcpL4Protocol_a12831eb88c02c37b3cf42cdda814cd19}{SendPacketV6} (pkt, outgoing, \hyperlink{classns3_1_1Ipv6Address_ac00bc221a0b226b2090d05468aec4b79}{Ipv6Address::ConvertFrom} (saddr),
659                     \hyperlink{classns3_1_1Ipv6Address_ac00bc221a0b226b2090d05468aec4b79}{Ipv6Address::ConvertFrom} (daddr), oif);
660 
661       \textcolor{keywordflow}{return};
662     \}
663   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1InetSocketAddress_a9426766e34e928ce5dbdbeb9563a10df}{InetSocketAddress::IsMatchingType} (saddr))
664     \{
665       InetSocketAddress \hyperlink{generate__test__data__lte__sinr_8m_ad83eeb3a142285d1243a08c6b7026df8}{s} = \hyperlink{classns3_1_1InetSocketAddress_ade776b1109e7b9a7be0b22ced49931e3}{InetSocketAddress::ConvertFrom} (saddr);
666       InetSocketAddress \hyperlink{buildings__pathloss_8m_a9f9b934daed17a4d3613b6886ff4cf4b}{d} = \hyperlink{classns3_1_1InetSocketAddress_ade776b1109e7b9a7be0b22ced49931e3}{InetSocketAddress::ConvertFrom} (daddr);
667 
668       \hyperlink{classns3_1_1TcpL4Protocol_ae57806dce4847383a27e329656e77e14}{SendPacketV4} (pkt, outgoing, s.GetIpv4 (), d.GetIpv4 (), oif);
669 
670       \textcolor{keywordflow}{return};
671     \}
672   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Inet6SocketAddress_a4d928c54affbfb530a12076d6d7e0540}{Inet6SocketAddress::IsMatchingType} (saddr))
673     \{
674       Inet6SocketAddress s = \hyperlink{classns3_1_1Inet6SocketAddress_a2177c66e1bcf17c85dcffb9d2a971f5a}{Inet6SocketAddress::ConvertFrom} (saddr);
675       Inet6SocketAddress d = \hyperlink{classns3_1_1Inet6SocketAddress_a2177c66e1bcf17c85dcffb9d2a971f5a}{Inet6SocketAddress::ConvertFrom} (daddr);
676 
677       \hyperlink{classns3_1_1TcpL4Protocol_a12831eb88c02c37b3cf42cdda814cd19}{SendPacketV6} (pkt, outgoing, s.GetIpv6 (), d.GetIpv6 (), oif);
678 
679       \textcolor{keywordflow}{return};
680     \}
681 
682   \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Trying to send a packet without IP addresses"});
683 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 26




Here is the caller graph for this function\+:
% FIG 27


\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Send\+Packet\+V4@{Send\+Packet\+V4}}
\index{Send\+Packet\+V4@{Send\+Packet\+V4}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Packet\+V4(\+Ptr$<$ Packet $>$ pkt, const Tcp\+Header \&outgoing, const Ipv4\+Address \&saddr, const Ipv4\+Address \&daddr, Ptr$<$ Net\+Device $>$ oif=0) const }{SendPacketV4(Ptr< Packet > pkt, const TcpHeader &outgoing, const Ipv4Address &saddr, const Ipv4Address &daddr, Ptr< NetDevice > oif=0) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+L4\+Protocol\+::\+Send\+Packet\+V4 (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{pkt, }
\item[{const {\bf Tcp\+Header} \&}]{outgoing, }
\item[{const {\bf Ipv4\+Address} \&}]{saddr, }
\item[{const {\bf Ipv4\+Address} \&}]{daddr, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{oif = {\ttfamily 0}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpL4Protocol_ae57806dce4847383a27e329656e77e14}{}\label{classns3_1_1TcpL4Protocol_ae57806dce4847383a27e329656e77e14}


Send a packet via T\+CP (I\+Pv4) 


\begin{DoxyParams}{Parameters}
{\em pkt} & The packet to send \\
\hline
{\em outgoing} & The packet header \\
\hline
{\em saddr} & The source \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \\
\hline
{\em daddr} & The destination \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \\
\hline
{\em oif} & The output interface bound. Defaults to null (unspecified). \\
\hline
\end{DoxyParams}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000064}{Todo}]Urgent\+Pointer \end{DoxyRefDesc}

\begin{DoxyCode}
538 \{
539   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << saddr << daddr << oif);
540   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"TcpL4Protocol "} << \textcolor{keyword}{this}
541                                  << \textcolor{stringliteral}{" sending seq "} << outgoing.GetSequenceNumber ()
542                                  << \textcolor{stringliteral}{" ack "} << outgoing.GetAckNumber ()
543                                  << \textcolor{stringliteral}{" flags "} << \hyperlink{classns3_1_1TcpHeader_aaaa261ca12b0fb50e45c7083cec88cff}{TcpHeader::FlagsToString} (outgoing
      .GetFlags ())
544                                  << \textcolor{stringliteral}{" data size "} << packet->GetSize ());
545   \textcolor{comment}{// XXX outgoingHeader cannot be logged}
546 
547   TcpHeader outgoingHeader = outgoing;
549   \textcolor{comment}{/* outgoingHeader.SetUrgentPointer (0); */}
550   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Node_a0515bfe9a3aeb6605d657ba855699815}{Node::ChecksumEnabled} ())
551     \{
552       outgoingHeader.EnableChecksums ();
553     \}
554   outgoingHeader.InitializeChecksum (saddr, daddr, \hyperlink{classns3_1_1TcpL4Protocol_ac6c1cee44ae21227e755678bb52dbc89}{PROT\_NUMBER});
555 
556   packet->AddHeader (outgoingHeader);
557 
558   Ptr<Ipv4> ipv4 =
559     \hyperlink{classns3_1_1TcpL4Protocol_a89e39fd5367f8ce22565f69e224de189}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv4> ();
560   \textcolor{keywordflow}{if} (ipv4 != 0)
561     \{
562       Ipv4Header header;
563       header.SetSource (saddr);
564       header.SetDestination (daddr);
565       header.SetProtocol (\hyperlink{classns3_1_1TcpL4Protocol_ac6c1cee44ae21227e755678bb52dbc89}{PROT\_NUMBER});
566       \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket::SocketErrno} errno\_;
567       Ptr<Ipv4Route> route;
568       \textcolor{keywordflow}{if} (ipv4->GetRoutingProtocol () != 0)
569         \{
570           route = ipv4->GetRoutingProtocol ()->RouteOutput (packet, header, oif, errno\_);
571         \}
572       \textcolor{keywordflow}{else}
573         \{
574           \hyperlink{group__logging_ga0261a8db1d4ac5f79417d117634fd455}{NS\_LOG\_ERROR} (\textcolor{stringliteral}{"No IPV4 Routing Protocol"});
575           route = 0;
576         \}
577       \hyperlink{classns3_1_1TcpL4Protocol_a6624133b0d5072cacbd77c9dc90aee75}{m\_downTarget} (packet, saddr, daddr, \hyperlink{classns3_1_1TcpL4Protocol_ac6c1cee44ae21227e755678bb52dbc89}{PROT\_NUMBER}, route);
578     \}
579   \textcolor{keywordflow}{else}
580     \{
581       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Trying to use Tcp on a node without an Ipv4 interface"});
582     \}
583 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 28




Here is the caller graph for this function\+:
% FIG 29


\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Send\+Packet\+V6@{Send\+Packet\+V6}}
\index{Send\+Packet\+V6@{Send\+Packet\+V6}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Packet\+V6(\+Ptr$<$ Packet $>$ pkt, const Tcp\+Header \&outgoing, const Ipv6\+Address \&saddr, const Ipv6\+Address \&daddr, Ptr$<$ Net\+Device $>$ oif=0) const }{SendPacketV6(Ptr< Packet > pkt, const TcpHeader &outgoing, const Ipv6Address &saddr, const Ipv6Address &daddr, Ptr< NetDevice > oif=0) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+L4\+Protocol\+::\+Send\+Packet\+V6 (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{pkt, }
\item[{const {\bf Tcp\+Header} \&}]{outgoing, }
\item[{const {\bf Ipv6\+Address} \&}]{saddr, }
\item[{const {\bf Ipv6\+Address} \&}]{daddr, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{oif = {\ttfamily 0}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpL4Protocol_a12831eb88c02c37b3cf42cdda814cd19}{}\label{classns3_1_1TcpL4Protocol_a12831eb88c02c37b3cf42cdda814cd19}


Send a packet via T\+CP (I\+Pv6) 


\begin{DoxyParams}{Parameters}
{\em pkt} & The packet to send \\
\hline
{\em outgoing} & The packet header \\
\hline
{\em saddr} & The source \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \\
\hline
{\em daddr} & The destination \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \\
\hline
{\em oif} & The output interface bound. Defaults to null (unspecified). \\
\hline
\end{DoxyParams}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000065}{Todo}]Urgent\+Pointer \end{DoxyRefDesc}

\begin{DoxyCode}
589 \{
590   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << saddr << daddr << oif);
591   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"TcpL4Protocol "} << \textcolor{keyword}{this}
592                                  << \textcolor{stringliteral}{" sending seq "} << outgoing.GetSequenceNumber ()
593                                  << \textcolor{stringliteral}{" ack "} << outgoing.GetAckNumber ()
594                                  << \textcolor{stringliteral}{" flags "} << \hyperlink{classns3_1_1TcpHeader_aaaa261ca12b0fb50e45c7083cec88cff}{TcpHeader::FlagsToString} (outgoing
      .GetFlags ())
595                                  << \textcolor{stringliteral}{" data size "} << packet->GetSize ());
596   \textcolor{comment}{// XXX outgoingHeader cannot be logged}
597 
598   \textcolor{keywordflow}{if} (daddr.IsIpv4MappedAddress ())
599     \{
600       \textcolor{keywordflow}{return} (\hyperlink{classns3_1_1TcpL4Protocol_a622217854cad6fdfd562f42a6731ba6c}{SendPacket} (packet, outgoing, saddr.GetIpv4MappedAddress (), daddr.
      GetIpv4MappedAddress (), oif));
601     \}
602   TcpHeader outgoingHeader = outgoing;
604   \textcolor{comment}{/* outgoingHeader.SetUrgentPointer (0); */}
605   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Node_a0515bfe9a3aeb6605d657ba855699815}{Node::ChecksumEnabled} ())
606     \{
607       outgoingHeader.EnableChecksums ();
608     \}
609   outgoingHeader.InitializeChecksum (saddr, daddr, \hyperlink{classns3_1_1TcpL4Protocol_ac6c1cee44ae21227e755678bb52dbc89}{PROT\_NUMBER});
610 
611   packet->AddHeader (outgoingHeader);
612 
613   Ptr<Ipv6L3Protocol> ipv6 = \hyperlink{classns3_1_1TcpL4Protocol_a89e39fd5367f8ce22565f69e224de189}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv6L3Protocol> ();
614   \textcolor{keywordflow}{if} (ipv6 != 0)
615     \{
616       Ipv6Header header;
617       header.SetSourceAddress (saddr);
618       header.SetDestinationAddress (daddr);
619       header.SetNextHeader (\hyperlink{classns3_1_1TcpL4Protocol_ac6c1cee44ae21227e755678bb52dbc89}{PROT\_NUMBER});
620       \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket::SocketErrno} errno\_;
621       Ptr<Ipv6Route> route;
622       \textcolor{keywordflow}{if} (ipv6->GetRoutingProtocol () != 0)
623         \{
624           route = ipv6->GetRoutingProtocol ()->RouteOutput (packet, header, oif, errno\_);
625         \}
626       \textcolor{keywordflow}{else}
627         \{
628           \hyperlink{group__logging_ga0261a8db1d4ac5f79417d117634fd455}{NS\_LOG\_ERROR} (\textcolor{stringliteral}{"No IPV6 Routing Protocol"});
629           route = 0;
630         \}
631       \hyperlink{classns3_1_1TcpL4Protocol_ae4447ef1e9b58f1352b819a9c6fff496}{m\_downTarget6} (packet, saddr, daddr, \hyperlink{classns3_1_1TcpL4Protocol_ac6c1cee44ae21227e755678bb52dbc89}{PROT\_NUMBER}, route);
632     \}
633   \textcolor{keywordflow}{else}
634     \{
635       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Trying to use Tcp on a node without an Ipv6 interface"});
636     \}
637 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 30




Here is the caller graph for this function\+:
% FIG 31


\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Set\+Down\+Target@{Set\+Down\+Target}}
\index{Set\+Down\+Target@{Set\+Down\+Target}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Down\+Target(\+Ip\+L4\+Protocol\+::\+Down\+Target\+Callback cb)}{SetDownTarget(IpL4Protocol::DownTargetCallback cb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+L4\+Protocol\+::\+Set\+Down\+Target (
\begin{DoxyParamCaption}
\item[{{\bf Ip\+L4\+Protocol\+::\+Down\+Target\+Callback}}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TcpL4Protocol_aa29220d10741bf33a6d95ce9a985971f}{}\label{classns3_1_1TcpL4Protocol_aa29220d10741bf33a6d95ce9a985971f}
This method allows a caller to set the current down target callback set for this L4 protocol (I\+Pv4 case)


\begin{DoxyParams}{Parameters}
{\em cb} & current \hyperlink{classns3_1_1Callback}{Callback} for the L4 protocol \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1IpL4Protocol_a9fc5e8e30a16bdc87623fa2ebc981af3}{ns3\+::\+Ip\+L4\+Protocol}.


\begin{DoxyCode}
726 \{
727   \hyperlink{classns3_1_1TcpL4Protocol_a6624133b0d5072cacbd77c9dc90aee75}{m\_downTarget} = callback;
728 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 32


\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Set\+Down\+Target6@{Set\+Down\+Target6}}
\index{Set\+Down\+Target6@{Set\+Down\+Target6}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Down\+Target6(\+Ip\+L4\+Protocol\+::\+Down\+Target\+Callback6 cb)}{SetDownTarget6(IpL4Protocol::DownTargetCallback6 cb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+L4\+Protocol\+::\+Set\+Down\+Target6 (
\begin{DoxyParamCaption}
\item[{{\bf Ip\+L4\+Protocol\+::\+Down\+Target\+Callback6}}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TcpL4Protocol_ae35e768fcbb81c201c695ba4fbbeab1d}{}\label{classns3_1_1TcpL4Protocol_ae35e768fcbb81c201c695ba4fbbeab1d}
This method allows a caller to set the current down target callback set for this L4 protocol (I\+Pv6 case)


\begin{DoxyParams}{Parameters}
{\em cb} & current \hyperlink{classns3_1_1Callback}{Callback} for the L4 protocol \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1IpL4Protocol_a2c3427eada095f3ae9a5e78fe6523e1e}{ns3\+::\+Ip\+L4\+Protocol}.


\begin{DoxyCode}
738 \{
739   \hyperlink{classns3_1_1TcpL4Protocol_ae4447ef1e9b58f1352b819a9c6fff496}{m\_downTarget6} = callback;
740 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 33


\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!Set\+Node@{Set\+Node}}
\index{Set\+Node@{Set\+Node}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Node(\+Ptr$<$ Node $>$ node)}{SetNode(Ptr< Node > node)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+L4\+Protocol\+::\+Set\+Node (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpL4Protocol_a092de53315ed89dfa2080ef0d92ccd56}{}\label{classns3_1_1TcpL4Protocol_a092de53315ed89dfa2080ef0d92ccd56}
Set node associated with this stack 
\begin{DoxyParams}{Parameters}
{\em node} & the node \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
105 \{
106   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
107   \hyperlink{classns3_1_1TcpL4Protocol_a89e39fd5367f8ce22565f69e224de189}{m\_node} = node;
108 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 34




\subsection{Member Data Documentation}
\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!m\+\_\+congestion\+Type\+Id@{m\+\_\+congestion\+Type\+Id}}
\index{m\+\_\+congestion\+Type\+Id@{m\+\_\+congestion\+Type\+Id}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+congestion\+Type\+Id}{m_congestionTypeId}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Tcp\+L4\+Protocol\+::m\+\_\+congestion\+Type\+Id\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpL4Protocol_a2c724fd042748420d8a8df49e7ef28d7}{}\label{classns3_1_1TcpL4Protocol_a2c724fd042748420d8a8df49e7ef28d7}


The socket \hyperlink{classns3_1_1TypeId}{Type\+Id}. 

\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!m\+\_\+down\+Target@{m\+\_\+down\+Target}}
\index{m\+\_\+down\+Target@{m\+\_\+down\+Target}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+down\+Target}{m_downTarget}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ip\+L4\+Protocol\+::\+Down\+Target\+Callback} ns3\+::\+Tcp\+L4\+Protocol\+::m\+\_\+down\+Target\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpL4Protocol_a6624133b0d5072cacbd77c9dc90aee75}{}\label{classns3_1_1TcpL4Protocol_a6624133b0d5072cacbd77c9dc90aee75}


\hyperlink{classns3_1_1Callback}{Callback} to send packets over I\+Pv4. 

\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!m\+\_\+down\+Target6@{m\+\_\+down\+Target6}}
\index{m\+\_\+down\+Target6@{m\+\_\+down\+Target6}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+down\+Target6}{m_downTarget6}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ip\+L4\+Protocol\+::\+Down\+Target\+Callback6} ns3\+::\+Tcp\+L4\+Protocol\+::m\+\_\+down\+Target6\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpL4Protocol_ae4447ef1e9b58f1352b819a9c6fff496}{}\label{classns3_1_1TcpL4Protocol_ae4447ef1e9b58f1352b819a9c6fff496}


\hyperlink{classns3_1_1Callback}{Callback} to send packets over I\+Pv6. 

\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!m\+\_\+end\+Points@{m\+\_\+end\+Points}}
\index{m\+\_\+end\+Points@{m\+\_\+end\+Points}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+end\+Points}{m_endPoints}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+End\+Point\+Demux}$\ast$ ns3\+::\+Tcp\+L4\+Protocol\+::m\+\_\+end\+Points\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpL4Protocol_a7ca53708bd7d91191af64a290095ebe7}{}\label{classns3_1_1TcpL4Protocol_a7ca53708bd7d91191af64a290095ebe7}


A list of I\+Pv4 end points. 

\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!m\+\_\+end\+Points6@{m\+\_\+end\+Points6}}
\index{m\+\_\+end\+Points6@{m\+\_\+end\+Points6}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+end\+Points6}{m_endPoints6}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+End\+Point\+Demux}$\ast$ ns3\+::\+Tcp\+L4\+Protocol\+::m\+\_\+end\+Points6\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpL4Protocol_a88deacf73247133fccfe64179ad665e3}{}\label{classns3_1_1TcpL4Protocol_a88deacf73247133fccfe64179ad665e3}


A list of I\+Pv6 end points. 

\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!m\+\_\+node@{m\+\_\+node}}
\index{m\+\_\+node@{m\+\_\+node}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+node}{m_node}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Node}$>$ ns3\+::\+Tcp\+L4\+Protocol\+::m\+\_\+node\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpL4Protocol_a89e39fd5367f8ce22565f69e224de189}{}\label{classns3_1_1TcpL4Protocol_a89e39fd5367f8ce22565f69e224de189}


the node this stack is associated with 

\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!m\+\_\+rtt\+Type\+Id@{m\+\_\+rtt\+Type\+Id}}
\index{m\+\_\+rtt\+Type\+Id@{m\+\_\+rtt\+Type\+Id}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+rtt\+Type\+Id}{m_rttTypeId}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Tcp\+L4\+Protocol\+::m\+\_\+rtt\+Type\+Id\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpL4Protocol_aff3e46318717dcbce5f222e94b8345cd}{}\label{classns3_1_1TcpL4Protocol_aff3e46318717dcbce5f222e94b8345cd}


The R\+TT Estimator \hyperlink{classns3_1_1TypeId}{Type\+Id}. 

\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!m\+\_\+sockets@{m\+\_\+sockets}}
\index{m\+\_\+sockets@{m\+\_\+sockets}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+sockets}{m_sockets}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<${\bf Ptr}$<${\bf Tcp\+Socket\+Base}$>$ $>$ ns3\+::\+Tcp\+L4\+Protocol\+::m\+\_\+sockets\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpL4Protocol_a7f0bde5144a1bb7594e4cf366669bcbc}{}\label{classns3_1_1TcpL4Protocol_a7f0bde5144a1bb7594e4cf366669bcbc}


list of sockets 

\index{ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}!P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER@{P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER}}
\index{P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER@{P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER}!ns3\+::\+Tcp\+L4\+Protocol@{ns3\+::\+Tcp\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER}{PROT_NUMBER}}]{\setlength{\rightskip}{0pt plus 5cm}const uint8\+\_\+t ns3\+::\+Tcp\+L4\+Protocol\+::\+P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER = 6\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1TcpL4Protocol_ac6c1cee44ae21227e755678bb52dbc89}{}\label{classns3_1_1TcpL4Protocol_ac6c1cee44ae21227e755678bb52dbc89}


protocol number (0x6) 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/model/\hyperlink{tcp-l4-protocol_8h}{tcp-\/l4-\/protocol.\+h}\item 
internet/model/\hyperlink{tcp-l4-protocol_8cc}{tcp-\/l4-\/protocol.\+cc}\end{DoxyCompactItemize}
