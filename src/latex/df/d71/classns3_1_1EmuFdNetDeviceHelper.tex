\hypertarget{classns3_1_1EmuFdNetDeviceHelper}{}\section{ns3\+:\+:Emu\+Fd\+Net\+Device\+Helper Class Reference}
\label{classns3_1_1EmuFdNetDeviceHelper}\index{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper@{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper}}


build a set of \hyperlink{classns3_1_1FdNetDevice}{Fd\+Net\+Device} objects attached to a physical network interface  




{\ttfamily \#include $<$emu-\/fd-\/net-\/device-\/helper.\+h$>$}



Inheritance diagram for ns3\+:\+:Emu\+Fd\+Net\+Device\+Helper\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Emu\+Fd\+Net\+Device\+Helper\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1EmuFdNetDeviceHelper_ae4f56369d0efcfe57883ccb2fac50505}{Emu\+Fd\+Net\+Device\+Helper} ()
\item 
virtual \hyperlink{classns3_1_1EmuFdNetDeviceHelper_a0599b6cc5450eb0d950da3bcfabdce4d}{$\sim$\+Emu\+Fd\+Net\+Device\+Helper} ()
\item 
std\+::string \hyperlink{classns3_1_1EmuFdNetDeviceHelper_a12d7886e84be06c4c5021ad92584bb2b}{Get\+Device\+Name} (void)
\item 
void \hyperlink{classns3_1_1EmuFdNetDeviceHelper_aa5c26a78442e507ba969f28ffa5f748e}{Set\+Device\+Name} (std\+::string device\+Name)
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ \hyperlink{classns3_1_1EmuFdNetDeviceHelper_a80562da33cef1c20d4b03b351fbbc21a}{Install\+Priv} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node) const 
\item 
virtual void \hyperlink{classns3_1_1EmuFdNetDeviceHelper_ad48e0e01cd07bd76bdc6bf05ed4fa756}{Set\+File\+Descriptor} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1FdNetDevice}{Fd\+Net\+Device} $>$ device) const 
\item 
virtual int \hyperlink{classns3_1_1EmuFdNetDeviceHelper_a64392b0acfeddf0121b251bc7e6e8906}{Create\+File\+Descriptor} (void) const 
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::string \hyperlink{classns3_1_1EmuFdNetDeviceHelper_a5c259590827f139ae1189a99addeca6a}{m\+\_\+device\+Name}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
build a set of \hyperlink{classns3_1_1FdNetDevice}{Fd\+Net\+Device} objects attached to a physical network interface 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper@{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper}!Emu\+Fd\+Net\+Device\+Helper@{Emu\+Fd\+Net\+Device\+Helper}}
\index{Emu\+Fd\+Net\+Device\+Helper@{Emu\+Fd\+Net\+Device\+Helper}!ns3\+::\+Emu\+Fd\+Net\+Device\+Helper@{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{Emu\+Fd\+Net\+Device\+Helper()}{EmuFdNetDeviceHelper()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Emu\+Fd\+Net\+Device\+Helper\+::\+Emu\+Fd\+Net\+Device\+Helper (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1EmuFdNetDeviceHelper_ae4f56369d0efcfe57883ccb2fac50505}{}\label{classns3_1_1EmuFdNetDeviceHelper_ae4f56369d0efcfe57883ccb2fac50505}
Construct a \hyperlink{classns3_1_1EmuFdNetDeviceHelper}{Emu\+Fd\+Net\+Device\+Helper}. 
\begin{DoxyCode}
63 \{
64   \hyperlink{classns3_1_1EmuFdNetDeviceHelper_a5c259590827f139ae1189a99addeca6a}{m\_deviceName} = \textcolor{stringliteral}{"undefined"};
65 \}
\end{DoxyCode}
\index{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper@{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper}!````~Emu\+Fd\+Net\+Device\+Helper@{$\sim$\+Emu\+Fd\+Net\+Device\+Helper}}
\index{````~Emu\+Fd\+Net\+Device\+Helper@{$\sim$\+Emu\+Fd\+Net\+Device\+Helper}!ns3\+::\+Emu\+Fd\+Net\+Device\+Helper@{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{$\sim$\+Emu\+Fd\+Net\+Device\+Helper()}{~EmuFdNetDeviceHelper()}}]{\setlength{\rightskip}{0pt plus 5cm}virtual ns3\+::\+Emu\+Fd\+Net\+Device\+Helper\+::$\sim$\+Emu\+Fd\+Net\+Device\+Helper (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1EmuFdNetDeviceHelper_a0599b6cc5450eb0d950da3bcfabdce4d}{}\label{classns3_1_1EmuFdNetDeviceHelper_a0599b6cc5450eb0d950da3bcfabdce4d}

\begin{DoxyCode}
48   \{
49   \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2




\subsection{Member Function Documentation}
\index{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper@{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper}!Create\+File\+Descriptor@{Create\+File\+Descriptor}}
\index{Create\+File\+Descriptor@{Create\+File\+Descriptor}!ns3\+::\+Emu\+Fd\+Net\+Device\+Helper@{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{Create\+File\+Descriptor(void) const }{CreateFileDescriptor(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Emu\+Fd\+Net\+Device\+Helper\+::\+Create\+File\+Descriptor (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1EmuFdNetDeviceHelper_a64392b0acfeddf0121b251bc7e6e8906}{}\label{classns3_1_1EmuFdNetDeviceHelper_a64392b0acfeddf0121b251bc7e6e8906}
Call out to a separate process running as suid root in order to get a raw socket. We do this to avoid having the entire simulation running as root. \begin{DoxyReturn}{Returns}
the raw\+Socket number 
\end{DoxyReturn}


Reimplemented in \hyperlink{classns3_1_1TapFdNetDeviceHelper_a096fe572156c6f315ca33f30d93e41c1}{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}, and \hyperlink{classns3_1_1PlanetLabFdNetDeviceHelper_ab758ef1ac544c73625dbfd6fa9d48e4f}{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper}.


\begin{DoxyCode}
194 \{
195   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
196 
197   \textcolor{comment}{//}
198   \textcolor{comment}{// We want to create a raw socket for our net device.  Unfortunately for us}
199   \textcolor{comment}{// you have to have root privileges to do that.  Instead of running the}
200   \textcolor{comment}{// entire simulation as root, we decided to make a small program who's whole}
201   \textcolor{comment}{// reason for being is to run as suid root and create a raw socket.  We're}
202   \textcolor{comment}{// going to fork and exec that program soon, but we need to have a socket}
203   \textcolor{comment}{// to talk to it with.  So we create a local interprocess (Unix) socket}
204   \textcolor{comment}{// for that purpose.}
205   \textcolor{comment}{//}
206   \textcolor{keywordtype}{int} sock = socket (PF\_UNIX, SOCK\_DGRAM, 0);
207   \textcolor{keywordflow}{if} (sock == -1)
208     \{
209       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"EmuFdNetDeviceHelper::CreateFileDescriptor(): Unix socket creation
       error, errno = "} << strerror (errno));
210     \}
211 
212   \textcolor{comment}{//}
213   \textcolor{comment}{// Bind to that socket and let the kernel allocate an endpoint}
214   \textcolor{comment}{//}
215   \textcolor{keyword}{struct }sockaddr\_un un;
216   memset (&un, 0, \textcolor{keyword}{sizeof} (un));
217   un.sun\_family = AF\_UNIX;
218   \textcolor{keywordtype}{int} status = bind (sock, (\textcolor{keyword}{struct} sockaddr*)&un, \textcolor{keyword}{sizeof} (sa\_family\_t));
219   \textcolor{keywordflow}{if} (status == -1)
220     \{
221       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"EmuFdNetDeviceHelper::CreateFileDescriptor(): Could not bind(): errno
       = "} << strerror (errno));
222     \}
223 
224   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Created Unix socket"});
225   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"sun\_family = "} << un.sun\_family);
226   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"sun\_path = "} << un.sun\_path);
227 
228   \textcolor{comment}{//}
229   \textcolor{comment}{// We have a socket here, but we want to get it there -- to the program we're}
230   \textcolor{comment}{// going to exec.  What we'll do is to do a getsockname and then encode the}
231   \textcolor{comment}{// resulting address information as a string, and then send the string to the}
232   \textcolor{comment}{// program as an argument.  So we need to get the sock name.}
233   \textcolor{comment}{//}
234   socklen\_t len = \textcolor{keyword}{sizeof} (un);
235   status = getsockname (sock, (\textcolor{keyword}{struct} sockaddr*)&un, &len);
236   \textcolor{keywordflow}{if} (status == -1)
237     \{
238       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"EmuFdNetDeviceHelper::CreateFileDescriptor(): Could not getsockname():
       errno = "} << strerror (errno));
239     \}
240 
241   \textcolor{comment}{//}
242   \textcolor{comment}{// Now encode that socket name (family and path) as a string of hex digits}
243   \textcolor{comment}{//}
244   std::string path = \hyperlink{namespacens3_a97907497171f00140c77ed054e3baad6}{BufferToString} ((uint8\_t *)&un, len);
245   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Encoded Unix socket as \(\backslash\)""} << path << \textcolor{stringliteral}{"\(\backslash\)""});
246   \textcolor{comment}{//}
247   \textcolor{comment}{// Fork and exec the process to create our socket.  If we're us (the parent)}
248   \textcolor{comment}{// we wait for the child (the socket creator) to complete and read the}
249   \textcolor{comment}{// socket it created using the ancillary data mechanism.}
250   \textcolor{comment}{//}
251   \textcolor{comment}{// Tom Goff reports the possiblility of a deadlock when trying to acquire the}
252   \textcolor{comment}{// python GIL here.  He says that this might be due to trying to access Python}
253   \textcolor{comment}{// objects after fork() without calling PyOS\_AfterFork() to properly reset}
254   \textcolor{comment}{// Python state (including the GIL).  There is no code to cause the problem}
255   \textcolor{comment}{// here in emu, but this was visible in similar code in tap-bridge.}
256   \textcolor{comment}{//}
257   pid\_t pid = ::fork ();
258   \textcolor{keywordflow}{if} (pid == 0)
259     \{
260       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Child process"});
261 
262       \textcolor{comment}{//}
263       \textcolor{comment}{// build a command line argument from the encoded endpoint string that}
264       \textcolor{comment}{// the socket creation process will use to figure out how to respond to}
265       \textcolor{comment}{// the (now) parent process.}
266       \textcolor{comment}{//}
267       std::ostringstream oss;
268       oss << \textcolor{stringliteral}{"-p"} << path;
269       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Parameters set to \(\backslash\)""} << oss.str () << \textcolor{stringliteral}{"\(\backslash\)""});
270 
271       \textcolor{comment}{//}
272       \textcolor{comment}{// Execute the socket creation process image.}
273       \textcolor{comment}{//}
274       status = ::execlp (RAW\_SOCK\_CREATOR,
275                          RAW\_SOCK\_CREATOR,                            \textcolor{comment}{// argv[0] (filename)}
276                          oss.str ().c\_str (),                           \textcolor{comment}{// argv[1] (-p<path?}
277                          (\textcolor{keywordtype}{char} *)NULL);
278 
279       \textcolor{comment}{//}
280       \textcolor{comment}{// If the execlp successfully completes, it never returns.  If it returns it failed or the OS is}
281       \textcolor{comment}{// broken.  In either case, we bail.}
282       \textcolor{comment}{//}
283       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"EmuFdNetDeviceHelper::CreateFileDescriptor(): Back from execlp(),
       status = "} <<
284                       status << \textcolor{stringliteral}{", errno = "} << ::strerror (errno));
285     \}
286   \textcolor{keywordflow}{else}
287     \{
288       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Parent process"});
289       \textcolor{comment}{//}
290       \textcolor{comment}{// We're the process running the emu net device.  We need to wait for the}
291       \textcolor{comment}{// socket creator process to finish its job.}
292       \textcolor{comment}{//}
293       \textcolor{keywordtype}{int} st;
294       pid\_t waited = waitpid (pid, &st, 0);
295       \textcolor{keywordflow}{if} (waited == -1)
296         \{
297           \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"EmuFdNetDeviceHelper::CreateFileDescriptor(): waitpid() fails,
       errno = "} << strerror (errno));
298         \}
299       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (pid == waited, \textcolor{stringliteral}{"EmuFdNetDeviceHelper::CreateFileDescriptor(): pid
       mismatch"});
300 
301       \textcolor{comment}{//}
302       \textcolor{comment}{// Check to see if the socket creator exited normally and then take a}
303       \textcolor{comment}{// look at the exit code.  If it bailed, so should we.  If it didn't}
304       \textcolor{comment}{// even exit normally, we bail too.}
305       \textcolor{comment}{//}
306       \textcolor{keywordflow}{if} (WIFEXITED (st))
307         \{
308           \textcolor{keywordtype}{int} exitStatus = WEXITSTATUS (st);
309           \textcolor{keywordflow}{if} (exitStatus != 0)
310             \{
311               \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"EmuFdNetDeviceHelper::CreateFileDescriptor(): socket creator
       exited normally with status "} << exitStatus);
312             \}
313         \}
314       \textcolor{keywordflow}{else}
315         \{
316           \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"EmuFdNetDeviceHelper::CreateFileDescriptor(): socket creator
       exited abnormally"});
317         \}
318 
319       \textcolor{comment}{//}
320       \textcolor{comment}{// At this point, the socket creator has run successfully and should}
321       \textcolor{comment}{// have created our raw socket and sent it back to the socket address}
322       \textcolor{comment}{// we provided.  Our socket should be waiting on the Unix socket.  We've}
323       \textcolor{comment}{// got to do a bunch of grunto work to get at it, though.}
324       \textcolor{comment}{//}
325       \textcolor{comment}{// The struct iovec below is part of a scatter-gather list.  It describes a}
326       \textcolor{comment}{// buffer.  In this case, it describes a buffer (an integer) that will}
327       \textcolor{comment}{// get the data that comes back from the socket creator process.  It will}
328       \textcolor{comment}{// be a magic number that we use as a consistency/sanity check.}
329       \textcolor{comment}{//}
330       \textcolor{keyword}{struct }iovec iov;
331       uint32\_t magic;
332       iov.iov\_base = &magic;
333       iov.iov\_len = \textcolor{keyword}{sizeof}(magic);
334 
335       \textcolor{comment}{//}
336       \textcolor{comment}{// The CMSG macros you'll see below are used to create and access control}
337       \textcolor{comment}{// messages (which is another name for ancillary data).  The ancillary}
338       \textcolor{comment}{// data is made up of pairs of struct cmsghdr structures and associated}
339       \textcolor{comment}{// data arrays.}
340       \textcolor{comment}{//}
341       \textcolor{comment}{// First, we're going to allocate a buffer on the stack to receive our}
342       \textcolor{comment}{// data array (that contains the socket).  Sometimes you'll see this called}
343       \textcolor{comment}{// an "ancillary element" but the msghdr uses the control message terminology}
344       \textcolor{comment}{// so we call it "control."}
345       \textcolor{comment}{//}
346       \textcolor{keywordtype}{size\_t} msg\_size = \textcolor{keyword}{sizeof}(int);
347       \textcolor{keywordtype}{char} control[CMSG\_SPACE (msg\_size)];
348 
349       \textcolor{comment}{//}
350       \textcolor{comment}{// There is a msghdr that is used to minimize the number of parameters}
351       \textcolor{comment}{// passed to recvmsg (which we will use to receive our ancillary data).}
352       \textcolor{comment}{// This structure uses terminology corresponding to control messages, so}
353       \textcolor{comment}{// you'll see msg\_control, which is the pointer to the ancillary data and}
354       \textcolor{comment}{// controller which is the size of the ancillary data array.}
355       \textcolor{comment}{//}
356       \textcolor{comment}{// So, initialize the message header that describes the ancillary/control}
357       \textcolor{comment}{// data we expect to receive and point it to buffer.}
358       \textcolor{comment}{//}
359       \textcolor{keyword}{struct }msghdr msg;
360       msg.msg\_name = 0;
361       msg.msg\_namelen = 0;
362       msg.msg\_iov = &iov;
363       msg.msg\_iovlen = 1;
364       msg.msg\_control = control;
365       msg.msg\_controllen = \textcolor{keyword}{sizeof} (control);
366       msg.msg\_flags = 0;
367 
368       \textcolor{comment}{//}
369       \textcolor{comment}{// Now we can actually receive the interesting bits from the socket}
370       \textcolor{comment}{// creator process.}
371       \textcolor{comment}{//}
372       ssize\_t bytesRead = recvmsg (sock, &msg, 0);
373       \textcolor{keywordflow}{if} (bytesRead != \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}))
374         \{
375           \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"EmuFdNetDeviceHelper::CreateFileDescriptor(): Wrong byte count
       from socket creator"});
376         \}
377 
378       \textcolor{comment}{//}
379       \textcolor{comment}{// There may be a number of message headers/ancillary data arrays coming in.}
380       \textcolor{comment}{// Let's look for the one with a type SCM\_RIGHTS which indicates it' the}
381       \textcolor{comment}{// one we're interested in.}
382       \textcolor{comment}{//}
383       \textcolor{keyword}{struct }cmsghdr *cmsg;
384       \textcolor{keywordflow}{for} (cmsg = CMSG\_FIRSTHDR (&msg); cmsg != NULL; cmsg = CMSG\_NXTHDR (&msg, cmsg))
385         \{
386           \textcolor{keywordflow}{if} (cmsg->cmsg\_level == SOL\_SOCKET
387               && cmsg->cmsg\_type == SCM\_RIGHTS)
388             \{
389               \textcolor{comment}{//}
390               \textcolor{comment}{// This is the type of message we want.  Check to see if the magic}
391               \textcolor{comment}{// number is correct and then pull out the socket we care about if}
392               \textcolor{comment}{// it matches}
393               \textcolor{comment}{//}
394               \textcolor{keywordflow}{if} (magic == \hyperlink{emu-fd-net-device-helper_8cc_adc226a140a49fe19a57e21bbe86341e4}{EMU\_MAGIC})
395                 \{
396                   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Got SCM\_RIGHTS with correct magic "} << magic);
397                   \textcolor{keywordtype}{int} *rawSocket = (\textcolor{keywordtype}{int}*)CMSG\_DATA (cmsg);
398                   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Got the socket from the socket creator = "} << *rawSocket);
399                   \textcolor{keywordflow}{return} *rawSocket;
400                 \}
401               \textcolor{keywordflow}{else}
402                 \{
403                   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Got SCM\_RIGHTS, but with bad magic "} << magic);
404                 \}
405             \}
406         \}
407       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Did not get the raw socket from the socket creator"});
408     \}
409 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3




Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper@{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper}!Get\+Device\+Name@{Get\+Device\+Name}}
\index{Get\+Device\+Name@{Get\+Device\+Name}!ns3\+::\+Emu\+Fd\+Net\+Device\+Helper@{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{Get\+Device\+Name(void)}{GetDeviceName(void)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string ns3\+::\+Emu\+Fd\+Net\+Device\+Helper\+::\+Get\+Device\+Name (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1EmuFdNetDeviceHelper_a12d7886e84be06c4c5021ad92584bb2b}{}\label{classns3_1_1EmuFdNetDeviceHelper_a12d7886e84be06c4c5021ad92584bb2b}
Get the device name of this device.

\begin{DoxyReturn}{Returns}
The device name of this device. 
\end{DoxyReturn}

\begin{DoxyCode}
75 \{
76   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1EmuFdNetDeviceHelper_a5c259590827f139ae1189a99addeca6a}{m\_deviceName};
77 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper@{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper}!Install\+Priv@{Install\+Priv}}
\index{Install\+Priv@{Install\+Priv}!ns3\+::\+Emu\+Fd\+Net\+Device\+Helper@{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{Install\+Priv(\+Ptr$<$ Node $>$ node) const }{InstallPriv(Ptr< Node > node) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Net\+Device} $>$ ns3\+::\+Emu\+Fd\+Net\+Device\+Helper\+::\+Install\+Priv (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1EmuFdNetDeviceHelper_a80562da33cef1c20d4b03b351fbbc21a}{}\label{classns3_1_1EmuFdNetDeviceHelper_a80562da33cef1c20d4b03b351fbbc21a}
This method creates an \hyperlink{classns3_1_1FdNetDevice}{ns3\+::\+Fd\+Net\+Device} attached to a physical network interface


\begin{DoxyParams}{Parameters}
{\em node} & The node to install the device in \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A container holding the added net device. 
\end{DoxyReturn}


Reimplemented from \hyperlink{classns3_1_1FdNetDeviceHelper_adf0e4f64b03f7203f7080b50f412a970}{ns3\+::\+Fd\+Net\+Device\+Helper}.



Reimplemented in \hyperlink{classns3_1_1TapFdNetDeviceHelper_a5b95f44885b6b5a5285604be0c6fa413}{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}, and \hyperlink{classns3_1_1PlanetLabFdNetDeviceHelper_a740ff8b94a42f4175af712baf00c83ab}{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper}.


\begin{DoxyCode}
81 \{
82   Ptr<NetDevice> \hyperlink{buildings__pathloss_8m_a9f9b934daed17a4d3613b6886ff4cf4b}{d} = \hyperlink{classns3_1_1FdNetDeviceHelper_adf0e4f64b03f7203f7080b50f412a970}{FdNetDeviceHelper::InstallPriv} (node);
83   Ptr<FdNetDevice> device = d->GetObject<FdNetDevice> ();
84   \hyperlink{classns3_1_1EmuFdNetDeviceHelper_ad48e0e01cd07bd76bdc6bf05ed4fa756}{SetFileDescriptor} (device);
85   \textcolor{keywordflow}{return} device;
86 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6




Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper@{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper}!Set\+Device\+Name@{Set\+Device\+Name}}
\index{Set\+Device\+Name@{Set\+Device\+Name}!ns3\+::\+Emu\+Fd\+Net\+Device\+Helper@{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{Set\+Device\+Name(std\+::string device\+Name)}{SetDeviceName(std::string deviceName)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Emu\+Fd\+Net\+Device\+Helper\+::\+Set\+Device\+Name (
\begin{DoxyParamCaption}
\item[{std\+::string}]{device\+Name}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1EmuFdNetDeviceHelper_aa5c26a78442e507ba969f28ffa5f748e}{}\label{classns3_1_1EmuFdNetDeviceHelper_aa5c26a78442e507ba969f28ffa5f748e}
Set the device name of this device.


\begin{DoxyParams}{Parameters}
{\em device\+Name} & The device name of this device. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
69 \{
70   \hyperlink{classns3_1_1EmuFdNetDeviceHelper_a5c259590827f139ae1189a99addeca6a}{m\_deviceName} = deviceName;
71 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper@{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper}!Set\+File\+Descriptor@{Set\+File\+Descriptor}}
\index{Set\+File\+Descriptor@{Set\+File\+Descriptor}!ns3\+::\+Emu\+Fd\+Net\+Device\+Helper@{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{Set\+File\+Descriptor(\+Ptr$<$ Fd\+Net\+Device $>$ device) const }{SetFileDescriptor(Ptr< FdNetDevice > device) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Emu\+Fd\+Net\+Device\+Helper\+::\+Set\+File\+Descriptor (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Fd\+Net\+Device} $>$}]{device}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1EmuFdNetDeviceHelper_ad48e0e01cd07bd76bdc6bf05ed4fa756}{}\label{classns3_1_1EmuFdNetDeviceHelper_ad48e0e01cd07bd76bdc6bf05ed4fa756}
Sets a file descriptor on the File\+Descriptor\+Net\+Device. 

Reimplemented in \hyperlink{classns3_1_1TapFdNetDeviceHelper_a8f1a78ce4fcf68db89d9acfccd6a3165}{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}, and \hyperlink{classns3_1_1PlanetLabFdNetDeviceHelper_acec8004fe1776760866ab8f6ca1b2936}{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper}.


\begin{DoxyCode}
90 \{
91   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Creating EMU socket"});
92 
93   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1EmuFdNetDeviceHelper_a5c259590827f139ae1189a99addeca6a}{m\_deviceName} == \textcolor{stringliteral}{"undefined"})
94     \{
95       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"EmuFdNetDeviceHelper::SetFileDescriptor (): m\_deviceName is not set"});
96     \}
97 
98   \textcolor{comment}{//}
99   \textcolor{comment}{// Call out to a separate process running as suid root in order to get a raw}
100   \textcolor{comment}{// socket.  We do this to avoid having the entire simulation running as root.}
101   \textcolor{comment}{//}
102   \textcolor{keywordtype}{int} \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_a44f21d5190b5a6df8089f54799628d7e}{fd} = \hyperlink{classns3_1_1EmuFdNetDeviceHelper_a64392b0acfeddf0121b251bc7e6e8906}{CreateFileDescriptor} ();
103   device->SetFileDescriptor (fd);
104 
105   \textcolor{comment}{//}
106   \textcolor{comment}{// Figure out which interface index corresponds to the device name in the corresponding attribute.}
107   \textcolor{comment}{//}
108   \textcolor{keyword}{struct }ifreq ifr;
109   bzero (&ifr, \textcolor{keyword}{sizeof}(ifr));
110   strncpy ((\textcolor{keywordtype}{char} *)ifr.ifr\_name, \hyperlink{classns3_1_1EmuFdNetDeviceHelper_a5c259590827f139ae1189a99addeca6a}{m\_deviceName}.c\_str (), IFNAMSIZ);
111 
112   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Getting interface index"});
113   int32\_t rc = ioctl (fd, SIOCGIFINDEX, &ifr);
114   \textcolor{keywordflow}{if} (rc == -1)
115     \{
116       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"EmuFdNetDeviceHelper::SetFileDescriptor (): Can't get interface index"}
      );
117     \}
118 
119   \textcolor{comment}{//}
120   \textcolor{comment}{// Bind the socket to the interface we just found.}
121   \textcolor{comment}{//}
122   \textcolor{keyword}{struct }sockaddr\_ll ll;
123   bzero (&ll, \textcolor{keyword}{sizeof}(ll));
124 
125   ll.sll\_family = AF\_PACKET;
126   ll.sll\_ifindex = ifr.ifr\_ifindex;
127   ll.sll\_protocol = htons (ETH\_P\_ALL);
128 
129   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Binding socket to interface"});
130 
131   rc = bind (fd, (\textcolor{keyword}{struct} sockaddr *)&ll, \textcolor{keyword}{sizeof} (ll));
132   \textcolor{keywordflow}{if} (rc == -1)
133     \{
134       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"EmuFdNetDeviceHelper::SetFileDescriptor (): Can't bind to specified
       interface"});
135     \}
136 
137   rc = ioctl (fd, SIOCGIFFLAGS, &ifr);
138   \textcolor{keywordflow}{if} (rc == -1)
139     \{
140       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"EmuFdNetDeviceHelper::SetFileDescriptor (): Can't get interface flags"}
      );
141     \}
142 
143   \textcolor{comment}{//}
144   \textcolor{comment}{// This device only works if the underlying interface is up in promiscuous}
145   \textcolor{comment}{// mode.  We could have turned it on in the socket creator, but the situation}
146   \textcolor{comment}{// is that we expect these devices to be used in conjunction with virtual}
147   \textcolor{comment}{// machines with connected host-only (simulated) networks, or in a testbed.}
148   \textcolor{comment}{// There is a lot of setup and configuration happening outside of this one}
149   \textcolor{comment}{// issue, and we expect that configuration to include choosing a valid}
150   \textcolor{comment}{// interface (e.g, "ath1"), ensuring that the device supports promiscuous}
151   \textcolor{comment}{// mode, and placing it in promiscuous mode.  We just make sure of the}
152   \textcolor{comment}{// end result.}
153   \textcolor{comment}{//}
154   \textcolor{keywordflow}{if} ((ifr.ifr\_flags & IFF\_PROMISC) == 0)
155     \{
156       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"EmuFdNetDeviceHelper::SetFileDescriptor (): "} << 
      \hyperlink{classns3_1_1EmuFdNetDeviceHelper_a5c259590827f139ae1189a99addeca6a}{m\_deviceName}.c\_str () << \textcolor{stringliteral}{" is not in promiscuous mode"});
157     \}
158 
159   \textcolor{keywordflow}{if} ((ifr.ifr\_flags & IFF\_BROADCAST) != IFF\_BROADCAST)
160     \{
161       \textcolor{comment}{// We default m\_isBroadcast to true but turn it off here if not}
162       \textcolor{comment}{// supported, because in the common case, overlying IP code will}
163       \textcolor{comment}{// assert during configuration time if this is false, before this}
164       \textcolor{comment}{// method has a chance to set it during runtime}
165       device->SetIsBroadcast (\textcolor{keyword}{false});
166     \}
167 
168   \textcolor{keywordflow}{if} ((ifr.ifr\_flags & IFF\_MULTICAST) == IFF\_MULTICAST)
169     \{
170       \textcolor{comment}{// This one is OK to enable at runtime}
171       device->SetIsMulticast (\textcolor{keyword}{true});
172     \}
173 
174   \textcolor{comment}{// Set the MTU of the device to the mtu of the associated network interface}
175   \textcolor{keyword}{struct }ifreq ifr2;
176   
177   bzero (&ifr2, \textcolor{keyword}{sizeof} (ifr2));
178   strcpy (ifr2.ifr\_name, \hyperlink{classns3_1_1EmuFdNetDeviceHelper_a5c259590827f139ae1189a99addeca6a}{m\_deviceName}.c\_str ());
179 
180   int32\_t mtufd = socket (PF\_INET, SOCK\_DGRAM, IPPROTO\_IP);
181 
182   rc = ioctl (mtufd, SIOCGIFMTU, &ifr2);
183   \textcolor{keywordflow}{if} (rc == -1)
184     \{
185       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"FdNetDevice::SetFileDescriptor (): Can't ioctl SIOCGIFMTU"});
186     \}
187  
188   close (mtufd);
189   device->SetMtu (ifr.ifr\_mtu);
190 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9




Here is the caller graph for this function\+:
% FIG 10




\subsection{Member Data Documentation}
\index{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper@{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper}!m\+\_\+device\+Name@{m\+\_\+device\+Name}}
\index{m\+\_\+device\+Name@{m\+\_\+device\+Name}!ns3\+::\+Emu\+Fd\+Net\+Device\+Helper@{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+device\+Name}{m_deviceName}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string ns3\+::\+Emu\+Fd\+Net\+Device\+Helper\+::m\+\_\+device\+Name\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classns3_1_1EmuFdNetDeviceHelper_a5c259590827f139ae1189a99addeca6a}{}\label{classns3_1_1EmuFdNetDeviceHelper_a5c259590827f139ae1189a99addeca6a}
The unix/linux name of the underlying device (e.\+g., eth0) 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
fd-\/net-\/device/helper/\hyperlink{emu-fd-net-device-helper_8h}{emu-\/fd-\/net-\/device-\/helper.\+h}\item 
fd-\/net-\/device/helper/\hyperlink{emu-fd-net-device-helper_8cc}{emu-\/fd-\/net-\/device-\/helper.\+cc}\end{DoxyCompactItemize}
