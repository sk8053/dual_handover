\hypertarget{classns3_1_1GlobalRouter}{}\section{ns3\+:\+:Global\+Router Class Reference}
\label{classns3_1_1GlobalRouter}\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}


An interface aggregated to a node to provide global routing info.  




{\ttfamily \#include $<$global-\/router-\/interface.\+h$>$}



Inheritance diagram for ns3\+:\+:Global\+Router\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Global\+Router\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1GlobalRouter_a778050c70fe491c0fe62b7cf6b10aaf6}{Global\+Router} ()
\begin{DoxyCompactList}\small\item\em Create a Global Router class. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1GlobalRouter_abaae22deb0f40803687805e2380f4684}{Set\+Routing\+Protocol} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4GlobalRouting}{Ipv4\+Global\+Routing} $>$ routing)
\begin{DoxyCompactList}\small\item\em Set the specific Global Routing Protocol to be used. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4GlobalRouting}{Ipv4\+Global\+Routing} $>$ \hyperlink{classns3_1_1GlobalRouter_a720ae2fce6e8a8a6ac4ae8c69b2a6715}{Get\+Routing\+Protocol} (void)
\begin{DoxyCompactList}\small\item\em Get the specific Global Routing Protocol used. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \hyperlink{classns3_1_1GlobalRouter_a746a83343a6868e415f29ceed9dc0cd0}{Get\+Router\+Id} (void) const 
\begin{DoxyCompactList}\small\item\em Get the Router ID associated with this Global Router. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1GlobalRouter_a44e135879879a27cd8d2566b5e9761cf}{Discover\+L\+S\+As} (void)
\begin{DoxyCompactList}\small\item\em Walk the connected channels, discover the adjacent routers and build the associated number of Global Routing Link State Advertisements that this router can export. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1GlobalRouter_addd8a89e462a36660a3f68dec959bb19}{Get\+Num\+L\+S\+As} (void) const 
\begin{DoxyCompactList}\small\item\em Get the Number of Global Routing Link State Advertisements that this router can export. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1GlobalRouter_a1ae9d137fabd4fa16b6bc7b292bbadd3}{Get\+L\+SA} (uint32\+\_\+t \hyperlink{lte__link__budget__x2__handover__measures_8m_abdb05bc5a064cf642a06c83b3392f148}{n}, \hyperlink{classns3_1_1GlobalRoutingLSA}{Global\+Routing\+L\+SA} \&lsa) const 
\begin{DoxyCompactList}\small\item\em Get a Global Routing Link State Advertisements that this router has said that it can export. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1GlobalRouter_a393647cfce742040c6adab116777695f}{Inject\+Route} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} network, \hyperlink{classns3_1_1Ipv4Mask}{Ipv4\+Mask} network\+Mask)
\begin{DoxyCompactList}\small\item\em Inject a route to be circulated to other routers as an external route. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1GlobalRouter_a5b28018cadfa511cc9d5b58506f65321}{Get\+N\+Injected\+Routes} (void)
\begin{DoxyCompactList}\small\item\em Get the number of injected routes that have been added to the routing table. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} $\ast$ \hyperlink{classns3_1_1GlobalRouter_a7fa5ef8dea5f91441b394cb4fa752112}{Get\+Injected\+Route} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
\begin{DoxyCompactList}\small\item\em Return the injected route indexed by i. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1GlobalRouter_aa8a781b1a62792f28d1962d7c0f4a0ee}{Remove\+Injected\+Route} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
\begin{DoxyCompactList}\small\item\em Withdraw a route from the global unicast routing table. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1GlobalRouter_a17da2fda3c801645ccaed838a8d2e553}{Withdraw\+Route} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} network, \hyperlink{classns3_1_1Ipv4Mask}{Ipv4\+Mask} network\+Mask)
\begin{DoxyCompactList}\small\item\em Withdraw a route from the global unicast routing table. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1GlobalRouter_a0154feb219f179c98f57ce14e966fc28}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1GlobalRoutingLSA}{Global\+Routing\+L\+SA} $\ast$ $>$ \hyperlink{classns3_1_1GlobalRouter_a01ba626a41e2ac7d2f53bd9adab92556}{List\+Of\+L\+S\+As\+\_\+t}
\begin{DoxyCompactList}\small\item\em container for the Global\+Routing\+L\+S\+As \end{DoxyCompactList}\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} $\ast$ $>$ \hyperlink{classns3_1_1GlobalRouter_a26119d19a18a0c540baffdc16f0a731f}{Injected\+Routes}
\begin{DoxyCompactList}\small\item\em container of \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} \end{DoxyCompactList}\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} $\ast$ $>$\+::const\+\_\+iterator \hyperlink{classns3_1_1GlobalRouter_aea87fa6405b7c0e2bd56adfcf37823a8}{Injected\+Routes\+CI}
\begin{DoxyCompactList}\small\item\em Const Iterator to container of \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry}. \end{DoxyCompactList}\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} $\ast$ $>$\+::iterator \hyperlink{classns3_1_1GlobalRouter_ac4ed7a61065c866b6f52abcdb2f29711}{Injected\+RoutesI}
\begin{DoxyCompactList}\small\item\em Iterator to container of \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry}. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual \hyperlink{classns3_1_1GlobalRouter_a790cbb0b727677916583a16cdd5d177a}{$\sim$\+Global\+Router} ()
\item 
void \hyperlink{classns3_1_1GlobalRouter_a7c6430b2da06fff5ce1fda4ac90c4836}{Clear\+L\+S\+As} (void)
\begin{DoxyCompactList}\small\item\em Clear list of L\+S\+As. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ \hyperlink{classns3_1_1GlobalRouter_a347a9eb0edc5b923d6d3a3614e48769f}{Get\+Adjacent} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ nd, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Channel}{Channel} $>$ ch) const 
\begin{DoxyCompactList}\small\item\em Link through the given channel and find the net device that\textquotesingle{}s on the other end. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1GlobalRouter_a7b30c3c09f93e3f3ac7cfe787b51d127}{Find\+Interface\+For\+Device} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ nd, uint32\+\_\+t \&index) const 
\begin{DoxyCompactList}\small\item\em Given a node and a net device, find an I\+P\+V4 interface index that corresponds to that net device. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \hyperlink{classns3_1_1GlobalRouter_ab562e4407394674ef8502b3ab1d051d6}{Find\+Designated\+Router\+For\+Link} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ nd\+Local) const 
\begin{DoxyCompactList}\small\item\em Finds a designated router. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1GlobalRouter_ae2af74f394b3b8de4daad7000fb0b9f7}{Another\+Router\+On\+Link} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ nd) const 
\begin{DoxyCompactList}\small\item\em Checks for the presence of another router on the \hyperlink{classns3_1_1NetDevice}{Net\+Device}. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1GlobalRouter_af981be58153ef32690b434072cd3205b}{Process\+Broadcast\+Link} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ nd, \hyperlink{classns3_1_1GlobalRoutingLSA}{Global\+Routing\+L\+SA} $\ast$p\+L\+SA, \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} \&\hyperlink{mmwave_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c})
\begin{DoxyCompactList}\small\item\em Process a generic broadcast link. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1GlobalRouter_a16b0eecb167b84a7160c8903839a826f}{Process\+Single\+Broadcast\+Link} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ nd, \hyperlink{classns3_1_1GlobalRoutingLSA}{Global\+Routing\+L\+SA} $\ast$p\+L\+SA, \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} \&\hyperlink{mmwave_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c})
\begin{DoxyCompactList}\small\item\em Process a single broadcast link. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1GlobalRouter_a7368716600989ea7d4bec67fa4f86e4c}{Process\+Bridged\+Broadcast\+Link} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ nd, \hyperlink{classns3_1_1GlobalRoutingLSA}{Global\+Routing\+L\+SA} $\ast$p\+L\+SA, \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} \&\hyperlink{mmwave_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c})
\begin{DoxyCompactList}\small\item\em Process a bridged broadcast link. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1GlobalRouter_adaf99c499d6e42e450a31b53a8019b14}{Process\+Point\+To\+Point\+Link} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ nd\+Local, \hyperlink{classns3_1_1GlobalRoutingLSA}{Global\+Routing\+L\+SA} $\ast$p\+L\+SA)
\begin{DoxyCompactList}\small\item\em Process a point to point link. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1GlobalRouter_aff937ae50e8cc2de5a6e989cbe17609b}{Build\+Network\+L\+S\+As} (\hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} \hyperlink{mmwave_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c})
\begin{DoxyCompactList}\small\item\em Build one Network\+L\+SA for each net device talking to a network that we are the designated router for. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} \hyperlink{classns3_1_1GlobalRouter_af1fc3edcc4d14d9344f3b94617da8e85}{Find\+All\+Non\+Bridged\+Devices\+On\+Link} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Channel}{Channel} $>$ ch) const 
\begin{DoxyCompactList}\small\item\em Return a container of all non-\/bridged Net\+Devices on a link. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1BridgeNetDevice}{Bridge\+Net\+Device} $>$ \hyperlink{classns3_1_1GlobalRouter_ad330b65439cd1be39799b52df948f98b}{Net\+Device\+Is\+Bridged} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ nd) const 
\begin{DoxyCompactList}\small\item\em Decide whether or not a given net device is being bridged by a \hyperlink{classns3_1_1BridgeNetDevice}{Bridge\+Net\+Device}. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1GlobalRouter_a2519d9ebeb7425ffe4569c6ed0eaf4cf}{Clear\+Bridges\+Visited} (void) const 
\item 
bool \hyperlink{classns3_1_1GlobalRouter_ab358e6c36f04f05c42a4ca2c472c3179}{Bridge\+Has\+Already\+Been\+Visited} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1BridgeNetDevice}{Bridge\+Net\+Device} $>$ device) const 
\item 
void \hyperlink{classns3_1_1GlobalRouter_a27297efb3e69712604932d5275ab2abb}{Mark\+Bridge\+As\+Visited} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1BridgeNetDevice}{Bridge\+Net\+Device} $>$ device) const 
\item 
virtual void \hyperlink{classns3_1_1GlobalRouter_a19d984861cd9f427781d291c57f7b1c6}{Do\+Dispose} (void)
\item 
\hyperlink{classns3_1_1GlobalRouter_a243a16e49c8b862db8460a5e4e11858a}{Global\+Router} (\hyperlink{classns3_1_1GlobalRouter}{Global\+Router} \&sr)
\begin{DoxyCompactList}\small\item\em Global Router copy construction is disallowed. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1GlobalRouter}{Global\+Router} \& \hyperlink{classns3_1_1GlobalRouter_a8a3edaf983ba050a8326d943e556c04e}{operator=} (\hyperlink{classns3_1_1GlobalRouter}{Global\+Router} \&sr)
\begin{DoxyCompactList}\small\item\em Global Router assignment operator is disallowed. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1GlobalRouter_a01ba626a41e2ac7d2f53bd9adab92556}{List\+Of\+L\+S\+As\+\_\+t} \hyperlink{classns3_1_1GlobalRouter_a5c583d84f810ce4404f54450a0ac18d4}{m\+\_\+\+L\+S\+As}
\begin{DoxyCompactList}\small\item\em database of Global\+Routing\+L\+S\+As \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \hyperlink{classns3_1_1GlobalRouter_aa107123583f6b2b68c61666a029b4270}{m\+\_\+router\+Id}
\begin{DoxyCompactList}\small\item\em router ID (its I\+Pv4 address) \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4GlobalRouting}{Ipv4\+Global\+Routing} $>$ \hyperlink{classns3_1_1GlobalRouter_a0a18bfb8e4f788c0e3027dcc603155a4}{m\+\_\+routing\+Protocol}
\begin{DoxyCompactList}\small\item\em the \hyperlink{classns3_1_1Ipv4GlobalRouting}{Ipv4\+Global\+Routing} in use \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1GlobalRouter_a26119d19a18a0c540baffdc16f0a731f}{Injected\+Routes} \hyperlink{classns3_1_1GlobalRouter_a2d1dd8dbb1bc813f24bff2fb2f0cde7f}{m\+\_\+injected\+Routes}
\begin{DoxyCompactList}\small\item\em Routes we are exporting. \end{DoxyCompactList}\item 
std\+::vector$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1BridgeNetDevice}{Bridge\+Net\+Device} $>$ $>$ \hyperlink{classns3_1_1GlobalRouter_ad1b09bb4b76610b276fb065a0cb8dee6}{m\+\_\+bridges\+Visited}
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
An interface aggregated to a node to provide global routing info. 

An interface aggregated to a node that provides global routing information to a global route manager. The presence of the interface indicates that the node is a router. The interface is the mechanism by which the router advertises its connections to neighboring routers. We\textquotesingle{}re basically allowing the route manager to query for link state advertisements. 

\subsection{Member Typedef Documentation}
\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Injected\+Routes@{Injected\+Routes}}
\index{Injected\+Routes@{Injected\+Routes}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Injected\+Routes}{InjectedRoutes}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Ipv4\+Routing\+Table\+Entry} $\ast$$>$ {\bf ns3\+::\+Global\+Router\+::\+Injected\+Routes}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1GlobalRouter_a26119d19a18a0c540baffdc16f0a731f}{}\label{classns3_1_1GlobalRouter_a26119d19a18a0c540baffdc16f0a731f}


container of \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} 

\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Injected\+Routes\+CI@{Injected\+Routes\+CI}}
\index{Injected\+Routes\+CI@{Injected\+Routes\+CI}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Injected\+Routes\+CI}{InjectedRoutesCI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Ipv4\+Routing\+Table\+Entry} $\ast$$>$\+::const\+\_\+iterator {\bf ns3\+::\+Global\+Router\+::\+Injected\+Routes\+CI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1GlobalRouter_aea87fa6405b7c0e2bd56adfcf37823a8}{}\label{classns3_1_1GlobalRouter_aea87fa6405b7c0e2bd56adfcf37823a8}


Const Iterator to container of \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry}. 

\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Injected\+RoutesI@{Injected\+RoutesI}}
\index{Injected\+RoutesI@{Injected\+RoutesI}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Injected\+RoutesI}{InjectedRoutesI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Ipv4\+Routing\+Table\+Entry} $\ast$$>$\+::iterator {\bf ns3\+::\+Global\+Router\+::\+Injected\+RoutesI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1GlobalRouter_ac4ed7a61065c866b6f52abcdb2f29711}{}\label{classns3_1_1GlobalRouter_ac4ed7a61065c866b6f52abcdb2f29711}


Iterator to container of \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry}. 

\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!List\+Of\+L\+S\+As\+\_\+t@{List\+Of\+L\+S\+As\+\_\+t}}
\index{List\+Of\+L\+S\+As\+\_\+t@{List\+Of\+L\+S\+As\+\_\+t}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{List\+Of\+L\+S\+As\+\_\+t}{ListOfLSAs_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Global\+Routing\+L\+SA}$\ast$$>$ {\bf ns3\+::\+Global\+Router\+::\+List\+Of\+L\+S\+As\+\_\+t}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1GlobalRouter_a01ba626a41e2ac7d2f53bd9adab92556}{}\label{classns3_1_1GlobalRouter_a01ba626a41e2ac7d2f53bd9adab92556}


container for the Global\+Routing\+L\+S\+As 



\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Global\+Router@{Global\+Router}}
\index{Global\+Router@{Global\+Router}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Global\+Router()}{GlobalRouter()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Global\+Router\+::\+Global\+Router (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1GlobalRouter_a778050c70fe491c0fe62b7cf6b10aaf6}{}\label{classns3_1_1GlobalRouter_a778050c70fe491c0fe62b7cf6b10aaf6}


Create a Global Router class. 


\begin{DoxyCode}
520   : \hyperlink{classns3_1_1GlobalRouter_a5c583d84f810ce4404f54450a0ac18d4}{m\_LSAs} ()
521 \{
522   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
523   \hyperlink{classns3_1_1GlobalRouter_aa107123583f6b2b68c61666a029b4270}{m\_routerId}.\hyperlink{classns3_1_1Ipv4Address_a7204982c2906b7df3f73739ca472dacb}{Set} (\hyperlink{classns3_1_1GlobalRouteManager_a7d2bab784e14064823d4115d65e949b7}{GlobalRouteManager::AllocateRouterId} ())
      ;
524 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!````~Global\+Router@{$\sim$\+Global\+Router}}
\index{````~Global\+Router@{$\sim$\+Global\+Router}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{$\sim$\+Global\+Router()}{~GlobalRouter()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Global\+Router\+::$\sim$\+Global\+Router (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1GlobalRouter_a790cbb0b727677916583a16cdd5d177a}{}\label{classns3_1_1GlobalRouter_a790cbb0b727677916583a16cdd5d177a}

\begin{DoxyCode}
527 \{
528   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
529   \hyperlink{classns3_1_1GlobalRouter_a7c6430b2da06fff5ce1fda4ac90c4836}{ClearLSAs} ();
530 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Global\+Router@{Global\+Router}}
\index{Global\+Router@{Global\+Router}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Global\+Router(\+Global\+Router \&sr)}{GlobalRouter(GlobalRouter &sr)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Global\+Router\+::\+Global\+Router (
\begin{DoxyParamCaption}
\item[{{\bf Global\+Router} \&}]{sr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1GlobalRouter_a243a16e49c8b862db8460a5e4e11858a}{}\label{classns3_1_1GlobalRouter_a243a16e49c8b862db8460a5e4e11858a}


Global Router copy construction is disallowed. 


\begin{DoxyParams}{Parameters}
{\em sr} & object to copy from. \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Another\+Router\+On\+Link@{Another\+Router\+On\+Link}}
\index{Another\+Router\+On\+Link@{Another\+Router\+On\+Link}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Another\+Router\+On\+Link(\+Ptr$<$ Net\+Device $>$ nd) const }{AnotherRouterOnLink(Ptr< NetDevice > nd) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Global\+Router\+::\+Another\+Router\+On\+Link (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{nd}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1GlobalRouter_ae2af74f394b3b8de4daad7000fb0b9f7}{}\label{classns3_1_1GlobalRouter_ae2af74f394b3b8de4daad7000fb0b9f7}


Checks for the presence of another router on the \hyperlink{classns3_1_1NetDevice}{Net\+Device}. 

Given a node and an attached net device, take a look off in the channel to which the net device is attached and look for a node on the other side that has a \hyperlink{classns3_1_1GlobalRouter}{Global\+Router} interface aggregated.


\begin{DoxyParams}{Parameters}
{\em nd} & \hyperlink{classns3_1_1NetDevice}{Net\+Device} to scan \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if a router is found 
\end{DoxyReturn}

\begin{DoxyCode}
1469 \{
1470   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << nd);
1471 
1472   Ptr<Channel> ch = nd->GetChannel ();
1473   \textcolor{keywordflow}{if} (!ch)
1474     \{
1475       \textcolor{comment}{// It may be that this net device is a stub device, without a channel}
1476       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1477     \}
1478   uint32\_t nDevices = ch->GetNDevices ();
1479   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (nDevices);
1480 
1481   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Looking for routers off of net device "} << nd << \textcolor{stringliteral}{" on node "} << nd->GetNode ()
      ->GetId ());
1482 
1483   \textcolor{comment}{//}
1484   \textcolor{comment}{// Look through all of the devices on the channel to which the net device}
1485   \textcolor{comment}{// in question is attached.}
1486   \textcolor{comment}{//}
1487   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < nDevices; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
1488     \{
1489       Ptr<NetDevice> ndOther = ch->GetDevice (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
1490       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (ndOther);
1491 
1492       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Examine channel device "} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} << \textcolor{stringliteral}{" on node "} << ndOther->GetNode ()->
      GetId ());
1493 
1494       \textcolor{comment}{// }
1495       \textcolor{comment}{// Ignore the net device itself.}
1496       \textcolor{comment}{//}
1497       \textcolor{keywordflow}{if} (ndOther == nd)
1498         \{
1499           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Myself, skip"});
1500           \textcolor{keywordflow}{continue};
1501         \}
1502 
1503       \textcolor{comment}{//}
1504       \textcolor{comment}{// For all other net devices, we need to check and see if a router}
1505       \textcolor{comment}{// is present.  If the net device on the other side is a bridged}
1506       \textcolor{comment}{// device, we need to consider all of the other devices on the }
1507       \textcolor{comment}{// bridge.}
1508       \textcolor{comment}{//}
1509       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"checking to see if device is bridged"});
1510       Ptr<BridgeNetDevice> bnd = \hyperlink{classns3_1_1GlobalRouter_ad330b65439cd1be39799b52df948f98b}{NetDeviceIsBridged} (ndOther);
1511       \textcolor{keywordflow}{if} (bnd)
1512         \{
1513           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Device is bridged by net device "} << bnd);
1514 
1515           \textcolor{comment}{// }
1516           \textcolor{comment}{// Check if we have seen this bridge net device already while}
1517           \textcolor{comment}{// recursively enumerating an L2 broadcast domain. If it is new }
1518           \textcolor{comment}{// to us, go ahead and process it. If we have already processed it,}
1519           \textcolor{comment}{// move to the next}
1520           \textcolor{comment}{// }
1521           \textcolor{keywordflow}{if}(\hyperlink{classns3_1_1GlobalRouter_ab358e6c36f04f05c42a4ca2c472c3179}{BridgeHasAlreadyBeenVisited}(bnd))
1522             \{
1523               \hyperlink{group__fatal_ga51ac4699be799d772ae7258d1ef6af21}{NS\_ABORT\_MSG} (\textcolor{stringliteral}{"ERROR: L2 forwarding loop detected!"});
1524             \}
1525 
1526           \hyperlink{classns3_1_1GlobalRouter_a27297efb3e69712604932d5275ab2abb}{MarkBridgeAsVisited}(bnd);
1527 
1528           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Looking through bridge ports of bridge net device "} << bnd);
1529           \textcolor{keywordflow}{for} (uint32\_t j = 0; j < bnd->GetNBridgePorts (); ++j)
1530             \{
1531               Ptr<NetDevice> ndBridged = bnd->GetBridgePort (j);
1532               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Examining bridge port "} << j << \textcolor{stringliteral}{" device "} << ndBridged);
1533               \textcolor{keywordflow}{if} (ndBridged == ndOther)
1534                 \{
1535                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"That bridge port is me, skip"});
1536                   \textcolor{keywordflow}{continue};
1537                 \}
1538 
1539               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Recursively looking for routers on bridge port "} << ndBridged);
1540               \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1GlobalRouter_ae2af74f394b3b8de4daad7000fb0b9f7}{AnotherRouterOnLink} (ndBridged))
1541                 \{
1542                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Found routers on bridge port, return true"});
1543                   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1544                 \}
1545             \}
1546           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"No routers on bridged net device, return false"});
1547           \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1548         \}
1549 
1550       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"This device is not bridged"});
1551       Ptr<Node> nodeTemp = ndOther->GetNode ();
1552       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (nodeTemp);
1553 
1554       Ptr<GlobalRouter> rtr = nodeTemp->GetObject<\hyperlink{classns3_1_1GlobalRouter_a778050c70fe491c0fe62b7cf6b10aaf6}{GlobalRouter}> ();
1555       \textcolor{keywordflow}{if} (rtr)
1556         \{
1557           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Found GlobalRouter interface, return true"});
1558           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1559         \}
1560       \textcolor{keywordflow}{else} 
1561         \{
1562           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"No GlobalRouter interface on device, continue search"});
1563         \}
1564     \}
1565   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"No routers found, return false"});
1566   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1567 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4




Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Bridge\+Has\+Already\+Been\+Visited@{Bridge\+Has\+Already\+Been\+Visited}}
\index{Bridge\+Has\+Already\+Been\+Visited@{Bridge\+Has\+Already\+Been\+Visited}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Bridge\+Has\+Already\+Been\+Visited(\+Ptr$<$ Bridge\+Net\+Device $>$ device) const }{BridgeHasAlreadyBeenVisited(Ptr< BridgeNetDevice > device) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Global\+Router\+::\+Bridge\+Has\+Already\+Been\+Visited (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Bridge\+Net\+Device} $>$}]{device}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1GlobalRouter_ab358e6c36f04f05c42a4ca2c472c3179}{}\label{classns3_1_1GlobalRouter_ab358e6c36f04f05c42a4ca2c472c3179}
When recursively checking for devices on the link, check whether a given device has already been visited.


\begin{DoxyParams}{Parameters}
{\em device} & the bridge device to check \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if bridge has already been visited 
\end{DoxyReturn}

\begin{DoxyCode}
1812 \{
1813   std::vector<Ptr<BridgeNetDevice> >::iterator iter;
1814   \textcolor{keywordflow}{for} (iter = \hyperlink{classns3_1_1GlobalRouter_ad1b09bb4b76610b276fb065a0cb8dee6}{m\_bridgesVisited}.begin (); iter != 
      \hyperlink{classns3_1_1GlobalRouter_ad1b09bb4b76610b276fb065a0cb8dee6}{m\_bridgesVisited}.end (); ++iter)
1815     \{
1816       \textcolor{keywordflow}{if} (bridgeNetDevice == *iter)
1817         \{
1818           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Bridge "} << bridgeNetDevice << \textcolor{stringliteral}{" has been visited."});
1819           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1820         \}
1821     \}
1822   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1823 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Build\+Network\+L\+S\+As@{Build\+Network\+L\+S\+As}}
\index{Build\+Network\+L\+S\+As@{Build\+Network\+L\+S\+As}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Build\+Network\+L\+S\+As(\+Net\+Device\+Container c)}{BuildNetworkLSAs(NetDeviceContainer c)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Global\+Router\+::\+Build\+Network\+L\+S\+As (
\begin{DoxyParamCaption}
\item[{{\bf Net\+Device\+Container}}]{c}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1GlobalRouter_aff937ae50e8cc2de5a6e989cbe17609b}{}\label{classns3_1_1GlobalRouter_aff937ae50e8cc2de5a6e989cbe17609b}


Build one Network\+L\+SA for each net device talking to a network that we are the designated router for. 


\begin{DoxyParams}{Parameters}
{\em c} & the devices. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1157 \{
1158   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << &\hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c});
1159 
1160   uint32\_t nDesignatedRouters = \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c}.GetN ();
1161   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Number of designated routers: "} << nDesignatedRouters);
1162 
1163   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < nDesignatedRouters; ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
1164     \{
1165       \textcolor{comment}{//}
1166       \textcolor{comment}{// Build one NetworkLSA for each net device talking to a network that we are the }
1167       \textcolor{comment}{// designated router for.  These devices are in the provided container.}
1168       \textcolor{comment}{//}
1169       Ptr<NetDevice> ndLocal = \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c}.Get (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
1170       Ptr<Node> node = ndLocal->GetNode ();
1171 
1172       Ptr<Ipv4> ipv4Local = node->GetObject<Ipv4> ();
1173       \hyperlink{group__fatal_ga0bd3f62c55e7347ff814572f3aaa3864}{NS\_ABORT\_MSG\_UNLESS} (ipv4Local, \textcolor{stringliteral}{"GlobalRouter::ProcessPointToPointLink ():
       GetObject for <Ipv4> interface failed"});
1174 
1175       uint32\_t interfaceLocal = ipv4Local->GetNInterfaces () + 1;
1176       \textcolor{keywordtype}{bool} rc = \hyperlink{classns3_1_1GlobalRouter_a7b30c3c09f93e3f3ac7cfe787b51d127}{FindInterfaceForDevice} (node, ndLocal, interfaceLocal);
1177       \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (rc == \textcolor{keyword}{false}, \textcolor{stringliteral}{"GlobalRouter::BuildNetworkLSAs (): No interface index
       associated with device"});
1178 
1179       \textcolor{keywordflow}{if} (ipv4Local->GetNAddresses (interfaceLocal) > 1)
1180         \{
1181           \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Warning, interface has multiple IP addresses; using only the primary one
      "});
1182         \}
1183       Ipv4Address addrLocal = ipv4Local->GetAddress (interfaceLocal, 0).GetLocal ();
1184       Ipv4Mask maskLocal = ipv4Local->GetAddress (interfaceLocal, 0).GetMask ();
1185 
1186       GlobalRoutingLSA *pLSA = \textcolor{keyword}{new} GlobalRoutingLSA;
1187       \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (pLSA == 0, \textcolor{stringliteral}{"GlobalRouter::BuildNetworkLSAs(): Can't alloc link record
      "});
1188 
1189       pLSA->SetLSType (\hyperlink{classns3_1_1GlobalRoutingLSA_a34eb53a1ed37c877923b74d671224fdeab37398976cdc8ddd08e1428a4700b5b4}{GlobalRoutingLSA::NetworkLSA});
1190       pLSA->SetLinkStateId (addrLocal);
1191       pLSA->SetAdvertisingRouter (\hyperlink{classns3_1_1GlobalRouter_aa107123583f6b2b68c61666a029b4270}{m\_routerId});
1192       pLSA->SetNetworkLSANetworkMask (maskLocal);
1193       pLSA->SetStatus (\hyperlink{classns3_1_1GlobalRoutingLSA_a18bf63da580856fe1cc158aa855af1bda0d9a91161488cead75d479293fd05a94}{GlobalRoutingLSA::LSA\_SPF\_NOT\_EXPLORED});
1194       pLSA->SetNode (node);
1195 
1196       \textcolor{comment}{//}
1197       \textcolor{comment}{// Build a list of AttachedRouters by walking the devices in the channel}
1198       \textcolor{comment}{// and, if we find a node with a GlobalRouter interface and an IPv4 }
1199       \textcolor{comment}{// interface associated with that device, we call it an attached router.}
1200       \textcolor{comment}{//}
1201       \hyperlink{classns3_1_1GlobalRouter_a2519d9ebeb7425ffe4569c6ed0eaf4cf}{ClearBridgesVisited} ();
1202       Ptr<Channel> ch = ndLocal->GetChannel ();
1203       uint32\_t nDevices = ch->GetNDevices ();
1204       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (nDevices);
1205       NetDeviceContainer deviceList = \hyperlink{classns3_1_1GlobalRouter_af1fc3edcc4d14d9344f3b94617da8e85}{FindAllNonBridgedDevicesOnLink} (ch);
1206       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Found "} << deviceList.GetN () << \textcolor{stringliteral}{" non-bridged devices on channel"});
1207 
1208       \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < deviceList.GetN (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
1209         \{
1210           Ptr<NetDevice> tempNd = deviceList.Get (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
1211           \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (tempNd);
1212           \textcolor{keywordflow}{if} (tempNd == ndLocal)
1213             \{
1214               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Adding "} << addrLocal << \textcolor{stringliteral}{" to Network LSA"});
1215               pLSA->AddAttachedRouter (addrLocal);
1216               \textcolor{keywordflow}{continue};
1217             \}
1218           Ptr<Node> tempNode = tempNd->GetNode ();
1219 
1220           \textcolor{comment}{// Does the node in question have a GlobalRouter interface?  If not it can}
1221           \textcolor{comment}{// hardly be considered an attached router.}
1222           \textcolor{comment}{//}
1223           Ptr<GlobalRouter> rtr = tempNode->GetObject<\hyperlink{classns3_1_1GlobalRouter_a778050c70fe491c0fe62b7cf6b10aaf6}{GlobalRouter}> ();
1224           \textcolor{keywordflow}{if} (rtr == 0)
1225             \{ 
1226               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Node "} << tempNode->GetId () << \textcolor{stringliteral}{" does not have GlobalRouter
       interface--skipping"});
1227               \textcolor{keywordflow}{continue};
1228             \}
1229 
1230           \textcolor{comment}{//}
1231           \textcolor{comment}{// Does the attached node have an ipv4 interface for the device we're probing?}
1232           \textcolor{comment}{// If not, it can't play router.}
1233           \textcolor{comment}{//}
1234           uint32\_t tempInterface = 0;
1235           \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1GlobalRouter_a7b30c3c09f93e3f3ac7cfe787b51d127}{FindInterfaceForDevice} (tempNode, tempNd, tempInterface))
1236             \{
1237               Ptr<Ipv4> tempIpv4 = tempNode->GetObject<Ipv4> ();
1238               \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (tempIpv4);
1239               \textcolor{keywordflow}{if} (!tempIpv4->IsUp (tempInterface))
1240                 \{
1241                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Remote side interface "} << tempInterface << \textcolor{stringliteral}{" not up"});
1242                 \}
1243               \textcolor{keywordflow}{else} 
1244                 \{
1245                   \textcolor{keywordflow}{if} (tempIpv4->GetNAddresses (tempInterface) > 1)
1246                     \{
1247                       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Warning, interface has multiple IP addresses; using only the
       primary one"});
1248                     \}
1249                   Ipv4Address tempAddr = tempIpv4->GetAddress (tempInterface, 0).GetLocal ();
1250                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Adding "} << tempAddr << \textcolor{stringliteral}{" to Network LSA"});
1251                   pLSA->AddAttachedRouter (tempAddr);
1252                 \}
1253             \}
1254           \textcolor{keywordflow}{else}
1255             \{
1256               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Node "} << tempNode->GetId () << \textcolor{stringliteral}{" device "} << tempNd << \textcolor{stringliteral}{" does not
       have IPv4 interface; skipping"});
1257             \}
1258         \}
1259       \hyperlink{classns3_1_1GlobalRouter_a5c583d84f810ce4404f54450a0ac18d4}{m\_LSAs}.push\_back (pLSA);
1260       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"========== LSA for node "} << node->GetId () << \textcolor{stringliteral}{" =========="});
1261       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (*pLSA);
1262       pLSA = 0;
1263     \}
1264 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7




Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Clear\+Bridges\+Visited@{Clear\+Bridges\+Visited}}
\index{Clear\+Bridges\+Visited@{Clear\+Bridges\+Visited}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Clear\+Bridges\+Visited(void) const }{ClearBridgesVisited(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Global\+Router\+::\+Clear\+Bridges\+Visited (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1GlobalRouter_a2519d9ebeb7425ffe4569c6ed0eaf4cf}{}\label{classns3_1_1GlobalRouter_a2519d9ebeb7425ffe4569c6ed0eaf4cf}
Clear the list of bridges visited on the link 
\begin{DoxyCode}
1803 \{
1804   \hyperlink{classns3_1_1GlobalRouter_ad1b09bb4b76610b276fb065a0cb8dee6}{m\_bridgesVisited}.clear();
1805 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 9


\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Clear\+L\+S\+As@{Clear\+L\+S\+As}}
\index{Clear\+L\+S\+As@{Clear\+L\+S\+As}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Clear\+L\+S\+As(void)}{ClearLSAs(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Global\+Router\+::\+Clear\+L\+S\+As (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1GlobalRouter_a7c6430b2da06fff5ce1fda4ac90c4836}{}\label{classns3_1_1GlobalRouter_a7c6430b2da06fff5ce1fda4ac90c4836}


Clear list of L\+S\+As. 


\begin{DoxyCode}
561 \{
562   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
563   \textcolor{keywordflow}{for} ( ListOfLSAs\_t::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1GlobalRouter_a5c583d84f810ce4404f54450a0ac18d4}{m\_LSAs}.begin ();
564         \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1GlobalRouter_a5c583d84f810ce4404f54450a0ac18d4}{m\_LSAs}.end (); 
565         \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
566     \{
567       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Free LSA"});
568 
569       GlobalRoutingLSA *\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
570       \textcolor{keyword}{delete} \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p};
571       p = 0;
572 
573       *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0;
574     \}
575   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Clear list of LSAs"});
576   \hyperlink{classns3_1_1GlobalRouter_a5c583d84f810ce4404f54450a0ac18d4}{m\_LSAs}.clear ();
577 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 10


\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Discover\+L\+S\+As@{Discover\+L\+S\+As}}
\index{Discover\+L\+S\+As@{Discover\+L\+S\+As}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Discover\+L\+S\+As(void)}{DiscoverLSAs(void)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Global\+Router\+::\+Discover\+L\+S\+As (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1GlobalRouter_a44e135879879a27cd8d2566b5e9761cf}{}\label{classns3_1_1GlobalRouter_a44e135879879a27cd8d2566b5e9761cf}


Walk the connected channels, discover the adjacent routers and build the associated number of Global Routing Link State Advertisements that this router can export. 

This is a fairly expensive operation in that every time it is called the current list of L\+S\+As is built by walking connected point-\/to-\/point channels and peeking into adjacent I\+P\+V4 stacks to get address information. This is done to allow for limited dynamics of the Global Routing environment. By that we mean that you can discover new link state advertisements after a network topology change by calling Discover\+L\+S\+As and then by reading those advertisements.

\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1GlobalRoutingLSA}{Global\+Routing\+L\+SA} 

\hyperlink{classns3_1_1GlobalRouter_a1ae9d137fabd4fa16b6bc7b292bbadd3}{Global\+Router\+::\+Get\+L\+SA} () 
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
The number of Global Routing Link State Advertisements. 
\end{DoxyReturn}

\begin{DoxyCode}
594 \{
595   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
596   Ptr<Node> node = GetObject<Node> ();
597   \hyperlink{group__fatal_ga0bd3f62c55e7347ff814572f3aaa3864}{NS\_ABORT\_MSG\_UNLESS} (node, \textcolor{stringliteral}{"GlobalRouter::DiscoverLSAs (): GetObject for <Node>
       interface failed"});
598   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"For node "} << node->GetId () );
599 
600   \hyperlink{classns3_1_1GlobalRouter_a7c6430b2da06fff5ce1fda4ac90c4836}{ClearLSAs} ();
601 
602   \textcolor{comment}{//}
603   \textcolor{comment}{// While building the Router-LSA, keep a list of those NetDevices for}
604   \textcolor{comment}{// which the current node is the designated router and we will later build }
605   \textcolor{comment}{// a NetworkLSA for.}
606   \textcolor{comment}{//}
607   NetDeviceContainer \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c};
608 
609   \textcolor{comment}{//}
610   \textcolor{comment}{// We're aggregated to a node.  We need to ask the node for a pointer to its}
611   \textcolor{comment}{// Ipv4 interface.  This is where the information regarding the attached }
612   \textcolor{comment}{// interfaces lives.  If we're a router, we had better have an Ipv4 interface.}
613   \textcolor{comment}{//}
614   Ptr<Ipv4> ipv4Local = node->GetObject<Ipv4> ();
615   \hyperlink{group__fatal_ga0bd3f62c55e7347ff814572f3aaa3864}{NS\_ABORT\_MSG\_UNLESS} (ipv4Local, \textcolor{stringliteral}{"GlobalRouter::DiscoverLSAs (): GetObject for <Ipv4>
       interface failed"});
616 
617   \textcolor{comment}{//}
618   \textcolor{comment}{// Every router node originates a Router-LSA}
619   \textcolor{comment}{//}
620   GlobalRoutingLSA *pLSA = \textcolor{keyword}{new} GlobalRoutingLSA;
621   pLSA->SetLSType (\hyperlink{classns3_1_1GlobalRoutingLSA_a34eb53a1ed37c877923b74d671224fdeada9e6185a392b3bb450846f5282e415d}{GlobalRoutingLSA::RouterLSA});
622   pLSA->SetLinkStateId (\hyperlink{classns3_1_1GlobalRouter_aa107123583f6b2b68c61666a029b4270}{m\_routerId});
623   pLSA->SetAdvertisingRouter (\hyperlink{classns3_1_1GlobalRouter_aa107123583f6b2b68c61666a029b4270}{m\_routerId});
624   pLSA->SetStatus (\hyperlink{classns3_1_1GlobalRoutingLSA_a18bf63da580856fe1cc158aa855af1bda0d9a91161488cead75d479293fd05a94}{GlobalRoutingLSA::LSA\_SPF\_NOT\_EXPLORED});
625   pLSA->SetNode (node);
626 
627   \textcolor{comment}{//}
628   \textcolor{comment}{// Ask the node for the number of net devices attached. This isn't necessarily }
629   \textcolor{comment}{// equal to the number of links to adjacent nodes (other routers) as the number}
630   \textcolor{comment}{// of devices may include those for stub networks (e.g., ethernets, etc.) and }
631   \textcolor{comment}{// bridge devices also take up an "extra" net device.}
632   \textcolor{comment}{//}
633   uint32\_t numDevices = node->GetNDevices ();
634 
635   \textcolor{comment}{//}
636   \textcolor{comment}{// Iterate through the devices on the node and walk the channel to see what's}
637   \textcolor{comment}{// on the other side of the standalone devices..}
638   \textcolor{comment}{//}
639   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < numDevices; ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
640     \{
641       Ptr<NetDevice> ndLocal = node->GetDevice (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
642 
643       \textcolor{keywordflow}{if} (DynamicCast <LoopbackNetDevice> (ndLocal))
644         \{
645           \textcolor{keywordflow}{continue};
646         \}
647 
648       \textcolor{comment}{//}
649       \textcolor{comment}{// There is an assumption that bridge ports must never have an IP address }
650       \textcolor{comment}{// associated with them.  This turns out to be a very convenient place to}
651       \textcolor{comment}{// check and make sure that this is the case.}
652       \textcolor{comment}{//}
653       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1GlobalRouter_ad330b65439cd1be39799b52df948f98b}{NetDeviceIsBridged} (ndLocal))
654         \{
655           \textcolor{comment}{// Initialize to value out of bounds to silence compiler}
656           uint32\_t interfaceBridge = ipv4Local->GetNInterfaces () + 1;
657           \textcolor{keywordtype}{bool} rc = \hyperlink{classns3_1_1GlobalRouter_a7b30c3c09f93e3f3ac7cfe787b51d127}{FindInterfaceForDevice} (node, ndLocal, interfaceBridge);
658           \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (rc, \textcolor{stringliteral}{"GlobalRouter::DiscoverLSAs(): Bridge ports must not have an
       IPv4 interface index"});
659         \}
660 
661       \textcolor{comment}{//}
662       \textcolor{comment}{// Check to see if the net device we just got has a corresponding IP }
663       \textcolor{comment}{// interface (could be a pure L2 NetDevice) -- for example a net device}
664       \textcolor{comment}{// associated with a bridge.  We are only going to involve devices with }
665       \textcolor{comment}{// IP addresses in routing.}
666       \textcolor{comment}{//}
667       \textcolor{keywordtype}{bool} isForwarding = \textcolor{keyword}{false};
668       \textcolor{keywordflow}{for} (uint32\_t j = 0; j < ipv4Local->GetNInterfaces (); ++j )
669         \{
670           \textcolor{keywordflow}{if} (ipv4Local->GetNetDevice (j) == ndLocal && ipv4Local->IsUp (j) &&
671               ipv4Local->IsForwarding (j)) 
672             \{
673               isForwarding = \textcolor{keyword}{true};
674               \textcolor{keywordflow}{break};
675             \}
676         \}
677 
678       \textcolor{keywordflow}{if} (!isForwarding)
679         \{
680           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Net device "} << ndLocal << \textcolor{stringliteral}{"has no IP interface or is not enabled for
       forwarding, skipping"});
681           \textcolor{keywordflow}{continue};
682         \}
683 
684       \textcolor{comment}{//}
685       \textcolor{comment}{// We have a net device that we need to check out.  If it suports }
686       \textcolor{comment}{// broadcast and is not a point-point link, then it will be either a stub }
687       \textcolor{comment}{// network or a transit network depending on the number of routers on}
688       \textcolor{comment}{// the segment.  We add the appropriate link record to the LSA.}
689       \textcolor{comment}{//}
690       \textcolor{comment}{// If the device is a point to point link, we treat it separately.  In}
691       \textcolor{comment}{// that case, there may be zero, one, or two link records added.}
692       \textcolor{comment}{//}
693 
694       \textcolor{keywordflow}{if} (ndLocal->IsBroadcast () && !ndLocal->IsPointToPoint () )
695         \{
696           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Broadcast link"});
697           \hyperlink{classns3_1_1GlobalRouter_af981be58153ef32690b434072cd3205b}{ProcessBroadcastLink} (ndLocal, pLSA, c);
698         \}
699       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ndLocal->IsPointToPoint () )
700         \{
701           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Point=to-point link"});
702           \hyperlink{classns3_1_1GlobalRouter_adaf99c499d6e42e450a31b53a8019b14}{ProcessPointToPointLink} (ndLocal, pLSA);
703         \}
704       \textcolor{keywordflow}{else}
705         \{
706           \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (0, \textcolor{stringliteral}{"GlobalRouter::DiscoverLSAs (): unknown link type"});
707         \}
708     \}
709 
710   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"========== LSA for node "} << node->GetId () << \textcolor{stringliteral}{" =========="});
711   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (*pLSA);
712   \hyperlink{classns3_1_1GlobalRouter_a5c583d84f810ce4404f54450a0ac18d4}{m\_LSAs}.push\_back (pLSA);
713   pLSA = 0;
714 
715   \textcolor{comment}{// }
716   \textcolor{comment}{// Now, determine whether we need to build a NetworkLSA.  This is the case if}
717   \textcolor{comment}{// we found at least one designated router.}
718   \textcolor{comment}{//}
719   uint32\_t nDesignatedRouters = c.GetN ();
720   \textcolor{keywordflow}{if} (nDesignatedRouters > 0)
721     \{
722       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Build Network LSAs"});
723       \hyperlink{classns3_1_1GlobalRouter_aff937ae50e8cc2de5a6e989cbe17609b}{BuildNetworkLSAs} (c);
724     \}
725 
726   \textcolor{comment}{//}
727   \textcolor{comment}{// Build injected route LSAs as external routes}
728   \textcolor{comment}{// RFC 2328, section 12.4.4}
729   \textcolor{comment}{//}
730   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1GlobalRouter_aea87fa6405b7c0e2bd56adfcf37823a8}{InjectedRoutesCI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1GlobalRouter_a2d1dd8dbb1bc813f24bff2fb2f0cde7f}{m\_injectedRoutes}.begin ();
731        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1GlobalRouter_a2d1dd8dbb1bc813f24bff2fb2f0cde7f}{m\_injectedRoutes}.end ();
732        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
733     \{
734       GlobalRoutingLSA *pLSA = \textcolor{keyword}{new} GlobalRoutingLSA;
735       pLSA->SetLSType (\hyperlink{classns3_1_1GlobalRoutingLSA_a34eb53a1ed37c877923b74d671224fdea695b98ad474baaa5f11ff5bb06048ec7}{GlobalRoutingLSA::ASExternalLSAs});
736       pLSA->SetLinkStateId ((*i)->GetDestNetwork ());
737       pLSA->SetAdvertisingRouter (\hyperlink{classns3_1_1GlobalRouter_aa107123583f6b2b68c61666a029b4270}{m\_routerId});
738       pLSA->SetNetworkLSANetworkMask ((*i)->GetDestNetworkMask ());
739       pLSA->SetStatus (\hyperlink{classns3_1_1GlobalRoutingLSA_a18bf63da580856fe1cc158aa855af1bda0d9a91161488cead75d479293fd05a94}{GlobalRoutingLSA::LSA\_SPF\_NOT\_EXPLORED});
740       \hyperlink{classns3_1_1GlobalRouter_a5c583d84f810ce4404f54450a0ac18d4}{m\_LSAs}.push\_back (pLSA); 
741     \}
742   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1GlobalRouter_a5c583d84f810ce4404f54450a0ac18d4}{m\_LSAs}.size ();
743 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 11


\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Do\+Dispose(void)}{DoDispose(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Global\+Router\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1GlobalRouter_a19d984861cd9f427781d291c57f7b1c6}{}\label{classns3_1_1GlobalRouter_a19d984861cd9f427781d291c57f7b1c6}
Destructor implementation.

This method is called by \hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose()} or by the \hyperlink{classns3_1_1Object}{Object}\textquotesingle{}s destructor, whichever comes first.

Subclasses are expected to implement their real destruction code in an overriden version of this method and chain up to their parent\textquotesingle{}s implementation once they are done. {\itshape i.\+e}, for simplicity, the destructor of every subclass should be empty and its content should be moved to the associated \hyperlink{classns3_1_1GlobalRouter_a19d984861cd9f427781d291c57f7b1c6}{Do\+Dispose()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.


\begin{DoxyCode}
547 \{
548   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
549   \hyperlink{classns3_1_1GlobalRouter_a0a18bfb8e4f788c0e3027dcc603155a4}{m\_routingProtocol} = 0;
550   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1GlobalRouter_ac4ed7a61065c866b6f52abcdb2f29711}{InjectedRoutesI} k = \hyperlink{classns3_1_1GlobalRouter_a2d1dd8dbb1bc813f24bff2fb2f0cde7f}{m\_injectedRoutes}.begin ();
551        k != \hyperlink{classns3_1_1GlobalRouter_a2d1dd8dbb1bc813f24bff2fb2f0cde7f}{m\_injectedRoutes}.end ();
552        k = \hyperlink{classns3_1_1GlobalRouter_a2d1dd8dbb1bc813f24bff2fb2f0cde7f}{m\_injectedRoutes}.erase (k))
553     \{
554       \textcolor{keyword}{delete} (*k);
555     \}
556   \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{Object::DoDispose} ();
557 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12


\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Find\+All\+Non\+Bridged\+Devices\+On\+Link@{Find\+All\+Non\+Bridged\+Devices\+On\+Link}}
\index{Find\+All\+Non\+Bridged\+Devices\+On\+Link@{Find\+All\+Non\+Bridged\+Devices\+On\+Link}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Find\+All\+Non\+Bridged\+Devices\+On\+Link(\+Ptr$<$ Channel $>$ ch) const }{FindAllNonBridgedDevicesOnLink(Ptr< Channel > ch) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Net\+Device\+Container} ns3\+::\+Global\+Router\+::\+Find\+All\+Non\+Bridged\+Devices\+On\+Link (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Channel} $>$}]{ch}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1GlobalRouter_af1fc3edcc4d14d9344f3b94617da8e85}{}\label{classns3_1_1GlobalRouter_af1fc3edcc4d14d9344f3b94617da8e85}


Return a container of all non-\/bridged Net\+Devices on a link. 

This method will recursively find all of the \textquotesingle{}edge\textquotesingle{} devices in an L2 broadcast domain. If there are no bridged devices, then the container returned is simply the set of devices on the channel passed in as an argument. If the link has bridges on it (and therefore multiple \hyperlink{classns3_1_1Channel}{ns3\+::\+Channel} objects interconnected by bridges), the method will find all of the non-\/bridged devices in the L2 broadcast domain.


\begin{DoxyParams}{Parameters}
{\em ch} & a channel from the link \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container}. 
\end{DoxyReturn}

\begin{DoxyCode}
1268 \{
1269   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << ch);
1270   NetDeviceContainer \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c};
1271 
1272   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < ch->GetNDevices (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
1273     \{
1274       Ptr<NetDevice> nd = ch->GetDevice (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
1275       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"checking to see if the device "} << nd << \textcolor{stringliteral}{" is bridged"});
1276       Ptr<BridgeNetDevice> bnd = \hyperlink{classns3_1_1GlobalRouter_ad330b65439cd1be39799b52df948f98b}{NetDeviceIsBridged} (nd);
1277       \textcolor{keywordflow}{if} (bnd && \hyperlink{classns3_1_1GlobalRouter_ab358e6c36f04f05c42a4ca2c472c3179}{BridgeHasAlreadyBeenVisited} (bnd) == \textcolor{keyword}{false})
1278         \{
1279           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Device is bridged by BridgeNetDevice "} << bnd << \textcolor{stringliteral}{" with "} << bnd->
      GetNBridgePorts () << \textcolor{stringliteral}{" ports"});
1280           \hyperlink{classns3_1_1GlobalRouter_a27297efb3e69712604932d5275ab2abb}{MarkBridgeAsVisited} (bnd);
1281           \textcolor{comment}{// Find all channels bridged together, and recursively call}
1282           \textcolor{comment}{// on all other channels}
1283           \textcolor{keywordflow}{for} (uint32\_t j = 0; j < bnd->GetNBridgePorts (); j++)
1284             \{
1285               Ptr<NetDevice> bridgedDevice = bnd->GetBridgePort (j);
1286               \textcolor{keywordflow}{if} (bridgedDevice->GetChannel () == ch)
1287                 \{
1288                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Skipping my own device/channel"});
1289                   \textcolor{keywordflow}{continue};
1290                 \}
1291               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Calling on channel "} << bridgedDevice->GetChannel ());
1292               c.Add (\hyperlink{classns3_1_1GlobalRouter_af1fc3edcc4d14d9344f3b94617da8e85}{FindAllNonBridgedDevicesOnLink} (bridgedDevice->
      GetChannel ()));
1293             \}
1294         \}
1295       \textcolor{keywordflow}{else}
1296         \{
1297           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Device is not bridged; adding"});
1298           c.Add (nd);
1299         \}
1300     \}
1301   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Found "} << c.GetN () << \textcolor{stringliteral}{" devices"});
1302   \textcolor{keywordflow}{return} \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c};
1303 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13




Here is the caller graph for this function\+:
% FIG 14


\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Find\+Designated\+Router\+For\+Link@{Find\+Designated\+Router\+For\+Link}}
\index{Find\+Designated\+Router\+For\+Link@{Find\+Designated\+Router\+For\+Link}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Find\+Designated\+Router\+For\+Link(\+Ptr$<$ Net\+Device $>$ nd\+Local) const }{FindDesignatedRouterForLink(Ptr< NetDevice > ndLocal) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Address} ns3\+::\+Global\+Router\+::\+Find\+Designated\+Router\+For\+Link (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{nd\+Local}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1GlobalRouter_ab562e4407394674ef8502b3ab1d051d6}{}\label{classns3_1_1GlobalRouter_ab562e4407394674ef8502b3ab1d051d6}


Finds a designated router. 

Given a local net device, we need to walk the channel to which the net device is attached and look for nodes with \hyperlink{classns3_1_1GlobalRouter}{Global\+Router} interfaces on them (one of them will be us). Of these, the router with the lowest IP address on the net device connecting to the channel becomes the designated router for the link.


\begin{DoxyParams}{Parameters}
{\em nd\+Local} & local \hyperlink{classns3_1_1NetDevice}{Net\+Device} to scan \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the IP address of the designated router 
\end{DoxyReturn}

\begin{DoxyCode}
1313 \{
1314   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << ndLocal);
1315 
1316   Ptr<Channel> ch = ndLocal->GetChannel ();
1317   uint32\_t nDevices = ch->GetNDevices ();
1318   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (nDevices);
1319 
1320   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Looking for designated router off of net device "} << ndLocal << \textcolor{stringliteral}{" on node "} <<
       
1321                 ndLocal->GetNode ()->GetId ());
1322 
1323   Ipv4Address desigRtr (\textcolor{stringliteral}{"255.255.255.255"});
1324 
1325   \textcolor{comment}{//}
1326   \textcolor{comment}{// Look through all of the devices on the channel to which the net device}
1327   \textcolor{comment}{// in question is attached.}
1328   \textcolor{comment}{//}
1329   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < nDevices; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
1330     \{
1331       Ptr<NetDevice> ndOther = ch->GetDevice (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
1332       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (ndOther);
1333 
1334       Ptr<Node> nodeOther = ndOther->GetNode ();
1335 
1336       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Examine channel device "} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} << \textcolor{stringliteral}{" on node "} << nodeOther->GetId ());
1337 
1338       \textcolor{comment}{//}
1339       \textcolor{comment}{// For all other net devices, we need to check and see if a router}
1340       \textcolor{comment}{// is present.  If the net device on the other side is a bridged}
1341       \textcolor{comment}{// device, we need to consider all of the other devices on the }
1342       \textcolor{comment}{// bridge as well (all of the bridge ports.}
1343       \textcolor{comment}{//}
1344       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"checking to see if the device is bridged"});
1345       Ptr<BridgeNetDevice> bnd = \hyperlink{classns3_1_1GlobalRouter_ad330b65439cd1be39799b52df948f98b}{NetDeviceIsBridged} (ndOther);
1346       \textcolor{keywordflow}{if} (bnd)
1347         \{
1348           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Device is bridged by BridgeNetDevice "} << bnd);
1349 
1350           \textcolor{comment}{//}
1351           \textcolor{comment}{// When enumerating a bridge, don't count the netdevice we came in on}
1352           \textcolor{comment}{//}
1353           \textcolor{keywordflow}{if} (ndLocal == ndOther)
1354             \{
1355               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Skip -- it is where we came from."});
1356               \textcolor{keywordflow}{continue};
1357             \}
1358 
1359           \textcolor{comment}{//}
1360           \textcolor{comment}{// It is possible that the bridge net device is sitting under a}
1361           \textcolor{comment}{// router, so we have to check for the presence of that router}
1362           \textcolor{comment}{// before we run off and follow all the links}
1363           \textcolor{comment}{//}
1364           \textcolor{comment}{// We require a designated router to have a GlobalRouter interface and}
1365           \textcolor{comment}{// an internet stack that includes the Ipv4 interface.  If it doesn't}
1366           \textcolor{comment}{// it can't play router.}
1367           \textcolor{comment}{//}
1368           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Checking for router on bridge net device "} << bnd);
1369           Ptr<GlobalRouter> rtr = nodeOther->GetObject<\hyperlink{classns3_1_1GlobalRouter_a778050c70fe491c0fe62b7cf6b10aaf6}{GlobalRouter}> ();
1370           Ptr<Ipv4> ipv4 = nodeOther->GetObject<Ipv4> ();
1371           \textcolor{keywordflow}{if} (rtr && ipv4)
1372             \{
1373               \textcolor{comment}{// Initialize to value out of bounds to silence compiler}
1374               uint32\_t interfaceOther = ipv4->GetNInterfaces () + 1;
1375               \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1GlobalRouter_a7b30c3c09f93e3f3ac7cfe787b51d127}{FindInterfaceForDevice} (nodeOther, bnd, interfaceOther))
1376                 \{
1377                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Found router on bridge net device "} << bnd);
1378                   \textcolor{keywordflow}{if} (!ipv4->IsUp (interfaceOther))
1379                     \{
1380                       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Remote side interface "} << interfaceOther << \textcolor{stringliteral}{" not up"});
1381                       \textcolor{keywordflow}{continue};
1382                     \}
1383                   \textcolor{keywordflow}{if} (ipv4->GetNAddresses (interfaceOther) > 1)
1384                     \{
1385                       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Warning, interface has multiple IP addresses; using only the
       primary one"});
1386                     \}
1387                   Ipv4Address addrOther = ipv4->GetAddress (interfaceOther, 0).GetLocal ();
1388                   desigRtr = addrOther < desigRtr ? addrOther : desigRtr;
1389                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"designated router now "} << desigRtr);
1390                 \}
1391             \}
1392 
1393           \textcolor{comment}{// }
1394           \textcolor{comment}{// Check if we have seen this bridge net device already while}
1395           \textcolor{comment}{// recursively enumerating an L2 broadcast domain. If it is new }
1396           \textcolor{comment}{// to us, go ahead and process it. If we have already processed it,}
1397           \textcolor{comment}{// move to the next}
1398           \textcolor{comment}{// }
1399           \textcolor{keywordflow}{if}(\hyperlink{classns3_1_1GlobalRouter_ab358e6c36f04f05c42a4ca2c472c3179}{BridgeHasAlreadyBeenVisited}(bnd))
1400             \{
1401               \hyperlink{group__fatal_ga51ac4699be799d772ae7258d1ef6af21}{NS\_ABORT\_MSG} (\textcolor{stringliteral}{"ERROR: L2 forwarding loop detected!"});
1402             \}
1403 
1404           \hyperlink{classns3_1_1GlobalRouter_a27297efb3e69712604932d5275ab2abb}{MarkBridgeAsVisited}(bnd);
1405 
1406           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Looking through bridge ports of bridge net device "} << bnd);
1407           \textcolor{keywordflow}{for} (uint32\_t j = 0; j < bnd->GetNBridgePorts (); ++j)
1408             \{
1409               Ptr<NetDevice> ndBridged = bnd->GetBridgePort (j);
1410               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Examining bridge port "} << j << \textcolor{stringliteral}{" device "} << ndBridged);
1411               \textcolor{keywordflow}{if} (ndBridged == ndOther)
1412                 \{
1413                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"That bridge port is me, don't walk backward"});
1414                   \textcolor{keywordflow}{continue};
1415                 \}
1416 
1417               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Recursively looking for routers down bridge port "} << ndBridged);
1418               Ipv4Address addrOther = \hyperlink{classns3_1_1GlobalRouter_ab562e4407394674ef8502b3ab1d051d6}{FindDesignatedRouterForLink} (ndBridged);
1419               desigRtr = addrOther < desigRtr ? addrOther : desigRtr;
1420               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"designated router now "} << desigRtr);
1421             \}
1422         \}
1423       \textcolor{keywordflow}{else}
1424         \{
1425           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"This device is not bridged"});
1426           Ptr<Node> nodeOther = ndOther->GetNode ();
1427           \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (nodeOther);
1428 
1429           \textcolor{comment}{//}
1430           \textcolor{comment}{// We require a designated router to have a GlobalRouter interface and}
1431           \textcolor{comment}{// an internet stack that includes the Ipv4 interface.  If it doesn't}
1432           \textcolor{comment}{//}
1433           Ptr<GlobalRouter> rtr = nodeOther->GetObject<\hyperlink{classns3_1_1GlobalRouter_a778050c70fe491c0fe62b7cf6b10aaf6}{GlobalRouter}> ();
1434           Ptr<Ipv4> ipv4 = nodeOther->GetObject<Ipv4> ();
1435           \textcolor{keywordflow}{if} (rtr && ipv4)
1436             \{
1437               \textcolor{comment}{// Initialize to value out of bounds to silence compiler}
1438               uint32\_t interfaceOther = ipv4->GetNInterfaces () + 1;
1439               \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1GlobalRouter_a7b30c3c09f93e3f3ac7cfe787b51d127}{FindInterfaceForDevice} (nodeOther, ndOther, interfaceOther))
1440                 \{
1441                   \textcolor{keywordflow}{if} (!ipv4->IsUp (interfaceOther))
1442                     \{
1443                       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Remote side interface "} << interfaceOther << \textcolor{stringliteral}{" not up"});
1444                       \textcolor{keywordflow}{continue};
1445                     \}
1446                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Found router on net device "} << ndOther);
1447                   \textcolor{keywordflow}{if} (ipv4->GetNAddresses (interfaceOther) > 1)
1448                     \{
1449                       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Warning, interface has multiple IP addresses; using only the
       primary one"});
1450                     \}
1451                   Ipv4Address addrOther = ipv4->GetAddress (interfaceOther, 0).GetLocal ();
1452                   desigRtr = addrOther < desigRtr ? addrOther : desigRtr;
1453                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"designated router now "} << desigRtr);
1454                 \}
1455             \}
1456         \}
1457     \}
1458   \textcolor{keywordflow}{return} desigRtr;
1459 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 15




Here is the caller graph for this function\+:
% FIG 16


\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Find\+Interface\+For\+Device@{Find\+Interface\+For\+Device}}
\index{Find\+Interface\+For\+Device@{Find\+Interface\+For\+Device}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Find\+Interface\+For\+Device(\+Ptr$<$ Node $>$ node, Ptr$<$ Net\+Device $>$ nd, uint32\+\_\+t \&index) const }{FindInterfaceForDevice(Ptr< Node > node, Ptr< NetDevice > nd, uint32_t &index) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Global\+Router\+::\+Find\+Interface\+For\+Device (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{nd, }
\item[{uint32\+\_\+t \&}]{index}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1GlobalRouter_a7b30c3c09f93e3f3ac7cfe787b51d127}{}\label{classns3_1_1GlobalRouter_a7b30c3c09f93e3f3ac7cfe787b51d127}


Given a node and a net device, find an I\+P\+V4 interface index that corresponds to that net device. 

This function may fail for various reasons. If a node does not have an internet stack (for example if it is a bridge) we won\textquotesingle{}t have an I\+Pv4 at all. If the node does have a stack, but the net device in question is bridged, there will not be an interface associated directly with the device.


\begin{DoxyParams}{Parameters}
{\em node} & the node \\
\hline
{\em nd} & outgoing \hyperlink{classns3_1_1NetDevice}{Net\+Device} \\
\hline
{\em index} & the I\+P\+V4 interface index \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success 
\end{DoxyReturn}

\begin{DoxyCode}
1730 \{
1731   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << node << nd << &index);
1732   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"For node "} << node->\hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} () << \textcolor{stringliteral}{" for net device "} << nd );
1733 
1734   Ptr<Ipv4> ipv4 = node->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv4> ();
1735   \textcolor{keywordflow}{if} (ipv4 == 0)
1736     \{
1737       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"No Ipv4 interface on node "} << node->\hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} ());
1738       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1739     \}
1740 
1741   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < ipv4->GetNInterfaces (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} )
1742     \{
1743       \textcolor{keywordflow}{if} (ipv4->GetNetDevice (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) == nd)
1744         \{
1745           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Device "} << nd << \textcolor{stringliteral}{" has associated ipv4 index "} << 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
1746           index = \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
1747           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1748         \}
1749     \}
1750 
1751   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Device "} << nd << \textcolor{stringliteral}{" has no associated ipv4 index"});
1752   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1753 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 17




Here is the caller graph for this function\+:
% FIG 18


\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Get\+Adjacent@{Get\+Adjacent}}
\index{Get\+Adjacent@{Get\+Adjacent}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Get\+Adjacent(\+Ptr$<$ Net\+Device $>$ nd, Ptr$<$ Channel $>$ ch) const }{GetAdjacent(Ptr< NetDevice > nd, Ptr< Channel > ch) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Net\+Device} $>$ ns3\+::\+Global\+Router\+::\+Get\+Adjacent (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{nd, }
\item[{{\bf Ptr}$<$ {\bf Channel} $>$}]{ch}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1GlobalRouter_a347a9eb0edc5b923d6d3a3614e48769f}{}\label{classns3_1_1GlobalRouter_a347a9eb0edc5b923d6d3a3614e48769f}


Link through the given channel and find the net device that\textquotesingle{}s on the other end. 

This only makes sense with a point-\/to-\/point channel.


\begin{DoxyParams}{Parameters}
{\em nd} & outgoing \hyperlink{classns3_1_1NetDevice}{Net\+Device} \\
\hline
{\em ch} & channel \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the \hyperlink{classns3_1_1NetDevice}{Net\+Device} on the other end 
\end{DoxyReturn}

\begin{DoxyCode}
1692 \{
1693   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << nd << ch);
1694   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (ch->GetNDevices () == 2, \textcolor{stringliteral}{"GlobalRouter::GetAdjacent (): Channel with other
       than two devices"});
1695 \textcolor{comment}{//}
1696 \textcolor{comment}{// This is a point to point channel with two endpoints.  Get both of them.}
1697 \textcolor{comment}{//}
1698   Ptr<NetDevice> nd1 = ch->GetDevice (0);
1699   Ptr<NetDevice> nd2 = ch->GetDevice (1);
1700 \textcolor{comment}{//}
1701 \textcolor{comment}{// One of the endpoints is going to be "us" -- that is the net device attached}
1702 \textcolor{comment}{// to the node on which we're running -- i.e., "nd".  The other endpoint (the}
1703 \textcolor{comment}{// one to which we are connected via the channel) is the adjacent router.}
1704 \textcolor{comment}{//}
1705   \textcolor{keywordflow}{if} (nd1 == nd)
1706     \{
1707       \textcolor{keywordflow}{return} nd2;
1708     \}
1709   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (nd2 == nd)
1710     \{
1711       \textcolor{keywordflow}{return} nd1;
1712     \}
1713   \textcolor{keywordflow}{else}
1714     \{
1715       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\textcolor{keyword}{false},
1716                      \textcolor{stringliteral}{"GlobalRouter::GetAdjacent (): Wrong or confused channel?"});
1717       \textcolor{keywordflow}{return} 0;
1718     \}
1719 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 19


\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Get\+Injected\+Route@{Get\+Injected\+Route}}
\index{Get\+Injected\+Route@{Get\+Injected\+Route}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Get\+Injected\+Route(uint32\+\_\+t i)}{GetInjectedRoute(uint32_t i)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Routing\+Table\+Entry} $\ast$ ns3\+::\+Global\+Router\+::\+Get\+Injected\+Route (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1GlobalRouter_a7fa5ef8dea5f91441b394cb4fa752112}{}\label{classns3_1_1GlobalRouter_a7fa5ef8dea5f91441b394cb4fa752112}


Return the injected route indexed by i. 


\begin{DoxyParams}{Parameters}
{\em i} & the index of the route \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a pointer to that \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} is returned 
\end{DoxyReturn}

\begin{DoxyCode}
1621 \{
1622   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << index);
1623   \textcolor{keywordflow}{if} (index < \hyperlink{classns3_1_1GlobalRouter_a2d1dd8dbb1bc813f24bff2fb2f0cde7f}{m\_injectedRoutes}.size ())
1624     \{
1625       uint32\_t tmp = 0;
1626       \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1GlobalRouter_aea87fa6405b7c0e2bd56adfcf37823a8}{InjectedRoutesCI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1GlobalRouter_a2d1dd8dbb1bc813f24bff2fb2f0cde7f}{m\_injectedRoutes}.begin ();
1627            \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1GlobalRouter_a2d1dd8dbb1bc813f24bff2fb2f0cde7f}{m\_injectedRoutes}.end ();
1628            \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
1629         \{
1630           \textcolor{keywordflow}{if} (tmp  == index)
1631             \{
1632               \textcolor{keywordflow}{return} *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
1633             \}
1634           tmp++;
1635         \}
1636     \}
1637   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\textcolor{keyword}{false});
1638   \textcolor{comment}{// quiet compiler.}
1639   \textcolor{keywordflow}{return} 0;
1640 \}
\end{DoxyCode}
\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Get\+L\+SA@{Get\+L\+SA}}
\index{Get\+L\+SA@{Get\+L\+SA}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Get\+L\+S\+A(uint32\+\_\+t n, Global\+Routing\+L\+S\+A \&lsa) const }{GetLSA(uint32_t n, GlobalRoutingLSA &lsa) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Global\+Router\+::\+Get\+L\+SA (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{n, }
\item[{{\bf Global\+Routing\+L\+SA} \&}]{lsa}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1GlobalRouter_a1ae9d137fabd4fa16b6bc7b292bbadd3}{}\label{classns3_1_1GlobalRouter_a1ae9d137fabd4fa16b6bc7b292bbadd3}


Get a Global Routing Link State Advertisements that this router has said that it can export. 

This is a fairly inexpensive expensive operation in that the hard work was done in Get\+Num\+L\+S\+As. We just copy the indicated Global Routing Link State Advertisement into the requested \hyperlink{classns3_1_1GlobalRoutingLSA}{Global\+Routing\+L\+SA} object.

You must call \hyperlink{classns3_1_1GlobalRouter_addd8a89e462a36660a3f68dec959bb19}{Global\+Router\+::\+Get\+Num\+L\+S\+As} before calling this method in order to discover the adjacent routers and build the advertisements. Get\+Num\+L\+S\+As will return the number of L\+S\+As this router advertises. The parameter n (requested L\+SA number) must be in the range 0 to \hyperlink{classns3_1_1GlobalRouter_addd8a89e462a36660a3f68dec959bb19}{Get\+Num\+L\+S\+As()} -\/ 1.

\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1GlobalRoutingLSA}{Global\+Routing\+L\+SA} 

Global\+Routing\+::\+Get\+Num\+L\+S\+As () 
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em n} & The index number of the L\+SA you want to read. \\
\hline
{\em lsa} & The \hyperlink{classns3_1_1GlobalRoutingLSA}{Global\+Routing\+L\+SA} class to receive the L\+SA information. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of Global Router Link State Advertisements. 
\end{DoxyReturn}

\begin{DoxyCode}
1581 \{
1582   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{namespacesample-rng-plot_aeb5ee5c431e338ef39b7ac5431242e1d}{n} << &lsa);
1583   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (lsa.IsEmpty (), \textcolor{stringliteral}{"GlobalRouter::GetLSA (): Must pass empty LSA"});
1584 \textcolor{comment}{//}
1585 \textcolor{comment}{// All of the work was done in GetNumLSAs.  All we have to do here is to}
1586 \textcolor{comment}{// walk the list of link state advertisements created there and return the }
1587 \textcolor{comment}{// one the client is interested in.}
1588 \textcolor{comment}{//}
1589   ListOfLSAs\_t::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1GlobalRouter_a5c583d84f810ce4404f54450a0ac18d4}{m\_LSAs}.begin ();
1590   uint32\_t j = 0;
1591 
1592   \textcolor{keywordflow}{for} (; i != \hyperlink{classns3_1_1GlobalRouter_a5c583d84f810ce4404f54450a0ac18d4}{m\_LSAs}.end (); i++, j++)
1593     \{
1594       \textcolor{keywordflow}{if} (j == \hyperlink{namespacesample-rng-plot_aeb5ee5c431e338ef39b7ac5431242e1d}{n})
1595         \{
1596           GlobalRoutingLSA *\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
1597           lsa = *\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p};
1598           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1599         \}
1600     \}
1601 
1602   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1603 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 20


\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Get\+N\+Injected\+Routes@{Get\+N\+Injected\+Routes}}
\index{Get\+N\+Injected\+Routes@{Get\+N\+Injected\+Routes}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Get\+N\+Injected\+Routes(void)}{GetNInjectedRoutes(void)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Global\+Router\+::\+Get\+N\+Injected\+Routes (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1GlobalRouter_a5b28018cadfa511cc9d5b58506f65321}{}\label{classns3_1_1GlobalRouter_a5b28018cadfa511cc9d5b58506f65321}


Get the number of injected routes that have been added to the routing table. 

\begin{DoxyReturn}{Returns}
number of injected routes 
\end{DoxyReturn}

\begin{DoxyCode}
1644 \{
1645   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1646   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1GlobalRouter_a2d1dd8dbb1bc813f24bff2fb2f0cde7f}{m\_injectedRoutes}.size ();
1647 \}
\end{DoxyCode}
\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Get\+Num\+L\+S\+As@{Get\+Num\+L\+S\+As}}
\index{Get\+Num\+L\+S\+As@{Get\+Num\+L\+S\+As}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Get\+Num\+L\+S\+As(void) const }{GetNumLSAs(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Global\+Router\+::\+Get\+Num\+L\+S\+As (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1GlobalRouter_addd8a89e462a36660a3f68dec959bb19}{}\label{classns3_1_1GlobalRouter_addd8a89e462a36660a3f68dec959bb19}


Get the Number of Global Routing Link State Advertisements that this router can export. 

To get meaningful information you must have previously called Discover\+L\+S\+As. After you know how many L\+S\+As are present in the router, you may call Get\+L\+SA () to retrieve the actual advertisement.

\begin{DoxySeeAlso}{See also}
Global\+Router\+L\+SA 

Global\+Routing\+::\+Discover\+L\+S\+As () 

Global\+Routing\+::\+Get\+L\+SA () 
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
The number of Global Routing Link State Advertisements. 
\end{DoxyReturn}

\begin{DoxyCode}
1571 \{
1572   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1573   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1GlobalRouter_a5c583d84f810ce4404f54450a0ac18d4}{m\_LSAs}.size ();
1574 \}
\end{DoxyCode}
\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Get\+Router\+Id@{Get\+Router\+Id}}
\index{Get\+Router\+Id@{Get\+Router\+Id}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Get\+Router\+Id(void) const }{GetRouterId(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Address} ns3\+::\+Global\+Router\+::\+Get\+Router\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1GlobalRouter_a746a83343a6868e415f29ceed9dc0cd0}{}\label{classns3_1_1GlobalRouter_a746a83343a6868e415f29ceed9dc0cd0}


Get the Router ID associated with this Global Router. 

The Router I\+Ds are allocated in the Routing\+Environment -- one per Router, starting at 0.\+0.\+0.\+1 and incrementing with each instantiation of a router.

\begin{DoxySeeAlso}{See also}
Routing\+Environment\+::\+Allocate\+Router\+Id () 
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
The Router ID associated with the Global Router. 
\end{DoxyReturn}

\begin{DoxyCode}
581 \{
582   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
583   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1GlobalRouter_aa107123583f6b2b68c61666a029b4270}{m\_routerId};
584 \}
\end{DoxyCode}
\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Get\+Routing\+Protocol@{Get\+Routing\+Protocol}}
\index{Get\+Routing\+Protocol@{Get\+Routing\+Protocol}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Get\+Routing\+Protocol(void)}{GetRoutingProtocol(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv4\+Global\+Routing} $>$ ns3\+::\+Global\+Router\+::\+Get\+Routing\+Protocol (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1GlobalRouter_a720ae2fce6e8a8a6ac4ae8c69b2a6715}{}\label{classns3_1_1GlobalRouter_a720ae2fce6e8a8a6ac4ae8c69b2a6715}


Get the specific Global Routing Protocol used. 

\begin{DoxyReturn}{Returns}
the routing protocol 
\end{DoxyReturn}

\begin{DoxyCode}
540 \{
541   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
542   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1GlobalRouter_a0a18bfb8e4f788c0e3027dcc603155a4}{m\_routingProtocol};
543 \}
\end{DoxyCode}
\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Global\+Router\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1GlobalRouter_a0154feb219f179c98f57ce14e966fc28}{}\label{classns3_1_1GlobalRouter_a0154feb219f179c98f57ce14e966fc28}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
512 \{
513   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::GlobalRouter"})
514     .SetParent<\hyperlink{classns3_1_1Object_a40860402e64d8008fb42329df7097cdb}{Object}> ()
515     .SetGroupName (\textcolor{stringliteral}{"Internet"});
516   \textcolor{keywordflow}{return} tid;
517 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 21


\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Inject\+Route@{Inject\+Route}}
\index{Inject\+Route@{Inject\+Route}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Inject\+Route(\+Ipv4\+Address network, Ipv4\+Mask network\+Mask)}{InjectRoute(Ipv4Address network, Ipv4Mask networkMask)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Global\+Router\+::\+Inject\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{network, }
\item[{{\bf Ipv4\+Mask}}]{network\+Mask}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1GlobalRouter_a393647cfce742040c6adab116777695f}{}\label{classns3_1_1GlobalRouter_a393647cfce742040c6adab116777695f}


Inject a route to be circulated to other routers as an external route. 


\begin{DoxyParams}{Parameters}
{\em network} & The Network to inject \\
\hline
{\em network\+Mask} & The Network Mask to inject \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1607 \{
1608   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << network << networkMask);
1609   Ipv4RoutingTableEntry *route = \textcolor{keyword}{new} Ipv4RoutingTableEntry ();
1610 \textcolor{comment}{//}
1611 \textcolor{comment}{// Interface number does not matter here, using 1.}
1612 \textcolor{comment}{//}
1613   *route = \hyperlink{classns3_1_1Ipv4RoutingTableEntry_abe3447a00495ded05ab095673531947a}{Ipv4RoutingTableEntry::CreateNetworkRouteTo} (network,
1614                                                         networkMask,
1615                                                         1);
1616   \hyperlink{classns3_1_1GlobalRouter_a2d1dd8dbb1bc813f24bff2fb2f0cde7f}{m\_injectedRoutes}.push\_back (route);
1617 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 22


\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Mark\+Bridge\+As\+Visited@{Mark\+Bridge\+As\+Visited}}
\index{Mark\+Bridge\+As\+Visited@{Mark\+Bridge\+As\+Visited}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Mark\+Bridge\+As\+Visited(\+Ptr$<$ Bridge\+Net\+Device $>$ device) const }{MarkBridgeAsVisited(Ptr< BridgeNetDevice > device) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Global\+Router\+::\+Mark\+Bridge\+As\+Visited (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Bridge\+Net\+Device} $>$}]{device}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1GlobalRouter_a27297efb3e69712604932d5275ab2abb}{}\label{classns3_1_1GlobalRouter_a27297efb3e69712604932d5275ab2abb}
When recursively checking for devices on the link, mark a given device as having been visited.


\begin{DoxyParams}{Parameters}
{\em device} & the bridge device to mark \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1830 \{
1831   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << bridgeNetDevice);
1832   \hyperlink{classns3_1_1GlobalRouter_ad1b09bb4b76610b276fb065a0cb8dee6}{m\_bridgesVisited}.push\_back (bridgeNetDevice);
1833 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 23


\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Net\+Device\+Is\+Bridged@{Net\+Device\+Is\+Bridged}}
\index{Net\+Device\+Is\+Bridged@{Net\+Device\+Is\+Bridged}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Net\+Device\+Is\+Bridged(\+Ptr$<$ Net\+Device $>$ nd) const }{NetDeviceIsBridged(Ptr< NetDevice > nd) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Bridge\+Net\+Device} $>$ ns3\+::\+Global\+Router\+::\+Net\+Device\+Is\+Bridged (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{nd}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1GlobalRouter_ad330b65439cd1be39799b52df948f98b}{}\label{classns3_1_1GlobalRouter_ad330b65439cd1be39799b52df948f98b}


Decide whether or not a given net device is being bridged by a \hyperlink{classns3_1_1BridgeNetDevice}{Bridge\+Net\+Device}. 


\begin{DoxyParams}{Parameters}
{\em nd} & the \hyperlink{classns3_1_1NetDevice}{Net\+Device} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the \hyperlink{classns3_1_1BridgeNetDevice}{Bridge\+Net\+Device} smart pointer or null if not found 
\end{DoxyReturn}

\begin{DoxyCode}
1760 \{
1761   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << nd);
1762 
1763   Ptr<Node> node = nd->GetNode ();
1764   uint32\_t nDevices = node->GetNDevices ();
1765 
1766   \textcolor{comment}{//}
1767   \textcolor{comment}{// There is no bit on a net device that says it is being bridged, so we have}
1768   \textcolor{comment}{// to look for bridges on the node to which the device is attached.  If we}
1769   \textcolor{comment}{// find a bridge, we need to look through its bridge ports (the devices it}
1770   \textcolor{comment}{// bridges) to see if we find the device in question.}
1771   \textcolor{comment}{//}
1772   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < nDevices; ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
1773     \{
1774       Ptr<NetDevice> ndTest = node->GetDevice (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
1775       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Examine device "} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} << \textcolor{stringliteral}{" "} << ndTest);
1776 
1777       \textcolor{keywordflow}{if} (ndTest->IsBridge ())
1778         \{
1779           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"device "} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} << \textcolor{stringliteral}{" is a bridge net device"});
1780           Ptr<BridgeNetDevice> bnd = ndTest->GetObject<BridgeNetDevice> ();
1781           \hyperlink{group__fatal_ga0bd3f62c55e7347ff814572f3aaa3864}{NS\_ABORT\_MSG\_UNLESS} (bnd, \textcolor{stringliteral}{"GlobalRouter::DiscoverLSAs (): GetObject for
       <BridgeNetDevice> failed"});
1782 
1783           \textcolor{keywordflow}{for} (uint32\_t j = 0; j < bnd->GetNBridgePorts (); ++j)
1784             \{
1785               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Examine bridge port "} << j << \textcolor{stringliteral}{" "} << bnd->GetBridgePort (j));
1786               \textcolor{keywordflow}{if} (bnd->GetBridgePort (j) == nd)
1787                 \{
1788                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Net device "} << nd << \textcolor{stringliteral}{" is bridged by "} << bnd);
1789                   \textcolor{keywordflow}{return} bnd;
1790                 \}
1791             \}
1792         \}
1793     \}
1794   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Net device "} << nd << \textcolor{stringliteral}{" is not bridged"});
1795   \textcolor{keywordflow}{return} 0;
1796 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 24




Here is the caller graph for this function\+:
% FIG 25


\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!operator=@{operator=}}
\index{operator=@{operator=}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{operator=(\+Global\+Router \&sr)}{operator=(GlobalRouter &sr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Global\+Router}\& ns3\+::\+Global\+Router\+::operator= (
\begin{DoxyParamCaption}
\item[{{\bf Global\+Router} \&}]{sr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1GlobalRouter_a8a3edaf983ba050a8326d943e556c04e}{}\label{classns3_1_1GlobalRouter_a8a3edaf983ba050a8326d943e556c04e}


Global Router assignment operator is disallowed. 


\begin{DoxyParams}{Parameters}
{\em sr} & object to copy from. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The object copied. 
\end{DoxyReturn}
\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Process\+Bridged\+Broadcast\+Link@{Process\+Bridged\+Broadcast\+Link}}
\index{Process\+Bridged\+Broadcast\+Link@{Process\+Bridged\+Broadcast\+Link}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Process\+Bridged\+Broadcast\+Link(\+Ptr$<$ Net\+Device $>$ nd, Global\+Routing\+L\+S\+A $\ast$p\+L\+S\+A, Net\+Device\+Container \&c)}{ProcessBridgedBroadcastLink(Ptr< NetDevice > nd, GlobalRoutingLSA *pLSA, NetDeviceContainer &c)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Global\+Router\+::\+Process\+Bridged\+Broadcast\+Link (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{nd, }
\item[{{\bf Global\+Routing\+L\+SA} $\ast$}]{p\+L\+SA, }
\item[{{\bf Net\+Device\+Container} \&}]{c}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1GlobalRouter_a7368716600989ea7d4bec67fa4f86e4c}{}\label{classns3_1_1GlobalRouter_a7368716600989ea7d4bec67fa4f86e4c}


Process a bridged broadcast link. 


\begin{DoxyParams}{Parameters}
{\em nd} & the \hyperlink{classns3_1_1NetDevice}{Net\+Device} \\
\hline
{\em p\+L\+SA} & the Global L\+SA \\
\hline
{\em c} & the returned \hyperlink{classns3_1_1NetDevice}{Net\+Device} container \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
873 \{
874   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << nd << pLSA << &\hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c});
875   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (nd->IsBridge (), \textcolor{stringliteral}{"GlobalRouter::ProcessBridgedBroadcastLink(): Called with
       non-bridge net device"});
876 
877 \textcolor{preprocessor}{#if 0}
878   \textcolor{comment}{//}
879   \textcolor{comment}{// It is possible to admit the possibility that a bridge device on a node}
880   \textcolor{comment}{// can also participate in routing.  This would surprise people who don't}
881   \textcolor{comment}{// come from Microsoft-land where they do use such a construct.  Based on}
882   \textcolor{comment}{// the principle of least-surprise, we will leave the relatively simple}
883   \textcolor{comment}{// code in place to do this, but not enable it until someone really wants}
884   \textcolor{comment}{// the capability.  Even then, we will not enable this code as a default}
885   \textcolor{comment}{// but rather something you will have to go and turn on.}
886   \textcolor{comment}{//}
887 
888   Ptr<BridgeNetDevice> bnd = nd->GetObject<BridgeNetDevice> ();
889   \hyperlink{group__fatal_ga0bd3f62c55e7347ff814572f3aaa3864}{NS\_ABORT\_MSG\_UNLESS} (bnd, \textcolor{stringliteral}{"GlobalRouter::DiscoverLSAs (): GetObject for
       <BridgeNetDevice> failed"});
890 
891   \textcolor{comment}{//}
892   \textcolor{comment}{// We have some preliminaries to do to get enough information to proceed.}
893   \textcolor{comment}{// This information we need comes from the internet stack, so notice that}
894   \textcolor{comment}{// there is an implied assumption that global routing is only going to }
895   \textcolor{comment}{// work with devices attached to the internet stack (have an ipv4 interface}
896   \textcolor{comment}{// associated to them.}
897   \textcolor{comment}{//}
898   Ptr<Node> node = nd->GetNode ();
899   Ptr<Ipv4> ipv4Local = node->GetObject<Ipv4> ();
900   \hyperlink{group__fatal_ga0bd3f62c55e7347ff814572f3aaa3864}{NS\_ABORT\_MSG\_UNLESS} (ipv4Local, \textcolor{stringliteral}{"GlobalRouter::ProcessBridgedBroadcastLink ():
       GetObject for <Ipv4> interface failed"});
901 
902   \textcolor{comment}{// Initialize to value out of bounds to silence compiler}
903   uint32\_t interfaceLocal = ipv4Local->GetNInterfaces () + 1;
904   \textcolor{keywordtype}{bool} rc = \hyperlink{classns3_1_1GlobalRouter_a7b30c3c09f93e3f3ac7cfe787b51d127}{FindInterfaceForDevice} (node, nd, interfaceLocal);
905   \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (rc == \textcolor{keyword}{false}, \textcolor{stringliteral}{"GlobalRouter::ProcessBridgedBroadcastLink(): No interface
       index associated with device"});
906 
907   \textcolor{keywordflow}{if} (ipv4Local->GetNAddresses (interfaceLocal) > 1)
908     \{
909       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Warning, interface has multiple IP addresses; using only the primary one"});
910     \}
911   Ipv4Address addrLocal = ipv4Local->GetAddress (interfaceLocal, 0).GetLocal ();
912   Ipv4Mask maskLocal = ipv4Local->GetAddress (interfaceLocal, 0).GetMask ();;
913   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Working with local address "} << addrLocal);
914   uint16\_t metricLocal = ipv4Local->GetMetric (interfaceLocal);
915 
916   \textcolor{comment}{//}
917   \textcolor{comment}{// We need to handle a bridge on the router.  This means that we have been }
918   \textcolor{comment}{// given a net device that is a BridgeNetDevice.  It has an associated Ipv4}
919   \textcolor{comment}{// interface index and address.  Some number of other net devices live "under"}
920   \textcolor{comment}{// the bridge device as so-called bridge ports.  In a nutshell, what we have}
921   \textcolor{comment}{// to do is to repeat what is done for a single broadcast link on all of }
922   \textcolor{comment}{// those net devices living under the bridge (trolls?)}
923   \textcolor{comment}{//}
924 
925   \textcolor{keywordtype}{bool} areTransitNetwork = \textcolor{keyword}{false};
926   Ipv4Address desigRtr (\textcolor{stringliteral}{"255.255.255.255"});
927 
928   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < bnd->GetNBridgePorts (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
929     \{
930       Ptr<NetDevice> ndTemp = bnd->GetBridgePort (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
931 
932       \textcolor{comment}{//}
933       \textcolor{comment}{// We have to decide if we are a transit network.  This is characterized}
934       \textcolor{comment}{// by the presence of another router on the network segment.  If we find}
935       \textcolor{comment}{// another router on any of our bridged links, we are a transit network.}
936       \textcolor{comment}{//}
937       \hyperlink{classns3_1_1GlobalRouter_a2519d9ebeb7425ffe4569c6ed0eaf4cf}{ClearBridgesVisited} ();
938       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1GlobalRouter_ae2af74f394b3b8de4daad7000fb0b9f7}{AnotherRouterOnLink} (ndTemp))
939         \{
940           areTransitNetwork = \textcolor{keyword}{true};
941 
942           \textcolor{comment}{//}
943           \textcolor{comment}{// If we're going to be a transit network, then we have got to elect}
944           \textcolor{comment}{// a designated router for the whole bridge.  This means finding the}
945           \textcolor{comment}{// router with the lowest IP address on the whole bridge.  We ask }
946           \textcolor{comment}{// for the lowest address on each segment and pick the lowest of them}
947           \textcolor{comment}{// all.}
948           \textcolor{comment}{//}
949           \hyperlink{classns3_1_1GlobalRouter_a2519d9ebeb7425ffe4569c6ed0eaf4cf}{ClearBridgesVisited} ();
950           Ipv4Address desigRtrTemp = \hyperlink{classns3_1_1GlobalRouter_ab562e4407394674ef8502b3ab1d051d6}{FindDesignatedRouterForLink} (ndTemp);
951 
952           \textcolor{comment}{//}
953           \textcolor{comment}{// Let's double-check that any designated router we find out on our}
954           \textcolor{comment}{// network is really on our network.}
955           \textcolor{comment}{//}
956           \textcolor{keywordflow}{if} (desigRtrTemp != \textcolor{stringliteral}{"255.255.255.255"})
957             \{
958               Ipv4Address networkHere = addrLocal.CombineMask (maskLocal);
959               Ipv4Address networkThere = desigRtrTemp.CombineMask (maskLocal);
960               \hyperlink{group__fatal_ga0bd3f62c55e7347ff814572f3aaa3864}{NS\_ABORT\_MSG\_UNLESS} (networkHere == networkThere, 
961                                    \textcolor{stringliteral}{"GlobalRouter::ProcessSingleBroadcastLink(): Network number confusion"});
962             \}
963           \textcolor{keywordflow}{if} (desigRtrTemp < desigRtr)
964             \{
965               desigRtr = desigRtrTemp;
966             \}
967         \}
968     \}
969   \textcolor{comment}{//}
970   \textcolor{comment}{// That's all the information we need to put it all together, just like we did}
971   \textcolor{comment}{// in the case of a single broadcast link.}
972   \textcolor{comment}{//}
973 
974   GlobalRoutingLinkRecord *plr = \textcolor{keyword}{new} GlobalRoutingLinkRecord;
975   \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (plr == 0, \textcolor{stringliteral}{"GlobalRouter::ProcessBridgedBroadcastLink(): Can't alloc link
       record"});
976 
977   \textcolor{keywordflow}{if} (areTransitNetwork == \textcolor{keyword}{false})
978     \{
979       \textcolor{comment}{//}
980       \textcolor{comment}{// This is a net device connected to a bridge of stub networks}
981       \textcolor{comment}{//}
982       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Router-LSA Stub Network"});
983       plr->SetLinkType (\hyperlink{classns3_1_1GlobalRoutingLinkRecord_a9380bcce9bca03943c4761b166a694f4a183ff8c880e05253fdca7bece2cad90b}{GlobalRoutingLinkRecord::StubNetwork});
984 
985       \textcolor{comment}{// }
986       \textcolor{comment}{// According to OSPF, the Link ID is the IP network number of }
987       \textcolor{comment}{// the attached network.}
988       \textcolor{comment}{//}
989       plr->SetLinkId (addrLocal.CombineMask (maskLocal));
990 
991       \textcolor{comment}{//}
992       \textcolor{comment}{// and the Link Data is the network mask; converted to Ipv4Address}
993       \textcolor{comment}{//}
994       Ipv4Address maskLocalAddr;
995       maskLocalAddr.Set (maskLocal.Get ());
996       plr->SetLinkData (maskLocalAddr);
997       plr->SetMetric (metricLocal);
998       pLSA->AddLinkRecord (plr);
999       plr = 0;
1000     \}
1001   \textcolor{keywordflow}{else}
1002     \{
1003       \textcolor{comment}{//}
1004       \textcolor{comment}{// We have multiple routers on a bridged broadcast interface, so this is}
1005       \textcolor{comment}{// a transit network.}
1006       \textcolor{comment}{//}
1007       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Router-LSA Transit Network"});
1008       plr->SetLinkType (\hyperlink{classns3_1_1GlobalRoutingLinkRecord_a9380bcce9bca03943c4761b166a694f4ad3d00014c9ba50539a53b55fce117856}{GlobalRoutingLinkRecord::TransitNetwork});
1009 
1010       \textcolor{comment}{// }
1011       \textcolor{comment}{// By definition, the router with the lowest IP address is the}
1012       \textcolor{comment}{// designated router for the network.  OSPF says that the Link ID}
1013       \textcolor{comment}{// gets the IP interface address of the designated router in this }
1014       \textcolor{comment}{// case.}
1015       \textcolor{comment}{//}
1016       \textcolor{keywordflow}{if} (desigRtr == addrLocal) 
1017         \{
1018           \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c}.Add (nd);
1019           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Node "} << node->GetId () << \textcolor{stringliteral}{" elected a designated router"});
1020         \}
1021       plr->SetLinkId (desigRtr);
1022 
1023       \textcolor{comment}{//}
1024       \textcolor{comment}{// OSPF says that the Link Data is this router's own IP address.}
1025       \textcolor{comment}{//}
1026       plr->SetLinkData (addrLocal);
1027       plr->SetMetric (metricLocal);
1028       pLSA->AddLinkRecord (plr);
1029       plr = 0;
1030     \}
1031 \textcolor{preprocessor}{#endif}
1032 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 26




Here is the caller graph for this function\+:
% FIG 27


\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Process\+Broadcast\+Link@{Process\+Broadcast\+Link}}
\index{Process\+Broadcast\+Link@{Process\+Broadcast\+Link}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Process\+Broadcast\+Link(\+Ptr$<$ Net\+Device $>$ nd, Global\+Routing\+L\+S\+A $\ast$p\+L\+S\+A, Net\+Device\+Container \&c)}{ProcessBroadcastLink(Ptr< NetDevice > nd, GlobalRoutingLSA *pLSA, NetDeviceContainer &c)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Global\+Router\+::\+Process\+Broadcast\+Link (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{nd, }
\item[{{\bf Global\+Routing\+L\+SA} $\ast$}]{p\+L\+SA, }
\item[{{\bf Net\+Device\+Container} \&}]{c}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1GlobalRouter_af981be58153ef32690b434072cd3205b}{}\label{classns3_1_1GlobalRouter_af981be58153ef32690b434072cd3205b}


Process a generic broadcast link. 


\begin{DoxyParams}{Parameters}
{\em nd} & the \hyperlink{classns3_1_1NetDevice}{Net\+Device} \\
\hline
{\em p\+L\+SA} & the Global L\+SA \\
\hline
{\em c} & the returned \hyperlink{classns3_1_1NetDevice}{Net\+Device} container \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
747 \{
748   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << nd << pLSA << &\hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c});
749 
750   \textcolor{keywordflow}{if} (nd->IsBridge ())
751     \{
752       \hyperlink{classns3_1_1GlobalRouter_a7368716600989ea7d4bec67fa4f86e4c}{ProcessBridgedBroadcastLink} (nd, pLSA, \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c});
753     \}
754   \textcolor{keywordflow}{else}
755     \{
756       \hyperlink{classns3_1_1GlobalRouter_a16b0eecb167b84a7160c8903839a826f}{ProcessSingleBroadcastLink} (nd, pLSA, \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c});
757     \}
758 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 28




Here is the caller graph for this function\+:
% FIG 29


\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Process\+Point\+To\+Point\+Link@{Process\+Point\+To\+Point\+Link}}
\index{Process\+Point\+To\+Point\+Link@{Process\+Point\+To\+Point\+Link}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Process\+Point\+To\+Point\+Link(\+Ptr$<$ Net\+Device $>$ nd\+Local, Global\+Routing\+L\+S\+A $\ast$p\+L\+S\+A)}{ProcessPointToPointLink(Ptr< NetDevice > ndLocal, GlobalRoutingLSA *pLSA)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Global\+Router\+::\+Process\+Point\+To\+Point\+Link (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{nd\+Local, }
\item[{{\bf Global\+Routing\+L\+SA} $\ast$}]{p\+L\+SA}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1GlobalRouter_adaf99c499d6e42e450a31b53a8019b14}{}\label{classns3_1_1GlobalRouter_adaf99c499d6e42e450a31b53a8019b14}


Process a point to point link. 


\begin{DoxyParams}{Parameters}
{\em nd\+Local} & the \hyperlink{classns3_1_1NetDevice}{Net\+Device} \\
\hline
{\em p\+L\+SA} & the Global L\+SA \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1036 \{
1037   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << ndLocal << pLSA);
1038 
1039   \textcolor{comment}{//}
1040   \textcolor{comment}{// We have some preliminaries to do to get enough information to proceed.}
1041   \textcolor{comment}{// This information we need comes from the internet stack, so notice that}
1042   \textcolor{comment}{// there is an implied assumption that global routing is only going to }
1043   \textcolor{comment}{// work with devices attached to the internet stack (have an ipv4 interface}
1044   \textcolor{comment}{// associated to them.}
1045   \textcolor{comment}{//}
1046   Ptr<Node> nodeLocal = ndLocal->GetNode ();
1047 
1048   Ptr<Ipv4> ipv4Local = nodeLocal->GetObject<Ipv4> ();
1049   \hyperlink{group__fatal_ga0bd3f62c55e7347ff814572f3aaa3864}{NS\_ABORT\_MSG\_UNLESS} (ipv4Local, \textcolor{stringliteral}{"GlobalRouter::ProcessPointToPointLink (): GetObject
       for <Ipv4> interface failed"});
1050 
1051   uint32\_t interfaceLocal = ipv4Local->GetNInterfaces () + 1;
1052   \textcolor{keywordtype}{bool} rc = \hyperlink{classns3_1_1GlobalRouter_a7b30c3c09f93e3f3ac7cfe787b51d127}{FindInterfaceForDevice} (nodeLocal, ndLocal, interfaceLocal);
1053   \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (rc == \textcolor{keyword}{false}, \textcolor{stringliteral}{"GlobalRouter::ProcessPointToPointLink (): No interface
       index associated with device"});
1054 
1055   \textcolor{keywordflow}{if} (ipv4Local->GetNAddresses (interfaceLocal) > 1)
1056     \{
1057       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Warning, interface has multiple IP addresses; using only the primary one"});
1058     \}
1059   Ipv4Address addrLocal = ipv4Local->GetAddress (interfaceLocal, 0).GetLocal ();
1060   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Working with local address "} << addrLocal);
1061   uint16\_t metricLocal = ipv4Local->GetMetric (interfaceLocal);
1062 
1063   \textcolor{comment}{//}
1064   \textcolor{comment}{// Now, we're going to walk over to the remote net device on the other end of }
1065   \textcolor{comment}{// the point-to-point channel we know we have.  This is where our adjacent }
1066   \textcolor{comment}{// router (to use OSPF lingo) is running.}
1067   \textcolor{comment}{//}
1068   Ptr<Channel> ch = ndLocal->GetChannel ();
1069 
1070   \textcolor{comment}{//}
1071   \textcolor{comment}{// Get the net device on the other side of the point-to-point channel.}
1072   \textcolor{comment}{//}
1073   Ptr<NetDevice> ndRemote = \hyperlink{classns3_1_1GlobalRouter_a347a9eb0edc5b923d6d3a3614e48769f}{GetAdjacent} (ndLocal, ch);
1074 
1075   \textcolor{comment}{//}
1076   \textcolor{comment}{// The adjacent net device is aggregated to a node.  We need to ask that net }
1077   \textcolor{comment}{// device for its node, then ask that node for its Ipv4 interface.  Note a}
1078   \textcolor{comment}{// requirement that nodes on either side of a point-to-point link must have }
1079   \textcolor{comment}{// internet stacks; and an assumption that point-to-point links are incompatible }
1080   \textcolor{comment}{// with bridging.}
1081   \textcolor{comment}{//}
1082   Ptr<Node> nodeRemote = ndRemote->GetNode ();
1083   Ptr<Ipv4> ipv4Remote = nodeRemote->GetObject<Ipv4> ();
1084   \hyperlink{group__fatal_ga0bd3f62c55e7347ff814572f3aaa3864}{NS\_ABORT\_MSG\_UNLESS} (ipv4Remote, 
1085                        \textcolor{stringliteral}{"GlobalRouter::ProcessPointToPointLink(): GetObject for remote <Ipv4> failed"});
1086 
1087   \textcolor{comment}{//}
1088   \textcolor{comment}{// Further note the requirement that nodes on either side of a point-to-point }
1089   \textcolor{comment}{// link must participate in global routing and therefore have a GlobalRouter}
1090   \textcolor{comment}{// interface aggregated.}
1091   \textcolor{comment}{//}
1092   Ptr<GlobalRouter> rtrRemote = nodeRemote->GetObject<\hyperlink{classns3_1_1GlobalRouter_a778050c70fe491c0fe62b7cf6b10aaf6}{GlobalRouter}> ();
1093   \textcolor{keywordflow}{if} (rtrRemote == 0)
1094     \{
1095       \textcolor{comment}{// This case is possible if the remote does not participate in global routing}
1096       \textcolor{keywordflow}{return};
1097     \}
1098   \textcolor{comment}{//}
1099   \textcolor{comment}{// We're going to need the remote router ID, so we might as well get it now.}
1100   \textcolor{comment}{//}
1101   Ipv4Address rtrIdRemote = rtrRemote->GetRouterId ();
1102   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Working with remote router "} << rtrIdRemote);
1103 
1104   \textcolor{comment}{//}
1105   \textcolor{comment}{// Now, just like we did above, we need to get the IP interface index for the }
1106   \textcolor{comment}{// net device on the other end of the point-to-point channel.}
1107   \textcolor{comment}{//}
1108   uint32\_t interfaceRemote = ipv4Remote->GetNInterfaces () + 1;
1109   rc = \hyperlink{classns3_1_1GlobalRouter_a7b30c3c09f93e3f3ac7cfe787b51d127}{FindInterfaceForDevice} (nodeRemote, ndRemote, interfaceRemote);
1110   \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (rc == \textcolor{keyword}{false}, \textcolor{stringliteral}{"GlobalRouter::ProcessPointToPointLinks(): No interface
       index associated with remote device"});
1111 
1112   \textcolor{comment}{//}
1113   \textcolor{comment}{// Now that we have the Ipv4 interface, we can get the (remote) address and}
1114   \textcolor{comment}{// mask we need.}
1115   \textcolor{comment}{//}
1116   \textcolor{keywordflow}{if} (ipv4Remote->GetNAddresses (interfaceRemote) > 1)
1117     \{
1118       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Warning, interface has multiple IP addresses; using only the primary one"});
1119     \}
1120   Ipv4Address addrRemote = ipv4Remote->GetAddress (interfaceRemote, 0).GetLocal ();
1121   Ipv4Mask maskRemote = ipv4Remote->GetAddress (interfaceRemote, 0).GetMask ();
1122   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Working with remote address "} << addrRemote);
1123 
1124   \textcolor{comment}{//}
1125   \textcolor{comment}{// Now we can fill out the link records for this link.  There are always two}
1126   \textcolor{comment}{// link records; the first is a point-to-point record describing the link and}
1127   \textcolor{comment}{// the second is a stub network record with the network number.}
1128   \textcolor{comment}{//}
1129   GlobalRoutingLinkRecord *plr;
1130   \textcolor{keywordflow}{if} (ipv4Remote->IsUp (interfaceRemote))
1131     \{
1132       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Remote side interface "} << interfaceRemote << \textcolor{stringliteral}{" is up-- add a type 1 link"}
      );
1133  
1134       plr  = \textcolor{keyword}{new} GlobalRoutingLinkRecord;
1135       \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (plr == 0, \textcolor{stringliteral}{"GlobalRouter::ProcessPointToPointLink(): Can't alloc link
       record"});
1136       plr->SetLinkType (\hyperlink{classns3_1_1GlobalRoutingLinkRecord_a9380bcce9bca03943c4761b166a694f4aa345c79cdcaba957f5e8296509183912}{GlobalRoutingLinkRecord::PointToPoint});
1137       plr->SetLinkId (rtrIdRemote);
1138       plr->SetLinkData (addrLocal);
1139       plr->SetMetric (metricLocal);
1140       pLSA->AddLinkRecord (plr);
1141       plr = 0;
1142     \}
1143 
1144   \textcolor{comment}{// Regardless of state of peer, add a type 3 link (RFC 2328: 12.4.1.1)}
1145   plr = \textcolor{keyword}{new} GlobalRoutingLinkRecord;
1146   \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (plr == 0, \textcolor{stringliteral}{"GlobalRouter::ProcessPointToPointLink(): Can't alloc link
       record"});
1147   plr->SetLinkType (\hyperlink{classns3_1_1GlobalRoutingLinkRecord_a9380bcce9bca03943c4761b166a694f4a183ff8c880e05253fdca7bece2cad90b}{GlobalRoutingLinkRecord::StubNetwork});
1148   plr->SetLinkId (addrRemote);
1149   plr->SetLinkData (Ipv4Address (maskRemote.Get ()));  \textcolor{comment}{// Frown}
1150   plr->SetMetric (metricLocal);
1151   pLSA->AddLinkRecord (plr);
1152   plr = 0;
1153 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 30




Here is the caller graph for this function\+:
% FIG 31


\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Process\+Single\+Broadcast\+Link@{Process\+Single\+Broadcast\+Link}}
\index{Process\+Single\+Broadcast\+Link@{Process\+Single\+Broadcast\+Link}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Process\+Single\+Broadcast\+Link(\+Ptr$<$ Net\+Device $>$ nd, Global\+Routing\+L\+S\+A $\ast$p\+L\+S\+A, Net\+Device\+Container \&c)}{ProcessSingleBroadcastLink(Ptr< NetDevice > nd, GlobalRoutingLSA *pLSA, NetDeviceContainer &c)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Global\+Router\+::\+Process\+Single\+Broadcast\+Link (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{nd, }
\item[{{\bf Global\+Routing\+L\+SA} $\ast$}]{p\+L\+SA, }
\item[{{\bf Net\+Device\+Container} \&}]{c}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1GlobalRouter_a16b0eecb167b84a7160c8903839a826f}{}\label{classns3_1_1GlobalRouter_a16b0eecb167b84a7160c8903839a826f}


Process a single broadcast link. 


\begin{DoxyParams}{Parameters}
{\em nd} & the \hyperlink{classns3_1_1NetDevice}{Net\+Device} \\
\hline
{\em p\+L\+SA} & the Global L\+SA \\
\hline
{\em c} & the returned \hyperlink{classns3_1_1NetDevice}{Net\+Device} container \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
762 \{
763   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << nd << pLSA << &\hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c});
764 
765   GlobalRoutingLinkRecord *plr = \textcolor{keyword}{new} GlobalRoutingLinkRecord;
766   \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (plr == 0, \textcolor{stringliteral}{"GlobalRouter::ProcessSingleBroadcastLink(): Can't alloc link
       record"});
767 
768   \textcolor{comment}{//}
769   \textcolor{comment}{// We have some preliminaries to do to get enough information to proceed.}
770   \textcolor{comment}{// This information we need comes from the internet stack, so notice that}
771   \textcolor{comment}{// there is an implied assumption that global routing is only going to }
772   \textcolor{comment}{// work with devices attached to the internet stack (have an ipv4 interface}
773   \textcolor{comment}{// associated to them.}
774   \textcolor{comment}{//}
775   Ptr<Node> node = nd->GetNode ();
776 
777   Ptr<Ipv4> ipv4Local = node->GetObject<Ipv4> ();
778   \hyperlink{group__fatal_ga0bd3f62c55e7347ff814572f3aaa3864}{NS\_ABORT\_MSG\_UNLESS} (ipv4Local, \textcolor{stringliteral}{"GlobalRouter::ProcessSingleBroadcastLink ():
       GetObject for <Ipv4> interface failed"});
779 
780   \textcolor{comment}{// Initialize to value out of bounds to silence compiler}
781   uint32\_t interfaceLocal = ipv4Local->GetNInterfaces () + 1;
782   \textcolor{keywordtype}{bool} rc = \hyperlink{classns3_1_1GlobalRouter_a7b30c3c09f93e3f3ac7cfe787b51d127}{FindInterfaceForDevice} (node, nd, interfaceLocal);
783   \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (rc == \textcolor{keyword}{false}, \textcolor{stringliteral}{"GlobalRouter::ProcessSingleBroadcastLink(): No interface
       index associated with device"});
784 
785   \textcolor{keywordflow}{if} (ipv4Local->GetNAddresses (interfaceLocal) > 1)
786     \{
787       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Warning, interface has multiple IP addresses; using only the primary one"});
788     \}
789   Ipv4Address addrLocal = ipv4Local->GetAddress (interfaceLocal, 0).GetLocal ();
790   Ipv4Mask maskLocal = ipv4Local->GetAddress (interfaceLocal, 0).GetMask ();
791   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Working with local address "} << addrLocal);
792   uint16\_t metricLocal = ipv4Local->GetMetric (interfaceLocal);
793 
794   \textcolor{comment}{//}
795   \textcolor{comment}{// Check to see if the net device is connected to a channel/network that has}
796   \textcolor{comment}{// another router on it.  If there is no other router on the link (but us) then}
797   \textcolor{comment}{// this is a stub network.  If we find another router, then what we have here}
798   \textcolor{comment}{// is a transit network.}
799   \textcolor{comment}{//}
800   \hyperlink{classns3_1_1GlobalRouter_a2519d9ebeb7425ffe4569c6ed0eaf4cf}{ClearBridgesVisited} ();
801   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1GlobalRouter_ae2af74f394b3b8de4daad7000fb0b9f7}{AnotherRouterOnLink} (nd) == \textcolor{keyword}{false})
802     \{
803       \textcolor{comment}{//}
804       \textcolor{comment}{// This is a net device connected to a stub network}
805       \textcolor{comment}{//}
806       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Router-LSA Stub Network"});
807       plr->SetLinkType (\hyperlink{classns3_1_1GlobalRoutingLinkRecord_a9380bcce9bca03943c4761b166a694f4a183ff8c880e05253fdca7bece2cad90b}{GlobalRoutingLinkRecord::StubNetwork});
808 
809       \textcolor{comment}{// }
810       \textcolor{comment}{// According to OSPF, the Link ID is the IP network number of }
811       \textcolor{comment}{// the attached network.}
812       \textcolor{comment}{//}
813       plr->SetLinkId (addrLocal.CombineMask (maskLocal));
814 
815       \textcolor{comment}{//}
816       \textcolor{comment}{// and the Link Data is the network mask; converted to Ipv4Address}
817       \textcolor{comment}{//}
818       Ipv4Address maskLocalAddr;
819       maskLocalAddr.Set (maskLocal.Get ());
820       plr->SetLinkData (maskLocalAddr);
821       plr->SetMetric (metricLocal);
822       pLSA->AddLinkRecord (plr);
823       plr = 0;
824     \}
825   \textcolor{keywordflow}{else}
826     \{
827       \textcolor{comment}{//}
828       \textcolor{comment}{// We have multiple routers on a broadcast interface, so this is}
829       \textcolor{comment}{// a transit network.}
830       \textcolor{comment}{//}
831       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Router-LSA Transit Network"});
832       plr->SetLinkType (\hyperlink{classns3_1_1GlobalRoutingLinkRecord_a9380bcce9bca03943c4761b166a694f4ad3d00014c9ba50539a53b55fce117856}{GlobalRoutingLinkRecord::TransitNetwork});
833 
834       \textcolor{comment}{// }
835       \textcolor{comment}{// By definition, the router with the lowest IP address is the}
836       \textcolor{comment}{// designated router for the network.  OSPF says that the Link ID}
837       \textcolor{comment}{// gets the IP interface address of the designated router in this }
838       \textcolor{comment}{// case.}
839       \textcolor{comment}{//}
840       \hyperlink{classns3_1_1GlobalRouter_a2519d9ebeb7425ffe4569c6ed0eaf4cf}{ClearBridgesVisited} ();
841       Ipv4Address desigRtr = \hyperlink{classns3_1_1GlobalRouter_ab562e4407394674ef8502b3ab1d051d6}{FindDesignatedRouterForLink} (nd);
842 
843       \textcolor{comment}{//}
844       \textcolor{comment}{// Let's double-check that any designated router we find out on our}
845       \textcolor{comment}{// network is really on our network.}
846       \textcolor{comment}{//}
847       \textcolor{keywordflow}{if} (desigRtr != \textcolor{stringliteral}{"255.255.255.255"})
848         \{
849           Ipv4Address networkHere = addrLocal.CombineMask (maskLocal);
850           Ipv4Address networkThere = desigRtr.CombineMask (maskLocal);
851           \hyperlink{group__fatal_ga0bd3f62c55e7347ff814572f3aaa3864}{NS\_ABORT\_MSG\_UNLESS} (networkHere == networkThere, 
852                                \textcolor{stringliteral}{"GlobalRouter::ProcessSingleBroadcastLink(): Network number confusion"});
853         \}
854       \textcolor{keywordflow}{if} (desigRtr == addrLocal) 
855         \{
856           \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c}.Add (nd);
857           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Node "} << node->GetId () << \textcolor{stringliteral}{" elected a designated router"});
858         \}
859       plr->SetLinkId (desigRtr);
860 
861       \textcolor{comment}{//}
862       \textcolor{comment}{// OSPF says that the Link Data is this router's own IP address.}
863       \textcolor{comment}{//}
864       plr->SetLinkData (addrLocal);
865       plr->SetMetric (metricLocal);
866       pLSA->AddLinkRecord (plr);
867       plr = 0;
868     \}
869 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 32




Here is the caller graph for this function\+:
% FIG 33


\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Remove\+Injected\+Route@{Remove\+Injected\+Route}}
\index{Remove\+Injected\+Route@{Remove\+Injected\+Route}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Remove\+Injected\+Route(uint32\+\_\+t i)}{RemoveInjectedRoute(uint32_t i)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Global\+Router\+::\+Remove\+Injected\+Route (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1GlobalRouter_aa8a781b1a62792f28d1962d7c0f4a0ee}{}\label{classns3_1_1GlobalRouter_aa8a781b1a62792f28d1962d7c0f4a0ee}


Withdraw a route from the global unicast routing table. 

Calling this function will cause all indexed routes numbered above index i to have their index decremented. For instance, it is possible to remove N injected routes by calling Remove\+Injected\+Route (0) N times.


\begin{DoxyParams}{Parameters}
{\em i} & The index (into the injected routing list) of the route to remove.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1GlobalRouter_a17da2fda3c801645ccaed838a8d2e553}{Global\+Router\+::\+Withdraw\+Route} () 
\end{DoxySeeAlso}

\begin{DoxyCode}
1651 \{
1652   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << index);
1653   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (index < \hyperlink{classns3_1_1GlobalRouter_a2d1dd8dbb1bc813f24bff2fb2f0cde7f}{m\_injectedRoutes}.size ());
1654   uint32\_t tmp = 0;
1655   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1GlobalRouter_ac4ed7a61065c866b6f52abcdb2f29711}{InjectedRoutesI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1GlobalRouter_a2d1dd8dbb1bc813f24bff2fb2f0cde7f}{m\_injectedRoutes}.begin (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1GlobalRouter_a2d1dd8dbb1bc813f24bff2fb2f0cde7f}{m\_injectedRoutes}.end (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
1656     \{
1657       \textcolor{keywordflow}{if} (tmp  == index)
1658         \{
1659           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Removing route "} << index << \textcolor{stringliteral}{"; size = "} << 
      \hyperlink{classns3_1_1GlobalRouter_a2d1dd8dbb1bc813f24bff2fb2f0cde7f}{m\_injectedRoutes}.size ());
1660           \textcolor{keyword}{delete} *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
1661           \hyperlink{classns3_1_1GlobalRouter_a2d1dd8dbb1bc813f24bff2fb2f0cde7f}{m\_injectedRoutes}.erase (i);
1662           \textcolor{keywordflow}{return};
1663         \}
1664       tmp++;
1665     \}
1666 \}
\end{DoxyCode}
\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Set\+Routing\+Protocol@{Set\+Routing\+Protocol}}
\index{Set\+Routing\+Protocol@{Set\+Routing\+Protocol}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Set\+Routing\+Protocol(\+Ptr$<$ Ipv4\+Global\+Routing $>$ routing)}{SetRoutingProtocol(Ptr< Ipv4GlobalRouting > routing)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Global\+Router\+::\+Set\+Routing\+Protocol (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv4\+Global\+Routing} $>$}]{routing}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1GlobalRouter_abaae22deb0f40803687805e2380f4684}{}\label{classns3_1_1GlobalRouter_abaae22deb0f40803687805e2380f4684}


Set the specific Global Routing Protocol to be used. 


\begin{DoxyParams}{Parameters}
{\em routing} & the routing protocol \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
534 \{
535   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << routing);
536   \hyperlink{classns3_1_1GlobalRouter_a0a18bfb8e4f788c0e3027dcc603155a4}{m\_routingProtocol} = routing;
537 \}
\end{DoxyCode}
\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!Withdraw\+Route@{Withdraw\+Route}}
\index{Withdraw\+Route@{Withdraw\+Route}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{Withdraw\+Route(\+Ipv4\+Address network, Ipv4\+Mask network\+Mask)}{WithdrawRoute(Ipv4Address network, Ipv4Mask networkMask)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Global\+Router\+::\+Withdraw\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{network, }
\item[{{\bf Ipv4\+Mask}}]{network\+Mask}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1GlobalRouter_a17da2fda3c801645ccaed838a8d2e553}{}\label{classns3_1_1GlobalRouter_a17da2fda3c801645ccaed838a8d2e553}


Withdraw a route from the global unicast routing table. 


\begin{DoxyParams}{Parameters}
{\em network} & The Network to withdraw \\
\hline
{\em network\+Mask} & The Network Mask to withdraw \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether the operation succeeded (will return false if no such route)
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1GlobalRouter_aa8a781b1a62792f28d1962d7c0f4a0ee}{Global\+Router\+::\+Remove\+Injected\+Route} () 
\end{DoxySeeAlso}

\begin{DoxyCode}
1670 \{
1671   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << network << networkMask);
1672   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1GlobalRouter_ac4ed7a61065c866b6f52abcdb2f29711}{InjectedRoutesI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1GlobalRouter_a2d1dd8dbb1bc813f24bff2fb2f0cde7f}{m\_injectedRoutes}.begin (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1GlobalRouter_a2d1dd8dbb1bc813f24bff2fb2f0cde7f}{m\_injectedRoutes}.end (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
1673     \{
1674       \textcolor{keywordflow}{if} ((*i)->GetDestNetwork () == network && (*i)->GetDestNetworkMask () == networkMask)
1675         \{
1676           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Withdrawing route to network/mask "} << network << \textcolor{stringliteral}{"/"} << networkMask);
1677           \textcolor{keyword}{delete} *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
1678           \hyperlink{classns3_1_1GlobalRouter_a2d1dd8dbb1bc813f24bff2fb2f0cde7f}{m\_injectedRoutes}.erase (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
1679           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1680         \}
1681     \}
1682   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1683 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!m\+\_\+bridges\+Visited@{m\+\_\+bridges\+Visited}}
\index{m\+\_\+bridges\+Visited@{m\+\_\+bridges\+Visited}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{m\+\_\+bridges\+Visited}{m_bridgesVisited}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<${\bf Ptr}$<${\bf Bridge\+Net\+Device}$>$ $>$ ns3\+::\+Global\+Router\+::m\+\_\+bridges\+Visited\hspace{0.3cm}{\ttfamily [mutable]}, {\ttfamily [private]}}\hypertarget{classns3_1_1GlobalRouter_ad1b09bb4b76610b276fb065a0cb8dee6}{}\label{classns3_1_1GlobalRouter_ad1b09bb4b76610b276fb065a0cb8dee6}
Container of bridges visited. \index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!m\+\_\+injected\+Routes@{m\+\_\+injected\+Routes}}
\index{m\+\_\+injected\+Routes@{m\+\_\+injected\+Routes}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{m\+\_\+injected\+Routes}{m_injectedRoutes}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Injected\+Routes} ns3\+::\+Global\+Router\+::m\+\_\+injected\+Routes\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1GlobalRouter_a2d1dd8dbb1bc813f24bff2fb2f0cde7f}{}\label{classns3_1_1GlobalRouter_a2d1dd8dbb1bc813f24bff2fb2f0cde7f}


Routes we are exporting. 

\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!m\+\_\+\+L\+S\+As@{m\+\_\+\+L\+S\+As}}
\index{m\+\_\+\+L\+S\+As@{m\+\_\+\+L\+S\+As}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{m\+\_\+\+L\+S\+As}{m_LSAs}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf List\+Of\+L\+S\+As\+\_\+t} ns3\+::\+Global\+Router\+::m\+\_\+\+L\+S\+As\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1GlobalRouter_a5c583d84f810ce4404f54450a0ac18d4}{}\label{classns3_1_1GlobalRouter_a5c583d84f810ce4404f54450a0ac18d4}


database of Global\+Routing\+L\+S\+As 

\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!m\+\_\+router\+Id@{m\+\_\+router\+Id}}
\index{m\+\_\+router\+Id@{m\+\_\+router\+Id}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{m\+\_\+router\+Id}{m_routerId}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Address} ns3\+::\+Global\+Router\+::m\+\_\+router\+Id\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1GlobalRouter_aa107123583f6b2b68c61666a029b4270}{}\label{classns3_1_1GlobalRouter_aa107123583f6b2b68c61666a029b4270}


router ID (its I\+Pv4 address) 

\index{ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}!m\+\_\+routing\+Protocol@{m\+\_\+routing\+Protocol}}
\index{m\+\_\+routing\+Protocol@{m\+\_\+routing\+Protocol}!ns3\+::\+Global\+Router@{ns3\+::\+Global\+Router}}
\subsubsection[{\texorpdfstring{m\+\_\+routing\+Protocol}{m_routingProtocol}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Ipv4\+Global\+Routing}$>$ ns3\+::\+Global\+Router\+::m\+\_\+routing\+Protocol\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1GlobalRouter_a0a18bfb8e4f788c0e3027dcc603155a4}{}\label{classns3_1_1GlobalRouter_a0a18bfb8e4f788c0e3027dcc603155a4}


the \hyperlink{classns3_1_1Ipv4GlobalRouting}{Ipv4\+Global\+Routing} in use 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/model/\hyperlink{global-router-interface_8h}{global-\/router-\/interface.\+h}\item 
internet/model/\hyperlink{global-router-interface_8cc}{global-\/router-\/interface.\+cc}\end{DoxyCompactItemize}
