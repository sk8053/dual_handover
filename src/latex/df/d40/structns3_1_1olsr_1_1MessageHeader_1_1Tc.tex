\hypertarget{structns3_1_1olsr_1_1MessageHeader_1_1Tc}{}\section{ns3\+:\+:olsr\+:\+:Message\+Header\+:\+:Tc Struct Reference}
\label{structns3_1_1olsr_1_1MessageHeader_1_1Tc}\index{ns3\+::olsr\+::\+Message\+Header\+::\+Tc@{ns3\+::olsr\+::\+Message\+Header\+::\+Tc}}


{\ttfamily \#include $<$olsr-\/header.\+h$>$}



Collaboration diagram for ns3\+:\+:olsr\+:\+:Message\+Header\+:\+:Tc\+:
% FIG 0
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Tc_a9793c70b09fd5059487997b90d724c7a}{Print} (std\+::ostream \&os) const 
\item 
uint32\+\_\+t \hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Tc_a0372fa0477f907c0681e92cb3dce6eee}{Get\+Serialized\+Size} (void) const 
\item 
void \hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Tc_afcbf30f5bf303dc4689b84f62704f7b9}{Serialize} (\hyperlink{classns3_1_1Buffer_1_1Iterator}{Buffer\+::\+Iterator} start) const 
\item 
uint32\+\_\+t \hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Tc_adbdd723f030f40d3978966f6f985a7be}{Deserialize} (\hyperlink{classns3_1_1Buffer_1_1Iterator}{Buffer\+::\+Iterator} start, uint32\+\_\+t message\+Size)
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::vector$<$ \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} $>$ \hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Tc_a236424f611929db7d7f154f8c31c970e}{neighbor\+Addresses}
\begin{DoxyCompactList}\small\item\em Neighbor address container. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Tc_a0f74e45f855b1b500fb950336ef4aa63}{ansn}
\begin{DoxyCompactList}\small\item\em Advertised Neighbor Sequence Number. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
TC Message Format

\begin{DoxyVerb}  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |              ANSN             |           Reserved            |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |               Advertised Neighbor Main Address                |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |               Advertised Neighbor Main Address                |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                              ...                              |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\end{DoxyVerb}
 

\subsection{Member Function Documentation}
\index{ns3\+::olsr\+::\+Message\+Header\+::\+Tc@{ns3\+::olsr\+::\+Message\+Header\+::\+Tc}!Deserialize@{Deserialize}}
\index{Deserialize@{Deserialize}!ns3\+::olsr\+::\+Message\+Header\+::\+Tc@{ns3\+::olsr\+::\+Message\+Header\+::\+Tc}}
\subsubsection[{\texorpdfstring{Deserialize(\+Buffer\+::\+Iterator start, uint32\+\_\+t message\+Size)}{Deserialize(Buffer::Iterator start, uint32_t messageSize)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::olsr\+::\+Message\+Header\+::\+Tc\+::\+Deserialize (
\begin{DoxyParamCaption}
\item[{{\bf Buffer\+::\+Iterator}}]{start, }
\item[{uint32\+\_\+t}]{message\+Size}
\end{DoxyParamCaption}
)}\hypertarget{structns3_1_1olsr_1_1MessageHeader_1_1Tc_adbdd723f030f40d3978966f6f985a7be}{}\label{structns3_1_1olsr_1_1MessageHeader_1_1Tc_adbdd723f030f40d3978966f6f985a7be}
This method is used by \hyperlink{classns3_1_1Packet_a0961eccf975d75f902d40956c93ba63e}{Packet\+::\+Remove\+Header} to re-\/create a header from the byte buffer of a packet.


\begin{DoxyParams}{Parameters}
{\em start} & an iterator which points to where the header should read from. \\
\hline
{\em message\+Size} & the message size. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of bytes read. 
\end{DoxyReturn}

\begin{DoxyCode}
454 \{
455   Buffer::Iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{namespacevisualizer_1_1core_a2a35e5d8a34af358b508dac8635754e0}{start};
456 
457   this->\hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Tc_a236424f611929db7d7f154f8c31c970e}{neighborAddresses}.clear ();
458   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (messageSize >= 4);
459 
460   this->\hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Tc_a0f74e45f855b1b500fb950336ef4aa63}{ansn} = i.ReadNtohU16 ();
461   i.ReadNtohU16 (); \textcolor{comment}{// Reserved}
462 
463   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} ((messageSize - 4) % \hyperlink{olsr-header_8cc_a78eabd4fb6c036f7de9b598066b3c39e}{IPV4\_ADDRESS\_SIZE} == 0);
464   \textcolor{keywordtype}{int} numAddresses = (messageSize - 4) / \hyperlink{olsr-header_8cc_a78eabd4fb6c036f7de9b598066b3c39e}{IPV4\_ADDRESS\_SIZE};
465   this->\hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Tc_a236424f611929db7d7f154f8c31c970e}{neighborAddresses}.clear ();
466   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} \hyperlink{namespacesample-rng-plot_aeb5ee5c431e338ef39b7ac5431242e1d}{n} = 0; \hyperlink{namespacesample-rng-plot_aeb5ee5c431e338ef39b7ac5431242e1d}{n} < numAddresses; ++\hyperlink{namespacesample-rng-plot_aeb5ee5c431e338ef39b7ac5431242e1d}{n})
467     \{
468       this->\hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Tc_a236424f611929db7d7f154f8c31c970e}{neighborAddresses}.push\_back (Ipv4Address (i.ReadNtohU32 ()));
469     \}
470 
471   \textcolor{keywordflow}{return} messageSize;
472 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 1


\index{ns3\+::olsr\+::\+Message\+Header\+::\+Tc@{ns3\+::olsr\+::\+Message\+Header\+::\+Tc}!Get\+Serialized\+Size@{Get\+Serialized\+Size}}
\index{Get\+Serialized\+Size@{Get\+Serialized\+Size}!ns3\+::olsr\+::\+Message\+Header\+::\+Tc@{ns3\+::olsr\+::\+Message\+Header\+::\+Tc}}
\subsubsection[{\texorpdfstring{Get\+Serialized\+Size(void) const }{GetSerializedSize(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::olsr\+::\+Message\+Header\+::\+Tc\+::\+Get\+Serialized\+Size (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{structns3_1_1olsr_1_1MessageHeader_1_1Tc_a0372fa0477f907c0681e92cb3dce6eee}{}\label{structns3_1_1olsr_1_1MessageHeader_1_1Tc_a0372fa0477f907c0681e92cb3dce6eee}
Returns the expected size of the header. \begin{DoxyReturn}{Returns}
the expected size of the header. 
\end{DoxyReturn}

\begin{DoxyCode}
427 \{
428   \textcolor{keywordflow}{return} 4 + this->\hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Tc_a236424f611929db7d7f154f8c31c970e}{neighborAddresses}.size () * 
      \hyperlink{olsr-header_8cc_a78eabd4fb6c036f7de9b598066b3c39e}{IPV4\_ADDRESS\_SIZE};
429 \}
\end{DoxyCode}
\index{ns3\+::olsr\+::\+Message\+Header\+::\+Tc@{ns3\+::olsr\+::\+Message\+Header\+::\+Tc}!Print@{Print}}
\index{Print@{Print}!ns3\+::olsr\+::\+Message\+Header\+::\+Tc@{ns3\+::olsr\+::\+Message\+Header\+::\+Tc}}
\subsubsection[{\texorpdfstring{Print(std\+::ostream \&os) const }{Print(std::ostream &os) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Message\+Header\+::\+Tc\+::\+Print (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os}
\end{DoxyParamCaption}
) const}\hypertarget{structns3_1_1olsr_1_1MessageHeader_1_1Tc_a9793c70b09fd5059487997b90d724c7a}{}\label{structns3_1_1olsr_1_1MessageHeader_1_1Tc_a9793c70b09fd5059487997b90d724c7a}
This method is used to print the content of a M\+ID message. 
\begin{DoxyParams}{Parameters}
{\em os} & output stream \\
\hline
\end{DoxyParams}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000154}{Todo}]\end{DoxyRefDesc}

\begin{DoxyCode}
433 \{
435 \}
\end{DoxyCode}
\index{ns3\+::olsr\+::\+Message\+Header\+::\+Tc@{ns3\+::olsr\+::\+Message\+Header\+::\+Tc}!Serialize@{Serialize}}
\index{Serialize@{Serialize}!ns3\+::olsr\+::\+Message\+Header\+::\+Tc@{ns3\+::olsr\+::\+Message\+Header\+::\+Tc}}
\subsubsection[{\texorpdfstring{Serialize(\+Buffer\+::\+Iterator start) const }{Serialize(Buffer::Iterator start) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Message\+Header\+::\+Tc\+::\+Serialize (
\begin{DoxyParamCaption}
\item[{{\bf Buffer\+::\+Iterator}}]{start}
\end{DoxyParamCaption}
) const}\hypertarget{structns3_1_1olsr_1_1MessageHeader_1_1Tc_afcbf30f5bf303dc4689b84f62704f7b9}{}\label{structns3_1_1olsr_1_1MessageHeader_1_1Tc_afcbf30f5bf303dc4689b84f62704f7b9}
This method is used by \hyperlink{classns3_1_1Packet_a465108c595a0bc592095cbcab1832ed8}{Packet\+::\+Add\+Header} to store a header into the byte buffer of a packet.


\begin{DoxyParams}{Parameters}
{\em start} & an iterator which points to where the header should be written. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
439 \{
440   Buffer::Iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{namespacevisualizer_1_1core_a2a35e5d8a34af358b508dac8635754e0}{start};
441 
442   i.WriteHtonU16 (this->\hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Tc_a0f74e45f855b1b500fb950336ef4aa63}{ansn});
443   i.WriteHtonU16 (0); \textcolor{comment}{// Reserved}
444 
445   \textcolor{keywordflow}{for} (std::vector<Ipv4Address>::const\_iterator iter = this->\hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Tc_a236424f611929db7d7f154f8c31c970e}{neighborAddresses}.begin ();
446        iter != this->\hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Tc_a236424f611929db7d7f154f8c31c970e}{neighborAddresses}.end (); iter++)
447     \{
448       i.WriteHtonU32 (iter->Get ());
449     \}
450 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2




\subsection{Member Data Documentation}
\index{ns3\+::olsr\+::\+Message\+Header\+::\+Tc@{ns3\+::olsr\+::\+Message\+Header\+::\+Tc}!ansn@{ansn}}
\index{ansn@{ansn}!ns3\+::olsr\+::\+Message\+Header\+::\+Tc@{ns3\+::olsr\+::\+Message\+Header\+::\+Tc}}
\subsubsection[{\texorpdfstring{ansn}{ansn}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::olsr\+::\+Message\+Header\+::\+Tc\+::ansn}\hypertarget{structns3_1_1olsr_1_1MessageHeader_1_1Tc_a0f74e45f855b1b500fb950336ef4aa63}{}\label{structns3_1_1olsr_1_1MessageHeader_1_1Tc_a0f74e45f855b1b500fb950336ef4aa63}


Advertised Neighbor Sequence Number. 

\index{ns3\+::olsr\+::\+Message\+Header\+::\+Tc@{ns3\+::olsr\+::\+Message\+Header\+::\+Tc}!neighbor\+Addresses@{neighbor\+Addresses}}
\index{neighbor\+Addresses@{neighbor\+Addresses}!ns3\+::olsr\+::\+Message\+Header\+::\+Tc@{ns3\+::olsr\+::\+Message\+Header\+::\+Tc}}
\subsubsection[{\texorpdfstring{neighbor\+Addresses}{neighborAddresses}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<${\bf Ipv4\+Address}$>$ ns3\+::olsr\+::\+Message\+Header\+::\+Tc\+::neighbor\+Addresses}\hypertarget{structns3_1_1olsr_1_1MessageHeader_1_1Tc_a236424f611929db7d7f154f8c31c970e}{}\label{structns3_1_1olsr_1_1MessageHeader_1_1Tc_a236424f611929db7d7f154f8c31c970e}


Neighbor address container. 



The documentation for this struct was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
olsr/model/\hyperlink{olsr-header_8h}{olsr-\/header.\+h}\item 
olsr/model/\hyperlink{olsr-header_8cc}{olsr-\/header.\+cc}\end{DoxyCompactItemize}
