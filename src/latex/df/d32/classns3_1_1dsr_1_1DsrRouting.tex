\hypertarget{classns3_1_1dsr_1_1DsrRouting}{}\section{ns3\+:\+:dsr\+:\+:Dsr\+Routing Class Reference}
\label{classns3_1_1dsr_1_1DsrRouting}\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}


Dsr Routing base.  




{\ttfamily \#include $<$dsr-\/routing.\+h$>$}



Inheritance diagram for ns3\+:\+:dsr\+:\+:Dsr\+Routing\+:
% FIG 0


Collaboration diagram for ns3\+:\+:dsr\+:\+:Dsr\+Routing\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1dsr_1_1DsrRouting_a3b686bd293d4bd096180a1996171ccd1}{Dsr\+Routing} ()
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1dsr_1_1DsrRouting_af7baa9f4a344a7ce6d36d5a543cdb962}{$\sim$\+Dsr\+Routing} ()
\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_af1ef6f867481d19a85863a75a3e72e5a}{Get\+Node} () const 
\begin{DoxyCompactList}\small\item\em Get the node. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_a0edfde42e4b79a1e04e186cc732360b9}{Set\+Node} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node)
\begin{DoxyCompactList}\small\item\em Set the node. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_af61179a03e52ebee0822caac80a830ff}{Set\+Route\+Cache} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1dsr_1_1DsrRouteCache}{dsr\+::\+Dsr\+Route\+Cache} $>$ r)
\begin{DoxyCompactList}\small\item\em Set the route cache. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1dsr_1_1DsrRouteCache}{dsr\+::\+Dsr\+Route\+Cache} $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_afa6f8c46b9d64b3a56bd78f7abb3d1ad}{Get\+Route\+Cache} () const 
\begin{DoxyCompactList}\small\item\em Get the route cache. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_a62fbce24642000a21a4e7c783f77c205}{Set\+Request\+Table} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1dsr_1_1DsrRreqTable}{dsr\+::\+Dsr\+Rreq\+Table} $>$ r)
\begin{DoxyCompactList}\small\item\em Set the node. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1dsr_1_1DsrRreqTable}{dsr\+::\+Dsr\+Rreq\+Table} $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_a86141cf3706e21637e9d97d341bd1ca9}{Get\+Request\+Table} () const 
\begin{DoxyCompactList}\small\item\em Get the request table. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_a10d09f5b58b469d0a7c92926f61dd9ab}{Set\+Passive\+Buffer} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1dsr_1_1DsrPassiveBuffer}{dsr\+::\+Dsr\+Passive\+Buffer} $>$ r)
\begin{DoxyCompactList}\small\item\em Set the node. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1dsr_1_1DsrPassiveBuffer}{dsr\+::\+Dsr\+Passive\+Buffer} $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_ae53372c864f32f34bc1964865a3865fe}{Get\+Passive\+Buffer} () const 
\begin{DoxyCompactList}\small\item\em Get the passive buffer. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5160f9f3016a0ee25fd5d52be1e4d51e}{Get\+Net\+Device\+From\+Context} (std\+::string context)
\begin{DoxyCompactList}\small\item\em Get the netdevice from the context. \end{DoxyCompactList}\item 
std\+::vector$<$ std\+::string $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_a147011231253d86c4b2d6a5a8fb0a152}{Get\+Elements\+From\+Context} (std\+::string context)
\begin{DoxyCompactList}\small\item\em Get the elements from the tracing context. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4593e50d5f36e9b9b013fe0422067c44}{Get\+I\+Dfrom\+IP} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} address)
\begin{DoxyCompactList}\small\item\em Get the node id from ip address. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \hyperlink{classns3_1_1dsr_1_1DsrRouting_abaf6e655b3bf50d3002c3739409d23a6}{Get\+I\+Pfrom\+ID} (uint16\+\_\+t id)
\begin{DoxyCompactList}\small\item\em Get the ip address from id. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5914e79eec0e5e33be08f55321e8aaea}{Get\+I\+Pfrom\+M\+AC} (\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} address)
\begin{DoxyCompactList}\small\item\em Get the Ip address from mac address. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa301f5bb9481fe5392297015328e6332}{Get\+Node\+With\+Address} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} ipv4\+Address)
\begin{DoxyCompactList}\small\item\em Get the node with give ip address. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_a21eda9cea85649375aed0a4b5f0c4c10}{Print\+Vector} (std\+::vector$<$ \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} $>$ \&vec)
\begin{DoxyCompactList}\small\item\em Print the route vector. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa1b16658c14499af76ca7dd69c034f22}{Search\+Next\+Hop} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} ipv4\+Address, std\+::vector$<$ \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} $>$ \&vec)
\begin{DoxyCompactList}\small\item\em Get the next hop of the route. \end{DoxyCompactList}\item 
int \hyperlink{classns3_1_1dsr_1_1DsrRouting_a3e98f8b73e3020a96dffa8b9ddfc520b}{Get\+Protocol\+Number} (void) const 
\begin{DoxyCompactList}\small\item\em Get the dsr protocol number. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_a10273aec775b5cf12eafb03ee46c4397}{Send\+Buff\+Timer\+Expire} ()
\begin{DoxyCompactList}\small\item\em The send buffer timer expire. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_a03ace9023e9fe58434dc004123c7d9e0}{Check\+Send\+Buffer} ()
\begin{DoxyCompactList}\small\item\em Check the send buffer of packets with route when send buffer timer expire. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_ae70ab39db551d1d81afc081196f78017}{Packet\+New\+Route} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} source, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} destination, uint8\+\_\+t protocol)
\begin{DoxyCompactList}\small\item\em When route vector corrupted, originate a new packet, normally not happening. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_a8a726fb52558a1a8172a5bd5b8cdb072}{Set\+Route} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} next\+Hop, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} src\+Address)
\begin{DoxyCompactList}\small\item\em Set the route to use for data packets, used by the option headers when sending data/control packets. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_a67d111b0188b6e2210d1b4782820f8e3}{Get\+Priority} (\hyperlink{namespacens3_1_1dsr_a7c80bcec67d78dc149a0e503014d07c5}{Dsr\+Message\+Type} message\+Type)
\begin{DoxyCompactList}\small\item\em Set the priority of the packet in network queue. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_ace5dd08bac91fa199ddfac7e81125a62}{Send\+Unreach\+Error} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} unreach\+Node, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} destination, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} original\+Dst, uint8\+\_\+t salvage, uint8\+\_\+t protocol)
\begin{DoxyCompactList}\small\item\em This function is responsible for sending error packets in case of break link to next hop. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_a2c5629706b8a73cce84964231ac93d6b}{Forward\+Err\+Packet} (\hyperlink{classns3_1_1dsr_1_1DsrOptionRerrUnreachHeader}{Dsr\+Option\+Rerr\+Unreach\+Header} \&rerr, \hyperlink{classns3_1_1dsr_1_1DsrOptionSRHeader}{Dsr\+Option\+S\+R\+Header} \&source\+Route, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} next\+Hop, uint8\+\_\+t protocol, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ route)
\begin{DoxyCompactList}\small\item\em This function is responsible for forwarding error packets along the route. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_af67eeb07193d10db8308cb4ecbe08b02}{Send} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} source, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} destination, uint8\+\_\+t protocol, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ route)
\begin{DoxyCompactList}\small\item\em This function is called by higher layer protocol when sending packets. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_a8ce910f1c56dc238ff98117c784c4541}{Add\+Ack\+Req\+Header} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \&packet, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} next\+Hop)
\begin{DoxyCompactList}\small\item\em This function is called to add ack request header for network acknowledgement. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_a84a2caf24a41eef8993b64cb22874f95}{Send\+Packet} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} source, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} next\+Hop, uint8\+\_\+t protocol)
\begin{DoxyCompactList}\small\item\em This function is called by when really sending out the packet. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa518edb174bccce1062304404424c6e0}{Scheduler} (uint32\+\_\+t priority)
\begin{DoxyCompactList}\small\item\em This function is called to schedule sending packets from the network queue. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_aefc4dde8bd52b5b631a7ebf1d5924210}{Priority\+Scheduler} (uint32\+\_\+t priority, bool continue\+With\+First)
\begin{DoxyCompactList}\small\item\em This function is called to schedule sending packets from the network queue by priority. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_aeb92858b27d37c4c593ef7f5be53dd09}{Increase\+Retrans\+Timer} ()
\begin{DoxyCompactList}\small\item\em This function is called to increase the retransmission timer for data packet in the network queue. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1dsr_1_1DsrRouting_a1ec646804cb4db00478cc07e51998608}{Send\+Real\+Down} (\hyperlink{classns3_1_1dsr_1_1DsrNetworkQueueEntry}{Dsr\+Network\+Queue\+Entry} \&new\+Entry)
\begin{DoxyCompactList}\small\item\em This function is called to send packets down stack. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_a1a862a16f3a5527f9425763864ac3e80}{Send\+Packet\+From\+Buffer} (\hyperlink{classns3_1_1dsr_1_1DsrOptionSRHeader}{Dsr\+Option\+S\+R\+Header} const \&source\+Route, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} next\+Hop, uint8\+\_\+t protocol)
\begin{DoxyCompactList}\small\item\em This function is responsible for sending out data packets when have route, if no route found, it will cache the packet and send out route requests. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa2c72a1da3112a21f199ebe9dbc18110}{Passive\+Entry\+Check} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} source, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} destination, uint8\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_a2089307bfbe378b6cd8b274b38f70bb9}{segs\+Left}, uint16\+\_\+t fragment\+Offset, uint16\+\_\+t identification, bool save\+Entry)
\begin{DoxyCompactList}\small\item\em Find the same passive entry. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_afb3145517b31e5a0e2016ac496c86050}{Cancel\+Packet\+All\+Timer} (\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffEntry}{Dsr\+Maintain\+Buff\+Entry} \&mb)
\begin{DoxyCompactList}\small\item\em Cancel all the packet timers. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1dsr_1_1DsrRouting_a2d33e2373aafc398451aa081c44c699a}{Cancel\+Passive\+Timer} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} source, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} destination, uint8\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_a2089307bfbe378b6cd8b274b38f70bb9}{segs\+Left})
\begin{DoxyCompactList}\small\item\em Cancel the passive timer. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_a720cc99dcbb0bc42539f0cab37018ae6}{Call\+Cancel\+Packet\+Timer} (uint16\+\_\+t ack\+Id, \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} const \&ipv4\+Header, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} real\+Src, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} real\+Dst)
\begin{DoxyCompactList}\small\item\em Call the cancel packet retransmission timer function. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_aeed35bcacf68c9f349078b508e73c9aa}{Cancel\+Network\+Packet\+Timer} (\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffEntry}{Dsr\+Maintain\+Buff\+Entry} \&mb)
\begin{DoxyCompactList}\small\item\em Cancel the network packet retransmission timer for a specific maintenance entry. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_aee6495417f54a12f484029ee1a445d64}{Cancel\+Passive\+Packet\+Timer} (\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffEntry}{Dsr\+Maintain\+Buff\+Entry} \&mb)
\begin{DoxyCompactList}\small\item\em Cancel the passive packet retransmission timer for a specific maintenance entry. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_a3d5aef30dc62293cdc487b7110be2324}{Cancel\+Link\+Packet\+Timer} (\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffEntry}{Dsr\+Maintain\+Buff\+Entry} \&mb)
\begin{DoxyCompactList}\small\item\em Cancel the link packet retransmission timer for a specific maintenance entry. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_a215e6fcab10ee0d744a657f0af2695c6}{Cancel\+Packet\+Timer\+Next\+Hop} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} next\+Hop, uint8\+\_\+t protocol)
\begin{DoxyCompactList}\small\item\em Cancel the packet retransmission timer for a all maintenance entries with next\+Hop address. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_a83dd51056e4e48ad538ff41fda129272}{Salvage\+Packet} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} source, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} dst, uint8\+\_\+t protocol)
\begin{DoxyCompactList}\small\item\em Salvage the packet which has been transmitted for 3 times. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_a947d831bc0964240b1a41b3a09832eff}{Schedule\+Link\+Packet\+Retry} (\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffEntry}{Dsr\+Maintain\+Buff\+Entry} \&mb, uint8\+\_\+t protocol)
\begin{DoxyCompactList}\small\item\em Schedule the packet retransmission based on link-\/layer acknowledgment. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_abfdfa37822a492971fdf24540b635039}{Schedule\+Passive\+Packet\+Retry} (\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffEntry}{Dsr\+Maintain\+Buff\+Entry} \&mb, uint8\+\_\+t protocol)
\begin{DoxyCompactList}\small\item\em Schedule the packet retransmission based on passive acknowledgment. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_a6a18c6baa374d5e6a68f8952d1afdb13}{Schedule\+Network\+Packet\+Retry} (\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffEntry}{Dsr\+Maintain\+Buff\+Entry} \&mb, bool is\+First, uint8\+\_\+t protocol)
\begin{DoxyCompactList}\small\item\em Schedule the packet retransmission based on network layer acknowledgment. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_ab0ce215bf5359f4d6d4541b8a479007c}{Link\+Schedule\+Timer\+Expire} (\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffEntry}{Dsr\+Maintain\+Buff\+Entry} \&mb, uint8\+\_\+t protocol)
\begin{DoxyCompactList}\small\item\em This function deals with packet retransmission timer expire using link acknowledgment. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_aabcdf59bcb4907718986626a7a402dad}{Network\+Schedule\+Timer\+Expire} (\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffEntry}{Dsr\+Maintain\+Buff\+Entry} \&mb, uint8\+\_\+t protocol)
\begin{DoxyCompactList}\small\item\em This function deals with packet retransmission timer expire using network acknowledgment. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_a2f93ffc379338703d6b6a923dff44dd5}{Passive\+Schedule\+Timer\+Expire} (\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffEntry}{Dsr\+Maintain\+Buff\+Entry} \&mb, uint8\+\_\+t protocol)
\begin{DoxyCompactList}\small\item\em This function deals with packet retransmission timer expire using passive acknowledgment. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_acae8a2eb510c8c9331104ab2aff29591}{Forward\+Packet} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1dsr_1_1DsrOptionSRHeader}{Dsr\+Option\+S\+R\+Header} \&source\+Route, \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} const \&ipv4\+Header, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} source, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} destination, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} target\+Address, uint8\+\_\+t protocol, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ route)
\begin{DoxyCompactList}\small\item\em Forward the packet using the route saved in the source route option header. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_a74777d1806e768fccc1c2fe169b42c98}{Send\+Initial\+Request} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} source, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} destination, uint8\+\_\+t protocol)
\begin{DoxyCompactList}\small\item\em Broadcast the route request packet in subnet. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_ae2100978eb9447540ceceeda17e95cea}{Send\+Error\+Request} (\hyperlink{classns3_1_1dsr_1_1DsrOptionRerrUnreachHeader}{Dsr\+Option\+Rerr\+Unreach\+Header} \&rerr, uint8\+\_\+t protocol)
\begin{DoxyCompactList}\small\item\em Send the error request packet. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_a21496638c09e75ea310e876135d0bf64}{Send\+Request} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} source)
\begin{DoxyCompactList}\small\item\em Forward the route request if the node is not the destination. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_a03175efa8103d392d90298f2d8985a29}{Schedule\+Inter\+Request} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet)
\begin{DoxyCompactList}\small\item\em Schedule the intermediate route request. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_a780988be538d2a1030d127f1d3c7932c}{Send\+Gratuitous\+Reply} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} reply\+To, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} reply\+From, std\+::vector$<$ \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} $>$ \&node\+List, uint8\+\_\+t protocol)
\begin{DoxyCompactList}\small\item\em Send the gratuitous reply. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_a69e03d265224fc60bf135b2496d97f04}{Send\+Reply} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} source, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} next\+Hop, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ route)
\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_a9987b38297fb1a4f4e175d5b81853464}{Schedule\+Initial\+Reply} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} source, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} next\+Hop, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ route)
\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_af078d9a9fe5a20264a93f481f6d0feb3}{Schedule\+Cached\+Reply} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} source, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} destination, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ route, double hops)
\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_af60f582ca5ce9871a1f582f052511a38}{Send\+Ack} (uint16\+\_\+t ack\+Id, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} destination, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} real\+Src, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} real\+Dst, uint8\+\_\+t protocol, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ route)
\item 
virtual enum \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80e}{Ip\+L4\+Protocol\+::\+Rx\+Status} \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4908cdae502d8bdca8a244d4420311e6}{Receive} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} const \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} $>$ incoming\+Interface)
\item 
virtual enum \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80e}{Ip\+L4\+Protocol\+::\+Rx\+Status} \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa0fd777071685501dfcf74f4a5102608}{Receive} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} const \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Interface}{Ipv6\+Interface} $>$ incoming\+Interface)
\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_a3831a9cac1a24f243f81e770ae4b9587}{Set\+Down\+Target} (\hyperlink{classns3_1_1IpL4Protocol_ae3ba76c0a48fbaa90529c528a15f12b6}{Ip\+L4\+Protocol\+::\+Down\+Target\+Callback} callback)
\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_a184a0f635df5cf3dac67c3eb97452dc8}{Set\+Down\+Target6} (\hyperlink{classns3_1_1IpL4Protocol_a039f3d1883632ab922fa958fc9ecd97f}{Ip\+L4\+Protocol\+::\+Down\+Target\+Callback6} callback)
\item 
\hyperlink{classns3_1_1IpL4Protocol_ae3ba76c0a48fbaa90529c528a15f12b6}{Ip\+L4\+Protocol\+::\+Down\+Target\+Callback} \hyperlink{classns3_1_1dsr_1_1DsrRouting_a62358ed8bc8d3df85af845522e84ad1a}{Get\+Down\+Target} (void) const 
\item 
\hyperlink{classns3_1_1IpL4Protocol_a039f3d1883632ab922fa958fc9ecd97f}{Ip\+L4\+Protocol\+::\+Down\+Target\+Callback6} \hyperlink{classns3_1_1dsr_1_1DsrRouting_acee265284cbac4dcf7764305ee7b6c99}{Get\+Down\+Target6} (void) const 
\item 
uint8\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_aae399429f2359860fbb7992313a2dbd1}{Process} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \&packet, \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} const \&ipv4\+Header, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} dst, uint8\+\_\+t $\ast$next\+Header, uint8\+\_\+t protocol, bool \&is\+Dropped)
\begin{DoxyCompactList}\small\item\em Process method Called from \hyperlink{classns3_1_1Ipv4L3Protocol_a2f27fb0a3f698ffb34a654323b063c94}{Ipv4\+L3\+Protocol\+::\+Receive}. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_af84bc8969d7d9e4ff167cab6bca88ce0}{Insert} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1dsr_1_1DsrOptions}{dsr\+::\+Dsr\+Options} $>$ option)
\begin{DoxyCompactList}\small\item\em Insert a new Dsr Option. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1dsr_1_1DsrOptions}{dsr\+::\+Dsr\+Options} $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5cdb4c336831a3158c6ba12d226a198e}{Get\+Option} (int option\+Number)
\begin{DoxyCompactList}\small\item\em Get the option corresponding to option\+Number. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_ad489fa602b093c8336cf4143ed60e429}{Cancel\+Rreq\+Timer} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} dst, bool is\+Remove)
\begin{DoxyCompactList}\small\item\em Cancel the route request timer. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_a056b38f3af6c2992be89b8fc5cb15448}{Schedule\+Rreq\+Retry} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, std\+::vector$<$ \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} $>$ address, bool non\+Prop, uint32\+\_\+t request\+Id, uint8\+\_\+t protocol)
\begin{DoxyCompactList}\small\item\em Schedule the route request retry. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa839b89cdf568048c4d09941b59e46d4}{Route\+Request\+Timer\+Expire} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, std\+::vector$<$ \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} $>$ address, uint32\+\_\+t request\+Id, uint8\+\_\+t protocol)
\item 
int64\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_aeaf02a6958f35bc630bae7729e9a7643}{Assign\+Streams} (int64\+\_\+t stream)
\end{DoxyCompactItemize}
{\bf }\par
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classns3_1_1dsr_1_1DsrRouting_a857054926335441b467ee12bdf160852}{Is\+Link\+Cache} ()
\begin{DoxyCompactList}\small\item\em functions used to direct to route cache \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_a1488df94bd0c30e86bce947bdab5b94e}{Use\+Extends} (\hyperlink{classns3_1_1dsr_1_1DsrRouteCacheEntry_ab834177006bdbfd2e3fa607c2a88cbdf}{Dsr\+Route\+Cache\+Entry\+::\+I\+P\+\_\+\+V\+E\+C\+T\+OR} rt)
\item 
bool \hyperlink{classns3_1_1dsr_1_1DsrRouting_a9b0d6cddf99a8825289e9d142ede2379}{Lookup\+Route} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} id, \hyperlink{classns3_1_1dsr_1_1DsrRouteCacheEntry}{Dsr\+Route\+Cache\+Entry} \&rt)
\item 
bool \hyperlink{classns3_1_1dsr_1_1DsrRouting_a38898aa39e12d5e96b56f3844b163bf1}{Add\+Route\+\_\+\+Link} (\hyperlink{classns3_1_1dsr_1_1DsrRouteCacheEntry_ab834177006bdbfd2e3fa607c2a88cbdf}{Dsr\+Route\+Cache\+Entry\+::\+I\+P\+\_\+\+V\+E\+C\+T\+OR} nodelist, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} source)
\item 
bool \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac56ce30b5f9242c5e930b65427f852f7}{Add\+Route} (\hyperlink{classns3_1_1dsr_1_1DsrRouteCacheEntry}{Dsr\+Route\+Cache\+Entry} \&rt)
\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_a7e1ee018d89708bc81f1dd7181b4cd36}{Delete\+All\+Routes\+Include\+Link} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} error\+Src, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} unreach\+Node, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} node)
\item 
bool \hyperlink{classns3_1_1dsr_1_1DsrRouting_ab193dd688e4f334420a6ffcecf5598c5}{Update\+Route\+Entry} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} dst)
\item 
bool \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5217c944c7299be31c764c533eb904d3}{Find\+Source\+Entry} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} src, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} dst, uint16\+\_\+t id)
\end{DoxyCompactItemize}

\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1dsr_1_1DsrRouting_add1c578a2b05d4e9bdd3d983b2e3b4ae}{Get\+Type\+Id} ()
\begin{DoxyCompactList}\small\item\em Get the type identificator. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const uint8\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_a66248f69fcf97af91d6fe17d70617cc9}{P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER} = 48
\begin{DoxyCompactList}\small\item\em Define the dsr protocol number. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1dsr_1_1DsrRouting_a7742bf3036dba9f9b24906b959be728e}{Notify\+New\+Aggregate} ()
\item 
virtual void \hyperlink{classns3_1_1dsr_1_1DsrRouting_a278734278728fc569d2d1ba58dcef0b9}{Do\+Dispose} (void)
\begin{DoxyCompactList}\small\item\em Drop trace callback. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_aacee2c8437c0b61579cfa7a420423e03}{m\+\_\+drop\+Trace}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ const \hyperlink{classns3_1_1dsr_1_1DsrOptionSRHeader}{Dsr\+Option\+S\+R\+Header} \& $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5e0a4e554d0321bd993b532d68931d75}{m\+\_\+tx\+Packet\+Trace}
\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1dsr_1_1DsrOptions}{Dsr\+Options} $>$ $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_a44a611adccbcf5776103154d0d2341d1}{Dsr\+Option\+List\+\_\+t}
\begin{DoxyCompactList}\small\item\em Define the list to hold D\+SR options. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa97c9bcf61e5623297563965740a8559}{Start} ()
\item 
void \hyperlink{classns3_1_1dsr_1_1DsrRouting_a0783bd1b2eb30dad7e578236cdac1388}{Send\+Rerr\+When\+Breaks\+Link\+To\+Next\+Hop} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} next\+Hop, uint8\+\_\+t protocol)
\begin{DoxyCompactList}\small\item\em Send the route error message when the link breaks to the next hop. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1dsr_1_1DsrRouting_a95d4ab6177fb07d4791a2ed82cd4a2bb}{Promisc\+Receive} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, uint16\+\_\+t protocol, const \hyperlink{classns3_1_1Address}{Address} \&\hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from}, const \hyperlink{classns3_1_1Address}{Address} \&to, \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2}{Net\+Device\+::\+Packet\+Type} packet\+Type)
\begin{DoxyCompactList}\small\item\em Promiscuous receive data packets destined to some other node. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1dsr_1_1DsrRouting_a44a611adccbcf5776103154d0d2341d1}{Dsr\+Option\+List\+\_\+t} \hyperlink{classns3_1_1dsr_1_1DsrRouting_a7f705d6856c04b7bce60317db968bf45}{m\+\_\+options}
\begin{DoxyCompactList}\small\item\em List of D\+SR Options supported. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4L3Protocol}{Ipv4\+L3\+Protocol} $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa42c1b9ee27c8168a2141d3d032006c3}{m\+\_\+ipv4}
\begin{DoxyCompactList}\small\item\em Ipv4l3\+Protocol. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_ab4c16d56044159989e52ad33c0afed2b}{m\+\_\+ipv4\+Route}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Ipv4}{Ipv4} Route. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_a0443d48172143cafa1d0491e35f3fbaf}{m\+\_\+ip}
\begin{DoxyCompactList}\small\item\em The ip ptr. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac27df0103a40973f0a3f78af0092c60d}{m\+\_\+node}
\begin{DoxyCompactList}\small\item\em The node ptr. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\+\_\+main\+Address}
\begin{DoxyCompactList}\small\item\em Our own Ip address. \end{DoxyCompactList}\item 
uint8\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_a2089307bfbe378b6cd8b274b38f70bb9}{segs\+Left}
\begin{DoxyCompactList}\small\item\em The segment left value from SR header. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1IpL4Protocol_ae3ba76c0a48fbaa90529c528a15f12b6}{Ip\+L4\+Protocol\+::\+Down\+Target\+Callback} \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa1eb6ea60fdf9ba2cac2079a74ce1ca4}{m\+\_\+down\+Target}
\begin{DoxyCompactList}\small\item\em The callback for down layer. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_ab2edb0a37a59600e15dbb91b5683ad25}{m\+\_\+max\+Network\+Size}
\begin{DoxyCompactList}\small\item\em Maximum network queue size. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5bf0e688251f1587471745f4355203c1}{m\+\_\+max\+Network\+Delay}
\begin{DoxyCompactList}\small\item\em Maximum network delay. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_acf9cc5a2ae446403b8b57f3340fac178}{m\+\_\+discovery\+Hop\+Limit}
\begin{DoxyCompactList}\small\item\em Maximum hops to go for route request. \end{DoxyCompactList}\item 
uint8\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_a89f7e66d9f1bd83433b004876acf4a45}{m\+\_\+max\+Salvage\+Count}
\begin{DoxyCompactList}\small\item\em Maximum \# times to salvage a packet. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1dsr_1_1DsrRouting_acb19e2fe8a4cc1812181cdd5491383ee}{m\+\_\+request\+Period}
\begin{DoxyCompactList}\small\item\em The base time interval between route requests. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1dsr_1_1DsrRouting_a42c2f43fbb0c5fefed36689eaf5c720e}{m\+\_\+nonprop\+Request\+Timeout}
\begin{DoxyCompactList}\small\item\em The non-\/propagation request timeout. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_a02a55fe3b490af4dbd62953065d293a3}{m\+\_\+send\+Retries}
\begin{DoxyCompactList}\small\item\em \subsection*{of retries have been sent for network acknowledgment}\end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_a88b8d65dce20b6b8f910be916623da0b}{m\+\_\+passive\+Retries}
\begin{DoxyCompactList}\small\item\em \subsection*{of retries have been sent for passive acknowledgment}\end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_a78b9a7405d3c905f57fa5aba63984d26}{m\+\_\+link\+Retries}
\begin{DoxyCompactList}\small\item\em \subsection*{of retries have been sent for link acknowledgment}\end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_a88bbff666cd3bb5bad099587a967d547}{m\+\_\+rreq\+Retries}
\begin{DoxyCompactList}\small\item\em Maximum number of retransmissions of R\+R\+EQ with T\+TL = Net\+Diameter to discover a route. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_aca44a3d45b57be61ec3e41774f20c1fb}{m\+\_\+max\+Maint\+Rexmt}
\begin{DoxyCompactList}\small\item\em Maximum number of retransmissions of data packets. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4c406057009653878e8cdf3e3a7f2106}{m\+\_\+node\+Traversal\+Time}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Time}{Time} estimated for packet to travel between two nodes. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5cf78026e2a25a4468c04745f4a10c13}{m\+\_\+max\+Send\+Buff\+Len}
\begin{DoxyCompactList}\small\item\em The maximum number of packets that we allow a routing protocol to buffer. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1dsr_1_1DsrRouting_a1f89794801db0336d92e4ca85fbc09a7}{m\+\_\+send\+Buffer\+Timeout}
\begin{DoxyCompactList}\small\item\em The maximum period of time that a routing protocol is allowed to buffer a packet for. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1dsr_1_1DsrSendBuffer}{Dsr\+Send\+Buffer} \hyperlink{classns3_1_1dsr_1_1DsrRouting_a887ae39d7060171753c0605d5c120549}{m\+\_\+send\+Buffer}
\begin{DoxyCompactList}\small\item\em The send buffer. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1dsr_1_1DsrErrorBuffer}{Dsr\+Error\+Buffer} \hyperlink{classns3_1_1dsr_1_1DsrRouting_a802e15bf588fd1e9ccd401221461397a}{m\+\_\+error\+Buffer}
\begin{DoxyCompactList}\small\item\em The error buffer to save the error messages. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_a65f608e0cfba00495392f94938fc02c0}{m\+\_\+max\+Maintain\+Len}
\begin{DoxyCompactList}\small\item\em Max \# of entries for maintainance buffer. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac6b1dffa9665af0d6a71aa7b947962ee}{m\+\_\+max\+Maintain\+Time}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Time}{Time} out for maintainance buffer. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_afce2c0909aecc7dfe4528f7f6b042019}{m\+\_\+max\+Cache\+Len}
\begin{DoxyCompactList}\small\item\em Max \# of cache entries for route cache. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1dsr_1_1DsrRouting_a76d8abfedbda7429e983c407748400be}{m\+\_\+max\+Cache\+Time}
\begin{DoxyCompactList}\small\item\em Max time for caching the route cache entry. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1dsr_1_1DsrRouting_a8f44b1800a0eff487b8490c65cee2d0a}{m\+\_\+max\+Rreq\+Time}
\begin{DoxyCompactList}\small\item\em Max time for caching the route request entry. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_a470ec4bd470cd1d802621752331d9916}{m\+\_\+max\+Entries\+Each\+Dst}
\begin{DoxyCompactList}\small\item\em Max number of route entries to save for each destination. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer}{Dsr\+Maintain\+Buffer} \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac9d28a64437fbe20a4228c9811f9fc27}{m\+\_\+maintain\+Buffer}
\begin{DoxyCompactList}\small\item\em The declaration of maintain buffer. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4d9ddfed8e907a5885bb5e0f4b41f388}{m\+\_\+request\+Id}
\begin{DoxyCompactList}\small\item\em The id assigned to each route request. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_a38c5f8c952141a9853ae9f8ee116e292}{m\+\_\+ack\+Id}
\begin{DoxyCompactList}\small\item\em The ack id assigned to each acknowledge. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_a8f6df12e2c9690f79943c2195af1be37}{m\+\_\+request\+Table\+Size}
\begin{DoxyCompactList}\small\item\em The max size of the request table size. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_aac8b18967bf0bc05a7f0024ea55e99b1}{m\+\_\+request\+Table\+Ids}
\begin{DoxyCompactList}\small\item\em The request table identifiers. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_a14ef1332178e76768359c27a45db9624}{m\+\_\+max\+Rreq\+Id}
\begin{DoxyCompactList}\small\item\em The max number of request ids for a single destination. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1dsr_1_1DsrRouting_a07022fdee22444ddb4560c1f78bccaf2}{m\+\_\+blacklist\+Timeout}
\begin{DoxyCompactList}\small\item\em The black list time out. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \hyperlink{classns3_1_1dsr_1_1DsrRouting_a52d4ef78c13236c73c60db85c0088ff6}{m\+\_\+broadcast}
\begin{DoxyCompactList}\small\item\em The broadcast IP address. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_afb77e13fc791e5076ee1f8595b9c6617}{m\+\_\+broadcast\+Jitter}
\begin{DoxyCompactList}\small\item\em The max time to delay route request broadcast. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1dsr_1_1DsrRouting_a6155bddae63f0e1fda8afbeebc25a54c}{m\+\_\+passive\+Ack\+Timeout}
\begin{DoxyCompactList}\small\item\em The timeout value for passive acknowledge. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_aadd1dd676ec50cae94ffd6f2eefb277c}{m\+\_\+try\+Passive\+Acks}
\begin{DoxyCompactList}\small\item\em Maximum number of packet transmission using passive acknowledgment. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1dsr_1_1DsrRouting_ace1671263c7f09cd2523f1c81dc41631}{m\+\_\+link\+Ack\+Timeout}
\begin{DoxyCompactList}\small\item\em The timeout value for link acknowledge. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_acecdd106e259c448bcfa6a6cef901658}{m\+\_\+try\+Link\+Acks}
\begin{DoxyCompactList}\small\item\em Maximum number of packet transmission using link acknowledgment. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Timer}{Timer} \hyperlink{classns3_1_1dsr_1_1DsrRouting_a7676aff7f691319b764fba26a726ef5d}{m\+\_\+send\+Buff\+Timer}
\begin{DoxyCompactList}\small\item\em The send buffer timer. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1dsr_1_1DsrRouting_a966d7c644a941e3e6365859983816e8b}{m\+\_\+send\+Buff\+Interval}
\begin{DoxyCompactList}\small\item\em how often to check send buffer \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1dsr_1_1DsrRouting_a43f5d8b4569f2122788518584ce3ae77}{m\+\_\+grat\+Reply\+Holdoff}
\begin{DoxyCompactList}\small\item\em The max gratuitous reply hold off time. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1dsr_1_1DsrRouting_abce8e7bae58dada0db217ca294cb4c6e}{m\+\_\+max\+Request\+Period}
\begin{DoxyCompactList}\small\item\em The max request period. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa22d7408adbcefde51113d45b83d415f}{m\+\_\+gra\+Reply\+Table\+Size}
\begin{DoxyCompactList}\small\item\em Set the gratuitous reply table size. \end{DoxyCompactList}\item 
std\+::string \hyperlink{classns3_1_1dsr_1_1DsrRouting_a07e25fa5f4aebf7b129a31853988045b}{m\+\_\+cache\+Type}
\begin{DoxyCompactList}\small\item\em The type of route cache. \end{DoxyCompactList}\item 
std\+::string \hyperlink{classns3_1_1dsr_1_1DsrRouting_a02b1f61021bb9db1a72bcff2eb4b496d}{m\+\_\+route\+Sort\+Type}
\begin{DoxyCompactList}\small\item\em The type of route sort methods. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4a6db69db44738ae07289fa0993ac916}{m\+\_\+stability\+Decr\+Factor}
\begin{DoxyCompactList}\small\item\em The initial decrease factor for link cache. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_a9c6b73944ece2adc5f06b5010d9e55f2}{m\+\_\+stability\+Incr\+Factor}
\begin{DoxyCompactList}\small\item\em The initial increase factor for link cache. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1dsr_1_1DsrRouting_a9b68bafde23cf10e425d341f91da3b5e}{m\+\_\+init\+Stability}
\begin{DoxyCompactList}\small\item\em The initial stability value for link cache. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1dsr_1_1DsrRouting_ad7daf5388ab1104e535b27bb4eae1421}{m\+\_\+min\+Life\+Time}
\begin{DoxyCompactList}\small\item\em The min life time. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa0a73bc163b0b32c84a5913ebbb62dc5}{m\+\_\+use\+Extends}
\begin{DoxyCompactList}\small\item\em The use extension of the life time for link cache. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1dsr_1_1DsrRouting_a83f7a7d54f8b078d987d46cf6edcd08e}{m\+\_\+sub\+Route}
\begin{DoxyCompactList}\small\item\em Whether to save sub route or not. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1dsr_1_1DsrRouting_a49d8f2c59b9e8bcd6cb57cb302eac47b}{m\+\_\+retrans\+Incr}
\begin{DoxyCompactList}\small\item\em the increase time for retransmission timer when face network congestion \end{DoxyCompactList}\item 
std\+::vector$<$ \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_afb085eaa8fcab547a83f683ef5aef41a}{m\+\_\+final\+Route}
\begin{DoxyCompactList}\small\item\em The route cache. \end{DoxyCompactList}\item 
std\+::map$<$ \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address}, \hyperlink{classns3_1_1Timer}{Timer} $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_a47174823b0622573b681afc40d6ea558}{m\+\_\+address\+Req\+Timer}
\begin{DoxyCompactList}\small\item\em Map IP address + R\+R\+EQ timer. \end{DoxyCompactList}\item 
std\+::map$<$ \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address}, \hyperlink{classns3_1_1Timer}{Timer} $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_a0936df610f90f7e79c24a2a8cdea6c14}{m\+\_\+non\+Prop\+Req\+Timer}
\begin{DoxyCompactList}\small\item\em Map IP address + R\+R\+EQ timer. \end{DoxyCompactList}\item 
std\+::map$<$ \hyperlink{structns3_1_1dsr_1_1NetworkKey}{Network\+Key}, \hyperlink{classns3_1_1Timer}{Timer} $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4a35b13cdca413ab5bc0b1b3b7b78907}{m\+\_\+address\+Forward\+Timer}
\begin{DoxyCompactList}\small\item\em Map network key + forward timer. \end{DoxyCompactList}\item 
std\+::map$<$ \hyperlink{structns3_1_1dsr_1_1NetworkKey}{Network\+Key}, uint32\+\_\+t $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5042f7e5df0470025fdb6023fcc24411}{m\+\_\+address\+Forward\+Cnt}
\begin{DoxyCompactList}\small\item\em Map network key + forward counts. \end{DoxyCompactList}\item 
std\+::map$<$ \hyperlink{structns3_1_1dsr_1_1PassiveKey}{Passive\+Key}, uint32\+\_\+t $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_a7fec404d680459aab2b40941a950502d}{m\+\_\+passive\+Cnt}
\begin{DoxyCompactList}\small\item\em Map packet key + passive forward counts. \end{DoxyCompactList}\item 
std\+::map$<$ \hyperlink{structns3_1_1dsr_1_1PassiveKey}{Passive\+Key}, \hyperlink{classns3_1_1Timer}{Timer} $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac53c706898e76a7f4871a460d13edd36}{m\+\_\+passive\+Ack\+Timer}
\begin{DoxyCompactList}\small\item\em The timer for passive acknowledgment. \end{DoxyCompactList}\item 
std\+::map$<$ \hyperlink{structns3_1_1dsr_1_1LinkKey}{Link\+Key}, uint32\+\_\+t $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_a85ba159639f9bc13b3d8890458128a79}{m\+\_\+link\+Cnt}
\begin{DoxyCompactList}\small\item\em Map packet key + link forward counts. \end{DoxyCompactList}\item 
std\+::map$<$ \hyperlink{structns3_1_1dsr_1_1LinkKey}{Link\+Key}, \hyperlink{classns3_1_1Timer}{Timer} $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_ad532172035dbd4b038de0e94f4ce5ff6}{m\+\_\+link\+Ack\+Timer}
\begin{DoxyCompactList}\small\item\em The timer for link acknowledgment. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1dsr_1_1DsrRouteCache}{dsr\+::\+Dsr\+Route\+Cache} $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\+\_\+route\+Cache}
\begin{DoxyCompactList}\small\item\em A \char`\"{}drop-\/front\char`\"{} queue used by the routing layer to cache routes found. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1dsr_1_1DsrRreqTable}{dsr\+::\+Dsr\+Rreq\+Table} $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_ae9ec27743735fa2d59cc5190961d1942}{m\+\_\+rreq\+Table}
\begin{DoxyCompactList}\small\item\em A \char`\"{}drop-\/front\char`\"{} queue used by the routing layer to cache route request sent. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1dsr_1_1DsrPassiveBuffer}{dsr\+::\+Dsr\+Passive\+Buffer} $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac0404985fc04df7f5b8f53ff1e487079}{m\+\_\+passive\+Buffer}
\begin{DoxyCompactList}\small\item\em A \char`\"{}drop-\/front\char`\"{} queue used by the routing layer to cache route request sent. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa1952258d04f2ca8a0980d8436bca317}{m\+\_\+num\+Priority\+Queues}
\begin{DoxyCompactList}\small\item\em The number of priority queues used. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1dsr_1_1DsrRouting_a216a52d8b579a034df948765d941d3a4}{m\+\_\+link\+Ack}
\begin{DoxyCompactList}\small\item\em define if we use link acknowledgement or not \end{DoxyCompactList}\item 
std\+::map$<$ uint32\+\_\+t, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1dsr_1_1DsrNetworkQueue}{dsr\+::\+Dsr\+Network\+Queue} $>$ $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4606c3dfb1099afbfe1e7cd1d1c3c8ee}{m\+\_\+priority\+Queue}
\begin{DoxyCompactList}\small\item\em priority queues \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1dsr_1_1DsrGraReply}{Dsr\+Gra\+Reply} \hyperlink{classns3_1_1dsr_1_1DsrRouting_a9208badf7697dda01917aa2034b0b59c}{m\+\_\+gra\+Reply}
\begin{DoxyCompactList}\small\item\em The gratuitous route reply. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1dsr_1_1DsrNetworkQueue}{Dsr\+Network\+Queue} \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4a59e341508820cdc2e46bcc7f7db59c}{m\+\_\+network\+Queue}
\begin{DoxyCompactList}\small\item\em The network queue. \end{DoxyCompactList}\item 
std\+::vector$<$ \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_add76dd26d3fd2721ab9be4520daa477f}{m\+\_\+clear\+List}
\begin{DoxyCompactList}\small\item\em The node that is clear to send packet to. \end{DoxyCompactList}\item 
std\+::vector$<$ \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_a350fab49fe12651b852fa42363684990}{m\+\_\+addresses}
\begin{DoxyCompactList}\small\item\em The bind ipv4 addresses with next hop, src, destination address in sequence. \end{DoxyCompactList}\item 
std\+::map$<$ std\+::string, uint32\+\_\+t $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_aadd597196a7816f0eca78f213a3aae44}{m\+\_\+mac\+To\+Node\+Id\+Map}
\begin{DoxyCompactList}\small\item\em The map of mac address to node id. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UniformRandomVariable}{Uniform\+Random\+Variable} $>$ \hyperlink{classns3_1_1dsr_1_1DsrRouting_a22a85b3510166ffdd451e4010f996f0f}{m\+\_\+uniform\+Random\+Variable}
\begin{DoxyCompactList}\small\item\em Provides uniform random variables. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Dsr Routing base. 

\subsection{Member Typedef Documentation}
\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Dsr\+Option\+List\+\_\+t@{Dsr\+Option\+List\+\_\+t}}
\index{Dsr\+Option\+List\+\_\+t@{Dsr\+Option\+List\+\_\+t}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Dsr\+Option\+List\+\_\+t}{DsrOptionList_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Ptr}$<${\bf Dsr\+Options}$>$ $>$ {\bf ns3\+::dsr\+::\+Dsr\+Routing\+::\+Dsr\+Option\+List\+\_\+t}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a44a611adccbcf5776103154d0d2341d1}{}\label{classns3_1_1dsr_1_1DsrRouting_a44a611adccbcf5776103154d0d2341d1}


Define the list to hold D\+SR options. 



\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Dsr\+Routing@{Dsr\+Routing}}
\index{Dsr\+Routing@{Dsr\+Routing}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Dsr\+Routing()}{DsrRouting()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::dsr\+::\+Dsr\+Routing\+::\+Dsr\+Routing (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a3b686bd293d4bd096180a1996171ccd1}{}\label{classns3_1_1dsr_1_1DsrRouting_a3b686bd293d4bd096180a1996171ccd1}


Constructor. 


\begin{DoxyCode}
357 \{
358   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
359 
360   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a22a85b3510166ffdd451e4010f996f0f}{m\_uniformRandomVariable} = CreateObject<UniformRandomVariable> ();
361 
362   \textcolor{comment}{/*}
363 \textcolor{comment}{   * The following Ptr statements created objects for all the options header for DSR, and each of them have}
364 \textcolor{comment}{   * distinct option number assigned, when DSR Routing received a packet from higher layer, it will find}
365 \textcolor{comment}{   * the following options based on the option number, and pass the packet to the appropriate option to}
366 \textcolor{comment}{   * process it. After the option processing, it will pass the packet back to DSR Routing to send down
       layer.}
367 \textcolor{comment}{   */}
368   Ptr<dsr::DsrOptionPad1> pad1Option = CreateObject<dsr::DsrOptionPad1> ();
369   Ptr<dsr::DsrOptionPadn> padnOption = CreateObject<dsr::DsrOptionPadn> ();
370   Ptr<dsr::DsrOptionRreq> rreqOption = CreateObject<dsr::DsrOptionRreq> ();
371   Ptr<dsr::DsrOptionRrep> rrepOption = CreateObject<dsr::DsrOptionRrep> ();
372   Ptr<dsr::DsrOptionSR>   srOption = CreateObject<dsr::DsrOptionSR> ();
373   Ptr<dsr::DsrOptionRerr>   rerrOption = CreateObject<dsr::DsrOptionRerr> ();
374   Ptr<dsr::DsrOptionAckReq> ackReq = CreateObject<dsr::DsrOptionAckReq> ();
375   Ptr<dsr::DsrOptionAck> ack = CreateObject<dsr::DsrOptionAck> ();
376 
377   \hyperlink{classns3_1_1dsr_1_1DsrRouting_af84bc8969d7d9e4ff167cab6bca88ce0}{Insert} (pad1Option);
378   \hyperlink{classns3_1_1dsr_1_1DsrRouting_af84bc8969d7d9e4ff167cab6bca88ce0}{Insert} (padnOption);
379   \hyperlink{classns3_1_1dsr_1_1DsrRouting_af84bc8969d7d9e4ff167cab6bca88ce0}{Insert} (rreqOption);
380   \hyperlink{classns3_1_1dsr_1_1DsrRouting_af84bc8969d7d9e4ff167cab6bca88ce0}{Insert} (rrepOption);
381   \hyperlink{classns3_1_1dsr_1_1DsrRouting_af84bc8969d7d9e4ff167cab6bca88ce0}{Insert} (srOption);
382   \hyperlink{classns3_1_1dsr_1_1DsrRouting_af84bc8969d7d9e4ff167cab6bca88ce0}{Insert} (rerrOption);
383   \hyperlink{classns3_1_1dsr_1_1DsrRouting_af84bc8969d7d9e4ff167cab6bca88ce0}{Insert} (ackReq);
384   \hyperlink{classns3_1_1dsr_1_1DsrRouting_af84bc8969d7d9e4ff167cab6bca88ce0}{Insert} (ack);
385 
386   \textcolor{comment}{// Check the send buffer for sending packets}
387   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a7676aff7f691319b764fba26a726ef5d}{m\_sendBuffTimer}.\hyperlink{classns3_1_1Timer_a044b29030c9de99298d51ac0ccfc104c}{SetFunction} (&
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a10273aec775b5cf12eafb03ee46c4397}{DsrRouting::SendBuffTimerExpire}, \textcolor{keyword}{this});
388   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a7676aff7f691319b764fba26a726ef5d}{m\_sendBuffTimer}.\hyperlink{classns3_1_1Timer_ac3345d696887578f518b19f359f7f94b}{Schedule} (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (100));
389 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!````~Dsr\+Routing@{$\sim$\+Dsr\+Routing}}
\index{````~Dsr\+Routing@{$\sim$\+Dsr\+Routing}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{$\sim$\+Dsr\+Routing()}{~DsrRouting()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::dsr\+::\+Dsr\+Routing\+::$\sim$\+Dsr\+Routing (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_af7baa9f4a344a7ce6d36d5a543cdb962}{}\label{classns3_1_1dsr_1_1DsrRouting_af7baa9f4a344a7ce6d36d5a543cdb962}


Destructor. 


\begin{DoxyCode}
392 \{
393   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
394 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Add\+Ack\+Req\+Header@{Add\+Ack\+Req\+Header}}
\index{Add\+Ack\+Req\+Header@{Add\+Ack\+Req\+Header}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Add\+Ack\+Req\+Header(\+Ptr$<$ Packet $>$ \&packet, Ipv4\+Address next\+Hop)}{AddAckReqHeader(Ptr< Packet > &packet, Ipv4Address nextHop)}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::\+Add\+Ack\+Req\+Header (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$ \&}]{packet, }
\item[{{\bf Ipv4\+Address}}]{next\+Hop}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a8ce910f1c56dc238ff98117c784c4541}{}\label{classns3_1_1dsr_1_1DsrRouting_a8ce910f1c56dc238ff98117c784c4541}


This function is called to add ack request header for network acknowledgement. 


\begin{DoxyCode}
1562 \{
1563   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << nextHop);
1564   \textcolor{comment}{// This packet is used to peek option type}
1565   Ptr<Packet> dsrP = packet->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} ();
1566   Ptr<Packet> tmpP = packet->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} ();
1567 
1568   DsrRoutingHeader dsrRoutingHeader;
1569   dsrP->\hyperlink{classns3_1_1Packet_a0961eccf975d75f902d40956c93ba63e}{RemoveHeader} (dsrRoutingHeader);          \textcolor{comment}{// Remove the DSR header in whole}
1570   uint8\_t protocol = dsrRoutingHeader.GetNextHeader ();
1571   uint32\_t sourceId = dsrRoutingHeader.GetSourceId ();
1572   uint32\_t destinationId = dsrRoutingHeader.GetDestId ();
1573   uint32\_t offset = dsrRoutingHeader.GetDsrOptionsOffset ();
1574   tmpP->RemoveAtStart (offset);       \textcolor{comment}{// Here the processed size is 8 bytes, which is the fixed sized
       extension header}
1575 
1576   \textcolor{comment}{// Get the number of routers' address field}
1577   uint8\_t buf[2];
1578   tmpP->CopyData (buf, \textcolor{keyword}{sizeof}(buf));
1579   uint8\_t numberAddress = (buf[1] - 2) / 4;
1580   DsrOptionSRHeader sourceRoute;
1581   sourceRoute.SetNumberAddress (numberAddress);
1582   tmpP->RemoveHeader (sourceRoute);               \textcolor{comment}{// this is a clean packet without any dsr involved
       headers}
1583 
1584   DsrOptionAckReqHeader ackReq;
1585   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a38c5f8c952141a9853ae9f8ee116e292}{m\_ackId} = \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->CheckUniqueAckId (nextHop);
1586   ackReq.SetAckId (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a38c5f8c952141a9853ae9f8ee116e292}{m\_ackId});
1587   uint8\_t length = (sourceRoute.GetLength () + ackReq.GetLength ());
1588   DsrRoutingHeader newDsrRoutingHeader;
1589   newDsrRoutingHeader.SetNextHeader (protocol);
1590   newDsrRoutingHeader.SetMessageType (2);
1591   newDsrRoutingHeader.SetSourceId (sourceId);
1592   newDsrRoutingHeader.SetDestId (destinationId);
1593   newDsrRoutingHeader.SetPayloadLength (length + 4);
1594   newDsrRoutingHeader.AddDsrOption (sourceRoute);
1595   newDsrRoutingHeader.AddDsrOption (ackReq);
1596   dsrP->AddHeader (newDsrRoutingHeader);
1597   \textcolor{comment}{// give the dsrP value to packet and then return}
1598   packet = dsrP;
1599   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1dsr_1_1DsrRouting_a38c5f8c952141a9853ae9f8ee116e292}{m\_ackId};
1600 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3




Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Add\+Route@{Add\+Route}}
\index{Add\+Route@{Add\+Route}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Add\+Route(\+Dsr\+Route\+Cache\+Entry \&rt)}{AddRoute(DsrRouteCacheEntry &rt)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::dsr\+::\+Dsr\+Routing\+::\+Add\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Dsr\+Route\+Cache\+Entry} \&}]{rt}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_ac56ce30b5f9242c5e930b65427f852f7}{}\label{classns3_1_1dsr_1_1DsrRouting_ac56ce30b5f9242c5e930b65427f852f7}

\begin{DoxyCode}
665 \{
666   std::vector<Ipv4Address> nodelist = rt.GetVector ();
667   Ipv4Address nextHop = \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa1b16658c14499af76ca7dd69c034f22}{SearchNextHop} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, nodelist);
668   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a802e15bf588fd1e9ccd401221461397a}{m\_errorBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrErrorBuffer_a6fc7e8bf24bb1a17c7b5ba809e036584}{DropPacketForErrLink} (
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, nextHop);
669   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->AddRoute (rt);
670 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Add\+Route\+\_\+\+Link@{Add\+Route\+\_\+\+Link}}
\index{Add\+Route\+\_\+\+Link@{Add\+Route\+\_\+\+Link}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Add\+Route\+\_\+\+Link(\+Dsr\+Route\+Cache\+Entry\+::\+I\+P\+\_\+\+V\+E\+C\+T\+O\+R nodelist, Ipv4\+Address source)}{AddRoute_Link(DsrRouteCacheEntry::IP_VECTOR nodelist, Ipv4Address source)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::dsr\+::\+Dsr\+Routing\+::\+Add\+Route\+\_\+\+Link (
\begin{DoxyParamCaption}
\item[{{\bf Dsr\+Route\+Cache\+Entry\+::\+I\+P\+\_\+\+V\+E\+C\+T\+OR}}]{nodelist, }
\item[{{\bf Ipv4\+Address}}]{source}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a38898aa39e12d5e96b56f3844b163bf1}{}\label{classns3_1_1dsr_1_1DsrRouting_a38898aa39e12d5e96b56f3844b163bf1}

\begin{DoxyCode}
658 \{
659   Ipv4Address nextHop = \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa1b16658c14499af76ca7dd69c034f22}{SearchNextHop} (source, nodelist);
660   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a802e15bf588fd1e9ccd401221461397a}{m\_errorBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrErrorBuffer_a6fc7e8bf24bb1a17c7b5ba809e036584}{DropPacketForErrLink} (source, nextHop);
661   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->AddRoute\_Link (nodelist, source);
662 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Assign\+Streams@{Assign\+Streams}}
\index{Assign\+Streams@{Assign\+Streams}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Assign\+Streams(int64\+\_\+t stream)}{AssignStreams(int64_t stream)}}]{\setlength{\rightskip}{0pt plus 5cm}int64\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::\+Assign\+Streams (
\begin{DoxyParamCaption}
\item[{int64\+\_\+t}]{stream}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_aeaf02a6958f35bc630bae7729e9a7643}{}\label{classns3_1_1dsr_1_1DsrRouting_aeaf02a6958f35bc630bae7729e9a7643}
Assign a fixed random variable stream number to the random variables used by this model. Return the number of streams (possibly zero) that have been assigned.


\begin{DoxyParams}{Parameters}
{\em stream} & first stream index to use \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of stream indices assigned by this model 
\end{DoxyReturn}

\begin{DoxyCode}
2621 \{
2622   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << stream);
2623   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a22a85b3510166ffdd451e4010f996f0f}{m\_uniformRandomVariable}->\hyperlink{classns3_1_1RandomVariableStream_add11aaf975607746b7e271d300659a94}{SetStream} (stream);
2624   \textcolor{keywordflow}{return} 1;
2625 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Call\+Cancel\+Packet\+Timer@{Call\+Cancel\+Packet\+Timer}}
\index{Call\+Cancel\+Packet\+Timer@{Call\+Cancel\+Packet\+Timer}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Call\+Cancel\+Packet\+Timer(uint16\+\_\+t ack\+Id, Ipv4\+Header const \&ipv4\+Header, Ipv4\+Address real\+Src, Ipv4\+Address real\+Dst)}{CallCancelPacketTimer(uint16_t ackId, Ipv4Header const &ipv4Header, Ipv4Address realSrc, Ipv4Address realDst)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Call\+Cancel\+Packet\+Timer (
\begin{DoxyParamCaption}
\item[{uint16\+\_\+t}]{ack\+Id, }
\item[{{\bf Ipv4\+Header} const \&}]{ipv4\+Header, }
\item[{{\bf Ipv4\+Address}}]{real\+Src, }
\item[{{\bf Ipv4\+Address}}]{real\+Dst}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a720cc99dcbb0bc42539f0cab37018ae6}{}\label{classns3_1_1dsr_1_1DsrRouting_a720cc99dcbb0bc42539f0cab37018ae6}


Call the cancel packet retransmission timer function. 


\begin{DoxyCode}
2030 \{
2031   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << (uint32\_t)ackId << ipv4Header << realSrc << realDst);
2032   Ipv4Address sender = ipv4Header.GetDestination ();
2033   Ipv4Address receiver = ipv4Header.GetSource ();
2034   \textcolor{comment}{/*}
2035 \textcolor{comment}{   * Create a packet to fill maintenance buffer, not used to compare with maintainance entry}
2036 \textcolor{comment}{   * The reason is ack header doesn't have the original packet copy}
2037 \textcolor{comment}{   */}
2038   Ptr<Packet> mainP = Create<Packet> ();
2039   DsrMaintainBuffEntry newEntry (\textcolor{comment}{/*Packet=*/} mainP, \textcolor{comment}{/*ourAddress=*/} sender, \textcolor{comment}{/*nextHop=*/} receiver,
2040                                           \textcolor{comment}{/*source=*/} realSrc, \textcolor{comment}{/*destination=*/} realDst, \textcolor{comment}{/*ackId=*/} ackId,
2041                                           \textcolor{comment}{/*SegsLeft=*/} 0, \textcolor{comment}{/*expire time=*/} 
      \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ());
2042   \hyperlink{classns3_1_1dsr_1_1DsrRouting_aeed35bcacf68c9f349078b508e73c9aa}{CancelNetworkPacketTimer} (newEntry);  \textcolor{comment}{// Only need to cancel network packet timer}
2043 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Cancel\+Link\+Packet\+Timer@{Cancel\+Link\+Packet\+Timer}}
\index{Cancel\+Link\+Packet\+Timer@{Cancel\+Link\+Packet\+Timer}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Cancel\+Link\+Packet\+Timer(\+Dsr\+Maintain\+Buff\+Entry \&mb)}{CancelLinkPacketTimer(DsrMaintainBuffEntry &mb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Cancel\+Link\+Packet\+Timer (
\begin{DoxyParamCaption}
\item[{{\bf Dsr\+Maintain\+Buff\+Entry} \&}]{mb}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a3d5aef30dc62293cdc487b7110be2324}{}\label{classns3_1_1dsr_1_1DsrRouting_a3d5aef30dc62293cdc487b7110be2324}


Cancel the link packet retransmission timer for a specific maintenance entry. 

T\+O\+DO need to think about this part 
\begin{DoxyCode}
2056 \{
2057   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
2058   LinkKey linkKey;
2059   linkKey.m\_ourAdd = mb.GetOurAdd ();
2060   linkKey.m\_nextHop = mb.GetNextHop ();
2061   linkKey.m\_source = mb.GetSrc ();
2062   linkKey.m\_destination = mb.GetDst ();
2063   \textcolor{comment}{/*}
2064 \textcolor{comment}{   * Here we have found the entry for send retries, so we get the value and increase it by one}
2065 \textcolor{comment}{   */}
2067   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a85ba159639f9bc13b3d8890458128a79}{m\_linkCnt}[linkKey] = 0;
2068   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a85ba159639f9bc13b3d8890458128a79}{m\_linkCnt}.erase (linkKey);
2069 
2070   \textcolor{comment}{// TODO if find the linkkey, we need to remove it}
2071 
2072   \textcolor{comment}{// Find the network acknowledgment timer}
2073   std::map<LinkKey, Timer>::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} =
2074     \hyperlink{classns3_1_1dsr_1_1DsrRouting_ad532172035dbd4b038de0e94f4ce5ff6}{m\_linkAckTimer}.find (linkKey);
2075   \textcolor{keywordflow}{if} (i == \hyperlink{classns3_1_1dsr_1_1DsrRouting_ad532172035dbd4b038de0e94f4ce5ff6}{m\_linkAckTimer}.end ())
2076     \{
2077       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"did not find the link timer"});
2078     \}
2079   \textcolor{keywordflow}{else}
2080     \{
2081       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"did find the link timer"});
2082       \textcolor{comment}{/*}
2083 \textcolor{comment}{       * Schedule the packet retry}
2084 \textcolor{comment}{       * Push back the nextHop, source, destination address}
2085 \textcolor{comment}{       */}
2086       \hyperlink{classns3_1_1dsr_1_1DsrRouting_ad532172035dbd4b038de0e94f4ce5ff6}{m\_linkAckTimer}[linkKey].Cancel ();
2087       \hyperlink{classns3_1_1dsr_1_1DsrRouting_ad532172035dbd4b038de0e94f4ce5ff6}{m\_linkAckTimer}[linkKey].Remove ();
2088       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ad532172035dbd4b038de0e94f4ce5ff6}{m\_linkAckTimer}[linkKey].IsRunning ())
2089         \{
2090           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Timer not canceled"});
2091         \}
2092       \hyperlink{classns3_1_1dsr_1_1DsrRouting_ad532172035dbd4b038de0e94f4ce5ff6}{m\_linkAckTimer}.erase (linkKey);
2093     \}
2094 
2095   \textcolor{comment}{// Erase the maintenance entry}
2096   \textcolor{comment}{// yet this does not check the segments left value here}
2097   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The link buffer size "} << \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac9d28a64437fbe20a4228c9811f9fc27}{m\_maintainBuffer}.
      \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a7df015a7d740c8b442df20f4ab3895b7}{GetSize}());
2098   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ac9d28a64437fbe20a4228c9811f9fc27}{m\_maintainBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a35cc9dcd004a3a860f03d61ffe9478ef}{LinkEqual} (mb))
2099     \{
2100       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Link acknowledgment received, remove same maintenance buffer entry"});
2101     \}
2102 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9




Here is the caller graph for this function\+:
% FIG 10


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Cancel\+Network\+Packet\+Timer@{Cancel\+Network\+Packet\+Timer}}
\index{Cancel\+Network\+Packet\+Timer@{Cancel\+Network\+Packet\+Timer}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Cancel\+Network\+Packet\+Timer(\+Dsr\+Maintain\+Buff\+Entry \&mb)}{CancelNetworkPacketTimer(DsrMaintainBuffEntry &mb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Cancel\+Network\+Packet\+Timer (
\begin{DoxyParamCaption}
\item[{{\bf Dsr\+Maintain\+Buff\+Entry} \&}]{mb}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_aeed35bcacf68c9f349078b508e73c9aa}{}\label{classns3_1_1dsr_1_1DsrRouting_aeed35bcacf68c9f349078b508e73c9aa}


Cancel the network packet retransmission timer for a specific maintenance entry. 


\begin{DoxyCode}
2106 \{
2107   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
2108   NetworkKey networkKey;
2109   networkKey.m\_ackId = mb.GetAckId ();
2110   networkKey.m\_ourAdd = mb.GetOurAdd ();
2111   networkKey.m\_nextHop = mb.GetNextHop ();
2112   networkKey.m\_source = mb.GetSrc ();
2113   networkKey.m\_destination = mb.GetDst ();
2114   \textcolor{comment}{/*}
2115 \textcolor{comment}{   * Here we have found the entry for send retries, so we get the value and increase it by one}
2116 \textcolor{comment}{   */}
2117   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5042f7e5df0470025fdb6023fcc24411}{m\_addressForwardCnt}[networkKey] = 0;
2118   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5042f7e5df0470025fdb6023fcc24411}{m\_addressForwardCnt}.erase (networkKey);
2119 
2120   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"ackId "} << mb.GetAckId () << \textcolor{stringliteral}{" ourAdd "} << mb.GetOurAdd () << \textcolor{stringliteral}{" nextHop "} << mb.
      GetNextHop ()
2121                         << \textcolor{stringliteral}{" source "} << mb.GetSrc () << \textcolor{stringliteral}{" destination "} << mb.GetDst ()
2122                         << \textcolor{stringliteral}{" segsLeft "} << (uint32\_t)mb.GetSegsLeft ()
2123                );
2124   \textcolor{comment}{// Find the network acknowledgment timer}
2125   std::map<NetworkKey, Timer>::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} =
2126     \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4a35b13cdca413ab5bc0b1b3b7b78907}{m\_addressForwardTimer}.find (networkKey);
2127   \textcolor{keywordflow}{if} (i == \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4a35b13cdca413ab5bc0b1b3b7b78907}{m\_addressForwardTimer}.end ())
2128     \{
2129       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"did not find the packet timer"});
2130     \}
2131   \textcolor{keywordflow}{else}
2132     \{
2133       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"did find the packet timer"});
2134       \textcolor{comment}{/*}
2135 \textcolor{comment}{       * Schedule the packet retry}
2136 \textcolor{comment}{       * Push back the nextHop, source, destination address}
2137 \textcolor{comment}{       */}
2138       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4a35b13cdca413ab5bc0b1b3b7b78907}{m\_addressForwardTimer}[networkKey].Cancel ();
2139       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4a35b13cdca413ab5bc0b1b3b7b78907}{m\_addressForwardTimer}[networkKey].Remove ();
2140       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4a35b13cdca413ab5bc0b1b3b7b78907}{m\_addressForwardTimer}[networkKey].IsRunning ())
2141         \{
2142           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Timer not canceled"});
2143         \}
2144       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4a35b13cdca413ab5bc0b1b3b7b78907}{m\_addressForwardTimer}.erase (networkKey);
2145     \}
2146   \textcolor{comment}{// Erase the maintenance entry}
2147   \textcolor{comment}{// yet this does not check the segments left value here}
2148   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ac9d28a64437fbe20a4228c9811f9fc27}{m\_maintainBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a8eaf2b7c9d9bd778db1b25b6f8d19255}{NetworkEqual} (mb))
2149     \{
2150       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Remove same maintenance buffer entry based on network acknowledgment"});
2151     \}
2152 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 11




Here is the caller graph for this function\+:
% FIG 12


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Cancel\+Packet\+All\+Timer@{Cancel\+Packet\+All\+Timer}}
\index{Cancel\+Packet\+All\+Timer@{Cancel\+Packet\+All\+Timer}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Cancel\+Packet\+All\+Timer(\+Dsr\+Maintain\+Buff\+Entry \&mb)}{CancelPacketAllTimer(DsrMaintainBuffEntry &mb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Cancel\+Packet\+All\+Timer (
\begin{DoxyParamCaption}
\item[{{\bf Dsr\+Maintain\+Buff\+Entry} \&}]{mb}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_afb3145517b31e5a0e2016ac496c86050}{}\label{classns3_1_1dsr_1_1DsrRouting_afb3145517b31e5a0e2016ac496c86050}


Cancel all the packet timers. 


\begin{DoxyCode}
2047 \{
2048   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
2049   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a3d5aef30dc62293cdc487b7110be2324}{CancelLinkPacketTimer} (mb);
2050   \hyperlink{classns3_1_1dsr_1_1DsrRouting_aeed35bcacf68c9f349078b508e73c9aa}{CancelNetworkPacketTimer} (mb);
2051   \hyperlink{classns3_1_1dsr_1_1DsrRouting_aee6495417f54a12f484029ee1a445d64}{CancelPassivePacketTimer} (mb);
2052 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13




Here is the caller graph for this function\+:
% FIG 14


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Cancel\+Packet\+Timer\+Next\+Hop@{Cancel\+Packet\+Timer\+Next\+Hop}}
\index{Cancel\+Packet\+Timer\+Next\+Hop@{Cancel\+Packet\+Timer\+Next\+Hop}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Cancel\+Packet\+Timer\+Next\+Hop(\+Ipv4\+Address next\+Hop, uint8\+\_\+t protocol)}{CancelPacketTimerNextHop(Ipv4Address nextHop, uint8_t protocol)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Cancel\+Packet\+Timer\+Next\+Hop (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{next\+Hop, }
\item[{uint8\+\_\+t}]{protocol}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a215e6fcab10ee0d744a657f0af2695c6}{}\label{classns3_1_1dsr_1_1DsrRouting_a215e6fcab10ee0d744a657f0af2695c6}


Cancel the packet retransmission timer for a all maintenance entries with next\+Hop address. 

T\+O\+DO if the error\+Dst is not seen before

T\+O\+DO need to think about whether we need the network queue entry or not 
\begin{DoxyCode}
2192 \{
2193   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << nextHop << (uint32\_t)protocol);
2194 
2195   DsrMaintainBuffEntry entry;
2196   std::vector<Ipv4Address> previousErrorDst;
2197   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ac9d28a64437fbe20a4228c9811f9fc27}{m\_maintainBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a0539c5c6c2b05e10f52372f5fdb93c06}{Dequeue} (nextHop, entry))
2198     \{
2199       Ipv4Address source = entry.GetSrc ();
2200       Ipv4Address destination = entry.GetDst ();
2201 
2202       Ptr<Packet> dsrP = entry.GetPacket ()->Copy ();
2203       Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = dsrP->Copy ();
2204       Ptr<Packet> packet = dsrP->Copy ();
2205       DsrRoutingHeader dsrRoutingHeader;
2206       dsrP->RemoveHeader (dsrRoutingHeader);          \textcolor{comment}{// Remove the dsr header in whole}
2207       uint32\_t offset = dsrRoutingHeader.GetDsrOptionsOffset ();
2208       p->RemoveAtStart (offset);
2209 
2210       \textcolor{comment}{// Get the number of routers' address field}
2211       uint8\_t buf[2];
2212       p->CopyData (buf, \textcolor{keyword}{sizeof}(buf));
2213       uint8\_t numberAddress = (buf[1] - 2) / 4;
2214       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The number of addresses "} << (uint32\_t)numberAddress);
2215       DsrOptionSRHeader sourceRoute;
2216       sourceRoute.SetNumberAddress (numberAddress);
2217       p->RemoveHeader (sourceRoute);
2218       std::vector<Ipv4Address> nodeList = sourceRoute.GetNodesAddress ();
2219       uint8\_t salvage = sourceRoute.GetSalvage ();
2220       Ipv4Address address1 = nodeList[1];
2221       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a21eda9cea85649375aed0a4b5f0c4c10}{PrintVector} (nodeList);
2222 
2223       \textcolor{comment}{/*}
2224 \textcolor{comment}{       * If the salvage is not 0, use the first address in the route as the error dst in error header}
2225 \textcolor{comment}{       * otherwise use the source of packet as the error destination}
2226 \textcolor{comment}{       */}
2227       Ipv4Address errorDst;
2228       \textcolor{keywordflow}{if} (salvage)
2229         \{
2230           errorDst = address1;
2231         \}
2232       \textcolor{keywordflow}{else}
2233         \{
2234           errorDst = source;
2235         \}
2237       \textcolor{keywordflow}{if} (std::find(previousErrorDst.begin(), previousErrorDst.end(), destination)==previousErrorDst.end())
2238       \{
2239         \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"have not seen this dst before "} << errorDst << \textcolor{stringliteral}{" in "} << 
      previousErrorDst.size());
2240         \hyperlink{classns3_1_1dsr_1_1DsrRouting_ace5dd08bac91fa199ddfac7e81125a62}{SendUnreachError} (nextHop, errorDst, destination, salvage, protocol);
2241         previousErrorDst.push\_back(errorDst);
2242       \}
2243 
2244       \textcolor{comment}{/*}
2245 \textcolor{comment}{       * Cancel the packet timer and then salvage the data packet}
2246 \textcolor{comment}{       */}
2247 
2248       \hyperlink{classns3_1_1dsr_1_1DsrRouting_afb3145517b31e5a0e2016ac496c86050}{CancelPacketAllTimer} (entry);
2249       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a83dd51056e4e48ad538ff41fda129272}{SalvagePacket} (packet, source, destination, protocol);
2250 
2251       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ac9d28a64437fbe20a4228c9811f9fc27}{m\_maintainBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a7df015a7d740c8b442df20f4ab3895b7}{GetSize} () && \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac9d28a64437fbe20a4228c9811f9fc27}{m\_maintainBuffer}.
      \hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a42eaded41fd2aeb05dbf0261a130281a}{Find} (nextHop))
2252         \{
2253           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Cancel the packet timer for next maintenance entry"});
2254           \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a22a85b3510166ffdd451e4010f996f0f}{m\_uniformRandomVariable}->\hyperlink{classns3_1_1RandomVariableStream_a66cd94e6305ce7f000f1a9ff0fcb9aef}{GetInteger} (0,100)),
2255                                &\hyperlink{classns3_1_1dsr_1_1DsrRouting_a215e6fcab10ee0d744a657f0af2695c6}{DsrRouting::CancelPacketTimerNextHop},\textcolor{keyword}{
      this},nextHop,protocol);
2256         \}
2257     \}
2258   \textcolor{keywordflow}{else}
2259     \{
2260       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Maintenance buffer entry not found"});
2261     \}
2263 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 15




Here is the caller graph for this function\+:
% FIG 16


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Cancel\+Passive\+Packet\+Timer@{Cancel\+Passive\+Packet\+Timer}}
\index{Cancel\+Passive\+Packet\+Timer@{Cancel\+Passive\+Packet\+Timer}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Cancel\+Passive\+Packet\+Timer(\+Dsr\+Maintain\+Buff\+Entry \&mb)}{CancelPassivePacketTimer(DsrMaintainBuffEntry &mb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Cancel\+Passive\+Packet\+Timer (
\begin{DoxyParamCaption}
\item[{{\bf Dsr\+Maintain\+Buff\+Entry} \&}]{mb}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_aee6495417f54a12f484029ee1a445d64}{}\label{classns3_1_1dsr_1_1DsrRouting_aee6495417f54a12f484029ee1a445d64}


Cancel the passive packet retransmission timer for a specific maintenance entry. 


\begin{DoxyCode}
2156 \{
2157   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
2158   PassiveKey passiveKey;
2159   passiveKey.m\_ackId = 0;
2160   passiveKey.m\_source = mb.GetSrc ();
2161   passiveKey.m\_destination = mb.GetDst ();
2162   passiveKey.m\_segsLeft = mb.GetSegsLeft ();
2163 
2164   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a7fec404d680459aab2b40941a950502d}{m\_passiveCnt}[passiveKey] = 0;
2165   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a7fec404d680459aab2b40941a950502d}{m\_passiveCnt}.erase (passiveKey);
2166 
2167   \textcolor{comment}{// Find the passive acknowledgment timer}
2168   std::map<PassiveKey, Timer>::const\_iterator j =
2169     \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac53c706898e76a7f4871a460d13edd36}{m\_passiveAckTimer}.find (passiveKey);
2170   \textcolor{keywordflow}{if} (j == \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac53c706898e76a7f4871a460d13edd36}{m\_passiveAckTimer}.end ())
2171     \{
2172       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"did not find the passive timer"});
2173     \}
2174   \textcolor{keywordflow}{else}
2175     \{
2176       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"find the passive timer"});
2177       \textcolor{comment}{/*}
2178 \textcolor{comment}{       * Cancel passive acknowledgment timer}
2179 \textcolor{comment}{       */}
2180       \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac53c706898e76a7f4871a460d13edd36}{m\_passiveAckTimer}[passiveKey].Cancel ();
2181       \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac53c706898e76a7f4871a460d13edd36}{m\_passiveAckTimer}[passiveKey].Remove ();
2182       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ac53c706898e76a7f4871a460d13edd36}{m\_passiveAckTimer}[passiveKey].IsRunning ())
2183         \{
2184           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Timer not canceled"});
2185         \}
2186       \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac53c706898e76a7f4871a460d13edd36}{m\_passiveAckTimer}.erase (passiveKey);
2187     \}
2188 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 17




Here is the caller graph for this function\+:
% FIG 18


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Cancel\+Passive\+Timer@{Cancel\+Passive\+Timer}}
\index{Cancel\+Passive\+Timer@{Cancel\+Passive\+Timer}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Cancel\+Passive\+Timer(\+Ptr$<$ Packet $>$ packet, Ipv4\+Address source, Ipv4\+Address destination, uint8\+\_\+t segs\+Left)}{CancelPassiveTimer(Ptr< Packet > packet, Ipv4Address source, Ipv4Address destination, uint8_t segsLeft)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::dsr\+::\+Dsr\+Routing\+::\+Cancel\+Passive\+Timer (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Ipv4\+Address}}]{source, }
\item[{{\bf Ipv4\+Address}}]{destination, }
\item[{uint8\+\_\+t}]{segs\+Left}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a2d33e2373aafc398451aa081c44c699a}{}\label{classns3_1_1dsr_1_1DsrRouting_a2d33e2373aafc398451aa081c44c699a}


Cancel the passive timer. 


\begin{DoxyCode}
2004 \{
2005   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << source << destination << (uint32\_t)
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a2089307bfbe378b6cd8b274b38f70bb9}{segsLeft});
2006 
2007   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Cancel the passive timer"});
2008 
2009   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = packet->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} ();
2010   \textcolor{comment}{// Here the segments left value need to plus one to check the earlier hop maintain buffer entry}
2011   DsrMaintainBuffEntry newEntry;
2012   newEntry.SetPacket (p);
2013   newEntry.SetSrc (source);
2014   newEntry.SetDst (destination);
2015   newEntry.SetAckId (0);
2016   newEntry.SetSegsLeft (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a2089307bfbe378b6cd8b274b38f70bb9}{segsLeft} + 1);
2017 
2018   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ac9d28a64437fbe20a4228c9811f9fc27}{m\_maintainBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a8968cfdf465293896b00fe4c11c4ba72}{PromiscEqual} (newEntry))
2019     \{
2020       \textcolor{comment}{// The PromiscEqual function will remove the maintain buffer entry if equal value found}
2021       \textcolor{comment}{// It only compares the source and destination address, ackId, and the segments left value}
2022       \hyperlink{classns3_1_1dsr_1_1DsrRouting_aee6495417f54a12f484029ee1a445d64}{CancelPassivePacketTimer} (newEntry);
2023       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
2024     \}
2025   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
2026 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 19


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Cancel\+Rreq\+Timer@{Cancel\+Rreq\+Timer}}
\index{Cancel\+Rreq\+Timer@{Cancel\+Rreq\+Timer}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Cancel\+Rreq\+Timer(\+Ipv4\+Address dst, bool is\+Remove)}{CancelRreqTimer(Ipv4Address dst, bool isRemove)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Cancel\+Rreq\+Timer (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{dst, }
\item[{bool}]{is\+Remove}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_ad489fa602b093c8336cf4143ed60e429}{}\label{classns3_1_1dsr_1_1DsrRouting_ad489fa602b093c8336cf4143ed60e429}


Cancel the route request timer. 


\begin{DoxyParams}{Parameters}
{\em dst} & The dst address of the route request timer \\
\hline
{\em is\+Remove} & whether to remove the route request entry or not \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2897 \{
2898   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << dst << isRemove);
2899   \textcolor{comment}{// Cancel the non propagation request timer if found}
2900   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a0936df610f90f7e79c24a2a8cdea6c14}{m\_nonPropReqTimer}.find (dst) == \hyperlink{classns3_1_1dsr_1_1DsrRouting_a0936df610f90f7e79c24a2a8cdea6c14}{m\_nonPropReqTimer}.end ())
2901     \{
2902       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Did not find the non-propagation timer"});
2903     \}
2904   \textcolor{keywordflow}{else}
2905     \{
2906       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"did find the non-propagation timer"});
2907     \}
2908   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a0936df610f90f7e79c24a2a8cdea6c14}{m\_nonPropReqTimer}[dst].Cancel ();
2909   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a0936df610f90f7e79c24a2a8cdea6c14}{m\_nonPropReqTimer}[dst].Remove ();
2910 
2911   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a0936df610f90f7e79c24a2a8cdea6c14}{m\_nonPropReqTimer}[dst].IsRunning ())
2912     \{
2913       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Timer not canceled"});
2914     \}
2915   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a0936df610f90f7e79c24a2a8cdea6c14}{m\_nonPropReqTimer}.erase (dst);
2916 
2917   \textcolor{comment}{// Cancel the address request timer if found}
2918   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a47174823b0622573b681afc40d6ea558}{m\_addressReqTimer}.find (dst) == \hyperlink{classns3_1_1dsr_1_1DsrRouting_a47174823b0622573b681afc40d6ea558}{m\_addressReqTimer}.end ())
2919     \{
2920       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Did not find the propagation timer"});
2921     \}
2922   \textcolor{keywordflow}{else}
2923     \{
2924       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"did find the propagation timer"});
2925     \}
2926   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a47174823b0622573b681afc40d6ea558}{m\_addressReqTimer}[dst].Cancel ();
2927   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a47174823b0622573b681afc40d6ea558}{m\_addressReqTimer}[dst].Remove ();
2928   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a47174823b0622573b681afc40d6ea558}{m\_addressReqTimer}[dst].IsRunning ())
2929     \{
2930       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Timer not canceled"});
2931     \}
2932   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a47174823b0622573b681afc40d6ea558}{m\_addressReqTimer}.erase (dst);
2933   \textcolor{comment}{/*}
2934 \textcolor{comment}{   * If the route request is scheduled to remove the route request entry}
2935 \textcolor{comment}{   * Remove the route request entry with the route retry times done for certain destination}
2936 \textcolor{comment}{   */}
2937   \textcolor{keywordflow}{if} (isRemove)
2938     \{
2939       \textcolor{comment}{// remove the route request entry from route request table}
2940       \hyperlink{classns3_1_1dsr_1_1DsrRouting_ae9ec27743735fa2d59cc5190961d1942}{m\_rreqTable}->RemoveRreqEntry (dst);
2941     \}
2942 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 20


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Check\+Send\+Buffer@{Check\+Send\+Buffer}}
\index{Check\+Send\+Buffer@{Check\+Send\+Buffer}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Check\+Send\+Buffer()}{CheckSendBuffer()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Check\+Send\+Buffer (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a03ace9023e9fe58434dc004123c7d9e0}{}\label{classns3_1_1dsr_1_1DsrRouting_a03ace9023e9fe58434dc004123c7d9e0}


Check the send buffer of packets with route when send buffer timer expire. 

When found a route and use it, Use\+Extends to the link cache

This will be priority 0

\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000022}{Todo}]New \hyperlink{classns3_1_1dsr_1_1DsrNetworkQueueEntry}{Dsr\+Network\+Queue\+Entry} \end{DoxyRefDesc}


When found a route and use it, Use\+Extends to the link cache 
\begin{DoxyCode}
832 \{
833   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds ()
834                << \textcolor{stringliteral}{" Checking send buffer at "} << \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress} << \textcolor{stringliteral}{" with size "} << 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a887ae39d7060171753c0605d5c120549}{m\_sendBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrSendBuffer_a0ecf75786eef7193fa5a5d84b2b7a1f0}{GetSize} ());
835 
836   \textcolor{keywordflow}{for} (std::vector<DsrSendBuffEntry>::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a887ae39d7060171753c0605d5c120549}{m\_sendBuffer}.
      \hyperlink{classns3_1_1dsr_1_1DsrSendBuffer_ad21223587fd6ae3a42b124416e877305}{GetBuffer} ().begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1dsr_1_1DsrRouting_a887ae39d7060171753c0605d5c120549}{m\_sendBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrSendBuffer_ad21223587fd6ae3a42b124416e877305}{GetBuffer} ().end (); )
837     \{
838       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Here we try to find the data packet in the send buffer"});
839       Ipv4Address destination = \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetDestination ();
840       DsrRouteCacheEntry toDst;
841       \textcolor{keywordtype}{bool} findRoute = \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->LookupRoute (destination, toDst);
842       \textcolor{keywordflow}{if} (findRoute)
843         \{
844           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"We have found a route for the packet"});
845           Ptr<const Packet> packet = \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetPacket ();
846           Ptr<Packet> cleanP = packet->Copy ();
847           uint8\_t protocol = \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->GetProtocol ();
848 
849           \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a887ae39d7060171753c0605d5c120549}{m\_sendBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrSendBuffer_ad21223587fd6ae3a42b124416e877305}{GetBuffer} ().erase (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
850 
851           DsrRoutingHeader dsrRoutingHeader;
852           Ptr<Packet> copyP = packet->Copy ();
853           Ptr<Packet> dsrPacket = packet->Copy ();
854           dsrPacket->RemoveHeader (dsrRoutingHeader);
855           uint32\_t offset = dsrRoutingHeader.GetDsrOptionsOffset ();
856           copyP->RemoveAtStart (offset); \textcolor{comment}{// Here the processed size is 8 bytes, which is the fixed sized
       extension header}
857           \textcolor{comment}{// The packet to get ipv4 header}
858           Ptr<Packet> ipv4P = copyP->Copy ();
859           \textcolor{comment}{/*}
860 \textcolor{comment}{           * Peek data to get the option type as well as length and segmentsLeft field}
861 \textcolor{comment}{           */}
862           uint32\_t size = copyP->GetSize ();
863           uint8\_t *\hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data} = \textcolor{keyword}{new} uint8\_t[size];
864           copyP->CopyData (data, size);
865 
866           uint8\_t optionType = 0;
867           optionType = *(\hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data});
868 
869           \textcolor{keywordflow}{if} (optionType == 3)
870             \{
871               Ptr<dsr::DsrOptions> dsrOption;
872               DsrOptionHeader dsrOptionHeader;
873               uint8\_t errorType = *(data + 2);
874 
875               \textcolor{keywordflow}{if} (errorType == 1) \textcolor{comment}{// This is the Route Error Option}
876                 \{
877                   DsrOptionRerrUnreachHeader rerr;
878                   copyP->RemoveHeader (rerr);
879                   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (copyP->GetSize () == 0);
880 
881                   DsrOptionRerrUnreachHeader newUnreach;
882                   newUnreach.SetErrorType (1);
883                   newUnreach.SetErrorSrc (rerr.GetErrorSrc ());
884                   newUnreach.SetUnreachNode (rerr.GetUnreachNode ());
885                   newUnreach.SetErrorDst (rerr.GetErrorDst ());
886                   newUnreach.SetSalvage (rerr.GetSalvage ()); \textcolor{comment}{// Set the value about whether to salvage a
       packet or not}
887 
888                   DsrOptionSRHeader sourceRoute;
889                   std::vector<Ipv4Address> errorRoute = toDst.GetVector ();
890                   sourceRoute.SetNodesAddress (errorRoute);
892                   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->IsLinkCache ())
893                     \{
894                       \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->UseExtends (errorRoute);
895                     \}
896                   sourceRoute.SetSegmentsLeft ((errorRoute.size () - 2));
897                   uint8\_t salvage = 0;
898                   sourceRoute.SetSalvage (salvage);
899                   Ipv4Address nextHop = \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa1b16658c14499af76ca7dd69c034f22}{SearchNextHop} (
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, errorRoute); \textcolor{comment}{// Get the next hop address}
900 
901                   \textcolor{keywordflow}{if} (nextHop == \textcolor{stringliteral}{"0.0.0.0"})
902                     \{
903                       \hyperlink{classns3_1_1dsr_1_1DsrRouting_ae70ab39db551d1d81afc081196f78017}{PacketNewRoute} (dsrPacket, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, destination, 
      protocol);
904                       \textcolor{keywordflow}{return};
905                     \}
906 
907                   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a8a726fb52558a1a8172a5bd5b8cdb072}{SetRoute} (nextHop, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress});
908                   uint8\_t length = (sourceRoute.GetLength () + newUnreach.GetLength ());
909                   dsrRoutingHeader.SetNextHeader (protocol);
910                   dsrRoutingHeader.SetMessageType (1);
911                   dsrRoutingHeader.SetSourceId (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4593e50d5f36e9b9b013fe0422067c44}{GetIDfromIP} (
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}));
912                   dsrRoutingHeader.SetDestId (255);
913                   dsrRoutingHeader.SetPayloadLength (uint16\_t (length) + 4);
914                   dsrRoutingHeader.AddDsrOption (newUnreach);
915                   dsrRoutingHeader.AddDsrOption (sourceRoute);
916 
917                   Ptr<Packet> newPacket = Create<Packet> ();
918                   newPacket->AddHeader (dsrRoutingHeader); \textcolor{comment}{// Add the routing header with rerr and
       sourceRoute attached to it}
919                   Ptr<NetDevice> dev = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a0443d48172143cafa1d0491e35f3fbaf}{m\_ip}->GetNetDevice (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a0443d48172143cafa1d0491e35f3fbaf}{m\_ip}->GetInterfaceForAddress (
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}));
920                   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ab4c16d56044159989e52ad33c0afed2b}{m\_ipv4Route}->SetOutputDevice (dev);
921 
922                   uint32\_t priority = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a67d111b0188b6e2210d1b4782820f8e3}{GetPriority} (\hyperlink{namespacens3_1_1dsr_a7c80bcec67d78dc149a0e503014d07c5abeaa53bf31d961c221e4e377ef6022f2}{DSR\_CONTROL\_PACKET}); 
923                   std::map<uint32\_t, Ptr<dsr::DsrNetworkQueue> >::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4606c3dfb1099afbfe1e7cd1d1c3c8ee}{m\_priorityQueue}.find (priority);
924                   Ptr<dsr::DsrNetworkQueue> dsrNetworkQueue = i->second;
925                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Will be inserting into priority queue number: "} << priority);
926 
927                   \textcolor{comment}{//m\_downTarget (newPacket, m\_mainAddress, nextHop, GetProtocolNumber (), m\_ipv4Route);}
928 
930                  DsrNetworkQueueEntry newEntry (newPacket, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, nextHop, 
      \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} (), \hyperlink{classns3_1_1dsr_1_1DsrRouting_ab4c16d56044159989e52ad33c0afed2b}{m\_ipv4Route});
931 
932                  \textcolor{keywordflow}{if} (dsrNetworkQueue->Enqueue (newEntry))
933                    \{
934                      \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa518edb174bccce1062304404424c6e0}{Scheduler} (priority);
935                    \}
936                  \textcolor{keywordflow}{else}
937                    \{
938                      \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Packet dropped as dsr network queue is full"});
939                    \}
940                 \}
941             \}
942           \textcolor{keywordflow}{else}
943             \{
944               dsrRoutingHeader.SetNextHeader (protocol);
945               dsrRoutingHeader.SetMessageType (2);
946               dsrRoutingHeader.SetSourceId (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4593e50d5f36e9b9b013fe0422067c44}{GetIDfromIP} (
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}));
947               dsrRoutingHeader.SetDestId (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4593e50d5f36e9b9b013fe0422067c44}{GetIDfromIP} (destination));
948 
949               DsrOptionSRHeader sourceRoute;
950               std::vector<Ipv4Address> nodeList = toDst.GetVector (); \textcolor{comment}{// Get the route from the route entry
       we found}
951               Ipv4Address nextHop = \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa1b16658c14499af76ca7dd69c034f22}{SearchNextHop} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, nodeList);  \textcolor{comment}{//
       Get the next hop address for the route}
952               \textcolor{keywordflow}{if} (nextHop == \textcolor{stringliteral}{"0.0.0.0"})
953                 \{
954                   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ae70ab39db551d1d81afc081196f78017}{PacketNewRoute} (dsrPacket, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, destination, 
      protocol);
955                   \textcolor{keywordflow}{return};
956                 \}
957               uint8\_t salvage = 0;
958               sourceRoute.SetNodesAddress (nodeList); \textcolor{comment}{// Save the whole route in the source route header of
       the packet}
959               sourceRoute.SetSegmentsLeft ((nodeList.size () - 2)); \textcolor{comment}{// The segmentsLeft field will indicate
       the hops to go}
960               sourceRoute.SetSalvage (salvage);
962               \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->IsLinkCache ())
963                 \{
964                   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->UseExtends (nodeList);
965                 \}
966               uint8\_t length = sourceRoute.GetLength ();
967               dsrRoutingHeader.SetPayloadLength (uint16\_t (length) + 2);
968               dsrRoutingHeader.AddDsrOption (sourceRoute);
969               cleanP->AddHeader (dsrRoutingHeader);
970               Ptr<const Packet> mtP = cleanP->Copy ();
971               \textcolor{comment}{// Put the data packet in the maintenance queue for data packet retransmission}
972               DsrMaintainBuffEntry newEntry (\textcolor{comment}{/*Packet=*/} mtP, \textcolor{comment}{/*Ipv4Address=*/} 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, \textcolor{comment}{/*nextHop=*/} nextHop,
973                                                       \textcolor{comment}{/*source=*/} \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, \textcolor{comment}{/*
      destination=*/} destination, \textcolor{comment}{/*ackId=*/} 0,
974                                                       \textcolor{comment}{/*SegsLeft=*/} nodeList.size () - 2, \textcolor{comment}{/*expire time=*/} 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac6b1dffa9665af0d6a71aa7b947962ee}{m\_maxMaintainTime});
975               \textcolor{keywordtype}{bool} result = \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac9d28a64437fbe20a4228c9811f9fc27}{m\_maintainBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a8ec30b5b9b0f6af36e61867327a47717}{Enqueue} (newEntry); \textcolor{comment}{// Enqueue the
       packet the the maintenance buffer}
976               \textcolor{keywordflow}{if} (result)
977                 \{
978                   NetworkKey networkKey;
979                   networkKey.m\_ackId = newEntry.GetAckId ();
980                   networkKey.m\_ourAdd = newEntry.GetOurAdd ();
981                   networkKey.m\_nextHop = newEntry.GetNextHop ();
982                   networkKey.m\_source = newEntry.GetSrc ();
983                   networkKey.m\_destination = newEntry.GetDst ();
984 
985                   PassiveKey passiveKey;
986                   passiveKey.m\_ackId = 0;
987                   passiveKey.m\_source = newEntry.GetSrc ();
988                   passiveKey.m\_destination = newEntry.GetDst ();
989                   passiveKey.m\_segsLeft = newEntry.GetSegsLeft ();
990 
991                   LinkKey linkKey;
992                   linkKey.m\_source = newEntry.GetSrc ();
993                   linkKey.m\_destination = newEntry.GetDst ();
994                   linkKey.m\_ourAdd = newEntry.GetOurAdd ();
995                   linkKey.m\_nextHop = newEntry.GetNextHop ();
996 
997                   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5042f7e5df0470025fdb6023fcc24411}{m\_addressForwardCnt}[networkKey] = 0;
998                   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a7fec404d680459aab2b40941a950502d}{m\_passiveCnt}[passiveKey] = 0;
999                   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a85ba159639f9bc13b3d8890458128a79}{m\_linkCnt}[linkKey] = 0;
1000 
1001                   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a216a52d8b579a034df948765d941d3a4}{m\_linkAck})
1002                     \{
1003                       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a947d831bc0964240b1a41b3a09832eff}{ScheduleLinkPacketRetry} (newEntry, protocol);
1004                     \}
1005                   \textcolor{keywordflow}{else}
1006                     \{
1007                       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Not using link acknowledgment"});
1008                       \textcolor{keywordflow}{if} (nextHop != destination)
1009                         \{
1010                           \hyperlink{classns3_1_1dsr_1_1DsrRouting_abfdfa37822a492971fdf24540b635039}{SchedulePassivePacketRetry} (newEntry, protocol);
1011                         \}
1012                       \textcolor{keywordflow}{else}
1013                         \{
1014                           \textcolor{comment}{// This is the first network retry}
1015                           \hyperlink{classns3_1_1dsr_1_1DsrRouting_a6a18c6baa374d5e6a68f8952d1afdb13}{ScheduleNetworkPacketRetry} (newEntry, \textcolor{keyword}{true}, protocol);
1016                         \}
1017                     \}
1018                 \}
1019               \textcolor{comment}{// we need to suspend the normal timer that checks the send buffer}
1020               \textcolor{comment}{// until we are done sending packets}
1021               \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1dsr_1_1DsrRouting_a7676aff7f691319b764fba26a726ef5d}{m\_sendBuffTimer}.\hyperlink{classns3_1_1Timer_a6eaea57766ec5e85023264fe2fb69066}{IsSuspended} ())
1022                 \{
1023                   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a7676aff7f691319b764fba26a726ef5d}{m\_sendBuffTimer}.\hyperlink{classns3_1_1Timer_a168f973f4c60fbeb1580d4734f91e049}{Suspend} ();
1024                 \}
1025               \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a966d7c644a941e3e6365859983816e8b}{m\_sendBuffInterval}, &
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a10273aec775b5cf12eafb03ee46c4397}{DsrRouting::SendBuffTimerExpire}, \textcolor{keyword}{this});
1026               \textcolor{keywordflow}{return};
1027             \}
1028         \}
1029       \textcolor{keywordflow}{else}
1030         \{
1031           ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
1032         \}
1033     \}
1034   \textcolor{comment}{//after going through the entire send buffer and send all packets found route,}
1035   \textcolor{comment}{//we need to resume the timer if it has been suspended}
1036   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a7676aff7f691319b764fba26a726ef5d}{m\_sendBuffTimer}.\hyperlink{classns3_1_1Timer_a6eaea57766ec5e85023264fe2fb69066}{IsSuspended} ())
1037     \{
1038       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Resume the send buffer timer"});
1039       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a7676aff7f691319b764fba26a726ef5d}{m\_sendBuffTimer}.\hyperlink{classns3_1_1Timer_ac09edfb12f9b4ef8fe582f1cd210b6fc}{Resume} ();
1040     \}
1041 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 21




Here is the caller graph for this function\+:
% FIG 22


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Delete\+All\+Routes\+Include\+Link@{Delete\+All\+Routes\+Include\+Link}}
\index{Delete\+All\+Routes\+Include\+Link@{Delete\+All\+Routes\+Include\+Link}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Delete\+All\+Routes\+Include\+Link(\+Ipv4\+Address error\+Src, Ipv4\+Address unreach\+Node, Ipv4\+Address node)}{DeleteAllRoutesIncludeLink(Ipv4Address errorSrc, Ipv4Address unreachNode, Ipv4Address node)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Delete\+All\+Routes\+Include\+Link (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{error\+Src, }
\item[{{\bf Ipv4\+Address}}]{unreach\+Node, }
\item[{{\bf Ipv4\+Address}}]{node}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a7e1ee018d89708bc81f1dd7181b4cd36}{}\label{classns3_1_1dsr_1_1DsrRouting_a7e1ee018d89708bc81f1dd7181b4cd36}

\begin{DoxyCode}
673 \{
674   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->DeleteAllRoutesIncludeLink (errorSrc, unreachNode, node);
675 \}
\end{DoxyCode}
\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Do\+Dispose(void)}{DoDispose(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a278734278728fc569d2d1ba58dcef0b9}{}\label{classns3_1_1dsr_1_1DsrRouting_a278734278728fc569d2d1ba58dcef0b9}


Drop trace callback. 



Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.


\begin{DoxyCode}
550 \{
551   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
552   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac27df0103a40973f0a3f78af0092c60d}{m\_node} = 0;
553   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa42c1b9ee27c8168a2141d3d032006c3}{m\_ipv4}->GetNInterfaces (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
554     \{
555       \textcolor{comment}{// Disable layer 2 link state monitoring (if possible)}
556       Ptr<NetDevice> dev = \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa42c1b9ee27c8168a2141d3d032006c3}{m\_ipv4}->GetNetDevice (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
557       Ptr<WifiNetDevice> wifi = dev->GetObject<WifiNetDevice> ();
558       \textcolor{keywordflow}{if} (wifi != 0)
559         \{
560           Ptr<WifiMac> mac = wifi->GetMac ()->GetObject<AdhocWifiMac> ();
561           \textcolor{keywordflow}{if} (mac != 0)
562             \{
563               mac->TraceDisconnectWithoutContext (\textcolor{stringliteral}{"TxErrHeader"},
564                                                   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->GetTxErrorCallback ());
565               \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->DelArpCache (\hyperlink{classns3_1_1dsr_1_1DsrRouting_aa42c1b9ee27c8168a2141d3d032006c3}{m\_ipv4}->GetInterface (
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})->GetArpCache ());
566             \}
567         \}
568     \}
569   \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{IpL4Protocol::DoDispose} ();
570 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 23


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Find\+Source\+Entry@{Find\+Source\+Entry}}
\index{Find\+Source\+Entry@{Find\+Source\+Entry}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Find\+Source\+Entry(\+Ipv4\+Address src, Ipv4\+Address dst, uint16\+\_\+t id)}{FindSourceEntry(Ipv4Address src, Ipv4Address dst, uint16_t id)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::dsr\+::\+Dsr\+Routing\+::\+Find\+Source\+Entry (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{src, }
\item[{{\bf Ipv4\+Address}}]{dst, }
\item[{uint16\+\_\+t}]{id}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a5217c944c7299be31c764c533eb904d3}{}\label{classns3_1_1dsr_1_1DsrRouting_a5217c944c7299be31c764c533eb904d3}

\begin{DoxyCode}
683 \{
684   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1dsr_1_1DsrRouting_ae9ec27743735fa2d59cc5190961d1942}{m\_rreqTable}->FindSourceEntry (src, dst, \textcolor{keywordtype}{id});
685 \}
\end{DoxyCode}
\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Forward\+Err\+Packet@{Forward\+Err\+Packet}}
\index{Forward\+Err\+Packet@{Forward\+Err\+Packet}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Forward\+Err\+Packet(\+Dsr\+Option\+Rerr\+Unreach\+Header \&rerr, Dsr\+Option\+S\+R\+Header \&source\+Route, Ipv4\+Address next\+Hop, uint8\+\_\+t protocol, Ptr$<$ Ipv4\+Route $>$ route)}{ForwardErrPacket(DsrOptionRerrUnreachHeader &rerr, DsrOptionSRHeader &sourceRoute, Ipv4Address nextHop, uint8_t protocol, Ptr< Ipv4Route > route)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Forward\+Err\+Packet (
\begin{DoxyParamCaption}
\item[{{\bf Dsr\+Option\+Rerr\+Unreach\+Header} \&}]{rerr, }
\item[{{\bf Dsr\+Option\+S\+R\+Header} \&}]{source\+Route, }
\item[{{\bf Ipv4\+Address}}]{next\+Hop, }
\item[{uint8\+\_\+t}]{protocol, }
\item[{{\bf Ptr}$<$ {\bf Ipv4\+Route} $>$}]{route}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a2c5629706b8a73cce84964231ac93d6b}{}\label{classns3_1_1dsr_1_1DsrRouting_a2c5629706b8a73cce84964231ac93d6b}


This function is responsible for forwarding error packets along the route. 

\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000024}{Todo}]New \hyperlink{classns3_1_1dsr_1_1DsrNetworkQueueEntry}{Dsr\+Network\+Queue\+Entry} \end{DoxyRefDesc}

\begin{DoxyCode}
1381 \{
1382   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << rerr << sourceRoute << nextHop << (uint32\_t)protocol << route);
1383   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (!\hyperlink{classns3_1_1dsr_1_1DsrRouting_aa1eb6ea60fdf9ba2cac2079a74ce1ca4}{m\_downTarget}.\hyperlink{classns3_1_1Callback_aa8e27826badbf37f84763f36f70d9b54}{IsNull} (), \textcolor{stringliteral}{"Error, DsrRouting cannot send
       downward"});
1384   DsrRoutingHeader dsrRoutingHeader;
1385   dsrRoutingHeader.SetNextHeader (protocol);
1386   dsrRoutingHeader.SetMessageType (1);
1387   dsrRoutingHeader.SetSourceId (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4593e50d5f36e9b9b013fe0422067c44}{GetIDfromIP} (rerr.GetErrorSrc ()));
1388   dsrRoutingHeader.SetDestId (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4593e50d5f36e9b9b013fe0422067c44}{GetIDfromIP} (rerr.GetErrorDst ()));
1389 
1390   uint8\_t length = (sourceRoute.GetLength () + rerr.GetLength ());
1391   dsrRoutingHeader.SetPayloadLength (uint16\_t (length) + 4);
1392   dsrRoutingHeader.AddDsrOption (rerr);
1393   dsrRoutingHeader.AddDsrOption (sourceRoute);
1394   Ptr<Packet> packet = Create<Packet> ();
1395   packet->AddHeader (dsrRoutingHeader);
1396   Ptr<NetDevice> dev = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a0443d48172143cafa1d0491e35f3fbaf}{m\_ip}->GetNetDevice (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a0443d48172143cafa1d0491e35f3fbaf}{m\_ip}->GetInterfaceForAddress (
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}));
1397   route->SetOutputDevice (dev);
1398 
1399   uint32\_t priority = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a67d111b0188b6e2210d1b4782820f8e3}{GetPriority} (\hyperlink{namespacens3_1_1dsr_a7c80bcec67d78dc149a0e503014d07c5abeaa53bf31d961c221e4e377ef6022f2}{DSR\_CONTROL\_PACKET});
1400   std::map<uint32\_t, Ptr<dsr::DsrNetworkQueue> >::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4606c3dfb1099afbfe1e7cd1d1c3c8ee}{m\_priorityQueue}.find (
      priority);
1401   Ptr<dsr::DsrNetworkQueue> dsrNetworkQueue = i->second;
1402   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Will be inserting into priority queue "} << dsrNetworkQueue << \textcolor{stringliteral}{" number: "} << 
      priority);
1403 
1404   \textcolor{comment}{//m\_downTarget (packet, m\_mainAddress, nextHop, GetProtocolNumber (), route);}
1405 
1407  DsrNetworkQueueEntry newEntry (packet, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, nextHop, 
      \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} (), route);
1408 
1409  \textcolor{keywordflow}{if} (dsrNetworkQueue->Enqueue (newEntry))
1410    \{
1411      \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa518edb174bccce1062304404424c6e0}{Scheduler} (priority);
1412    \}
1413  \textcolor{keywordflow}{else}
1414    \{
1415      \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Packet dropped as dsr network queue is full"});
1416    \}
1417 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 24


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Forward\+Packet@{Forward\+Packet}}
\index{Forward\+Packet@{Forward\+Packet}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Forward\+Packet(\+Ptr$<$ const Packet $>$ packet, Dsr\+Option\+S\+R\+Header \&source\+Route, Ipv4\+Header const \&ipv4\+Header, Ipv4\+Address source, Ipv4\+Address destination, Ipv4\+Address target\+Address, uint8\+\_\+t protocol, Ptr$<$ Ipv4\+Route $>$ route)}{ForwardPacket(Ptr< const Packet > packet, DsrOptionSRHeader &sourceRoute, Ipv4Header const &ipv4Header, Ipv4Address source, Ipv4Address destination, Ipv4Address targetAddress, uint8_t protocol, Ptr< Ipv4Route > route)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Forward\+Packet (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{packet, }
\item[{{\bf Dsr\+Option\+S\+R\+Header} \&}]{source\+Route, }
\item[{{\bf Ipv4\+Header} const \&}]{ipv4\+Header, }
\item[{{\bf Ipv4\+Address}}]{source, }
\item[{{\bf Ipv4\+Address}}]{destination, }
\item[{{\bf Ipv4\+Address}}]{target\+Address, }
\item[{uint8\+\_\+t}]{protocol, }
\item[{{\bf Ptr}$<$ {\bf Ipv4\+Route} $>$}]{route}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_acae8a2eb510c8c9331104ab2aff29591}{}\label{classns3_1_1dsr_1_1DsrRouting_acae8a2eb510c8c9331104ab2aff29591}


Forward the packet using the route saved in the source route option header. 


\begin{DoxyCode}
2672 \{
2673   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << sourceRoute << source << nextHop << targetAddress << (
      uint32\_t)protocol << route);
2674   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (!\hyperlink{classns3_1_1dsr_1_1DsrRouting_aa1eb6ea60fdf9ba2cac2079a74ce1ca4}{m\_downTarget}.\hyperlink{classns3_1_1Callback_aa8e27826badbf37f84763f36f70d9b54}{IsNull} (), \textcolor{stringliteral}{"Error, DsrRouting cannot send
       downward"});
2675 
2676   DsrRoutingHeader dsrRoutingHeader;
2677   dsrRoutingHeader.SetNextHeader (protocol);
2678   dsrRoutingHeader.SetMessageType (2);
2679   dsrRoutingHeader.SetSourceId (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4593e50d5f36e9b9b013fe0422067c44}{GetIDfromIP} (source));
2680   dsrRoutingHeader.SetDestId (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4593e50d5f36e9b9b013fe0422067c44}{GetIDfromIP} (targetAddress));
2681 
2682   \textcolor{comment}{// We get the salvage value in sourceRoute header and set it to route error header if triggered error}
2683   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = packet->Copy ();
2684   uint8\_t length = sourceRoute.GetLength ();
2685   dsrRoutingHeader.SetPayloadLength (uint16\_t (length) + 2);
2686   dsrRoutingHeader.AddDsrOption (sourceRoute);
2687   p->AddHeader (dsrRoutingHeader);
2688 
2689   Ptr<const Packet> mtP = p->Copy ();
2690 
2691   DsrMaintainBuffEntry newEntry (\textcolor{comment}{/*Packet=*/} mtP, \textcolor{comment}{/*ourAddress=*/} \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, \textcolor{comment}{/*nextHop=*/} 
      nextHop,
2692                               \textcolor{comment}{/*source=*/} source, \textcolor{comment}{/*destination=*/} targetAddress, \textcolor{comment}{/*ackId=*/} 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a38c5f8c952141a9853ae9f8ee116e292}{m\_ackId},
2693                               \textcolor{comment}{/*SegsLeft=*/} sourceRoute.GetSegmentsLeft (), \textcolor{comment}{/*expire time=*/} 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac6b1dffa9665af0d6a71aa7b947962ee}{m\_maxMaintainTime});
2694   \textcolor{keywordtype}{bool} result = \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac9d28a64437fbe20a4228c9811f9fc27}{m\_maintainBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a8ec30b5b9b0f6af36e61867327a47717}{Enqueue} (newEntry);
2695 
2696   \textcolor{keywordflow}{if} (result)
2697     \{
2698       NetworkKey networkKey;
2699       networkKey.m\_ackId = newEntry.GetAckId ();
2700       networkKey.m\_ourAdd = newEntry.GetOurAdd ();
2701       networkKey.m\_nextHop = newEntry.GetNextHop ();
2702       networkKey.m\_source = newEntry.GetSrc ();
2703       networkKey.m\_destination = newEntry.GetDst ();
2704 
2705       PassiveKey passiveKey;
2706       passiveKey.m\_ackId = 0;
2707       passiveKey.m\_source = newEntry.GetSrc ();
2708       passiveKey.m\_destination = newEntry.GetDst ();
2709       passiveKey.m\_segsLeft = newEntry.GetSegsLeft ();
2710 
2711       LinkKey linkKey;
2712       linkKey.m\_source = newEntry.GetSrc ();
2713       linkKey.m\_destination = newEntry.GetDst ();
2714       linkKey.m\_ourAdd = newEntry.GetOurAdd ();
2715       linkKey.m\_nextHop = newEntry.GetNextHop ();
2716 
2717       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5042f7e5df0470025fdb6023fcc24411}{m\_addressForwardCnt}[networkKey] = 0;
2718       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a7fec404d680459aab2b40941a950502d}{m\_passiveCnt}[passiveKey] = 0;
2719       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a85ba159639f9bc13b3d8890458128a79}{m\_linkCnt}[linkKey] = 0;
2720 
2721       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a216a52d8b579a034df948765d941d3a4}{m\_linkAck})
2722         \{
2723           \hyperlink{classns3_1_1dsr_1_1DsrRouting_a947d831bc0964240b1a41b3a09832eff}{ScheduleLinkPacketRetry} (newEntry, protocol);
2724         \}
2725       \textcolor{keywordflow}{else}
2726         \{
2727           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Not using link acknowledgment"});
2728           \textcolor{keywordflow}{if} (nextHop != targetAddress)
2729             \{
2730               \hyperlink{classns3_1_1dsr_1_1DsrRouting_abfdfa37822a492971fdf24540b635039}{SchedulePassivePacketRetry} (newEntry, protocol);
2731             \}
2732           \textcolor{keywordflow}{else}
2733             \{
2734               \textcolor{comment}{// This is the first network retry}
2735               \hyperlink{classns3_1_1dsr_1_1DsrRouting_a6a18c6baa374d5e6a68f8952d1afdb13}{ScheduleNetworkPacketRetry} (newEntry, \textcolor{keyword}{true}, protocol);
2736             \}
2737         \}
2738     \}
2739 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 25


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Get\+Down\+Target@{Get\+Down\+Target}}
\index{Get\+Down\+Target@{Get\+Down\+Target}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Down\+Target(void) const }{GetDownTarget(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ip\+L4\+Protocol\+::\+Down\+Target\+Callback} ns3\+::dsr\+::\+Dsr\+Routing\+::\+Get\+Down\+Target (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a62358ed8bc8d3df85af845522e84ad1a}{}\label{classns3_1_1dsr_1_1DsrRouting_a62358ed8bc8d3df85af845522e84ad1a}
This method allows a caller to get the current down target callback set for this L4 protocol (I\+Pv4 case)

\begin{DoxyReturn}{Returns}
current \hyperlink{classns3_1_1Callback}{Callback} for the L4 protocol 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1IpL4Protocol_ac0689deffbf226af223668bca54870d0}{ns3\+::\+Ip\+L4\+Protocol}.


\begin{DoxyCode}
3513 \{
3514   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa1eb6ea60fdf9ba2cac2079a74ce1ca4}{m\_downTarget};
3515 \}
\end{DoxyCode}
\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Get\+Down\+Target6@{Get\+Down\+Target6}}
\index{Get\+Down\+Target6@{Get\+Down\+Target6}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Down\+Target6(void) const }{GetDownTarget6(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ip\+L4\+Protocol\+::\+Down\+Target\+Callback6} ns3\+::dsr\+::\+Dsr\+Routing\+::\+Get\+Down\+Target6 (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_acee265284cbac4dcf7764305ee7b6c99}{}\label{classns3_1_1dsr_1_1DsrRouting_acee265284cbac4dcf7764305ee7b6c99}
This method allows a caller to get the current down target callback set for this L4 protocol (I\+Pv6 case)

\begin{DoxyReturn}{Returns}
current \hyperlink{classns3_1_1Callback}{Callback} for the L4 protocol 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1IpL4Protocol_a208389e5d6362765a58c50264b13b18d}{ns3\+::\+Ip\+L4\+Protocol}.


\begin{DoxyCode}
3519 \{
3520   \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Unimplemented"});
3521   \textcolor{keywordflow}{return} MakeNullCallback<void,Ptr<Packet>, Ipv6Address, Ipv6Address, uint8\_t, Ptr<Ipv6Route> > ();
3522 \}
\end{DoxyCode}
\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Get\+Elements\+From\+Context@{Get\+Elements\+From\+Context}}
\index{Get\+Elements\+From\+Context@{Get\+Elements\+From\+Context}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Elements\+From\+Context(std\+::string context)}{GetElementsFromContext(std::string context)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<$ std\+::string $>$ ns3\+::dsr\+::\+Dsr\+Routing\+::\+Get\+Elements\+From\+Context (
\begin{DoxyParamCaption}
\item[{std\+::string}]{context}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a147011231253d86c4b2d6a5a8fb0a152}{}\label{classns3_1_1dsr_1_1DsrRouting_a147011231253d86c4b2d6a5a8fb0a152}


Get the elements from the tracing context. 


\begin{DoxyParams}{Parameters}
{\em context} & context \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the elements we are looking for 
\end{DoxyReturn}

\begin{DoxyCode}
535 \{
536   std::vector <std::string> elements;
537   \textcolor{keywordtype}{size\_t} pos1=0, pos2;
538   \textcolor{keywordflow}{while} (pos1 != context.npos)
539   \{
540     pos1 = context.find (\textcolor{stringliteral}{"/"},pos1);
541     pos2 = context.find (\textcolor{stringliteral}{"/"},pos1+1);
542     elements.push\_back (context.substr (pos1+1,pos2-(pos1+1)));
543     pos1 = pos2;
544   \}
545   \textcolor{keywordflow}{return} elements;
546 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 26


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Get\+I\+Dfrom\+IP@{Get\+I\+Dfrom\+IP}}
\index{Get\+I\+Dfrom\+IP@{Get\+I\+Dfrom\+IP}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Get\+I\+Dfrom\+I\+P(\+Ipv4\+Address address)}{GetIDfromIP(Ipv4Address address)}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::\+Get\+I\+Dfrom\+IP (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{address}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a4593e50d5f36e9b9b013fe0422067c44}{}\label{classns3_1_1dsr_1_1DsrRouting_a4593e50d5f36e9b9b013fe0422067c44}


Get the node id from ip address. 


\begin{DoxyParams}{Parameters}
{\em address} & I\+Pv4 address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the node id 
\end{DoxyReturn}

\begin{DoxyCode}
778 \{
779   int32\_t nNodes = \hyperlink{classns3_1_1NodeList_a1d110b1670005895dd5812baab13682a}{NodeList::GetNNodes} ();
780   \textcolor{keywordflow}{for} (int32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < nNodes; ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
781     \{
782       Ptr<Node> node = \hyperlink{classns3_1_1NodeList_a80ac09977d48d29db5c704ac8483cf6c}{NodeList::GetNode} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
783       Ptr<Ipv4> ipv4 = node->GetObject<Ipv4> ();
784       \textcolor{keywordflow}{if} (ipv4->GetAddress (1, 0).GetLocal () == address)
785         \{
786           \textcolor{keywordflow}{return} uint16\_t (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
787         \}
788     \}
789   \textcolor{keywordflow}{return} 256;
790 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 27




Here is the caller graph for this function\+:
% FIG 28


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Get\+I\+Pfrom\+ID@{Get\+I\+Pfrom\+ID}}
\index{Get\+I\+Pfrom\+ID@{Get\+I\+Pfrom\+ID}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Get\+I\+Pfrom\+I\+D(uint16\+\_\+t id)}{GetIPfromID(uint16_t id)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Address} ns3\+::dsr\+::\+Dsr\+Routing\+::\+Get\+I\+Pfrom\+ID (
\begin{DoxyParamCaption}
\item[{uint16\+\_\+t}]{id}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_abaf6e655b3bf50d3002c3739409d23a6}{}\label{classns3_1_1dsr_1_1DsrRouting_abaf6e655b3bf50d3002c3739409d23a6}


Get the ip address from id. 


\begin{DoxyParams}{Parameters}
{\em id} & unique ID \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the ip address for the id 
\end{DoxyReturn}

\begin{DoxyCode}
794 \{
795   \textcolor{keywordflow}{if} (\textcolor{keywordtype}{id} >= 256)
796     \{
797       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Exceed the node range"});
798       \textcolor{keywordflow}{return} \textcolor{stringliteral}{"0.0.0.0"};
799     \}
800   \textcolor{keywordflow}{else}
801     \{
802       Ptr<Node> node = \hyperlink{classns3_1_1NodeList_a80ac09977d48d29db5c704ac8483cf6c}{NodeList::GetNode} (uint32\_t (\textcolor{keywordtype}{id}));
803       Ptr<Ipv4> ipv4 = node->GetObject<Ipv4> ();
804       \textcolor{keywordflow}{return} ipv4->GetAddress (1, 0).GetLocal ();
805     \}
806 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 29




Here is the caller graph for this function\+:
% FIG 30


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Get\+I\+Pfrom\+M\+AC@{Get\+I\+Pfrom\+M\+AC}}
\index{Get\+I\+Pfrom\+M\+AC@{Get\+I\+Pfrom\+M\+AC}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Get\+I\+Pfrom\+M\+A\+C(\+Mac48\+Address address)}{GetIPfromMAC(Mac48Address address)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Address} ns3\+::dsr\+::\+Dsr\+Routing\+::\+Get\+I\+Pfrom\+M\+AC (
\begin{DoxyParamCaption}
\item[{{\bf Mac48\+Address}}]{address}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a5914e79eec0e5e33be08f55321e8aaea}{}\label{classns3_1_1dsr_1_1DsrRouting_a5914e79eec0e5e33be08f55321e8aaea}


Get the Ip address from mac address. 


\begin{DoxyParams}{Parameters}
{\em address} & \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the ip address 
\end{DoxyReturn}

\begin{DoxyCode}
689 \{
690   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << address);
691   int32\_t nNodes = \hyperlink{classns3_1_1NodeList_a1d110b1670005895dd5812baab13682a}{NodeList::GetNNodes} ();
692   \textcolor{keywordflow}{for} (int32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < nNodes; ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
693     \{
694       Ptr<Node> node = \hyperlink{classns3_1_1NodeList_a80ac09977d48d29db5c704ac8483cf6c}{NodeList::GetNode} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
695       Ptr<Ipv4> ipv4 = node->GetObject<Ipv4> ();
696       Ptr<NetDevice> netDevice = ipv4->GetNetDevice (1);
697 
698       \textcolor{keywordflow}{if} (netDevice->GetAddress () == address)
699         \{
700           \textcolor{keywordflow}{return} ipv4->GetAddress (1, 0).GetLocal ();
701         \}
702     \}
703   \textcolor{keywordflow}{return} 0;
704 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 31




Here is the caller graph for this function\+:
% FIG 32


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Get\+Net\+Device\+From\+Context@{Get\+Net\+Device\+From\+Context}}
\index{Get\+Net\+Device\+From\+Context@{Get\+Net\+Device\+From\+Context}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Net\+Device\+From\+Context(std\+::string context)}{GetNetDeviceFromContext(std::string context)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Net\+Device} $>$ ns3\+::dsr\+::\+Dsr\+Routing\+::\+Get\+Net\+Device\+From\+Context (
\begin{DoxyParamCaption}
\item[{std\+::string}]{context}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a5160f9f3016a0ee25fd5d52be1e4d51e}{}\label{classns3_1_1dsr_1_1DsrRouting_a5160f9f3016a0ee25fd5d52be1e4d51e}


Get the netdevice from the context. 


\begin{DoxyParams}{Parameters}
{\em context} & context \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the netdevice we are looking for 
\end{DoxyReturn}

\begin{DoxyCode}
523 \{
524   \textcolor{comment}{// Use "NodeList/*/DeviceList/*/ as reference}
525   \textcolor{comment}{// where element [1] is the Node Id}
526   \textcolor{comment}{// element [2] is the NetDevice Id}
527   std::vector <std::string> elements = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a147011231253d86c4b2d6a5a8fb0a152}{GetElementsFromContext} (context);
528   Ptr<Node> \hyperlink{namespacesample-rng-plot_aeb5ee5c431e338ef39b7ac5431242e1d}{n} = \hyperlink{classns3_1_1NodeList_a80ac09977d48d29db5c704ac8483cf6c}{NodeList::GetNode} (atoi (elements[1].c\_str ()));
529   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (n);
530   \textcolor{keywordflow}{return} n->GetDevice (atoi (elements[3].c\_str ()));
531 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 33


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Get\+Node@{Get\+Node}}
\index{Get\+Node@{Get\+Node}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Node() const }{GetNode() const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Node} $>$ ns3\+::dsr\+::\+Dsr\+Routing\+::\+Get\+Node (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1dsr_1_1DsrRouting_af1ef6f867481d19a85863a75a3e72e5a}{}\label{classns3_1_1dsr_1_1DsrRouting_af1ef6f867481d19a85863a75a3e72e5a}


Get the node. 

\begin{DoxyReturn}{Returns}
the node 
\end{DoxyReturn}

\begin{DoxyCode}
580 \{
581   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
582   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac27df0103a40973f0a3f78af0092c60d}{m\_node};
583 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 34


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Get\+Node\+With\+Address@{Get\+Node\+With\+Address}}
\index{Get\+Node\+With\+Address@{Get\+Node\+With\+Address}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Node\+With\+Address(\+Ipv4\+Address ipv4\+Address)}{GetNodeWithAddress(Ipv4Address ipv4Address)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Node} $>$ ns3\+::dsr\+::\+Dsr\+Routing\+::\+Get\+Node\+With\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{ipv4\+Address}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_aa301f5bb9481fe5392297015328e6332}{}\label{classns3_1_1dsr_1_1DsrRouting_aa301f5bb9481fe5392297015328e6332}


Get the node with give ip address. 


\begin{DoxyParams}{Parameters}
{\em ipv4\+Address} & I\+Pv4 address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the node associated with the ip address 
\end{DoxyReturn}

\begin{DoxyCode}
626 \{
627   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << ipv4Address);
628   int32\_t nNodes = \hyperlink{classns3_1_1NodeList_a1d110b1670005895dd5812baab13682a}{NodeList::GetNNodes} ();
629   \textcolor{keywordflow}{for} (int32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < nNodes; ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
630     \{
631       Ptr<Node> node = \hyperlink{classns3_1_1NodeList_a80ac09977d48d29db5c704ac8483cf6c}{NodeList::GetNode} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
632       Ptr<Ipv4> ipv4 = node->GetObject<Ipv4> ();
633       int32\_t ifIndex = ipv4->GetInterfaceForAddress (ipv4Address);
634       \textcolor{keywordflow}{if} (ifIndex != -1)
635         \{
636           \textcolor{keywordflow}{return} node;
637         \}
638     \}
639   \textcolor{keywordflow}{return} 0;
640 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 35




Here is the caller graph for this function\+:
% FIG 36


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Get\+Option@{Get\+Option}}
\index{Get\+Option@{Get\+Option}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Option(int option\+Number)}{GetOption(int optionNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf dsr\+::\+Dsr\+Options} $>$ ns3\+::dsr\+::\+Dsr\+Routing\+::\+Get\+Option (
\begin{DoxyParamCaption}
\item[{int}]{option\+Number}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a5cdb4c336831a3158c6ba12d226a198e}{}\label{classns3_1_1dsr_1_1DsrRouting_a5cdb4c336831a3158c6ba12d226a198e}


Get the option corresponding to option\+Number. 


\begin{DoxyParams}{Parameters}
{\em option\+Number} & the option number of the option to retrieve \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a matching Dsr option 
\end{DoxyReturn}

\begin{DoxyCode}
3530 \{
3531   \textcolor{keywordflow}{for} (DsrOptionList\_t::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a7f705d6856c04b7bce60317db968bf45}{m\_options}.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a7f705d6856c04b7bce60317db968bf45}{m\_options}.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
3532     \{
3533       \textcolor{keywordflow}{if} ((*i)->GetOptionNumber () == optionNumber)
3534         \{
3535           \textcolor{keywordflow}{return} *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
3536         \}
3537     \}
3538   \textcolor{keywordflow}{return} 0;
3539 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 37


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Get\+Passive\+Buffer@{Get\+Passive\+Buffer}}
\index{Get\+Passive\+Buffer@{Get\+Passive\+Buffer}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Passive\+Buffer() const }{GetPassiveBuffer() const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf dsr\+::\+Dsr\+Passive\+Buffer} $>$ ns3\+::dsr\+::\+Dsr\+Routing\+::\+Get\+Passive\+Buffer (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1dsr_1_1DsrRouting_ae53372c864f32f34bc1964865a3865fe}{}\label{classns3_1_1dsr_1_1DsrRouting_ae53372c864f32f34bc1964865a3865fe}


Get the passive buffer. 

\begin{DoxyReturn}{Returns}
the passive buffer 
\end{DoxyReturn}

\begin{DoxyCode}
619 \{
620   \textcolor{comment}{// / Get the request table to use}
621   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac0404985fc04df7f5b8f53ff1e487079}{m\_passiveBuffer};
622 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 38


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Get\+Priority@{Get\+Priority}}
\index{Get\+Priority@{Get\+Priority}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Priority(\+Dsr\+Message\+Type message\+Type)}{GetPriority(DsrMessageType messageType)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::\+Get\+Priority (
\begin{DoxyParamCaption}
\item[{{\bf Dsr\+Message\+Type}}]{message\+Type}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a67d111b0188b6e2210d1b4782820f8e3}{}\label{classns3_1_1dsr_1_1DsrRouting_a67d111b0188b6e2210d1b4782820f8e3}


Set the priority of the packet in network queue. 


\begin{DoxyParams}{Parameters}
{\em message\+Type} & Message type \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the priority value 
\end{DoxyReturn}

\begin{DoxyCode}
810 \{
811   \textcolor{keywordflow}{if} (messageType == \hyperlink{namespacens3_1_1dsr_a7c80bcec67d78dc149a0e503014d07c5abeaa53bf31d961c221e4e377ef6022f2}{DSR\_CONTROL\_PACKET})
812     \{
813       \textcolor{keywordflow}{return} 0;
814     \}
815   \textcolor{keywordflow}{else}
816     \{
817       \textcolor{keywordflow}{return} 1;
818     \}
819 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 39


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Get\+Protocol\+Number@{Get\+Protocol\+Number}}
\index{Get\+Protocol\+Number@{Get\+Protocol\+Number}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Protocol\+Number(void) const }{GetProtocolNumber(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::dsr\+::\+Dsr\+Routing\+::\+Get\+Protocol\+Number (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a3e98f8b73e3020a96dffa8b9ddfc520b}{}\label{classns3_1_1dsr_1_1DsrRouting_a3e98f8b73e3020a96dffa8b9ddfc520b}


Get the dsr protocol number. 

\begin{DoxyReturn}{Returns}
protocol number 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1IpL4Protocol_aa5b2c5a670f5304b1a36b890ea858977}{ns3\+::\+Ip\+L4\+Protocol}.


\begin{DoxyCode}
771 \{
772   \textcolor{comment}{// / This is the protocol number for DSR which is 48}
773   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1dsr_1_1DsrRouting_a66248f69fcf97af91d6fe17d70617cc9}{PROT\_NUMBER};
774 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 40


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Get\+Request\+Table@{Get\+Request\+Table}}
\index{Get\+Request\+Table@{Get\+Request\+Table}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Request\+Table() const }{GetRequestTable() const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf dsr\+::\+Dsr\+Rreq\+Table} $>$ ns3\+::dsr\+::\+Dsr\+Routing\+::\+Get\+Request\+Table (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a86141cf3706e21637e9d97d341bd1ca9}{}\label{classns3_1_1dsr_1_1DsrRouting_a86141cf3706e21637e9d97d341bd1ca9}


Get the request table. 

\begin{DoxyReturn}{Returns}
the request table 
\end{DoxyReturn}

\begin{DoxyCode}
606 \{
607   \textcolor{comment}{// / Get the request table to use}
608   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1dsr_1_1DsrRouting_ae9ec27743735fa2d59cc5190961d1942}{m\_rreqTable};
609 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 41


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Get\+Route\+Cache@{Get\+Route\+Cache}}
\index{Get\+Route\+Cache@{Get\+Route\+Cache}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Route\+Cache() const }{GetRouteCache() const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf dsr\+::\+Dsr\+Route\+Cache} $>$ ns3\+::dsr\+::\+Dsr\+Routing\+::\+Get\+Route\+Cache (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1dsr_1_1DsrRouting_afa6f8c46b9d64b3a56bd78f7abb3d1ad}{}\label{classns3_1_1dsr_1_1DsrRouting_afa6f8c46b9d64b3a56bd78f7abb3d1ad}


Get the route cache. 

\begin{DoxyReturn}{Returns}
the route cache 
\end{DoxyReturn}

\begin{DoxyCode}
593 \{
594   \textcolor{comment}{// / Get the route cache to use}
595   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache};
596 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 42


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id()}{GetTypeId()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::dsr\+::\+Dsr\+Routing\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_add1c578a2b05d4e9bdd3d983b2e3b4ae}{}\label{classns3_1_1dsr_1_1DsrRouting_add1c578a2b05d4e9bdd3d983b2e3b4ae}


Get the type identificator. 

\begin{DoxyReturn}{Returns}
type identificator 
\end{DoxyReturn}

\begin{DoxyCode}
109 \{
110   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::dsr::DsrRouting"})
111     .SetParent<IpL4Protocol> ()
112     .SetGroupName (\textcolor{stringliteral}{"Dsr"})
113     .AddConstructor<\hyperlink{classns3_1_1dsr_1_1DsrRouting_a3b686bd293d4bd096180a1996171ccd1}{DsrRouting}> ()
114     .AddAttribute (\textcolor{stringliteral}{"RouteCache"},
115                    \textcolor{stringliteral}{"The route cache for saving routes from "}
116                    \textcolor{stringliteral}{"route discovery process."},
117                    PointerValue (0),
118                    MakePointerAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_af61179a03e52ebee0822caac80a830ff}{DsrRouting::SetRouteCache},
119                                         &\hyperlink{classns3_1_1dsr_1_1DsrRouting_afa6f8c46b9d64b3a56bd78f7abb3d1ad}{DsrRouting::GetRouteCache}),
120                    MakePointerChecker<DsrRouteCache> ())
121     .AddAttribute (\textcolor{stringliteral}{"RreqTable"},
122                    \textcolor{stringliteral}{"The request table to manage route requests."},
123                    PointerValue (0),
124                    MakePointerAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_a62fbce24642000a21a4e7c783f77c205}{DsrRouting::SetRequestTable},
125                                         &\hyperlink{classns3_1_1dsr_1_1DsrRouting_a86141cf3706e21637e9d97d341bd1ca9}{DsrRouting::GetRequestTable}),
126                    MakePointerChecker<DsrRreqTable> ())
127     .AddAttribute (\textcolor{stringliteral}{"PassiveBuffer"},
128                    \textcolor{stringliteral}{"The passive buffer to manage "}
129                    \textcolor{stringliteral}{"promisucously received passive ack."},
130                    PointerValue (0),
131                    MakePointerAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_a10d09f5b58b469d0a7c92926f61dd9ab}{DsrRouting::SetPassiveBuffer},
132                                         &\hyperlink{classns3_1_1dsr_1_1DsrRouting_ae53372c864f32f34bc1964865a3865fe}{DsrRouting::GetPassiveBuffer}),
133                    MakePointerChecker<DsrPassiveBuffer> ())
134     .AddAttribute (\textcolor{stringliteral}{"MaxSendBuffLen"},
135                    \textcolor{stringliteral}{"Maximum number of packets that can be stored "}
136                    \textcolor{stringliteral}{"in send buffer."},
137                    UintegerValue (64),
138                    MakeUintegerAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_a5cf78026e2a25a4468c04745f4a10c13}{DsrRouting::m\_maxSendBuffLen}),
139                    MakeUintegerChecker<uint32\_t> ())
140     .AddAttribute (\textcolor{stringliteral}{"MaxSendBuffTime"},
141                    \textcolor{stringliteral}{"Maximum time packets can be queued in the send buffer ."},
142                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (30)),
143                    MakeTimeAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_a1f89794801db0336d92e4ca85fbc09a7}{DsrRouting::m\_sendBufferTimeout}),
144                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
145     .AddAttribute (\textcolor{stringliteral}{"MaxMaintLen"},
146                    \textcolor{stringliteral}{"Maximum number of packets that can be stored "}
147                    \textcolor{stringliteral}{"in maintenance buffer."},
148                    UintegerValue (50),
149                    MakeUintegerAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_a65f608e0cfba00495392f94938fc02c0}{DsrRouting::m\_maxMaintainLen}),
150                    MakeUintegerChecker<uint32\_t> ())
151     .AddAttribute (\textcolor{stringliteral}{"MaxMaintTime"},
152                    \textcolor{stringliteral}{"Maximum time packets can be queued in maintenance buffer."},
153                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (30)),
154                    MakeTimeAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_ac6b1dffa9665af0d6a71aa7b947962ee}{DsrRouting::m\_maxMaintainTime}),
155                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
156     .AddAttribute (\textcolor{stringliteral}{"MaxCacheLen"},
157                    \textcolor{stringliteral}{"Maximum number of route entries that can be stored "}
158                    \textcolor{stringliteral}{"in route cache."},
159                    UintegerValue (64),
160                    MakeUintegerAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_afce2c0909aecc7dfe4528f7f6b042019}{DsrRouting::m\_maxCacheLen}),
161                    MakeUintegerChecker<uint32\_t> ())
162     .AddAttribute (\textcolor{stringliteral}{"RouteCacheTimeout"},
163                    \textcolor{stringliteral}{"Maximum time the route cache can be queued in "}
164                    \textcolor{stringliteral}{"route cache."},
165                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (300)),
166                    MakeTimeAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_a76d8abfedbda7429e983c407748400be}{DsrRouting::m\_maxCacheTime}),
167                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
168     .AddAttribute (\textcolor{stringliteral}{"MaxEntriesEachDst"},
169                    \textcolor{stringliteral}{"Maximum number of route entries for a "}
170                    \textcolor{stringliteral}{"single destination to respond."},
171                    UintegerValue (20),
172                    MakeUintegerAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_a470ec4bd470cd1d802621752331d9916}{DsrRouting::m\_maxEntriesEachDst}),
173                    MakeUintegerChecker<uint32\_t> ())
174     .AddAttribute (\textcolor{stringliteral}{"SendBuffInterval"},
175                    \textcolor{stringliteral}{"How often to check send buffer for packet with route."},
176                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (500)),
177                    MakeTimeAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_a966d7c644a941e3e6365859983816e8b}{DsrRouting::m\_sendBuffInterval}),
178                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
179     .AddAttribute (\textcolor{stringliteral}{"NodeTraversalTime"},
180                    \textcolor{stringliteral}{"The time it takes to traverse two neighboring nodes."},
181                    TimeValue (\hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (40)),
182                    MakeTimeAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4c406057009653878e8cdf3e3a7f2106}{DsrRouting::m\_nodeTraversalTime}),
183                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
184     .AddAttribute (\textcolor{stringliteral}{"RreqRetries"},
185                    \textcolor{stringliteral}{"Maximum number of retransmissions for "}
186                    \textcolor{stringliteral}{"request discovery of a route."},
187                    UintegerValue (16),
188                    MakeUintegerAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_a88bbff666cd3bb5bad099587a967d547}{DsrRouting::m\_rreqRetries}),
189                    MakeUintegerChecker<uint32\_t> ())
190     .AddAttribute (\textcolor{stringliteral}{"MaintenanceRetries"},
191                    \textcolor{stringliteral}{"Maximum number of retransmissions for "}
192                    \textcolor{stringliteral}{"data packets from maintenance buffer."},
193                    UintegerValue (2),
194                    MakeUintegerAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_aca44a3d45b57be61ec3e41774f20c1fb}{DsrRouting::m\_maxMaintRexmt}),
195                    MakeUintegerChecker<uint32\_t> ())
196     .AddAttribute (\textcolor{stringliteral}{"RequestTableSize"},
197                    \textcolor{stringliteral}{"Maximum number of request entries in the request table, "}
198                    \textcolor{stringliteral}{"set this as the number of nodes in the simulation."},
199                    UintegerValue (64),
200                    MakeUintegerAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_a8f6df12e2c9690f79943c2195af1be37}{DsrRouting::m\_requestTableSize}),
201                    MakeUintegerChecker<uint32\_t> ())
202     .AddAttribute (\textcolor{stringliteral}{"RequestIdSize"},
203                    \textcolor{stringliteral}{"Maximum number of request source Ids in "}
204                    \textcolor{stringliteral}{"the request table."},
205                    UintegerValue (16),
206                    MakeUintegerAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_aac8b18967bf0bc05a7f0024ea55e99b1}{DsrRouting::m\_requestTableIds}),
207                    MakeUintegerChecker<uint32\_t> ())
208     .AddAttribute (\textcolor{stringliteral}{"UniqueRequestIdSize"},
209                    \textcolor{stringliteral}{"Maximum number of request Ids in "}
210                    \textcolor{stringliteral}{"the request table for a single destination."},
211                    UintegerValue (256),
212                    MakeUintegerAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_a14ef1332178e76768359c27a45db9624}{DsrRouting::m\_maxRreqId}),
213                    MakeUintegerChecker<uint32\_t> ())
214     .AddAttribute (\textcolor{stringliteral}{"NonPropRequestTimeout"},
215                    \textcolor{stringliteral}{"The timeout value for non-propagation request."},
216                    TimeValue (\hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (30)),
217                    MakeTimeAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_a42c2f43fbb0c5fefed36689eaf5c720e}{DsrRouting::m\_nonpropRequestTimeout}
      ),
218                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
219     .AddAttribute (\textcolor{stringliteral}{"DiscoveryHopLimit"},
220                    \textcolor{stringliteral}{"The max discovery hop limit for route requests."},
221                    UintegerValue (255),
222                    MakeUintegerAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_acf9cc5a2ae446403b8b57f3340fac178}{DsrRouting::m\_discoveryHopLimit}),
223                    MakeUintegerChecker<uint32\_t> ())
224     .AddAttribute (\textcolor{stringliteral}{"MaxSalvageCount"},
225                    \textcolor{stringliteral}{"The max salvage count for a single data packet."},
226                    UintegerValue (15),
227                    MakeUintegerAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_a89f7e66d9f1bd83433b004876acf4a45}{DsrRouting::m\_maxSalvageCount}),
228                    MakeUintegerChecker<uint8\_t> ())
229     .AddAttribute (\textcolor{stringliteral}{"BlacklistTimeout"},
230                    \textcolor{stringliteral}{"The time for a neighbor to stay in blacklist."},
231                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (3)),
232                    MakeTimeAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_a07022fdee22444ddb4560c1f78bccaf2}{DsrRouting::m\_blacklistTimeout}),
233                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
234     .AddAttribute (\textcolor{stringliteral}{"GratReplyHoldoff"},
235                    \textcolor{stringliteral}{"The time for gratuitous reply entry to expire."},
236                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (1)),
237                    MakeTimeAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_a43f5d8b4569f2122788518584ce3ae77}{DsrRouting::m\_gratReplyHoldoff}),
238                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
239     .AddAttribute (\textcolor{stringliteral}{"BroadcastJitter"},
240                    \textcolor{stringliteral}{"The jitter time to avoid collision for broadcast packets."},
241                    UintegerValue (10),
242                    MakeUintegerAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_afb77e13fc791e5076ee1f8595b9c6617}{DsrRouting::m\_broadcastJitter}),
243                    MakeUintegerChecker<uint32\_t> ())
244     .AddAttribute (\textcolor{stringliteral}{"LinkAckTimeout"},
245                    \textcolor{stringliteral}{"The time a packet in maintenance buffer wait for "}
246                    \textcolor{stringliteral}{"link acknowledgment."},
247                    TimeValue (\hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (100)),
248                    MakeTimeAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_ace1671263c7f09cd2523f1c81dc41631}{DsrRouting::m\_linkAckTimeout}),
249                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
250     .AddAttribute (\textcolor{stringliteral}{"TryLinkAcks"},
251                    \textcolor{stringliteral}{"The number of link acknowledgment to use."},
252                    UintegerValue (1),
253                    MakeUintegerAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_acecdd106e259c448bcfa6a6cef901658}{DsrRouting::m\_tryLinkAcks}),
254                    MakeUintegerChecker<uint32\_t> ())
255     .AddAttribute (\textcolor{stringliteral}{"PassiveAckTimeout"},
256                    \textcolor{stringliteral}{"The time a packet in maintenance buffer wait for "}
257                    \textcolor{stringliteral}{"passive acknowledgment."},
258                    TimeValue (\hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (100)),
259                    MakeTimeAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_a6155bddae63f0e1fda8afbeebc25a54c}{DsrRouting::m\_passiveAckTimeout}),
260                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
261     .AddAttribute (\textcolor{stringliteral}{"TryPassiveAcks"},
262                    \textcolor{stringliteral}{"The number of passive acknowledgment to use."},
263                    UintegerValue (1),
264                    MakeUintegerAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_aadd1dd676ec50cae94ffd6f2eefb277c}{DsrRouting::m\_tryPassiveAcks}),
265                    MakeUintegerChecker<uint32\_t> ())
266     .AddAttribute (\textcolor{stringliteral}{"RequestPeriod"},
267                    \textcolor{stringliteral}{"The base time interval between route requests."},
268                    TimeValue (\hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (500)),
269                    MakeTimeAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_acb19e2fe8a4cc1812181cdd5491383ee}{DsrRouting::m\_requestPeriod}),
270                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
271     .AddAttribute (\textcolor{stringliteral}{"MaxRequestPeriod"},
272                    \textcolor{stringliteral}{"The max time interval between route requests."},
273                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (10)),
274                    MakeTimeAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_abce8e7bae58dada0db217ca294cb4c6e}{DsrRouting::m\_maxRequestPeriod}),
275                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
276     .AddAttribute (\textcolor{stringliteral}{"GraReplyTableSize"},
277                    \textcolor{stringliteral}{"The gratuitous reply table size."},
278                    UintegerValue (64),
279                    MakeUintegerAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_aa22d7408adbcefde51113d45b83d415f}{DsrRouting::m\_graReplyTableSize}),
280                    MakeUintegerChecker<uint32\_t> ())
281     .AddAttribute (\textcolor{stringliteral}{"CacheType"},
282                    \textcolor{stringliteral}{"Use Link Cache or use Path Cache"},
283                    StringValue (\textcolor{stringliteral}{"LinkCache"}),
284                    MakeStringAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_a07e25fa5f4aebf7b129a31853988045b}{DsrRouting::m\_cacheType}),
285                    MakeStringChecker ())
286     .AddAttribute (\textcolor{stringliteral}{"StabilityDecrFactor"},
287                    \textcolor{stringliteral}{"The stability decrease factor for link cache"},
288                    UintegerValue (2),
289                    MakeUintegerAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4a6db69db44738ae07289fa0993ac916}{DsrRouting::m\_stabilityDecrFactor}
      ),
290                    MakeUintegerChecker<uint32\_t> ())
291     .AddAttribute (\textcolor{stringliteral}{"StabilityIncrFactor"},
292                    \textcolor{stringliteral}{"The stability increase factor for link cache"},
293                    UintegerValue (4),
294                    MakeUintegerAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_a9c6b73944ece2adc5f06b5010d9e55f2}{DsrRouting::m\_stabilityIncrFactor}
      ),
295                    MakeUintegerChecker<uint32\_t> ())
296     .AddAttribute (\textcolor{stringliteral}{"InitStability"},
297                    \textcolor{stringliteral}{"The initial stability factor for link cache"},
298                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (25)),
299                    MakeTimeAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_a9b68bafde23cf10e425d341f91da3b5e}{DsrRouting::m\_initStability}),
300                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
301     .AddAttribute (\textcolor{stringliteral}{"MinLifeTime"},
302                    \textcolor{stringliteral}{"The minimal life time for link cache"},
303                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (1)),
304                    MakeTimeAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_ad7daf5388ab1104e535b27bb4eae1421}{DsrRouting::m\_minLifeTime}),
305                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
306     .AddAttribute (\textcolor{stringliteral}{"UseExtends"},
307                    \textcolor{stringliteral}{"The extension time for link cache"},
308                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (120)),
309                    MakeTimeAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_aa0a73bc163b0b32c84a5913ebbb62dc5}{DsrRouting::m\_useExtends}),
310                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
311     .AddAttribute (\textcolor{stringliteral}{"EnableSubRoute"},
312                    \textcolor{stringliteral}{"Enables saving of sub route when receiving "}
313                    \textcolor{stringliteral}{"route error messages, only available when "}
314                    \textcolor{stringliteral}{"using path route cache"},
315                    BooleanValue (\textcolor{keyword}{true}),
316                    MakeBooleanAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_a83f7a7d54f8b078d987d46cf6edcd08e}{DsrRouting::m\_subRoute}),
317                    MakeBooleanChecker ())
318     .AddAttribute (\textcolor{stringliteral}{"RetransIncr"},
319                    \textcolor{stringliteral}{"The increase time for retransmission timer "}
320                    \textcolor{stringliteral}{"when facing network congestion"},
321                    TimeValue (\hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (20)),
322                    MakeTimeAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_a49d8f2c59b9e8bcd6cb57cb302eac47b}{DsrRouting::m\_retransIncr}),
323                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
324     .AddAttribute (\textcolor{stringliteral}{"MaxNetworkQueueSize"},
325                    \textcolor{stringliteral}{"The max number of packet to save in the network queue."},
326                    UintegerValue (400),
327                    MakeUintegerAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_ab2edb0a37a59600e15dbb91b5683ad25}{DsrRouting::m\_maxNetworkSize}),
328                    MakeUintegerChecker<uint32\_t> ())
329     .AddAttribute (\textcolor{stringliteral}{"MaxNetworkQueueDelay"},
330                    \textcolor{stringliteral}{"The max time for a packet to stay in the network queue."},
331                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (30.0)),
332                    MakeTimeAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_a5bf0e688251f1587471745f4355203c1}{DsrRouting::m\_maxNetworkDelay}),
333                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
334     .AddAttribute (\textcolor{stringliteral}{"NumPriorityQueues"},
335                    \textcolor{stringliteral}{"The max number of packet to save in the network queue."},
336                    UintegerValue (2),
337                    MakeUintegerAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_aa1952258d04f2ca8a0980d8436bca317}{DsrRouting::m\_numPriorityQueues}),
338                    MakeUintegerChecker<uint32\_t> ())
339     .AddAttribute (\textcolor{stringliteral}{"LinkAcknowledgment"},
340                    \textcolor{stringliteral}{"Enable Link layer acknowledgment mechanism"},
341                    BooleanValue (\textcolor{keyword}{true}),
342                    MakeBooleanAccessor (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_a216a52d8b579a034df948765d941d3a4}{DsrRouting::m\_linkAck}),
343                    MakeBooleanChecker ())
344     .AddTraceSource (\textcolor{stringliteral}{"Tx"},
345                      \textcolor{stringliteral}{"Send DSR packet."},
346                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5e0a4e554d0321bd993b532d68931d75}{DsrRouting::m\_txPacketTrace}),
347                      \textcolor{stringliteral}{"ns3::dsr::DsrOptionSRHeader::TracedCallback"})
348     .AddTraceSource (\textcolor{stringliteral}{"Drop"},
349                      \textcolor{stringliteral}{"Drop DSR packet"},
350                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_aacee2c8437c0b61579cfa7a420423e03}{DsrRouting::m\_dropTrace}),
351                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
352   ;
353   \textcolor{keywordflow}{return} tid;
354 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 43


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Increase\+Retrans\+Timer@{Increase\+Retrans\+Timer}}
\index{Increase\+Retrans\+Timer@{Increase\+Retrans\+Timer}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Increase\+Retrans\+Timer()}{IncreaseRetransTimer()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Increase\+Retrans\+Timer (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_aeb92858b27d37c4c593ef7f5be53dd09}{}\label{classns3_1_1dsr_1_1DsrRouting_aeb92858b27d37c4c593ef7f5be53dd09}


This function is called to increase the retransmission timer for data packet in the network queue. 


\begin{DoxyCode}
1713 \{
1714   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1715   \textcolor{comment}{// We may want to get the queue first and then we need to save a vector of the entries here and then find}
1716   uint32\_t priority = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a67d111b0188b6e2210d1b4782820f8e3}{GetPriority} (\hyperlink{namespacens3_1_1dsr_a7c80bcec67d78dc149a0e503014d07c5ad29c69f5a6ad5fbb5eec5524f553e315}{DSR\_DATA\_PACKET});
1717   std::map<uint32\_t, Ptr<dsr::DsrNetworkQueue> >::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4606c3dfb1099afbfe1e7cd1d1c3c8ee}{m\_priorityQueue}.find (
      priority);
1718   Ptr<dsr::DsrNetworkQueue> dsrNetworkQueue = i->second;
1719 
1720   std::vector<DsrNetworkQueueEntry> newNetworkQueue = dsrNetworkQueue->GetQueue ();
1721   \textcolor{keywordflow}{for} (std::vector<DsrNetworkQueueEntry>::iterator i = newNetworkQueue.begin (); i != newNetworkQueue.end (
      ); i++)
1722     \{
1723       Ipv4Address nextHop = i->GetNextHopAddress ();
1724       \textcolor{keywordflow}{for} (std::map<NetworkKey, Timer>::iterator j = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4a35b13cdca413ab5bc0b1b3b7b78907}{m\_addressForwardTimer}.begin (); j
       != \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4a35b13cdca413ab5bc0b1b3b7b78907}{m\_addressForwardTimer}.end (); j++)
1725         \{
1726           \textcolor{keywordflow}{if} (nextHop == j->first.m\_nextHop)
1727             \{
1728               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The network delay left is "} << j->second.GetDelayLeft ());
1729               j->second.SetDelay (j->second.GetDelayLeft () + \hyperlink{classns3_1_1dsr_1_1DsrRouting_a49d8f2c59b9e8bcd6cb57cb302eac47b}{m\_retransIncr});
1730             \}
1731         \}
1732     \}
1733 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 44




Here is the caller graph for this function\+:
% FIG 45


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Insert@{Insert}}
\index{Insert@{Insert}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Insert(\+Ptr$<$ dsr\+::\+Dsr\+Options $>$ option)}{Insert(Ptr< dsr::DsrOptions > option)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Insert (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf dsr\+::\+Dsr\+Options} $>$}]{option}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_af84bc8969d7d9e4ff167cab6bca88ce0}{}\label{classns3_1_1dsr_1_1DsrRouting_af84bc8969d7d9e4ff167cab6bca88ce0}


Insert a new Dsr Option. 


\begin{DoxyParams}{Parameters}
{\em option} & the option to insert \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
3525 \{
3526   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a7f705d6856c04b7bce60317db968bf45}{m\_options}.push\_back (option);
3527 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 46


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Is\+Link\+Cache@{Is\+Link\+Cache}}
\index{Is\+Link\+Cache@{Is\+Link\+Cache}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Is\+Link\+Cache()}{IsLinkCache()}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::dsr\+::\+Dsr\+Routing\+::\+Is\+Link\+Cache (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a857054926335441b467ee12bdf160852}{}\label{classns3_1_1dsr_1_1DsrRouting_a857054926335441b467ee12bdf160852}


functions used to direct to route cache 


\begin{DoxyCode}
643 \{
644   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->IsLinkCache ();
645 \}
\end{DoxyCode}
\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Link\+Schedule\+Timer\+Expire@{Link\+Schedule\+Timer\+Expire}}
\index{Link\+Schedule\+Timer\+Expire@{Link\+Schedule\+Timer\+Expire}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Link\+Schedule\+Timer\+Expire(\+Dsr\+Maintain\+Buff\+Entry \&mb, uint8\+\_\+t protocol)}{LinkScheduleTimerExpire(DsrMaintainBuffEntry &mb, uint8_t protocol)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Link\+Schedule\+Timer\+Expire (
\begin{DoxyParamCaption}
\item[{{\bf Dsr\+Maintain\+Buff\+Entry} \&}]{mb, }
\item[{uint8\+\_\+t}]{protocol}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_ab0ce215bf5359f4d6d4541b8a479007c}{}\label{classns3_1_1dsr_1_1DsrRouting_ab0ce215bf5359f4d6d4541b8a479007c}


This function deals with packet retransmission timer expire using link acknowledgment. 


\begin{DoxyCode}
2534 \{
2535   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << (uint32\_t)protocol);
2536   Ipv4Address nextHop = mb.GetNextHop ();
2537   Ptr<const Packet> packet = mb.GetPacket ();
2538   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a8a726fb52558a1a8172a5bd5b8cdb072}{SetRoute} (nextHop, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress});
2539   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = packet->Copy ();
2540 
2541   LinkKey lk;
2542   lk.m\_source = mb.GetSrc ();
2543   lk.m\_destination = mb.GetDst ();
2544   lk.m\_ourAdd = mb.GetOurAdd ();
2545   lk.m\_nextHop = mb.GetNextHop ();
2546 
2547   \textcolor{comment}{// Cancel passive ack timer}
2548   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ad532172035dbd4b038de0e94f4ce5ff6}{m\_linkAckTimer}[lk].Cancel ();
2549   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ad532172035dbd4b038de0e94f4ce5ff6}{m\_linkAckTimer}[lk].Remove ();
2550   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ad532172035dbd4b038de0e94f4ce5ff6}{m\_linkAckTimer}[lk].IsRunning ())
2551     \{
2552       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Timer not canceled"});
2553     \}
2554   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ad532172035dbd4b038de0e94f4ce5ff6}{m\_linkAckTimer}.erase (lk);
2555 
2556   \textcolor{comment}{// Increase the send retry times}
2557   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a78b9a7405d3c905f57fa5aba63984d26}{m\_linkRetries} = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a85ba159639f9bc13b3d8890458128a79}{m\_linkCnt}[lk];
2558   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a78b9a7405d3c905f57fa5aba63984d26}{m\_linkRetries} < \hyperlink{classns3_1_1dsr_1_1DsrRouting_acecdd106e259c448bcfa6a6cef901658}{m\_tryLinkAcks})
2559     \{
2560       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a85ba159639f9bc13b3d8890458128a79}{m\_linkCnt}[lk] = ++\hyperlink{classns3_1_1dsr_1_1DsrRouting_a78b9a7405d3c905f57fa5aba63984d26}{m\_linkRetries};
2561       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a947d831bc0964240b1a41b3a09832eff}{ScheduleLinkPacketRetry} (mb, protocol);
2562     \}
2563   \textcolor{keywordflow}{else}
2564     \{
2565       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"We need to send error messages now"});
2566 
2567       \textcolor{comment}{// Delete all the routes including the links}
2568       \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->DeleteAllRoutesIncludeLink (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, nextHop, 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress});
2569       \textcolor{comment}{/*}
2570 \textcolor{comment}{       * here we cancel the packet retransmission time for all the packets have next hop address as nextHop}
2571 \textcolor{comment}{       * Also salvage the packet for the all the packet destined for the nextHop address}
2572 \textcolor{comment}{       * this is also responsible for send unreachable error back to source}
2573 \textcolor{comment}{       */}
2574       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a215e6fcab10ee0d744a657f0af2695c6}{CancelPacketTimerNextHop} (nextHop, protocol);
2575     \}
2576 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 47




Here is the caller graph for this function\+:
% FIG 48


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Lookup\+Route@{Lookup\+Route}}
\index{Lookup\+Route@{Lookup\+Route}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Lookup\+Route(\+Ipv4\+Address id, Dsr\+Route\+Cache\+Entry \&rt)}{LookupRoute(Ipv4Address id, DsrRouteCacheEntry &rt)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::dsr\+::\+Dsr\+Routing\+::\+Lookup\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{id, }
\item[{{\bf Dsr\+Route\+Cache\+Entry} \&}]{rt}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a9b0d6cddf99a8825289e9d142ede2379}{}\label{classns3_1_1dsr_1_1DsrRouting_a9b0d6cddf99a8825289e9d142ede2379}

\begin{DoxyCode}
653 \{
654   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->LookupRoute (\textcolor{keywordtype}{id}, rt);
655 \}
\end{DoxyCode}
\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Network\+Schedule\+Timer\+Expire@{Network\+Schedule\+Timer\+Expire}}
\index{Network\+Schedule\+Timer\+Expire@{Network\+Schedule\+Timer\+Expire}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Network\+Schedule\+Timer\+Expire(\+Dsr\+Maintain\+Buff\+Entry \&mb, uint8\+\_\+t protocol)}{NetworkScheduleTimerExpire(DsrMaintainBuffEntry &mb, uint8_t protocol)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Network\+Schedule\+Timer\+Expire (
\begin{DoxyParamCaption}
\item[{{\bf Dsr\+Maintain\+Buff\+Entry} \&}]{mb, }
\item[{uint8\+\_\+t}]{protocol}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_aabcdf59bcb4907718986626a7a402dad}{}\label{classns3_1_1dsr_1_1DsrRouting_aabcdf59bcb4907718986626a7a402dad}


This function deals with packet retransmission timer expire using network acknowledgment. 


\begin{DoxyCode}
2630 \{
2631   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = mb.GetPacket ()->Copy ();
2632   Ipv4Address source = mb.GetSrc ();
2633   Ipv4Address nextHop = mb.GetNextHop ();
2634   Ipv4Address dst = mb.GetDst ();
2635 
2636   NetworkKey networkKey;
2637   networkKey.m\_ackId = mb.GetAckId ();
2638   networkKey.m\_ourAdd = mb.GetOurAdd ();
2639   networkKey.m\_nextHop = nextHop;
2640   networkKey.m\_source = source;
2641   networkKey.m\_destination = dst;
2642 
2643   \textcolor{comment}{// Increase the send retry times}
2644   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a02a55fe3b490af4dbd62953065d293a3}{m\_sendRetries} = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5042f7e5df0470025fdb6023fcc24411}{m\_addressForwardCnt}[networkKey];
2645 
2646   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a02a55fe3b490af4dbd62953065d293a3}{m\_sendRetries} >= \hyperlink{classns3_1_1dsr_1_1DsrRouting_aca44a3d45b57be61ec3e41774f20c1fb}{m\_maxMaintRexmt})
2647     \{
2648       \textcolor{comment}{// Delete all the routes including the links}
2649       \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->DeleteAllRoutesIncludeLink (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, nextHop, 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress});
2650       \textcolor{comment}{/*}
2651 \textcolor{comment}{       * here we cancel the packet retransmission time for all the packets have next hop address as nextHop}
2652 \textcolor{comment}{       * Also salvage the packet for the all the packet destined for the nextHop address}
2653 \textcolor{comment}{       */}
2654       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a215e6fcab10ee0d744a657f0af2695c6}{CancelPacketTimerNextHop} (nextHop, protocol);
2655     \}
2656   \textcolor{keywordflow}{else}
2657     \{
2658       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5042f7e5df0470025fdb6023fcc24411}{m\_addressForwardCnt}[networkKey] = ++\hyperlink{classns3_1_1dsr_1_1DsrRouting_a02a55fe3b490af4dbd62953065d293a3}{m\_sendRetries};
2659       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a6a18c6baa374d5e6a68f8952d1afdb13}{ScheduleNetworkPacketRetry} (mb, \textcolor{keyword}{false}, protocol);
2660     \}
2661 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 49




Here is the caller graph for this function\+:
% FIG 50


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Notify\+New\+Aggregate@{Notify\+New\+Aggregate}}
\index{Notify\+New\+Aggregate@{Notify\+New\+Aggregate}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Notify\+New\+Aggregate()}{NotifyNewAggregate()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Notify\+New\+Aggregate (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a7742bf3036dba9f9b24906b959be728e}{}\label{classns3_1_1dsr_1_1DsrRouting_a7742bf3036dba9f9b24906b959be728e}
Notify all Objects aggregated to this one of a new \hyperlink{classns3_1_1Object}{Object} being aggregated.

This method is invoked whenever two sets of Objects are aggregated together. It is invoked exactly once for each \hyperlink{classns3_1_1Object}{Object} in both sets. This method can be overriden by subclasses who wish to be notified of aggregation events. These subclasses must chain up to their base class \hyperlink{classns3_1_1dsr_1_1DsrRouting_a7742bf3036dba9f9b24906b959be728e}{Notify\+New\+Aggregate()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} and \hyperlink{classns3_1_1Object_a79dd435d300f3deca814553f561a2922}{Aggregate\+Object()} from within this method.

This function must be implemented in the stack that needs to notify other stacks connected to the node of their presence in the node. 

Reimplemented from \hyperlink{classns3_1_1Object_a1bd7211125185a6cd511c35fea4e500f}{ns3\+::\+Object}.


\begin{DoxyCode}
398 \{
399   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \textcolor{stringliteral}{"NotifyNewAggregate"});
400   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ac27df0103a40973f0a3f78af0092c60d}{m\_node} == 0)
401     \{
402       Ptr<Node> node = this->GetObject<Node> ();
403       \textcolor{keywordflow}{if} (node != 0)
404         \{
405           \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa42c1b9ee27c8168a2141d3d032006c3}{m\_ipv4} = this->GetObject<Ipv4L3Protocol> ();
406           \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_aa42c1b9ee27c8168a2141d3d032006c3}{m\_ipv4} != 0)
407             \{
408               this->\hyperlink{classns3_1_1dsr_1_1DsrRouting_a0edfde42e4b79a1e04e186cc732360b9}{SetNode} (node);
409               \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa42c1b9ee27c8168a2141d3d032006c3}{m\_ipv4}->Insert (\textcolor{keyword}{this});
410               this->\hyperlink{classns3_1_1dsr_1_1DsrRouting_a3831a9cac1a24f243f81e770ae4b9587}{SetDownTarget} (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1Ipv4L3Protocol_abe8cf785815f3fbb32b0e21d629be641}{Ipv4L3Protocol::Send}, \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa42c1b9ee27c8168a2141d3d032006c3}{m\_ipv4}));
411             \}
412 
413           \hyperlink{classns3_1_1dsr_1_1DsrRouting_a0443d48172143cafa1d0491e35f3fbaf}{m\_ip} = node->GetObject<Ipv4> ();
414           \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a0443d48172143cafa1d0491e35f3fbaf}{m\_ip} != 0)
415             \{
416               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Ipv4 started"});
417             \}
418         \}
419     \}
420   \hyperlink{classns3_1_1Object_a1bd7211125185a6cd511c35fea4e500f}{IpL4Protocol::NotifyNewAggregate} ();
421   \hyperlink{classns3_1_1Simulator_a2219ee02c0647adc83d1c918c3256266}{Simulator::ScheduleNow} (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_aa97c9bcf61e5623297563965740a8559}{DsrRouting::Start}, \textcolor{keyword}{this});
422 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 51


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Packet\+New\+Route@{Packet\+New\+Route}}
\index{Packet\+New\+Route@{Packet\+New\+Route}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Packet\+New\+Route(\+Ptr$<$ Packet $>$ packet, Ipv4\+Address source, Ipv4\+Address destination, uint8\+\_\+t protocol)}{PacketNewRoute(Ptr< Packet > packet, Ipv4Address source, Ipv4Address destination, uint8_t protocol)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Packet\+New\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Ipv4\+Address}}]{source, }
\item[{{\bf Ipv4\+Address}}]{destination, }
\item[{uint8\+\_\+t}]{protocol}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_ae70ab39db551d1d81afc081196f78017}{}\label{classns3_1_1dsr_1_1DsrRouting_ae70ab39db551d1d81afc081196f78017}


When route vector corrupted, originate a new packet, normally not happening. 

When found a route and use it, Use\+Extends to the link cache 
\begin{DoxyCode}
1149 \{
1150   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << source << destination << (uint32\_t)protocol);
1151   \textcolor{comment}{// Look up routes for the specific destination}
1152   DsrRouteCacheEntry toDst;
1153   \textcolor{keywordtype}{bool} findRoute = \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->LookupRoute (destination, toDst);
1154   \textcolor{comment}{// Queue the packet if there is no route pre-existing}
1155   \textcolor{keywordflow}{if} (!findRoute)
1156     \{
1157       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds ()
1158                    << \textcolor{stringliteral}{"s "} << \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress} << \textcolor{stringliteral}{" there is no route for this packet, queue the
       packet"});
1159 
1160       Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = packet->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} ();
1161       DsrSendBuffEntry newEntry (p, destination, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a1f89794801db0336d92e4ca85fbc09a7}{m\_sendBufferTimeout}, protocol);     \textcolor{comment}{//
       Create a new entry for send buffer}
1162       \textcolor{keywordtype}{bool} result = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a887ae39d7060171753c0605d5c120549}{m\_sendBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrSendBuffer_aac846f6a38f6fc6431c8483103ed5121}{Enqueue} (newEntry);     \textcolor{comment}{// Enqueue the packet in send
       buffer}
1163       \textcolor{keywordflow}{if} (result)
1164         \{
1165           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds ()
1166                        << \textcolor{stringliteral}{"s Add packet PID: "} << packet->\hyperlink{classns3_1_1Packet_a1f212c825b50e54d94f5b9ae99592e6a}{GetUid} () << \textcolor{stringliteral}{" to queue. Packet: "} << *
      packet);
1167 
1168           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Send RREQ to"} << destination);
1169           \textcolor{keywordflow}{if} ((\hyperlink{classns3_1_1dsr_1_1DsrRouting_a47174823b0622573b681afc40d6ea558}{m\_addressReqTimer}.find (destination) == 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a47174823b0622573b681afc40d6ea558}{m\_addressReqTimer}.end ()) && (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a0936df610f90f7e79c24a2a8cdea6c14}{m\_nonPropReqTimer}.find (destination) == 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a0936df610f90f7e79c24a2a8cdea6c14}{m\_nonPropReqTimer}.end ()))
1170             \{
1171               \textcolor{comment}{/*}
1172 \textcolor{comment}{               * Call the send request function, it will update the request table entry and ttl there}
1173 \textcolor{comment}{               */}
1174               \hyperlink{classns3_1_1dsr_1_1DsrRouting_a74777d1806e768fccc1c2fe169b42c98}{SendInitialRequest} (source, destination, protocol);
1175             \}
1176         \}
1177     \}
1178   \textcolor{keywordflow}{else}
1179     \{
1180       Ptr<Packet> cleanP = packet->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} ();
1181       DsrRoutingHeader dsrRoutingHeader;
1182       dsrRoutingHeader.SetNextHeader (protocol);
1183       dsrRoutingHeader.SetMessageType (2);
1184       dsrRoutingHeader.SetSourceId (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4593e50d5f36e9b9b013fe0422067c44}{GetIDfromIP} (source));
1185       dsrRoutingHeader.SetDestId (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4593e50d5f36e9b9b013fe0422067c44}{GetIDfromIP} (destination));
1186 
1187       DsrOptionSRHeader sourceRoute;
1188       std::vector<Ipv4Address> nodeList = toDst.GetVector ();     \textcolor{comment}{// Get the route from the route entry we
       found}
1189       Ipv4Address nextHop = \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa1b16658c14499af76ca7dd69c034f22}{SearchNextHop} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, nodeList);      \textcolor{comment}{// Get
       the next hop address for the route}
1190       \textcolor{keywordflow}{if} (nextHop == \textcolor{stringliteral}{"0.0.0.0"})
1191         \{
1192           \hyperlink{classns3_1_1dsr_1_1DsrRouting_ae70ab39db551d1d81afc081196f78017}{PacketNewRoute} (cleanP, source, destination, protocol);
1193           \textcolor{keywordflow}{return};
1194         \}
1195       uint8\_t salvage = 0;
1196       sourceRoute.SetNodesAddress (nodeList);     \textcolor{comment}{// Save the whole route in the source route header of the
       packet}
1198 \textcolor{comment}{}      \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->IsLinkCache ())
1199         \{
1200           \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->UseExtends (nodeList);
1201         \}
1202       sourceRoute.SetSegmentsLeft ((nodeList.size () - 2));     \textcolor{comment}{// The segmentsLeft field will indicate the
       hops to go}
1203       sourceRoute.SetSalvage (salvage);
1204 
1205       uint8\_t length = sourceRoute.GetLength ();
1206       dsrRoutingHeader.SetPayloadLength (uint16\_t (length) + 2);
1207       dsrRoutingHeader.AddDsrOption (sourceRoute);
1208       cleanP->AddHeader (dsrRoutingHeader);
1209       Ptr<const Packet> mtP = cleanP->Copy ();
1210       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a8a726fb52558a1a8172a5bd5b8cdb072}{SetRoute} (nextHop, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress});
1211       \textcolor{comment}{// Put the data packet in the maintenance queue for data packet retransmission}
1212       DsrMaintainBuffEntry newEntry (\textcolor{comment}{/*Packet=*/} mtP, \textcolor{comment}{/*Ipv4Address=*/} 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, \textcolor{comment}{/*nextHop=*/} nextHop,
1213                                               \textcolor{comment}{/*source=*/} source, \textcolor{comment}{/*destination=*/} destination, \textcolor{comment}{/*ackId=*/} 
      0,
1214                                               \textcolor{comment}{/*SegsLeft=*/} nodeList.size () - 2, \textcolor{comment}{/*expire time=*/} 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac6b1dffa9665af0d6a71aa7b947962ee}{m\_maxMaintainTime});
1215       \textcolor{keywordtype}{bool} result = \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac9d28a64437fbe20a4228c9811f9fc27}{m\_maintainBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a8ec30b5b9b0f6af36e61867327a47717}{Enqueue} (newEntry);     \textcolor{comment}{// Enqueue the packet
       the the maintenance buffer}
1216 
1217       \textcolor{keywordflow}{if} (result)
1218         \{
1219           NetworkKey networkKey;
1220           networkKey.m\_ackId = newEntry.GetAckId ();
1221           networkKey.m\_ourAdd = newEntry.GetOurAdd ();
1222           networkKey.m\_nextHop = newEntry.GetNextHop ();
1223           networkKey.m\_source = newEntry.GetSrc ();
1224           networkKey.m\_destination = newEntry.GetDst ();
1225 
1226           PassiveKey passiveKey;
1227           passiveKey.m\_ackId = 0;
1228           passiveKey.m\_source = newEntry.GetSrc ();
1229           passiveKey.m\_destination = newEntry.GetDst ();
1230           passiveKey.m\_segsLeft = newEntry.GetSegsLeft ();
1231 
1232           LinkKey linkKey;
1233           linkKey.m\_source = newEntry.GetSrc ();
1234           linkKey.m\_destination = newEntry.GetDst ();
1235           linkKey.m\_ourAdd = newEntry.GetOurAdd ();
1236           linkKey.m\_nextHop = newEntry.GetNextHop ();
1237 
1238           \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5042f7e5df0470025fdb6023fcc24411}{m\_addressForwardCnt}[networkKey] = 0;
1239           \hyperlink{classns3_1_1dsr_1_1DsrRouting_a7fec404d680459aab2b40941a950502d}{m\_passiveCnt}[passiveKey] = 0;
1240           \hyperlink{classns3_1_1dsr_1_1DsrRouting_a85ba159639f9bc13b3d8890458128a79}{m\_linkCnt}[linkKey] = 0;
1241 
1242           \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a216a52d8b579a034df948765d941d3a4}{m\_linkAck})
1243             \{
1244               \hyperlink{classns3_1_1dsr_1_1DsrRouting_a947d831bc0964240b1a41b3a09832eff}{ScheduleLinkPacketRetry} (newEntry, protocol);
1245             \}
1246           \textcolor{keywordflow}{else}
1247             \{
1248               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Not using link acknowledgment"});
1249               \textcolor{keywordflow}{if} (nextHop != destination)
1250                 \{
1251                   \hyperlink{classns3_1_1dsr_1_1DsrRouting_abfdfa37822a492971fdf24540b635039}{SchedulePassivePacketRetry} (newEntry, protocol);
1252                 \}
1253               \textcolor{keywordflow}{else}
1254                 \{
1255                   \textcolor{comment}{// This is the first network retry}
1256                   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a6a18c6baa374d5e6a68f8952d1afdb13}{ScheduleNetworkPacketRetry} (newEntry, \textcolor{keyword}{true}, protocol);
1257                 \}
1258             \}
1259         \}
1260     \}
1261 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 52




Here is the caller graph for this function\+:
% FIG 53


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Passive\+Entry\+Check@{Passive\+Entry\+Check}}
\index{Passive\+Entry\+Check@{Passive\+Entry\+Check}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Passive\+Entry\+Check(\+Ptr$<$ Packet $>$ packet, Ipv4\+Address source, Ipv4\+Address destination, uint8\+\_\+t segs\+Left, uint16\+\_\+t fragment\+Offset, uint16\+\_\+t identification, bool save\+Entry)}{PassiveEntryCheck(Ptr< Packet > packet, Ipv4Address source, Ipv4Address destination, uint8_t segsLeft, uint16_t fragmentOffset, uint16_t identification, bool saveEntry)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::dsr\+::\+Dsr\+Routing\+::\+Passive\+Entry\+Check (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Ipv4\+Address}}]{source, }
\item[{{\bf Ipv4\+Address}}]{destination, }
\item[{uint8\+\_\+t}]{segs\+Left, }
\item[{uint16\+\_\+t}]{fragment\+Offset, }
\item[{uint16\+\_\+t}]{identification, }
\item[{bool}]{save\+Entry}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_aa2c72a1da3112a21f199ebe9dbc18110}{}\label{classns3_1_1dsr_1_1DsrRouting_aa2c72a1da3112a21f199ebe9dbc18110}


Find the same passive entry. 

Save this passive buffer entry for later check 
\begin{DoxyCode}
1961 \{
1962   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << source << destination << (uint32\_t)
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a2089307bfbe378b6cd8b274b38f70bb9}{segsLeft});
1963 
1964   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = packet->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} ();
1965   \textcolor{comment}{// Here the segments left value need to plus one to check the earlier hop maintain buffer entry}
1966   DsrPassiveBuffEntry newEntry;
1967   newEntry.SetPacket (p);
1968   newEntry.SetSource (source);
1969   newEntry.SetDestination (destination);
1970   newEntry.SetIdentification (identification);
1971   newEntry.SetFragmentOffset (fragmentOffset);
1972   newEntry.SetSegsLeft (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a2089307bfbe378b6cd8b274b38f70bb9}{segsLeft});  \textcolor{comment}{// We try to make sure the segments left is larger for 1}
1973 
1974 
1975   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The passive buffer size "} << \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac0404985fc04df7f5b8f53ff1e487079}{m\_passiveBuffer}->GetSize());
1976 
1977   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ac0404985fc04df7f5b8f53ff1e487079}{m\_passiveBuffer}->AllEqual (newEntry) && (!saveEntry))
1978     \{
1979       \textcolor{comment}{// The PromiscEqual function will remove the maintain buffer entry if equal value found}
1980       \textcolor{comment}{// It only compares the source and destination address, ackId, and the segments left value}
1981       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"We get the all equal for passive buffer here"});
1982 
1983       DsrMaintainBuffEntry mbEntry;
1984       mbEntry.SetPacket (p);
1985       mbEntry.SetSrc (source);
1986       mbEntry.SetDst (destination);
1987       mbEntry.SetAckId (0);
1988       mbEntry.SetSegsLeft (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a2089307bfbe378b6cd8b274b38f70bb9}{segsLeft} + 1);
1989 
1990       \hyperlink{classns3_1_1dsr_1_1DsrRouting_aee6495417f54a12f484029ee1a445d64}{CancelPassivePacketTimer} (mbEntry);
1991       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1992     \}
1993   \textcolor{keywordflow}{if} (saveEntry)
1994     \{
1996       \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac0404985fc04df7f5b8f53ff1e487079}{m\_passiveBuffer}->Enqueue (newEntry);
1997     \}
1998   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1999 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 54


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Passive\+Schedule\+Timer\+Expire@{Passive\+Schedule\+Timer\+Expire}}
\index{Passive\+Schedule\+Timer\+Expire@{Passive\+Schedule\+Timer\+Expire}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Passive\+Schedule\+Timer\+Expire(\+Dsr\+Maintain\+Buff\+Entry \&mb, uint8\+\_\+t protocol)}{PassiveScheduleTimerExpire(DsrMaintainBuffEntry &mb, uint8_t protocol)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Passive\+Schedule\+Timer\+Expire (
\begin{DoxyParamCaption}
\item[{{\bf Dsr\+Maintain\+Buff\+Entry} \&}]{mb, }
\item[{uint8\+\_\+t}]{protocol}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a2f93ffc379338703d6b6a923dff44dd5}{}\label{classns3_1_1dsr_1_1DsrRouting_a2f93ffc379338703d6b6a923dff44dd5}


This function deals with packet retransmission timer expire using passive acknowledgment. 


\begin{DoxyCode}
2581 \{
2582   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << (uint32\_t)protocol);
2583   Ipv4Address nextHop = mb.GetNextHop ();
2584   Ptr<const Packet> packet = mb.GetPacket ();
2585   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a8a726fb52558a1a8172a5bd5b8cdb072}{SetRoute} (nextHop, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress});
2586   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = packet->Copy ();
2587 
2588   PassiveKey pk;
2589   pk.m\_ackId = 0;
2590   pk.m\_source = mb.GetSrc ();
2591   pk.m\_destination = mb.GetDst ();
2592   pk.m\_segsLeft = mb.GetSegsLeft ();
2593 
2594   \textcolor{comment}{// Cancel passive ack timer}
2595   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac53c706898e76a7f4871a460d13edd36}{m\_passiveAckTimer}[pk].Cancel ();
2596   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac53c706898e76a7f4871a460d13edd36}{m\_passiveAckTimer}[pk].Remove ();
2597   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ac53c706898e76a7f4871a460d13edd36}{m\_passiveAckTimer}[pk].IsRunning ())
2598     \{
2599       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Timer not canceled"});
2600     \}
2601   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac53c706898e76a7f4871a460d13edd36}{m\_passiveAckTimer}.erase (pk);
2602 
2603   \textcolor{comment}{// Increase the send retry times}
2604   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a88b8d65dce20b6b8f910be916623da0b}{m\_passiveRetries} = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a7fec404d680459aab2b40941a950502d}{m\_passiveCnt}[pk];
2605   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a88b8d65dce20b6b8f910be916623da0b}{m\_passiveRetries} < \hyperlink{classns3_1_1dsr_1_1DsrRouting_aadd1dd676ec50cae94ffd6f2eefb277c}{m\_tryPassiveAcks})
2606     \{
2607       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a7fec404d680459aab2b40941a950502d}{m\_passiveCnt}[pk] = ++\hyperlink{classns3_1_1dsr_1_1DsrRouting_a88b8d65dce20b6b8f910be916623da0b}{m\_passiveRetries};
2608       \hyperlink{classns3_1_1dsr_1_1DsrRouting_abfdfa37822a492971fdf24540b635039}{SchedulePassivePacketRetry} (mb, protocol);
2609     \}
2610   \textcolor{keywordflow}{else}
2611     \{
2612       \textcolor{comment}{// This is the first network acknowledgement retry}
2613       \textcolor{comment}{// Cancel the passive packet timer now and remove maintenance buffer entry for it}
2614       \hyperlink{classns3_1_1dsr_1_1DsrRouting_aee6495417f54a12f484029ee1a445d64}{CancelPassivePacketTimer} (mb);
2615       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a6a18c6baa374d5e6a68f8952d1afdb13}{ScheduleNetworkPacketRetry} (mb, \textcolor{keyword}{true}, protocol);
2616     \}
2617 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 55




Here is the caller graph for this function\+:
% FIG 56


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Print\+Vector@{Print\+Vector}}
\index{Print\+Vector@{Print\+Vector}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Print\+Vector(std\+::vector$<$ Ipv4\+Address $>$ \&vec)}{PrintVector(std::vector< Ipv4Address > &vec)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Print\+Vector (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ {\bf Ipv4\+Address} $>$ \&}]{vec}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a21eda9cea85649375aed0a4b5f0c4c10}{}\label{classns3_1_1dsr_1_1DsrRouting_a21eda9cea85649375aed0a4b5f0c4c10}


Print the route vector. 


\begin{DoxyCode}
707 \{
708   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
709   \textcolor{comment}{/*}
710 \textcolor{comment}{   * Check elements in a route vector}
711 \textcolor{comment}{   */}
712   \textcolor{keywordflow}{if} (!vec.size ())
713     \{
714       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The vector is empty"});
715     \}
716   \textcolor{keywordflow}{else}
717     \{
718       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Print all the elements in a vector"});
719       \textcolor{keywordflow}{for} (std::vector<Ipv4Address>::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = vec.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != vec.end (); ++
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
720         \{
721           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The ip address "} << *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
722         \}
723     \}
724 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 57


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Priority\+Scheduler@{Priority\+Scheduler}}
\index{Priority\+Scheduler@{Priority\+Scheduler}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Priority\+Scheduler(uint32\+\_\+t priority, bool continue\+With\+First)}{PriorityScheduler(uint32_t priority, bool continueWithFirst)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Priority\+Scheduler (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{priority, }
\item[{bool}]{continue\+With\+First}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_aefc4dde8bd52b5b631a7ebf1d5924210}{}\label{classns3_1_1dsr_1_1DsrRouting_aefc4dde8bd52b5b631a7ebf1d5924210}


This function is called to schedule sending packets from the network queue by priority. 


\begin{DoxyCode}
1640 \{
1641   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << priority << continueWithFirst);
1642   uint32\_t numPriorities;
1643   \textcolor{keywordflow}{if} (continueWithFirst)
1644     \{
1645       numPriorities = 0;
1646     \}
1647   \textcolor{keywordflow}{else}
1648     \{
1649       numPriorities = priority;
1650     \}
1651   \textcolor{comment}{// priorities ranging from 0 to m\_numPriorityQueues, with 0 as the highest priority}
1652   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = priority; numPriorities < \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa1952258d04f2ca8a0980d8436bca317}{m\_numPriorityQueues}; numPriorities++)
1653     \{
1654       std::map<uint32\_t, Ptr<DsrNetworkQueue> >::iterator q = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4606c3dfb1099afbfe1e7cd1d1c3c8ee}{m\_priorityQueue}.find (
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
1655       Ptr<dsr::DsrNetworkQueue> dsrNetworkQueue = q->second;
1656       uint32\_t queueSize = dsrNetworkQueue->GetSize ();
1657       \textcolor{keywordflow}{if} (queueSize == 0)
1658         \{
1659           \textcolor{keywordflow}{if} ((\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} == (m\_numPriorityQueues - 1)) && continueWithFirst)
1660             \{
1661               \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0;
1662             \}
1663           \textcolor{keywordflow}{else}
1664             \{
1665               \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++;
1666             \}
1667         \}
1668       \textcolor{keywordflow}{else}
1669         \{
1670           uint32\_t totalQueueSize = 0;
1671           \textcolor{keywordflow}{for} (std::map<uint32\_t, Ptr<dsr::DsrNetworkQueue> >::iterator j = 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4606c3dfb1099afbfe1e7cd1d1c3c8ee}{m\_priorityQueue}.begin (); j != \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4606c3dfb1099afbfe1e7cd1d1c3c8ee}{m\_priorityQueue}.end (); j++)
1672             \{
1673               \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"The size of the network queue for "} << j->first << \textcolor{stringliteral}{" is "} << j->
      second->GetSize ());
1674               totalQueueSize += j->second->GetSize ();
1675               \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"The total network queue size is "} << totalQueueSize);
1676             \}
1677           \textcolor{keywordflow}{if} (totalQueueSize > 5)
1678             \{
1679               \textcolor{comment}{// Here the queue size is larger than 5, we need to increase the retransmission timer for
       each packet in the network queue}
1680               \hyperlink{classns3_1_1dsr_1_1DsrRouting_aeb92858b27d37c4c593ef7f5be53dd09}{IncreaseRetransTimer} ();
1681             \}
1682           DsrNetworkQueueEntry newEntry;
1683           dsrNetworkQueue->Dequeue (newEntry);
1684           \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a1ec646804cb4db00478cc07e51998608}{SendRealDown} (newEntry))
1685             \{
1686               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Packet sent by Dsr. Calling PriorityScheduler after some time"});
1687               \textcolor{comment}{// packet was successfully sent down. call scheduler after some time}
1688               \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{group__timecivil_ga17465a639c8d1464e76538afdd78a9f0}{MicroSeconds} (
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a22a85b3510166ffdd451e4010f996f0f}{m\_uniformRandomVariable}->\hyperlink{classns3_1_1RandomVariableStream_a66cd94e6305ce7f000f1a9ff0fcb9aef}{GetInteger} (0, 1000)),
1689                                    &\hyperlink{classns3_1_1dsr_1_1DsrRouting_aefc4dde8bd52b5b631a7ebf1d5924210}{DsrRouting::PriorityScheduler},\textcolor{keyword}{this}, 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, \textcolor{keyword}{false});
1690             \}
1691           \textcolor{keywordflow}{else}
1692             \{
1693               \textcolor{comment}{// packet was dropped by Dsr. Call scheduler immediately so that we can}
1694               \textcolor{comment}{// send another packet immediately.}
1695               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Packet dropped by Dsr. Calling PriorityScheduler immediately"});
1696               \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (0), &
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_aefc4dde8bd52b5b631a7ebf1d5924210}{DsrRouting::PriorityScheduler}, \textcolor{keyword}{this}, \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, \textcolor{keyword}{false});
1697             \}
1698 
1699           \textcolor{keywordflow}{if} ((\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} == (m\_numPriorityQueues - 1)) && continueWithFirst)
1700             \{
1701               \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0;
1702             \}
1703           \textcolor{keywordflow}{else}
1704             \{
1705               \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++;
1706             \}
1707         \}
1708     \}
1709 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 58




Here is the caller graph for this function\+:
% FIG 59


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Process@{Process}}
\index{Process@{Process}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Process(\+Ptr$<$ Packet $>$ \&packet, Ipv4\+Header const \&ipv4\+Header, Ipv4\+Address dst, uint8\+\_\+t $\ast$next\+Header, uint8\+\_\+t protocol, bool \&is\+Dropped)}{Process(Ptr< Packet > &packet, Ipv4Header const &ipv4Header, Ipv4Address dst, uint8_t *nextHeader, uint8_t protocol, bool &isDropped)}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::\+Process (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$ \&}]{packet, }
\item[{{\bf Ipv4\+Header} const \&}]{ipv4\+Header, }
\item[{{\bf Ipv4\+Address}}]{dst, }
\item[{uint8\+\_\+t $\ast$}]{next\+Header, }
\item[{uint8\+\_\+t}]{protocol, }
\item[{bool \&}]{is\+Dropped}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_aae399429f2359860fbb7992313a2dbd1}{}\label{classns3_1_1dsr_1_1DsrRouting_aae399429f2359860fbb7992313a2dbd1}


Process method Called from \hyperlink{classns3_1_1Ipv4L3Protocol_a2f27fb0a3f698ffb34a654323b063c94}{Ipv4\+L3\+Protocol\+::\+Receive}. 


\begin{DoxyParams}{Parameters}
{\em packet} & the packet \\
\hline
{\em ipv4\+Header} & I\+Pv4 header of the packet \\
\hline
{\em dst} & destination address of the packet received (i.\+e. us) \\
\hline
{\em next\+Header} & the next header \\
\hline
{\em protocol} & the protocol number \\
\hline
{\em is\+Dropped} & if the packet must be dropped \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the size processed 
\end{DoxyReturn}
\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Promisc\+Receive@{Promisc\+Receive}}
\index{Promisc\+Receive@{Promisc\+Receive}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Promisc\+Receive(\+Ptr$<$ Net\+Device $>$ device, Ptr$<$ const Packet $>$ packet, uint16\+\_\+t protocol, const Address \&from, const Address \&to, Net\+Device\+::\+Packet\+Type packet\+Type)}{PromiscReceive(Ptr< NetDevice > device, Ptr< const Packet > packet, uint16_t protocol, const Address &from, const Address &to, NetDevice::PacketType packetType)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::dsr\+::\+Dsr\+Routing\+::\+Promisc\+Receive (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{device, }
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{packet, }
\item[{uint16\+\_\+t}]{protocol, }
\item[{const {\bf Address} \&}]{from, }
\item[{const {\bf Address} \&}]{to, }
\item[{{\bf Net\+Device\+::\+Packet\+Type}}]{packet\+Type}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a95d4ab6177fb07d4791a2ed82cd4a2bb}{}\label{classns3_1_1dsr_1_1DsrRouting_a95d4ab6177fb07d4791a2ed82cd4a2bb}


Promiscuous receive data packets destined to some other node. 


\begin{DoxyParams}{Parameters}
{\em device} & The network device \\
\hline
{\em packet} & Data packet we just received \\
\hline
{\em protocol} & The protocol we receive, need to verify it is dsr protocol \\
\hline
{\em from} & The from address we received the packet \\
\hline
{\em to} & The address this packet is destined for \\
\hline
{\em packet\+Type} & The dsr packet type, 0 is for control packet, 1 for data packet \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the packet was processed, false otherwise 
\end{DoxyReturn}
This is the ip address we just received data packet from

Remember this is the entry for previous node

Get the previous node\textquotesingle{}s maintenance buffer and passive ack 
\begin{DoxyCode}
1045 \{
1046 
1047   \textcolor{keywordflow}{if} (protocol != \hyperlink{classns3_1_1Ipv4L3Protocol_a0146bc84815b7b73adb9c62cdafc9442}{Ipv4L3Protocol::PROT\_NUMBER})
1048     \{
1049       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1050     \}
1051   \textcolor{comment}{// Remove the ipv4 header here}
1052   Ptr<Packet> pktMinusIpHdr = packet->Copy ();
1053   Ipv4Header ipv4Header;
1054   pktMinusIpHdr->RemoveHeader(ipv4Header);
1055 
1056   \textcolor{keywordflow}{if} (ipv4Header.GetProtocol () != \hyperlink{classns3_1_1dsr_1_1DsrRouting_a66248f69fcf97af91d6fe17d70617cc9}{DsrRouting::PROT\_NUMBER})
1057     \{
1058       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1059     \}
1060   \textcolor{comment}{// Remove the dsr routing header here}
1061   Ptr<Packet> pktMinusDsrHdr = pktMinusIpHdr->Copy ();
1062   DsrRoutingHeader dsrRouting;
1063   pktMinusDsrHdr->RemoveHeader (dsrRouting);
1064 
1065   \textcolor{comment}{/*}
1066 \textcolor{comment}{   * Message type 2 means the data packet, we will further process the data}
1067 \textcolor{comment}{   * packet for delivery notification, safely ignore control packet}
1068 \textcolor{comment}{   * Another check here is our own address, if this is the data destinated for us,}
1069 \textcolor{comment}{   * process it further, otherwise, just ignore it}
1070 \textcolor{comment}{   */}
1071   Ipv4Address ourAddress = \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa42c1b9ee27c8168a2141d3d032006c3}{m\_ipv4}->GetAddress (1, 0).GetLocal ();
1072   \textcolor{comment}{// check if the message type is 2 and if the ipv4 address matches}
1073   \textcolor{keywordflow}{if} (dsrRouting.GetMessageType () == 2 && ourAddress == \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress})
1074     \{
1075       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"data packet receives "} << packet->GetUid ());
1076       Ipv4Address sourceIp = \hyperlink{classns3_1_1dsr_1_1DsrRouting_abaf6e655b3bf50d3002c3739409d23a6}{GetIPfromID} (dsrRouting.GetSourceId ());
1077       Ipv4Address destinationIp = \hyperlink{classns3_1_1dsr_1_1DsrRouting_abaf6e655b3bf50d3002c3739409d23a6}{GetIPfromID} ( dsrRouting.GetDestId ());
1079       Ipv4Address previousHop = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5914e79eec0e5e33be08f55321e8aaea}{GetIPfromMAC} (
      \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (\hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from}));
1080 
1081       Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = Create<Packet> ();
1082       \textcolor{comment}{// Here the segments left value need to plus one to check the earlier hop maintain buffer entry}
1083       DsrMaintainBuffEntry newEntry;
1084       newEntry.SetPacket (p);
1085       newEntry.SetSrc (sourceIp);
1086       newEntry.SetDst (destinationIp);
1088       newEntry.SetOurAdd (previousHop);
1089       newEntry.SetNextHop (ourAddress);
1091       Ptr<Node> node = \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa301f5bb9481fe5392297015328e6332}{GetNodeWithAddress} (previousHop);
1092       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The previous node "} << previousHop);
1093 
1094       Ptr<dsr::DsrRouting> dsr = node->GetObject<dsr::DsrRouting> ();
1095       dsr->CancelLinkPacketTimer (newEntry);
1096     \}
1097 
1098   \textcolor{comment}{// Receive only IP packets and packets destined for other hosts}
1099   \textcolor{keywordflow}{if} (packetType == \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2a60c00fab4286dd2903e2b197a9f8c6c8}{NetDevice::PACKET\_OTHERHOST})
1100     \{
1101       \textcolor{comment}{//just to minimize debug output}
1102       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from} << to << packetType << *pktMinusIpHdr);
1103 
1104       uint8\_t offset = dsrRouting.GetDsrOptionsOffset ();        \textcolor{comment}{// Get the offset for option header, 4
       bytes in this case}
1105       uint8\_t nextHeader = dsrRouting.GetNextHeader ();
1106       uint32\_t sourceId = dsrRouting.GetSourceId ();
1107       Ipv4Address source = \hyperlink{classns3_1_1dsr_1_1DsrRouting_abaf6e655b3bf50d3002c3739409d23a6}{GetIPfromID} (sourceId);
1108 
1109       \textcolor{comment}{// This packet is used to peek option type}
1110       pktMinusIpHdr->RemoveAtStart (offset);
1111       \textcolor{comment}{/*}
1112 \textcolor{comment}{       * Peek data to get the option type as well as length and segmentsLeft field}
1113 \textcolor{comment}{       */}
1114       uint32\_t size = pktMinusIpHdr->GetSize ();
1115       uint8\_t *\hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data} = \textcolor{keyword}{new} uint8\_t[size];
1116       pktMinusIpHdr->CopyData (data, size);
1117       uint8\_t optionType = 0;
1118       optionType = *(\hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data});
1119 
1120       Ptr<dsr::DsrOptions> dsrOption;
1121 
1122       \textcolor{keywordflow}{if} (optionType == 96)        \textcolor{comment}{// This is the source route option}
1123         \{
1124           Ipv4Address promiscSource = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5914e79eec0e5e33be08f55321e8aaea}{GetIPfromMAC} (
      \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (\hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from}));
1125           dsrOption = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5cdb4c336831a3158c6ba12d226a198e}{GetOption} (optionType);       \textcolor{comment}{// Get the relative DSR option and demux to
       the process function}
1126           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds () <<
1127                         \textcolor{stringliteral}{" DSR node "} << \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress} <<
1128                         \textcolor{stringliteral}{" overhearing packet PID: "} << pktMinusIpHdr->GetUid () <<
1129                         \textcolor{stringliteral}{" from "} << promiscSource <<
1130                         \textcolor{stringliteral}{" to "} << \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5914e79eec0e5e33be08f55321e8aaea}{GetIPfromMAC} (
      \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (to)) <<
1131                         \textcolor{stringliteral}{" with source IP "} << ipv4Header.GetSource () <<
1132                         \textcolor{stringliteral}{" and destination IP "} << ipv4Header.GetDestination () <<
1133                         \textcolor{stringliteral}{" and packet : "} << *pktMinusDsrHdr);
1134 
1135           \textcolor{keywordtype}{bool} isPromisc = \textcolor{keyword}{true};                     \textcolor{comment}{// Set the boolean value isPromisc as true}
1136           dsrOption->Process (pktMinusIpHdr, pktMinusDsrHdr, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, source, ipv4Header
      , nextHeader, isPromisc, promiscSource);
1137           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1138 
1139         \}
1140     \}
1141   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1142 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 60




Here is the caller graph for this function\+:
% FIG 61


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Receive@{Receive}}
\index{Receive@{Receive}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Receive(\+Ptr$<$ Packet $>$ p, Ipv4\+Header const \&header, Ptr$<$ Ipv4\+Interface $>$ incoming\+Interface)}{Receive(Ptr< Packet > p, Ipv4Header const &header, Ptr< Ipv4Interface > incomingInterface)}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Ip\+L4\+Protocol\+::\+Rx\+Status} ns3\+::dsr\+::\+Dsr\+Routing\+::\+Receive (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{{\bf Ipv4\+Header} const \&}]{header, }
\item[{{\bf Ptr}$<$ {\bf Ipv4\+Interface} $>$}]{incoming\+Interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a4908cdae502d8bdca8a244d4420311e6}{}\label{classns3_1_1dsr_1_1DsrRouting_a4908cdae502d8bdca8a244d4420311e6}

\begin{DoxyParams}{Parameters}
{\em p} & packet to forward up \\
\hline
{\em header} & I\+Pv4 \hyperlink{classns3_1_1Header}{Header} information \\
\hline
{\em incoming\+Interface} & the \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} on which the packet arrived \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
receive status
\end{DoxyReturn}
Called from lower-\/level layers to send the packet up in the stack. this is just here for the sake of passing in the promisc source 

Implements \hyperlink{classns3_1_1IpL4Protocol_ad184969a1d9fd630f09e61d15ccad19d}{ns3\+::\+Ip\+L4\+Protocol}.


\begin{DoxyCode}
3306 \{
3307   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << p << ip << incomingInterface);
3308 
3309   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Our own IP address "} << \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress} << \textcolor{stringliteral}{" The incoming interface
       address "} << incomingInterface);
3310   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac27df0103a40973f0a3f78af0092c60d}{m\_node} = \hyperlink{classns3_1_1dsr_1_1DsrRouting_af1ef6f867481d19a85863a75a3e72e5a}{GetNode} ();                        \textcolor{comment}{// Get the node}
3311   Ptr<Packet> packet = p->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} ();            \textcolor{comment}{// Save a copy of the received packet}
3312   \textcolor{comment}{/*}
3313 \textcolor{comment}{   * When forwarding or local deliver packets, this one should be used always!!}
3314 \textcolor{comment}{   */}
3315   DsrRoutingHeader dsrRoutingHeader;
3316   packet->\hyperlink{classns3_1_1Packet_a0961eccf975d75f902d40956c93ba63e}{RemoveHeader} (dsrRoutingHeader);          \textcolor{comment}{// Remove the DSR header in whole}
3317   Ptr<Packet> copy = packet->Copy ();
3318 
3319   uint8\_t protocol = dsrRoutingHeader.GetNextHeader ();
3320   uint32\_t sourceId = dsrRoutingHeader.GetSourceId ();
3321   Ipv4Address source = \hyperlink{classns3_1_1dsr_1_1DsrRouting_abaf6e655b3bf50d3002c3739409d23a6}{GetIPfromID} (sourceId);
3322   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"The source address "} << source << \textcolor{stringliteral}{" with source id "} << sourceId);
3323   \textcolor{comment}{/*}
3324 \textcolor{comment}{   * Get the IP source and destination address}
3325 \textcolor{comment}{   */}
3326   Ipv4Address src = ip.GetSource ();
3327 
3328   \textcolor{keywordtype}{bool} isPromisc = \textcolor{keyword}{false};
3329   uint32\_t offset = dsrRoutingHeader.GetDsrOptionsOffset ();        \textcolor{comment}{// Get the offset for option header, 8
       bytes in this case}
3330 
3331   \textcolor{comment}{// This packet is used to peek option type}
3332   p->\hyperlink{classns3_1_1Packet_a78aa207e7921dd2f9f7e0d0b7a1c730a}{RemoveAtStart} (offset);
3333 
3334   Ptr<dsr::DsrOptions> dsrOption;
3335   DsrOptionHeader dsrOptionHeader;
3336   \textcolor{comment}{/*}
3337 \textcolor{comment}{   * Peek data to get the option type as well as length and segmentsLeft field}
3338 \textcolor{comment}{   */}
3339   uint32\_t size = p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ();
3340   uint8\_t *\hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data} = \textcolor{keyword}{new} uint8\_t[size];
3341   p->\hyperlink{classns3_1_1Packet_a5a6d304b9e0d90733919ffe224b98f0d}{CopyData} (data, size);
3342 
3343   uint8\_t optionType = 0;
3344   uint8\_t optionLength = 0;
3345   uint8\_t segmentsLeft = 0;
3346 
3347   optionType = *(\hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data});
3348   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"The option type value "} << (uint32\_t)optionType << \textcolor{stringliteral}{" with packet id "} << p->
      \hyperlink{classns3_1_1Packet_a1f212c825b50e54d94f5b9ae99592e6a}{GetUid}());
3349   dsrOption = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5cdb4c336831a3158c6ba12d226a198e}{GetOption} (optionType);       \textcolor{comment}{// Get the relative dsr option and demux to the
       process function}
3350   Ipv4Address promiscSource;      
3351   \textcolor{keywordflow}{if} (optionType == 1)        \textcolor{comment}{// This is the request option}
3352     \{
3353       BlackList *blackList = \hyperlink{classns3_1_1dsr_1_1DsrRouting_ae9ec27743735fa2d59cc5190961d1942}{m\_rreqTable}->FindUnidirectional (src);
3354       \textcolor{keywordflow}{if} (blackList)
3355         \{
3356           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Discard this packet due to unidirectional link"});
3357           \hyperlink{classns3_1_1dsr_1_1DsrRouting_aacee2c8437c0b61579cfa7a420423e03}{m\_dropTrace} (p);
3358         \}
3359 
3360       dsrOption = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5cdb4c336831a3158c6ba12d226a198e}{GetOption} (optionType);
3361       optionLength = dsrOption->Process (p, packet, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, source, ip, protocol, 
      isPromisc, promiscSource);
3362 
3363       \textcolor{keywordflow}{if} (optionLength == 0)
3364         \{
3365           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Discard this packet"});
3366           \hyperlink{classns3_1_1dsr_1_1DsrRouting_aacee2c8437c0b61579cfa7a420423e03}{m\_dropTrace} (p);
3367         \}
3368     \}
3369   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (optionType == 2)
3370     \{
3371       dsrOption = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5cdb4c336831a3158c6ba12d226a198e}{GetOption} (optionType);
3372       optionLength = dsrOption->Process (p, packet, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, source, ip, protocol, 
      isPromisc, promiscSource);
3373 
3374       \textcolor{keywordflow}{if} (optionLength == 0)
3375         \{
3376           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Discard this packet"});
3377           \hyperlink{classns3_1_1dsr_1_1DsrRouting_aacee2c8437c0b61579cfa7a420423e03}{m\_dropTrace} (p);
3378         \}
3379     \}
3380 
3381   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (optionType == 32)       \textcolor{comment}{// This is the ACK option}
3382     \{
3383       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"This is the ack option"});
3384       dsrOption = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5cdb4c336831a3158c6ba12d226a198e}{GetOption} (optionType);
3385       optionLength = dsrOption->Process (p, packet, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, source, ip, protocol, 
      isPromisc, promiscSource);
3386 
3387       \textcolor{keywordflow}{if} (optionLength == 0)
3388         \{
3389           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Discard this packet"});
3390           \hyperlink{classns3_1_1dsr_1_1DsrRouting_aacee2c8437c0b61579cfa7a420423e03}{m\_dropTrace} (p);
3391         \}
3392     \}
3393 
3394   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (optionType == 3)       \textcolor{comment}{// This is a route error header}
3395     \{
3396       \textcolor{comment}{// populate this route error}
3397       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"The option type value "} << (uint32\_t)optionType);
3398 
3399       dsrOption = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5cdb4c336831a3158c6ba12d226a198e}{GetOption} (optionType);
3400       optionLength = dsrOption->Process (p, packet, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, source, ip, protocol, 
      isPromisc, promiscSource);
3401 
3402       \textcolor{keywordflow}{if} (optionLength == 0)
3403         \{
3404           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Discard this packet"});
3405           \hyperlink{classns3_1_1dsr_1_1DsrRouting_aacee2c8437c0b61579cfa7a420423e03}{m\_dropTrace} (p);
3406         \}
3407       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"The option Length "} << (uint32\_t)optionLength);
3408     \}
3409 
3410   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (optionType == 96)       \textcolor{comment}{// This is the source route option}
3411     \{
3412       dsrOption = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5cdb4c336831a3158c6ba12d226a198e}{GetOption} (optionType);
3413       optionLength = dsrOption->Process (p, packet, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, source, ip, protocol, 
      isPromisc, promiscSource);
3414       segmentsLeft = *(data + 3);
3415       \textcolor{keywordflow}{if} (optionLength == 0)
3416         \{
3417           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Discard this packet"});
3418           \hyperlink{classns3_1_1dsr_1_1DsrRouting_aacee2c8437c0b61579cfa7a420423e03}{m\_dropTrace} (p);
3419         \}
3420       \textcolor{keywordflow}{else}
3421         \{
3422           \textcolor{keywordflow}{if} (segmentsLeft == 0)
3423             \{
3424               \textcolor{comment}{// / Get the next header}
3425               uint8\_t nextHeader = dsrRoutingHeader.GetNextHeader ();
3426               Ptr<Ipv4L3Protocol> l3proto = \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac27df0103a40973f0a3f78af0092c60d}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv4L3Protocol> ();
3427               Ptr<IpL4Protocol> nextProto = l3proto->GetProtocol (nextHeader);
3428               \textcolor{keywordflow}{if} (nextProto != 0)
3429                 \{
3430                   \textcolor{comment}{// we need to make a copy in the unlikely event we hit the}
3431                   \textcolor{comment}{// RX\_ENDPOINT\_UNREACH code path}
3432                   \textcolor{comment}{// Here we can use the packet that has been get off whole DSR header}
3433                   \textcolor{keyword}{enum} \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80e}{IpL4Protocol::RxStatus} status =
3434                     nextProto->Receive (copy, ip, incomingInterface);
3435                   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The receive status "} << status);
3436                   \textcolor{keywordflow}{switch} (status)
3437                     \{
3438                     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80eabd979bce2f3b22521c81c4115c66317e}{IpL4Protocol::RX\_OK}:
3439                     \textcolor{comment}{// fall through}
3440                     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80eac7f4577d3ab1a219d6cb2b6964c49afd}{IpL4Protocol::RX\_ENDPOINT\_CLOSED}:
3441                     \textcolor{comment}{// fall through}
3442                     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80eaba0111c02656760e18ca30479e297b07}{IpL4Protocol::RX\_CSUM\_FAILED}:
3443                       \textcolor{keywordflow}{break};
3444                     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80ea00e3d2a534b8bd353395254c0735948b}{IpL4Protocol::RX\_ENDPOINT\_UNREACH}:
3445                       \textcolor{keywordflow}{if} (ip.GetDestination ().IsBroadcast () == \textcolor{keyword}{true}
3446                           || ip.GetDestination ().IsMulticast () == \textcolor{keyword}{true})
3447                         \{
3448                           \textcolor{keywordflow}{break};       \textcolor{comment}{// Do not reply to broadcast or multicast}
3449                         \}
3450                       \textcolor{comment}{// Another case to suppress ICMP is a subnet-directed broadcast}
3451                     \}
3452                   \textcolor{keywordflow}{return} status;
3453                 \}
3454               \textcolor{keywordflow}{else}
3455                 \{
3456                   \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Should not have 0 next protocol value"});
3457                 \}
3458             \}
3459           \textcolor{keywordflow}{else}
3460             \{
3461               \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"This is not the final destination, the packet has already been
       forward to next hop"});
3462             \}
3463         \}
3464     \}
3465   \textcolor{keywordflow}{else}
3466     \{
3467       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Unknown Option. Drop!"});
3468       \textcolor{comment}{/*}
3469 \textcolor{comment}{       * Initialize the salvage value to 0}
3470 \textcolor{comment}{       */}
3471       uint8\_t salvage = 0;
3472 
3473       DsrOptionRerrUnsupportHeader rerrUnsupportHeader;
3474       rerrUnsupportHeader.SetErrorType (3);               \textcolor{comment}{// The error type 3 means Option not supported}
3475       rerrUnsupportHeader.SetErrorSrc (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress});       \textcolor{comment}{// The error source address is
       our own address}
3476       rerrUnsupportHeader.SetUnsupported (optionType);       \textcolor{comment}{// The unsupported option type number}
3477       rerrUnsupportHeader.SetErrorDst (src);              \textcolor{comment}{// Error destination address is the destination
       of the data packet}
3478       rerrUnsupportHeader.SetSalvage (salvage);           \textcolor{comment}{// Set the value about whether to salvage a
       packet or not}
3479 
3480       \textcolor{comment}{/*}
3481 \textcolor{comment}{       * The unknow option error is not supported currently in this implementation, and it's also not
       likely to}
3482 \textcolor{comment}{       * happen in simulations}
3483 \textcolor{comment}{       */}
3484 \textcolor{comment}{//            SendError (rerrUnsupportHeader, 0, protocol); // Send the error packet}
3485     \}
3486   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80eabd979bce2f3b22521c81c4115c66317e}{IpL4Protocol::RX\_OK};
3487 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 62


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Receive@{Receive}}
\index{Receive@{Receive}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Receive(\+Ptr$<$ Packet $>$ p, Ipv6\+Header const \&header, Ptr$<$ Ipv6\+Interface $>$ incoming\+Interface)}{Receive(Ptr< Packet > p, Ipv6Header const &header, Ptr< Ipv6Interface > incomingInterface)}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Ip\+L4\+Protocol\+::\+Rx\+Status} ns3\+::dsr\+::\+Dsr\+Routing\+::\+Receive (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{{\bf Ipv6\+Header} const \&}]{header, }
\item[{{\bf Ptr}$<$ {\bf Ipv6\+Interface} $>$}]{incoming\+Interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_aa0fd777071685501dfcf74f4a5102608}{}\label{classns3_1_1dsr_1_1DsrRouting_aa0fd777071685501dfcf74f4a5102608}

\begin{DoxyParams}{Parameters}
{\em p} & packet to forward up \\
\hline
{\em header} & I\+Pv6 \hyperlink{classns3_1_1Header}{Header} information \\
\hline
{\em incoming\+Interface} & the \hyperlink{classns3_1_1Ipv6Interface}{Ipv6\+Interface} on which the packet arrived \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
receive status
\end{DoxyReturn}
Called from lower-\/level layers to send the packet up in the stack. Not implemented (I\+Pv6). 

Implements \hyperlink{classns3_1_1IpL4Protocol_a1722da521b414c28875cb2a4f4aaf242}{ns3\+::\+Ip\+L4\+Protocol}.


\begin{DoxyCode}
3493 \{
3494   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << p << ip.GetSourceAddress () << ip.GetDestinationAddress () << 
      incomingInterface);
3495   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80ea00e3d2a534b8bd353395254c0735948b}{IpL4Protocol::RX\_ENDPOINT\_UNREACH};
3496 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 63


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Route\+Request\+Timer\+Expire@{Route\+Request\+Timer\+Expire}}
\index{Route\+Request\+Timer\+Expire@{Route\+Request\+Timer\+Expire}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Route\+Request\+Timer\+Expire(\+Ptr$<$ Packet $>$ packet, std\+::vector$<$ Ipv4\+Address $>$ address, uint32\+\_\+t request\+Id, uint8\+\_\+t protocol)}{RouteRequestTimerExpire(Ptr< Packet > packet, std::vector< Ipv4Address > address, uint32_t requestId, uint8_t protocol)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Route\+Request\+Timer\+Expire (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{std\+::vector$<$ {\bf Ipv4\+Address} $>$}]{address, }
\item[{uint32\+\_\+t}]{request\+Id, }
\item[{uint8\+\_\+t}]{protocol}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_aa839b89cdf568048c4d09941b59e46d4}{}\label{classns3_1_1dsr_1_1DsrRouting_aa839b89cdf568048c4d09941b59e46d4}
Handle route discovery timer


\begin{DoxyParams}{Parameters}
{\em packet} & the original packet \\
\hline
{\em address} & List of I\+Pv4 addresses \\
\hline
{\em request\+Id} & Unique request ID \\
\hline
{\em protocol} & the protocol number \\
\hline
\end{DoxyParams}
Set the salvage value to 0

Try to send out data packet from the send buffer if found 
\begin{DoxyCode}
3018 \{
3019   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << requestId << (uint32\_t)protocol);
3020   \textcolor{comment}{// Get a clean packet without dsr header}
3021   Ptr<Packet> dsrP = packet->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} ();
3022   DsrRoutingHeader dsrRoutingHeader;
3023   dsrP->\hyperlink{classns3_1_1Packet_a0961eccf975d75f902d40956c93ba63e}{RemoveHeader} (dsrRoutingHeader);          \textcolor{comment}{// Remove the dsr header in whole}
3024 
3025   Ipv4Address source = address[0];
3026   Ipv4Address dst = address[1];
3027   DsrRouteCacheEntry toDst;
3028   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->LookupRoute (dst, toDst))
3029     \{
3030       \textcolor{comment}{/*}
3031 \textcolor{comment}{       * Found a route the dst, construct the source route option header}
3032 \textcolor{comment}{       */}
3033       DsrOptionSRHeader sourceRoute;
3034       std::vector<Ipv4Address> ip = toDst.GetVector ();
3035       sourceRoute.SetNodesAddress (ip);
3036       \textcolor{comment}{// When we found the route and use it, UseExtends for the link cache}
3037       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->IsLinkCache ())
3038         \{
3039           \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->UseExtends (ip);
3040         \}
3041       sourceRoute.SetSegmentsLeft ((ip.size () - 2));
3043       sourceRoute.SetSalvage (0);
3044       Ipv4Address nextHop = \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa1b16658c14499af76ca7dd69c034f22}{SearchNextHop} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, ip);       \textcolor{comment}{// Get the
       next hop address}
3045       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"The nextHop address is "} << nextHop);
3046       \textcolor{keywordflow}{if} (nextHop == \textcolor{stringliteral}{"0.0.0.0"})
3047         \{
3048           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Error next hop address"});
3049           \hyperlink{classns3_1_1dsr_1_1DsrRouting_ae70ab39db551d1d81afc081196f78017}{PacketNewRoute} (dsrP, source, dst, protocol);
3050           \textcolor{keywordflow}{return};
3051         \}
3052       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a8a726fb52558a1a8172a5bd5b8cdb072}{SetRoute} (nextHop, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress});
3053       \hyperlink{classns3_1_1dsr_1_1DsrRouting_ad489fa602b093c8336cf4143ed60e429}{CancelRreqTimer} (dst, \textcolor{keyword}{true});
3055       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a887ae39d7060171753c0605d5c120549}{m\_sendBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrSendBuffer_a0ecf75786eef7193fa5a5d84b2b7a1f0}{GetSize} () != 0 && \hyperlink{classns3_1_1dsr_1_1DsrRouting_a887ae39d7060171753c0605d5c120549}{m\_sendBuffer}.
      \hyperlink{classns3_1_1dsr_1_1DsrSendBuffer_acf27d9e92a1d1960b9094c4108724a53}{Find} (dst))
3056         \{
3057           \hyperlink{classns3_1_1dsr_1_1DsrRouting_a1a862a16f3a5527f9425763864ac3e80}{SendPacketFromBuffer} (sourceRoute, nextHop, protocol);
3058         \}
3059       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Route to "} << dst << \textcolor{stringliteral}{" found"});
3060       \textcolor{keywordflow}{return};
3061     \}
3062   \textcolor{comment}{/*}
3063 \textcolor{comment}{   *  If a route discovery has been attempted m\_rreqRetries times at the maximum TTL without}
3064 \textcolor{comment}{   *  receiving any RREP, all data packets destined for the corresponding destination SHOULD be}
3065 \textcolor{comment}{   *  dropped from the buffer and a Destination Unreachable message SHOULD be delivered to the application.}
3066 \textcolor{comment}{   */}
3067   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"The new request count for "} << dst << \textcolor{stringliteral}{" is "} << 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_ae9ec27743735fa2d59cc5190961d1942}{m\_rreqTable}->GetRreqCnt (dst) << \textcolor{stringliteral}{" the max "} << \hyperlink{classns3_1_1dsr_1_1DsrRouting_a88bbff666cd3bb5bad099587a967d547}{m\_rreqRetries});
3068   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ae9ec27743735fa2d59cc5190961d1942}{m\_rreqTable}->GetRreqCnt (dst) >= \hyperlink{classns3_1_1dsr_1_1DsrRouting_a88bbff666cd3bb5bad099587a967d547}{m\_rreqRetries})
3069     \{
3070       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Route discovery to "} << dst << \textcolor{stringliteral}{" has been attempted "} << 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a88bbff666cd3bb5bad099587a967d547}{m\_rreqRetries} << \textcolor{stringliteral}{" times"});
3071       \hyperlink{classns3_1_1dsr_1_1DsrRouting_ad489fa602b093c8336cf4143ed60e429}{CancelRreqTimer} (dst, \textcolor{keyword}{true});
3072       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Route not found. Drop packet with dst "} << dst);
3073       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a887ae39d7060171753c0605d5c120549}{m\_sendBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrSendBuffer_af20f9ff303a1099f3568254d4c58e829}{DropPacketWithDst} (dst);
3074     \}
3075   \textcolor{keywordflow}{else}
3076     \{
3077       SocketIpTtlTag tag;
3078       tag.SetTtl ((uint8\_t)\hyperlink{classns3_1_1dsr_1_1DsrRouting_acf9cc5a2ae446403b8b57f3340fac178}{m\_discoveryHopLimit});
3079       Ptr<Packet> propPacket = packet->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} ();
3080       propPacket->\hyperlink{classns3_1_1Packet_a7400b8655852f5271c5957250d0141af}{AddPacketTag} (tag);
3081       \textcolor{comment}{// Increase the request count}
3082       \hyperlink{classns3_1_1dsr_1_1DsrRouting_ae9ec27743735fa2d59cc5190961d1942}{m\_rreqTable}->FindAndUpdate (dst);
3083       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a21496638c09e75ea310e876135d0bf64}{SendRequest} (propPacket, source);
3084       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Check the route request entry "} << source << \textcolor{stringliteral}{" "} << dst);
3085       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a056b38f3af6c2992be89b8fc5cb15448}{ScheduleRreqRetry} (packet, address, \textcolor{keyword}{false}, requestId, protocol);
3086     \}
3087   \textcolor{keywordflow}{return};
3088 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 64




Here is the caller graph for this function\+:
% FIG 65


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Salvage\+Packet@{Salvage\+Packet}}
\index{Salvage\+Packet@{Salvage\+Packet}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Salvage\+Packet(\+Ptr$<$ const Packet $>$ packet, Ipv4\+Address source, Ipv4\+Address dst, uint8\+\_\+t protocol)}{SalvagePacket(Ptr< const Packet > packet, Ipv4Address source, Ipv4Address dst, uint8_t protocol)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Salvage\+Packet (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{packet, }
\item[{{\bf Ipv4\+Address}}]{source, }
\item[{{\bf Ipv4\+Address}}]{dst, }
\item[{uint8\+\_\+t}]{protocol}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a83dd51056e4e48ad538ff41fda129272}{}\label{classns3_1_1dsr_1_1DsrRouting_a83dd51056e4e48ad538ff41fda129272}


Salvage the packet which has been transmitted for 3 times. 

When found a route and use it, Use\+Extends to the link cache

\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000027}{Todo}]New \hyperlink{classns3_1_1dsr_1_1DsrNetworkQueueEntry}{Dsr\+Network\+Queue\+Entry} \end{DoxyRefDesc}

\begin{DoxyCode}
2267 \{
2268   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << source << dst << (uint32\_t)protocol);
2269   \textcolor{comment}{// Create two copies of packet}
2270   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = packet->Copy ();
2271   Ptr<Packet> newPacket = packet->Copy ();
2272   \textcolor{comment}{// Remove the routing header in a whole to get a clean packet}
2273   DsrRoutingHeader dsrRoutingHeader;
2274   p->RemoveHeader (dsrRoutingHeader);
2275   \textcolor{comment}{// Remove offset of dsr routing header}
2276   uint8\_t offset = dsrRoutingHeader.GetDsrOptionsOffset ();
2277   newPacket->RemoveAtStart (offset);
2278 
2279   \textcolor{comment}{// Get the number of routers' address field}
2280   uint8\_t buf[2];
2281   newPacket->CopyData (buf, \textcolor{keyword}{sizeof}(buf));
2282   uint8\_t numberAddress = (buf[1] - 2) / 4;
2283 
2284   DsrOptionSRHeader sourceRoute;
2285   sourceRoute.SetNumberAddress (numberAddress);
2286   newPacket->RemoveHeader (sourceRoute);
2287   uint8\_t salvage = sourceRoute.GetSalvage ();
2288   \textcolor{comment}{/*}
2289 \textcolor{comment}{   * Look in the route cache for other routes for this destination}
2290 \textcolor{comment}{   */}
2291   DsrRouteCacheEntry toDst;
2292   \textcolor{keywordtype}{bool} findRoute = \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->LookupRoute (dst, toDst);
2293   \textcolor{keywordflow}{if} (findRoute && (salvage < \hyperlink{classns3_1_1dsr_1_1DsrRouting_a89f7e66d9f1bd83433b004876acf4a45}{m\_maxSalvageCount}))
2294     \{
2295       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"We have found a route for the packet"});
2296       DsrRoutingHeader newDsrRoutingHeader;
2297       newDsrRoutingHeader.SetNextHeader (protocol);
2298       newDsrRoutingHeader.SetMessageType (2);
2299       newDsrRoutingHeader.SetSourceId (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4593e50d5f36e9b9b013fe0422067c44}{GetIDfromIP} (source));
2300       newDsrRoutingHeader.SetDestId (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4593e50d5f36e9b9b013fe0422067c44}{GetIDfromIP} (dst));
2301 
2302       std::vector<Ipv4Address> nodeList = toDst.GetVector ();     \textcolor{comment}{// Get the route from the route entry we
       found}
2303       Ipv4Address nextHop = \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa1b16658c14499af76ca7dd69c034f22}{SearchNextHop} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, nodeList);      \textcolor{comment}{// Get
       the next hop address for the route}
2304       \textcolor{keywordflow}{if} (nextHop == \textcolor{stringliteral}{"0.0.0.0"})
2305         \{
2306           \hyperlink{classns3_1_1dsr_1_1DsrRouting_ae70ab39db551d1d81afc081196f78017}{PacketNewRoute} (p, source, dst, protocol);
2307           \textcolor{keywordflow}{return};
2308         \}
2309       \textcolor{comment}{// Increase the salvage count by 1}
2310       salvage++;
2311       DsrOptionSRHeader sourceRoute;
2312       sourceRoute.SetSalvage (salvage);
2313       sourceRoute.SetNodesAddress (nodeList);     \textcolor{comment}{// Save the whole route in the source route header of the
       packet}
2314       sourceRoute.SetSegmentsLeft ((nodeList.size () - 2));     \textcolor{comment}{// The segmentsLeft field will indicate the
       hops to go}
2316 \textcolor{comment}{}      \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->IsLinkCache ())
2317         \{
2318           \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->UseExtends (nodeList);
2319         \}
2320       uint8\_t length = sourceRoute.GetLength ();
2321       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"length of source route header "} << (uint32\_t)(sourceRoute.GetLength ()));
2322       newDsrRoutingHeader.SetPayloadLength (uint16\_t (length) + 2);
2323       newDsrRoutingHeader.AddDsrOption (sourceRoute);
2324       p->AddHeader (newDsrRoutingHeader);
2325 
2326       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a8a726fb52558a1a8172a5bd5b8cdb072}{SetRoute} (nextHop, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress});
2327       Ptr<NetDevice> dev = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a0443d48172143cafa1d0491e35f3fbaf}{m\_ip}->GetNetDevice (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a0443d48172143cafa1d0491e35f3fbaf}{m\_ip}->GetInterfaceForAddress (
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}));
2328       \hyperlink{classns3_1_1dsr_1_1DsrRouting_ab4c16d56044159989e52ad33c0afed2b}{m\_ipv4Route}->SetOutputDevice (dev);
2329 
2330       \textcolor{comment}{// Send out the data packet}
2331       uint32\_t priority = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a67d111b0188b6e2210d1b4782820f8e3}{GetPriority} (\hyperlink{namespacens3_1_1dsr_a7c80bcec67d78dc149a0e503014d07c5ad29c69f5a6ad5fbb5eec5524f553e315}{DSR\_DATA\_PACKET});
2332       std::map<uint32\_t, Ptr<dsr::DsrNetworkQueue> >::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4606c3dfb1099afbfe1e7cd1d1c3c8ee}{m\_priorityQueue}.find (priority);
2333       Ptr<dsr::DsrNetworkQueue> dsrNetworkQueue = i->second;
2334       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Will be inserting into priority queue "} << dsrNetworkQueue << \textcolor{stringliteral}{" number: "} 
      << priority);
2335 
2336       \textcolor{comment}{//m\_downTarget (p, m\_mainAddress, nextHop, GetProtocolNumber (), m\_ipv4Route);}
2337 
2339      DsrNetworkQueueEntry newEntry (p, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, nextHop, 
      \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} (), \hyperlink{classns3_1_1dsr_1_1DsrRouting_ab4c16d56044159989e52ad33c0afed2b}{m\_ipv4Route});
2340 
2341      \textcolor{keywordflow}{if} (dsrNetworkQueue->Enqueue (newEntry))
2342        \{
2343          \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa518edb174bccce1062304404424c6e0}{Scheduler} (priority);
2344        \}
2345      \textcolor{keywordflow}{else}
2346        \{
2347          \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Packet dropped as dsr network queue is full"});
2348        \}
2349 
2350       \textcolor{comment}{/*}
2351 \textcolor{comment}{       * Mark the next hop address in blacklist}
2352 \textcolor{comment}{       */}
2353 \textcolor{comment}{//      NS\_LOG\_DEBUG ("Save the next hop node in blacklist");}
2354 \textcolor{comment}{//      m\_rreqTable->MarkLinkAsUnidirectional (nextHop, m\_blacklistTimeout);}
2355     \}
2356   \textcolor{keywordflow}{else}
2357     \{
2358       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Will not salvage this packet, silently drop"});
2359     \}
2360 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 66




Here is the caller graph for this function\+:
% FIG 67


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Schedule\+Cached\+Reply@{Schedule\+Cached\+Reply}}
\index{Schedule\+Cached\+Reply@{Schedule\+Cached\+Reply}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Schedule\+Cached\+Reply(\+Ptr$<$ Packet $>$ packet, Ipv4\+Address source, Ipv4\+Address destination, Ptr$<$ Ipv4\+Route $>$ route, double hops)}{ScheduleCachedReply(Ptr< Packet > packet, Ipv4Address source, Ipv4Address destination, Ptr< Ipv4Route > route, double hops)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Schedule\+Cached\+Reply (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Ipv4\+Address}}]{source, }
\item[{{\bf Ipv4\+Address}}]{destination, }
\item[{{\bf Ptr}$<$ {\bf Ipv4\+Route} $>$}]{route, }
\item[{double}]{hops}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_af078d9a9fe5a20264a93f481f6d0feb3}{}\label{classns3_1_1dsr_1_1DsrRouting_af078d9a9fe5a20264a93f481f6d0feb3}
Schedule the cached reply to a random start time to avoid possible route reply storm


\begin{DoxyParams}{Parameters}
{\em packet} & the original packet \\
\hline
{\em source} & I\+Pv4 address of the source (i.\+e. request originator) \\
\hline
{\em destination} & I\+Pv4 address of the destination \\
\hline
{\em route} & Route \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
3242 \{
3243   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << source << destination);
3244   \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (2 * \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4c406057009653878e8cdf3e3a7f2106}{m\_nodeTraversalTime} * (hops - 1 
      + \hyperlink{classns3_1_1dsr_1_1DsrRouting_a22a85b3510166ffdd451e4010f996f0f}{m\_uniformRandomVariable}->\hyperlink{classns3_1_1UniformRandomVariable_a03822d8c86ac51e9aa83bbc73041386b}{GetValue} (0,1))), &
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a69e03d265224fc60bf135b2496d97f04}{DsrRouting::SendReply}, \textcolor{keyword}{this}, packet, source, destination, route);
3245 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 68


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Schedule\+Initial\+Reply@{Schedule\+Initial\+Reply}}
\index{Schedule\+Initial\+Reply@{Schedule\+Initial\+Reply}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Schedule\+Initial\+Reply(\+Ptr$<$ Packet $>$ packet, Ipv4\+Address source, Ipv4\+Address next\+Hop, Ptr$<$ Ipv4\+Route $>$ route)}{ScheduleInitialReply(Ptr< Packet > packet, Ipv4Address source, Ipv4Address nextHop, Ptr< Ipv4Route > route)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Schedule\+Initial\+Reply (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Ipv4\+Address}}]{source, }
\item[{{\bf Ipv4\+Address}}]{next\+Hop, }
\item[{{\bf Ptr}$<$ {\bf Ipv4\+Route} $>$}]{route}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a9987b38297fb1a4f4e175d5b81853464}{}\label{classns3_1_1dsr_1_1DsrRouting_a9987b38297fb1a4f4e175d5b81853464}
this is a generating the initial route reply from the destination address, a random delay time \mbox{[}0, m\+\_\+broadcast\+Jitter\mbox{]} is used before unicasting back the route reply packet


\begin{DoxyParams}{Parameters}
{\em packet} & the original packet \\
\hline
{\em source} & I\+Pv4 address of the source (i.\+e. request originator) \\
\hline
{\em next\+Hop} & I\+Pv4 address of the next hop \\
\hline
{\em route} & Route \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
3230 \{
3231   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << source << nextHop);
3232   \hyperlink{classns3_1_1Simulator_a2219ee02c0647adc83d1c918c3256266}{Simulator::ScheduleNow} (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_a69e03d265224fc60bf135b2496d97f04}{DsrRouting::SendReply}, \textcolor{keyword}{this},
3233                           packet, source, nextHop, route);
3234 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 69


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Schedule\+Inter\+Request@{Schedule\+Inter\+Request}}
\index{Schedule\+Inter\+Request@{Schedule\+Inter\+Request}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Schedule\+Inter\+Request(\+Ptr$<$ Packet $>$ packet)}{ScheduleInterRequest(Ptr< Packet > packet)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Schedule\+Inter\+Request (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a03175efa8103d392d90298f2d8985a29}{}\label{classns3_1_1dsr_1_1DsrRouting_a03175efa8103d392d90298f2d8985a29}


Schedule the intermediate route request. 


\begin{DoxyParams}{Parameters}
{\em packet} & the original packet \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
3121 \{
3122   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet);
3123   \textcolor{comment}{/*}
3124 \textcolor{comment}{   * This is a forwarding case when sending route requests, a random delay time [0, m\_broadcastJitter]}
3125 \textcolor{comment}{   * used before forwarding as link-layer broadcast}
3126 \textcolor{comment}{   */}
3127   \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a22a85b3510166ffdd451e4010f996f0f}{m\_uniformRandomVariable}->\hyperlink{classns3_1_1RandomVariableStream_a66cd94e6305ce7f000f1a9ff0fcb9aef}{GetInteger} (0, 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_afb77e13fc791e5076ee1f8595b9c6617}{m\_broadcastJitter})), &\hyperlink{classns3_1_1dsr_1_1DsrRouting_a21496638c09e75ea310e876135d0bf64}{DsrRouting::SendRequest}, \textcolor{keyword}{this},
3128                        packet, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress});
3129 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 70


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Schedule\+Link\+Packet\+Retry@{Schedule\+Link\+Packet\+Retry}}
\index{Schedule\+Link\+Packet\+Retry@{Schedule\+Link\+Packet\+Retry}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Schedule\+Link\+Packet\+Retry(\+Dsr\+Maintain\+Buff\+Entry \&mb, uint8\+\_\+t protocol)}{ScheduleLinkPacketRetry(DsrMaintainBuffEntry &mb, uint8_t protocol)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Schedule\+Link\+Packet\+Retry (
\begin{DoxyParamCaption}
\item[{{\bf Dsr\+Maintain\+Buff\+Entry} \&}]{mb, }
\item[{uint8\+\_\+t}]{protocol}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a947d831bc0964240b1a41b3a09832eff}{}\label{classns3_1_1dsr_1_1DsrRouting_a947d831bc0964240b1a41b3a09832eff}


Schedule the packet retransmission based on link-\/layer acknowledgment. 


\begin{DoxyParams}{Parameters}
{\em mb} & maintainenace buffer entry \\
\hline
{\em protocol} & the protocol number \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2365 \{
2366   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << (uint32\_t) protocol);
2367 
2368   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = mb.GetPacket ()->Copy ();
2369   Ipv4Address source = mb.GetSrc ();
2370   Ipv4Address nextHop = mb.GetNextHop ();
2371 
2372   \textcolor{comment}{// Send the data packet out before schedule the next packet transmission}
2373   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a84a2caf24a41eef8993b64cb22874f95}{SendPacket} (p, source, nextHop, protocol);
2374 
2375   LinkKey linkKey;
2376   linkKey.m\_source = mb.GetSrc ();
2377   linkKey.m\_destination = mb.GetDst ();
2378   linkKey.m\_ourAdd = mb.GetOurAdd ();
2379   linkKey.m\_nextHop = mb.GetNextHop ();
2380 
2381   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ad532172035dbd4b038de0e94f4ce5ff6}{m\_linkAckTimer}.find (linkKey) == \hyperlink{classns3_1_1dsr_1_1DsrRouting_ad532172035dbd4b038de0e94f4ce5ff6}{m\_linkAckTimer}.end ())
2382     \{
2383       Timer timer (\hyperlink{classns3_1_1Timer_a816309b83cd2a35bea47d9bbc6bbf721a07a9dd5063b32fb6cf1f813c6ee7e28e}{Timer::CANCEL\_ON\_DESTROY});
2384       \hyperlink{classns3_1_1dsr_1_1DsrRouting_ad532172035dbd4b038de0e94f4ce5ff6}{m\_linkAckTimer}[linkKey] = timer;
2385     \}
2386   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ad532172035dbd4b038de0e94f4ce5ff6}{m\_linkAckTimer}[linkKey].SetFunction (&
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_ab0ce215bf5359f4d6d4541b8a479007c}{DsrRouting::LinkScheduleTimerExpire}, \textcolor{keyword}{this});
2387   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ad532172035dbd4b038de0e94f4ce5ff6}{m\_linkAckTimer}[linkKey].Remove ();
2388   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ad532172035dbd4b038de0e94f4ce5ff6}{m\_linkAckTimer}[linkKey].SetArguments (mb, protocol);
2389   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ad532172035dbd4b038de0e94f4ce5ff6}{m\_linkAckTimer}[linkKey].Schedule (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ace1671263c7f09cd2523f1c81dc41631}{m\_linkAckTimeout});
2390 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 71




Here is the caller graph for this function\+:
% FIG 72


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Schedule\+Network\+Packet\+Retry@{Schedule\+Network\+Packet\+Retry}}
\index{Schedule\+Network\+Packet\+Retry@{Schedule\+Network\+Packet\+Retry}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Schedule\+Network\+Packet\+Retry(\+Dsr\+Maintain\+Buff\+Entry \&mb, bool is\+First, uint8\+\_\+t protocol)}{ScheduleNetworkPacketRetry(DsrMaintainBuffEntry &mb, bool isFirst, uint8_t protocol)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Schedule\+Network\+Packet\+Retry (
\begin{DoxyParamCaption}
\item[{{\bf Dsr\+Maintain\+Buff\+Entry} \&}]{mb, }
\item[{bool}]{is\+First, }
\item[{uint8\+\_\+t}]{protocol}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a6a18c6baa374d5e6a68f8952d1afdb13}{}\label{classns3_1_1dsr_1_1DsrRouting_a6a18c6baa374d5e6a68f8952d1afdb13}


Schedule the packet retransmission based on network layer acknowledgment. 


\begin{DoxyParams}{Parameters}
{\em mb} & maintainenace buffer entry \\
\hline
{\em is\+First} & see if this is the first packet retry or not \\
\hline
{\em protocol} & the protocol number \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2427 \{
2428   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = Create<Packet> ();
2429   Ptr<Packet> dsrP = Create<Packet> ();
2430   \textcolor{comment}{// The new entry will be used for retransmission}
2431   NetworkKey networkKey;
2432   Ipv4Address nextHop = mb.GetNextHop ();
2433   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"is the first retry or not "} << isFirst);
2434   \textcolor{keywordflow}{if} (isFirst)
2435     \{
2436       \textcolor{comment}{// This is the very first network packet retry}
2437       p = mb.GetPacket ()->Copy ();
2438       \textcolor{comment}{// Here we add the ack request header to the data packet for network acknowledgement}
2439       uint16\_t ackId = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a8ce910f1c56dc238ff98117c784c4541}{AddAckReqHeader} (p, nextHop);
2440 
2441       Ipv4Address source = mb.GetSrc ();
2442       Ipv4Address nextHop = mb.GetNextHop ();
2443       \textcolor{comment}{// Send the data packet out before schedule the next packet transmission}
2444       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a84a2caf24a41eef8993b64cb22874f95}{SendPacket} (p, source, nextHop, protocol);
2445 
2446       dsrP = p->Copy ();
2447       DsrMaintainBuffEntry newEntry = mb;
2448       \textcolor{comment}{// The function AllEqual will find the exact entry and delete it if found}
2449       \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac9d28a64437fbe20a4228c9811f9fc27}{m\_maintainBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a2f553fb512d4aee9a538c799bc2d0f45}{AllEqual} (mb);
2450       newEntry.SetPacket (dsrP);
2451       newEntry.SetAckId (ackId);
2452       newEntry.SetExpireTime (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ac6b1dffa9665af0d6a71aa7b947962ee}{m\_maxMaintainTime});
2453 
2454       networkKey.m\_ackId = newEntry.GetAckId ();
2455       networkKey.m\_ourAdd = newEntry.GetOurAdd ();
2456       networkKey.m\_nextHop = newEntry.GetNextHop ();
2457       networkKey.m\_source = newEntry.GetSrc ();
2458       networkKey.m\_destination = newEntry.GetDst ();
2459 
2460       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5042f7e5df0470025fdb6023fcc24411}{m\_addressForwardCnt}[networkKey] = 0;
2461       \textcolor{keywordflow}{if} (! \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac9d28a64437fbe20a4228c9811f9fc27}{m\_maintainBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a8ec30b5b9b0f6af36e61867327a47717}{Enqueue} (newEntry))
2462         \{
2463           \hyperlink{group__logging_ga0261a8db1d4ac5f79417d117634fd455}{NS\_LOG\_ERROR} (\textcolor{stringliteral}{"Failed to enqueue packet retry"});
2464         \}
2465 
2466       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4a35b13cdca413ab5bc0b1b3b7b78907}{m\_addressForwardTimer}.find (networkKey) == 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4a35b13cdca413ab5bc0b1b3b7b78907}{m\_addressForwardTimer}.end ())
2467         \{
2468           Timer timer (\hyperlink{classns3_1_1Timer_a816309b83cd2a35bea47d9bbc6bbf721a07a9dd5063b32fb6cf1f813c6ee7e28e}{Timer::CANCEL\_ON\_DESTROY});
2469           \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4a35b13cdca413ab5bc0b1b3b7b78907}{m\_addressForwardTimer}[networkKey] = timer;
2470         \}
2471 
2472       \textcolor{comment}{// After m\_tryPassiveAcks, schedule the packet retransmission using network acknowledgment option}
2473       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4a35b13cdca413ab5bc0b1b3b7b78907}{m\_addressForwardTimer}[networkKey].SetFunction (&
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_aabcdf59bcb4907718986626a7a402dad}{DsrRouting::NetworkScheduleTimerExpire}, \textcolor{keyword}{this});
2474       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4a35b13cdca413ab5bc0b1b3b7b78907}{m\_addressForwardTimer}[networkKey].Remove ();
2475       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4a35b13cdca413ab5bc0b1b3b7b78907}{m\_addressForwardTimer}[networkKey].SetArguments (newEntry, protocol);
2476       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The packet retries time for "} << newEntry.GetAckId () << \textcolor{stringliteral}{" is "} << 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a02a55fe3b490af4dbd62953065d293a3}{m\_sendRetries}
2477                                                    << \textcolor{stringliteral}{" and the delay time is "} << 
      \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (2 * \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4c406057009653878e8cdf3e3a7f2106}{m\_nodeTraversalTime}).GetSeconds ());
2478       \textcolor{comment}{// Back-off mechanism}
2479       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4a35b13cdca413ab5bc0b1b3b7b78907}{m\_addressForwardTimer}[networkKey].Schedule (\hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (2 * 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4c406057009653878e8cdf3e3a7f2106}{m\_nodeTraversalTime}));
2480     \}
2481   \textcolor{keywordflow}{else}
2482     \{
2483       networkKey.m\_ackId = mb.GetAckId ();
2484       networkKey.m\_ourAdd = mb.GetOurAdd ();
2485       networkKey.m\_nextHop = mb.GetNextHop ();
2486       networkKey.m\_source = mb.GetSrc ();
2487       networkKey.m\_destination = mb.GetDst ();
2488       \textcolor{comment}{/*}
2489 \textcolor{comment}{       * Here we have found the entry for send retries, so we get the value and increase it by one}
2490 \textcolor{comment}{       */}
2491       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a02a55fe3b490af4dbd62953065d293a3}{m\_sendRetries} = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5042f7e5df0470025fdb6023fcc24411}{m\_addressForwardCnt}[networkKey];
2492       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The packet retry we have done "} << 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a02a55fe3b490af4dbd62953065d293a3}{m\_sendRetries});
2493 
2494       p = mb.GetPacket ()->Copy ();
2495       dsrP = mb.GetPacket ()->Copy ();
2496 
2497       Ipv4Address source = mb.GetSrc ();
2498       Ipv4Address nextHop = mb.GetNextHop ();
2499       \textcolor{comment}{// Send the data packet out before schedule the next packet transmission}
2500       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a84a2caf24a41eef8993b64cb22874f95}{SendPacket} (p, source, nextHop, protocol);
2501 
2502       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The packet with dsr header "} << dsrP->GetSize ());
2503       networkKey.m\_ackId = mb.GetAckId ();
2504       networkKey.m\_ourAdd = mb.GetOurAdd ();
2505       networkKey.m\_nextHop = mb.GetNextHop ();
2506       networkKey.m\_source = mb.GetSrc ();
2507       networkKey.m\_destination = mb.GetDst ();
2508       \textcolor{comment}{/*}
2509 \textcolor{comment}{       *  If a data packet has been attempted SendRetries times at the maximum TTL without}
2510 \textcolor{comment}{       *  receiving any ACK, all data packets destined for the corresponding destination SHOULD be}
2511 \textcolor{comment}{       *  dropped from the send buffer}
2512 \textcolor{comment}{       *}
2513 \textcolor{comment}{       *  The maxMaintRexmt also needs to decrease one for the passive ack packet}
2514 \textcolor{comment}{       */}
2515       \textcolor{comment}{/*}
2516 \textcolor{comment}{       * Check if the send retry time for a certain packet has already passed max maintenance
       retransmission}
2517 \textcolor{comment}{       * time or not}
2518 \textcolor{comment}{       */}
2519 
2520       \textcolor{comment}{// After m\_tryPassiveAcks, schedule the packet retransmission using network acknowledgment option}
2521       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4a35b13cdca413ab5bc0b1b3b7b78907}{m\_addressForwardTimer}[networkKey].SetFunction (&
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_aabcdf59bcb4907718986626a7a402dad}{DsrRouting::NetworkScheduleTimerExpire}, \textcolor{keyword}{this});
2522       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4a35b13cdca413ab5bc0b1b3b7b78907}{m\_addressForwardTimer}[networkKey].Remove ();
2523       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4a35b13cdca413ab5bc0b1b3b7b78907}{m\_addressForwardTimer}[networkKey].SetArguments (mb, protocol);
2524       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The packet retries time for "} << mb.GetAckId () << \textcolor{stringliteral}{" is "} << 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a02a55fe3b490af4dbd62953065d293a3}{m\_sendRetries}
2525                                                    << \textcolor{stringliteral}{" and the delay time is "} << 
      \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (2 * \hyperlink{classns3_1_1dsr_1_1DsrRouting_a02a55fe3b490af4dbd62953065d293a3}{m\_sendRetries} *  \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4c406057009653878e8cdf3e3a7f2106}{m\_nodeTraversalTime}).GetSeconds ());
2526       \textcolor{comment}{// Back-off mechanism}
2527       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4a35b13cdca413ab5bc0b1b3b7b78907}{m\_addressForwardTimer}[networkKey].Schedule (\hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (2 * 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a02a55fe3b490af4dbd62953065d293a3}{m\_sendRetries} * \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4c406057009653878e8cdf3e3a7f2106}{m\_nodeTraversalTime}));
2528     \}
2529 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 73




Here is the caller graph for this function\+:
% FIG 74


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Schedule\+Passive\+Packet\+Retry@{Schedule\+Passive\+Packet\+Retry}}
\index{Schedule\+Passive\+Packet\+Retry@{Schedule\+Passive\+Packet\+Retry}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Schedule\+Passive\+Packet\+Retry(\+Dsr\+Maintain\+Buff\+Entry \&mb, uint8\+\_\+t protocol)}{SchedulePassivePacketRetry(DsrMaintainBuffEntry &mb, uint8_t protocol)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Schedule\+Passive\+Packet\+Retry (
\begin{DoxyParamCaption}
\item[{{\bf Dsr\+Maintain\+Buff\+Entry} \&}]{mb, }
\item[{uint8\+\_\+t}]{protocol}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_abfdfa37822a492971fdf24540b635039}{}\label{classns3_1_1dsr_1_1DsrRouting_abfdfa37822a492971fdf24540b635039}


Schedule the packet retransmission based on passive acknowledgment. 


\begin{DoxyParams}{Parameters}
{\em mb} & maintainenace buffer entry \\
\hline
{\em protocol} & the protocol number \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2395 \{
2396   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << (uint32\_t)protocol);
2397 
2398   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = mb.GetPacket ()->Copy ();
2399   Ipv4Address source = mb.GetSrc ();
2400   Ipv4Address nextHop = mb.GetNextHop ();
2401 
2402   \textcolor{comment}{// Send the data packet out before schedule the next packet transmission}
2403   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a84a2caf24a41eef8993b64cb22874f95}{SendPacket} (p, source, nextHop, protocol);
2404 
2405   PassiveKey passiveKey;
2406   passiveKey.m\_ackId = 0;
2407   passiveKey.m\_source = mb.GetSrc ();
2408   passiveKey.m\_destination = mb.GetDst ();
2409   passiveKey.m\_segsLeft = mb.GetSegsLeft ();
2410 
2411   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ac53c706898e76a7f4871a460d13edd36}{m\_passiveAckTimer}.find (passiveKey) == \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac53c706898e76a7f4871a460d13edd36}{m\_passiveAckTimer}.end ())
2412     \{
2413       Timer timer (\hyperlink{classns3_1_1Timer_a816309b83cd2a35bea47d9bbc6bbf721a07a9dd5063b32fb6cf1f813c6ee7e28e}{Timer::CANCEL\_ON\_DESTROY});
2414       \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac53c706898e76a7f4871a460d13edd36}{m\_passiveAckTimer}[passiveKey] = timer;
2415     \}
2416   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The passive acknowledgment option for data packet"});
2417   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac53c706898e76a7f4871a460d13edd36}{m\_passiveAckTimer}[passiveKey].SetFunction (&
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a2f93ffc379338703d6b6a923dff44dd5}{DsrRouting::PassiveScheduleTimerExpire}, \textcolor{keyword}{this});
2418   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac53c706898e76a7f4871a460d13edd36}{m\_passiveAckTimer}[passiveKey].Remove ();
2419   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac53c706898e76a7f4871a460d13edd36}{m\_passiveAckTimer}[passiveKey].SetArguments (mb, protocol);
2420   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac53c706898e76a7f4871a460d13edd36}{m\_passiveAckTimer}[passiveKey].Schedule (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a6155bddae63f0e1fda8afbeebc25a54c}{m\_passiveAckTimeout});
2421 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 75




Here is the caller graph for this function\+:
% FIG 76


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Scheduler@{Scheduler}}
\index{Scheduler@{Scheduler}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Scheduler(uint32\+\_\+t priority)}{Scheduler(uint32_t priority)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Scheduler (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{priority}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_aa518edb174bccce1062304404424c6e0}{}\label{classns3_1_1dsr_1_1DsrRouting_aa518edb174bccce1062304404424c6e0}


This function is called to schedule sending packets from the network queue. 


\begin{DoxyCode}
1633 \{
1634   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1635   \hyperlink{classns3_1_1dsr_1_1DsrRouting_aefc4dde8bd52b5b631a7ebf1d5924210}{PriorityScheduler} (priority, \textcolor{keyword}{true});
1636 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 77




Here is the caller graph for this function\+:
% FIG 78


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Schedule\+Rreq\+Retry@{Schedule\+Rreq\+Retry}}
\index{Schedule\+Rreq\+Retry@{Schedule\+Rreq\+Retry}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Schedule\+Rreq\+Retry(\+Ptr$<$ Packet $>$ packet, std\+::vector$<$ Ipv4\+Address $>$ address, bool non\+Prop, uint32\+\_\+t request\+Id, uint8\+\_\+t protocol)}{ScheduleRreqRetry(Ptr< Packet > packet, std::vector< Ipv4Address > address, bool nonProp, uint32_t requestId, uint8_t protocol)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Schedule\+Rreq\+Retry (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{std\+::vector$<$ {\bf Ipv4\+Address} $>$}]{address, }
\item[{bool}]{non\+Prop, }
\item[{uint32\+\_\+t}]{request\+Id, }
\item[{uint8\+\_\+t}]{protocol}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a056b38f3af6c2992be89b8fc5cb15448}{}\label{classns3_1_1dsr_1_1DsrRouting_a056b38f3af6c2992be89b8fc5cb15448}


Schedule the route request retry. 


\begin{DoxyParams}{Parameters}
{\em packet} & the original packet \\
\hline
{\em address} & List of I\+Pv4 addresses \\
\hline
{\em non\+Prop} & flag if R\+R\+EQ is non-\/propagating \\
\hline
{\em request\+Id} & Unique request ID \\
\hline
{\em protocol} & the protocol number \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
2946 \{
2947   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << nonProp << requestId << (uint32\_t)protocol);
2948   Ipv4Address source = address[0];
2949   Ipv4Address dst = address[1];
2950   \textcolor{keywordflow}{if} (nonProp)
2951     \{
2952       \textcolor{comment}{// The nonProp route request is only sent out only and is already used}
2953       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a0936df610f90f7e79c24a2a8cdea6c14}{m\_nonPropReqTimer}.find (dst) == \hyperlink{classns3_1_1dsr_1_1DsrRouting_a0936df610f90f7e79c24a2a8cdea6c14}{m\_nonPropReqTimer}.end ())
2954         \{
2955           Timer timer (\hyperlink{classns3_1_1Timer_a816309b83cd2a35bea47d9bbc6bbf721a07a9dd5063b32fb6cf1f813c6ee7e28e}{Timer::CANCEL\_ON\_DESTROY});
2956           \hyperlink{classns3_1_1dsr_1_1DsrRouting_a0936df610f90f7e79c24a2a8cdea6c14}{m\_nonPropReqTimer}[dst] = timer;
2957         \}
2958       std::vector<Ipv4Address> address;
2959       address.push\_back (source);
2960       address.push\_back (dst);
2961       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a0936df610f90f7e79c24a2a8cdea6c14}{m\_nonPropReqTimer}[dst].SetFunction (&
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa839b89cdf568048c4d09941b59e46d4}{DsrRouting::RouteRequestTimerExpire}, \textcolor{keyword}{this});
2962       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a0936df610f90f7e79c24a2a8cdea6c14}{m\_nonPropReqTimer}[dst].Remove ();
2963       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a0936df610f90f7e79c24a2a8cdea6c14}{m\_nonPropReqTimer}[dst].SetArguments (packet, address, requestId, protocol);
2964       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a0936df610f90f7e79c24a2a8cdea6c14}{m\_nonPropReqTimer}[dst].Schedule (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a42c2f43fbb0c5fefed36689eaf5c720e}{m\_nonpropRequestTimeout});
2965     \}
2966   \textcolor{keywordflow}{else}
2967     \{
2968       \textcolor{comment}{// Cancel the non propagation request timer if found}
2969       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a0936df610f90f7e79c24a2a8cdea6c14}{m\_nonPropReqTimer}[dst].Cancel ();
2970       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a0936df610f90f7e79c24a2a8cdea6c14}{m\_nonPropReqTimer}[dst].Remove ();
2971       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a0936df610f90f7e79c24a2a8cdea6c14}{m\_nonPropReqTimer}[dst].IsRunning ())
2972         \{
2973           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Timer not canceled"});
2974         \}
2975       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a0936df610f90f7e79c24a2a8cdea6c14}{m\_nonPropReqTimer}.erase (dst);
2976 
2977       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a47174823b0622573b681afc40d6ea558}{m\_addressReqTimer}.find (dst) == \hyperlink{classns3_1_1dsr_1_1DsrRouting_a47174823b0622573b681afc40d6ea558}{m\_addressReqTimer}.end ())
2978         \{
2979           Timer timer (\hyperlink{classns3_1_1Timer_a816309b83cd2a35bea47d9bbc6bbf721a07a9dd5063b32fb6cf1f813c6ee7e28e}{Timer::CANCEL\_ON\_DESTROY});
2980           \hyperlink{classns3_1_1dsr_1_1DsrRouting_a47174823b0622573b681afc40d6ea558}{m\_addressReqTimer}[dst] = timer;
2981         \}
2982       std::vector<Ipv4Address> address;
2983       address.push\_back (source);
2984       address.push\_back (dst);
2985       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a47174823b0622573b681afc40d6ea558}{m\_addressReqTimer}[dst].SetFunction (&
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa839b89cdf568048c4d09941b59e46d4}{DsrRouting::RouteRequestTimerExpire}, \textcolor{keyword}{this});
2986       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a47174823b0622573b681afc40d6ea558}{m\_addressReqTimer}[dst].Remove ();
2987       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a47174823b0622573b681afc40d6ea558}{m\_addressReqTimer}[dst].SetArguments (packet, address, requestId, protocol);
2988       \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} rreqDelay;
2989       \textcolor{comment}{// back off mechanism for sending route requests}
2990       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ae9ec27743735fa2d59cc5190961d1942}{m\_rreqTable}->GetRreqCnt (dst))
2991         \{
2992           \textcolor{comment}{// When the route request count is larger than 0}
2993           \textcolor{comment}{// This is the exponential back-off mechanism for route request}
2994           rreqDelay = \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (std::pow (static\_cast<double> (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ae9ec27743735fa2d59cc5190961d1942}{m\_rreqTable}->GetRreqCnt (dst)), 2
      .0) * \hyperlink{classns3_1_1dsr_1_1DsrRouting_acb19e2fe8a4cc1812181cdd5491383ee}{m\_requestPeriod});
2995         \}
2996       \textcolor{keywordflow}{else}
2997         \{
2998           \textcolor{comment}{// This is the first route request retry}
2999           rreqDelay = \hyperlink{classns3_1_1dsr_1_1DsrRouting_acb19e2fe8a4cc1812181cdd5491383ee}{m\_requestPeriod};
3000         \}
3001       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Request count for "} << dst << \textcolor{stringliteral}{" "} << 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_ae9ec27743735fa2d59cc5190961d1942}{m\_rreqTable}->GetRreqCnt (dst) << \textcolor{stringliteral}{" with delay time "} << rreqDelay.GetSeconds () << \textcolor{stringliteral}{" second"});
3002       \textcolor{keywordflow}{if} (rreqDelay > \hyperlink{classns3_1_1dsr_1_1DsrRouting_abce8e7bae58dada0db217ca294cb4c6e}{m\_maxRequestPeriod})
3003         \{
3004           \textcolor{comment}{// use the max request period}
3005           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"The max request delay time "} << 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_abce8e7bae58dada0db217ca294cb4c6e}{m\_maxRequestPeriod}.\hyperlink{classns3_1_1Time_a8f20d5c3b0902d7b4320982f340b57c8}{GetSeconds} ());
3006           \hyperlink{classns3_1_1dsr_1_1DsrRouting_a47174823b0622573b681afc40d6ea558}{m\_addressReqTimer}[dst].Schedule (\hyperlink{classns3_1_1dsr_1_1DsrRouting_abce8e7bae58dada0db217ca294cb4c6e}{m\_maxRequestPeriod});
3007         \}
3008       \textcolor{keywordflow}{else}
3009         \{
3010           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"The request delay time "} << rreqDelay.GetSeconds () << \textcolor{stringliteral}{" second"});
3011           \hyperlink{classns3_1_1dsr_1_1DsrRouting_a47174823b0622573b681afc40d6ea558}{m\_addressReqTimer}[dst].Schedule (rreqDelay);
3012         \}
3013     \}
3014 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 79




Here is the caller graph for this function\+:
% FIG 80


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Search\+Next\+Hop@{Search\+Next\+Hop}}
\index{Search\+Next\+Hop@{Search\+Next\+Hop}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Search\+Next\+Hop(\+Ipv4\+Address ipv4\+Address, std\+::vector$<$ Ipv4\+Address $>$ \&vec)}{SearchNextHop(Ipv4Address ipv4Address, std::vector< Ipv4Address > &vec)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Address} ns3\+::dsr\+::\+Dsr\+Routing\+::\+Search\+Next\+Hop (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{ipv4\+Address, }
\item[{std\+::vector$<$ {\bf Ipv4\+Address} $>$ \&}]{vec}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_aa1b16658c14499af76ca7dd69c034f22}{}\label{classns3_1_1dsr_1_1DsrRouting_aa1b16658c14499af76ca7dd69c034f22}


Get the next hop of the route. 


\begin{DoxyParams}{Parameters}
{\em ipv4\+Address} & \\
\hline
{\em vec} & Route \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the next hop address of the route 
\end{DoxyReturn}

\begin{DoxyCode}
727 \{
728   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << ipv4Address);
729   Ipv4Address nextHop;
730   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"the vector size "} << vec.size ());
731   \textcolor{keywordflow}{if} (vec.size () == 2)
732     \{
733       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The two nodes are neighbors"});
734       nextHop = vec[1];
735       \textcolor{keywordflow}{return} nextHop;
736     \}
737   \textcolor{keywordflow}{else}
738     \{
739       \textcolor{keywordflow}{if} (ipv4Address == vec.back ())
740         \{
741           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"We have reached to the final destination "} << ipv4Address << \textcolor{stringliteral}{" "} << 
      vec.back ());
742           \textcolor{keywordflow}{return} ipv4Address;
743         \}
744       \textcolor{keywordflow}{for} (std::vector<Ipv4Address>::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = vec.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != vec.end (); ++
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
745         \{
746           \textcolor{keywordflow}{if} (ipv4Address == (*\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}))
747             \{
748               nextHop = *(++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
749               \textcolor{keywordflow}{return} nextHop;
750             \}
751         \}
752     \}
753   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Next hop address not found"});
754   Ipv4Address none = \textcolor{stringliteral}{"0.0.0.0"};
755   \textcolor{keywordflow}{return} none;
756 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 81


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Send@{Send}}
\index{Send@{Send}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Send(\+Ptr$<$ Packet $>$ packet, Ipv4\+Address source, Ipv4\+Address destination, uint8\+\_\+t protocol, Ptr$<$ Ipv4\+Route $>$ route)}{Send(Ptr< Packet > packet, Ipv4Address source, Ipv4Address destination, uint8_t protocol, Ptr< Ipv4Route > route)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Send (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Ipv4\+Address}}]{source, }
\item[{{\bf Ipv4\+Address}}]{destination, }
\item[{uint8\+\_\+t}]{protocol, }
\item[{{\bf Ptr}$<$ {\bf Ipv4\+Route} $>$}]{route}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_af67eeb07193d10db8308cb4ecbe08b02}{}\label{classns3_1_1dsr_1_1DsrRouting_af67eeb07193d10db8308cb4ecbe08b02}


This function is called by higher layer protocol when sending packets. 

When found a route and use it, Use\+Extends to the link cache 
\begin{DoxyCode}
1425 \{
1426   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << source << destination << (uint32\_t)protocol << route);
1427   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (!\hyperlink{classns3_1_1dsr_1_1DsrRouting_aa1eb6ea60fdf9ba2cac2079a74ce1ca4}{m\_downTarget}.\hyperlink{classns3_1_1Callback_aa8e27826badbf37f84763f36f70d9b54}{IsNull} (), \textcolor{stringliteral}{"Error, DsrRouting cannot send
       downward"});
1428 
1429   \textcolor{keywordflow}{if} (protocol == 1)
1430     \{
1431       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Drop packet. Not handling ICMP packet for now"});
1432     \}
1433   \textcolor{keywordflow}{else}
1434     \{
1435       \textcolor{comment}{// Look up routes for the specific destination}
1436       DsrRouteCacheEntry toDst;
1437       \textcolor{keywordtype}{bool} findRoute = \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->LookupRoute (destination, toDst);
1438       \textcolor{comment}{// Queue the packet if there is no route pre-existing}
1439       \textcolor{keywordflow}{if} (!findRoute)
1440         \{
1441           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds ()
1442                        << \textcolor{stringliteral}{"s "} << \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress} << \textcolor{stringliteral}{" there is no route for this packet, queue
       the packet"});
1443 
1444           Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = packet->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} ();
1445           DsrSendBuffEntry newEntry (p, destination, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a1f89794801db0336d92e4ca85fbc09a7}{m\_sendBufferTimeout}, protocol);    
       \textcolor{comment}{// Create a new entry for send buffer}
1446           \textcolor{keywordtype}{bool} result = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a887ae39d7060171753c0605d5c120549}{m\_sendBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrSendBuffer_aac846f6a38f6fc6431c8483103ed5121}{Enqueue} (newEntry);     \textcolor{comment}{// Enqueue the packet in
       send buffer}
1447           \textcolor{keywordflow}{if} (result)
1448             \{
1449               \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds ()
1450                            << \textcolor{stringliteral}{"s Add packet PID: "} << packet->\hyperlink{classns3_1_1Packet_a1f212c825b50e54d94f5b9ae99592e6a}{GetUid} () << \textcolor{stringliteral}{" to send buffer. Packet: 
      "} << *packet);
1451               \textcolor{comment}{// Only when there is no existing route request timer when new route request is scheduled}
1452               \textcolor{keywordflow}{if} ((\hyperlink{classns3_1_1dsr_1_1DsrRouting_a47174823b0622573b681afc40d6ea558}{m\_addressReqTimer}.find (destination) == 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a47174823b0622573b681afc40d6ea558}{m\_addressReqTimer}.end ()) && (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a0936df610f90f7e79c24a2a8cdea6c14}{m\_nonPropReqTimer}.find (destination) == 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a0936df610f90f7e79c24a2a8cdea6c14}{m\_nonPropReqTimer}.end ()))
1453                 \{
1454                   \textcolor{comment}{/*}
1455 \textcolor{comment}{                   * Call the send request function, it will update the request table entry and ttl value}
1456 \textcolor{comment}{                   */}
1457                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Send initial RREQ to "} << destination);
1458                   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a74777d1806e768fccc1c2fe169b42c98}{SendInitialRequest} (source, destination, protocol);
1459                 \}
1460               \textcolor{keywordflow}{else}
1461                 \{
1462                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"There is existing route request timer with request count "} << 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_ae9ec27743735fa2d59cc5190961d1942}{m\_rreqTable}->GetRreqCnt (destination));
1463                 \}
1464             \}
1465         \}
1466       \textcolor{keywordflow}{else}
1467         \{
1468           Ptr<Packet> cleanP = packet->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} ();
1469           DsrRoutingHeader dsrRoutingHeader;
1470           dsrRoutingHeader.SetNextHeader (protocol);
1471           dsrRoutingHeader.SetMessageType (2);
1472           dsrRoutingHeader.SetSourceId (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4593e50d5f36e9b9b013fe0422067c44}{GetIDfromIP} (source));
1473           dsrRoutingHeader.SetDestId (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4593e50d5f36e9b9b013fe0422067c44}{GetIDfromIP} (destination));
1474 
1475           DsrOptionSRHeader sourceRoute;
1476           std::vector<Ipv4Address> nodeList = toDst.GetVector ();       \textcolor{comment}{// Get the route from the route
       entry we found}
1477           Ipv4Address nextHop = \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa1b16658c14499af76ca7dd69c034f22}{SearchNextHop} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, nodeList);        \textcolor{comment}{
      // Get the next hop address for the route}
1478           \textcolor{keywordflow}{if} (nextHop == \textcolor{stringliteral}{"0.0.0.0"})
1479             \{
1480               \hyperlink{classns3_1_1dsr_1_1DsrRouting_ae70ab39db551d1d81afc081196f78017}{PacketNewRoute} (cleanP, source, destination, protocol);
1481               \textcolor{keywordflow}{return};
1482             \}
1483           uint8\_t salvage = 0;
1484           sourceRoute.SetNodesAddress (nodeList);       \textcolor{comment}{// Save the whole route in the source route header
       of the packet}
1486 \textcolor{comment}{}          \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->IsLinkCache ())
1487             \{
1488               \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->UseExtends (nodeList);
1489             \}
1490           sourceRoute.SetSegmentsLeft ((nodeList.size () - 2));       \textcolor{comment}{// The segmentsLeft field will
       indicate the hops to go}
1491           sourceRoute.SetSalvage (salvage);
1492 
1493           uint8\_t length = sourceRoute.GetLength ();
1494 
1495           dsrRoutingHeader.SetPayloadLength (uint16\_t (length) + 2);
1496           dsrRoutingHeader.AddDsrOption (sourceRoute);
1497           cleanP->AddHeader (dsrRoutingHeader);
1498 
1499           Ptr<const Packet> mtP = cleanP->Copy ();
1500           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"maintain packet size "} << cleanP->GetSize ());
1501           \textcolor{comment}{// Put the data packet in the maintenance queue for data packet retransmission}
1502           DsrMaintainBuffEntry newEntry (\textcolor{comment}{/*Packet=*/} mtP, \textcolor{comment}{/*ourAddress=*/} 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, \textcolor{comment}{/*nextHop=*/} nextHop,
1503                                                   \textcolor{comment}{/*source=*/} source, \textcolor{comment}{/*destination=*/} destination, \textcolor{comment}{/*
      ackId=*/} 0,
1504                                                   \textcolor{comment}{/*SegsLeft=*/} nodeList.size () - 2, \textcolor{comment}{/*expire time=*/} 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac6b1dffa9665af0d6a71aa7b947962ee}{m\_maxMaintainTime});
1505           \textcolor{keywordtype}{bool} result = \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac9d28a64437fbe20a4228c9811f9fc27}{m\_maintainBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a8ec30b5b9b0f6af36e61867327a47717}{Enqueue} (newEntry);       \textcolor{comment}{// Enqueue the
       packet the the maintenance buffer}
1506           \textcolor{keywordflow}{if} (result)
1507             \{
1508               NetworkKey networkKey;
1509               networkKey.m\_ackId = newEntry.GetAckId ();
1510               networkKey.m\_ourAdd = newEntry.GetOurAdd ();
1511               networkKey.m\_nextHop = newEntry.GetNextHop ();
1512               networkKey.m\_source = newEntry.GetSrc ();
1513               networkKey.m\_destination = newEntry.GetDst ();
1514 
1515               PassiveKey passiveKey;
1516               passiveKey.m\_ackId = 0;
1517               passiveKey.m\_source = newEntry.GetSrc ();
1518               passiveKey.m\_destination = newEntry.GetDst ();
1519               passiveKey.m\_segsLeft = newEntry.GetSegsLeft ();
1520 
1521               LinkKey linkKey;
1522               linkKey.m\_source = newEntry.GetSrc ();
1523               linkKey.m\_destination = newEntry.GetDst ();
1524               linkKey.m\_ourAdd = newEntry.GetOurAdd ();
1525               linkKey.m\_nextHop = newEntry.GetNextHop ();
1526 
1527               \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5042f7e5df0470025fdb6023fcc24411}{m\_addressForwardCnt}[networkKey] = 0;
1528               \hyperlink{classns3_1_1dsr_1_1DsrRouting_a7fec404d680459aab2b40941a950502d}{m\_passiveCnt}[passiveKey] = 0;
1529               \hyperlink{classns3_1_1dsr_1_1DsrRouting_a85ba159639f9bc13b3d8890458128a79}{m\_linkCnt}[linkKey] = 0;
1530 
1531               \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a216a52d8b579a034df948765d941d3a4}{m\_linkAck})
1532                 \{
1533                   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a947d831bc0964240b1a41b3a09832eff}{ScheduleLinkPacketRetry} (newEntry, protocol);
1534                 \}
1535               \textcolor{keywordflow}{else}
1536                 \{
1537                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Not using link acknowledgment"});
1538                   \textcolor{keywordflow}{if} (nextHop != destination)
1539                     \{
1540                       \hyperlink{classns3_1_1dsr_1_1DsrRouting_abfdfa37822a492971fdf24540b635039}{SchedulePassivePacketRetry} (newEntry, protocol);
1541                     \}
1542                   \textcolor{keywordflow}{else}
1543                     \{
1544                       \textcolor{comment}{// This is the first network retry}
1545                       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a6a18c6baa374d5e6a68f8952d1afdb13}{ScheduleNetworkPacketRetry} (newEntry, \textcolor{keyword}{true}, protocol);
1546                     \}
1547                 \}
1548             \}
1549 
1550           \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a887ae39d7060171753c0605d5c120549}{m\_sendBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrSendBuffer_a0ecf75786eef7193fa5a5d84b2b7a1f0}{GetSize} () != 0 && \hyperlink{classns3_1_1dsr_1_1DsrRouting_a887ae39d7060171753c0605d5c120549}{m\_sendBuffer}.
      \hyperlink{classns3_1_1dsr_1_1DsrSendBuffer_acf27d9e92a1d1960b9094c4108724a53}{Find} (destination))
1551             \{
1552               \textcolor{comment}{// Try to send packet from *previously* queued entries from send buffer if any}
1553               \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a22a85b3510166ffdd451e4010f996f0f}{m\_uniformRandomVariable}->\hyperlink{classns3_1_1RandomVariableStream_a66cd94e6305ce7f000f1a9ff0fcb9aef}{GetInteger} (0,100)),
1554                                    &\hyperlink{classns3_1_1dsr_1_1DsrRouting_a1a862a16f3a5527f9425763864ac3e80}{DsrRouting::SendPacketFromBuffer}, \textcolor{keyword}{this},
       sourceRoute, nextHop, protocol);
1555             \}
1556         \}
1557     \}
1558 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 82




Here is the caller graph for this function\+:
% FIG 83


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Send\+Ack@{Send\+Ack}}
\index{Send\+Ack@{Send\+Ack}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Send\+Ack(uint16\+\_\+t ack\+Id, Ipv4\+Address destination, Ipv4\+Address real\+Src, Ipv4\+Address real\+Dst, uint8\+\_\+t protocol, Ptr$<$ Ipv4\+Route $>$ route)}{SendAck(uint16_t ackId, Ipv4Address destination, Ipv4Address realSrc, Ipv4Address realDst, uint8_t protocol, Ptr< Ipv4Route > route)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Send\+Ack (
\begin{DoxyParamCaption}
\item[{uint16\+\_\+t}]{ack\+Id, }
\item[{{\bf Ipv4\+Address}}]{destination, }
\item[{{\bf Ipv4\+Address}}]{real\+Src, }
\item[{{\bf Ipv4\+Address}}]{real\+Dst, }
\item[{uint8\+\_\+t}]{protocol, }
\item[{{\bf Ptr}$<$ {\bf Ipv4\+Route} $>$}]{route}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_af60f582ca5ce9871a1f582f052511a38}{}\label{classns3_1_1dsr_1_1DsrRouting_af60f582ca5ce9871a1f582f052511a38}
Send network layer acknowledgment back to the earlier hop to notify the receipt of data packet


\begin{DoxyParams}{Parameters}
{\em ack\+Id} & A\+CK ID \\
\hline
{\em destination} & I\+Pv4 address of the immediate A\+CK receiver \\
\hline
{\em real\+Src} & I\+Pv4 address of the real source \\
\hline
{\em real\+Dst} & I\+Pv4 address of the real destination \\
\hline
{\em protocol} & the protocol number \\
\hline
{\em route} & Route \\
\hline
\end{DoxyParams}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000030}{Todo}]New \hyperlink{classns3_1_1dsr_1_1DsrNetworkQueueEntry}{Dsr\+Network\+Queue\+Entry} \end{DoxyRefDesc}

\begin{DoxyCode}
3254 \{
3255   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << ackId << destination << realSrc << realDst << (uint32\_t)protocol 
      << route);
3256   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (!\hyperlink{classns3_1_1dsr_1_1DsrRouting_aa1eb6ea60fdf9ba2cac2079a74ce1ca4}{m\_downTarget}.\hyperlink{classns3_1_1Callback_aa8e27826badbf37f84763f36f70d9b54}{IsNull} (), \textcolor{stringliteral}{"Error, DsrRouting cannot send
       downward"});
3257 
3258   \textcolor{comment}{// This is a route reply option header}
3259   DsrRoutingHeader dsrRoutingHeader;
3260   dsrRoutingHeader.SetNextHeader (protocol);
3261   dsrRoutingHeader.SetMessageType (1);
3262   dsrRoutingHeader.SetSourceId (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4593e50d5f36e9b9b013fe0422067c44}{GetIDfromIP} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}));
3263   dsrRoutingHeader.SetDestId (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4593e50d5f36e9b9b013fe0422067c44}{GetIDfromIP} (destination));
3264 
3265   DsrOptionAckHeader ack;
3266   \textcolor{comment}{/*}
3267 \textcolor{comment}{   * Set the ack Id and set the ack source address and destination address}
3268 \textcolor{comment}{   */}
3269   ack.SetAckId (ackId);
3270   ack.SetRealSrc (realSrc);
3271   ack.SetRealDst (realDst);
3272 
3273   uint8\_t length = ack.GetLength ();
3274   dsrRoutingHeader.SetPayloadLength (uint16\_t (length) + 2);
3275   dsrRoutingHeader.AddDsrOption (ack);
3276 
3277   Ptr<Packet> packet = Create<Packet> ();
3278   packet->AddHeader (dsrRoutingHeader);
3279   Ptr<NetDevice> dev = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a0443d48172143cafa1d0491e35f3fbaf}{m\_ip}->GetNetDevice (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a0443d48172143cafa1d0491e35f3fbaf}{m\_ip}->GetInterfaceForAddress (
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}));
3280   route->SetOutputDevice (dev);
3281 
3282   uint32\_t priority = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a67d111b0188b6e2210d1b4782820f8e3}{GetPriority} (\hyperlink{namespacens3_1_1dsr_a7c80bcec67d78dc149a0e503014d07c5abeaa53bf31d961c221e4e377ef6022f2}{DSR\_CONTROL\_PACKET});
3283   std::map<uint32\_t, Ptr<dsr::DsrNetworkQueue> >::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4606c3dfb1099afbfe1e7cd1d1c3c8ee}{m\_priorityQueue}.find (
      priority);
3284   Ptr<dsr::DsrNetworkQueue> dsrNetworkQueue = i->second;
3285 
3286   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Will be inserting into priority queue "} << dsrNetworkQueue << \textcolor{stringliteral}{" number: "} << 
      priority);
3287 
3288   \textcolor{comment}{//m\_downTarget (packet, m\_mainAddress, destination, GetProtocolNumber (), route);}
3289 
3291  DsrNetworkQueueEntry newEntry (packet, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, destination, 
      \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} (), route);
3292  \textcolor{keywordflow}{if} (dsrNetworkQueue->Enqueue (newEntry))
3293    \{
3294      \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa518edb174bccce1062304404424c6e0}{Scheduler} (priority);
3295    \}
3296  \textcolor{keywordflow}{else}
3297    \{
3298      \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Packet dropped as dsr network queue is full"});
3299    \}
3300 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 84


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Send\+Buff\+Timer\+Expire@{Send\+Buff\+Timer\+Expire}}
\index{Send\+Buff\+Timer\+Expire@{Send\+Buff\+Timer\+Expire}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Send\+Buff\+Timer\+Expire()}{SendBuffTimerExpire()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Send\+Buff\+Timer\+Expire (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a10273aec775b5cf12eafb03ee46c4397}{}\label{classns3_1_1dsr_1_1DsrRouting_a10273aec775b5cf12eafb03ee46c4397}


The send buffer timer expire. 


\begin{DoxyCode}
822 \{
823   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a7676aff7f691319b764fba26a726ef5d}{m\_sendBuffTimer}.\hyperlink{classns3_1_1Timer_addbc6c740f21ddeb6ad358557962b24c}{IsRunning} ())
824     \{
825       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a7676aff7f691319b764fba26a726ef5d}{m\_sendBuffTimer}.\hyperlink{classns3_1_1Timer_ac8261489cfc3361ab869ea2387cfc841}{Cancel} ();
826     \}
827   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a7676aff7f691319b764fba26a726ef5d}{m\_sendBuffTimer}.\hyperlink{classns3_1_1Timer_ac3345d696887578f518b19f359f7f94b}{Schedule} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a966d7c644a941e3e6365859983816e8b}{m\_sendBuffInterval});
828   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a03ace9023e9fe58434dc004123c7d9e0}{CheckSendBuffer} ();
829 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 85




Here is the caller graph for this function\+:
% FIG 86


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Send\+Error\+Request@{Send\+Error\+Request}}
\index{Send\+Error\+Request@{Send\+Error\+Request}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Send\+Error\+Request(\+Dsr\+Option\+Rerr\+Unreach\+Header \&rerr, uint8\+\_\+t protocol)}{SendErrorRequest(DsrOptionRerrUnreachHeader &rerr, uint8_t protocol)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Send\+Error\+Request (
\begin{DoxyParamCaption}
\item[{{\bf Dsr\+Option\+Rerr\+Unreach\+Header} \&}]{rerr, }
\item[{uint8\+\_\+t}]{protocol}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_ae2100978eb9447540ceceeda17e95cea}{}\label{classns3_1_1dsr_1_1DsrRouting_ae2100978eb9447540ceceeda17e95cea}


Send the error request packet. 


\begin{DoxyParams}{Parameters}
{\em rerr} & the route error header \\
\hline
{\em protocol} & the protocol number \\
\hline
\end{DoxyParams}
When found a route and use it, Use\+Extends to the link cache

Try to send out the packet from the buffer once we found one route 
\begin{DoxyCode}
2792 \{
2793   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << (uint32\_t)protocol);
2794   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (!\hyperlink{classns3_1_1dsr_1_1DsrRouting_aa1eb6ea60fdf9ba2cac2079a74ce1ca4}{m\_downTarget}.\hyperlink{classns3_1_1Callback_aa8e27826badbf37f84763f36f70d9b54}{IsNull} (), \textcolor{stringliteral}{"Error, DsrRouting cannot send
       downward"});
2795   uint8\_t salvage = rerr.GetSalvage ();
2796   Ipv4Address dst = rerr.GetOriginalDst ();
2797   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"our own address here "} << \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress} << \textcolor{stringliteral}{" error source "} << 
      rerr.GetErrorSrc () << \textcolor{stringliteral}{" error destination "} << rerr.GetErrorDst ()
2798                                         << \textcolor{stringliteral}{" error next hop "} << rerr.GetUnreachNode () << \textcolor{stringliteral}{" original dst "}
       << rerr.GetOriginalDst ()
2799                 );
2800   DsrRouteCacheEntry toDst;
2801   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->LookupRoute (dst, toDst))
2802     \{
2803       \textcolor{comment}{/*}
2804 \textcolor{comment}{       * Found a route the dst, construct the source route option header}
2805 \textcolor{comment}{       */}
2806       DsrOptionSRHeader sourceRoute;
2807       std::vector<Ipv4Address> ip = toDst.GetVector ();
2808       sourceRoute.SetNodesAddress (ip);
2810       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->IsLinkCache ())
2811         \{
2812           \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->UseExtends (ip);
2813         \}
2814       sourceRoute.SetSegmentsLeft ((ip.size () - 2));
2815       sourceRoute.SetSalvage (salvage);
2816       Ipv4Address nextHop = \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa1b16658c14499af76ca7dd69c034f22}{SearchNextHop} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, ip);       \textcolor{comment}{// Get the
       next hop address}
2817       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The nextHop address "} << nextHop);
2818       Ptr<Packet> packet = Create<Packet> ();
2819       \textcolor{keywordflow}{if} (nextHop == \textcolor{stringliteral}{"0.0.0.0"})
2820         \{
2821           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Error next hop address"});
2822           \hyperlink{classns3_1_1dsr_1_1DsrRouting_ae70ab39db551d1d81afc081196f78017}{PacketNewRoute} (packet, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, dst, protocol);
2823           \textcolor{keywordflow}{return};
2824         \}
2825       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a8a726fb52558a1a8172a5bd5b8cdb072}{SetRoute} (nextHop, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress});
2826       \hyperlink{classns3_1_1dsr_1_1DsrRouting_ad489fa602b093c8336cf4143ed60e429}{CancelRreqTimer} (dst, \textcolor{keyword}{true});
2828       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a887ae39d7060171753c0605d5c120549}{m\_sendBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrSendBuffer_a0ecf75786eef7193fa5a5d84b2b7a1f0}{GetSize} () != 0 && \hyperlink{classns3_1_1dsr_1_1DsrRouting_a887ae39d7060171753c0605d5c120549}{m\_sendBuffer}.
      \hyperlink{classns3_1_1dsr_1_1DsrSendBuffer_acf27d9e92a1d1960b9094c4108724a53}{Find} (dst))
2829         \{
2830           \hyperlink{classns3_1_1dsr_1_1DsrRouting_a1a862a16f3a5527f9425763864ac3e80}{SendPacketFromBuffer} (sourceRoute, nextHop, protocol);
2831         \}
2832       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Route to "} << dst << \textcolor{stringliteral}{" found"});
2833       \textcolor{keywordflow}{return};
2834     \}
2835   \textcolor{keywordflow}{else}
2836     \{
2837       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"No route found, initiate route error request"});
2838       Ptr<Packet> packet = Create<Packet> ();
2839       Ipv4Address originalDst = rerr.GetOriginalDst ();
2840       \textcolor{comment}{// Create an empty route ptr}
2841       Ptr<Ipv4Route> route = 0;
2842       \textcolor{comment}{/*}
2843 \textcolor{comment}{       * Construct the route request option header}
2844 \textcolor{comment}{       */}
2845       DsrRoutingHeader dsrRoutingHeader;
2846       dsrRoutingHeader.SetNextHeader (protocol);
2847       dsrRoutingHeader.SetMessageType (1);
2848       dsrRoutingHeader.SetSourceId (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4593e50d5f36e9b9b013fe0422067c44}{GetIDfromIP} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}));
2849       dsrRoutingHeader.SetDestId (255);
2850 
2851       Ptr<Packet> dstP = Create<Packet> ();
2852       DsrOptionRreqHeader rreqHeader;                                \textcolor{comment}{// has an alignment of 4n+0}
2853       rreqHeader.AddNodeAddress (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress});                     \textcolor{comment}{// Add our own address in
       the header}
2854       rreqHeader.SetTarget (originalDst);
2855       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4d9ddfed8e907a5885bb5e0f4b41f388}{m\_requestId} = \hyperlink{classns3_1_1dsr_1_1DsrRouting_ae9ec27743735fa2d59cc5190961d1942}{m\_rreqTable}->CheckUniqueRreqId (originalDst);       \textcolor{comment}{// Check the
       Id cache for duplicate ones}
2856       rreqHeader.SetId (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4d9ddfed8e907a5885bb5e0f4b41f388}{m\_requestId});
2857 
2858       dsrRoutingHeader.AddDsrOption (rreqHeader);         \textcolor{comment}{// Add the rreqHeader to the dsr extension header}
2859       dsrRoutingHeader.AddDsrOption (rerr);
2860       uint8\_t length = rreqHeader.GetLength () + rerr.GetLength ();
2861       dsrRoutingHeader.SetPayloadLength (uint16\_t (length) + 4);
2862       dstP->AddHeader (dsrRoutingHeader);
2863       \textcolor{comment}{// Schedule the route requests retry, propagate the route request message as it contains error}
2864       \textcolor{keywordtype}{bool} nonProp = \textcolor{keyword}{false};
2865       std::vector<Ipv4Address> address;
2866       address.push\_back (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress});
2867       address.push\_back (originalDst);
2868       \textcolor{comment}{/*}
2869 \textcolor{comment}{       * Add the socket ip ttl tag to the packet to limit the scope of route requests}
2870 \textcolor{comment}{       */}
2871       SocketIpTtlTag tag;
2872       tag.SetTtl ((uint8\_t)\hyperlink{classns3_1_1dsr_1_1DsrRouting_acf9cc5a2ae446403b8b57f3340fac178}{m\_discoveryHopLimit});
2873       Ptr<Packet> propPacket = dstP->Copy ();
2874       propPacket->AddPacketTag (tag);
2875 
2876       \textcolor{keywordflow}{if} ((\hyperlink{classns3_1_1dsr_1_1DsrRouting_a47174823b0622573b681afc40d6ea558}{m\_addressReqTimer}.find (originalDst) == 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a47174823b0622573b681afc40d6ea558}{m\_addressReqTimer}.end ()) && (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a0936df610f90f7e79c24a2a8cdea6c14}{m\_nonPropReqTimer}.find (originalDst) == 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a0936df610f90f7e79c24a2a8cdea6c14}{m\_nonPropReqTimer}.end ()))
2877         \{
2878           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Only when there is no existing route request time when the initial route
       request is scheduled"});
2879           \hyperlink{classns3_1_1dsr_1_1DsrRouting_a21496638c09e75ea310e876135d0bf64}{SendRequest} (propPacket, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress});
2880           \hyperlink{classns3_1_1dsr_1_1DsrRouting_a056b38f3af6c2992be89b8fc5cb15448}{ScheduleRreqRetry} (dstP, address, nonProp, 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4d9ddfed8e907a5885bb5e0f4b41f388}{m\_requestId}, protocol);
2881         \}
2882       \textcolor{keywordflow}{else}
2883         \{
2884           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"There is existing route request, find the existing route request entry"})
      ;
2885           \textcolor{comment}{/*}
2886 \textcolor{comment}{           * Cancel the route request timer first before scheduling the route request}
2887 \textcolor{comment}{           * in this case, we do not want to remove the route request entry, so the isRemove value is false}
2888 \textcolor{comment}{           */}
2889           \hyperlink{classns3_1_1dsr_1_1DsrRouting_ad489fa602b093c8336cf4143ed60e429}{CancelRreqTimer} (originalDst, \textcolor{keyword}{false});
2890           \hyperlink{classns3_1_1dsr_1_1DsrRouting_a056b38f3af6c2992be89b8fc5cb15448}{ScheduleRreqRetry} (dstP, address, nonProp, 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4d9ddfed8e907a5885bb5e0f4b41f388}{m\_requestId}, protocol);
2891         \}
2892     \}
2893 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 87




Here is the caller graph for this function\+:
% FIG 88


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Send\+Gratuitous\+Reply@{Send\+Gratuitous\+Reply}}
\index{Send\+Gratuitous\+Reply@{Send\+Gratuitous\+Reply}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Send\+Gratuitous\+Reply(\+Ipv4\+Address reply\+To, Ipv4\+Address reply\+From, std\+::vector$<$ Ipv4\+Address $>$ \&node\+List, uint8\+\_\+t protocol)}{SendGratuitousReply(Ipv4Address replyTo, Ipv4Address replyFrom, std::vector< Ipv4Address > &nodeList, uint8_t protocol)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Send\+Gratuitous\+Reply (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{reply\+To, }
\item[{{\bf Ipv4\+Address}}]{reply\+From, }
\item[{std\+::vector$<$ {\bf Ipv4\+Address} $>$ \&}]{node\+List, }
\item[{uint8\+\_\+t}]{protocol}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a780988be538d2a1030d127f1d3c7932c}{}\label{classns3_1_1dsr_1_1DsrRouting_a780988be538d2a1030d127f1d3c7932c}


Send the gratuitous reply. 


\begin{DoxyParams}{Parameters}
{\em reply\+To} & The destination address to send the reply to \\
\hline
{\em reply\+From} & The source address sending the reply \\
\hline
{\em node\+List} & Route \\
\hline
{\em protocol} & the protocol number \\
\hline
\end{DoxyParams}
Push back the node addresses other than those between src\+Address and our own ip address
\begin{DoxyCode}
3133 \{
3134   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << source << srcAddress << (uint32\_t)protocol);
3135   \textcolor{keywordflow}{if} (!(\hyperlink{classns3_1_1dsr_1_1DsrRouting_a9208badf7697dda01917aa2034b0b59c}{m\_graReply}.\hyperlink{classns3_1_1dsr_1_1DsrGraReply_ad8e17d0d037d282a4b2f70d40d1a189b}{FindAndUpdate} (source, srcAddress, 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a43f5d8b4569f2122788518584ce3ae77}{m\_gratReplyHoldoff})))     \textcolor{comment}{// Find the gratuitous reply entry}
3136     \{
3137       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Update gratuitous reply "} << source);
3138       GraReplyEntry graReplyEntry (source, srcAddress, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a43f5d8b4569f2122788518584ce3ae77}{m\_gratReplyHoldoff} + 
      \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ());
3139       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a9208badf7697dda01917aa2034b0b59c}{m\_graReply}.\hyperlink{classns3_1_1dsr_1_1DsrGraReply_a0eeeca01927b90e79481ef06e29ed062}{AddEntry} (graReplyEntry);
3140       \textcolor{comment}{/*}
3141 \textcolor{comment}{       * Automatic route shortening}
3142 \textcolor{comment}{       */}
3143       \hyperlink{classns3_1_1dsr_1_1DsrRouting_afb085eaa8fcab547a83f683ef5aef41a}{m\_finalRoute}.clear ();      \textcolor{comment}{// Clear the final route vector}
3147 \textcolor{comment}{}      std::vector<Ipv4Address>::iterator before = find (nodeList.begin (), nodeList.end (), srcAddress);
3148       \textcolor{keywordflow}{for} (std::vector<Ipv4Address>::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = nodeList.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != before; ++
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
3149         \{
3150           \hyperlink{classns3_1_1dsr_1_1DsrRouting_afb085eaa8fcab547a83f683ef5aef41a}{m\_finalRoute}.push\_back (*\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
3151         \}
3152       \hyperlink{classns3_1_1dsr_1_1DsrRouting_afb085eaa8fcab547a83f683ef5aef41a}{m\_finalRoute}.push\_back (srcAddress);
3153       std::vector<Ipv4Address>::iterator after = find (nodeList.begin (), nodeList.end (), 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress});
3154       \textcolor{keywordflow}{for} (std::vector<Ipv4Address>::iterator j = after; j != nodeList.end (); ++j)
3155         \{
3156           \hyperlink{classns3_1_1dsr_1_1DsrRouting_afb085eaa8fcab547a83f683ef5aef41a}{m\_finalRoute}.push\_back (*j);
3157         \}
3158       DsrOptionRrepHeader rrep;
3159       rrep.SetNodesAddress (\hyperlink{classns3_1_1dsr_1_1DsrRouting_afb085eaa8fcab547a83f683ef5aef41a}{m\_finalRoute});           \textcolor{comment}{// Set the node addresses in the route
       reply header}
3160       \textcolor{comment}{// Get the real reply source and destination}
3161       Ipv4Address replySrc = \hyperlink{classns3_1_1dsr_1_1DsrRouting_afb085eaa8fcab547a83f683ef5aef41a}{m\_finalRoute}.back ();
3162       Ipv4Address replyDst = \hyperlink{classns3_1_1dsr_1_1DsrRouting_afb085eaa8fcab547a83f683ef5aef41a}{m\_finalRoute}.front ();
3163       \textcolor{comment}{/*}
3164 \textcolor{comment}{       * Set the route and use it in send back route reply}
3165 \textcolor{comment}{       */}
3166       \hyperlink{classns3_1_1dsr_1_1DsrRouting_ab4c16d56044159989e52ad33c0afed2b}{m\_ipv4Route} = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a8a726fb52558a1a8172a5bd5b8cdb072}{SetRoute} (srcAddress, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress});
3167       \textcolor{comment}{/*}
3168 \textcolor{comment}{       * This part adds DSR header to the packet and send reply}
3169 \textcolor{comment}{       */}
3170       DsrRoutingHeader dsrRoutingHeader;
3171       dsrRoutingHeader.SetNextHeader (protocol);
3172       dsrRoutingHeader.SetMessageType (1);
3173       dsrRoutingHeader.SetSourceId (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4593e50d5f36e9b9b013fe0422067c44}{GetIDfromIP} (replySrc));
3174       dsrRoutingHeader.SetDestId (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4593e50d5f36e9b9b013fe0422067c44}{GetIDfromIP} (replyDst));
3175 
3176       uint8\_t length = rrep.GetLength ();        \textcolor{comment}{// Get the length of the rrep header excluding the type
       header}
3177       dsrRoutingHeader.SetPayloadLength (uint16\_t (length) + 2);
3178       dsrRoutingHeader.AddDsrOption (rrep);
3179       Ptr<Packet> newPacket = Create<Packet> ();
3180       newPacket->AddHeader (dsrRoutingHeader);
3181       \textcolor{comment}{/*}
3182 \textcolor{comment}{       * Send gratuitous reply}
3183 \textcolor{comment}{       */}
3184       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Send back gratuitous route reply"});
3185       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a69e03d265224fc60bf135b2496d97f04}{SendReply} (newPacket, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, srcAddress, 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_ab4c16d56044159989e52ad33c0afed2b}{m\_ipv4Route});
3186     \}
3187   \textcolor{keywordflow}{else}
3188     \{
3189       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"The same gratuitous route reply has already sent"});
3190     \}
3191 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 89


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Send\+Initial\+Request@{Send\+Initial\+Request}}
\index{Send\+Initial\+Request@{Send\+Initial\+Request}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Send\+Initial\+Request(\+Ipv4\+Address source, Ipv4\+Address destination, uint8\+\_\+t protocol)}{SendInitialRequest(Ipv4Address source, Ipv4Address destination, uint8_t protocol)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Send\+Initial\+Request (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{source, }
\item[{{\bf Ipv4\+Address}}]{destination, }
\item[{uint8\+\_\+t}]{protocol}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a74777d1806e768fccc1c2fe169b42c98}{}\label{classns3_1_1dsr_1_1DsrRouting_a74777d1806e768fccc1c2fe169b42c98}


Broadcast the route request packet in subnet. 


\begin{DoxyCode}
2745 \{
2746   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << source << destination << (uint32\_t)protocol);
2747   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (!\hyperlink{classns3_1_1dsr_1_1DsrRouting_aa1eb6ea60fdf9ba2cac2079a74ce1ca4}{m\_downTarget}.\hyperlink{classns3_1_1Callback_aa8e27826badbf37f84763f36f70d9b54}{IsNull} (), \textcolor{stringliteral}{"Error, DsrRouting cannot send
       downward"});
2748   Ptr<Packet> packet = Create<Packet> ();
2749   \textcolor{comment}{// Create an empty Ipv4 route ptr}
2750   Ptr<Ipv4Route> route;
2751   \textcolor{comment}{/*}
2752 \textcolor{comment}{   * Construct the route request option header}
2753 \textcolor{comment}{   */}
2754   DsrRoutingHeader dsrRoutingHeader;
2755   dsrRoutingHeader.SetNextHeader (protocol);
2756   dsrRoutingHeader.SetMessageType (1);
2757   dsrRoutingHeader.SetSourceId (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4593e50d5f36e9b9b013fe0422067c44}{GetIDfromIP} (source));
2758   dsrRoutingHeader.SetDestId (255);
2759 
2760   DsrOptionRreqHeader rreqHeader;                                  \textcolor{comment}{// has an alignment of 4n+0}
2761   rreqHeader.AddNodeAddress (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress});                       \textcolor{comment}{// Add our own address in
       the header}
2762   rreqHeader.SetTarget (destination);
2763   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4d9ddfed8e907a5885bb5e0f4b41f388}{m\_requestId} = \hyperlink{classns3_1_1dsr_1_1DsrRouting_ae9ec27743735fa2d59cc5190961d1942}{m\_rreqTable}->CheckUniqueRreqId (destination);      \textcolor{comment}{// Check the Id
       cache for duplicate ones}
2764   rreqHeader.SetId (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4d9ddfed8e907a5885bb5e0f4b41f388}{m\_requestId});
2765 
2766   dsrRoutingHeader.AddDsrOption (rreqHeader);                      \textcolor{comment}{// Add the rreqHeader to the dsr
       extension header}
2767   uint8\_t length = rreqHeader.GetLength ();
2768   dsrRoutingHeader.SetPayloadLength (uint16\_t (length) + 2);
2769   packet->AddHeader (dsrRoutingHeader);
2770 
2771   \textcolor{comment}{// Schedule the route requests retry with non-propagation set true}
2772   \textcolor{keywordtype}{bool} nonProp = \textcolor{keyword}{true};
2773   std::vector<Ipv4Address> address;
2774   address.push\_back (source);
2775   address.push\_back (destination);
2776   \textcolor{comment}{/*}
2777 \textcolor{comment}{   * Add the socket ip ttl tag to the packet to limit the scope of route requests}
2778 \textcolor{comment}{   */}
2779   SocketIpTtlTag tag;
2780   tag.SetTtl (0);
2781   Ptr<Packet> nonPropPacket = packet->Copy ();
2782   nonPropPacket->AddPacketTag (tag);
2783   \textcolor{comment}{// Increase the request count}
2784   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ae9ec27743735fa2d59cc5190961d1942}{m\_rreqTable}->FindAndUpdate (destination);
2785   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a21496638c09e75ea310e876135d0bf64}{SendRequest} (nonPropPacket, source);
2786   \textcolor{comment}{// Schedule the next route request}
2787   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a056b38f3af6c2992be89b8fc5cb15448}{ScheduleRreqRetry} (packet, address, nonProp, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4d9ddfed8e907a5885bb5e0f4b41f388}{m\_requestId}, protocol);
2788 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 90




Here is the caller graph for this function\+:
% FIG 91


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Send\+Packet@{Send\+Packet}}
\index{Send\+Packet@{Send\+Packet}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Send\+Packet(\+Ptr$<$ Packet $>$ packet, Ipv4\+Address source, Ipv4\+Address next\+Hop, uint8\+\_\+t protocol)}{SendPacket(Ptr< Packet > packet, Ipv4Address source, Ipv4Address nextHop, uint8_t protocol)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Send\+Packet (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Ipv4\+Address}}]{source, }
\item[{{\bf Ipv4\+Address}}]{next\+Hop, }
\item[{uint8\+\_\+t}]{protocol}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a84a2caf24a41eef8993b64cb22874f95}{}\label{classns3_1_1dsr_1_1DsrRouting_a84a2caf24a41eef8993b64cb22874f95}


This function is called by when really sending out the packet. 

\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000025}{Todo}]New \hyperlink{classns3_1_1dsr_1_1DsrNetworkQueueEntry}{Dsr\+Network\+Queue\+Entry} \end{DoxyRefDesc}

\begin{DoxyCode}
1604 \{
1605   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << source << nextHop << (uint32\_t)protocol);
1606   \textcolor{comment}{// Send out the data packet}
1607   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ab4c16d56044159989e52ad33c0afed2b}{m\_ipv4Route} = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a8a726fb52558a1a8172a5bd5b8cdb072}{SetRoute} (nextHop, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress});
1608   Ptr<NetDevice> dev = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a0443d48172143cafa1d0491e35f3fbaf}{m\_ip}->GetNetDevice (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a0443d48172143cafa1d0491e35f3fbaf}{m\_ip}->GetInterfaceForAddress (
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}));
1609   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ab4c16d56044159989e52ad33c0afed2b}{m\_ipv4Route}->SetOutputDevice (dev);
1610 
1611   uint32\_t priority = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a67d111b0188b6e2210d1b4782820f8e3}{GetPriority} (\hyperlink{namespacens3_1_1dsr_a7c80bcec67d78dc149a0e503014d07c5ad29c69f5a6ad5fbb5eec5524f553e315}{DSR\_DATA\_PACKET});
1612   std::map<uint32\_t, Ptr<dsr::DsrNetworkQueue> >::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4606c3dfb1099afbfe1e7cd1d1c3c8ee}{m\_priorityQueue}.find (
      priority);
1613   Ptr<dsr::DsrNetworkQueue> dsrNetworkQueue = i->second;
1614   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Will be inserting into priority queue number: "} << priority);
1615 
1616   \textcolor{comment}{//m\_downTarget (packet, source, nextHop, GetProtocolNumber (), m\_ipv4Route);}
1617 
1619  DsrNetworkQueueEntry newEntry (packet, source, nextHop, \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} (), 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_ab4c16d56044159989e52ad33c0afed2b}{m\_ipv4Route});
1620 
1621  \textcolor{keywordflow}{if} (dsrNetworkQueue->Enqueue (newEntry))
1622    \{
1623      \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa518edb174bccce1062304404424c6e0}{Scheduler} (priority);
1624    \}
1625  \textcolor{keywordflow}{else}
1626    \{
1627      \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Packet dropped as dsr network queue is full"});
1628    \}
1629 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 92




Here is the caller graph for this function\+:
% FIG 93


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Send\+Packet\+From\+Buffer@{Send\+Packet\+From\+Buffer}}
\index{Send\+Packet\+From\+Buffer@{Send\+Packet\+From\+Buffer}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Send\+Packet\+From\+Buffer(\+Dsr\+Option\+S\+R\+Header const \&source\+Route, Ipv4\+Address next\+Hop, uint8\+\_\+t protocol)}{SendPacketFromBuffer(DsrOptionSRHeader const &sourceRoute, Ipv4Address nextHop, uint8_t protocol)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Send\+Packet\+From\+Buffer (
\begin{DoxyParamCaption}
\item[{{\bf Dsr\+Option\+S\+R\+Header} const \&}]{source\+Route, }
\item[{{\bf Ipv4\+Address}}]{next\+Hop, }
\item[{uint8\+\_\+t}]{protocol}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a1a862a16f3a5527f9425763864ac3e80}{}\label{classns3_1_1dsr_1_1DsrRouting_a1a862a16f3a5527f9425763864ac3e80}


This function is responsible for sending out data packets when have route, if no route found, it will cache the packet and send out route requests. 

When found a route and use it, Use\+Extends to the link cache

When found a route and use it, Use\+Extends to the link cache

\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000026}{Todo}]New \hyperlink{classns3_1_1dsr_1_1DsrNetworkQueueEntry}{Dsr\+Network\+Queue\+Entry} \end{DoxyRefDesc}

\begin{DoxyCode}
1749 \{
1750   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << nextHop << (uint32\_t)protocol);
1751   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (!\hyperlink{classns3_1_1dsr_1_1DsrRouting_aa1eb6ea60fdf9ba2cac2079a74ce1ca4}{m\_downTarget}.\hyperlink{classns3_1_1Callback_aa8e27826badbf37f84763f36f70d9b54}{IsNull} (), \textcolor{stringliteral}{"Error, DsrRouting cannot send
       downward"});
1752 
1753   \textcolor{comment}{// Reconstruct the route and Retransmit the data packet}
1754   std::vector<Ipv4Address> nodeList = sourceRoute.GetNodesAddress ();
1755   Ipv4Address destination = nodeList.back ();
1756   Ipv4Address source = nodeList.front ();       \textcolor{comment}{// Get the source address}
1757   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"The nexthop address "} << nextHop << \textcolor{stringliteral}{" the source "} << source << \textcolor{stringliteral}{" the
       destination "} << destination);
1758   \textcolor{comment}{/*}
1759 \textcolor{comment}{   * Here we try to find data packet from send buffer, if packet with this destination found, send it out}
1760 \textcolor{comment}{   */}
1761   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a887ae39d7060171753c0605d5c120549}{m\_sendBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrSendBuffer_acf27d9e92a1d1960b9094c4108724a53}{Find} (destination))
1762     \{
1763       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"destination over here "} << destination);
1764 
1766       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->IsLinkCache ())
1767         \{
1768           \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->UseExtends (nodeList);
1769         \}
1770       DsrSendBuffEntry entry;
1771       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a887ae39d7060171753c0605d5c120549}{m\_sendBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrSendBuffer_a31b49398ddb6a97b6ef27daa0d4ff6d7}{Dequeue} (destination, entry))
1772         \{
1773           Ptr<Packet> packet = entry.GetPacket ()->Copy ();
1774           Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = packet->Copy ();      \textcolor{comment}{// get a copy of the packet}
1775           \textcolor{comment}{// Set the source route option}
1776           DsrRoutingHeader dsrRoutingHeader;
1777           dsrRoutingHeader.SetNextHeader (protocol);
1778           dsrRoutingHeader.SetMessageType (2);
1779           dsrRoutingHeader.SetSourceId (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4593e50d5f36e9b9b013fe0422067c44}{GetIDfromIP} (source));
1780           dsrRoutingHeader.SetDestId (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4593e50d5f36e9b9b013fe0422067c44}{GetIDfromIP} (destination));
1781 
1782           uint8\_t length = sourceRoute.GetLength ();
1783           dsrRoutingHeader.SetPayloadLength (uint16\_t (length) + 2);
1784           dsrRoutingHeader.AddDsrOption (sourceRoute);
1785 
1786           p->AddHeader (dsrRoutingHeader);
1787 
1788           Ptr<const Packet> mtP = p->Copy ();
1789           \textcolor{comment}{// Put the data packet in the maintenance queue for data packet retransmission}
1790           DsrMaintainBuffEntry newEntry (\textcolor{comment}{/*Packet=*/} mtP, \textcolor{comment}{/*ourAddress=*/} 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, \textcolor{comment}{/*nextHop=*/} nextHop,
1791                                       \textcolor{comment}{/*source=*/} source, \textcolor{comment}{/*destination=*/} destination, \textcolor{comment}{/*ackId=*/} 0,
1792                                       \textcolor{comment}{/*SegsLeft=*/} nodeList.size () - 2, \textcolor{comment}{/*expire time=*/} 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac6b1dffa9665af0d6a71aa7b947962ee}{m\_maxMaintainTime});
1793           \textcolor{keywordtype}{bool} result = \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac9d28a64437fbe20a4228c9811f9fc27}{m\_maintainBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a8ec30b5b9b0f6af36e61867327a47717}{Enqueue} (newEntry);       \textcolor{comment}{// Enqueue the
       packet the the maintenance buffer}
1794 
1795           \textcolor{keywordflow}{if} (result)
1796             \{
1797               NetworkKey networkKey;
1798               networkKey.m\_ackId = newEntry.GetAckId ();
1799               networkKey.m\_ourAdd = newEntry.GetOurAdd ();
1800               networkKey.m\_nextHop = newEntry.GetNextHop ();
1801               networkKey.m\_source = newEntry.GetSrc ();
1802               networkKey.m\_destination = newEntry.GetDst ();
1803 
1804               PassiveKey passiveKey;
1805               passiveKey.m\_ackId = 0;
1806               passiveKey.m\_source = newEntry.GetSrc ();
1807               passiveKey.m\_destination = newEntry.GetDst ();
1808               passiveKey.m\_segsLeft = newEntry.GetSegsLeft ();
1809 
1810               LinkKey linkKey;
1811               linkKey.m\_source = newEntry.GetSrc ();
1812               linkKey.m\_destination = newEntry.GetDst ();
1813               linkKey.m\_ourAdd = newEntry.GetOurAdd ();
1814               linkKey.m\_nextHop = newEntry.GetNextHop ();
1815 
1816               \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5042f7e5df0470025fdb6023fcc24411}{m\_addressForwardCnt}[networkKey] = 0;
1817               \hyperlink{classns3_1_1dsr_1_1DsrRouting_a7fec404d680459aab2b40941a950502d}{m\_passiveCnt}[passiveKey] = 0;
1818               \hyperlink{classns3_1_1dsr_1_1DsrRouting_a85ba159639f9bc13b3d8890458128a79}{m\_linkCnt}[linkKey] = 0;
1819 
1820               \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a216a52d8b579a034df948765d941d3a4}{m\_linkAck})
1821                 \{
1822                   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a947d831bc0964240b1a41b3a09832eff}{ScheduleLinkPacketRetry} (newEntry, protocol);
1823                 \}
1824               \textcolor{keywordflow}{else}
1825                 \{
1826                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Not using link acknowledgment"});
1827                   \textcolor{keywordflow}{if} (nextHop != destination)
1828                     \{
1829                       \hyperlink{classns3_1_1dsr_1_1DsrRouting_abfdfa37822a492971fdf24540b635039}{SchedulePassivePacketRetry} (newEntry, protocol);
1830                     \}
1831                   \textcolor{keywordflow}{else}
1832                     \{
1833                       \textcolor{comment}{// This is the first network retry}
1834                       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a6a18c6baa374d5e6a68f8952d1afdb13}{ScheduleNetworkPacketRetry} (newEntry, \textcolor{keyword}{true}, protocol);
1835                     \}
1836                 \}
1837             \}
1838 
1839           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"send buffer size here and the destination "} << 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a887ae39d7060171753c0605d5c120549}{m\_sendBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrSendBuffer_a0ecf75786eef7193fa5a5d84b2b7a1f0}{GetSize}() << \textcolor{stringliteral}{" "} << destination);
1840           \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a887ae39d7060171753c0605d5c120549}{m\_sendBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrSendBuffer_a0ecf75786eef7193fa5a5d84b2b7a1f0}{GetSize} () != 0 && \hyperlink{classns3_1_1dsr_1_1DsrRouting_a887ae39d7060171753c0605d5c120549}{m\_sendBuffer}.
      \hyperlink{classns3_1_1dsr_1_1DsrSendBuffer_acf27d9e92a1d1960b9094c4108724a53}{Find} (destination))
1841             \{
1842               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Schedule sending the next packet in send buffer"});
1843               \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a22a85b3510166ffdd451e4010f996f0f}{m\_uniformRandomVariable}->\hyperlink{classns3_1_1RandomVariableStream_a66cd94e6305ce7f000f1a9ff0fcb9aef}{GetInteger} (0,100)),
1844                                    &\hyperlink{classns3_1_1dsr_1_1DsrRouting_a1a862a16f3a5527f9425763864ac3e80}{DsrRouting::SendPacketFromBuffer}, \textcolor{keyword}{this},
       sourceRoute, nextHop, protocol);
1845             \}
1846         \}
1847       \textcolor{keywordflow}{else}
1848         \{
1849           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"All queued packets are out-dated for the destination in send buffer"});
1850         \}
1851     \}
1852   \textcolor{comment}{/*}
1853 \textcolor{comment}{   * Here we try to find data packet from send buffer, if packet with this destiantion found, send it out}
1854 \textcolor{comment}{   */}
1855   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a802e15bf588fd1e9ccd401221461397a}{m\_errorBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrErrorBuffer_a6297a3549b5a22b7a71f7ffe44323b0e}{Find} (destination))
1856     \{
1857       DsrErrorBuffEntry entry;
1858       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a802e15bf588fd1e9ccd401221461397a}{m\_errorBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrErrorBuffer_a58e0c804871e9834661054edaa8f3f21}{Dequeue} (destination, entry))
1859         \{
1860           Ptr<Packet> packet = entry.GetPacket ()->Copy ();
1861           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The queued packet size "} << packet->GetSize ());
1862 
1863           DsrRoutingHeader dsrRoutingHeader;
1864           Ptr<Packet> copyP = packet->Copy ();
1865           Ptr<Packet> dsrPacket = packet->Copy ();
1866           dsrPacket->RemoveHeader (dsrRoutingHeader);
1867           uint32\_t offset = dsrRoutingHeader.GetDsrOptionsOffset ();
1868           copyP->RemoveAtStart (offset);       \textcolor{comment}{// Here the processed size is 8 bytes, which is the fixed
       sized extension header}
1869           \textcolor{comment}{/*}
1870 \textcolor{comment}{           * Peek data to get the option type as well as length and segmentsLeft field}
1871 \textcolor{comment}{           */}
1872           uint32\_t size = copyP->GetSize ();
1873           uint8\_t *\hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data} = \textcolor{keyword}{new} uint8\_t[size];
1874           copyP->CopyData (data, size);
1875 
1876           uint8\_t optionType = 0;
1877           optionType = *(\hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data});
1878           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The option type value in send packet "} << (uint32\_t)optionType);
1879           \textcolor{keywordflow}{if} (optionType == 3)
1880             \{
1881               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The packet is error packet"});
1882               Ptr<dsr::DsrOptions> dsrOption;
1883               DsrOptionHeader dsrOptionHeader;
1884 
1885               uint8\_t errorType = *(data + 2);
1886               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The error type"});
1887               \textcolor{keywordflow}{if} (errorType == 1)
1888                 \{
1889                   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The packet is route error unreach packet"});
1890                   DsrOptionRerrUnreachHeader rerr;
1891                   copyP->RemoveHeader (rerr);
1892                   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (copyP->GetSize () == 0);
1893                   uint8\_t length = (sourceRoute.GetLength () + rerr.GetLength ());
1894 
1895                   DsrOptionRerrUnreachHeader newUnreach;
1896                   newUnreach.SetErrorType (1);
1897                   newUnreach.SetErrorSrc (rerr.GetErrorSrc ());
1898                   newUnreach.SetUnreachNode (rerr.GetUnreachNode ());
1899                   newUnreach.SetErrorDst (rerr.GetErrorDst ());
1900                   newUnreach.SetOriginalDst (rerr.GetOriginalDst ());
1901                   newUnreach.SetSalvage (rerr.GetSalvage ());       \textcolor{comment}{// Set the value about whether to
       salvage a packet or not}
1902 
1903                   std::vector<Ipv4Address> nodeList = sourceRoute.GetNodesAddress ();
1904                   DsrRoutingHeader newRoutingHeader;
1905                   newRoutingHeader.SetNextHeader (protocol);
1906                   newRoutingHeader.SetMessageType (1);
1907                   newRoutingHeader.SetSourceId (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4593e50d5f36e9b9b013fe0422067c44}{GetIDfromIP} (rerr.GetErrorSrc ()));
1908                   newRoutingHeader.SetDestId (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4593e50d5f36e9b9b013fe0422067c44}{GetIDfromIP} (rerr.GetErrorDst ()));
1909                   newRoutingHeader.SetPayloadLength (uint16\_t (length) + 4);
1910                   newRoutingHeader.AddDsrOption (newUnreach);
1911                   newRoutingHeader.AddDsrOption (sourceRoute);
1913                   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->IsLinkCache ())
1914                     \{
1915                       \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->UseExtends (nodeList);
1916                     \}
1917                   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a8a726fb52558a1a8172a5bd5b8cdb072}{SetRoute} (nextHop, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress});
1918                   Ptr<Packet> newPacket = Create<Packet> ();
1919                   newPacket->AddHeader (newRoutingHeader);       \textcolor{comment}{// Add the extension header with rerr and
       sourceRoute attached to it}
1920                   Ptr<NetDevice> dev = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a0443d48172143cafa1d0491e35f3fbaf}{m\_ip}->GetNetDevice (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a0443d48172143cafa1d0491e35f3fbaf}{m\_ip}->GetInterfaceForAddress (
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}));
1921                   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ab4c16d56044159989e52ad33c0afed2b}{m\_ipv4Route}->SetOutputDevice (dev);
1922 
1923                   uint32\_t priority = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a67d111b0188b6e2210d1b4782820f8e3}{GetPriority} (\hyperlink{namespacens3_1_1dsr_a7c80bcec67d78dc149a0e503014d07c5abeaa53bf31d961c221e4e377ef6022f2}{DSR\_CONTROL\_PACKET});
1924                   std::map<uint32\_t, Ptr<dsr::DsrNetworkQueue> >::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4606c3dfb1099afbfe1e7cd1d1c3c8ee}{m\_priorityQueue}.find (priority);
1925                   Ptr<dsr::DsrNetworkQueue> dsrNetworkQueue = i->second;
1926                   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Will be inserting into priority queue "} << dsrNetworkQueue << \textcolor{stringliteral}{
      " number: "} << priority);
1927 
1928                   \textcolor{comment}{//m\_downTarget (newPacket, m\_mainAddress, nextHop, GetProtocolNumber (), m\_ipv4Route);}
1929 
1931                  DsrNetworkQueueEntry newEntry (newPacket, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, nextHop, 
      \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} (), \hyperlink{classns3_1_1dsr_1_1DsrRouting_ab4c16d56044159989e52ad33c0afed2b}{m\_ipv4Route});
1932 
1933                  \textcolor{keywordflow}{if} (dsrNetworkQueue->Enqueue (newEntry))
1934                    \{
1935                      \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa518edb174bccce1062304404424c6e0}{Scheduler} (priority);
1936                    \}
1937                  \textcolor{keywordflow}{else}
1938                    \{
1939                      \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Packet dropped as dsr network queue is full"});
1940                    \}
1941                 \}
1942             \}
1943 
1944           \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a802e15bf588fd1e9ccd401221461397a}{m\_errorBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrErrorBuffer_ab92dc271abcc1543af60225e3bde0469}{GetSize} () != 0 && \hyperlink{classns3_1_1dsr_1_1DsrRouting_a802e15bf588fd1e9ccd401221461397a}{m\_errorBuffer}.
      \hyperlink{classns3_1_1dsr_1_1DsrErrorBuffer_a6297a3549b5a22b7a71f7ffe44323b0e}{Find} (destination))
1945             \{
1946               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Schedule sending the next packet in error buffer"});
1947               \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a22a85b3510166ffdd451e4010f996f0f}{m\_uniformRandomVariable}->\hyperlink{classns3_1_1RandomVariableStream_a66cd94e6305ce7f000f1a9ff0fcb9aef}{GetInteger} (0,100)),
1948                                    &\hyperlink{classns3_1_1dsr_1_1DsrRouting_a1a862a16f3a5527f9425763864ac3e80}{DsrRouting::SendPacketFromBuffer}, \textcolor{keyword}{this},
       sourceRoute, nextHop, protocol);
1949             \}
1950         \}
1951     \}
1952   \textcolor{keywordflow}{else}
1953     \{
1954       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Packet not found in either the send or error buffer"});
1955     \}
1956 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 94




Here is the caller graph for this function\+:
% FIG 95


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Send\+Real\+Down@{Send\+Real\+Down}}
\index{Send\+Real\+Down@{Send\+Real\+Down}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Send\+Real\+Down(\+Dsr\+Network\+Queue\+Entry \&new\+Entry)}{SendRealDown(DsrNetworkQueueEntry &newEntry)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::dsr\+::\+Dsr\+Routing\+::\+Send\+Real\+Down (
\begin{DoxyParamCaption}
\item[{{\bf Dsr\+Network\+Queue\+Entry} \&}]{new\+Entry}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a1ec646804cb4db00478cc07e51998608}{}\label{classns3_1_1dsr_1_1DsrRouting_a1ec646804cb4db00478cc07e51998608}


This function is called to send packets down stack. 


\begin{DoxyCode}
1737 \{
1738   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1739   Ipv4Address source = newEntry.GetSourceAddress ();
1740   Ipv4Address nextHop = newEntry.GetNextHopAddress ();
1741   Ptr<Packet> packet = newEntry.GetPacket ()->Copy ();
1742   Ptr<Ipv4Route> route = newEntry.GetIpv4Route ();
1743   \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa1eb6ea60fdf9ba2cac2079a74ce1ca4}{m\_downTarget} (packet, source, nextHop, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a3e98f8b73e3020a96dffa8b9ddfc520b}{GetProtocolNumber} (), route);
1744   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1745 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 96




Here is the caller graph for this function\+:
% FIG 97


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Send\+Reply@{Send\+Reply}}
\index{Send\+Reply@{Send\+Reply}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Send\+Reply(\+Ptr$<$ Packet $>$ packet, Ipv4\+Address source, Ipv4\+Address next\+Hop, Ptr$<$ Ipv4\+Route $>$ route)}{SendReply(Ptr< Packet > packet, Ipv4Address source, Ipv4Address nextHop, Ptr< Ipv4Route > route)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Send\+Reply (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Ipv4\+Address}}]{source, }
\item[{{\bf Ipv4\+Address}}]{next\+Hop, }
\item[{{\bf Ptr}$<$ {\bf Ipv4\+Route} $>$}]{route}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a69e03d265224fc60bf135b2496d97f04}{}\label{classns3_1_1dsr_1_1DsrRouting_a69e03d265224fc60bf135b2496d97f04}
Send the route reply back to the request originator with the cumulated route


\begin{DoxyParams}{Parameters}
{\em packet} & the original packet \\
\hline
{\em source} & I\+Pv4 address of the source (i.\+e. request originator) \\
\hline
{\em next\+Hop} & I\+Pv4 address of the next hop \\
\hline
{\em route} & Route \\
\hline
\end{DoxyParams}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000029}{Todo}]New \hyperlink{classns3_1_1dsr_1_1DsrNetworkQueueEntry}{Dsr\+Network\+Queue\+Entry} \end{DoxyRefDesc}

\begin{DoxyCode}
3198 \{
3199   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << source << nextHop);
3200   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (!\hyperlink{classns3_1_1dsr_1_1DsrRouting_aa1eb6ea60fdf9ba2cac2079a74ce1ca4}{m\_downTarget}.\hyperlink{classns3_1_1Callback_aa8e27826badbf37f84763f36f70d9b54}{IsNull} (), \textcolor{stringliteral}{"Error, DsrRouting cannot send
       downward"});
3201 
3202   Ptr<NetDevice> dev = \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa42c1b9ee27c8168a2141d3d032006c3}{m\_ipv4}->GetNetDevice (\hyperlink{classns3_1_1dsr_1_1DsrRouting_aa42c1b9ee27c8168a2141d3d032006c3}{m\_ipv4}->GetInterfaceForAddress (
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}));
3203   route->SetOutputDevice (dev);
3204   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"The output device "} << dev << \textcolor{stringliteral}{" packet is: "} << *packet);
3205 
3206   uint32\_t priority = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a67d111b0188b6e2210d1b4782820f8e3}{GetPriority} (\hyperlink{namespacens3_1_1dsr_a7c80bcec67d78dc149a0e503014d07c5abeaa53bf31d961c221e4e377ef6022f2}{DSR\_CONTROL\_PACKET});
3207   std::map<uint32\_t, Ptr<dsr::DsrNetworkQueue> >::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4606c3dfb1099afbfe1e7cd1d1c3c8ee}{m\_priorityQueue}.find (
      priority);
3208   Ptr<dsr::DsrNetworkQueue> dsrNetworkQueue = i->second;
3209   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Inserting into priority queue number: "} << priority);
3210 
3211   \textcolor{comment}{//m\_downTarget (packet, source, nextHop, GetProtocolNumber (), route);}
3212 
3214  DsrNetworkQueueEntry newEntry (packet, source, nextHop, \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} (), route);
3215  \textcolor{keywordflow}{if} (dsrNetworkQueue->Enqueue (newEntry))
3216    \{
3217      \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa518edb174bccce1062304404424c6e0}{Scheduler} (priority);
3218    \}
3219  \textcolor{keywordflow}{else}
3220    \{
3221      \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Packet dropped as dsr network queue is full"});
3222    \}
3223 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 98




Here is the caller graph for this function\+:
% FIG 99


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Send\+Request@{Send\+Request}}
\index{Send\+Request@{Send\+Request}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Send\+Request(\+Ptr$<$ Packet $>$ packet, Ipv4\+Address source)}{SendRequest(Ptr< Packet > packet, Ipv4Address source)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Send\+Request (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Ipv4\+Address}}]{source}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a21496638c09e75ea310e876135d0bf64}{}\label{classns3_1_1dsr_1_1DsrRouting_a21496638c09e75ea310e876135d0bf64}


Forward the route request if the node is not the destination. 


\begin{DoxyParams}{Parameters}
{\em packet} & the original packet \\
\hline
{\em source} & address \\
\hline
\end{DoxyParams}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000028}{Todo}]New \hyperlink{classns3_1_1dsr_1_1DsrNetworkQueueEntry}{Dsr\+Network\+Queue\+Entry} \end{DoxyRefDesc}

\begin{DoxyCode}
3093 \{
3094   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << source);
3095 
3096   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (!\hyperlink{classns3_1_1dsr_1_1DsrRouting_aa1eb6ea60fdf9ba2cac2079a74ce1ca4}{m\_downTarget}.\hyperlink{classns3_1_1Callback_aa8e27826badbf37f84763f36f70d9b54}{IsNull} (), \textcolor{stringliteral}{"Error, DsrRouting cannot send
       downward"});
3097   \textcolor{comment}{/*}
3098 \textcolor{comment}{   * The destination address here is directed broadcast address}
3099 \textcolor{comment}{   */}
3100   uint32\_t priority = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a67d111b0188b6e2210d1b4782820f8e3}{GetPriority} (\hyperlink{namespacens3_1_1dsr_a7c80bcec67d78dc149a0e503014d07c5abeaa53bf31d961c221e4e377ef6022f2}{DSR\_CONTROL\_PACKET});
3101   std::map<uint32\_t, Ptr<dsr::DsrNetworkQueue> >::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4606c3dfb1099afbfe1e7cd1d1c3c8ee}{m\_priorityQueue}.find (
      priority);
3102   Ptr<dsr::DsrNetworkQueue> dsrNetworkQueue = i->second;
3103   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Inserting into priority queue number: "} << priority);
3104 
3105   \textcolor{comment}{//m\_downTarget (packet, source, m\_broadcast, GetProtocolNumber (), 0);}
3106 
3108  DsrNetworkQueueEntry newEntry (packet, source, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a52d4ef78c13236c73c60db85c0088ff6}{m\_broadcast}, 
      \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} (), 0);
3109  \textcolor{keywordflow}{if} (dsrNetworkQueue->Enqueue (newEntry))
3110    \{
3111      \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa518edb174bccce1062304404424c6e0}{Scheduler} (priority);
3112    \}
3113  \textcolor{keywordflow}{else}
3114    \{
3115      \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Packet dropped as dsr network queue is full"});
3116    \}
3117 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 100




Here is the caller graph for this function\+:
% FIG 101


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Send\+Rerr\+When\+Breaks\+Link\+To\+Next\+Hop@{Send\+Rerr\+When\+Breaks\+Link\+To\+Next\+Hop}}
\index{Send\+Rerr\+When\+Breaks\+Link\+To\+Next\+Hop@{Send\+Rerr\+When\+Breaks\+Link\+To\+Next\+Hop}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Send\+Rerr\+When\+Breaks\+Link\+To\+Next\+Hop(\+Ipv4\+Address next\+Hop, uint8\+\_\+t protocol)}{SendRerrWhenBreaksLinkToNextHop(Ipv4Address nextHop, uint8_t protocol)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Send\+Rerr\+When\+Breaks\+Link\+To\+Next\+Hop (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{next\+Hop, }
\item[{uint8\+\_\+t}]{protocol}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a0783bd1b2eb30dad7e578236cdac1388}{}\label{classns3_1_1dsr_1_1DsrRouting_a0783bd1b2eb30dad7e578236cdac1388}


Send the route error message when the link breaks to the next hop. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Send\+Unreach\+Error@{Send\+Unreach\+Error}}
\index{Send\+Unreach\+Error@{Send\+Unreach\+Error}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Send\+Unreach\+Error(\+Ipv4\+Address unreach\+Node, Ipv4\+Address destination, Ipv4\+Address original\+Dst, uint8\+\_\+t salvage, uint8\+\_\+t protocol)}{SendUnreachError(Ipv4Address unreachNode, Ipv4Address destination, Ipv4Address originalDst, uint8_t salvage, uint8_t protocol)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Send\+Unreach\+Error (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{unreach\+Node, }
\item[{{\bf Ipv4\+Address}}]{destination, }
\item[{{\bf Ipv4\+Address}}]{original\+Dst, }
\item[{uint8\+\_\+t}]{salvage, }
\item[{uint8\+\_\+t}]{protocol}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_ace5dd08bac91fa199ddfac7e81125a62}{}\label{classns3_1_1dsr_1_1DsrRouting_ace5dd08bac91fa199ddfac7e81125a62}


This function is responsible for sending error packets in case of break link to next hop. 

When found a route and use it, Use\+Extends to the link cache

\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000023}{Todo}]New \hyperlink{classns3_1_1dsr_1_1DsrNetworkQueueEntry}{Dsr\+Network\+Queue\+Entry} \end{DoxyRefDesc}

\begin{DoxyCode}
1265 \{
1266   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << unreachNode << destination << originalDst << (uint32\_t)salvage <<
       (uint32\_t)protocol);
1267   DsrRoutingHeader dsrRoutingHeader;
1268   dsrRoutingHeader.SetNextHeader (protocol);
1269   dsrRoutingHeader.SetMessageType (1);
1270   dsrRoutingHeader.SetSourceId (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4593e50d5f36e9b9b013fe0422067c44}{GetIDfromIP} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}));
1271   dsrRoutingHeader.SetDestId (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4593e50d5f36e9b9b013fe0422067c44}{GetIDfromIP} (destination));
1272 
1273   DsrOptionRerrUnreachHeader rerrUnreachHeader;
1274   rerrUnreachHeader.SetErrorType (1);
1275   rerrUnreachHeader.SetErrorSrc (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress});
1276   rerrUnreachHeader.SetUnreachNode (unreachNode);
1277   rerrUnreachHeader.SetErrorDst (destination);
1278   rerrUnreachHeader.SetOriginalDst (originalDst);
1279   rerrUnreachHeader.SetSalvage (salvage);                       \textcolor{comment}{// Set the value about whether to salvage a
       packet or not}
1280   uint8\_t rerrLength = rerrUnreachHeader.GetLength ();
1281 
1282 
1283   DsrRouteCacheEntry toDst;
1284   \textcolor{keywordtype}{bool} findRoute = \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->LookupRoute (destination, toDst);
1285   \textcolor{comment}{// Queue the packet if there is no route pre-existing}
1286   Ptr<Packet> newPacket = Create<Packet> ();
1287   \textcolor{keywordflow}{if} (!findRoute)
1288     \{
1289       \textcolor{keywordflow}{if} (destination == \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress})
1290       \{
1291         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"We are the error source, send request to original dst "} << originalDst);
1292         \textcolor{comment}{// Send error request message if we are the source node}
1293         \hyperlink{classns3_1_1dsr_1_1DsrRouting_ae2100978eb9447540ceceeda17e95cea}{SendErrorRequest} (rerrUnreachHeader, protocol);
1294       \}
1295       \textcolor{keywordflow}{else} 
1296       \{
1297         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds ()
1298                      << \textcolor{stringliteral}{"s "} << \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress} << \textcolor{stringliteral}{" there is no route for this packet, queue
       the packet"});
1299 
1300         dsrRoutingHeader.SetPayloadLength (rerrLength + 2);
1301         dsrRoutingHeader.AddDsrOption (rerrUnreachHeader);
1302         newPacket->AddHeader (dsrRoutingHeader);
1303         Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = newPacket->Copy ();
1304         \textcolor{comment}{// Save the error packet in the error buffer}
1305         DsrErrorBuffEntry newEntry (p, destination, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, unreachNode, 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a1f89794801db0336d92e4ca85fbc09a7}{m\_sendBufferTimeout}, protocol);
1306         \textcolor{keywordtype}{bool} result = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a802e15bf588fd1e9ccd401221461397a}{m\_errorBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrErrorBuffer_a509601131629af3b0b4881f88d9b672e}{Enqueue} (newEntry);                    \textcolor{comment}{// Enqueue
       the packet in send buffer}
1307         \textcolor{keywordflow}{if} (result)
1308           \{
1309             \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds ()
1310                          << \textcolor{stringliteral}{"s Add packet PID: "} << p->GetUid () << \textcolor{stringliteral}{" to queue. Packet: "} << *
      \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p});
1311             \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Send RREQ to"} << destination);
1312             \textcolor{keywordflow}{if} ((\hyperlink{classns3_1_1dsr_1_1DsrRouting_a47174823b0622573b681afc40d6ea558}{m\_addressReqTimer}.find (destination) == 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a47174823b0622573b681afc40d6ea558}{m\_addressReqTimer}.end ()) && (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a0936df610f90f7e79c24a2a8cdea6c14}{m\_nonPropReqTimer}.find (destination) == 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a0936df610f90f7e79c24a2a8cdea6c14}{m\_nonPropReqTimer}.end ()))
1313               \{
1314                 \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"When there is no existing route request for "} << destination << \textcolor{stringliteral}{
      ", initialize one"});
1315                 \textcolor{comment}{/*}
1316 \textcolor{comment}{                 * Call the send request function, it will update the request table entry and ttl there}
1317 \textcolor{comment}{                 */}
1318                 \hyperlink{classns3_1_1dsr_1_1DsrRouting_a74777d1806e768fccc1c2fe169b42c98}{SendInitialRequest} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, destination, protocol);
1319               \}
1320           \}
1321       \}
1322     \}
1323   \textcolor{keywordflow}{else}
1324     \{
1325       std::vector<Ipv4Address> nodeList = toDst.GetVector ();
1326       Ipv4Address nextHop = \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa1b16658c14499af76ca7dd69c034f22}{SearchNextHop} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, nodeList);
1327       \textcolor{keywordflow}{if} (nextHop == \textcolor{stringliteral}{"0.0.0.0"})
1328         \{
1329           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The route is not right"});
1330           \hyperlink{classns3_1_1dsr_1_1DsrRouting_ae70ab39db551d1d81afc081196f78017}{PacketNewRoute} (newPacket, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, destination, protocol);
1331           \textcolor{keywordflow}{return};
1332         \}
1333       DsrOptionSRHeader sourceRoute;
1334       sourceRoute.SetNodesAddress (nodeList);
1336       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->IsLinkCache ())
1337         \{
1338           \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->UseExtends (nodeList);
1339         \}
1340       sourceRoute.SetSegmentsLeft ((nodeList.size () - 2));
1341       uint8\_t srLength = sourceRoute.GetLength ();
1342       uint8\_t length = (srLength + rerrLength);
1343 
1344       dsrRoutingHeader.SetPayloadLength (uint16\_t (length) + 4);
1345       dsrRoutingHeader.AddDsrOption (rerrUnreachHeader);
1346       dsrRoutingHeader.AddDsrOption (sourceRoute);
1347       newPacket->AddHeader (dsrRoutingHeader);
1348 
1349       \hyperlink{classns3_1_1dsr_1_1DsrRouting_a8a726fb52558a1a8172a5bd5b8cdb072}{SetRoute} (nextHop, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress});
1350       Ptr<NetDevice> dev = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a0443d48172143cafa1d0491e35f3fbaf}{m\_ip}->GetNetDevice (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a0443d48172143cafa1d0491e35f3fbaf}{m\_ip}->GetInterfaceForAddress (
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}));
1351       \hyperlink{classns3_1_1dsr_1_1DsrRouting_ab4c16d56044159989e52ad33c0afed2b}{m\_ipv4Route}->SetOutputDevice (dev);
1352       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Send the packet to the next hop address "} << nextHop << \textcolor{stringliteral}{" from "} << 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress} << \textcolor{stringliteral}{" with the size "} << newPacket->GetSize ());
1353 
1354       uint32\_t priority = \hyperlink{classns3_1_1dsr_1_1DsrRouting_a67d111b0188b6e2210d1b4782820f8e3}{GetPriority} (\hyperlink{namespacens3_1_1dsr_a7c80bcec67d78dc149a0e503014d07c5abeaa53bf31d961c221e4e377ef6022f2}{DSR\_CONTROL\_PACKET});
1355       std::map<uint32\_t, Ptr<dsr::DsrNetworkQueue> >::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4606c3dfb1099afbfe1e7cd1d1c3c8ee}{m\_priorityQueue}.find (priority);
1356       Ptr<dsr::DsrNetworkQueue> dsrNetworkQueue = i->second;
1357       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Will be inserting into priority queue "} << dsrNetworkQueue << \textcolor{stringliteral}{" number: "} 
      << priority);
1358 
1359       \textcolor{comment}{//m\_downTarget (newPacket, m\_mainAddress, nextHop, GetProtocolNumber (), m\_ipv4Route);}
1360 
1362      DsrNetworkQueueEntry newEntry (newPacket, \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress}, nextHop, 
      \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} (), \hyperlink{classns3_1_1dsr_1_1DsrRouting_ab4c16d56044159989e52ad33c0afed2b}{m\_ipv4Route});
1363 
1364      \textcolor{keywordflow}{if} (dsrNetworkQueue->Enqueue (newEntry))
1365        \{
1366          \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa518edb174bccce1062304404424c6e0}{Scheduler} (priority);
1367        \}
1368      \textcolor{keywordflow}{else}
1369        \{
1370          \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Packet dropped as dsr network queue is full"});
1371        \}
1372     \}
1373 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 102




Here is the caller graph for this function\+:
% FIG 103


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Set\+Down\+Target@{Set\+Down\+Target}}
\index{Set\+Down\+Target@{Set\+Down\+Target}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Set\+Down\+Target(\+Ip\+L4\+Protocol\+::\+Down\+Target\+Callback callback)}{SetDownTarget(IpL4Protocol::DownTargetCallback callback)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Set\+Down\+Target (
\begin{DoxyParamCaption}
\item[{{\bf Ip\+L4\+Protocol\+::\+Down\+Target\+Callback}}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a3831a9cac1a24f243f81e770ae4b9587}{}\label{classns3_1_1dsr_1_1DsrRouting_a3831a9cac1a24f243f81e770ae4b9587}
This method allows a caller to set the current down target callback set for this L4 protocol (I\+Pv4 case)


\begin{DoxyParams}{Parameters}
{\em cb} & current \hyperlink{classns3_1_1Callback}{Callback} for the L4 protocol \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1IpL4Protocol_a9fc5e8e30a16bdc87623fa2ebc981af3}{ns3\+::\+Ip\+L4\+Protocol}.


\begin{DoxyCode}
3500 \{
3501   \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa1eb6ea60fdf9ba2cac2079a74ce1ca4}{m\_downTarget} = callback;
3502 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 104


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Set\+Down\+Target6@{Set\+Down\+Target6}}
\index{Set\+Down\+Target6@{Set\+Down\+Target6}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Set\+Down\+Target6(\+Ip\+L4\+Protocol\+::\+Down\+Target\+Callback6 callback)}{SetDownTarget6(IpL4Protocol::DownTargetCallback6 callback)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Set\+Down\+Target6 (
\begin{DoxyParamCaption}
\item[{{\bf Ip\+L4\+Protocol\+::\+Down\+Target\+Callback6}}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a184a0f635df5cf3dac67c3eb97452dc8}{}\label{classns3_1_1dsr_1_1DsrRouting_a184a0f635df5cf3dac67c3eb97452dc8}
This method allows a caller to set the current down target callback set for this L4 protocol (I\+Pv6 case)


\begin{DoxyParams}{Parameters}
{\em cb} & current \hyperlink{classns3_1_1Callback}{Callback} for the L4 protocol \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1IpL4Protocol_a2c3427eada095f3ae9a5e78fe6523e1e}{ns3\+::\+Ip\+L4\+Protocol}.


\begin{DoxyCode}
3506 \{
3507   \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Unimplemented"});
3508 \}
\end{DoxyCode}
\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Set\+Node@{Set\+Node}}
\index{Set\+Node@{Set\+Node}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Set\+Node(\+Ptr$<$ Node $>$ node)}{SetNode(Ptr< Node > node)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Set\+Node (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a0edfde42e4b79a1e04e186cc732360b9}{}\label{classns3_1_1dsr_1_1DsrRouting_a0edfde42e4b79a1e04e186cc732360b9}


Set the node. 


\begin{DoxyParams}{Parameters}
{\em node} & the node to set \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
574 \{
575   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac27df0103a40973f0a3f78af0092c60d}{m\_node} = node;
576 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 105


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Set\+Passive\+Buffer@{Set\+Passive\+Buffer}}
\index{Set\+Passive\+Buffer@{Set\+Passive\+Buffer}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Set\+Passive\+Buffer(\+Ptr$<$ dsr\+::\+Dsr\+Passive\+Buffer $>$ r)}{SetPassiveBuffer(Ptr< dsr::DsrPassiveBuffer > r)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Set\+Passive\+Buffer (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf dsr\+::\+Dsr\+Passive\+Buffer} $>$}]{r}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a10d09f5b58b469d0a7c92926f61dd9ab}{}\label{classns3_1_1dsr_1_1DsrRouting_a10d09f5b58b469d0a7c92926f61dd9ab}


Set the node. 


\begin{DoxyParams}{Parameters}
{\em r} & the passive buffer to set \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
612 \{
613   \textcolor{comment}{// / Set the request table to use}
614   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac0404985fc04df7f5b8f53ff1e487079}{m\_passiveBuffer} = \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p};
615 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 106


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Set\+Request\+Table@{Set\+Request\+Table}}
\index{Set\+Request\+Table@{Set\+Request\+Table}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Set\+Request\+Table(\+Ptr$<$ dsr\+::\+Dsr\+Rreq\+Table $>$ r)}{SetRequestTable(Ptr< dsr::DsrRreqTable > r)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Set\+Request\+Table (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf dsr\+::\+Dsr\+Rreq\+Table} $>$}]{r}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a62fbce24642000a21a4e7c783f77c205}{}\label{classns3_1_1dsr_1_1DsrRouting_a62fbce24642000a21a4e7c783f77c205}


Set the node. 


\begin{DoxyParams}{Parameters}
{\em r} & the request table to set \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
599 \{
600   \textcolor{comment}{// / Set the request table to use}
601   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ae9ec27743735fa2d59cc5190961d1942}{m\_rreqTable} = q;
602 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 107


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Set\+Route@{Set\+Route}}
\index{Set\+Route@{Set\+Route}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Set\+Route(\+Ipv4\+Address next\+Hop, Ipv4\+Address src\+Address)}{SetRoute(Ipv4Address nextHop, Ipv4Address srcAddress)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv4\+Route} $>$ ns3\+::dsr\+::\+Dsr\+Routing\+::\+Set\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{next\+Hop, }
\item[{{\bf Ipv4\+Address}}]{src\+Address}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a8a726fb52558a1a8172a5bd5b8cdb072}{}\label{classns3_1_1dsr_1_1DsrRouting_a8a726fb52558a1a8172a5bd5b8cdb072}


Set the route to use for data packets, used by the option headers when sending data/control packets. 


\begin{DoxyParams}{Parameters}
{\em next\+Hop} & next hop I\+Pv4 address \\
\hline
{\em src\+Address} & I\+Pv4 address of the source \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the route 
\end{DoxyReturn}

\begin{DoxyCode}
760 \{
761   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << nextHop << srcAddress);
762   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ab4c16d56044159989e52ad33c0afed2b}{m\_ipv4Route} = Create<Ipv4Route> ();
763   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ab4c16d56044159989e52ad33c0afed2b}{m\_ipv4Route}->SetDestination (nextHop);
764   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ab4c16d56044159989e52ad33c0afed2b}{m\_ipv4Route}->SetGateway (nextHop);
765   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ab4c16d56044159989e52ad33c0afed2b}{m\_ipv4Route}->SetSource (srcAddress);
766   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1dsr_1_1DsrRouting_ab4c16d56044159989e52ad33c0afed2b}{m\_ipv4Route};
767 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 108


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Set\+Route\+Cache@{Set\+Route\+Cache}}
\index{Set\+Route\+Cache@{Set\+Route\+Cache}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Set\+Route\+Cache(\+Ptr$<$ dsr\+::\+Dsr\+Route\+Cache $>$ r)}{SetRouteCache(Ptr< dsr::DsrRouteCache > r)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Set\+Route\+Cache (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf dsr\+::\+Dsr\+Route\+Cache} $>$}]{r}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_af61179a03e52ebee0822caac80a830ff}{}\label{classns3_1_1dsr_1_1DsrRouting_af61179a03e52ebee0822caac80a830ff}


Set the route cache. 


\begin{DoxyParams}{Parameters}
{\em r} & the route cache to set \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
586 \{
587   \textcolor{comment}{// / Set the route cache to use}
588   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache} = r;
589 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 109


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Start@{Start}}
\index{Start@{Start}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Start()}{Start()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Start (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_aa97c9bcf61e5623297563965740a8559}{}\label{classns3_1_1dsr_1_1DsrRouting_aa97c9bcf61e5623297563965740a8559}
T\+O\+DO whether this Send\+Rerr\+When\+Breaks\+Link\+To\+Next\+Hop is used or not 
\begin{DoxyCode}
425 \{
426   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \textcolor{stringliteral}{"Start DSR Routing protocol"});
427 
428   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"The number of network queues "} << \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa1952258d04f2ca8a0980d8436bca317}{m\_numPriorityQueues});
429   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa1952258d04f2ca8a0980d8436bca317}{m\_numPriorityQueues}; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
430     \{
431       \textcolor{comment}{// Set the network queue max size and the delay}
432       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"The network queue size "} << \hyperlink{classns3_1_1dsr_1_1DsrRouting_ab2edb0a37a59600e15dbb91b5683ad25}{m\_maxNetworkSize} << \textcolor{stringliteral}{" and the
       queue delay "} << \hyperlink{classns3_1_1dsr_1_1DsrRouting_a5bf0e688251f1587471745f4355203c1}{m\_maxNetworkDelay}.\hyperlink{classns3_1_1Time_a8f20d5c3b0902d7b4320982f340b57c8}{GetSeconds} ());
433       Ptr<dsr::DsrNetworkQueue> queue\_i = CreateObject<dsr::DsrNetworkQueue> (
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_ab2edb0a37a59600e15dbb91b5683ad25}{m\_maxNetworkSize},\hyperlink{classns3_1_1dsr_1_1DsrRouting_a5bf0e688251f1587471745f4355203c1}{m\_maxNetworkDelay});
434       std::pair<std::map<uint32\_t, Ptr<dsr::DsrNetworkQueue> >::iterator, \textcolor{keywordtype}{bool}> result\_i = 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4606c3dfb1099afbfe1e7cd1d1c3c8ee}{m\_priorityQueue}.insert (std::make\_pair (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, queue\_i));
435       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (result\_i.second, \textcolor{stringliteral}{"Error in creating queues"});
436     \}
437   Ptr<dsr::DsrRreqTable> rreqTable = CreateObject<dsr::DsrRreqTable> ();
438   \textcolor{comment}{// Set the initial hop limit}
439   rreqTable->SetInitHopLimit (\hyperlink{classns3_1_1dsr_1_1DsrRouting_acf9cc5a2ae446403b8b57f3340fac178}{m\_discoveryHopLimit});
440   \textcolor{comment}{// Configure the request table parameters}
441   rreqTable->SetRreqTableSize (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a8f6df12e2c9690f79943c2195af1be37}{m\_requestTableSize});
442   rreqTable->SetRreqIdSize (\hyperlink{classns3_1_1dsr_1_1DsrRouting_aac8b18967bf0bc05a7f0024ea55e99b1}{m\_requestTableIds});
443   rreqTable->SetUniqueRreqIdSize (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a14ef1332178e76768359c27a45db9624}{m\_maxRreqId});
444   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a62fbce24642000a21a4e7c783f77c205}{SetRequestTable} (rreqTable);
445   \textcolor{comment}{// Set the passive buffer parameters using just the send buffer parameters}
446   Ptr<dsr::DsrPassiveBuffer> passiveBuffer = CreateObject<dsr::DsrPassiveBuffer> ();
447   passiveBuffer->SetMaxQueueLen (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a5cf78026e2a25a4468c04745f4a10c13}{m\_maxSendBuffLen});
448   passiveBuffer->SetPassiveBufferTimeout (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a1f89794801db0336d92e4ca85fbc09a7}{m\_sendBufferTimeout});
449   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a10d09f5b58b469d0a7c92926f61dd9ab}{SetPassiveBuffer} (passiveBuffer);
450 
451   \textcolor{comment}{// Set the send buffer parameters}
452   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a887ae39d7060171753c0605d5c120549}{m\_sendBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrSendBuffer_a01d2c15d2f020c8f46b628426a98450f}{SetMaxQueueLen} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a5cf78026e2a25a4468c04745f4a10c13}{m\_maxSendBuffLen});
453   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a887ae39d7060171753c0605d5c120549}{m\_sendBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrSendBuffer_a3b036f56c257571ae3fa5b5a49b2a57b}{SetSendBufferTimeout} (
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a1f89794801db0336d92e4ca85fbc09a7}{m\_sendBufferTimeout});
454   \textcolor{comment}{// Set the error buffer parameters using just the send buffer parameters}
455   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a802e15bf588fd1e9ccd401221461397a}{m\_errorBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrErrorBuffer_a33d6346a6ae17ae2c4deb4eb78e265d4}{SetMaxQueueLen} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a5cf78026e2a25a4468c04745f4a10c13}{m\_maxSendBuffLen});
456   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a802e15bf588fd1e9ccd401221461397a}{m\_errorBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrErrorBuffer_a97b369b6d8af902f6249d9746e85f4e2}{SetErrorBufferTimeout} (
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a1f89794801db0336d92e4ca85fbc09a7}{m\_sendBufferTimeout});
457   \textcolor{comment}{// Set the maintenance buffer parameters}
458   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac9d28a64437fbe20a4228c9811f9fc27}{m\_maintainBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a1e52f7157e94aea3e44003e9da22e7ff}{SetMaxQueueLen} (
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a65f608e0cfba00495392f94938fc02c0}{m\_maxMaintainLen});
459   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac9d28a64437fbe20a4228c9811f9fc27}{m\_maintainBuffer}.\hyperlink{classns3_1_1dsr_1_1DsrMaintainBuffer_a480bdf66ecdb34f06413d76dcacd77e9}{SetMaintainBufferTimeout} (
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac6b1dffa9665af0d6a71aa7b947962ee}{m\_maxMaintainTime});
460   \textcolor{comment}{// Set the gratuitous reply table size}
461   \hyperlink{classns3_1_1dsr_1_1DsrRouting_a9208badf7697dda01917aa2034b0b59c}{m\_graReply}.\hyperlink{classns3_1_1dsr_1_1DsrGraReply_a9137731288aa4ea5e895ded38d85ffd0}{SetGraTableSize} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_aa22d7408adbcefde51113d45b83d415f}{m\_graReplyTableSize});
462 
463   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress} == Ipv4Address ())
464     \{
465       Ipv4Address loopback (\textcolor{stringliteral}{"127.0.0.1"});
466       \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa42c1b9ee27c8168a2141d3d032006c3}{m\_ipv4}->GetNInterfaces (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
467         \{
468           \textcolor{comment}{// Use primary address, if multiple}
469           Ipv4Address addr = \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa42c1b9ee27c8168a2141d3d032006c3}{m\_ipv4}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, 0).GetLocal ();
470           \hyperlink{classns3_1_1dsr_1_1DsrRouting_a52d4ef78c13236c73c60db85c0088ff6}{m\_broadcast} = \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa42c1b9ee27c8168a2141d3d032006c3}{m\_ipv4}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, 0).GetBroadcast ();
471           \textcolor{keywordflow}{if} (addr != loopback)
472             \{
473               \textcolor{comment}{/*}
474 \textcolor{comment}{               * Set dsr route cache}
475 \textcolor{comment}{               */}
476               Ptr<dsr::DsrRouteCache> routeCache = CreateObject<dsr::DsrRouteCache> ();
477               \textcolor{comment}{// Configure the path cache parameters}
478               routeCache->SetCacheType (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a07e25fa5f4aebf7b129a31853988045b}{m\_cacheType});
479               routeCache->SetSubRoute (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a83f7a7d54f8b078d987d46cf6edcd08e}{m\_subRoute});
480               routeCache->SetMaxCacheLen (\hyperlink{classns3_1_1dsr_1_1DsrRouting_afce2c0909aecc7dfe4528f7f6b042019}{m\_maxCacheLen});
481               routeCache->SetCacheTimeout (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a76d8abfedbda7429e983c407748400be}{m\_maxCacheTime});
482               routeCache->SetMaxEntriesEachDst (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a470ec4bd470cd1d802621752331d9916}{m\_maxEntriesEachDst});
483               \textcolor{comment}{// Parameters for link cache}
484               routeCache->SetStabilityDecrFactor (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a4a6db69db44738ae07289fa0993ac916}{m\_stabilityDecrFactor});
485               routeCache->SetStabilityIncrFactor (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a9c6b73944ece2adc5f06b5010d9e55f2}{m\_stabilityIncrFactor});
486               routeCache->SetInitStability (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a9b68bafde23cf10e425d341f91da3b5e}{m\_initStability});
487               routeCache->SetMinLifeTime (\hyperlink{classns3_1_1dsr_1_1DsrRouting_ad7daf5388ab1104e535b27bb4eae1421}{m\_minLifeTime});
488               routeCache->SetUseExtends (\hyperlink{classns3_1_1dsr_1_1DsrRouting_aa0a73bc163b0b32c84a5913ebbb62dc5}{m\_useExtends});
489               routeCache->ScheduleTimer ();
490               \textcolor{comment}{// The call back to handle link error and send error message to appropriate nodes}
492 \textcolor{comment}{}              \textcolor{comment}{// routeCache->SetCallback (MakeCallback (&DsrRouting::SendRerrWhenBreaksLinkToNextHop,
       this));}
493               \hyperlink{classns3_1_1dsr_1_1DsrRouting_af61179a03e52ebee0822caac80a830ff}{SetRouteCache} (routeCache);
494               \textcolor{comment}{// Set the main address as the current ip address}
495               \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress} = addr;
496 
497               \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa42c1b9ee27c8168a2141d3d032006c3}{m\_ipv4}->GetNetDevice (1)->SetPromiscReceiveCallback (
      \hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&\hyperlink{classns3_1_1dsr_1_1DsrRouting_a95d4ab6177fb07d4791a2ed82cd4a2bb}{DsrRouting::PromiscReceive}, \textcolor{keyword}{this}));
498 
499               \textcolor{comment}{// Allow neighbor manager use this interface for layer 2 feedback if possible}
500               Ptr<NetDevice> dev = \hyperlink{classns3_1_1dsr_1_1DsrRouting_aa42c1b9ee27c8168a2141d3d032006c3}{m\_ipv4}->GetNetDevice (\hyperlink{classns3_1_1dsr_1_1DsrRouting_aa42c1b9ee27c8168a2141d3d032006c3}{m\_ipv4}->GetInterfaceForAddress (addr))
      ;
501               Ptr<WifiNetDevice> wifi = dev->GetObject<WifiNetDevice> ();
502               \textcolor{keywordflow}{if} (wifi == 0)
503                 \{
504                   \textcolor{keywordflow}{break};
505                 \}
506               Ptr<WifiMac> mac = wifi->GetMac ();
507               \textcolor{keywordflow}{if} (mac == 0)
508                 \{
509                   \textcolor{keywordflow}{break};
510                 \}
511 
512               routeCache->AddArpCache (\hyperlink{classns3_1_1dsr_1_1DsrRouting_aa42c1b9ee27c8168a2141d3d032006c3}{m\_ipv4}->GetInterface (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})->GetArpCache ());
513               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Starting DSR on node "} << \hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress});
514               \textcolor{keywordflow}{break};
515             \}
516         \}
517       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{m\_mainAddress} != Ipv4Address () && 
      \hyperlink{classns3_1_1dsr_1_1DsrRouting_a52d4ef78c13236c73c60db85c0088ff6}{m\_broadcast} != Ipv4Address ());
518     \}
519 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 110




Here is the caller graph for this function\+:
% FIG 111


\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Update\+Route\+Entry@{Update\+Route\+Entry}}
\index{Update\+Route\+Entry@{Update\+Route\+Entry}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Update\+Route\+Entry(\+Ipv4\+Address dst)}{UpdateRouteEntry(Ipv4Address dst)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::dsr\+::\+Dsr\+Routing\+::\+Update\+Route\+Entry (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{dst}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_ab193dd688e4f334420a6ffcecf5598c5}{}\label{classns3_1_1dsr_1_1DsrRouting_ab193dd688e4f334420a6ffcecf5598c5}

\begin{DoxyCode}
678 \{
679   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->UpdateRouteEntry (dst);
680 \}
\end{DoxyCode}
\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!Use\+Extends@{Use\+Extends}}
\index{Use\+Extends@{Use\+Extends}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{Use\+Extends(\+Dsr\+Route\+Cache\+Entry\+::\+I\+P\+\_\+\+V\+E\+C\+T\+O\+R rt)}{UseExtends(DsrRouteCacheEntry::IP_VECTOR rt)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::dsr\+::\+Dsr\+Routing\+::\+Use\+Extends (
\begin{DoxyParamCaption}
\item[{{\bf Dsr\+Route\+Cache\+Entry\+::\+I\+P\+\_\+\+V\+E\+C\+T\+OR}}]{rt}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a1488df94bd0c30e86bce947bdab5b94e}{}\label{classns3_1_1dsr_1_1DsrRouting_a1488df94bd0c30e86bce947bdab5b94e}

\begin{DoxyCode}
648 \{
649   \hyperlink{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{m\_routeCache}->UseExtends (rt);
650 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+ack\+Id@{m\+\_\+ack\+Id}}
\index{m\+\_\+ack\+Id@{m\+\_\+ack\+Id}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+ack\+Id}{m_ackId}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+ack\+Id\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a38c5f8c952141a9853ae9f8ee116e292}{}\label{classns3_1_1dsr_1_1DsrRouting_a38c5f8c952141a9853ae9f8ee116e292}


The ack id assigned to each acknowledge. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+addresses@{m\+\_\+addresses}}
\index{m\+\_\+addresses@{m\+\_\+addresses}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+addresses}{m_addresses}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<${\bf Ipv4\+Address}$>$ ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+addresses\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a350fab49fe12651b852fa42363684990}{}\label{classns3_1_1dsr_1_1DsrRouting_a350fab49fe12651b852fa42363684990}


The bind ipv4 addresses with next hop, src, destination address in sequence. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+address\+Forward\+Cnt@{m\+\_\+address\+Forward\+Cnt}}
\index{m\+\_\+address\+Forward\+Cnt@{m\+\_\+address\+Forward\+Cnt}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+address\+Forward\+Cnt}{m_addressForwardCnt}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<${\bf Network\+Key}, uint32\+\_\+t$>$ ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+address\+Forward\+Cnt\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a5042f7e5df0470025fdb6023fcc24411}{}\label{classns3_1_1dsr_1_1DsrRouting_a5042f7e5df0470025fdb6023fcc24411}


Map network key + forward counts. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+address\+Forward\+Timer@{m\+\_\+address\+Forward\+Timer}}
\index{m\+\_\+address\+Forward\+Timer@{m\+\_\+address\+Forward\+Timer}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+address\+Forward\+Timer}{m_addressForwardTimer}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<${\bf Network\+Key}, {\bf Timer}$>$ ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+address\+Forward\+Timer\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a4a35b13cdca413ab5bc0b1b3b7b78907}{}\label{classns3_1_1dsr_1_1DsrRouting_a4a35b13cdca413ab5bc0b1b3b7b78907}


Map network key + forward timer. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+address\+Req\+Timer@{m\+\_\+address\+Req\+Timer}}
\index{m\+\_\+address\+Req\+Timer@{m\+\_\+address\+Req\+Timer}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+address\+Req\+Timer}{m_addressReqTimer}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<${\bf Ipv4\+Address}, {\bf Timer}$>$ ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+address\+Req\+Timer\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a47174823b0622573b681afc40d6ea558}{}\label{classns3_1_1dsr_1_1DsrRouting_a47174823b0622573b681afc40d6ea558}


Map IP address + R\+R\+EQ timer. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+blacklist\+Timeout@{m\+\_\+blacklist\+Timeout}}
\index{m\+\_\+blacklist\+Timeout@{m\+\_\+blacklist\+Timeout}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+blacklist\+Timeout}{m_blacklistTimeout}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+blacklist\+Timeout\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a07022fdee22444ddb4560c1f78bccaf2}{}\label{classns3_1_1dsr_1_1DsrRouting_a07022fdee22444ddb4560c1f78bccaf2}


The black list time out. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+broadcast@{m\+\_\+broadcast}}
\index{m\+\_\+broadcast@{m\+\_\+broadcast}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+broadcast}{m_broadcast}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Address} ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+broadcast\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a52d4ef78c13236c73c60db85c0088ff6}{}\label{classns3_1_1dsr_1_1DsrRouting_a52d4ef78c13236c73c60db85c0088ff6}


The broadcast IP address. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+broadcast\+Jitter@{m\+\_\+broadcast\+Jitter}}
\index{m\+\_\+broadcast\+Jitter@{m\+\_\+broadcast\+Jitter}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+broadcast\+Jitter}{m_broadcastJitter}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+broadcast\+Jitter\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_afb77e13fc791e5076ee1f8595b9c6617}{}\label{classns3_1_1dsr_1_1DsrRouting_afb77e13fc791e5076ee1f8595b9c6617}


The max time to delay route request broadcast. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+cache\+Type@{m\+\_\+cache\+Type}}
\index{m\+\_\+cache\+Type@{m\+\_\+cache\+Type}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+cache\+Type}{m_cacheType}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+cache\+Type\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a07e25fa5f4aebf7b129a31853988045b}{}\label{classns3_1_1dsr_1_1DsrRouting_a07e25fa5f4aebf7b129a31853988045b}


The type of route cache. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+clear\+List@{m\+\_\+clear\+List}}
\index{m\+\_\+clear\+List@{m\+\_\+clear\+List}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+clear\+List}{m_clearList}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<${\bf Ipv4\+Address}$>$ ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+clear\+List\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_add76dd26d3fd2721ab9be4520daa477f}{}\label{classns3_1_1dsr_1_1DsrRouting_add76dd26d3fd2721ab9be4520daa477f}


The node that is clear to send packet to. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+discovery\+Hop\+Limit@{m\+\_\+discovery\+Hop\+Limit}}
\index{m\+\_\+discovery\+Hop\+Limit@{m\+\_\+discovery\+Hop\+Limit}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+discovery\+Hop\+Limit}{m_discoveryHopLimit}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+discovery\+Hop\+Limit\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_acf9cc5a2ae446403b8b57f3340fac178}{}\label{classns3_1_1dsr_1_1DsrRouting_acf9cc5a2ae446403b8b57f3340fac178}


Maximum hops to go for route request. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+down\+Target@{m\+\_\+down\+Target}}
\index{m\+\_\+down\+Target@{m\+\_\+down\+Target}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+down\+Target}{m_downTarget}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ip\+L4\+Protocol\+::\+Down\+Target\+Callback} ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+down\+Target\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_aa1eb6ea60fdf9ba2cac2079a74ce1ca4}{}\label{classns3_1_1dsr_1_1DsrRouting_aa1eb6ea60fdf9ba2cac2079a74ce1ca4}


The callback for down layer. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+drop\+Trace@{m\+\_\+drop\+Trace}}
\index{m\+\_\+drop\+Trace@{m\+\_\+drop\+Trace}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+drop\+Trace}{m_dropTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+drop\+Trace\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_aacee2c8437c0b61579cfa7a420423e03}{}\label{classns3_1_1dsr_1_1DsrRouting_aacee2c8437c0b61579cfa7a420423e03}
The trace for drop, receive and send data packets \index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+error\+Buffer@{m\+\_\+error\+Buffer}}
\index{m\+\_\+error\+Buffer@{m\+\_\+error\+Buffer}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+error\+Buffer}{m_errorBuffer}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Dsr\+Error\+Buffer} ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+error\+Buffer\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a802e15bf588fd1e9ccd401221461397a}{}\label{classns3_1_1dsr_1_1DsrRouting_a802e15bf588fd1e9ccd401221461397a}


The error buffer to save the error messages. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+final\+Route@{m\+\_\+final\+Route}}
\index{m\+\_\+final\+Route@{m\+\_\+final\+Route}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+final\+Route}{m_finalRoute}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<${\bf Ipv4\+Address}$>$ ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+final\+Route\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_afb085eaa8fcab547a83f683ef5aef41a}{}\label{classns3_1_1dsr_1_1DsrRouting_afb085eaa8fcab547a83f683ef5aef41a}


The route cache. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+gra\+Reply@{m\+\_\+gra\+Reply}}
\index{m\+\_\+gra\+Reply@{m\+\_\+gra\+Reply}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+gra\+Reply}{m_graReply}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Dsr\+Gra\+Reply} ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+gra\+Reply\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a9208badf7697dda01917aa2034b0b59c}{}\label{classns3_1_1dsr_1_1DsrRouting_a9208badf7697dda01917aa2034b0b59c}


The gratuitous route reply. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+gra\+Reply\+Table\+Size@{m\+\_\+gra\+Reply\+Table\+Size}}
\index{m\+\_\+gra\+Reply\+Table\+Size@{m\+\_\+gra\+Reply\+Table\+Size}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+gra\+Reply\+Table\+Size}{m_graReplyTableSize}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+gra\+Reply\+Table\+Size\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_aa22d7408adbcefde51113d45b83d415f}{}\label{classns3_1_1dsr_1_1DsrRouting_aa22d7408adbcefde51113d45b83d415f}


Set the gratuitous reply table size. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+grat\+Reply\+Holdoff@{m\+\_\+grat\+Reply\+Holdoff}}
\index{m\+\_\+grat\+Reply\+Holdoff@{m\+\_\+grat\+Reply\+Holdoff}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+grat\+Reply\+Holdoff}{m_gratReplyHoldoff}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+grat\+Reply\+Holdoff\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a43f5d8b4569f2122788518584ce3ae77}{}\label{classns3_1_1dsr_1_1DsrRouting_a43f5d8b4569f2122788518584ce3ae77}


The max gratuitous reply hold off time. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+init\+Stability@{m\+\_\+init\+Stability}}
\index{m\+\_\+init\+Stability@{m\+\_\+init\+Stability}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+init\+Stability}{m_initStability}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+init\+Stability\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a9b68bafde23cf10e425d341f91da3b5e}{}\label{classns3_1_1dsr_1_1DsrRouting_a9b68bafde23cf10e425d341f91da3b5e}


The initial stability value for link cache. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+ip@{m\+\_\+ip}}
\index{m\+\_\+ip@{m\+\_\+ip}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+ip}{m_ip}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Ipv4}$>$ ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+ip\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a0443d48172143cafa1d0491e35f3fbaf}{}\label{classns3_1_1dsr_1_1DsrRouting_a0443d48172143cafa1d0491e35f3fbaf}


The ip ptr. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+ipv4@{m\+\_\+ipv4}}
\index{m\+\_\+ipv4@{m\+\_\+ipv4}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+ipv4}{m_ipv4}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Ipv4\+L3\+Protocol}$>$ ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+ipv4\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_aa42c1b9ee27c8168a2141d3d032006c3}{}\label{classns3_1_1dsr_1_1DsrRouting_aa42c1b9ee27c8168a2141d3d032006c3}


Ipv4l3\+Protocol. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+ipv4\+Route@{m\+\_\+ipv4\+Route}}
\index{m\+\_\+ipv4\+Route@{m\+\_\+ipv4\+Route}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+ipv4\+Route}{m_ipv4Route}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Ipv4\+Route}$>$ ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+ipv4\+Route\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_ab4c16d56044159989e52ad33c0afed2b}{}\label{classns3_1_1dsr_1_1DsrRouting_ab4c16d56044159989e52ad33c0afed2b}


\hyperlink{classns3_1_1Ipv4}{Ipv4} Route. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+link\+Ack@{m\+\_\+link\+Ack}}
\index{m\+\_\+link\+Ack@{m\+\_\+link\+Ack}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+link\+Ack}{m_linkAck}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+link\+Ack\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a216a52d8b579a034df948765d941d3a4}{}\label{classns3_1_1dsr_1_1DsrRouting_a216a52d8b579a034df948765d941d3a4}


define if we use link acknowledgement or not 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+link\+Ack\+Timeout@{m\+\_\+link\+Ack\+Timeout}}
\index{m\+\_\+link\+Ack\+Timeout@{m\+\_\+link\+Ack\+Timeout}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+link\+Ack\+Timeout}{m_linkAckTimeout}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+link\+Ack\+Timeout\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_ace1671263c7f09cd2523f1c81dc41631}{}\label{classns3_1_1dsr_1_1DsrRouting_ace1671263c7f09cd2523f1c81dc41631}


The timeout value for link acknowledge. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+link\+Ack\+Timer@{m\+\_\+link\+Ack\+Timer}}
\index{m\+\_\+link\+Ack\+Timer@{m\+\_\+link\+Ack\+Timer}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+link\+Ack\+Timer}{m_linkAckTimer}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<${\bf Link\+Key}, {\bf Timer}$>$ ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+link\+Ack\+Timer\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_ad532172035dbd4b038de0e94f4ce5ff6}{}\label{classns3_1_1dsr_1_1DsrRouting_ad532172035dbd4b038de0e94f4ce5ff6}


The timer for link acknowledgment. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+link\+Cnt@{m\+\_\+link\+Cnt}}
\index{m\+\_\+link\+Cnt@{m\+\_\+link\+Cnt}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+link\+Cnt}{m_linkCnt}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<${\bf Link\+Key}, uint32\+\_\+t$>$ ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+link\+Cnt\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a85ba159639f9bc13b3d8890458128a79}{}\label{classns3_1_1dsr_1_1DsrRouting_a85ba159639f9bc13b3d8890458128a79}


Map packet key + link forward counts. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+link\+Retries@{m\+\_\+link\+Retries}}
\index{m\+\_\+link\+Retries@{m\+\_\+link\+Retries}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+link\+Retries}{m_linkRetries}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+link\+Retries\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a78b9a7405d3c905f57fa5aba63984d26}{}\label{classns3_1_1dsr_1_1DsrRouting_a78b9a7405d3c905f57fa5aba63984d26}


\subsection*{of retries have been sent for link acknowledgment}

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+mac\+To\+Node\+Id\+Map@{m\+\_\+mac\+To\+Node\+Id\+Map}}
\index{m\+\_\+mac\+To\+Node\+Id\+Map@{m\+\_\+mac\+To\+Node\+Id\+Map}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+mac\+To\+Node\+Id\+Map}{m_macToNodeIdMap}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<$std\+::string, uint32\+\_\+t$>$ ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+mac\+To\+Node\+Id\+Map\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_aadd597196a7816f0eca78f213a3aae44}{}\label{classns3_1_1dsr_1_1DsrRouting_aadd597196a7816f0eca78f213a3aae44}


The map of mac address to node id. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+main\+Address@{m\+\_\+main\+Address}}
\index{m\+\_\+main\+Address@{m\+\_\+main\+Address}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+main\+Address}{m_mainAddress}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Address} ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+main\+Address\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}{}\label{classns3_1_1dsr_1_1DsrRouting_a73182b5edee2d8460f28855e058fc9a0}


Our own Ip address. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+maintain\+Buffer@{m\+\_\+maintain\+Buffer}}
\index{m\+\_\+maintain\+Buffer@{m\+\_\+maintain\+Buffer}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+maintain\+Buffer}{m_maintainBuffer}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Dsr\+Maintain\+Buffer} ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+maintain\+Buffer\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_ac9d28a64437fbe20a4228c9811f9fc27}{}\label{classns3_1_1dsr_1_1DsrRouting_ac9d28a64437fbe20a4228c9811f9fc27}


The declaration of maintain buffer. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+max\+Cache\+Len@{m\+\_\+max\+Cache\+Len}}
\index{m\+\_\+max\+Cache\+Len@{m\+\_\+max\+Cache\+Len}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Cache\+Len}{m_maxCacheLen}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+max\+Cache\+Len\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_afce2c0909aecc7dfe4528f7f6b042019}{}\label{classns3_1_1dsr_1_1DsrRouting_afce2c0909aecc7dfe4528f7f6b042019}


Max \# of cache entries for route cache. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+max\+Cache\+Time@{m\+\_\+max\+Cache\+Time}}
\index{m\+\_\+max\+Cache\+Time@{m\+\_\+max\+Cache\+Time}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Cache\+Time}{m_maxCacheTime}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+max\+Cache\+Time\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a76d8abfedbda7429e983c407748400be}{}\label{classns3_1_1dsr_1_1DsrRouting_a76d8abfedbda7429e983c407748400be}


Max time for caching the route cache entry. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+max\+Entries\+Each\+Dst@{m\+\_\+max\+Entries\+Each\+Dst}}
\index{m\+\_\+max\+Entries\+Each\+Dst@{m\+\_\+max\+Entries\+Each\+Dst}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Entries\+Each\+Dst}{m_maxEntriesEachDst}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+max\+Entries\+Each\+Dst\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a470ec4bd470cd1d802621752331d9916}{}\label{classns3_1_1dsr_1_1DsrRouting_a470ec4bd470cd1d802621752331d9916}


Max number of route entries to save for each destination. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+max\+Maintain\+Len@{m\+\_\+max\+Maintain\+Len}}
\index{m\+\_\+max\+Maintain\+Len@{m\+\_\+max\+Maintain\+Len}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Maintain\+Len}{m_maxMaintainLen}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+max\+Maintain\+Len\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a65f608e0cfba00495392f94938fc02c0}{}\label{classns3_1_1dsr_1_1DsrRouting_a65f608e0cfba00495392f94938fc02c0}


Max \# of entries for maintainance buffer. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+max\+Maintain\+Time@{m\+\_\+max\+Maintain\+Time}}
\index{m\+\_\+max\+Maintain\+Time@{m\+\_\+max\+Maintain\+Time}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Maintain\+Time}{m_maxMaintainTime}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+max\+Maintain\+Time\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_ac6b1dffa9665af0d6a71aa7b947962ee}{}\label{classns3_1_1dsr_1_1DsrRouting_ac6b1dffa9665af0d6a71aa7b947962ee}


\hyperlink{classns3_1_1Time}{Time} out for maintainance buffer. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+max\+Maint\+Rexmt@{m\+\_\+max\+Maint\+Rexmt}}
\index{m\+\_\+max\+Maint\+Rexmt@{m\+\_\+max\+Maint\+Rexmt}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Maint\+Rexmt}{m_maxMaintRexmt}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+max\+Maint\+Rexmt\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_aca44a3d45b57be61ec3e41774f20c1fb}{}\label{classns3_1_1dsr_1_1DsrRouting_aca44a3d45b57be61ec3e41774f20c1fb}


Maximum number of retransmissions of data packets. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+max\+Network\+Delay@{m\+\_\+max\+Network\+Delay}}
\index{m\+\_\+max\+Network\+Delay@{m\+\_\+max\+Network\+Delay}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Network\+Delay}{m_maxNetworkDelay}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+max\+Network\+Delay\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a5bf0e688251f1587471745f4355203c1}{}\label{classns3_1_1dsr_1_1DsrRouting_a5bf0e688251f1587471745f4355203c1}


Maximum network delay. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+max\+Network\+Size@{m\+\_\+max\+Network\+Size}}
\index{m\+\_\+max\+Network\+Size@{m\+\_\+max\+Network\+Size}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Network\+Size}{m_maxNetworkSize}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+max\+Network\+Size\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_ab2edb0a37a59600e15dbb91b5683ad25}{}\label{classns3_1_1dsr_1_1DsrRouting_ab2edb0a37a59600e15dbb91b5683ad25}


Maximum network queue size. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+max\+Request\+Period@{m\+\_\+max\+Request\+Period}}
\index{m\+\_\+max\+Request\+Period@{m\+\_\+max\+Request\+Period}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Request\+Period}{m_maxRequestPeriod}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+max\+Request\+Period\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_abce8e7bae58dada0db217ca294cb4c6e}{}\label{classns3_1_1dsr_1_1DsrRouting_abce8e7bae58dada0db217ca294cb4c6e}


The max request period. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+max\+Rreq\+Id@{m\+\_\+max\+Rreq\+Id}}
\index{m\+\_\+max\+Rreq\+Id@{m\+\_\+max\+Rreq\+Id}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Rreq\+Id}{m_maxRreqId}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+max\+Rreq\+Id\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a14ef1332178e76768359c27a45db9624}{}\label{classns3_1_1dsr_1_1DsrRouting_a14ef1332178e76768359c27a45db9624}


The max number of request ids for a single destination. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+max\+Rreq\+Time@{m\+\_\+max\+Rreq\+Time}}
\index{m\+\_\+max\+Rreq\+Time@{m\+\_\+max\+Rreq\+Time}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Rreq\+Time}{m_maxRreqTime}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+max\+Rreq\+Time\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a8f44b1800a0eff487b8490c65cee2d0a}{}\label{classns3_1_1dsr_1_1DsrRouting_a8f44b1800a0eff487b8490c65cee2d0a}


Max time for caching the route request entry. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+max\+Salvage\+Count@{m\+\_\+max\+Salvage\+Count}}
\index{m\+\_\+max\+Salvage\+Count@{m\+\_\+max\+Salvage\+Count}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Salvage\+Count}{m_maxSalvageCount}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+max\+Salvage\+Count\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a89f7e66d9f1bd83433b004876acf4a45}{}\label{classns3_1_1dsr_1_1DsrRouting_a89f7e66d9f1bd83433b004876acf4a45}


Maximum \# times to salvage a packet. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+max\+Send\+Buff\+Len@{m\+\_\+max\+Send\+Buff\+Len}}
\index{m\+\_\+max\+Send\+Buff\+Len@{m\+\_\+max\+Send\+Buff\+Len}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Send\+Buff\+Len}{m_maxSendBuffLen}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+max\+Send\+Buff\+Len\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a5cf78026e2a25a4468c04745f4a10c13}{}\label{classns3_1_1dsr_1_1DsrRouting_a5cf78026e2a25a4468c04745f4a10c13}


The maximum number of packets that we allow a routing protocol to buffer. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+min\+Life\+Time@{m\+\_\+min\+Life\+Time}}
\index{m\+\_\+min\+Life\+Time@{m\+\_\+min\+Life\+Time}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+min\+Life\+Time}{m_minLifeTime}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+min\+Life\+Time\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_ad7daf5388ab1104e535b27bb4eae1421}{}\label{classns3_1_1dsr_1_1DsrRouting_ad7daf5388ab1104e535b27bb4eae1421}


The min life time. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+network\+Queue@{m\+\_\+network\+Queue}}
\index{m\+\_\+network\+Queue@{m\+\_\+network\+Queue}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+network\+Queue}{m_networkQueue}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Dsr\+Network\+Queue} ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+network\+Queue\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a4a59e341508820cdc2e46bcc7f7db59c}{}\label{classns3_1_1dsr_1_1DsrRouting_a4a59e341508820cdc2e46bcc7f7db59c}


The network queue. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+node@{m\+\_\+node}}
\index{m\+\_\+node@{m\+\_\+node}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+node}{m_node}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Node}$>$ ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+node\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_ac27df0103a40973f0a3f78af0092c60d}{}\label{classns3_1_1dsr_1_1DsrRouting_ac27df0103a40973f0a3f78af0092c60d}


The node ptr. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+node\+Traversal\+Time@{m\+\_\+node\+Traversal\+Time}}
\index{m\+\_\+node\+Traversal\+Time@{m\+\_\+node\+Traversal\+Time}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+node\+Traversal\+Time}{m_nodeTraversalTime}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+node\+Traversal\+Time\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a4c406057009653878e8cdf3e3a7f2106}{}\label{classns3_1_1dsr_1_1DsrRouting_a4c406057009653878e8cdf3e3a7f2106}


\hyperlink{classns3_1_1Time}{Time} estimated for packet to travel between two nodes. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+non\+Prop\+Req\+Timer@{m\+\_\+non\+Prop\+Req\+Timer}}
\index{m\+\_\+non\+Prop\+Req\+Timer@{m\+\_\+non\+Prop\+Req\+Timer}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+non\+Prop\+Req\+Timer}{m_nonPropReqTimer}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<${\bf Ipv4\+Address}, {\bf Timer}$>$ ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+non\+Prop\+Req\+Timer\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a0936df610f90f7e79c24a2a8cdea6c14}{}\label{classns3_1_1dsr_1_1DsrRouting_a0936df610f90f7e79c24a2a8cdea6c14}


Map IP address + R\+R\+EQ timer. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+nonprop\+Request\+Timeout@{m\+\_\+nonprop\+Request\+Timeout}}
\index{m\+\_\+nonprop\+Request\+Timeout@{m\+\_\+nonprop\+Request\+Timeout}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+nonprop\+Request\+Timeout}{m_nonpropRequestTimeout}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+nonprop\+Request\+Timeout\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a42c2f43fbb0c5fefed36689eaf5c720e}{}\label{classns3_1_1dsr_1_1DsrRouting_a42c2f43fbb0c5fefed36689eaf5c720e}


The non-\/propagation request timeout. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+num\+Priority\+Queues@{m\+\_\+num\+Priority\+Queues}}
\index{m\+\_\+num\+Priority\+Queues@{m\+\_\+num\+Priority\+Queues}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+num\+Priority\+Queues}{m_numPriorityQueues}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+num\+Priority\+Queues\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_aa1952258d04f2ca8a0980d8436bca317}{}\label{classns3_1_1dsr_1_1DsrRouting_aa1952258d04f2ca8a0980d8436bca317}


The number of priority queues used. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+options@{m\+\_\+options}}
\index{m\+\_\+options@{m\+\_\+options}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+options}{m_options}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Dsr\+Option\+List\+\_\+t} ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+options\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a7f705d6856c04b7bce60317db968bf45}{}\label{classns3_1_1dsr_1_1DsrRouting_a7f705d6856c04b7bce60317db968bf45}


List of D\+SR Options supported. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+passive\+Ack\+Timeout@{m\+\_\+passive\+Ack\+Timeout}}
\index{m\+\_\+passive\+Ack\+Timeout@{m\+\_\+passive\+Ack\+Timeout}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+passive\+Ack\+Timeout}{m_passiveAckTimeout}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+passive\+Ack\+Timeout\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a6155bddae63f0e1fda8afbeebc25a54c}{}\label{classns3_1_1dsr_1_1DsrRouting_a6155bddae63f0e1fda8afbeebc25a54c}


The timeout value for passive acknowledge. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+passive\+Ack\+Timer@{m\+\_\+passive\+Ack\+Timer}}
\index{m\+\_\+passive\+Ack\+Timer@{m\+\_\+passive\+Ack\+Timer}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+passive\+Ack\+Timer}{m_passiveAckTimer}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<${\bf Passive\+Key}, {\bf Timer}$>$ ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+passive\+Ack\+Timer\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_ac53c706898e76a7f4871a460d13edd36}{}\label{classns3_1_1dsr_1_1DsrRouting_ac53c706898e76a7f4871a460d13edd36}


The timer for passive acknowledgment. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+passive\+Buffer@{m\+\_\+passive\+Buffer}}
\index{m\+\_\+passive\+Buffer@{m\+\_\+passive\+Buffer}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+passive\+Buffer}{m_passiveBuffer}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf dsr\+::\+Dsr\+Passive\+Buffer}$>$ ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+passive\+Buffer\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_ac0404985fc04df7f5b8f53ff1e487079}{}\label{classns3_1_1dsr_1_1DsrRouting_ac0404985fc04df7f5b8f53ff1e487079}


A \char`\"{}drop-\/front\char`\"{} queue used by the routing layer to cache route request sent. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+passive\+Cnt@{m\+\_\+passive\+Cnt}}
\index{m\+\_\+passive\+Cnt@{m\+\_\+passive\+Cnt}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+passive\+Cnt}{m_passiveCnt}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<${\bf Passive\+Key}, uint32\+\_\+t$>$ ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+passive\+Cnt\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a7fec404d680459aab2b40941a950502d}{}\label{classns3_1_1dsr_1_1DsrRouting_a7fec404d680459aab2b40941a950502d}


Map packet key + passive forward counts. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+passive\+Retries@{m\+\_\+passive\+Retries}}
\index{m\+\_\+passive\+Retries@{m\+\_\+passive\+Retries}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+passive\+Retries}{m_passiveRetries}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+passive\+Retries\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a88b8d65dce20b6b8f910be916623da0b}{}\label{classns3_1_1dsr_1_1DsrRouting_a88b8d65dce20b6b8f910be916623da0b}


\subsection*{of retries have been sent for passive acknowledgment}

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+priority\+Queue@{m\+\_\+priority\+Queue}}
\index{m\+\_\+priority\+Queue@{m\+\_\+priority\+Queue}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+priority\+Queue}{m_priorityQueue}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<$uint32\+\_\+t, {\bf Ptr}$<${\bf dsr\+::\+Dsr\+Network\+Queue}$>$ $>$ ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+priority\+Queue\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a4606c3dfb1099afbfe1e7cd1d1c3c8ee}{}\label{classns3_1_1dsr_1_1DsrRouting_a4606c3dfb1099afbfe1e7cd1d1c3c8ee}


priority queues 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+request\+Id@{m\+\_\+request\+Id}}
\index{m\+\_\+request\+Id@{m\+\_\+request\+Id}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+request\+Id}{m_requestId}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+request\+Id\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a4d9ddfed8e907a5885bb5e0f4b41f388}{}\label{classns3_1_1dsr_1_1DsrRouting_a4d9ddfed8e907a5885bb5e0f4b41f388}


The id assigned to each route request. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+request\+Period@{m\+\_\+request\+Period}}
\index{m\+\_\+request\+Period@{m\+\_\+request\+Period}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+request\+Period}{m_requestPeriod}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+request\+Period\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_acb19e2fe8a4cc1812181cdd5491383ee}{}\label{classns3_1_1dsr_1_1DsrRouting_acb19e2fe8a4cc1812181cdd5491383ee}


The base time interval between route requests. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+request\+Table\+Ids@{m\+\_\+request\+Table\+Ids}}
\index{m\+\_\+request\+Table\+Ids@{m\+\_\+request\+Table\+Ids}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+request\+Table\+Ids}{m_requestTableIds}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+request\+Table\+Ids\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_aac8b18967bf0bc05a7f0024ea55e99b1}{}\label{classns3_1_1dsr_1_1DsrRouting_aac8b18967bf0bc05a7f0024ea55e99b1}


The request table identifiers. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+request\+Table\+Size@{m\+\_\+request\+Table\+Size}}
\index{m\+\_\+request\+Table\+Size@{m\+\_\+request\+Table\+Size}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+request\+Table\+Size}{m_requestTableSize}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+request\+Table\+Size\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a8f6df12e2c9690f79943c2195af1be37}{}\label{classns3_1_1dsr_1_1DsrRouting_a8f6df12e2c9690f79943c2195af1be37}


The max size of the request table size. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+retrans\+Incr@{m\+\_\+retrans\+Incr}}
\index{m\+\_\+retrans\+Incr@{m\+\_\+retrans\+Incr}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+retrans\+Incr}{m_retransIncr}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+retrans\+Incr\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a49d8f2c59b9e8bcd6cb57cb302eac47b}{}\label{classns3_1_1dsr_1_1DsrRouting_a49d8f2c59b9e8bcd6cb57cb302eac47b}


the increase time for retransmission timer when face network congestion 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+route\+Cache@{m\+\_\+route\+Cache}}
\index{m\+\_\+route\+Cache@{m\+\_\+route\+Cache}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+route\+Cache}{m_routeCache}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf dsr\+::\+Dsr\+Route\+Cache}$>$ ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+route\+Cache\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}{}\label{classns3_1_1dsr_1_1DsrRouting_ac409bdb961b9fff0fb63ebd026be99ad}


A \char`\"{}drop-\/front\char`\"{} queue used by the routing layer to cache routes found. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+route\+Sort\+Type@{m\+\_\+route\+Sort\+Type}}
\index{m\+\_\+route\+Sort\+Type@{m\+\_\+route\+Sort\+Type}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+route\+Sort\+Type}{m_routeSortType}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+route\+Sort\+Type\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a02b1f61021bb9db1a72bcff2eb4b496d}{}\label{classns3_1_1dsr_1_1DsrRouting_a02b1f61021bb9db1a72bcff2eb4b496d}


The type of route sort methods. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+rreq\+Retries@{m\+\_\+rreq\+Retries}}
\index{m\+\_\+rreq\+Retries@{m\+\_\+rreq\+Retries}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+rreq\+Retries}{m_rreqRetries}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+rreq\+Retries\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a88bbff666cd3bb5bad099587a967d547}{}\label{classns3_1_1dsr_1_1DsrRouting_a88bbff666cd3bb5bad099587a967d547}


Maximum number of retransmissions of R\+R\+EQ with T\+TL = Net\+Diameter to discover a route. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+rreq\+Table@{m\+\_\+rreq\+Table}}
\index{m\+\_\+rreq\+Table@{m\+\_\+rreq\+Table}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+rreq\+Table}{m_rreqTable}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf dsr\+::\+Dsr\+Rreq\+Table}$>$ ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+rreq\+Table\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_ae9ec27743735fa2d59cc5190961d1942}{}\label{classns3_1_1dsr_1_1DsrRouting_ae9ec27743735fa2d59cc5190961d1942}


A \char`\"{}drop-\/front\char`\"{} queue used by the routing layer to cache route request sent. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+send\+Buffer@{m\+\_\+send\+Buffer}}
\index{m\+\_\+send\+Buffer@{m\+\_\+send\+Buffer}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+send\+Buffer}{m_sendBuffer}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Dsr\+Send\+Buffer} ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+send\+Buffer\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a887ae39d7060171753c0605d5c120549}{}\label{classns3_1_1dsr_1_1DsrRouting_a887ae39d7060171753c0605d5c120549}


The send buffer. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+send\+Buffer\+Timeout@{m\+\_\+send\+Buffer\+Timeout}}
\index{m\+\_\+send\+Buffer\+Timeout@{m\+\_\+send\+Buffer\+Timeout}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+send\+Buffer\+Timeout}{m_sendBufferTimeout}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+send\+Buffer\+Timeout\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a1f89794801db0336d92e4ca85fbc09a7}{}\label{classns3_1_1dsr_1_1DsrRouting_a1f89794801db0336d92e4ca85fbc09a7}


The maximum period of time that a routing protocol is allowed to buffer a packet for. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+send\+Buff\+Interval@{m\+\_\+send\+Buff\+Interval}}
\index{m\+\_\+send\+Buff\+Interval@{m\+\_\+send\+Buff\+Interval}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+send\+Buff\+Interval}{m_sendBuffInterval}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+send\+Buff\+Interval\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a966d7c644a941e3e6365859983816e8b}{}\label{classns3_1_1dsr_1_1DsrRouting_a966d7c644a941e3e6365859983816e8b}


how often to check send buffer 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+send\+Buff\+Timer@{m\+\_\+send\+Buff\+Timer}}
\index{m\+\_\+send\+Buff\+Timer@{m\+\_\+send\+Buff\+Timer}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+send\+Buff\+Timer}{m_sendBuffTimer}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Timer} ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+send\+Buff\+Timer\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a7676aff7f691319b764fba26a726ef5d}{}\label{classns3_1_1dsr_1_1DsrRouting_a7676aff7f691319b764fba26a726ef5d}


The send buffer timer. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+send\+Retries@{m\+\_\+send\+Retries}}
\index{m\+\_\+send\+Retries@{m\+\_\+send\+Retries}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+send\+Retries}{m_sendRetries}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+send\+Retries\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a02a55fe3b490af4dbd62953065d293a3}{}\label{classns3_1_1dsr_1_1DsrRouting_a02a55fe3b490af4dbd62953065d293a3}


\subsection*{of retries have been sent for network acknowledgment}

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+stability\+Decr\+Factor@{m\+\_\+stability\+Decr\+Factor}}
\index{m\+\_\+stability\+Decr\+Factor@{m\+\_\+stability\+Decr\+Factor}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+stability\+Decr\+Factor}{m_stabilityDecrFactor}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+stability\+Decr\+Factor\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a4a6db69db44738ae07289fa0993ac916}{}\label{classns3_1_1dsr_1_1DsrRouting_a4a6db69db44738ae07289fa0993ac916}


The initial decrease factor for link cache. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+stability\+Incr\+Factor@{m\+\_\+stability\+Incr\+Factor}}
\index{m\+\_\+stability\+Incr\+Factor@{m\+\_\+stability\+Incr\+Factor}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+stability\+Incr\+Factor}{m_stabilityIncrFactor}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+stability\+Incr\+Factor\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a9c6b73944ece2adc5f06b5010d9e55f2}{}\label{classns3_1_1dsr_1_1DsrRouting_a9c6b73944ece2adc5f06b5010d9e55f2}


The initial increase factor for link cache. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+sub\+Route@{m\+\_\+sub\+Route}}
\index{m\+\_\+sub\+Route@{m\+\_\+sub\+Route}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+sub\+Route}{m_subRoute}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+sub\+Route\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a83f7a7d54f8b078d987d46cf6edcd08e}{}\label{classns3_1_1dsr_1_1DsrRouting_a83f7a7d54f8b078d987d46cf6edcd08e}


Whether to save sub route or not. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+try\+Link\+Acks@{m\+\_\+try\+Link\+Acks}}
\index{m\+\_\+try\+Link\+Acks@{m\+\_\+try\+Link\+Acks}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+try\+Link\+Acks}{m_tryLinkAcks}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+try\+Link\+Acks\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_acecdd106e259c448bcfa6a6cef901658}{}\label{classns3_1_1dsr_1_1DsrRouting_acecdd106e259c448bcfa6a6cef901658}


Maximum number of packet transmission using link acknowledgment. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+try\+Passive\+Acks@{m\+\_\+try\+Passive\+Acks}}
\index{m\+\_\+try\+Passive\+Acks@{m\+\_\+try\+Passive\+Acks}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+try\+Passive\+Acks}{m_tryPassiveAcks}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+try\+Passive\+Acks\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_aadd1dd676ec50cae94ffd6f2eefb277c}{}\label{classns3_1_1dsr_1_1DsrRouting_aadd1dd676ec50cae94ffd6f2eefb277c}


Maximum number of packet transmission using passive acknowledgment. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+tx\+Packet\+Trace@{m\+\_\+tx\+Packet\+Trace}}
\index{m\+\_\+tx\+Packet\+Trace@{m\+\_\+tx\+Packet\+Trace}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+tx\+Packet\+Trace}{m_txPacketTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<$const {\bf Dsr\+Option\+S\+R\+Header} \&$>$ ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+tx\+Packet\+Trace\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a5e0a4e554d0321bd993b532d68931d75}{}\label{classns3_1_1dsr_1_1DsrRouting_a5e0a4e554d0321bd993b532d68931d75}
\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+uniform\+Random\+Variable@{m\+\_\+uniform\+Random\+Variable}}
\index{m\+\_\+uniform\+Random\+Variable@{m\+\_\+uniform\+Random\+Variable}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+uniform\+Random\+Variable}{m_uniformRandomVariable}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Uniform\+Random\+Variable}$>$ ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+uniform\+Random\+Variable\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a22a85b3510166ffdd451e4010f996f0f}{}\label{classns3_1_1dsr_1_1DsrRouting_a22a85b3510166ffdd451e4010f996f0f}


Provides uniform random variables. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!m\+\_\+use\+Extends@{m\+\_\+use\+Extends}}
\index{m\+\_\+use\+Extends@{m\+\_\+use\+Extends}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+use\+Extends}{m_useExtends}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::dsr\+::\+Dsr\+Routing\+::m\+\_\+use\+Extends\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_aa0a73bc163b0b32c84a5913ebbb62dc5}{}\label{classns3_1_1dsr_1_1DsrRouting_aa0a73bc163b0b32c84a5913ebbb62dc5}


The use extension of the life time for link cache. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER@{P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER}}
\index{P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER@{P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER}{PROT_NUMBER}}]{\setlength{\rightskip}{0pt plus 5cm}const uint8\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::\+P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER = 48\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a66248f69fcf97af91d6fe17d70617cc9}{}\label{classns3_1_1dsr_1_1DsrRouting_a66248f69fcf97af91d6fe17d70617cc9}


Define the dsr protocol number. 

\index{ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}!segs\+Left@{segs\+Left}}
\index{segs\+Left@{segs\+Left}!ns3\+::dsr\+::\+Dsr\+Routing@{ns3\+::dsr\+::\+Dsr\+Routing}}
\subsubsection[{\texorpdfstring{segs\+Left}{segsLeft}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::dsr\+::\+Dsr\+Routing\+::segs\+Left\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrRouting_a2089307bfbe378b6cd8b274b38f70bb9}{}\label{classns3_1_1dsr_1_1DsrRouting_a2089307bfbe378b6cd8b274b38f70bb9}


The segment left value from SR header. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
dsr/model/\hyperlink{dsr-routing_8h}{dsr-\/routing.\+h}\item 
dsr/model/\hyperlink{dsr-routing_8cc}{dsr-\/routing.\+cc}\end{DoxyCompactItemize}
