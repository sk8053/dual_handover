\hypertarget{classns3_1_1NetDeviceQueue}{}\section{ns3\+:\+:Net\+Device\+Queue Class Reference}
\label{classns3_1_1NetDeviceQueue}\index{ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}}


Network device transmission queue.  




{\ttfamily \#include $<$net-\/device-\/queue-\/interface.\+h$>$}



Inheritance diagram for ns3\+:\+:Net\+Device\+Queue\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Net\+Device\+Queue\+:
% FIG 1
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classns3_1_1Callback}{Callback}$<$ void $>$ \hyperlink{classns3_1_1NetDeviceQueue_af33b3e91885b68cc983c87b131826300}{Wake\+Callback}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Callback}{Callback} invoked by netdevices to wake upper layers. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1NetDeviceQueue_a1fd96da76b4b0f83f18e4ca7f6892713}{Net\+Device\+Queue} ()
\item 
virtual \hyperlink{classns3_1_1NetDeviceQueue_a20ac6106fe315652e8e0b8977b20b395}{$\sim$\+Net\+Device\+Queue} ()
\item 
virtual void \hyperlink{classns3_1_1NetDeviceQueue_aaa749761cdf8daf3424953b2ce77fca3}{Start} (void)
\item 
virtual void \hyperlink{classns3_1_1NetDeviceQueue_a7890ad382a288dd85dd25e0de8f75f3d}{Stop} (void)
\item 
virtual void \hyperlink{classns3_1_1NetDeviceQueue_a587aa3b6c3e66da41951a6a05604246f}{Wake} (void)
\item 
bool \hyperlink{classns3_1_1NetDeviceQueue_a577d4ced8ac8e0bbe655545bdd5722f7}{Is\+Stopped} (void) const 
\begin{DoxyCompactList}\small\item\em Get the status of the device transmission queue. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1NetDeviceQueue_afd7c9f18ad2cabc2624a764702d46a2b}{Set\+Wake\+Callback} (\hyperlink{classns3_1_1NetDeviceQueue_af33b3e91885b68cc983c87b131826300}{Wake\+Callback} cb)
\begin{DoxyCompactList}\small\item\em Set the wake callback. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1NetDeviceQueue_a6de25696a8c8aefa7a7eccd7d69bfc63}{Notify\+Queued\+Bytes} (uint32\+\_\+t bytes)
\begin{DoxyCompactList}\small\item\em Called by the netdevice to report the number of bytes queued to the device queue. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1NetDeviceQueue_a6aa75fa77fba0ea27ffa8c135112f1b3}{Notify\+Transmitted\+Bytes} (uint32\+\_\+t bytes)
\begin{DoxyCompactList}\small\item\em Called by the netdevice to report the number of bytes it is going to transmit. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1NetDeviceQueue_a4de87b16e1e556608aa8f23bc590a0de}{Reset\+Queue\+Limits} ()
\begin{DoxyCompactList}\small\item\em Reset queue limits state. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1NetDeviceQueue_a2ee44bb945c17d31e70f9c4ac651465b}{Set\+Queue\+Limits} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1QueueLimits}{Queue\+Limits} $>$ ql)
\begin{DoxyCompactList}\small\item\em Set queue limits to this queue. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1QueueLimits}{Queue\+Limits} $>$ \hyperlink{classns3_1_1NetDeviceQueue_a271d0613d179ead88394a9733f1a0628}{Get\+Queue\+Limits} ()
\begin{DoxyCompactList}\small\item\em Get queue limits to this queue. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Item $>$ }\\static void \hyperlink{classns3_1_1NetDeviceQueue_aada25000d7564442eec5853d84729c6a}{Packet\+Enqueued} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Queue}{Queue}$<$ Item $>$ $>$ queue, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDeviceQueueInterface}{Net\+Device\+Queue\+Interface} $>$ ndqi, uint8\+\_\+t txq, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const Item $>$ item)
\begin{DoxyCompactList}\small\item\em Perform the actions required by flow control and dynamic queue limits when a packet is enqueued in the queue of a netdevice. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Item $>$ }\\static void \hyperlink{classns3_1_1NetDeviceQueue_a406572ce308f6e0bf59a60abcc8e73e5}{Packet\+Dequeued} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Queue}{Queue}$<$ Item $>$ $>$ queue, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDeviceQueueInterface}{Net\+Device\+Queue\+Interface} $>$ ndqi, uint8\+\_\+t txq, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const Item $>$ item)
\begin{DoxyCompactList}\small\item\em Perform the actions required by flow control and dynamic queue limits when a packet is dequeued (or dropped after dequeue) from the queue of a netdevice. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Item $>$ }\\static void \hyperlink{classns3_1_1NetDeviceQueue_a0f6712b277a48d3f482f21b3176b765e}{Packet\+Discarded} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Queue}{Queue}$<$ Item $>$ $>$ queue, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDeviceQueueInterface}{Net\+Device\+Queue\+Interface} $>$ ndqi, uint8\+\_\+t txq, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const Item $>$ item)
\begin{DoxyCompactList}\small\item\em Perform the actions required by flow control and dynamic queue limits when a packet is dropped before being enqueued in the queue of a netdevice (which likely indicates that the queue is full) \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Private Member Functions}
\begin{DoxyCompactItemize}
\item 
static void \hyperlink{classns3_1_1NetDeviceQueue_a638a4fa522a75c1c91a8ba303f3000ec}{Do\+Ns\+Log} (const enum \hyperlink{namespacens3_aa6464a4d69551a9cc968e17a65f39bdb}{Log\+Level} level, std\+::string str)
\begin{DoxyCompactList}\small\item\em Pass messages to the ns-\/3 logging system. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classns3_1_1NetDeviceQueue_ae0ffd8982c7000674eac6948a398f3de}{m\+\_\+stopped\+By\+Device}
\begin{DoxyCompactList}\small\item\em True if the queue has been stopped by the device. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1NetDeviceQueue_a025451a1ed0b95ba3e10b1597f1b3873}{m\+\_\+stopped\+By\+Queue\+Limits}
\begin{DoxyCompactList}\small\item\em True if the queue has been stopped by a queue limits object. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1QueueLimits}{Queue\+Limits} $>$ \hyperlink{classns3_1_1NetDeviceQueue_a29a6c2635a83e3ea45365a3a0a839639}{m\+\_\+queue\+Limits}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Queue}{Queue} limits object. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1NetDeviceQueue_af33b3e91885b68cc983c87b131826300}{Wake\+Callback} \hyperlink{classns3_1_1NetDeviceQueue_abfc6b3a5c3cbbd967400751e7184b2d7}{m\+\_\+wake\+Callback}
\begin{DoxyCompactList}\small\item\em Wake callback. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Network device transmission queue. 

This class stores information about a single transmission queue of a network device that is exposed to queue discs. Such information includes the state of the transmission queue (whether it has been stopped or not) and data used by techniques such as Byte \hyperlink{classns3_1_1Queue}{Queue} Limits.

This class roughly models the struct netdev\+\_\+queue of Linux. 

\subsection{Member Typedef Documentation}
\index{ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}!Wake\+Callback@{Wake\+Callback}}
\index{Wake\+Callback@{Wake\+Callback}!ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}}
\subsubsection[{\texorpdfstring{Wake\+Callback}{WakeCallback}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Callback}$<$ void $>$ {\bf ns3\+::\+Net\+Device\+Queue\+::\+Wake\+Callback}}\hypertarget{classns3_1_1NetDeviceQueue_af33b3e91885b68cc983c87b131826300}{}\label{classns3_1_1NetDeviceQueue_af33b3e91885b68cc983c87b131826300}


\hyperlink{classns3_1_1Callback}{Callback} invoked by netdevices to wake upper layers. 



\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}!Net\+Device\+Queue@{Net\+Device\+Queue}}
\index{Net\+Device\+Queue@{Net\+Device\+Queue}!ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}}
\subsubsection[{\texorpdfstring{Net\+Device\+Queue()}{NetDeviceQueue()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Net\+Device\+Queue\+::\+Net\+Device\+Queue (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1NetDeviceQueue_a1fd96da76b4b0f83f18e4ca7f6892713}{}\label{classns3_1_1NetDeviceQueue_a1fd96da76b4b0f83f18e4ca7f6892713}

\begin{DoxyCode}
32   : \hyperlink{classns3_1_1NetDeviceQueue_ae0ffd8982c7000674eac6948a398f3de}{m\_stoppedByDevice} (\textcolor{keyword}{false}),
33     \hyperlink{classns3_1_1NetDeviceQueue_a025451a1ed0b95ba3e10b1597f1b3873}{m\_stoppedByQueueLimits} (\textcolor{keyword}{false})
34 \{
35   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
36 \}
\end{DoxyCode}
\index{ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}!````~Net\+Device\+Queue@{$\sim$\+Net\+Device\+Queue}}
\index{````~Net\+Device\+Queue@{$\sim$\+Net\+Device\+Queue}!ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}}
\subsubsection[{\texorpdfstring{$\sim$\+Net\+Device\+Queue()}{~NetDeviceQueue()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Net\+Device\+Queue\+::$\sim$\+Net\+Device\+Queue (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1NetDeviceQueue_a20ac6106fe315652e8e0b8977b20b395}{}\label{classns3_1_1NetDeviceQueue_a20ac6106fe315652e8e0b8977b20b395}

\begin{DoxyCode}
39 \{
40   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
41 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}!Do\+Ns\+Log@{Do\+Ns\+Log}}
\index{Do\+Ns\+Log@{Do\+Ns\+Log}!ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}}
\subsubsection[{\texorpdfstring{Do\+Ns\+Log(const enum Log\+Level level, std\+::string str)}{DoNsLog(const enum LogLevel level, std::string str)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Net\+Device\+Queue\+::\+Do\+Ns\+Log (
\begin{DoxyParamCaption}
\item[{const enum {\bf Log\+Level}}]{level, }
\item[{std\+::string}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\hypertarget{classns3_1_1NetDeviceQueue_a638a4fa522a75c1c91a8ba303f3000ec}{}\label{classns3_1_1NetDeviceQueue_a638a4fa522a75c1c91a8ba303f3000ec}


Pass messages to the ns-\/3 logging system. 


\begin{DoxyParams}{Parameters}
{\em level} & the log level \\
\hline
{\em str} & the message to log \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
150 \{
151     \hyperlink{log-macros-disabled_8h_ab01b4392d98b06fb128e77c85129a477}{NS\_LOG} (level, str);
152 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}!Get\+Queue\+Limits@{Get\+Queue\+Limits}}
\index{Get\+Queue\+Limits@{Get\+Queue\+Limits}!ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}}
\subsubsection[{\texorpdfstring{Get\+Queue\+Limits()}{GetQueueLimits()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Queue\+Limits} $>$ ns3\+::\+Net\+Device\+Queue\+::\+Get\+Queue\+Limits (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1NetDeviceQueue_a271d0613d179ead88394a9733f1a0628}{}\label{classns3_1_1NetDeviceQueue_a271d0613d179ead88394a9733f1a0628}


Get queue limits to this queue. 

\begin{DoxyReturn}{Returns}
the queue limits associated to this queue 
\end{DoxyReturn}

\begin{DoxyCode}
143 \{
144   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
145   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1NetDeviceQueue_a29a6c2635a83e3ea45365a3a0a839639}{m\_queueLimits};
146 \}
\end{DoxyCode}
\index{ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}!Is\+Stopped@{Is\+Stopped}}
\index{Is\+Stopped@{Is\+Stopped}!ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}}
\subsubsection[{\texorpdfstring{Is\+Stopped(void) const }{IsStopped(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Net\+Device\+Queue\+::\+Is\+Stopped (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1NetDeviceQueue_a577d4ced8ac8e0bbe655545bdd5722f7}{}\label{classns3_1_1NetDeviceQueue_a577d4ced8ac8e0bbe655545bdd5722f7}


Get the status of the device transmission queue. 

\begin{DoxyReturn}{Returns}
true if the device transmission queue is stopped.
\end{DoxyReturn}
Called by queue discs to enquire about the status of a given transmission queue. This is the analogous to the netif\+\_\+xmit\+\_\+stopped function of the Linux kernel. 
\begin{DoxyCode}
45 \{
46   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
47   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1NetDeviceQueue_ae0ffd8982c7000674eac6948a398f3de}{m\_stoppedByDevice} || \hyperlink{classns3_1_1NetDeviceQueue_a025451a1ed0b95ba3e10b1597f1b3873}{m\_stoppedByQueueLimits};
48 \}
\end{DoxyCode}
\index{ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}!Notify\+Queued\+Bytes@{Notify\+Queued\+Bytes}}
\index{Notify\+Queued\+Bytes@{Notify\+Queued\+Bytes}!ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}}
\subsubsection[{\texorpdfstring{Notify\+Queued\+Bytes(uint32\+\_\+t bytes)}{NotifyQueuedBytes(uint32_t bytes)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Net\+Device\+Queue\+::\+Notify\+Queued\+Bytes (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{bytes}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1NetDeviceQueue_a6de25696a8c8aefa7a7eccd7d69bfc63}{}\label{classns3_1_1NetDeviceQueue_a6de25696a8c8aefa7a7eccd7d69bfc63}


Called by the netdevice to report the number of bytes queued to the device queue. 


\begin{DoxyParams}{Parameters}
{\em bytes} & number of bytes queued to the device queue \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
87 \{
88   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << bytes);
89   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1NetDeviceQueue_a29a6c2635a83e3ea45365a3a0a839639}{m\_queueLimits})
90     \{
91       \textcolor{keywordflow}{return};
92     \}
93   \hyperlink{classns3_1_1NetDeviceQueue_a29a6c2635a83e3ea45365a3a0a839639}{m\_queueLimits}->Queued (bytes);
94   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1NetDeviceQueue_a29a6c2635a83e3ea45365a3a0a839639}{m\_queueLimits}->Available () >= 0)
95     \{
96       \textcolor{keywordflow}{return};
97     \}
98   \hyperlink{classns3_1_1NetDeviceQueue_a025451a1ed0b95ba3e10b1597f1b3873}{m\_stoppedByQueueLimits} = \textcolor{keyword}{true};
99 \}
\end{DoxyCode}
\index{ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}!Notify\+Transmitted\+Bytes@{Notify\+Transmitted\+Bytes}}
\index{Notify\+Transmitted\+Bytes@{Notify\+Transmitted\+Bytes}!ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}}
\subsubsection[{\texorpdfstring{Notify\+Transmitted\+Bytes(uint32\+\_\+t bytes)}{NotifyTransmittedBytes(uint32_t bytes)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Net\+Device\+Queue\+::\+Notify\+Transmitted\+Bytes (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{bytes}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1NetDeviceQueue_a6aa75fa77fba0ea27ffa8c135112f1b3}{}\label{classns3_1_1NetDeviceQueue_a6aa75fa77fba0ea27ffa8c135112f1b3}


Called by the netdevice to report the number of bytes it is going to transmit. 


\begin{DoxyParams}{Parameters}
{\em bytes} & number of bytes the device is going to transmit \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
103 \{
104   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << bytes);
105   \textcolor{keywordflow}{if} ((!\hyperlink{classns3_1_1NetDeviceQueue_a29a6c2635a83e3ea45365a3a0a839639}{m\_queueLimits}) || (!bytes))
106     \{
107       \textcolor{keywordflow}{return};
108     \}
109   \hyperlink{classns3_1_1NetDeviceQueue_a29a6c2635a83e3ea45365a3a0a839639}{m\_queueLimits}->Completed (bytes);
110   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1NetDeviceQueue_a29a6c2635a83e3ea45365a3a0a839639}{m\_queueLimits}->Available () < 0)
111     \{
112       \textcolor{keywordflow}{return};
113     \}
114   \textcolor{keywordtype}{bool} wasStoppedByQueueLimits = \hyperlink{classns3_1_1NetDeviceQueue_a025451a1ed0b95ba3e10b1597f1b3873}{m\_stoppedByQueueLimits};
115   \hyperlink{classns3_1_1NetDeviceQueue_a025451a1ed0b95ba3e10b1597f1b3873}{m\_stoppedByQueueLimits} = \textcolor{keyword}{false};
116   \textcolor{comment}{// Request the queue disc to dequeue a packet}
117   \textcolor{keywordflow}{if} (wasStoppedByQueueLimits && !\hyperlink{classns3_1_1NetDeviceQueue_abfc6b3a5c3cbbd967400751e7184b2d7}{m\_wakeCallback}.\hyperlink{classns3_1_1Callback_aa8e27826badbf37f84763f36f70d9b54}{IsNull} ())
118     \{
119       \hyperlink{classns3_1_1Simulator_a2219ee02c0647adc83d1c918c3256266}{Simulator::ScheduleNow} (&
      \hyperlink{classns3_1_1NetDeviceQueue_abfc6b3a5c3cbbd967400751e7184b2d7}{NetDeviceQueue::m\_wakeCallback}, \textcolor{keyword}{this});
120     \}
121 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}!Packet\+Dequeued@{Packet\+Dequeued}}
\index{Packet\+Dequeued@{Packet\+Dequeued}!ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}}
\subsubsection[{\texorpdfstring{Packet\+Dequeued(\+Ptr$<$ Queue$<$ Item $>$ $>$ queue, Ptr$<$ Net\+Device\+Queue\+Interface $>$ ndqi, uint8\+\_\+t txq, Ptr$<$ const Item $>$ item)}{PacketDequeued(Ptr< Queue< Item > > queue, Ptr< NetDeviceQueueInterface > ndqi, uint8_t txq, Ptr< const Item > item)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Item $>$ void ns3\+::\+Net\+Device\+Queue\+::\+Packet\+Dequeued (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Queue}$<$ Item $>$ $>$}]{queue, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device\+Queue\+Interface} $>$}]{ndqi, }
\item[{uint8\+\_\+t}]{txq, }
\item[{{\bf Ptr}$<$ const Item $>$}]{item}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1NetDeviceQueue_a406572ce308f6e0bf59a60abcc8e73e5}{}\label{classns3_1_1NetDeviceQueue_a406572ce308f6e0bf59a60abcc8e73e5}


Perform the actions required by flow control and dynamic queue limits when a packet is dequeued (or dropped after dequeue) from the queue of a netdevice. 


\begin{DoxyParams}{Parameters}
{\em queue} & the device queue \\
\hline
{\em ndqi} & the \hyperlink{classns3_1_1NetDeviceQueueInterface}{Net\+Device\+Queue\+Interface} object aggregated to the device \\
\hline
{\em txq} & the index of the transmission queue associated with the device queue \\
\hline
{\em item} & the dequeued (or dropped after dequeue) packet\\
\hline
\end{DoxyParams}
This method must be connected to the \char`\"{}\+Dequeue\char`\"{} and \char`\"{}\+Drop\+After\+Dequeue\char`\"{} traced callbacks of a \hyperlink{classns3_1_1Queue}{Queue} object (through a bound callback) in order for a netdevice to support flow control and dynamic queue limits. 
\begin{DoxyCode}
404 \{
405   \hyperlink{net-device-queue-interface_8h_a2594f550b116d0d76e5b25826a8e986e}{NDQI\_LOG} (\hyperlink{namespacens3_aa6464a4d69551a9cc968e17a65f39bdbad960c03edfbfa929248b88c0f974a555}{LOG\_LOGIC}, \textcolor{stringliteral}{"NetDeviceQueue:PacketDequeued("} << queue << \textcolor{stringliteral}{", "} << ndqi
406             << \textcolor{stringliteral}{", "} << txq << \textcolor{stringliteral}{", "} << item << \textcolor{stringliteral}{")"});
407 
408   \textcolor{comment}{// Inform BQL}
409   ndqi->GetTxQueue (txq)->NotifyTransmittedBytes (item->GetSize ());
410 
411   uint16\_t mtu = ndqi->GetObject<NetDevice> ()->GetMtu ();
412 
413   \textcolor{comment}{// After dequeuing a packet, if there is room for another packet we}
414   \textcolor{comment}{// call Wake () that ensures that the queue is not stopped and restarts}
415   \textcolor{comment}{// the queue disc if the queue was stopped}
416 
417   \textcolor{keywordflow}{if} ((queue->GetMode () == \hyperlink{classns3_1_1QueueBase_adc473162c2a2bcb3d76d151d6d7ee02aa68a809be7a09a4c4c7d8feb37f2f7a9d}{QueueBase::QUEUE\_MODE\_PACKETS} &&
418        queue->GetNPackets () < queue->GetMaxPackets ()) ||
419       (queue->GetMode () == \hyperlink{classns3_1_1QueueBase_adc473162c2a2bcb3d76d151d6d7ee02aa141eeb76bf0704ba0fdb23b04ffc3453}{QueueBase::QUEUE\_MODE\_BYTES} &&
420        queue->GetNBytes () + mtu <= queue->GetMaxBytes ()))
421     \{
422       ndqi->GetTxQueue (txq)->Wake ();
423     \}
424 \}
\end{DoxyCode}
\index{ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}!Packet\+Discarded@{Packet\+Discarded}}
\index{Packet\+Discarded@{Packet\+Discarded}!ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}}
\subsubsection[{\texorpdfstring{Packet\+Discarded(\+Ptr$<$ Queue$<$ Item $>$ $>$ queue, Ptr$<$ Net\+Device\+Queue\+Interface $>$ ndqi, uint8\+\_\+t txq, Ptr$<$ const Item $>$ item)}{PacketDiscarded(Ptr< Queue< Item > > queue, Ptr< NetDeviceQueueInterface > ndqi, uint8_t txq, Ptr< const Item > item)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Item $>$ void ns3\+::\+Net\+Device\+Queue\+::\+Packet\+Discarded (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Queue}$<$ Item $>$ $>$}]{queue, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device\+Queue\+Interface} $>$}]{ndqi, }
\item[{uint8\+\_\+t}]{txq, }
\item[{{\bf Ptr}$<$ const Item $>$}]{item}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1NetDeviceQueue_a0f6712b277a48d3f482f21b3176b765e}{}\label{classns3_1_1NetDeviceQueue_a0f6712b277a48d3f482f21b3176b765e}


Perform the actions required by flow control and dynamic queue limits when a packet is dropped before being enqueued in the queue of a netdevice (which likely indicates that the queue is full) 


\begin{DoxyParams}{Parameters}
{\em queue} & the device queue \\
\hline
{\em ndqi} & the \hyperlink{classns3_1_1NetDeviceQueueInterface}{Net\+Device\+Queue\+Interface} object aggregated to the device \\
\hline
{\em txq} & the index of the transmission queue associated with the device queue \\
\hline
{\em item} & the dropped packet\\
\hline
\end{DoxyParams}
This method must be connected to the \char`\"{}\+Drop\+Before\+Enqueue\char`\"{} traced callback of a \hyperlink{classns3_1_1Queue}{Queue} object (through a bound callback) in order for a netdevice to support flow control and dynamic queue limits. 
\begin{DoxyCode}
431 \{
432   \hyperlink{net-device-queue-interface_8h_a2594f550b116d0d76e5b25826a8e986e}{NDQI\_LOG} (\hyperlink{namespacens3_aa6464a4d69551a9cc968e17a65f39bdbad960c03edfbfa929248b88c0f974a555}{LOG\_LOGIC}, \textcolor{stringliteral}{"NetDeviceQueue:PacketDiscarded("} << queue << \textcolor{stringliteral}{", "} << ndqi
433             << \textcolor{stringliteral}{", "} << txq << \textcolor{stringliteral}{", "} << item << \textcolor{stringliteral}{")"});
434 
435   \textcolor{comment}{// This method is called when a packet is discarded before being enqueued in the}
436   \textcolor{comment}{// device queue, likely because the queue is full. This should not happen if the}
437   \textcolor{comment}{// device correctly stops the queue. Anyway, stop the tx queue, so that the upper}
438   \textcolor{comment}{// layers do not send packets until there is room in the queue again.}
439 
440   \hyperlink{net-device-queue-interface_8h_a2594f550b116d0d76e5b25826a8e986e}{NDQI\_LOG} (\hyperlink{namespacens3_aa6464a4d69551a9cc968e17a65f39bdba4055b1591e6f4a44495a693a01c4f3e3}{LOG\_ERROR}, \textcolor{stringliteral}{"BUG! No room in the device queue for the received packet! ("}
441             << queue->GetNPackets () << \textcolor{stringliteral}{" packets and "} << queue->GetNBytes () << \textcolor{stringliteral}{" bytes inside)"});
442 
443   ndqi->GetTxQueue (txq)->Stop ();
444 \}
\end{DoxyCode}
\index{ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}!Packet\+Enqueued@{Packet\+Enqueued}}
\index{Packet\+Enqueued@{Packet\+Enqueued}!ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}}
\subsubsection[{\texorpdfstring{Packet\+Enqueued(\+Ptr$<$ Queue$<$ Item $>$ $>$ queue, Ptr$<$ Net\+Device\+Queue\+Interface $>$ ndqi, uint8\+\_\+t txq, Ptr$<$ const Item $>$ item)}{PacketEnqueued(Ptr< Queue< Item > > queue, Ptr< NetDeviceQueueInterface > ndqi, uint8_t txq, Ptr< const Item > item)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Item $>$ void ns3\+::\+Net\+Device\+Queue\+::\+Packet\+Enqueued (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Queue}$<$ Item $>$ $>$}]{queue, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device\+Queue\+Interface} $>$}]{ndqi, }
\item[{uint8\+\_\+t}]{txq, }
\item[{{\bf Ptr}$<$ const Item $>$}]{item}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1NetDeviceQueue_aada25000d7564442eec5853d84729c6a}{}\label{classns3_1_1NetDeviceQueue_aada25000d7564442eec5853d84729c6a}


Perform the actions required by flow control and dynamic queue limits when a packet is enqueued in the queue of a netdevice. 


\begin{DoxyParams}{Parameters}
{\em queue} & the device queue \\
\hline
{\em ndqi} & the \hyperlink{classns3_1_1NetDeviceQueueInterface}{Net\+Device\+Queue\+Interface} object aggregated to the device \\
\hline
{\em txq} & the index of the transmission queue associated with the device queue \\
\hline
{\em item} & the enqueued packet\\
\hline
\end{DoxyParams}
This method must be connected to the \char`\"{}\+Enqueue\char`\"{} traced callback of a \hyperlink{classns3_1_1Queue}{Queue} object (through a bound callback) in order for a netdevice to support flow control and dynamic queue limits. 
\begin{DoxyCode}
376 \{
377   \hyperlink{net-device-queue-interface_8h_a2594f550b116d0d76e5b25826a8e986e}{NDQI\_LOG} (\hyperlink{namespacens3_aa6464a4d69551a9cc968e17a65f39bdbad960c03edfbfa929248b88c0f974a555}{LOG\_LOGIC}, \textcolor{stringliteral}{"NetDeviceQueue:PacketEnqueued("} << queue << \textcolor{stringliteral}{", "} << ndqi
378             << \textcolor{stringliteral}{", "} << txq << \textcolor{stringliteral}{", "} << item << \textcolor{stringliteral}{")"});
379 
380   \textcolor{comment}{// Inform BQL}
381   ndqi->GetTxQueue (txq)->NotifyQueuedBytes (item->GetSize ());
382 
383   uint16\_t mtu = ndqi->GetObject<NetDevice> ()->GetMtu ();
384 
385   \textcolor{comment}{// After enqueuing a packet, we need to check whether the queue is able to}
386   \textcolor{comment}{// store another packet. If not, we stop the queue}
387 
388   \textcolor{keywordflow}{if} ((queue->GetMode () == \hyperlink{classns3_1_1QueueBase_adc473162c2a2bcb3d76d151d6d7ee02aa68a809be7a09a4c4c7d8feb37f2f7a9d}{QueueBase::QUEUE\_MODE\_PACKETS} &&
389        queue->GetNPackets () >= queue->GetMaxPackets ()) ||
390       (queue->GetMode () == \hyperlink{classns3_1_1QueueBase_adc473162c2a2bcb3d76d151d6d7ee02aa141eeb76bf0704ba0fdb23b04ffc3453}{QueueBase::QUEUE\_MODE\_BYTES} &&
391        queue->GetNBytes () + mtu > queue->GetMaxBytes ()))
392     \{
393       \hyperlink{net-device-queue-interface_8h_a2594f550b116d0d76e5b25826a8e986e}{NDQI\_LOG} (\hyperlink{namespacens3_aa6464a4d69551a9cc968e17a65f39bdbae5a9fe44e2d62303656baa0cf1a687a0}{LOG\_DEBUG}, \textcolor{stringliteral}{"The device queue is being stopped ("} << queue->GetNPackets ()
394                 << \textcolor{stringliteral}{" packets and "} << queue->GetNBytes () << \textcolor{stringliteral}{" bytes inside)"});
395       ndqi->GetTxQueue (txq)->Stop ();
396     \}
397 \}
\end{DoxyCode}
\index{ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}!Reset\+Queue\+Limits@{Reset\+Queue\+Limits}}
\index{Reset\+Queue\+Limits@{Reset\+Queue\+Limits}!ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}}
\subsubsection[{\texorpdfstring{Reset\+Queue\+Limits()}{ResetQueueLimits()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Net\+Device\+Queue\+::\+Reset\+Queue\+Limits (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1NetDeviceQueue_a4de87b16e1e556608aa8f23bc590a0de}{}\label{classns3_1_1NetDeviceQueue_a4de87b16e1e556608aa8f23bc590a0de}


Reset queue limits state. 


\begin{DoxyCode}
125 \{
126   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
127   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1NetDeviceQueue_a29a6c2635a83e3ea45365a3a0a839639}{m\_queueLimits})
128     \{
129       \textcolor{keywordflow}{return};
130     \}
131   \hyperlink{classns3_1_1NetDeviceQueue_a29a6c2635a83e3ea45365a3a0a839639}{m\_queueLimits}->Reset ();
132 \}
\end{DoxyCode}
\index{ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}!Set\+Queue\+Limits@{Set\+Queue\+Limits}}
\index{Set\+Queue\+Limits@{Set\+Queue\+Limits}!ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}}
\subsubsection[{\texorpdfstring{Set\+Queue\+Limits(\+Ptr$<$ Queue\+Limits $>$ ql)}{SetQueueLimits(Ptr< QueueLimits > ql)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Net\+Device\+Queue\+::\+Set\+Queue\+Limits (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Queue\+Limits} $>$}]{ql}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1NetDeviceQueue_a2ee44bb945c17d31e70f9c4ac651465b}{}\label{classns3_1_1NetDeviceQueue_a2ee44bb945c17d31e70f9c4ac651465b}


Set queue limits to this queue. 


\begin{DoxyParams}{Parameters}
{\em ql} & the queue limits associated to this queue \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
136 \{
137   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << ql);
138   \hyperlink{classns3_1_1NetDeviceQueue_a29a6c2635a83e3ea45365a3a0a839639}{m\_queueLimits} = ql;
139 \}
\end{DoxyCode}
\index{ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}!Set\+Wake\+Callback@{Set\+Wake\+Callback}}
\index{Set\+Wake\+Callback@{Set\+Wake\+Callback}!ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}}
\subsubsection[{\texorpdfstring{Set\+Wake\+Callback(\+Wake\+Callback cb)}{SetWakeCallback(WakeCallback cb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Net\+Device\+Queue\+::\+Set\+Wake\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Wake\+Callback}}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1NetDeviceQueue_afd7c9f18ad2cabc2624a764702d46a2b}{}\label{classns3_1_1NetDeviceQueue_afd7c9f18ad2cabc2624a764702d46a2b}


Set the wake callback. 


\begin{DoxyParams}{Parameters}
{\em cb} & the callback to set\\
\hline
\end{DoxyParams}
Called by the traffic control layer to set the wake callback. The wake callback is invoked by the device whenever it is needed to \char`\"{}wake\char`\"{} the upper layers (i.\+e., solicitate the queue disc associated with this transmission queue (in case of multi-\/queue aware queue discs) or to the network device (otherwise) to send packets down to the device). 
\begin{DoxyCode}
81 \{
82   \hyperlink{classns3_1_1NetDeviceQueue_abfc6b3a5c3cbbd967400751e7184b2d7}{m\_wakeCallback} = cb;
83 \}
\end{DoxyCode}
\index{ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}!Start@{Start}}
\index{Start@{Start}!ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}}
\subsubsection[{\texorpdfstring{Start(void)}{Start(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Net\+Device\+Queue\+::\+Start (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1NetDeviceQueue_aaa749761cdf8daf3424953b2ce77fca3}{}\label{classns3_1_1NetDeviceQueue_aaa749761cdf8daf3424953b2ce77fca3}
Called by the device to start this device transmission queue. This is the analogous to the netif\+\_\+tx\+\_\+start\+\_\+queue function of the Linux kernel. 
\begin{DoxyCode}
52 \{
53   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
54   \hyperlink{classns3_1_1NetDeviceQueue_ae0ffd8982c7000674eac6948a398f3de}{m\_stoppedByDevice} = \textcolor{keyword}{false};
55 \}
\end{DoxyCode}
\index{ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}!Stop@{Stop}}
\index{Stop@{Stop}!ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}}
\subsubsection[{\texorpdfstring{Stop(void)}{Stop(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Net\+Device\+Queue\+::\+Stop (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1NetDeviceQueue_a7890ad382a288dd85dd25e0de8f75f3d}{}\label{classns3_1_1NetDeviceQueue_a7890ad382a288dd85dd25e0de8f75f3d}
Called by the device to stop this device transmission queue. This is the analogous to the netif\+\_\+tx\+\_\+stop\+\_\+queue function of the Linux kernel. 
\begin{DoxyCode}
59 \{
60   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
61   \hyperlink{classns3_1_1NetDeviceQueue_ae0ffd8982c7000674eac6948a398f3de}{m\_stoppedByDevice} = \textcolor{keyword}{true};
62 \}
\end{DoxyCode}
\index{ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}!Wake@{Wake}}
\index{Wake@{Wake}!ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}}
\subsubsection[{\texorpdfstring{Wake(void)}{Wake(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Net\+Device\+Queue\+::\+Wake (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1NetDeviceQueue_a587aa3b6c3e66da41951a6a05604246f}{}\label{classns3_1_1NetDeviceQueue_a587aa3b6c3e66da41951a6a05604246f}
Called by the device to wake the queue disc associated with this device transmission queue. This is done by invoking the wake callback. This is the analogous to the netif\+\_\+tx\+\_\+wake\+\_\+queue function of the Linux kernel. 
\begin{DoxyCode}
66 \{
67   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
68 
69   \textcolor{keywordtype}{bool} wasStoppedByDevice = \hyperlink{classns3_1_1NetDeviceQueue_ae0ffd8982c7000674eac6948a398f3de}{m\_stoppedByDevice};
70   \hyperlink{classns3_1_1NetDeviceQueue_ae0ffd8982c7000674eac6948a398f3de}{m\_stoppedByDevice} = \textcolor{keyword}{false};
71 
72   \textcolor{comment}{// Request the queue disc to dequeue a packet}
73   \textcolor{keywordflow}{if} (wasStoppedByDevice && !\hyperlink{classns3_1_1NetDeviceQueue_abfc6b3a5c3cbbd967400751e7184b2d7}{m\_wakeCallback}.\hyperlink{classns3_1_1Callback_aa8e27826badbf37f84763f36f70d9b54}{IsNull} ())
74     \{
75       \hyperlink{classns3_1_1Simulator_a2219ee02c0647adc83d1c918c3256266}{Simulator::ScheduleNow} (&
      \hyperlink{classns3_1_1NetDeviceQueue_abfc6b3a5c3cbbd967400751e7184b2d7}{NetDeviceQueue::m\_wakeCallback}, \textcolor{keyword}{this});
76     \}
77 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4




\subsection{Member Data Documentation}
\index{ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}!m\+\_\+queue\+Limits@{m\+\_\+queue\+Limits}}
\index{m\+\_\+queue\+Limits@{m\+\_\+queue\+Limits}!ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}}
\subsubsection[{\texorpdfstring{m\+\_\+queue\+Limits}{m_queueLimits}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Queue\+Limits}$>$ ns3\+::\+Net\+Device\+Queue\+::m\+\_\+queue\+Limits\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1NetDeviceQueue_a29a6c2635a83e3ea45365a3a0a839639}{}\label{classns3_1_1NetDeviceQueue_a29a6c2635a83e3ea45365a3a0a839639}


\hyperlink{classns3_1_1Queue}{Queue} limits object. 

\index{ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}!m\+\_\+stopped\+By\+Device@{m\+\_\+stopped\+By\+Device}}
\index{m\+\_\+stopped\+By\+Device@{m\+\_\+stopped\+By\+Device}!ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}}
\subsubsection[{\texorpdfstring{m\+\_\+stopped\+By\+Device}{m_stoppedByDevice}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Net\+Device\+Queue\+::m\+\_\+stopped\+By\+Device\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1NetDeviceQueue_ae0ffd8982c7000674eac6948a398f3de}{}\label{classns3_1_1NetDeviceQueue_ae0ffd8982c7000674eac6948a398f3de}


True if the queue has been stopped by the device. 

\index{ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}!m\+\_\+stopped\+By\+Queue\+Limits@{m\+\_\+stopped\+By\+Queue\+Limits}}
\index{m\+\_\+stopped\+By\+Queue\+Limits@{m\+\_\+stopped\+By\+Queue\+Limits}!ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}}
\subsubsection[{\texorpdfstring{m\+\_\+stopped\+By\+Queue\+Limits}{m_stoppedByQueueLimits}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Net\+Device\+Queue\+::m\+\_\+stopped\+By\+Queue\+Limits\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1NetDeviceQueue_a025451a1ed0b95ba3e10b1597f1b3873}{}\label{classns3_1_1NetDeviceQueue_a025451a1ed0b95ba3e10b1597f1b3873}


True if the queue has been stopped by a queue limits object. 

\index{ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}!m\+\_\+wake\+Callback@{m\+\_\+wake\+Callback}}
\index{m\+\_\+wake\+Callback@{m\+\_\+wake\+Callback}!ns3\+::\+Net\+Device\+Queue@{ns3\+::\+Net\+Device\+Queue}}
\subsubsection[{\texorpdfstring{m\+\_\+wake\+Callback}{m_wakeCallback}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Wake\+Callback} ns3\+::\+Net\+Device\+Queue\+::m\+\_\+wake\+Callback\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1NetDeviceQueue_abfc6b3a5c3cbbd967400751e7184b2d7}{}\label{classns3_1_1NetDeviceQueue_abfc6b3a5c3cbbd967400751e7184b2d7}


Wake callback. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
network/utils/\hyperlink{net-device-queue-interface_8h}{net-\/device-\/queue-\/interface.\+h}\item 
network/utils/\hyperlink{net-device-queue-interface_8cc}{net-\/device-\/queue-\/interface.\+cc}\end{DoxyCompactItemize}
