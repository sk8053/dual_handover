\hypertarget{classns3_1_1Ipv4RoutingHelper}{}\section{ns3\+:\+:Ipv4\+Routing\+Helper Class Reference}
\label{classns3_1_1Ipv4RoutingHelper}\index{ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}}


a factory to create \hyperlink{classns3_1_1Ipv4RoutingProtocol}{ns3\+::\+Ipv4\+Routing\+Protocol} objects  




{\ttfamily \#include $<$ipv4-\/routing-\/helper.\+h$>$}



Inheritance diagram for ns3\+:\+:Ipv4\+Routing\+Helper\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Ipv4\+Routing\+Helper\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual \hyperlink{classns3_1_1Ipv4RoutingHelper_a66f82dc0628b52ad186c7c73e4cd096e}{$\sim$\+Ipv4\+Routing\+Helper} ()
\item 
virtual \hyperlink{classns3_1_1Ipv4RoutingHelper}{Ipv4\+Routing\+Helper} $\ast$ \hyperlink{classns3_1_1Ipv4RoutingHelper_acf569a0ecf95d5b5186456f368eaa465}{Copy} (void) const =0
\begin{DoxyCompactList}\small\item\em virtual constructor \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} $>$ \hyperlink{classns3_1_1Ipv4RoutingHelper_aa00350f9ab9f2ea2ff83f6ef04dae209}{Create} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node) const =0
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static void \hyperlink{classns3_1_1Ipv4RoutingHelper_a10d8ba23eca330de968fdfbca2730ec3}{Print\+Routing\+Table\+All\+At} (\hyperlink{classns3_1_1Time}{Time} print\+Time, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream, \hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295a}{Time\+::\+Unit} unit=\hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295aade8622b06524a328cd3a59db6ccf76af}{Time\+::S})
\begin{DoxyCompactList}\small\item\em prints the routing tables of all nodes at a particular time. \end{DoxyCompactList}\item 
static void \hyperlink{classns3_1_1Ipv4RoutingHelper_ae82209b94194b58afed38b80e92ed202}{Print\+Routing\+Table\+All\+Every} (\hyperlink{classns3_1_1Time}{Time} print\+Interval, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream, \hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295a}{Time\+::\+Unit} unit=\hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295aade8622b06524a328cd3a59db6ccf76af}{Time\+::S})
\begin{DoxyCompactList}\small\item\em prints the routing tables of all nodes at regular intervals specified by user. \end{DoxyCompactList}\item 
static void \hyperlink{classns3_1_1Ipv4RoutingHelper_a0abbae008296b5ab6f4e7612390ee37f}{Print\+Routing\+Table\+At} (\hyperlink{classns3_1_1Time}{Time} print\+Time, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream, \hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295a}{Time\+::\+Unit} unit=\hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295aade8622b06524a328cd3a59db6ccf76af}{Time\+::S})
\begin{DoxyCompactList}\small\item\em prints the routing tables of a node at a particular time. \end{DoxyCompactList}\item 
static void \hyperlink{classns3_1_1Ipv4RoutingHelper_ae2af473c43fc96aecd689072887d7dce}{Print\+Routing\+Table\+Every} (\hyperlink{classns3_1_1Time}{Time} print\+Interval, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream, \hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295a}{Time\+::\+Unit} unit=\hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295aade8622b06524a328cd3a59db6ccf76af}{Time\+::S})
\begin{DoxyCompactList}\small\item\em prints the routing tables of a node at regular intervals specified by user. \end{DoxyCompactList}\item 
static void \hyperlink{classns3_1_1Ipv4RoutingHelper_ab74b74f056874f2058c1a1b2e0573049}{Print\+Neighbor\+Cache\+All\+At} (\hyperlink{classns3_1_1Time}{Time} print\+Time, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream)
\begin{DoxyCompactList}\small\item\em prints the neighbor cache of all nodes at a particular time. \end{DoxyCompactList}\item 
static void \hyperlink{classns3_1_1Ipv4RoutingHelper_ab9a6ef81b586a23f92fc1595c52661de}{Print\+Neighbor\+Cache\+All\+Every} (\hyperlink{classns3_1_1Time}{Time} print\+Interval, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream)
\begin{DoxyCompactList}\small\item\em prints the neighbor cache of all nodes at regular intervals specified by user. \end{DoxyCompactList}\item 
static void \hyperlink{classns3_1_1Ipv4RoutingHelper_a6cbcf152538f660d62508ca5e398a982}{Print\+Neighbor\+Cache\+At} (\hyperlink{classns3_1_1Time}{Time} print\+Time, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream)
\begin{DoxyCompactList}\small\item\em prints the neighbor cache of a node at a particular time. \end{DoxyCompactList}\item 
static void \hyperlink{classns3_1_1Ipv4RoutingHelper_a8e2a4a699fedde1a4dd18db03c2694b0}{Print\+Neighbor\+Cache\+Every} (\hyperlink{classns3_1_1Time}{Time} print\+Interval, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream)
\begin{DoxyCompactList}\small\item\em prints the neighbor cache of a node at regular intervals specified by user. \end{DoxyCompactList}\item 
{\footnotesize template$<$class T $>$ }\\static \hyperlink{classns3_1_1Ptr}{Ptr}$<$ T $>$ \hyperlink{classns3_1_1Ipv4RoutingHelper_a97b656bcb2a4e6634698c0686f087159}{Get\+Routing} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} $>$ protocol)
\begin{DoxyCompactList}\small\item\em Request a specified routing protocol $<$T$>$ from \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} protocol. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Private Member Functions}
\begin{DoxyCompactItemize}
\item 
static void \hyperlink{classns3_1_1Ipv4RoutingHelper_a76916d127d8b18fd9eb7688d83f9ff20}{Print} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream, \hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295a}{Time\+::\+Unit} unit=\hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295aade8622b06524a328cd3a59db6ccf76af}{Time\+::S})
\begin{DoxyCompactList}\small\item\em prints the routing tables of a node. \end{DoxyCompactList}\item 
static void \hyperlink{classns3_1_1Ipv4RoutingHelper_a5a7009aae503d8d191cedfce4f4278c0}{Print\+Every} (\hyperlink{classns3_1_1Time}{Time} print\+Interval, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream, \hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295a}{Time\+::\+Unit} unit=\hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295aade8622b06524a328cd3a59db6ccf76af}{Time\+::S})
\begin{DoxyCompactList}\small\item\em prints the routing tables of a node at regular intervals specified by user. \end{DoxyCompactList}\item 
static void \hyperlink{classns3_1_1Ipv4RoutingHelper_ae2bcc2aced34f45479b388fa16761e85}{Print\+Arp\+Cache} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream)
\begin{DoxyCompactList}\small\item\em prints the neighbor cache of a node. \end{DoxyCompactList}\item 
static void \hyperlink{classns3_1_1Ipv4RoutingHelper_a34f51ee22efe6ae308e4843741e80388}{Print\+Arp\+Cache\+Every} (\hyperlink{classns3_1_1Time}{Time} print\+Interval, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream)
\begin{DoxyCompactList}\small\item\em prints the neighbor cache of a node at regular intervals specified by user. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
a factory to create \hyperlink{classns3_1_1Ipv4RoutingProtocol}{ns3\+::\+Ipv4\+Routing\+Protocol} objects 

For each new routing protocol created as a subclass of \hyperlink{classns3_1_1Ipv4RoutingProtocol}{ns3\+::\+Ipv4\+Routing\+Protocol}, you need to create a subclass of \hyperlink{classns3_1_1Ipv4RoutingHelper}{ns3\+::\+Ipv4\+Routing\+Helper} which can be used by \hyperlink{classns3_1_1InternetStackHelper_a3e382c02df022dec79952a7eca8cd5ba}{ns3\+::\+Internet\+Stack\+Helper\+::\+Set\+Routing\+Helper} and \hyperlink{classns3_1_1InternetStackHelper_a6645b412f31283d2d9bc3d8a95cebbc0}{ns3\+::\+Internet\+Stack\+Helper\+::\+Install}. 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}!````~Ipv4\+Routing\+Helper@{$\sim$\+Ipv4\+Routing\+Helper}}
\index{````~Ipv4\+Routing\+Helper@{$\sim$\+Ipv4\+Routing\+Helper}!ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{$\sim$\+Ipv4\+Routing\+Helper()}{~Ipv4RoutingHelper()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv4\+Routing\+Helper\+::$\sim$\+Ipv4\+Routing\+Helper (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4RoutingHelper_a66f82dc0628b52ad186c7c73e4cd096e}{}\label{classns3_1_1Ipv4RoutingHelper_a66f82dc0628b52ad186c7c73e4cd096e}

\begin{DoxyCode}
35 \{
36 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}!Copy@{Copy}}
\index{Copy@{Copy}!ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Copy(void) const =0}{Copy(void) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Ipv4\+Routing\+Helper}$\ast$ ns3\+::\+Ipv4\+Routing\+Helper\+::\+Copy (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4RoutingHelper_acf569a0ecf95d5b5186456f368eaa465}{}\label{classns3_1_1Ipv4RoutingHelper_acf569a0ecf95d5b5186456f368eaa465}


virtual constructor 

\begin{DoxyReturn}{Returns}
pointer to clone of this \hyperlink{classns3_1_1Ipv4RoutingHelper}{Ipv4\+Routing\+Helper}
\end{DoxyReturn}
This method is mainly for internal use by the other helpers; clients are expected to free the dynamic memory allocated by this method 

Implemented in \hyperlink{classns3_1_1RipHelper_a9d9a8f0f57b1dc853c1d64f860b8510a}{ns3\+::\+Rip\+Helper}, \hyperlink{classns3_1_1Ipv4ListRoutingHelper_ad3fd2a48714f76a854da26da012d8cf3}{ns3\+::\+Ipv4\+List\+Routing\+Helper}, \hyperlink{classns3_1_1Ipv4StaticRoutingHelper_a0cf5ca3ae4ffbfab2ed392e47327ee43}{ns3\+::\+Ipv4\+Static\+Routing\+Helper}, \hyperlink{classns3_1_1OlsrHelper_af546fca892f59583bd40a9611dd4ec91}{ns3\+::\+Olsr\+Helper}, \hyperlink{classns3_1_1Ipv4NixVectorHelper_a7c0df9f3d269dedeb235232f510f7e11}{ns3\+::\+Ipv4\+Nix\+Vector\+Helper}, \hyperlink{classns3_1_1DsdvHelper_aa970c778597f490eba0377253eeb68a6}{ns3\+::\+Dsdv\+Helper}, \hyperlink{classns3_1_1Ipv4GlobalRoutingHelper_a6fd74d97461818a65d3d22becb1b6015}{ns3\+::\+Ipv4\+Global\+Routing\+Helper}, and \hyperlink{classns3_1_1AodvHelper_afd466ee08d419ba826ec4b1d1ee91dbd}{ns3\+::\+Aodv\+Helper}.



Here is the caller graph for this function\+:
% FIG 2


\index{ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}!Create@{Create}}
\index{Create@{Create}!ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Create(\+Ptr$<$ Node $>$ node) const =0}{Create(Ptr< Node > node) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Ptr}$<${\bf Ipv4\+Routing\+Protocol}$>$ ns3\+::\+Ipv4\+Routing\+Helper\+::\+Create (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4RoutingHelper_aa00350f9ab9f2ea2ff83f6ef04dae209}{}\label{classns3_1_1Ipv4RoutingHelper_aa00350f9ab9f2ea2ff83f6ef04dae209}

\begin{DoxyParams}{Parameters}
{\em node} & the node within which the new routing protocol will run \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a newly-\/created routing protocol 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv4ListRoutingHelper_aba2da53223e807fc446608c3b6f078c7}{ns3\+::\+Ipv4\+List\+Routing\+Helper}, \hyperlink{classns3_1_1OlsrHelper_abf3f54af63afa19675712bee4934ad82}{ns3\+::\+Olsr\+Helper}, \hyperlink{classns3_1_1RipHelper_af9b89490714b2f494beec7a0f628346b}{ns3\+::\+Rip\+Helper}, \hyperlink{classns3_1_1Ipv4StaticRoutingHelper_afb0392b022183275e7949eb9235334e9}{ns3\+::\+Ipv4\+Static\+Routing\+Helper}, \hyperlink{classns3_1_1DsdvHelper_a3ddb5f954a8c681cf8d1b0bee78f772f}{ns3\+::\+Dsdv\+Helper}, \hyperlink{classns3_1_1Ipv4NixVectorHelper_a803ebba1b96868068ae0c23b26ae0325}{ns3\+::\+Ipv4\+Nix\+Vector\+Helper}, \hyperlink{classns3_1_1Ipv4GlobalRoutingHelper_a7aad4286a1ead7073bd73c6b19a32a59}{ns3\+::\+Ipv4\+Global\+Routing\+Helper}, and \hyperlink{classns3_1_1AodvHelper_a4e588837b00d654debf150b149216b2d}{ns3\+::\+Aodv\+Helper}.



Here is the caller graph for this function\+:
% FIG 3


\index{ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}!Get\+Routing@{Get\+Routing}}
\index{Get\+Routing@{Get\+Routing}!ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Get\+Routing(\+Ptr$<$ Ipv4\+Routing\+Protocol $>$ protocol)}{GetRouting(Ptr< Ipv4RoutingProtocol > protocol)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ {\bf Ptr}$<$ T $>$ ns3\+::\+Ipv4\+Routing\+Helper\+::\+Get\+Routing (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv4\+Routing\+Protocol} $>$}]{protocol}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv4RoutingHelper_a97b656bcb2a4e6634698c0686f087159}{}\label{classns3_1_1Ipv4RoutingHelper_a97b656bcb2a4e6634698c0686f087159}


Request a specified routing protocol $<$T$>$ from \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} protocol. 

If protocol is \hyperlink{classns3_1_1Ipv4ListRouting}{Ipv4\+List\+Routing}, then protocol will be searched in the list, otherwise a simple Dynamic\+Cast will be performed


\begin{DoxyParams}{Parameters}
{\em protocol} & Smart pointer to \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} object \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a Smart Pointer to the requested protocol (zero if the protocol can\textquotesingle{}t be found) 
\end{DoxyReturn}

\begin{DoxyCode}
262 \{
263   Ptr<T> ret = DynamicCast<T> (protocol);
264   \textcolor{keywordflow}{if} (ret == 0)
265     \{
266       \textcolor{comment}{// trying to check if protocol is a list routing}
267       Ptr<Ipv4ListRouting> lrp = DynamicCast<Ipv4ListRouting> (protocol);
268       \textcolor{keywordflow}{if} (lrp != 0)
269         \{
270           \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < lrp->GetNRoutingProtocols ();  \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
271             \{
272               int16\_t priority;
273               ret = GetRouting<T> (lrp->GetRoutingProtocol (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, priority)); \textcolor{comment}{// potential recursion, if
       inside ListRouting is ListRouting}
274               \textcolor{keywordflow}{if} (ret != 0)
275                 \textcolor{keywordflow}{break};
276             \}
277         \}
278     \}
279 
280   \textcolor{keywordflow}{return} ret;
281 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}!Print@{Print}}
\index{Print@{Print}!ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Print(\+Ptr$<$ Node $>$ node, Ptr$<$ Output\+Stream\+Wrapper $>$ stream, Time\+::\+Unit unit=\+Time\+::\+S)}{Print(Ptr< Node > node, Ptr< OutputStreamWrapper > stream, Time::Unit unit=Time::S)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Routing\+Helper\+::\+Print (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node, }
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream, }
\item[{{\bf Time\+::\+Unit}}]{unit = {\ttfamily {\bf Time\+::S}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4RoutingHelper_a76916d127d8b18fd9eb7688d83f9ff20}{}\label{classns3_1_1Ipv4RoutingHelper_a76916d127d8b18fd9eb7688d83f9ff20}


prints the routing tables of a node. 


\begin{DoxyParams}{Parameters}
{\em node} & The node ptr for which we need the routing table to be printed \\
\hline
{\em stream} & The output stream object to use \\
\hline
{\em unit} & The time unit to be used in the report\\
\hline
\end{DoxyParams}
This method calls the Print\+Routing\+Table() method of the \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} stored in the \hyperlink{classns3_1_1Ipv4}{Ipv4} object; the output format is routing protocol-\/specific. 
\begin{DoxyCode}
72 \{
73   Ptr<Ipv4> ipv4 = node->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv4> ();
74   \textcolor{keywordflow}{if} (ipv4)
75     \{
76       Ptr<Ipv4RoutingProtocol> rp = ipv4->GetRoutingProtocol ();
77       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (rp);
78       rp->PrintRoutingTable (stream, unit);
79     \}
80 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4




Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}!Print\+Arp\+Cache@{Print\+Arp\+Cache}}
\index{Print\+Arp\+Cache@{Print\+Arp\+Cache}!ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Print\+Arp\+Cache(\+Ptr$<$ Node $>$ node, Ptr$<$ Output\+Stream\+Wrapper $>$ stream)}{PrintArpCache(Ptr< Node > node, Ptr< OutputStreamWrapper > stream)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Routing\+Helper\+::\+Print\+Arp\+Cache (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node, }
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4RoutingHelper_ae2bcc2aced34f45479b388fa16761e85}{}\label{classns3_1_1Ipv4RoutingHelper_ae2bcc2aced34f45479b388fa16761e85}


prints the neighbor cache of a node. 


\begin{DoxyParams}{Parameters}
{\em node} & The node ptr for which we need the neighbor cache to be printed \\
\hline
{\em stream} & The output stream object to use\\
\hline
\end{DoxyParams}
This method calls the \hyperlink{classns3_1_1Ipv4RoutingHelper_ae2bcc2aced34f45479b388fa16761e85}{Print\+Arp\+Cache()} method of the \hyperlink{classns3_1_1ArpCache}{Arp\+Cache} associated with each \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} stored in the \hyperlink{classns3_1_1Ipv4}{Ipv4} object, for all nodes at the specified time. The output format is similar to\+: \begin{DoxyVerb}10.1.1.2 dev 1 lladdr 00-06-00:00:00:00:00:02 REACHABLE
\end{DoxyVerb}
 Note that the M\+AC address is printed as \char`\"{}type\char`\"{}-\/\char`\"{}size\char`\"{}-\/\char`\"{}actual address\char`\"{} 
\begin{DoxyCode}
129 \{
130   Ptr<Ipv4L3Protocol> ipv4 = node->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv4L3Protocol> ();
131   \textcolor{keywordflow}{if} (ipv4)
132     \{
133       std::ostream* os = stream->\hyperlink{classns3_1_1OutputStreamWrapper_a0cf30a4188ab6fdae2b2ab74db11acc2}{GetStream} ();
134 
135       *os << \textcolor{stringliteral}{"ARP Cache of node "};
136       std::string found = \hyperlink{classns3_1_1Names_ab9664faf23569aaae64a2d1f65265045}{Names::FindName} (node);
137       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Names_ab9664faf23569aaae64a2d1f65265045}{Names::FindName} (node) != \textcolor{stringliteral}{""})
138         \{
139           *os << found;
140         \}
141       \textcolor{keywordflow}{else}
142         \{
143           *os << static\_cast<int> (node->\hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} ());
144         \}
145       *os << \textcolor{stringliteral}{" at time "} << \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().\hyperlink{classns3_1_1Time_a8f20d5c3b0902d7b4320982f340b57c8}{GetSeconds} () << \textcolor{stringliteral}{"\(\backslash\)n"};
146 
147       \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}=0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}<ipv4->GetNInterfaces(); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
148         \{
149           Ptr<ArpCache> arpCache = ipv4->GetInterface (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})->GetArpCache ();
150           \textcolor{keywordflow}{if} (arpCache)
151             \{
152               arpCache->PrintArpCache (stream);
153             \}
154         \}
155     \}
156 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6




Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}!Print\+Arp\+Cache\+Every@{Print\+Arp\+Cache\+Every}}
\index{Print\+Arp\+Cache\+Every@{Print\+Arp\+Cache\+Every}!ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Print\+Arp\+Cache\+Every(\+Time print\+Interval, Ptr$<$ Node $>$ node, Ptr$<$ Output\+Stream\+Wrapper $>$ stream)}{PrintArpCacheEvery(Time printInterval, Ptr< Node > node, Ptr< OutputStreamWrapper > stream)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Routing\+Helper\+::\+Print\+Arp\+Cache\+Every (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{print\+Interval, }
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node, }
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4RoutingHelper_a34f51ee22efe6ae308e4843741e80388}{}\label{classns3_1_1Ipv4RoutingHelper_a34f51ee22efe6ae308e4843741e80388}


prints the neighbor cache of a node at regular intervals specified by user. 


\begin{DoxyParams}{Parameters}
{\em print\+Interval} & the time interval for which the neighbor cache is supposed to be printed. \\
\hline
{\em node} & The node ptr for which we need the neighbor cache to be printed \\
\hline
{\em stream} & The output stream object to use\\
\hline
\end{DoxyParams}
This method calls the \hyperlink{classns3_1_1Ipv4RoutingHelper_ae2bcc2aced34f45479b388fa16761e85}{Print\+Arp\+Cache()} method of the \hyperlink{classns3_1_1ArpCache}{Arp\+Cache} associated with each \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} stored in the \hyperlink{classns3_1_1Ipv4}{Ipv4} object, for all nodes at the specified time. The output format is similar to\+: \begin{DoxyVerb}10.1.1.2 dev 1 lladdr 00-06-00:00:00:00:00:02 REACHABLE
\end{DoxyVerb}
 Note that the M\+AC address is printed as \char`\"{}type\char`\"{}-\/\char`\"{}size\char`\"{}-\/\char`\"{}actual address\char`\"{} 
\begin{DoxyCode}
160 \{
161   Ptr<Ipv4L3Protocol> ipv4 = node->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv4L3Protocol> ();
162   \textcolor{keywordflow}{if} (ipv4)
163     \{
164       std::ostream* os = stream->\hyperlink{classns3_1_1OutputStreamWrapper_a0cf30a4188ab6fdae2b2ab74db11acc2}{GetStream} ();
165 
166       *os << \textcolor{stringliteral}{"ARP Cache of node "};
167       std::string found = \hyperlink{classns3_1_1Names_ab9664faf23569aaae64a2d1f65265045}{Names::FindName} (node);
168       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Names_ab9664faf23569aaae64a2d1f65265045}{Names::FindName} (node) != \textcolor{stringliteral}{""})
169         \{
170           *os << found;
171         \}
172       \textcolor{keywordflow}{else}
173         \{
174           *os << static\_cast<int> (node->\hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} ());
175         \}
176       *os << \textcolor{stringliteral}{" at time "} << \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().\hyperlink{classns3_1_1Time_a8f20d5c3b0902d7b4320982f340b57c8}{GetSeconds} () << \textcolor{stringliteral}{"\(\backslash\)n"};
177 
178       \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}=0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}<ipv4->GetNInterfaces(); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
179         \{
180           Ptr<ArpCache> arpCache = ipv4->GetInterface (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})->GetArpCache ();
181           \textcolor{keywordflow}{if} (arpCache)
182             \{
183               arpCache->PrintArpCache (stream);
184             \}
185         \}
186       \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (printInterval, &
      \hyperlink{classns3_1_1Ipv4RoutingHelper_a34f51ee22efe6ae308e4843741e80388}{Ipv4RoutingHelper::PrintArpCacheEvery}, printInterval, node, stream);
187     \}
188 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8




Here is the caller graph for this function\+:
% FIG 9


\index{ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}!Print\+Every@{Print\+Every}}
\index{Print\+Every@{Print\+Every}!ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Print\+Every(\+Time print\+Interval, Ptr$<$ Node $>$ node, Ptr$<$ Output\+Stream\+Wrapper $>$ stream, Time\+::\+Unit unit=\+Time\+::\+S)}{PrintEvery(Time printInterval, Ptr< Node > node, Ptr< OutputStreamWrapper > stream, Time::Unit unit=Time::S)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Routing\+Helper\+::\+Print\+Every (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{print\+Interval, }
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node, }
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream, }
\item[{{\bf Time\+::\+Unit}}]{unit = {\ttfamily {\bf Time\+::S}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4RoutingHelper_a5a7009aae503d8d191cedfce4f4278c0}{}\label{classns3_1_1Ipv4RoutingHelper_a5a7009aae503d8d191cedfce4f4278c0}


prints the routing tables of a node at regular intervals specified by user. 


\begin{DoxyParams}{Parameters}
{\em print\+Interval} & the time interval for which the routing table is supposed to be printed. \\
\hline
{\em node} & The node ptr for which we need the routing table to be printed \\
\hline
{\em stream} & The output stream object to use \\
\hline
{\em unit} & The time unit to be used in the report\\
\hline
\end{DoxyParams}
This method calls the Print\+Routing\+Table() method of the \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} stored in the \hyperlink{classns3_1_1Ipv4}{Ipv4} object, for the selected node at the specified interval; the output format is routing protocol-\/specific. 
\begin{DoxyCode}
84 \{
85   Ptr<Ipv4> ipv4 = node->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv4> ();
86   \textcolor{keywordflow}{if} (ipv4)
87     \{
88       Ptr<Ipv4RoutingProtocol> rp = ipv4->GetRoutingProtocol ();
89       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (rp);
90       rp->PrintRoutingTable (stream, unit);
91       \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (printInterval, &
      \hyperlink{classns3_1_1Ipv4RoutingHelper_a5a7009aae503d8d191cedfce4f4278c0}{Ipv4RoutingHelper::PrintEvery}, printInterval, node, stream, unit);
92     \}
93 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10




Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}!Print\+Neighbor\+Cache\+All\+At@{Print\+Neighbor\+Cache\+All\+At}}
\index{Print\+Neighbor\+Cache\+All\+At@{Print\+Neighbor\+Cache\+All\+At}!ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Print\+Neighbor\+Cache\+All\+At(\+Time print\+Time, Ptr$<$ Output\+Stream\+Wrapper $>$ stream)}{PrintNeighborCacheAllAt(Time printTime, Ptr< OutputStreamWrapper > stream)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Routing\+Helper\+::\+Print\+Neighbor\+Cache\+All\+At (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{print\+Time, }
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv4RoutingHelper_ab74b74f056874f2058c1a1b2e0573049}{}\label{classns3_1_1Ipv4RoutingHelper_ab74b74f056874f2058c1a1b2e0573049}


prints the neighbor cache of all nodes at a particular time. 


\begin{DoxyParams}{Parameters}
{\em print\+Time} & the time at which the neighbor cache is supposed to be printed. \\
\hline
{\em stream} & The output stream object to use\\
\hline
\end{DoxyParams}
This method calls the \hyperlink{classns3_1_1Ipv4RoutingHelper_ae2bcc2aced34f45479b388fa16761e85}{Print\+Arp\+Cache()} method of the \hyperlink{classns3_1_1ArpCache}{Arp\+Cache} associated with each \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} stored in the \hyperlink{classns3_1_1Ipv4}{Ipv4} object, for all nodes at the specified time. The output format is similar to\+: \begin{DoxyVerb}10.1.1.2 dev 1 lladdr 00-06-00:00:00:00:00:02 REACHABLE
\end{DoxyVerb}
 Note that the M\+AC address is printed as \char`\"{}type\char`\"{}-\/\char`\"{}size\char`\"{}-\/\char`\"{}actual address\char`\"{} 
\begin{DoxyCode}
97 \{
98   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1NodeList_a1d110b1670005895dd5812baab13682a}{NodeList::GetNNodes} (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
99     \{
100       Ptr<Node> node = \hyperlink{classns3_1_1NodeList_a80ac09977d48d29db5c704ac8483cf6c}{NodeList::GetNode} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
101       \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (printTime, &
      \hyperlink{classns3_1_1Ipv4RoutingHelper_ae2bcc2aced34f45479b388fa16761e85}{Ipv4RoutingHelper::PrintArpCache}, node, stream);
102     \}
103 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12


\index{ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}!Print\+Neighbor\+Cache\+All\+Every@{Print\+Neighbor\+Cache\+All\+Every}}
\index{Print\+Neighbor\+Cache\+All\+Every@{Print\+Neighbor\+Cache\+All\+Every}!ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Print\+Neighbor\+Cache\+All\+Every(\+Time print\+Interval, Ptr$<$ Output\+Stream\+Wrapper $>$ stream)}{PrintNeighborCacheAllEvery(Time printInterval, Ptr< OutputStreamWrapper > stream)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Routing\+Helper\+::\+Print\+Neighbor\+Cache\+All\+Every (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{print\+Interval, }
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv4RoutingHelper_ab9a6ef81b586a23f92fc1595c52661de}{}\label{classns3_1_1Ipv4RoutingHelper_ab9a6ef81b586a23f92fc1595c52661de}


prints the neighbor cache of all nodes at regular intervals specified by user. 


\begin{DoxyParams}{Parameters}
{\em print\+Interval} & the time interval for which the neighbor cache is supposed to be printed. \\
\hline
{\em stream} & The output stream object to use\\
\hline
\end{DoxyParams}
This method calls the \hyperlink{classns3_1_1Ipv4RoutingHelper_ae2bcc2aced34f45479b388fa16761e85}{Print\+Arp\+Cache()} method of the \hyperlink{classns3_1_1ArpCache}{Arp\+Cache} associated with each \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} stored in the \hyperlink{classns3_1_1Ipv4}{Ipv4} object, for all nodes at the specified time. The output format is similar to\+: \begin{DoxyVerb}10.1.1.2 dev 1 lladdr 00-06-00:00:00:00:00:02 REACHABLE
\end{DoxyVerb}
 Note that the M\+AC address is printed as \char`\"{}type\char`\"{}-\/\char`\"{}size\char`\"{}-\/\char`\"{}actual address\char`\"{} 
\begin{DoxyCode}
107 \{
108   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1NodeList_a1d110b1670005895dd5812baab13682a}{NodeList::GetNNodes} (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
109     \{
110       Ptr<Node> node = \hyperlink{classns3_1_1NodeList_a80ac09977d48d29db5c704ac8483cf6c}{NodeList::GetNode} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
111       \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (printInterval, &
      \hyperlink{classns3_1_1Ipv4RoutingHelper_a34f51ee22efe6ae308e4843741e80388}{Ipv4RoutingHelper::PrintArpCacheEvery}, printInterval, node, stream);
112     \}
113 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13


\index{ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}!Print\+Neighbor\+Cache\+At@{Print\+Neighbor\+Cache\+At}}
\index{Print\+Neighbor\+Cache\+At@{Print\+Neighbor\+Cache\+At}!ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Print\+Neighbor\+Cache\+At(\+Time print\+Time, Ptr$<$ Node $>$ node, Ptr$<$ Output\+Stream\+Wrapper $>$ stream)}{PrintNeighborCacheAt(Time printTime, Ptr< Node > node, Ptr< OutputStreamWrapper > stream)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Routing\+Helper\+::\+Print\+Neighbor\+Cache\+At (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{print\+Time, }
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node, }
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv4RoutingHelper_a6cbcf152538f660d62508ca5e398a982}{}\label{classns3_1_1Ipv4RoutingHelper_a6cbcf152538f660d62508ca5e398a982}


prints the neighbor cache of a node at a particular time. 


\begin{DoxyParams}{Parameters}
{\em print\+Time} & the time at which the neighbor cache is supposed to be printed. \\
\hline
{\em node} & The node ptr for which we need the neighbor cache to be printed \\
\hline
{\em stream} & The output stream object to use\\
\hline
\end{DoxyParams}
This method calls the \hyperlink{classns3_1_1Ipv4RoutingHelper_ae2bcc2aced34f45479b388fa16761e85}{Print\+Arp\+Cache()} method of the \hyperlink{classns3_1_1ArpCache}{Arp\+Cache} associated with each \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} stored in the \hyperlink{classns3_1_1Ipv4}{Ipv4} object, for all nodes at the specified time. The output format is similar to\+: \begin{DoxyVerb}10.1.1.2 dev 1 lladdr 00-06-00:00:00:00:00:02 REACHABLE
\end{DoxyVerb}
 Note that the M\+AC address is printed as \char`\"{}type\char`\"{}-\/\char`\"{}size\char`\"{}-\/\char`\"{}actual address\char`\"{} 
\begin{DoxyCode}
117 \{
118   \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (printTime, &
      \hyperlink{classns3_1_1Ipv4RoutingHelper_ae2bcc2aced34f45479b388fa16761e85}{Ipv4RoutingHelper::PrintArpCache}, node, stream);
119 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 14


\index{ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}!Print\+Neighbor\+Cache\+Every@{Print\+Neighbor\+Cache\+Every}}
\index{Print\+Neighbor\+Cache\+Every@{Print\+Neighbor\+Cache\+Every}!ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Print\+Neighbor\+Cache\+Every(\+Time print\+Interval, Ptr$<$ Node $>$ node, Ptr$<$ Output\+Stream\+Wrapper $>$ stream)}{PrintNeighborCacheEvery(Time printInterval, Ptr< Node > node, Ptr< OutputStreamWrapper > stream)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Routing\+Helper\+::\+Print\+Neighbor\+Cache\+Every (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{print\+Interval, }
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node, }
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv4RoutingHelper_a8e2a4a699fedde1a4dd18db03c2694b0}{}\label{classns3_1_1Ipv4RoutingHelper_a8e2a4a699fedde1a4dd18db03c2694b0}


prints the neighbor cache of a node at regular intervals specified by user. 


\begin{DoxyParams}{Parameters}
{\em print\+Interval} & the time interval for which the neighbor cache is supposed to be printed. \\
\hline
{\em node} & The node ptr for which we need the neighbor cache to be printed \\
\hline
{\em stream} & The output stream object to use\\
\hline
\end{DoxyParams}
This method calls the \hyperlink{classns3_1_1Ipv4RoutingHelper_ae2bcc2aced34f45479b388fa16761e85}{Print\+Arp\+Cache()} method of the \hyperlink{classns3_1_1ArpCache}{Arp\+Cache} associated with each \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} stored in the \hyperlink{classns3_1_1Ipv4}{Ipv4} object, for all nodes at the specified time. The output format is similar to\+: \begin{DoxyVerb}10.1.1.2 dev 1 lladdr 00-06-00:00:00:00:00:02 REACHABLE
\end{DoxyVerb}
 Note that the M\+AC address is printed as \char`\"{}type\char`\"{}-\/\char`\"{}size\char`\"{}-\/\char`\"{}actual address\char`\"{} 
\begin{DoxyCode}
123 \{
124   \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (printInterval, &
      \hyperlink{classns3_1_1Ipv4RoutingHelper_a34f51ee22efe6ae308e4843741e80388}{Ipv4RoutingHelper::PrintArpCacheEvery}, printInterval, node, stream);
125 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 15


\index{ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}!Print\+Routing\+Table\+All\+At@{Print\+Routing\+Table\+All\+At}}
\index{Print\+Routing\+Table\+All\+At@{Print\+Routing\+Table\+All\+At}!ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Print\+Routing\+Table\+All\+At(\+Time print\+Time, Ptr$<$ Output\+Stream\+Wrapper $>$ stream, Time\+::\+Unit unit=\+Time\+::\+S)}{PrintRoutingTableAllAt(Time printTime, Ptr< OutputStreamWrapper > stream, Time::Unit unit=Time::S)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Routing\+Helper\+::\+Print\+Routing\+Table\+All\+At (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{print\+Time, }
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream, }
\item[{{\bf Time\+::\+Unit}}]{unit = {\ttfamily {\bf Time\+::S}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv4RoutingHelper_a10d8ba23eca330de968fdfbca2730ec3}{}\label{classns3_1_1Ipv4RoutingHelper_a10d8ba23eca330de968fdfbca2730ec3}


prints the routing tables of all nodes at a particular time. 


\begin{DoxyParams}{Parameters}
{\em print\+Time} & the time at which the routing table is supposed to be printed. \\
\hline
{\em stream} & The output stream object to use \\
\hline
{\em unit} & The time unit to be used in the report\\
\hline
\end{DoxyParams}
This method calls the Print\+Routing\+Table() method of the \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} stored in the \hyperlink{classns3_1_1Ipv4}{Ipv4} object, for all nodes at the specified time; the output format is routing protocol-\/specific. 
\begin{DoxyCode}
40 \{
41   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1NodeList_a1d110b1670005895dd5812baab13682a}{NodeList::GetNNodes} (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
42     \{
43       Ptr<Node> node = \hyperlink{classns3_1_1NodeList_a80ac09977d48d29db5c704ac8483cf6c}{NodeList::GetNode} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
44       \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (printTime, &
      \hyperlink{classns3_1_1Ipv4RoutingHelper_a76916d127d8b18fd9eb7688d83f9ff20}{Ipv4RoutingHelper::Print}, node, stream, unit);
45     \}
46 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 16




Here is the caller graph for this function\+:
% FIG 17


\index{ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}!Print\+Routing\+Table\+All\+Every@{Print\+Routing\+Table\+All\+Every}}
\index{Print\+Routing\+Table\+All\+Every@{Print\+Routing\+Table\+All\+Every}!ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Print\+Routing\+Table\+All\+Every(\+Time print\+Interval, Ptr$<$ Output\+Stream\+Wrapper $>$ stream, Time\+::\+Unit unit=\+Time\+::\+S)}{PrintRoutingTableAllEvery(Time printInterval, Ptr< OutputStreamWrapper > stream, Time::Unit unit=Time::S)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Routing\+Helper\+::\+Print\+Routing\+Table\+All\+Every (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{print\+Interval, }
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream, }
\item[{{\bf Time\+::\+Unit}}]{unit = {\ttfamily {\bf Time\+::S}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv4RoutingHelper_ae82209b94194b58afed38b80e92ed202}{}\label{classns3_1_1Ipv4RoutingHelper_ae82209b94194b58afed38b80e92ed202}


prints the routing tables of all nodes at regular intervals specified by user. 


\begin{DoxyParams}{Parameters}
{\em print\+Interval} & the time interval for which the routing table is supposed to be printed. \\
\hline
{\em stream} & The output stream object to use \\
\hline
{\em unit} & The time unit to be used in the report\\
\hline
\end{DoxyParams}
This method calls the Print\+Routing\+Table() method of the \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} stored in the \hyperlink{classns3_1_1Ipv4}{Ipv4} object, for all nodes at the specified time interval; the output format is routing protocol-\/specific. 
\begin{DoxyCode}
50 \{
51   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1NodeList_a1d110b1670005895dd5812baab13682a}{NodeList::GetNNodes} (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
52     \{
53       Ptr<Node> node = \hyperlink{classns3_1_1NodeList_a80ac09977d48d29db5c704ac8483cf6c}{NodeList::GetNode} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
54       \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (printInterval, &
      \hyperlink{classns3_1_1Ipv4RoutingHelper_a5a7009aae503d8d191cedfce4f4278c0}{Ipv4RoutingHelper::PrintEvery}, printInterval, node, stream, unit);
55     \}
56 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 18


\index{ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}!Print\+Routing\+Table\+At@{Print\+Routing\+Table\+At}}
\index{Print\+Routing\+Table\+At@{Print\+Routing\+Table\+At}!ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Print\+Routing\+Table\+At(\+Time print\+Time, Ptr$<$ Node $>$ node, Ptr$<$ Output\+Stream\+Wrapper $>$ stream, Time\+::\+Unit unit=\+Time\+::\+S)}{PrintRoutingTableAt(Time printTime, Ptr< Node > node, Ptr< OutputStreamWrapper > stream, Time::Unit unit=Time::S)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Routing\+Helper\+::\+Print\+Routing\+Table\+At (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{print\+Time, }
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node, }
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream, }
\item[{{\bf Time\+::\+Unit}}]{unit = {\ttfamily {\bf Time\+::S}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv4RoutingHelper_a0abbae008296b5ab6f4e7612390ee37f}{}\label{classns3_1_1Ipv4RoutingHelper_a0abbae008296b5ab6f4e7612390ee37f}


prints the routing tables of a node at a particular time. 


\begin{DoxyParams}{Parameters}
{\em print\+Time} & the time at which the routing table is supposed to be printed. \\
\hline
{\em node} & The node ptr for which we need the routing table to be printed \\
\hline
{\em stream} & The output stream object to use \\
\hline
{\em unit} & The time unit to be used in the report\\
\hline
\end{DoxyParams}
This method calls the Print\+Routing\+Table() method of the \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} stored in the \hyperlink{classns3_1_1Ipv4}{Ipv4} object, for the selected node at the specified time; the output format is routing protocol-\/specific. 
\begin{DoxyCode}
60 \{
61   \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (printTime, &\hyperlink{classns3_1_1Ipv4RoutingHelper_a76916d127d8b18fd9eb7688d83f9ff20}{Ipv4RoutingHelper::Print}, 
      node, stream, unit);
62 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 19


\index{ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}!Print\+Routing\+Table\+Every@{Print\+Routing\+Table\+Every}}
\index{Print\+Routing\+Table\+Every@{Print\+Routing\+Table\+Every}!ns3\+::\+Ipv4\+Routing\+Helper@{ns3\+::\+Ipv4\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Print\+Routing\+Table\+Every(\+Time print\+Interval, Ptr$<$ Node $>$ node, Ptr$<$ Output\+Stream\+Wrapper $>$ stream, Time\+::\+Unit unit=\+Time\+::\+S)}{PrintRoutingTableEvery(Time printInterval, Ptr< Node > node, Ptr< OutputStreamWrapper > stream, Time::Unit unit=Time::S)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Routing\+Helper\+::\+Print\+Routing\+Table\+Every (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{print\+Interval, }
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node, }
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream, }
\item[{{\bf Time\+::\+Unit}}]{unit = {\ttfamily {\bf Time\+::S}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv4RoutingHelper_ae2af473c43fc96aecd689072887d7dce}{}\label{classns3_1_1Ipv4RoutingHelper_ae2af473c43fc96aecd689072887d7dce}


prints the routing tables of a node at regular intervals specified by user. 


\begin{DoxyParams}{Parameters}
{\em print\+Interval} & the time interval for which the routing table is supposed to be printed. \\
\hline
{\em node} & The node ptr for which we need the routing table to be printed \\
\hline
{\em stream} & The output stream object to use \\
\hline
{\em unit} & The time unit to be used in the report\\
\hline
\end{DoxyParams}
This method calls the Print\+Routing\+Table() method of the \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} stored in the \hyperlink{classns3_1_1Ipv4}{Ipv4} object, for the selected node at the specified interval; the output format is routing protocol-\/specific. 
\begin{DoxyCode}
66 \{
67   \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (printInterval, &
      \hyperlink{classns3_1_1Ipv4RoutingHelper_a5a7009aae503d8d191cedfce4f4278c0}{Ipv4RoutingHelper::PrintEvery}, printInterval, node, stream, unit);
68 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 20




The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/helper/\hyperlink{ipv4-routing-helper_8h}{ipv4-\/routing-\/helper.\+h}\item 
internet/helper/\hyperlink{ipv4-routing-helper_8cc}{ipv4-\/routing-\/helper.\+cc}\end{DoxyCompactItemize}
