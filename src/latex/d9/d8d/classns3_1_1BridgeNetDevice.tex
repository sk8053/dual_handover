\hypertarget{classns3_1_1BridgeNetDevice}{}\section{ns3\+:\+:Bridge\+Net\+Device Class Reference}
\label{classns3_1_1BridgeNetDevice}\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}


a virtual net device that bridges multiple L\+AN segments  




{\ttfamily \#include $<$bridge-\/net-\/device.\+h$>$}



Inheritance diagram for ns3\+:\+:Bridge\+Net\+Device\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Bridge\+Net\+Device\+:
% FIG 1
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structns3_1_1BridgeNetDevice_1_1LearnedState}{Learned\+State}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1BridgeNetDevice_ab113a3cc0394ab89479fbdae8c21c27a}{Bridge\+Net\+Device} ()
\item 
virtual \hyperlink{classns3_1_1BridgeNetDevice_ab94b1e287fdec3d21ea0bf485244825e}{$\sim$\+Bridge\+Net\+Device} ()
\item 
void \hyperlink{classns3_1_1BridgeNetDevice_a963a535726ea5c94e2258825d0de260a}{Add\+Bridge\+Port} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ bridge\+Port)
\begin{DoxyCompactList}\small\item\em Add a \textquotesingle{}port\textquotesingle{} to a bridge device. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1BridgeNetDevice_a93fbb63deb6803390b53cf537ac66a2d}{Get\+N\+Bridge\+Ports} (void) const 
\begin{DoxyCompactList}\small\item\em Gets the number of bridged \textquotesingle{}ports\textquotesingle{}, i.\+e., the Net\+Devices currently bridged. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ \hyperlink{classns3_1_1BridgeNetDevice_ada7284f361adefebb72364c61446ed05}{Get\+Bridge\+Port} (uint32\+\_\+t \hyperlink{lte__link__budget__x2__handover__measures_8m_abdb05bc5a064cf642a06c83b3392f148}{n}) const 
\begin{DoxyCompactList}\small\item\em Gets the n-\/th bridged port. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1BridgeNetDevice_a94fe34b7074a4ac12cb3ae8f3272d1e1}{Set\+If\+Index} (const uint32\+\_\+t index)
\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1BridgeNetDevice_a7e7679e8e284072bb9fc1a950ca57594}{Get\+If\+Index} (void) const 
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Channel}{Channel} $>$ \hyperlink{classns3_1_1BridgeNetDevice_ae40842a4c4b32ba6c39381e65e71320e}{Get\+Channel} (void) const 
\item 
virtual void \hyperlink{classns3_1_1BridgeNetDevice_a455c6aa85f8790a9588b6fd794f2d920}{Set\+Address} (\hyperlink{classns3_1_1Address}{Address} address)
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1BridgeNetDevice_a2bf34b9c7dfde567cfa90dde807185ab}{Get\+Address} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1BridgeNetDevice_afc362f1047067ebf64e2f81f790f9c50}{Set\+Mtu} (const uint16\+\_\+t mtu)
\item 
virtual uint16\+\_\+t \hyperlink{classns3_1_1BridgeNetDevice_a86e660792da21b0c3eafb103cfc228c5}{Get\+Mtu} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1BridgeNetDevice_ad40e11c2707ff5c012c71c288b281cce}{Is\+Link\+Up} (void) const 
\item 
virtual void \hyperlink{classns3_1_1BridgeNetDevice_ad883eed3ac45d608e4d5683992ae9e9d}{Add\+Link\+Change\+Callback} (\hyperlink{classns3_1_1Callback}{Callback}$<$ void $>$ callback)
\item 
virtual bool \hyperlink{classns3_1_1BridgeNetDevice_ac56c83ea08ab0df37ac19777a5dd8d7f}{Is\+Broadcast} (void) const 
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1BridgeNetDevice_a35c3033a90f189f94e4b5d6951630c19}{Get\+Broadcast} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1BridgeNetDevice_a865db3336d37fca6cd09c46c93199a38}{Is\+Multicast} (void) const 
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1BridgeNetDevice_ab6714d1180ea4f909087418989e3851f}{Get\+Multicast} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} multicast\+Group) const 
\begin{DoxyCompactList}\small\item\em Make and return a M\+AC multicast address using the provided multicast group. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1BridgeNetDevice_a87de7a289e4485873185a2db12dd0665}{Is\+Point\+To\+Point} (void) const 
\begin{DoxyCompactList}\small\item\em Return true if the net device is on a point-\/to-\/point link. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1BridgeNetDevice_a35be2b9e5834724af90adde9fb1c2f70}{Is\+Bridge} (void) const 
\begin{DoxyCompactList}\small\item\em Return true if the net device is acting as a bridge. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1BridgeNetDevice_ac94136d6499505f6712c939c35b97e06}{Send} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, const \hyperlink{classns3_1_1Address}{Address} \&dest, uint16\+\_\+t protocol\+Number)
\item 
virtual bool \hyperlink{classns3_1_1BridgeNetDevice_a7ad2acf7936e29f003c9046d76ea2099}{Send\+From} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, const \hyperlink{classns3_1_1Address}{Address} \&source, const \hyperlink{classns3_1_1Address}{Address} \&dest, uint16\+\_\+t protocol\+Number)
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1BridgeNetDevice_acf2c0417701321ab9c3db740f9de5f79}{Get\+Node} (void) const 
\item 
virtual void \hyperlink{classns3_1_1BridgeNetDevice_a2720492d8546e096200dbec52105b7cd}{Set\+Node} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node)
\item 
virtual bool \hyperlink{classns3_1_1BridgeNetDevice_a8c2054a731287fa948512b7dce9d9d7c}{Needs\+Arp} (void) const 
\item 
virtual void \hyperlink{classns3_1_1BridgeNetDevice_abb019b6f29cbab5305195a38a415ddd1}{Set\+Receive\+Callback} (\hyperlink{classns3_1_1NetDevice_ad5e5e1ca187472bc2ba99575d8def568}{Net\+Device\+::\+Receive\+Callback} cb)
\item 
virtual void \hyperlink{classns3_1_1BridgeNetDevice_a01af49738a7fe604a04a7f3f273a1485}{Set\+Promisc\+Receive\+Callback} (\hyperlink{classns3_1_1NetDevice_a427225795919f26c414bee2ea3f31ed2}{Net\+Device\+::\+Promisc\+Receive\+Callback} cb)
\item 
virtual bool \hyperlink{classns3_1_1BridgeNetDevice_a204774b4a1fa122412c7ef273b7463a3}{Supports\+Send\+From} () const 
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1BridgeNetDevice_aa6d896c3ead0f292d2c85a5f69d5438b}{Get\+Multicast} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} addr) const 
\begin{DoxyCompactList}\small\item\em Get the M\+AC multicast address corresponding to the I\+Pv6 address provided. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1BridgeNetDevice_a9c8adb9ce413618caaa052929b69a6c9}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1BridgeNetDevice_ac8233fc38afed1acc24fc9d3cb19d498}{Do\+Dispose} (void)
\item 
void \hyperlink{classns3_1_1BridgeNetDevice_a958c86321b73b2c400b54bfad9d03e68}{Receive\+From\+Device} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, uint16\+\_\+t protocol, \hyperlink{classns3_1_1Address}{Address} const \&source, \hyperlink{classns3_1_1Address}{Address} const \&destination, \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2}{Packet\+Type} packet\+Type)
\begin{DoxyCompactList}\small\item\em Receives a packet from one bridged port. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1BridgeNetDevice_a815693fe0b0d77e33e1843fa7d991701}{Forward\+Unicast} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ incoming\+Port, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, uint16\+\_\+t protocol, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} src, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} dst)
\begin{DoxyCompactList}\small\item\em Forwards a unicast packet. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1BridgeNetDevice_af3eff77ebe2114537d28aacc77adef45}{Forward\+Broadcast} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ incoming\+Port, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, uint16\+\_\+t protocol, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} src, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} dst)
\begin{DoxyCompactList}\small\item\em Forwards a broadcast or a multicast packet. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1BridgeNetDevice_a9e0a97f4e3b3aa2cd1a3516cb739f721}{Learn} (\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} source, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ \hyperlink{visualizer-ideas_8txt_a21ff1c530daf8435e00048b7fc2c58e3}{port})
\begin{DoxyCompactList}\small\item\em Learns the port a M\+AC address is sending from. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ \hyperlink{classns3_1_1BridgeNetDevice_a944d20ca7524ef699812e653670407b6}{Get\+Learned\+State} (\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} source)
\begin{DoxyCompactList}\small\item\em Gets the port associated to a source address. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1BridgeNetDevice_a6ad6b98824ba200832d18c05ad841ecf}{Bridge\+Net\+Device} (const \hyperlink{classns3_1_1BridgeNetDevice}{Bridge\+Net\+Device} \&)
\begin{DoxyCompactList}\small\item\em Copy constructor. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1BridgeNetDevice}{Bridge\+Net\+Device} \& \hyperlink{classns3_1_1BridgeNetDevice_a8179f775c915bb7e681f05df96460f0d}{operator=} (const \hyperlink{classns3_1_1BridgeNetDevice}{Bridge\+Net\+Device} \&)
\begin{DoxyCompactList}\small\item\em Copy constructor. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1NetDevice_ad5e5e1ca187472bc2ba99575d8def568}{Net\+Device\+::\+Receive\+Callback} \hyperlink{classns3_1_1BridgeNetDevice_a50ecd306e326a77a22666272606fe85a}{m\+\_\+rx\+Callback}
\begin{DoxyCompactList}\small\item\em receive callback \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1NetDevice_a427225795919f26c414bee2ea3f31ed2}{Net\+Device\+::\+Promisc\+Receive\+Callback} \hyperlink{classns3_1_1BridgeNetDevice_ae930168508bfb61f8a7721e7a6312654}{m\+\_\+promisc\+Rx\+Callback}
\begin{DoxyCompactList}\small\item\em promiscuous receive callback \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} \hyperlink{classns3_1_1BridgeNetDevice_a3a8897765d112fe99d399a4b4b947d2f}{m\+\_\+address}
\begin{DoxyCompactList}\small\item\em M\+AC address of the \hyperlink{classns3_1_1NetDevice}{Net\+Device}. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1BridgeNetDevice_a6b6c209fa78de612f218db0dd40b8319}{m\+\_\+expiration\+Time}
\begin{DoxyCompactList}\small\item\em time it takes for learned M\+AC state to expire \end{DoxyCompactList}\item 
std\+::map$<$ \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address}, \hyperlink{structns3_1_1BridgeNetDevice_1_1LearnedState}{Learned\+State} $>$ \hyperlink{classns3_1_1BridgeNetDevice_a201ac30909835a3efd1b34470e8fb5ec}{m\+\_\+learn\+State}
\begin{DoxyCompactList}\small\item\em Container for known address statuses. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1BridgeNetDevice_a1880454d764d3c555c2fa71a9d66345e}{m\+\_\+node}
\begin{DoxyCompactList}\small\item\em node owning this \hyperlink{classns3_1_1NetDevice}{Net\+Device} \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1BridgeChannel}{Bridge\+Channel} $>$ \hyperlink{classns3_1_1BridgeNetDevice_a091384e0ef3d890c26a26d9681b22986}{m\+\_\+channel}
\begin{DoxyCompactList}\small\item\em virtual bridged channel \end{DoxyCompactList}\item 
std\+::vector$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ $>$ \hyperlink{classns3_1_1BridgeNetDevice_accf2a9a81b4be28b155d6b5aeeb185be}{m\+\_\+ports}
\begin{DoxyCompactList}\small\item\em bridged ports \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1BridgeNetDevice_a224b5e6b5a12b9c1dbafec290165eac5}{m\+\_\+if\+Index}
\begin{DoxyCompactList}\small\item\em Interface index. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1BridgeNetDevice_ab0ab0e7f99c14058e65f12bfea364641}{m\+\_\+mtu}
\begin{DoxyCompactList}\small\item\em M\+TU of the bridged \hyperlink{classns3_1_1NetDevice}{Net\+Device}. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1BridgeNetDevice_a94b14f30049e8b7fdcd134b620b5996e}{m\+\_\+enable\+Learning}
\begin{DoxyCompactList}\small\item\em true if the bridge will learn the node status \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
a virtual net device that bridges multiple L\+AN segments 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Bridge\+Net\+Device@{Bridge\+Net\+Device}}
\index{Bridge\+Net\+Device@{Bridge\+Net\+Device}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Bridge\+Net\+Device()}{BridgeNetDevice()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Bridge\+Net\+Device\+::\+Bridge\+Net\+Device (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BridgeNetDevice_ab113a3cc0394ab89479fbdae8c21c27a}{}\label{classns3_1_1BridgeNetDevice_ab113a3cc0394ab89479fbdae8c21c27a}

\begin{DoxyCode}
62   : \hyperlink{classns3_1_1BridgeNetDevice_a1880454d764d3c555c2fa71a9d66345e}{m\_node} (0),
63     \hyperlink{classns3_1_1BridgeNetDevice_a224b5e6b5a12b9c1dbafec290165eac5}{m\_ifIndex} (0)
64 \{
65   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
66   \hyperlink{classns3_1_1BridgeNetDevice_a091384e0ef3d890c26a26d9681b22986}{m\_channel} = CreateObject<BridgeChannel> ();
67 \}
\end{DoxyCode}
\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!````~Bridge\+Net\+Device@{$\sim$\+Bridge\+Net\+Device}}
\index{````~Bridge\+Net\+Device@{$\sim$\+Bridge\+Net\+Device}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{$\sim$\+Bridge\+Net\+Device()}{~BridgeNetDevice()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Bridge\+Net\+Device\+::$\sim$\+Bridge\+Net\+Device (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1BridgeNetDevice_ab94b1e287fdec3d21ea0bf485244825e}{}\label{classns3_1_1BridgeNetDevice_ab94b1e287fdec3d21ea0bf485244825e}

\begin{DoxyCode}
70 \{
71   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
72 \}
\end{DoxyCode}
\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Bridge\+Net\+Device@{Bridge\+Net\+Device}}
\index{Bridge\+Net\+Device@{Bridge\+Net\+Device}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Bridge\+Net\+Device(const Bridge\+Net\+Device \&)}{BridgeNetDevice(const BridgeNetDevice &)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Bridge\+Net\+Device\+::\+Bridge\+Net\+Device (
\begin{DoxyParamCaption}
\item[{const {\bf Bridge\+Net\+Device} \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BridgeNetDevice_a6ad6b98824ba200832d18c05ad841ecf}{}\label{classns3_1_1BridgeNetDevice_a6ad6b98824ba200832d18c05ad841ecf}


Copy constructor. 

Defined and unimplemented to avoid misuse 

\subsection{Member Function Documentation}
\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Add\+Bridge\+Port@{Add\+Bridge\+Port}}
\index{Add\+Bridge\+Port@{Add\+Bridge\+Port}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Add\+Bridge\+Port(\+Ptr$<$ Net\+Device $>$ bridge\+Port)}{AddBridgePort(Ptr< NetDevice > bridgePort)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Bridge\+Net\+Device\+::\+Add\+Bridge\+Port (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{bridge\+Port}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BridgeNetDevice_a963a535726ea5c94e2258825d0de260a}{}\label{classns3_1_1BridgeNetDevice_a963a535726ea5c94e2258825d0de260a}


Add a \textquotesingle{}port\textquotesingle{} to a bridge device. 


\begin{DoxyParams}{Parameters}
{\em bridge\+Port} & the \hyperlink{classns3_1_1NetDevice}{Net\+Device} to add\\
\hline
\end{DoxyParams}
This method adds a new bridge port to a \hyperlink{classns3_1_1BridgeNetDevice}{Bridge\+Net\+Device}, so that the new bridge port \hyperlink{classns3_1_1NetDevice}{Net\+Device} becomes part of the bridge and L2 frames start being forwarded to/from this \hyperlink{classns3_1_1NetDevice}{Net\+Device}.


\begin{DoxyParams}{Parameters}
{\em bridge\+Port} & \hyperlink{classns3_1_1NetDevice}{Net\+Device} \\
\hline
\end{DoxyParams}
\begin{DoxyAttention}{Attention}
The netdevice that is being added as bridge port must {\itshape not} have an IP address. In order to add IP connectivity to a bridging node you must enable IP on the \hyperlink{classns3_1_1BridgeNetDevice}{Bridge\+Net\+Device} itself, never on its port netdevices. 
\end{DoxyAttention}

\begin{DoxyCode}
243 \{
244   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
245   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (bridgePort != \textcolor{keyword}{this});
246   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1Mac48Address_a55cc1e3c6aa63fd1a4f8f7d9be4ae182}{Mac48Address::IsMatchingType} (bridgePort->GetAddress ()))
247     \{
248       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Device does not support eui 48 addresses: cannot be added to bridge."})
      ;
249     \}
250   \textcolor{keywordflow}{if} (!bridgePort->SupportsSendFrom ())
251     \{
252       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Device does not support SendFrom: cannot be added to bridge."});
253     \}
254   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1BridgeNetDevice_a3a8897765d112fe99d399a4b4b947d2f}{m\_address} == Mac48Address ())
255     \{
256       \hyperlink{classns3_1_1BridgeNetDevice_a3a8897765d112fe99d399a4b4b947d2f}{m\_address} = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (bridgePort->GetAddress ());
257     \}
258 
259   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"RegisterProtocolHandler for "} << bridgePort->GetInstanceTypeId ().GetName ());
260   \hyperlink{classns3_1_1BridgeNetDevice_a1880454d764d3c555c2fa71a9d66345e}{m\_node}->\hyperlink{classns3_1_1Node_af713f0e7ea5c49b4fa0b3613405c45fa}{RegisterProtocolHandler} (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1BridgeNetDevice_a958c86321b73b2c400b54bfad9d03e68}{BridgeNetDevice::ReceiveFromDevice}, \textcolor{keyword}{this}),
261                                    0, bridgePort, \textcolor{keyword}{true});
262   \hyperlink{classns3_1_1BridgeNetDevice_accf2a9a81b4be28b155d6b5aeeb185be}{m\_ports}.push\_back (bridgePort);
263   \hyperlink{classns3_1_1BridgeNetDevice_a091384e0ef3d890c26a26d9681b22986}{m\_channel}->AddChannel (bridgePort->GetChannel ());
264 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Add\+Link\+Change\+Callback@{Add\+Link\+Change\+Callback}}
\index{Add\+Link\+Change\+Callback@{Add\+Link\+Change\+Callback}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Add\+Link\+Change\+Callback(\+Callback$<$ void $>$ callback)}{AddLinkChangeCallback(Callback< void > callback)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Bridge\+Net\+Device\+::\+Add\+Link\+Change\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Callback}$<$ void $>$}]{callback}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1BridgeNetDevice_ad883eed3ac45d608e4d5683992ae9e9d}{}\label{classns3_1_1BridgeNetDevice_ad883eed3ac45d608e4d5683992ae9e9d}

\begin{DoxyParams}{Parameters}
{\em callback} & the callback to invoke\\
\hline
\end{DoxyParams}
Add a callback invoked whenever the link status changes to UP. This callback is typically used by the I\+P/\+A\+RP layer to flush the A\+RP cache and by I\+Pv6 stack to flush N\+D\+I\+SC cache whenever the link goes up. 

Implements \hyperlink{classns3_1_1NetDevice_aafb1bf869d38ef7a7112d11fab0163a3}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
327 \{\}
\end{DoxyCode}
\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Do\+Dispose(void)}{DoDispose(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Bridge\+Net\+Device\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1BridgeNetDevice_ac8233fc38afed1acc24fc9d3cb19d498}{}\label{classns3_1_1BridgeNetDevice_ac8233fc38afed1acc24fc9d3cb19d498}
Destructor implementation.

This method is called by \hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose()} or by the \hyperlink{classns3_1_1Object}{Object}\textquotesingle{}s destructor, whichever comes first.

Subclasses are expected to implement their real destruction code in an overriden version of this method and chain up to their parent\textquotesingle{}s implementation once they are done. {\itshape i.\+e}, for simplicity, the destructor of every subclass should be empty and its content should be moved to the associated \hyperlink{classns3_1_1BridgeNetDevice_ac8233fc38afed1acc24fc9d3cb19d498}{Do\+Dispose()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.


\begin{DoxyCode}
76 \{
77   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
78   \textcolor{keywordflow}{for} (std::vector< Ptr<NetDevice> >::iterator iter = \hyperlink{classns3_1_1BridgeNetDevice_accf2a9a81b4be28b155d6b5aeeb185be}{m\_ports}.begin (); iter != 
      \hyperlink{classns3_1_1BridgeNetDevice_accf2a9a81b4be28b155d6b5aeeb185be}{m\_ports}.end (); iter++)
79     \{
80       *iter = 0;
81     \}
82   \hyperlink{classns3_1_1BridgeNetDevice_accf2a9a81b4be28b155d6b5aeeb185be}{m\_ports}.clear ();
83   \hyperlink{classns3_1_1BridgeNetDevice_a091384e0ef3d890c26a26d9681b22986}{m\_channel} = 0;
84   \hyperlink{classns3_1_1BridgeNetDevice_a1880454d764d3c555c2fa71a9d66345e}{m\_node} = 0;
85   \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{NetDevice::DoDispose} ();
86 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Forward\+Broadcast@{Forward\+Broadcast}}
\index{Forward\+Broadcast@{Forward\+Broadcast}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Forward\+Broadcast(\+Ptr$<$ Net\+Device $>$ incoming\+Port, Ptr$<$ const Packet $>$ packet, uint16\+\_\+t protocol, Mac48\+Address src, Mac48\+Address dst)}{ForwardBroadcast(Ptr< NetDevice > incomingPort, Ptr< const Packet > packet, uint16_t protocol, Mac48Address src, Mac48Address dst)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Bridge\+Net\+Device\+::\+Forward\+Broadcast (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{incoming\+Port, }
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{packet, }
\item[{uint16\+\_\+t}]{protocol, }
\item[{{\bf Mac48\+Address}}]{src, }
\item[{{\bf Mac48\+Address}}]{dst}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classns3_1_1BridgeNetDevice_af3eff77ebe2114537d28aacc77adef45}{}\label{classns3_1_1BridgeNetDevice_af3eff77ebe2114537d28aacc77adef45}


Forwards a broadcast or a multicast packet. 


\begin{DoxyParams}{Parameters}
{\em incoming\+Port} & the packet incoming port \\
\hline
{\em packet} & the packet \\
\hline
{\em protocol} & the packet protocol (e.\+g., Ethertype) \\
\hline
{\em src} & the packet source \\
\hline
{\em dst} & the packet destination \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
169 \{
170   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
171   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"LearningBridgeForward (incomingPort="} << incomingPort->GetInstanceTypeId ().
      GetName ()
172                                                        << \textcolor{stringliteral}{", packet="} << packet << \textcolor{stringliteral}{", protocol="}<<protocol
173                                                        << \textcolor{stringliteral}{", src="} << src << \textcolor{stringliteral}{", dst="} << dst << \textcolor{stringliteral}{")"});
174   \hyperlink{classns3_1_1BridgeNetDevice_a9e0a97f4e3b3aa2cd1a3516cb739f721}{Learn} (src, incomingPort);
175 
176   \textcolor{keywordflow}{for} (std::vector< Ptr<NetDevice> >::iterator iter = \hyperlink{classns3_1_1BridgeNetDevice_accf2a9a81b4be28b155d6b5aeeb185be}{m\_ports}.begin ();
177        iter != \hyperlink{classns3_1_1BridgeNetDevice_accf2a9a81b4be28b155d6b5aeeb185be}{m\_ports}.end (); iter++)
178     \{
179       Ptr<NetDevice> \hyperlink{dsdv-manet_8cc_a8e0798404bf2cf5dabb84c5ba9a4f236}{port} = *iter;
180       \textcolor{keywordflow}{if} (port != incomingPort)
181         \{
182           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"LearningBridgeForward ("} << src << \textcolor{stringliteral}{" => "} << dst << \textcolor{stringliteral}{"): "} 
183                                                   << incomingPort->GetInstanceTypeId ().GetName ()
184                                                   << \textcolor{stringliteral}{" --> "} << port->GetInstanceTypeId ().GetName ()
185                                                   << \textcolor{stringliteral}{" (UID "} << packet->GetUid () << \textcolor{stringliteral}{")."});
186           port->SendFrom (packet->Copy (), src, dst, protocol);
187         \}
188     \}
189 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4




Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Forward\+Unicast@{Forward\+Unicast}}
\index{Forward\+Unicast@{Forward\+Unicast}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Forward\+Unicast(\+Ptr$<$ Net\+Device $>$ incoming\+Port, Ptr$<$ const Packet $>$ packet, uint16\+\_\+t protocol, Mac48\+Address src, Mac48\+Address dst)}{ForwardUnicast(Ptr< NetDevice > incomingPort, Ptr< const Packet > packet, uint16_t protocol, Mac48Address src, Mac48Address dst)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Bridge\+Net\+Device\+::\+Forward\+Unicast (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{incoming\+Port, }
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{packet, }
\item[{uint16\+\_\+t}]{protocol, }
\item[{{\bf Mac48\+Address}}]{src, }
\item[{{\bf Mac48\+Address}}]{dst}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classns3_1_1BridgeNetDevice_a815693fe0b0d77e33e1843fa7d991701}{}\label{classns3_1_1BridgeNetDevice_a815693fe0b0d77e33e1843fa7d991701}


Forwards a unicast packet. 


\begin{DoxyParams}{Parameters}
{\em incoming\+Port} & the packet incoming port \\
\hline
{\em packet} & the packet \\
\hline
{\em protocol} & the packet protocol (e.\+g., Ethertype) \\
\hline
{\em src} & the packet source \\
\hline
{\em dst} & the packet destination \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
134 \{
135   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
136   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"LearningBridgeForward (incomingPort="} << incomingPort->GetInstanceTypeId ().
      GetName ()
137                                                        << \textcolor{stringliteral}{", packet="} << packet << \textcolor{stringliteral}{", protocol="}<<protocol
138                                                        << \textcolor{stringliteral}{", src="} << src << \textcolor{stringliteral}{", dst="} << dst << \textcolor{stringliteral}{")"});
139 
140   \hyperlink{classns3_1_1BridgeNetDevice_a9e0a97f4e3b3aa2cd1a3516cb739f721}{Learn} (src, incomingPort);
141   Ptr<NetDevice> outPort = \hyperlink{classns3_1_1BridgeNetDevice_a944d20ca7524ef699812e653670407b6}{GetLearnedState} (dst);
142   \textcolor{keywordflow}{if} (outPort != NULL && outPort != incomingPort)
143     \{
144       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Learning bridge state says to use port `"} << outPort->GetInstanceTypeId ()
      .GetName () << \textcolor{stringliteral}{"'"});
145       outPort->SendFrom (packet->Copy (), src, dst, protocol);
146     \}
147   \textcolor{keywordflow}{else}
148     \{
149       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"No learned state: send through all ports"});
150       \textcolor{keywordflow}{for} (std::vector< Ptr<NetDevice> >::iterator iter = \hyperlink{classns3_1_1BridgeNetDevice_accf2a9a81b4be28b155d6b5aeeb185be}{m\_ports}.begin ();
151            iter != \hyperlink{classns3_1_1BridgeNetDevice_accf2a9a81b4be28b155d6b5aeeb185be}{m\_ports}.end (); iter++)
152         \{
153           Ptr<NetDevice> \hyperlink{dsdv-manet_8cc_a8e0798404bf2cf5dabb84c5ba9a4f236}{port} = *iter;
154           \textcolor{keywordflow}{if} (port != incomingPort)
155             \{
156               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"LearningBridgeForward ("} << src << \textcolor{stringliteral}{" => "} << dst << \textcolor{stringliteral}{"): "} 
157                                                       << incomingPort->GetInstanceTypeId ().GetName ()
158                                                       << \textcolor{stringliteral}{" --> "} << port->GetInstanceTypeId ().GetName ()
159                                                       << \textcolor{stringliteral}{" (UID "} << packet->GetUid () << \textcolor{stringliteral}{")."});
160               port->SendFrom (packet->Copy (), src, dst, protocol);
161             \}
162         \}
163     \}
164 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6




Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Get\+Address@{Get\+Address}}
\index{Get\+Address@{Get\+Address}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Address(void) const }{GetAddress(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Bridge\+Net\+Device\+::\+Get\+Address (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1BridgeNetDevice_a2bf34b9c7dfde567cfa90dde807185ab}{}\label{classns3_1_1BridgeNetDevice_a2bf34b9c7dfde567cfa90dde807185ab}
\begin{DoxyReturn}{Returns}
the current \hyperlink{classns3_1_1Address}{Address} of this interface. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a671f99de496d6f09ae343bb715301fb2}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
296 \{
297   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
298   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1BridgeNetDevice_a3a8897765d112fe99d399a4b4b947d2f}{m\_address};
299 \}
\end{DoxyCode}
\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Get\+Bridge\+Port@{Get\+Bridge\+Port}}
\index{Get\+Bridge\+Port@{Get\+Bridge\+Port}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Bridge\+Port(uint32\+\_\+t n) const }{GetBridgePort(uint32_t n) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Net\+Device} $>$ ns3\+::\+Bridge\+Net\+Device\+::\+Get\+Bridge\+Port (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{n}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1BridgeNetDevice_ada7284f361adefebb72364c61446ed05}{}\label{classns3_1_1BridgeNetDevice_ada7284f361adefebb72364c61446ed05}


Gets the n-\/th bridged port. 


\begin{DoxyParams}{Parameters}
{\em n} & the port index \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the n-\/th bridged \hyperlink{classns3_1_1NetDevice}{Net\+Device} 
\end{DoxyReturn}

\begin{DoxyCode}
236 \{
237   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
238   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1BridgeNetDevice_accf2a9a81b4be28b155d6b5aeeb185be}{m\_ports}[\hyperlink{namespacesample-rng-plot_aeb5ee5c431e338ef39b7ac5431242e1d}{n}];
239 \}
\end{DoxyCode}
\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Get\+Broadcast@{Get\+Broadcast}}
\index{Get\+Broadcast@{Get\+Broadcast}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Broadcast(void) const }{GetBroadcast(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Bridge\+Net\+Device\+::\+Get\+Broadcast (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1BridgeNetDevice_a35c3033a90f189f94e4b5d6951630c19}{}\label{classns3_1_1BridgeNetDevice_a35c3033a90f189f94e4b5d6951630c19}
\begin{DoxyReturn}{Returns}
the broadcast address supported by this netdevice.
\end{DoxyReturn}
Calling this method is invalid if Is\+Broadcast returns not true. 

Implements \hyperlink{classns3_1_1NetDevice_a4724e03bc548dd8e967cc4a7356197bd}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
340 \{
341   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
342   \textcolor{keywordflow}{return} Mac48Address (\textcolor{stringliteral}{"ff:ff:ff:ff:ff:ff"});
343 \}
\end{DoxyCode}
\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Get\+Channel@{Get\+Channel}}
\index{Get\+Channel@{Get\+Channel}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Channel(void) const }{GetChannel(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Channel} $>$ ns3\+::\+Bridge\+Net\+Device\+::\+Get\+Channel (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1BridgeNetDevice_ae40842a4c4b32ba6c39381e65e71320e}{}\label{classns3_1_1BridgeNetDevice_ae40842a4c4b32ba6c39381e65e71320e}
\begin{DoxyReturn}{Returns}
the channel this \hyperlink{classns3_1_1NetDevice}{Net\+Device} is connected to. The value returned can be zero if the \hyperlink{classns3_1_1NetDevice}{Net\+Device} is not yet connected to any channel or if the underlying \hyperlink{classns3_1_1NetDevice}{Net\+Device} has no concept of a channel. i.\+e., callers {\itshape must} check for zero and be ready to handle it. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a3d810bd2738634e2e851661271828565}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
282 \{
283   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
284   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1BridgeNetDevice_a091384e0ef3d890c26a26d9681b22986}{m\_channel};
285 \}
\end{DoxyCode}
\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Get\+If\+Index@{Get\+If\+Index}}
\index{Get\+If\+Index@{Get\+If\+Index}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+If\+Index(void) const }{GetIfIndex(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Bridge\+Net\+Device\+::\+Get\+If\+Index (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1BridgeNetDevice_a7e7679e8e284072bb9fc1a950ca57594}{}\label{classns3_1_1BridgeNetDevice_a7e7679e8e284072bb9fc1a950ca57594}
\begin{DoxyReturn}{Returns}
index if\+Index of the device 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a8c1ae2ec8eadc4524dfc1e425bfa0850}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
275 \{
276   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
277   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1BridgeNetDevice_a224b5e6b5a12b9c1dbafec290165eac5}{m\_ifIndex};
278 \}
\end{DoxyCode}
\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Get\+Learned\+State@{Get\+Learned\+State}}
\index{Get\+Learned\+State@{Get\+Learned\+State}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Learned\+State(\+Mac48\+Address source)}{GetLearnedState(Mac48Address source)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Net\+Device} $>$ ns3\+::\+Bridge\+Net\+Device\+::\+Get\+Learned\+State (
\begin{DoxyParamCaption}
\item[{{\bf Mac48\+Address}}]{source}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classns3_1_1BridgeNetDevice_a944d20ca7524ef699812e653670407b6}{}\label{classns3_1_1BridgeNetDevice_a944d20ca7524ef699812e653670407b6}


Gets the port associated to a source address. 


\begin{DoxyParams}{Parameters}
{\em source} & the source address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the port the source is associated to, or N\+U\+LL if no association is known. 
\end{DoxyReturn}

\begin{DoxyCode}
203 \{
204   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
205   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1BridgeNetDevice_a94b14f30049e8b7fdcd134b620b5996e}{m\_enableLearning})
206     \{
207       \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} now = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ();
208       std::map<Mac48Address, LearnedState>::iterator iter =
209         \hyperlink{classns3_1_1BridgeNetDevice_a201ac30909835a3efd1b34470e8fb5ec}{m\_learnState}.find (source);
210       \textcolor{keywordflow}{if} (iter != \hyperlink{classns3_1_1BridgeNetDevice_a201ac30909835a3efd1b34470e8fb5ec}{m\_learnState}.end ())
211         \{
212           LearnedState &state = iter->second;
213           \textcolor{keywordflow}{if} (state.expirationTime > now)
214             \{
215               \textcolor{keywordflow}{return} state.associatedPort;
216             \}
217           \textcolor{keywordflow}{else}
218             \{
219               \hyperlink{classns3_1_1BridgeNetDevice_a201ac30909835a3efd1b34470e8fb5ec}{m\_learnState}.erase (iter);
220             \}
221         \}
222     \}
223   \textcolor{keywordflow}{return} NULL;
224 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8




Here is the caller graph for this function\+:
% FIG 9


\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Get\+Mtu@{Get\+Mtu}}
\index{Get\+Mtu@{Get\+Mtu}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Mtu(void) const }{GetMtu(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Bridge\+Net\+Device\+::\+Get\+Mtu (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1BridgeNetDevice_a86e660792da21b0c3eafb103cfc228c5}{}\label{classns3_1_1BridgeNetDevice_a86e660792da21b0c3eafb103cfc228c5}
\begin{DoxyReturn}{Returns}
the link-\/level M\+TU in bytes for this interface.
\end{DoxyReturn}
This value is typically used by the IP layer to perform IP fragmentation when needed. 

Implements \hyperlink{classns3_1_1NetDevice_a91f4f5d01bc2d567c1e0a69b63a4cf14}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
311 \{
312   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
313   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1BridgeNetDevice_ab0ab0e7f99c14058e65f12bfea364641}{m\_mtu};
314 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 10


\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Get\+Multicast@{Get\+Multicast}}
\index{Get\+Multicast@{Get\+Multicast}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Multicast(\+Ipv4\+Address multicast\+Group) const }{GetMulticast(Ipv4Address multicastGroup) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Bridge\+Net\+Device\+::\+Get\+Multicast (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{multicast\+Group}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1BridgeNetDevice_ab6714d1180ea4f909087418989e3851f}{}\label{classns3_1_1BridgeNetDevice_ab6714d1180ea4f909087418989e3851f}


Make and return a M\+AC multicast address using the provided multicast group. 

\{1112\} says that an \hyperlink{classns3_1_1Ipv4}{Ipv4} host group address is mapped to an Ethernet multicast address by placing the low-\/order 23-\/bits of the IP address into the low-\/order 23 bits of the Ethernet multicast address 01-\/00-\/5\+E-\/00-\/00-\/00 (hex). Similar R\+F\+Cs exist for \hyperlink{classns3_1_1Ipv6}{Ipv6} and Eui64 mappings. This method performs the multicast address creation function appropriate to the underlying M\+AC address of the device. This M\+AC address is encapsulated in an abstract \hyperlink{classns3_1_1Address}{Address} to avoid dependencies on the exact M\+AC address format.

In the case of net devices that do not support multicast, clients are expected to test \hyperlink{classns3_1_1NetDevice_a1afb4848a9226540f1ff51f9b31ae95e}{Net\+Device\+::\+Is\+Multicast} and avoid attempting to map multicast packets. Subclasses of \hyperlink{classns3_1_1NetDevice}{Net\+Device} that do support multicasting are expected to override this method and provide an implementation appropriate to the particular device.


\begin{DoxyParams}{Parameters}
{\em multicast\+Group} & The IP address for the multicast group destination of the packet. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The M\+AC multicast \hyperlink{classns3_1_1Address}{Address} used to send packets to the provided multicast group.
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Calling this method is invalid if Is\+Multicast returns not true. 
\end{DoxyWarning}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1BridgeNetDevice_a865db3336d37fca6cd09c46c93199a38}{Is\+Multicast()} 
\end{DoxySeeAlso}


Implements \hyperlink{classns3_1_1NetDevice_a98aa4852df367b6a393c8cc1d88af0d9}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
354 \{
355   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << multicastGroup);
356   Mac48Address multicast = \hyperlink{classns3_1_1Mac48Address_a23d170f8c7a7d90a8110425620285819}{Mac48Address::GetMulticast} (multicastGroup);
357   \textcolor{keywordflow}{return} multicast;
358 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 11


\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Get\+Multicast@{Get\+Multicast}}
\index{Get\+Multicast@{Get\+Multicast}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Multicast(\+Ipv6\+Address addr) const }{GetMulticast(Ipv6Address addr) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Bridge\+Net\+Device\+::\+Get\+Multicast (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{addr}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1BridgeNetDevice_aa6d896c3ead0f292d2c85a5f69d5438b}{}\label{classns3_1_1BridgeNetDevice_aa6d896c3ead0f292d2c85a5f69d5438b}


Get the M\+AC multicast address corresponding to the I\+Pv6 address provided. 


\begin{DoxyParams}{Parameters}
{\em addr} & I\+Pv6 address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the M\+AC multicast address 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Calling this method is invalid if Is\+Multicast returns not true. 
\end{DoxyWarning}


Implements \hyperlink{classns3_1_1NetDevice_a46479a2c0101c6f9da9251ed4d7575bd}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
461 \{
462   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << addr);
463   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Mac48Address_a23d170f8c7a7d90a8110425620285819}{Mac48Address::GetMulticast} (addr);
464 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12


\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Get\+N\+Bridge\+Ports@{Get\+N\+Bridge\+Ports}}
\index{Get\+N\+Bridge\+Ports@{Get\+N\+Bridge\+Ports}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+N\+Bridge\+Ports(void) const }{GetNBridgePorts(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Bridge\+Net\+Device\+::\+Get\+N\+Bridge\+Ports (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1BridgeNetDevice_a93fbb63deb6803390b53cf537ac66a2d}{}\label{classns3_1_1BridgeNetDevice_a93fbb63deb6803390b53cf537ac66a2d}


Gets the number of bridged \textquotesingle{}ports\textquotesingle{}, i.\+e., the Net\+Devices currently bridged. 

\begin{DoxyReturn}{Returns}
the number of bridged ports. 
\end{DoxyReturn}

\begin{DoxyCode}
228 \{
229   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
230   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1BridgeNetDevice_accf2a9a81b4be28b155d6b5aeeb185be}{m\_ports}.size ();
231 \}
\end{DoxyCode}
\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Get\+Node@{Get\+Node}}
\index{Get\+Node@{Get\+Node}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Node(void) const }{GetNode(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Node} $>$ ns3\+::\+Bridge\+Net\+Device\+::\+Get\+Node (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1BridgeNetDevice_acf2c0417701321ab9c3db740f9de5f79}{}\label{classns3_1_1BridgeNetDevice_acf2c0417701321ab9c3db740f9de5f79}
\begin{DoxyReturn}{Returns}
the node base class which contains this network interface.
\end{DoxyReturn}
When a subclass needs to get access to the underlying node base class to print the nodeid for example, it can invoke this method. 

Implements \hyperlink{classns3_1_1NetDevice_a098b6cc4339ac00c62e75cfa48c8aeac}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
417 \{
418   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
419   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1BridgeNetDevice_a1880454d764d3c555c2fa71a9d66345e}{m\_node};
420 \}
\end{DoxyCode}
\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Bridge\+Net\+Device\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1BridgeNetDevice_a9c8adb9ce413618caaa052929b69a6c9}{}\label{classns3_1_1BridgeNetDevice_a9c8adb9ce413618caaa052929b69a6c9}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
36 \{
37   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::BridgeNetDevice"})
38     .SetParent<NetDevice> ()
39     .SetGroupName(\textcolor{stringliteral}{"Bridge"})
40     .AddConstructor<\hyperlink{classns3_1_1BridgeNetDevice_ab113a3cc0394ab89479fbdae8c21c27a}{BridgeNetDevice}> ()
41     .AddAttribute (\textcolor{stringliteral}{"Mtu"}, \textcolor{stringliteral}{"The MAC-level Maximum Transmission Unit"},
42                    UintegerValue (1500),
43                    MakeUintegerAccessor (&\hyperlink{classns3_1_1BridgeNetDevice_afc362f1047067ebf64e2f81f790f9c50}{BridgeNetDevice::SetMtu},
44                                          &\hyperlink{classns3_1_1BridgeNetDevice_a86e660792da21b0c3eafb103cfc228c5}{BridgeNetDevice::GetMtu}),
45                    MakeUintegerChecker<uint16\_t> ())
46     .AddAttribute (\textcolor{stringliteral}{"EnableLearning"},
47                    \textcolor{stringliteral}{"Enable the learning mode of the Learning Bridge"},
48                    BooleanValue (\textcolor{keyword}{true}),
49                    MakeBooleanAccessor (&\hyperlink{classns3_1_1BridgeNetDevice_a94b14f30049e8b7fdcd134b620b5996e}{BridgeNetDevice::m\_enableLearning}
      ),
50                    MakeBooleanChecker ())
51     .AddAttribute (\textcolor{stringliteral}{"ExpirationTime"},
52                    \textcolor{stringliteral}{"Time it takes for learned MAC state entry to expire."},
53                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (300)),
54                    MakeTimeAccessor (&\hyperlink{classns3_1_1BridgeNetDevice_a6b6c209fa78de612f218db0dd40b8319}{BridgeNetDevice::m\_expirationTime}),
55                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
56   ;
57   \textcolor{keywordflow}{return} tid;
58 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13


\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Is\+Bridge@{Is\+Bridge}}
\index{Is\+Bridge@{Is\+Bridge}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Bridge(void) const }{IsBridge(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Bridge\+Net\+Device\+::\+Is\+Bridge (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1BridgeNetDevice_a35be2b9e5834724af90adde9fb1c2f70}{}\label{classns3_1_1BridgeNetDevice_a35be2b9e5834724af90adde9fb1c2f70}


Return true if the net device is acting as a bridge. 

\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Bridge flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a9d34556a1c83a69dacb08698ca4a1d94}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
370 \{
371   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
372   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
373 \}
\end{DoxyCode}
\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Is\+Broadcast@{Is\+Broadcast}}
\index{Is\+Broadcast@{Is\+Broadcast}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Broadcast(void) const }{IsBroadcast(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Bridge\+Net\+Device\+::\+Is\+Broadcast (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1BridgeNetDevice_ac56c83ea08ab0df37ac19777a5dd8d7f}{}\label{classns3_1_1BridgeNetDevice_ac56c83ea08ab0df37ac19777a5dd8d7f}
\begin{DoxyReturn}{Returns}
true if this interface supports a broadcast address, false otherwise. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a67f992b20858cd7b397d8fba2feff141}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
332 \{
333   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
334   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
335 \}
\end{DoxyCode}
\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Is\+Link\+Up@{Is\+Link\+Up}}
\index{Is\+Link\+Up@{Is\+Link\+Up}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Link\+Up(void) const }{IsLinkUp(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Bridge\+Net\+Device\+::\+Is\+Link\+Up (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1BridgeNetDevice_ad40e11c2707ff5c012c71c288b281cce}{}\label{classns3_1_1BridgeNetDevice_ad40e11c2707ff5c012c71c288b281cce}
\begin{DoxyReturn}{Returns}
true if link is up; false otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_afe1822b79e19a05ab95f693c8fb64fc7}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
319 \{
320   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
321   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
322 \}
\end{DoxyCode}
\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Is\+Multicast@{Is\+Multicast}}
\index{Is\+Multicast@{Is\+Multicast}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Multicast(void) const }{IsMulticast(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Bridge\+Net\+Device\+::\+Is\+Multicast (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1BridgeNetDevice_a865db3336d37fca6cd09c46c93199a38}{}\label{classns3_1_1BridgeNetDevice_a865db3336d37fca6cd09c46c93199a38}
\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Multicast flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a1afb4848a9226540f1ff51f9b31ae95e}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
347 \{
348   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
349   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
350 \}
\end{DoxyCode}
\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Is\+Point\+To\+Point@{Is\+Point\+To\+Point}}
\index{Is\+Point\+To\+Point@{Is\+Point\+To\+Point}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Point\+To\+Point(void) const }{IsPointToPoint(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Bridge\+Net\+Device\+::\+Is\+Point\+To\+Point (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1BridgeNetDevice_a87de7a289e4485873185a2db12dd0665}{}\label{classns3_1_1BridgeNetDevice_a87de7a289e4485873185a2db12dd0665}


Return true if the net device is on a point-\/to-\/point link. 

\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Point\+To\+Point flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a718177f25efeaf2dbf8a18fcab87224d}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
363 \{
364   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
365   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
366 \}
\end{DoxyCode}
\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Learn@{Learn}}
\index{Learn@{Learn}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Learn(\+Mac48\+Address source, Ptr$<$ Net\+Device $>$ port)}{Learn(Mac48Address source, Ptr< NetDevice > port)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Bridge\+Net\+Device\+::\+Learn (
\begin{DoxyParamCaption}
\item[{{\bf Mac48\+Address}}]{source, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{port}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classns3_1_1BridgeNetDevice_a9e0a97f4e3b3aa2cd1a3516cb739f721}{}\label{classns3_1_1BridgeNetDevice_a9e0a97f4e3b3aa2cd1a3516cb739f721}


Learns the port a M\+AC address is sending from. 


\begin{DoxyParams}{Parameters}
{\em source} & source address \\
\hline
{\em port} & the port the source is sending from \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
192 \{
193   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
194   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1BridgeNetDevice_a94b14f30049e8b7fdcd134b620b5996e}{m\_enableLearning})
195     \{
196       LearnedState &state = \hyperlink{classns3_1_1BridgeNetDevice_a201ac30909835a3efd1b34470e8fb5ec}{m\_learnState}[source];
197       state.associatedPort = \hyperlink{dsdv-manet_8cc_a8e0798404bf2cf5dabb84c5ba9a4f236}{port};
198       state.expirationTime = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} () + \hyperlink{classns3_1_1BridgeNetDevice_a6b6c209fa78de612f218db0dd40b8319}{m\_expirationTime};
199     \}
200 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 14




Here is the caller graph for this function\+:
% FIG 15


\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Needs\+Arp@{Needs\+Arp}}
\index{Needs\+Arp@{Needs\+Arp}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Needs\+Arp(void) const }{NeedsArp(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Bridge\+Net\+Device\+::\+Needs\+Arp (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1BridgeNetDevice_a8c2054a731287fa948512b7dce9d9d7c}{}\label{classns3_1_1BridgeNetDevice_a8c2054a731287fa948512b7dce9d9d7c}
\begin{DoxyReturn}{Returns}
true if A\+RP is needed, false otherwise.
\end{DoxyReturn}
Called by higher-\/layers to check if this \hyperlink{classns3_1_1NetDevice}{Net\+Device} requires A\+RP to be used. 

Implements \hyperlink{classns3_1_1NetDevice_ab1a133696310cad3dc2c3d1a4993f310}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
433 \{
434   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
435   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
436 \}
\end{DoxyCode}
\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!operator=@{operator=}}
\index{operator=@{operator=}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{operator=(const Bridge\+Net\+Device \&)}{operator=(const BridgeNetDevice &)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Bridge\+Net\+Device}\& ns3\+::\+Bridge\+Net\+Device\+::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf Bridge\+Net\+Device} \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BridgeNetDevice_a8179f775c915bb7e681f05df96460f0d}{}\label{classns3_1_1BridgeNetDevice_a8179f775c915bb7e681f05df96460f0d}


Copy constructor. 

Defined and unimplemented to avoid misuse \begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Receive\+From\+Device@{Receive\+From\+Device}}
\index{Receive\+From\+Device@{Receive\+From\+Device}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Receive\+From\+Device(\+Ptr$<$ Net\+Device $>$ device, Ptr$<$ const Packet $>$ packet, uint16\+\_\+t protocol, Address const \&source, Address const \&destination, Packet\+Type packet\+Type)}{ReceiveFromDevice(Ptr< NetDevice > device, Ptr< const Packet > packet, uint16_t protocol, Address const &source, Address const &destination, PacketType packetType)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Bridge\+Net\+Device\+::\+Receive\+From\+Device (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{device, }
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{packet, }
\item[{uint16\+\_\+t}]{protocol, }
\item[{{\bf Address} const \&}]{source, }
\item[{{\bf Address} const \&}]{destination, }
\item[{{\bf Packet\+Type}}]{packet\+Type}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classns3_1_1BridgeNetDevice_a958c86321b73b2c400b54bfad9d03e68}{}\label{classns3_1_1BridgeNetDevice_a958c86321b73b2c400b54bfad9d03e68}


Receives a packet from one bridged port. 


\begin{DoxyParams}{Parameters}
{\em device} & the originating port \\
\hline
{\em packet} & the received packet \\
\hline
{\em protocol} & the packet protocol (e.\+g., Ethertype) \\
\hline
{\em source} & the packet source \\
\hline
{\em destination} & the packet destination \\
\hline
{\em packet\+Type} & the packet type (e.\+g., host, broadcast, etc.) \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
91 \{
92   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
93   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"UID is "} << packet->GetUid ());
94 
95   Mac48Address src48 = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (src);
96   Mac48Address dst48 = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (dst);
97 
98   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1BridgeNetDevice_ae930168508bfb61f8a7721e7a6312654}{m\_promiscRxCallback}.\hyperlink{classns3_1_1Callback_aa8e27826badbf37f84763f36f70d9b54}{IsNull} ())
99     \{
100       \hyperlink{classns3_1_1BridgeNetDevice_ae930168508bfb61f8a7721e7a6312654}{m\_promiscRxCallback} (\textcolor{keyword}{this}, packet, protocol, src, dst, packetType);
101     \}
102 
103   \textcolor{keywordflow}{switch} (packetType)
104     \{
105     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2a60835731aced24ac0c712ba61e62462e}{PACKET\_HOST}:
106       \textcolor{keywordflow}{if} (dst48 == \hyperlink{classns3_1_1BridgeNetDevice_a3a8897765d112fe99d399a4b4b947d2f}{m\_address})
107         \{
108           \hyperlink{classns3_1_1BridgeNetDevice_a50ecd306e326a77a22666272606fe85a}{m\_rxCallback} (\textcolor{keyword}{this}, packet, protocol, src);
109         \}
110       \textcolor{keywordflow}{break};
111 
112     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2adfeb6a2929cee183836a32fe293ce205}{PACKET\_BROADCAST}:
113     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2ae3ffb88d364e97f06f662f5d7ba53bbe}{PACKET\_MULTICAST}:
114       \hyperlink{classns3_1_1BridgeNetDevice_a50ecd306e326a77a22666272606fe85a}{m\_rxCallback} (\textcolor{keyword}{this}, packet, protocol, src);
115       \hyperlink{classns3_1_1BridgeNetDevice_af3eff77ebe2114537d28aacc77adef45}{ForwardBroadcast} (incomingPort, packet, protocol, src48, dst48);
116       \textcolor{keywordflow}{break};
117 
118     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2a60c00fab4286dd2903e2b197a9f8c6c8}{PACKET\_OTHERHOST}:
119       \textcolor{keywordflow}{if} (dst48 == \hyperlink{classns3_1_1BridgeNetDevice_a3a8897765d112fe99d399a4b4b947d2f}{m\_address})
120         \{
121           \hyperlink{classns3_1_1BridgeNetDevice_a50ecd306e326a77a22666272606fe85a}{m\_rxCallback} (\textcolor{keyword}{this}, packet, protocol, src);
122         \}
123       \textcolor{keywordflow}{else}
124         \{
125           \hyperlink{classns3_1_1BridgeNetDevice_a815693fe0b0d77e33e1843fa7d991701}{ForwardUnicast} (incomingPort, packet, protocol, src48, dst48);
126         \}
127       \textcolor{keywordflow}{break};
128     \}
129 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 16




Here is the caller graph for this function\+:
% FIG 17


\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Send@{Send}}
\index{Send@{Send}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Send(\+Ptr$<$ Packet $>$ packet, const Address \&dest, uint16\+\_\+t protocol\+Number)}{Send(Ptr< Packet > packet, const Address &dest, uint16_t protocolNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Bridge\+Net\+Device\+::\+Send (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{const {\bf Address} \&}]{dest, }
\item[{uint16\+\_\+t}]{protocol\+Number}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1BridgeNetDevice_ac94136d6499505f6712c939c35b97e06}{}\label{classns3_1_1BridgeNetDevice_ac94136d6499505f6712c939c35b97e06}

\begin{DoxyParams}{Parameters}
{\em packet} & packet sent from above down to Network Device \\
\hline
{\em dest} & mac address of the destination (already resolved) \\
\hline
{\em protocol\+Number} & identifies the type of payload contained in this packet. Used to call the right L3\+Protocol when the packet is received.\\
\hline
\end{DoxyParams}
Called from higher layer to send packet into Network Device to the specified destination \hyperlink{classns3_1_1Address}{Address}

\begin{DoxyReturn}{Returns}
whether the Send operation succeeded 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a59f41afb0fe8951bb94d5739cbe6ee7d}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
378 \{
379   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
380   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1BridgeNetDevice_a7ad2acf7936e29f003c9046d76ea2099}{SendFrom} (packet, \hyperlink{classns3_1_1BridgeNetDevice_a3a8897765d112fe99d399a4b4b947d2f}{m\_address}, dest, protocolNumber);
381 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 18


\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Send\+From@{Send\+From}}
\index{Send\+From@{Send\+From}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Send\+From(\+Ptr$<$ Packet $>$ packet, const Address \&source, const Address \&dest, uint16\+\_\+t protocol\+Number)}{SendFrom(Ptr< Packet > packet, const Address &source, const Address &dest, uint16_t protocolNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Bridge\+Net\+Device\+::\+Send\+From (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{const {\bf Address} \&}]{source, }
\item[{const {\bf Address} \&}]{dest, }
\item[{uint16\+\_\+t}]{protocol\+Number}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1BridgeNetDevice_a7ad2acf7936e29f003c9046d76ea2099}{}\label{classns3_1_1BridgeNetDevice_a7ad2acf7936e29f003c9046d76ea2099}

\begin{DoxyParams}{Parameters}
{\em packet} & packet sent from above down to Network Device \\
\hline
{\em source} & source mac address (so called \char`\"{}\+M\+A\+C spoofing\char`\"{}) \\
\hline
{\em dest} & mac address of the destination (already resolved) \\
\hline
{\em protocol\+Number} & identifies the type of payload contained in this packet. Used to call the right L3\+Protocol when the packet is received.\\
\hline
\end{DoxyParams}
Called from higher layer to send packet into Network Device with the specified source and destination Addresses.

\begin{DoxyReturn}{Returns}
whether the Send operation succeeded 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a19d55a4746c1ae584bf7da69959a885b}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
385 \{
386   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
387   Mac48Address dst = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (dest); 
388 
389   \textcolor{comment}{// try to use the learned state if data is unicast}
390   \textcolor{keywordflow}{if} (!dst.IsGroup ())
391     \{
392       Ptr<NetDevice> outPort = \hyperlink{classns3_1_1BridgeNetDevice_a944d20ca7524ef699812e653670407b6}{GetLearnedState} (dst);
393       \textcolor{keywordflow}{if} (outPort != NULL) 
394         \{
395           outPort->SendFrom (packet, src, dest, protocolNumber);
396           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
397         \}
398     \}
399 
400   \textcolor{comment}{// data was not unicast or no state has been learned for that mac}
401   \textcolor{comment}{// address => flood through all ports.}
402   Ptr<Packet> pktCopy;
403   \textcolor{keywordflow}{for} (std::vector< Ptr<NetDevice> >::iterator iter = \hyperlink{classns3_1_1BridgeNetDevice_accf2a9a81b4be28b155d6b5aeeb185be}{m\_ports}.begin ();
404        iter != \hyperlink{classns3_1_1BridgeNetDevice_accf2a9a81b4be28b155d6b5aeeb185be}{m\_ports}.end (); iter++)
405     \{
406       pktCopy = packet->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} ();
407       Ptr<NetDevice> \hyperlink{dsdv-manet_8cc_a8e0798404bf2cf5dabb84c5ba9a4f236}{port} = *iter;
408       port->SendFrom (pktCopy, src, dest, protocolNumber);
409     \}
410 
411   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
412 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 19




Here is the caller graph for this function\+:
% FIG 20


\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Set\+Address@{Set\+Address}}
\index{Set\+Address@{Set\+Address}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Address(\+Address address)}{SetAddress(Address address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Bridge\+Net\+Device\+::\+Set\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1BridgeNetDevice_a455c6aa85f8790a9588b6fd794f2d920}{}\label{classns3_1_1BridgeNetDevice_a455c6aa85f8790a9588b6fd794f2d920}
Set the address of this interface 
\begin{DoxyParams}{Parameters}
{\em address} & address to set \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1NetDevice_ab56dc36bc0547471ab3210eda60ee76c}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
289 \{
290   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
291   \hyperlink{classns3_1_1BridgeNetDevice_a3a8897765d112fe99d399a4b4b947d2f}{m\_address} = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (address);
292 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 21


\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Set\+If\+Index@{Set\+If\+Index}}
\index{Set\+If\+Index@{Set\+If\+Index}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+If\+Index(const uint32\+\_\+t index)}{SetIfIndex(const uint32_t index)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Bridge\+Net\+Device\+::\+Set\+If\+Index (
\begin{DoxyParamCaption}
\item[{const uint32\+\_\+t}]{index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1BridgeNetDevice_a94fe34b7074a4ac12cb3ae8f3272d1e1}{}\label{classns3_1_1BridgeNetDevice_a94fe34b7074a4ac12cb3ae8f3272d1e1}

\begin{DoxyParams}{Parameters}
{\em index} & if\+Index of the device \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1NetDevice_a2e1ac6c1189cd565420305d85a193fb8}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
268 \{
269   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
270   \hyperlink{classns3_1_1BridgeNetDevice_a224b5e6b5a12b9c1dbafec290165eac5}{m\_ifIndex} = index;
271 \}
\end{DoxyCode}
\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Set\+Mtu@{Set\+Mtu}}
\index{Set\+Mtu@{Set\+Mtu}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Mtu(const uint16\+\_\+t mtu)}{SetMtu(const uint16_t mtu)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Bridge\+Net\+Device\+::\+Set\+Mtu (
\begin{DoxyParamCaption}
\item[{const uint16\+\_\+t}]{mtu}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1BridgeNetDevice_afc362f1047067ebf64e2f81f790f9c50}{}\label{classns3_1_1BridgeNetDevice_afc362f1047067ebf64e2f81f790f9c50}

\begin{DoxyParams}{Parameters}
{\em mtu} & M\+TU value, in bytes, to set for the device \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether the M\+TU value was within legal bounds
\end{DoxyReturn}
Override for default M\+TU defined on a per-\/type basis. 

Implements \hyperlink{classns3_1_1NetDevice_a2ba4956d45cde68eab3cbdd6ede06df0}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
303 \{
304   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
305   \hyperlink{classns3_1_1BridgeNetDevice_ab0ab0e7f99c14058e65f12bfea364641}{m\_mtu} = mtu;
306   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
307 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 22


\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Set\+Node@{Set\+Node}}
\index{Set\+Node@{Set\+Node}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Node(\+Ptr$<$ Node $>$ node)}{SetNode(Ptr< Node > node)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Bridge\+Net\+Device\+::\+Set\+Node (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1BridgeNetDevice_a2720492d8546e096200dbec52105b7cd}{}\label{classns3_1_1BridgeNetDevice_a2720492d8546e096200dbec52105b7cd}

\begin{DoxyParams}{Parameters}
{\em node} & the node associated to this netdevice.\\
\hline
\end{DoxyParams}
This method is called from \hyperlink{classns3_1_1Node_a42ff83ee1d5d1649c770d3f5b62375de}{ns3\+::\+Node\+::\+Add\+Device}. 

Implements \hyperlink{classns3_1_1NetDevice_a3ae520ae06e93b957f0f56f113319a08}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
425 \{
426   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
427   \hyperlink{classns3_1_1BridgeNetDevice_a1880454d764d3c555c2fa71a9d66345e}{m\_node} = node;
428 \}
\end{DoxyCode}
\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Set\+Promisc\+Receive\+Callback@{Set\+Promisc\+Receive\+Callback}}
\index{Set\+Promisc\+Receive\+Callback@{Set\+Promisc\+Receive\+Callback}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Promisc\+Receive\+Callback(\+Net\+Device\+::\+Promisc\+Receive\+Callback cb)}{SetPromiscReceiveCallback(NetDevice::PromiscReceiveCallback cb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Bridge\+Net\+Device\+::\+Set\+Promisc\+Receive\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Net\+Device\+::\+Promisc\+Receive\+Callback}}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1BridgeNetDevice_a01af49738a7fe604a04a7f3f273a1485}{}\label{classns3_1_1BridgeNetDevice_a01af49738a7fe604a04a7f3f273a1485}

\begin{DoxyParams}{Parameters}
{\em cb} & callback to invoke whenever a packet has been received in promiscuous mode and must be forwarded to the higher layers.\\
\hline
\end{DoxyParams}
Enables netdevice promiscuous mode and sets the callback that will handle promiscuous mode packets. Note, promiscuous mode packets means {\itshape all} packets, including those packets that can be sensed by the netdevice but which are intended to be received by other hosts. 

Implements \hyperlink{classns3_1_1NetDevice_a3968946bdbb74d47d7b13612baad7d6d}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
448 \{
449   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
450   \hyperlink{classns3_1_1BridgeNetDevice_ae930168508bfb61f8a7721e7a6312654}{m\_promiscRxCallback} = cb;
451 \}
\end{DoxyCode}
\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Set\+Receive\+Callback@{Set\+Receive\+Callback}}
\index{Set\+Receive\+Callback@{Set\+Receive\+Callback}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Receive\+Callback(\+Net\+Device\+::\+Receive\+Callback cb)}{SetReceiveCallback(NetDevice::ReceiveCallback cb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Bridge\+Net\+Device\+::\+Set\+Receive\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Net\+Device\+::\+Receive\+Callback}}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1BridgeNetDevice_abb019b6f29cbab5305195a38a415ddd1}{}\label{classns3_1_1BridgeNetDevice_abb019b6f29cbab5305195a38a415ddd1}

\begin{DoxyParams}{Parameters}
{\em cb} & callback to invoke whenever a packet has been received and must be forwarded to the higher layers.\\
\hline
\end{DoxyParams}
Set the callback to be used to notify higher layers when a packet has been received. 

Implements \hyperlink{classns3_1_1NetDevice_ac63e4d5668e421fec4b5d37f32e7dd18}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
441 \{
442   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
443   \hyperlink{classns3_1_1BridgeNetDevice_a50ecd306e326a77a22666272606fe85a}{m\_rxCallback} = cb;
444 \}
\end{DoxyCode}
\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!Supports\+Send\+From@{Supports\+Send\+From}}
\index{Supports\+Send\+From@{Supports\+Send\+From}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{Supports\+Send\+From() const }{SupportsSendFrom() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Bridge\+Net\+Device\+::\+Supports\+Send\+From (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1BridgeNetDevice_a204774b4a1fa122412c7ef273b7463a3}{}\label{classns3_1_1BridgeNetDevice_a204774b4a1fa122412c7ef273b7463a3}
\begin{DoxyReturn}{Returns}
true if this interface supports a bridging mode, false otherwise. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a04793d220b54c40e110ebf86dae5b25c}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
455 \{
456   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
457   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
458 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!m\+\_\+address@{m\+\_\+address}}
\index{m\+\_\+address@{m\+\_\+address}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+address}{m_address}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Mac48\+Address} ns3\+::\+Bridge\+Net\+Device\+::m\+\_\+address\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BridgeNetDevice_a3a8897765d112fe99d399a4b4b947d2f}{}\label{classns3_1_1BridgeNetDevice_a3a8897765d112fe99d399a4b4b947d2f}


M\+AC address of the \hyperlink{classns3_1_1NetDevice}{Net\+Device}. 

\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!m\+\_\+channel@{m\+\_\+channel}}
\index{m\+\_\+channel@{m\+\_\+channel}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+channel}{m_channel}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Bridge\+Channel}$>$ ns3\+::\+Bridge\+Net\+Device\+::m\+\_\+channel\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BridgeNetDevice_a091384e0ef3d890c26a26d9681b22986}{}\label{classns3_1_1BridgeNetDevice_a091384e0ef3d890c26a26d9681b22986}


virtual bridged channel 

\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!m\+\_\+enable\+Learning@{m\+\_\+enable\+Learning}}
\index{m\+\_\+enable\+Learning@{m\+\_\+enable\+Learning}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+enable\+Learning}{m_enableLearning}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Bridge\+Net\+Device\+::m\+\_\+enable\+Learning\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BridgeNetDevice_a94b14f30049e8b7fdcd134b620b5996e}{}\label{classns3_1_1BridgeNetDevice_a94b14f30049e8b7fdcd134b620b5996e}


true if the bridge will learn the node status 

\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!m\+\_\+expiration\+Time@{m\+\_\+expiration\+Time}}
\index{m\+\_\+expiration\+Time@{m\+\_\+expiration\+Time}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+expiration\+Time}{m_expirationTime}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Bridge\+Net\+Device\+::m\+\_\+expiration\+Time\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BridgeNetDevice_a6b6c209fa78de612f218db0dd40b8319}{}\label{classns3_1_1BridgeNetDevice_a6b6c209fa78de612f218db0dd40b8319}


time it takes for learned M\+AC state to expire 

\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!m\+\_\+if\+Index@{m\+\_\+if\+Index}}
\index{m\+\_\+if\+Index@{m\+\_\+if\+Index}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+if\+Index}{m_ifIndex}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Bridge\+Net\+Device\+::m\+\_\+if\+Index\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BridgeNetDevice_a224b5e6b5a12b9c1dbafec290165eac5}{}\label{classns3_1_1BridgeNetDevice_a224b5e6b5a12b9c1dbafec290165eac5}


Interface index. 

\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!m\+\_\+learn\+State@{m\+\_\+learn\+State}}
\index{m\+\_\+learn\+State@{m\+\_\+learn\+State}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+learn\+State}{m_learnState}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<${\bf Mac48\+Address}, {\bf Learned\+State}$>$ ns3\+::\+Bridge\+Net\+Device\+::m\+\_\+learn\+State\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BridgeNetDevice_a201ac30909835a3efd1b34470e8fb5ec}{}\label{classns3_1_1BridgeNetDevice_a201ac30909835a3efd1b34470e8fb5ec}


Container for known address statuses. 

\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!m\+\_\+mtu@{m\+\_\+mtu}}
\index{m\+\_\+mtu@{m\+\_\+mtu}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+mtu}{m_mtu}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Bridge\+Net\+Device\+::m\+\_\+mtu\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BridgeNetDevice_ab0ab0e7f99c14058e65f12bfea364641}{}\label{classns3_1_1BridgeNetDevice_ab0ab0e7f99c14058e65f12bfea364641}


M\+TU of the bridged \hyperlink{classns3_1_1NetDevice}{Net\+Device}. 

\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!m\+\_\+node@{m\+\_\+node}}
\index{m\+\_\+node@{m\+\_\+node}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+node}{m_node}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Node}$>$ ns3\+::\+Bridge\+Net\+Device\+::m\+\_\+node\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BridgeNetDevice_a1880454d764d3c555c2fa71a9d66345e}{}\label{classns3_1_1BridgeNetDevice_a1880454d764d3c555c2fa71a9d66345e}


node owning this \hyperlink{classns3_1_1NetDevice}{Net\+Device} 

\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!m\+\_\+ports@{m\+\_\+ports}}
\index{m\+\_\+ports@{m\+\_\+ports}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+ports}{m_ports}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<$ {\bf Ptr}$<${\bf Net\+Device}$>$ $>$ ns3\+::\+Bridge\+Net\+Device\+::m\+\_\+ports\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BridgeNetDevice_accf2a9a81b4be28b155d6b5aeeb185be}{}\label{classns3_1_1BridgeNetDevice_accf2a9a81b4be28b155d6b5aeeb185be}


bridged ports 

\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!m\+\_\+promisc\+Rx\+Callback@{m\+\_\+promisc\+Rx\+Callback}}
\index{m\+\_\+promisc\+Rx\+Callback@{m\+\_\+promisc\+Rx\+Callback}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+promisc\+Rx\+Callback}{m_promiscRxCallback}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Net\+Device\+::\+Promisc\+Receive\+Callback} ns3\+::\+Bridge\+Net\+Device\+::m\+\_\+promisc\+Rx\+Callback\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BridgeNetDevice_ae930168508bfb61f8a7721e7a6312654}{}\label{classns3_1_1BridgeNetDevice_ae930168508bfb61f8a7721e7a6312654}


promiscuous receive callback 

\index{ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}!m\+\_\+rx\+Callback@{m\+\_\+rx\+Callback}}
\index{m\+\_\+rx\+Callback@{m\+\_\+rx\+Callback}!ns3\+::\+Bridge\+Net\+Device@{ns3\+::\+Bridge\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+rx\+Callback}{m_rxCallback}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Net\+Device\+::\+Receive\+Callback} ns3\+::\+Bridge\+Net\+Device\+::m\+\_\+rx\+Callback\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BridgeNetDevice_a50ecd306e326a77a22666272606fe85a}{}\label{classns3_1_1BridgeNetDevice_a50ecd306e326a77a22666272606fe85a}


receive callback 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
bridge/model/\hyperlink{bridge-net-device_8h}{bridge-\/net-\/device.\+h}\item 
bridge/model/\hyperlink{bridge-net-device_8cc}{bridge-\/net-\/device.\+cc}\end{DoxyCompactItemize}
