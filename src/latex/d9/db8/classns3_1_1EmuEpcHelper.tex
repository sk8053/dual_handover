\hypertarget{classns3_1_1EmuEpcHelper}{}\section{ns3\+:\+:Emu\+Epc\+Helper Class Reference}
\label{classns3_1_1EmuEpcHelper}\index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}


Create an E\+PC network using Emu\+Fd\+Net\+Device.  




{\ttfamily \#include $<$emu-\/epc-\/helper.\+h$>$}



Inheritance diagram for ns3\+:\+:Emu\+Epc\+Helper\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Emu\+Epc\+Helper\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1EmuEpcHelper_a10b42d66910c4ee73006f40eea1a1de1}{Emu\+Epc\+Helper} ()
\item 
virtual \hyperlink{classns3_1_1EmuEpcHelper_a6d85fe041fb25c277903b65dd6821d09}{$\sim$\+Emu\+Epc\+Helper} ()
\item 
virtual void \hyperlink{classns3_1_1EmuEpcHelper_ae66ac77634aad1dfb03bbe0d8a54acc1}{Do\+Initialize} ()
\item 
virtual void \hyperlink{classns3_1_1EmuEpcHelper_a4e8f0a693cb3d0ac02b558832b9da4f6}{Do\+Dispose} ()
\item 
virtual void \hyperlink{classns3_1_1EmuEpcHelper_abaff0cf3ed70c034b5e0fd22dc89a7ba}{Add\+Enb} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ enb\+Node, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ lte\+Enb\+Net\+Device, uint16\+\_\+t cell\+Id)
\item 
virtual void \hyperlink{classns3_1_1EmuEpcHelper_a8b7d0f8cf83b8b359ecd7517d73b2297}{Add\+Ue} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ ue\+Lte\+Device, uint64\+\_\+t imsi)
\item 
virtual void \hyperlink{classns3_1_1EmuEpcHelper_adeca48cbe7143128f3578b4904e02218}{Add\+X2\+Interface} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ enb\+Node1, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ enb\+Node2)
\item 
virtual uint8\+\_\+t \hyperlink{classns3_1_1EmuEpcHelper_abe3db05cf4a2a6e1220bcceb2d0b4095}{Activate\+Eps\+Bearer} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ ue\+Lte\+Device, uint64\+\_\+t imsi, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1EpcTft}{Epc\+Tft} $>$ tft, \hyperlink{structns3_1_1EpsBearer}{Eps\+Bearer} bearer)
\item 
virtual uint8\+\_\+t \hyperlink{classns3_1_1EmuEpcHelper_a97cf3f2565769c61b47a06bcc88780c1}{Activate\+Eps\+Bearer} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ ue\+Lte\+Device, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1EpcUeNas}{Epc\+Ue\+Nas} $>$ ue\+Nas, uint64\+\_\+t imsi, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1EpcTft}{Epc\+Tft} $>$ tft, \hyperlink{structns3_1_1EpsBearer}{Eps\+Bearer} bearer)
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1EmuEpcHelper_a3442c3e768f3531ca65e23ba388420f9}{Get\+Pgw\+Node} ()
\item 
virtual \hyperlink{classns3_1_1Ipv4InterfaceContainer}{Ipv4\+Interface\+Container} \hyperlink{classns3_1_1EmuEpcHelper_aac502ef9ce75512e249e7b98f70b82a7}{Assign\+Ue\+Ipv4\+Address} (\hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} ue\+Devices)
\item 
virtual \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \hyperlink{classns3_1_1EmuEpcHelper_a3bd27e33922c8053bff248c7a89f3404}{Get\+Ue\+Default\+Gateway\+Address} ()
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1EmuEpcHelper_ac8293232dc3c4e65ef35373424ea75b2}{Get\+Type\+Id} (void)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ipv4AddressHelper}{Ipv4\+Address\+Helper} \hyperlink{classns3_1_1EmuEpcHelper_ab57fc887c64c3f3aec6516957a84275d}{m\+\_\+ue\+Address\+Helper}
\item 
\hyperlink{classns3_1_1Ipv4AddressHelper}{Ipv4\+Address\+Helper} \hyperlink{classns3_1_1EmuEpcHelper_af71f1e0e4c76588bf8c7565484614c08}{m\+\_\+s1ap\+Ipv4\+Address\+Helper}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1EmuEpcHelper_a5c68f673b82b8c80b5fb88ae986f8cea}{m\+\_\+sgw\+Pgw}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1EpcSgwPgwApplication}{Epc\+Sgw\+Pgw\+Application} $>$ \hyperlink{classns3_1_1EmuEpcHelper_a9f3619ec9e8725d4fbb9794a4f21aaa4}{m\+\_\+sgw\+Pgw\+App}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1VirtualNetDevice}{Virtual\+Net\+Device} $>$ \hyperlink{classns3_1_1EmuEpcHelper_ababd4c0bb2cb44e0194c852e6411b501}{m\+\_\+tun\+Device}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1EmuEpcHelper_aef136870f0ad1c40d3e139f34ff9f5d1}{m\+\_\+mme\+Node}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1EpcMmeApplication}{Epc\+Mme\+Application} $>$ \hyperlink{classns3_1_1EmuEpcHelper_a20264a8bd8b295161b08d09e4794f02f}{m\+\_\+mme\+App}
\item 
\hyperlink{classns3_1_1Ipv4AddressHelper}{Ipv4\+Address\+Helper} \hyperlink{classns3_1_1EmuEpcHelper_a53dccacd37ee9a31fbd739762a615c1b}{m\+\_\+epc\+Ipv4\+Address\+Helper}
\item 
uint16\+\_\+t \hyperlink{classns3_1_1EmuEpcHelper_a99fe0fcbc0bd3668f30cf6ae53377a22}{m\+\_\+gtpu\+Udp\+Port}
\item 
\hyperlink{classns3_1_1DataRate}{Data\+Rate} \hyperlink{classns3_1_1EmuEpcHelper_ac0b5058393492c89ecacfe6324cdef69}{m\+\_\+s1ap\+Link\+Data\+Rate}
\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1EmuEpcHelper_a9e719fe27e97da61af652e8fe47640b6}{m\+\_\+s1ap\+Link\+Delay}
\item 
uint16\+\_\+t \hyperlink{classns3_1_1EmuEpcHelper_a8ed5f99d60bfe51d3dac00c2ab445a17}{m\+\_\+s1ap\+Link\+Mtu}
\item 
uint16\+\_\+t \hyperlink{classns3_1_1EmuEpcHelper_a40b9bb46dee69ea02ffe0722b462db8e}{m\+\_\+s1ap\+Udp\+Port}
\item 
std\+::map$<$ uint64\+\_\+t, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ $>$ \hyperlink{classns3_1_1EmuEpcHelper_ac7fabf537680e203fa2456bc1854e764}{m\+\_\+imsi\+Enb\+Device\+Map}
\item 
\hyperlink{classns3_1_1Ipv4InterfaceContainer}{Ipv4\+Interface\+Container} \hyperlink{classns3_1_1EmuEpcHelper_aec4d868be3d7593b66f0e87fc59055f1}{m\+\_\+sgw\+Ip\+Ifaces}
\item 
std\+::string \hyperlink{classns3_1_1EmuEpcHelper_aaf7c6410b27ea82a8fabc136801bf0d4}{m\+\_\+sgw\+Device\+Name}
\item 
std\+::string \hyperlink{classns3_1_1EmuEpcHelper_a6bd1148381a5fb8d14a20673b4d50420}{m\+\_\+enb\+Device\+Name}
\item 
std\+::string \hyperlink{classns3_1_1EmuEpcHelper_abb2f5dec50c8361cb99e11c9c688bf5c}{m\+\_\+sgw\+Mac\+Address}
\item 
std\+::string \hyperlink{classns3_1_1EmuEpcHelper_a5958f60d6b9a984edace5ee351188e39}{m\+\_\+enb\+Mac\+Address\+Base}
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Create an E\+PC network using Emu\+Fd\+Net\+Device. 

This Helper will create an E\+PC network topology comprising of a single node that implements both the S\+GW and P\+GW functionality, and an M\+ME node. The S1-\/U, X2-\/U and X2-\/C interfaces are realized using Emu\+Fd\+Net\+Device; in particular, one device is used to send all the traffic related to these interfaces. 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!Emu\+Epc\+Helper@{Emu\+Epc\+Helper}}
\index{Emu\+Epc\+Helper@{Emu\+Epc\+Helper}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{Emu\+Epc\+Helper()}{EmuEpcHelper()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Emu\+Epc\+Helper\+::\+Emu\+Epc\+Helper (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1EmuEpcHelper_a10b42d66910c4ee73006f40eea1a1de1}{}\label{classns3_1_1EmuEpcHelper_a10b42d66910c4ee73006f40eea1a1de1}
Constructor 
\begin{DoxyCode}
63   : \hyperlink{classns3_1_1EmuEpcHelper_a99fe0fcbc0bd3668f30cf6ae53377a22}{m\_gtpuUdpPort} (2152),  \textcolor{comment}{// fixed by the standard}
64     \hyperlink{classns3_1_1EmuEpcHelper_a40b9bb46dee69ea02ffe0722b462db8e}{m\_s1apUdpPort} (36412)
65 \{
66   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
67 
68 \}
\end{DoxyCode}
\index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!````~Emu\+Epc\+Helper@{$\sim$\+Emu\+Epc\+Helper}}
\index{````~Emu\+Epc\+Helper@{$\sim$\+Emu\+Epc\+Helper}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{$\sim$\+Emu\+Epc\+Helper()}{~EmuEpcHelper()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Emu\+Epc\+Helper\+::$\sim$\+Emu\+Epc\+Helper (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1EmuEpcHelper_a6d85fe041fb25c277903b65dd6821d09}{}\label{classns3_1_1EmuEpcHelper_a6d85fe041fb25c277903b65dd6821d09}
Destructor 
\begin{DoxyCode}
71 \{
72   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
73 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!Activate\+Eps\+Bearer@{Activate\+Eps\+Bearer}}
\index{Activate\+Eps\+Bearer@{Activate\+Eps\+Bearer}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{Activate\+Eps\+Bearer(\+Ptr$<$ Net\+Device $>$ ue\+Lte\+Device, uint64\+\_\+t imsi, Ptr$<$ Epc\+Tft $>$ tft, Eps\+Bearer bearer)}{ActivateEpsBearer(Ptr< NetDevice > ueLteDevice, uint64_t imsi, Ptr< EpcTft > tft, EpsBearer bearer)}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::\+Emu\+Epc\+Helper\+::\+Activate\+Eps\+Bearer (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{ue\+Lte\+Device, }
\item[{uint64\+\_\+t}]{imsi, }
\item[{{\bf Ptr}$<$ {\bf Epc\+Tft} $>$}]{tft, }
\item[{{\bf Eps\+Bearer}}]{bearer}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1EmuEpcHelper_abe3db05cf4a2a6e1220bcceb2d0b4095}{}\label{classns3_1_1EmuEpcHelper_abe3db05cf4a2a6e1220bcceb2d0b4095}
Activate an E\+PS bearer, setting up the corresponding S1-\/U tunnel.


\begin{DoxyParams}{Parameters}
{\em ue\+Lte\+Device} & the Ipv4-\/enabled device of the UE, normally connected via the L\+TE radio interface \\
\hline
{\em imsi} & the unique identifier of the UE \\
\hline
{\em tft} & the Traffic Flow Template of the new bearer \\
\hline
{\em bearer} & struct describing the characteristics of the E\+PS bearer to be activated \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1EpcHelper_afb58872b560ccfaf012419990185069c}{ns3\+::\+Epc\+Helper}.


\begin{DoxyCode}
389 \{
390   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << ueDevice << imsi);
391 
392   \textcolor{comment}{// we now retrieve the IPv4 address of the UE and notify it to the SGW;}
393   \textcolor{comment}{// we couldn't do it before since address assignment is triggered by}
394   \textcolor{comment}{// the user simulation program, rather than done by the EPC   }
395   Ptr<Node> ueNode = ueDevice->GetNode (); 
396   Ptr<Ipv4> ueIpv4 = ueNode->GetObject<Ipv4> ();
397   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (ueIpv4 != 0, \textcolor{stringliteral}{"UEs need to have IPv4 installed before EPS bearers can be
       activated"});
398   int32\_t \textcolor{keyword}{interface }=  ueIpv4->GetInterfaceForDevice (ueDevice);
399   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (interface >= 0);
400   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (ueIpv4->GetNAddresses (interface) == 1);
401   Ipv4Address ueAddr = ueIpv4->GetAddress (interface, 0).GetLocal ();
402   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{" UE IP address: "} << ueAddr);  \hyperlink{classns3_1_1EmuEpcHelper_a9f3619ec9e8725d4fbb9794a4f21aaa4}{m\_sgwPgwApp}->SetUeAddress (imsi, 
      ueAddr);
403   
404   uint8\_t bearerId = \hyperlink{classns3_1_1EmuEpcHelper_a20264a8bd8b295161b08d09e4794f02f}{m\_mmeApp}->AddBearer (imsi, tft, bearer);
405   Ptr<LteUeNetDevice> ueLteDevice = ueDevice->GetObject<LteUeNetDevice> ();
406   \textcolor{keywordflow}{if} (ueLteDevice)
407     \{
408       \hyperlink{classns3_1_1Simulator_a2219ee02c0647adc83d1c918c3256266}{Simulator::ScheduleNow} (&\hyperlink{classns3_1_1EpcUeNas_acf5ffebf27befd60a0984e8284556b92}{EpcUeNas::ActivateEpsBearer}
      , ueLteDevice->GetNas (), bearer, tft);
409     \}
410   \textcolor{keywordflow}{return} bearerId;
411 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!Activate\+Eps\+Bearer@{Activate\+Eps\+Bearer}}
\index{Activate\+Eps\+Bearer@{Activate\+Eps\+Bearer}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{Activate\+Eps\+Bearer(\+Ptr$<$ Net\+Device $>$ ue\+Lte\+Device, Ptr$<$ Epc\+Ue\+Nas $>$ ue\+Nas, uint64\+\_\+t imsi, Ptr$<$ Epc\+Tft $>$ tft, Eps\+Bearer bearer)}{ActivateEpsBearer(Ptr< NetDevice > ueLteDevice, Ptr< EpcUeNas > ueNas, uint64_t imsi, Ptr< EpcTft > tft, EpsBearer bearer)}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::\+Emu\+Epc\+Helper\+::\+Activate\+Eps\+Bearer (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{ue\+Lte\+Device, }
\item[{{\bf Ptr}$<$ {\bf Epc\+Ue\+Nas} $>$}]{ue\+Nas, }
\item[{uint64\+\_\+t}]{imsi, }
\item[{{\bf Ptr}$<$ {\bf Epc\+Tft} $>$}]{tft, }
\item[{{\bf Eps\+Bearer}}]{bearer}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1EmuEpcHelper_a97cf3f2565769c61b47a06bcc88780c1}{}\label{classns3_1_1EmuEpcHelper_a97cf3f2565769c61b47a06bcc88780c1}
Activate an E\+PS bearer, setting up the corresponding S1-\/U tunnel.


\begin{DoxyParams}{Parameters}
{\em ue\+Lte\+Device} & the Ipv4-\/enabled device of the UE, normally connected via the L\+TE radio interface \\
\hline
{\em the} & N\+AS of that device \\
\hline
{\em imsi} & the unique identifier of the UE \\
\hline
{\em tft} & the Traffic Flow Template of the new bearer \\
\hline
{\em bearer} & struct describing the characteristics of the E\+PS bearer to be activated \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1EpcHelper_ae40cb48539bb7f3bac84282851a5c341}{ns3\+::\+Epc\+Helper}.


\begin{DoxyCode}
415 \{
416   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << ueDevice << imsi);
417 
418   \textcolor{comment}{// we now retrieve the IPv4 address of the UE and notify it to the SGW;}
419   \textcolor{comment}{// we couldn't do it before since address assignment is triggered by}
420   \textcolor{comment}{// the user simulation program, rather than done by the EPC   }
421   Ptr<Node> ueNode = ueDevice->GetNode (); 
422   Ptr<Ipv4> ueIpv4 = ueNode->GetObject<Ipv4> ();
423   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (ueIpv4 != 0, \textcolor{stringliteral}{"UEs need to have IPv4 installed before EPS bearers can be
       activated"});
424   int32\_t \textcolor{keyword}{interface }=  ueIpv4->GetInterfaceForDevice (ueDevice);
425   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (interface >= 0);
426   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (ueIpv4->GetNAddresses (interface) == 1);
427   Ipv4Address ueAddr = ueIpv4->GetAddress (interface, 0).GetLocal ();
428   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{" UE IP address: "} << ueAddr);  \hyperlink{classns3_1_1EmuEpcHelper_a9f3619ec9e8725d4fbb9794a4f21aaa4}{m\_sgwPgwApp}->SetUeAddress (imsi, 
      ueAddr);
429   
430   uint8\_t bearerId = \hyperlink{classns3_1_1EmuEpcHelper_a20264a8bd8b295161b08d09e4794f02f}{m\_mmeApp}->AddBearer (imsi, tft, bearer);
431   \hyperlink{classns3_1_1Simulator_a2219ee02c0647adc83d1c918c3256266}{Simulator::ScheduleNow} (&\hyperlink{classns3_1_1EpcUeNas_acf5ffebf27befd60a0984e8284556b92}{EpcUeNas::ActivateEpsBearer}, 
      ueNas, bearer, tft);
432   \textcolor{keywordflow}{return} bearerId;
433 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!Add\+Enb@{Add\+Enb}}
\index{Add\+Enb@{Add\+Enb}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{Add\+Enb(\+Ptr$<$ Node $>$ enb\+Node, Ptr$<$ Net\+Device $>$ lte\+Enb\+Net\+Device, uint16\+\_\+t cell\+Id)}{AddEnb(Ptr< Node > enbNode, Ptr< NetDevice > lteEnbNetDevice, uint16_t cellId)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Emu\+Epc\+Helper\+::\+Add\+Enb (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{enb\+Node, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{lte\+Enb\+Net\+Device, }
\item[{uint16\+\_\+t}]{cell\+Id}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1EmuEpcHelper_abaff0cf3ed70c034b5e0fd22dc89a7ba}{}\label{classns3_1_1EmuEpcHelper_abaff0cf3ed70c034b5e0fd22dc89a7ba}
Add an e\+NB to the E\+PC


\begin{DoxyParams}{Parameters}
{\em enb\+Node} & the previosuly created e\+NB node which is to be added to the E\+PC \\
\hline
{\em lte\+Enb\+Net\+Device} & the \hyperlink{classns3_1_1LteEnbNetDevice}{Lte\+Enb\+Net\+Device} of the e\+NB node \\
\hline
{\em cell\+Id} & ID of the e\+NB \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1EpcHelper_a0f715f9593ea99e7aa8fa56ed57de6dc}{ns3\+::\+Epc\+Helper}.


\begin{DoxyCode}
220 \{
221   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << enb << lteEnbNetDevice << cellId);
222 
223   \hyperlink{classns3_1_1Object_af4411cb29971772fcd09203474a95078}{Initialize} ();
224 
225   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (enb == lteEnbNetDevice->GetNode ());  
226 
227   \textcolor{comment}{// add an IPv4 stack to the previously created eNB}
228   InternetStackHelper internet;
229   internet.Install (enb);
230   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"number of Ipv4 ifaces of the eNB after node creation: "} << enb->GetObject<Ipv4
      > ()->GetNInterfaces ());
231 
232 
233 
234   \textcolor{comment}{// Create an EmuFdNetDevice for the eNB to connect with the SGW and other eNBs}
235   EmuFdNetDeviceHelper emu;
236   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"eNB device: "} << \hyperlink{classns3_1_1EmuEpcHelper_a6bd1148381a5fb8d14a20673b4d50420}{m\_enbDeviceName});
237   emu.SetDeviceName (\hyperlink{classns3_1_1EmuEpcHelper_a6bd1148381a5fb8d14a20673b4d50420}{m\_enbDeviceName});  
238   NetDeviceContainer enbDevices = emu.Install (enb);
239 
240   \hyperlink{group__fatal_ga979468222aa80366c2c98aa1554f3eec}{NS\_ABORT\_IF} ((cellId == 0) || (cellId > 255));
241   std::ostringstream enbMacAddress;
242   enbMacAddress << \hyperlink{classns3_1_1EmuEpcHelper_a5958f60d6b9a984edace5ee351188e39}{m\_enbMacAddressBase} << \textcolor{stringliteral}{":"} << std::hex << std::setfill (\textcolor{charliteral}{'0'}) << 
      std::setw (2) << cellId;
243   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"MAC address of enB with cellId "} << cellId << \textcolor{stringliteral}{" : "} << enbMacAddress.str ());
244   Ptr<NetDevice> enbDev = enbDevices.Get (0);
245   enbDev->SetAttribute (\textcolor{stringliteral}{"Address"}, Mac48AddressValue (enbMacAddress.str ().c\_str ()));
246 
247   \textcolor{comment}{//emu.EnablePcap ("enbDevice", enbDev);}
248 
249   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"number of Ipv4 ifaces of the eNB after installing emu dev: "} << enb->GetObject
      <Ipv4> ()->GetNInterfaces ());  
250   Ipv4InterfaceContainer enbIpIfaces = \hyperlink{classns3_1_1EmuEpcHelper_a53dccacd37ee9a31fbd739762a615c1b}{m\_epcIpv4AddressHelper}.
      \hyperlink{classns3_1_1Ipv4AddressHelper_af8e7f4a1a7e74c00014a1eac445a27af}{Assign} (enbDevices);
251   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"number of Ipv4 ifaces of the eNB after assigning Ipv4 addr to S1 dev: "} << enb
      ->GetObject<Ipv4> ()->GetNInterfaces ());
252   
253   Ipv4Address enbAddress = enbIpIfaces.GetAddress (0);
254   Ipv4Address sgwAddress = \hyperlink{classns3_1_1EmuEpcHelper_aec4d868be3d7593b66f0e87fc59055f1}{m\_sgwIpIfaces}.\hyperlink{classns3_1_1Ipv4InterfaceContainer_ae63208dcd222be986822937ee4aa828c}{GetAddress} (0);
255 
256   \textcolor{comment}{// create S1-U socket for the ENB}
257   Ptr<Socket> enbS1uSocket = \hyperlink{classns3_1_1Socket_ad448a62bb50ad3dbac59c879a885a8d2}{Socket::CreateSocket} (enb, 
      \hyperlink{classns3_1_1TypeId_a119cf99c20931fdc294602cd360b180e}{TypeId::LookupByName} (\textcolor{stringliteral}{"ns3::UdpSocketFactory"}));
258   \textcolor{keywordtype}{int} retval = enbS1uSocket->Bind (InetSocketAddress (enbAddress, \hyperlink{classns3_1_1EmuEpcHelper_a99fe0fcbc0bd3668f30cf6ae53377a22}{m\_gtpuUdpPort}));
259   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (retval == 0);
260     
261   \textcolor{comment}{// create LTE socket for the ENB }
262   Ptr<Socket> enbLteSocket = \hyperlink{classns3_1_1Socket_ad448a62bb50ad3dbac59c879a885a8d2}{Socket::CreateSocket} (enb, 
      \hyperlink{classns3_1_1TypeId_a119cf99c20931fdc294602cd360b180e}{TypeId::LookupByName} (\textcolor{stringliteral}{"ns3::PacketSocketFactory"}));
263   PacketSocketAddress enbLteSocketBindAddress;
264   enbLteSocketBindAddress.SetSingleDevice (lteEnbNetDevice->GetIfIndex ());
265   enbLteSocketBindAddress.SetProtocol (\hyperlink{classns3_1_1Ipv4L3Protocol_a0146bc84815b7b73adb9c62cdafc9442}{Ipv4L3Protocol::PROT\_NUMBER});
266   retval = enbLteSocket->Bind (enbLteSocketBindAddress);
267   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (retval == 0);  
268   PacketSocketAddress enbLteSocketConnectAddress;
269   enbLteSocketConnectAddress.SetPhysicalAddress (\hyperlink{classns3_1_1Mac48Address_a55156e302c6bf950c0b558365adbde84}{Mac48Address::GetBroadcast} ());
270   enbLteSocketConnectAddress.SetSingleDevice (lteEnbNetDevice->GetIfIndex ());
271   enbLteSocketConnectAddress.SetProtocol (\hyperlink{classns3_1_1Ipv4L3Protocol_a0146bc84815b7b73adb9c62cdafc9442}{Ipv4L3Protocol::PROT\_NUMBER});
272   retval = enbLteSocket->Connect (enbLteSocketConnectAddress);
273   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (retval == 0);  
274   
275   \textcolor{comment}{// create a point to point link between the new eNB and the MME with}
276   \textcolor{comment}{// the corresponding new NetDevices on each side}
277   NodeContainer enbMmeNodes;
278   enbMmeNodes.Add (\hyperlink{classns3_1_1EmuEpcHelper_aef136870f0ad1c40d3e139f34ff9f5d1}{m\_mmeNode});
279   enbMmeNodes.Add (enb);
280   PointToPointHelper p2ph\_mme;
281   p2ph\_mme.SetDeviceAttribute (\textcolor{stringliteral}{"DataRate"}, DataRateValue (\hyperlink{classns3_1_1EmuEpcHelper_ac0b5058393492c89ecacfe6324cdef69}{m\_s1apLinkDataRate}));
282   p2ph\_mme.SetDeviceAttribute (\textcolor{stringliteral}{"Mtu"}, UintegerValue (\hyperlink{classns3_1_1EmuEpcHelper_a8ed5f99d60bfe51d3dac00c2ab445a17}{m\_s1apLinkMtu}));
283   p2ph\_mme.SetChannelAttribute (\textcolor{stringliteral}{"Delay"}, TimeValue (\hyperlink{classns3_1_1EmuEpcHelper_a9e719fe27e97da61af652e8fe47640b6}{m\_s1apLinkDelay}));  
284   NetDeviceContainer enbMmeDevices = p2ph\_mme.Install (enb, \hyperlink{classns3_1_1EmuEpcHelper_aef136870f0ad1c40d3e139f34ff9f5d1}{m\_mmeNode});
285   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"number of Ipv4 ifaces of the eNB after installing p2p dev: "} << enb->GetObject
      <Ipv4> ()->GetNInterfaces ());  
286 
287   \hyperlink{classns3_1_1EmuEpcHelper_af71f1e0e4c76588bf8c7565484614c08}{m\_s1apIpv4AddressHelper}.\hyperlink{classns3_1_1Ipv4AddressHelper_a3277d133ef0d2669934a16a8206ba8e4}{NewNetwork} ();
288   Ipv4InterfaceContainer enbMmeIpIfaces = \hyperlink{classns3_1_1EmuEpcHelper_af71f1e0e4c76588bf8c7565484614c08}{m\_s1apIpv4AddressHelper}.
      \hyperlink{classns3_1_1Ipv4AddressHelper_af8e7f4a1a7e74c00014a1eac445a27af}{Assign} (enbMmeDevices);
289   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"number of Ipv4 ifaces of the eNB after assigning Ipv4 addr to S1 dev: "} << enb
      ->GetObject<Ipv4> ()->GetNInterfaces ());
290   
291   Ipv4Address mme\_enbAddress = enbMmeIpIfaces.GetAddress (0);
292   Ipv4Address mmeAddress = enbMmeIpIfaces.GetAddress (1);
293 
294   \textcolor{comment}{// create S1-AP socket for the ENB}
295   Ptr<Socket> enbS1apSocket = \hyperlink{classns3_1_1Socket_ad448a62bb50ad3dbac59c879a885a8d2}{Socket::CreateSocket} (enb, 
      \hyperlink{classns3_1_1TypeId_a119cf99c20931fdc294602cd360b180e}{TypeId::LookupByName} (\textcolor{stringliteral}{"ns3::UdpSocketFactory"}));
296   retval = enbS1apSocket->Bind (InetSocketAddress (mme\_enbAddress, \hyperlink{classns3_1_1EmuEpcHelper_a40b9bb46dee69ea02ffe0722b462db8e}{m\_s1apUdpPort}));
297   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (retval == 0);
298 
299   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"create EpcEnbApplication"});
300   Ptr<EpcEnbApplication> enbApp = CreateObject<EpcEnbApplication> (enbLteSocket, enbS1uSocket, enbAddress, 
      sgwAddress, cellId);
301   enb->AddApplication (enbApp);
302   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (enb->GetNApplications () == 1);
303   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (enb->GetApplication (0)->GetObject<EpcEnbApplication> () != 0, \textcolor{stringliteral}{"cannot
       retrieve EpcEnbApplication"});
304   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"enb: "} << enb << \textcolor{stringliteral}{", enb->GetApplication (0): "} << enb->GetApplication (0));
305 
306   
307   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Create EpcX2 entity"});
308   Ptr<EpcX2> x2 = CreateObject<EpcX2> ();
309   enb->AggregateObject (x2);
310 
311   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"connect S1-AP interface"});
312 
313   uint16\_t mmeId = 1;
314   Ptr<EpcS1apEnb> s1apEnb = CreateObject<EpcS1apEnb> (enbS1apSocket, mme\_enbAddress, mmeAddress, cellId, 
      mmeId); \textcolor{comment}{// only one mme!}
315   enb->AggregateObject(s1apEnb);
316   enbApp->SetS1apSapMme (s1apEnb->GetEpcS1apSapEnbProvider ());
317   s1apEnb->SetEpcS1apSapEnbUser (enbApp->GetS1apSapEnb());
318   \hyperlink{classns3_1_1EmuEpcHelper_a20264a8bd8b295161b08d09e4794f02f}{m\_mmeApp}->AddEnb (cellId, mme\_enbAddress); \textcolor{comment}{// TODO consider if this can be removed}
319   \textcolor{comment}{// add the interface to the S1AP endpoint on the MME}
320   Ptr<EpcS1apMme> s1apMme = \hyperlink{classns3_1_1EmuEpcHelper_aef136870f0ad1c40d3e139f34ff9f5d1}{m\_mmeNode}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<EpcS1apMme> ();
321   s1apMme->AddS1apInterface (cellId, mme\_enbAddress);
322   
323   \hyperlink{classns3_1_1EmuEpcHelper_a9f3619ec9e8725d4fbb9794a4f21aaa4}{m\_sgwPgwApp}->AddEnb (cellId, enbAddress, sgwAddress);
324 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4


\index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!Add\+Ue@{Add\+Ue}}
\index{Add\+Ue@{Add\+Ue}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{Add\+Ue(\+Ptr$<$ Net\+Device $>$ ue\+Lte\+Device, uint64\+\_\+t imsi)}{AddUe(Ptr< NetDevice > ueLteDevice, uint64_t imsi)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Emu\+Epc\+Helper\+::\+Add\+Ue (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{ue\+Lte\+Device, }
\item[{uint64\+\_\+t}]{imsi}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1EmuEpcHelper_a8b7d0f8cf83b8b359ecd7517d73b2297}{}\label{classns3_1_1EmuEpcHelper_a8b7d0f8cf83b8b359ecd7517d73b2297}
Notify the E\+PC of the existance of a new UE which might attach at a later time


\begin{DoxyParams}{Parameters}
{\em ue\+Lte\+Device} & the UE device to be attached \\
\hline
{\em imsi} & the unique identifier of the UE \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1EpcHelper_a900681efc6663ad4bc5f9d3aedd1a6ef}{ns3\+::\+Epc\+Helper}.


\begin{DoxyCode}
379 \{
380   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << imsi << ueDevice );
381   
382   \hyperlink{classns3_1_1EmuEpcHelper_a20264a8bd8b295161b08d09e4794f02f}{m\_mmeApp}->AddUe (imsi);
383   \hyperlink{classns3_1_1EmuEpcHelper_a9f3619ec9e8725d4fbb9794a4f21aaa4}{m\_sgwPgwApp}->AddUe (imsi);
384   
385 \}
\end{DoxyCode}
\index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!Add\+X2\+Interface@{Add\+X2\+Interface}}
\index{Add\+X2\+Interface@{Add\+X2\+Interface}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{Add\+X2\+Interface(\+Ptr$<$ Node $>$ enb\+Node1, Ptr$<$ Node $>$ enb\+Node2)}{AddX2Interface(Ptr< Node > enbNode1, Ptr< Node > enbNode2)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Emu\+Epc\+Helper\+::\+Add\+X2\+Interface (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{enb\+Node1, }
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{enb\+Node2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1EmuEpcHelper_adeca48cbe7143128f3578b4904e02218}{}\label{classns3_1_1EmuEpcHelper_adeca48cbe7143128f3578b4904e02218}
Add an X2 interface between two e\+NB


\begin{DoxyParams}{Parameters}
{\em enb\+Node1} & one e\+NB peer of the X2 interface \\
\hline
{\em enb\+Node2} & the other e\+NB peer of the X2 interface \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1EpcHelper_a69497cfb457e8b44cb0f21b56bcaae34}{ns3\+::\+Epc\+Helper}.


\begin{DoxyCode}
329 \{
330   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << enb1 << enb2);
331 
332   \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"X2 support still untested"});
333 
334 
335   \textcolor{comment}{// for X2, we reuse the same device and IP address of the S1-U interface}
336   Ptr<Ipv4> enb1Ipv4 = enb1->GetObject<Ipv4> ();
337   Ptr<Ipv4> enb2Ipv4 = enb2->GetObject<Ipv4> ();
338   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"number of Ipv4 ifaces of the eNB #1: "} << enb1Ipv4->GetNInterfaces ());
339   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"number of Ipv4 ifaces of the eNB #2: "} << enb2Ipv4->GetNInterfaces ());
340   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"number of NetDevices of the eNB #1: "} << enb1->GetNDevices ());
341   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"number of NetDevices of the eNB #2: "} << enb2->GetNDevices ());
342 
343   \textcolor{comment}{// 0 is the LTE device, 1 is localhost, 2 is the EPC NetDevice}
344   Ptr<NetDevice> enb1EpcDev = enb1->GetDevice (2);
345   Ptr<NetDevice> enb2EpcDev = enb2->GetDevice (2);
346 
347   int32\_t enb1Interface =  enb1Ipv4->GetInterfaceForDevice (enb1EpcDev);
348   int32\_t enb2Interface =  enb2Ipv4->GetInterfaceForDevice (enb2EpcDev);
349   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (enb1Interface >= 0);
350   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (enb2Interface >= 0);
351   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (enb1Ipv4->GetNAddresses (enb1Interface) == 1);
352   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (enb2Ipv4->GetNAddresses (enb2Interface) == 1);
353   Ipv4Address enb1Addr = enb1Ipv4->GetAddress (enb1Interface, 0).GetLocal (); 
354   Ipv4Address enb2Addr = enb2Ipv4->GetAddress (enb2Interface, 0).GetLocal (); 
355   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{" eNB 1 IP address: "} << enb1Addr); 
356   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{" eNB 2 IP address: "} << enb2Addr);
357   
358   \textcolor{comment}{// Add X2 interface to both eNBs' X2 entities}
359   Ptr<EpcX2> enb1X2 = enb1->GetObject<EpcX2> ();
360   Ptr<LteEnbNetDevice> enb1LteDev = enb1->GetDevice (0)->GetObject<LteEnbNetDevice> ();
361   uint16\_t enb1CellId = enb1LteDev->GetCellId ();
362   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"LteEnbNetDevice #1 = "} << enb1LteDev << \textcolor{stringliteral}{" - CellId = "} << enb1CellId);
363 
364   Ptr<EpcX2> enb2X2 = enb2->GetObject<EpcX2> ();
365   Ptr<LteEnbNetDevice> enb2LteDev = enb2->GetDevice (0)->GetObject<LteEnbNetDevice> ();
366   uint16\_t enb2CellId = enb2LteDev->GetCellId ();
367   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"LteEnbNetDevice #2 = "} << enb2LteDev << \textcolor{stringliteral}{" - CellId = "} << enb2CellId);
368 
369   enb1X2->AddX2Interface (enb1CellId, enb1Addr, enb2CellId, enb2Addr);
370   enb2X2->AddX2Interface (enb2CellId, enb2Addr, enb1CellId, enb1Addr);
371 
372   enb1LteDev->GetRrc ()->AddX2Neighbour (enb2LteDev->GetCellId ());
373   enb2LteDev->GetRrc ()->AddX2Neighbour (enb1LteDev->GetCellId ());
374 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5


\index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!Assign\+Ue\+Ipv4\+Address@{Assign\+Ue\+Ipv4\+Address}}
\index{Assign\+Ue\+Ipv4\+Address@{Assign\+Ue\+Ipv4\+Address}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{Assign\+Ue\+Ipv4\+Address(\+Net\+Device\+Container ue\+Devices)}{AssignUeIpv4Address(NetDeviceContainer ueDevices)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Interface\+Container} ns3\+::\+Emu\+Epc\+Helper\+::\+Assign\+Ue\+Ipv4\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Net\+Device\+Container}}]{ue\+Devices}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1EmuEpcHelper_aac502ef9ce75512e249e7b98f70b82a7}{}\label{classns3_1_1EmuEpcHelper_aac502ef9ce75512e249e7b98f70b82a7}
Assign I\+Pv4 addresses to UE devices


\begin{DoxyParams}{Parameters}
{\em ue\+Devices} & the set of UE devices\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the interface container, 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Ipv4AddressHelper_af8e7f4a1a7e74c00014a1eac445a27af}{Ipv4\+Address\+Helper\+::\+Assign()} which has similar semantics 
\end{DoxySeeAlso}


Implements \hyperlink{classns3_1_1EpcHelper_a1184afcb5823f2a3ed62fc7f2a7fdc7e}{ns3\+::\+Epc\+Helper}.


\begin{DoxyCode}
445 \{
446   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1EmuEpcHelper_ab57fc887c64c3f3aec6516957a84275d}{m\_ueAddressHelper}.\hyperlink{classns3_1_1Ipv4AddressHelper_af8e7f4a1a7e74c00014a1eac445a27af}{Assign} (ueDevices);
447 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6


\index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{Do\+Dispose()}{DoDispose()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Emu\+Epc\+Helper\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1EmuEpcHelper_a4e8f0a693cb3d0ac02b558832b9da4f6}{}\label{classns3_1_1EmuEpcHelper_a4e8f0a693cb3d0ac02b558832b9da4f6}
Destructor implementation.

This method is called by \hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose()} or by the \hyperlink{classns3_1_1Object}{Object}\textquotesingle{}s destructor, whichever comes first.

Subclasses are expected to implement their real destruction code in an overriden version of this method and chain up to their parent\textquotesingle{}s implementation once they are done. {\itshape i.\+e}, for simplicity, the destructor of every subclass should be empty and its content should be moved to the associated \hyperlink{classns3_1_1EmuEpcHelper_a4e8f0a693cb3d0ac02b558832b9da4f6}{Do\+Dispose()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1EpcHelper_a6c1962f072e55196ad97df418892b135}{ns3\+::\+Epc\+Helper}.


\begin{DoxyCode}
209 \{
210   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
211   \hyperlink{classns3_1_1EmuEpcHelper_ababd4c0bb2cb44e0194c852e6411b501}{m\_tunDevice}->\hyperlink{classns3_1_1VirtualNetDevice_ae4e54639e40bf1c5d8d6ed7da9ababed}{SetSendCallback} (\hyperlink{group__makenullcallback_ga7e3cd6816f63ea9112c04b0086c2c65a}{MakeNullCallback}<\textcolor{keywordtype}{bool}, 
      Ptr<Packet>, \textcolor{keyword}{const} Address&, \textcolor{keyword}{const} Address&, uint16\_t> ());
212   \hyperlink{classns3_1_1EmuEpcHelper_ababd4c0bb2cb44e0194c852e6411b501}{m\_tunDevice} = 0;
213   \hyperlink{classns3_1_1EmuEpcHelper_a9f3619ec9e8725d4fbb9794a4f21aaa4}{m\_sgwPgwApp} = 0;  
214   \hyperlink{classns3_1_1EmuEpcHelper_a5c68f673b82b8c80b5fb88ae986f8cea}{m\_sgwPgw}->\hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose} ();
215 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7


\index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!Do\+Initialize@{Do\+Initialize}}
\index{Do\+Initialize@{Do\+Initialize}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{Do\+Initialize()}{DoInitialize()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Emu\+Epc\+Helper\+::\+Do\+Initialize (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1EmuEpcHelper_ae66ac77634aad1dfb03bbe0d8a54acc1}{}\label{classns3_1_1EmuEpcHelper_ae66ac77634aad1dfb03bbe0d8a54acc1}
\hyperlink{classns3_1_1Object_af4411cb29971772fcd09203474a95078}{Initialize()} implementation.

This method is called only once by \hyperlink{classns3_1_1Object_af4411cb29971772fcd09203474a95078}{Initialize()}. If the user calls \hyperlink{classns3_1_1Object_af4411cb29971772fcd09203474a95078}{Initialize()} multiple times, \hyperlink{classns3_1_1EmuEpcHelper_ae66ac77634aad1dfb03bbe0d8a54acc1}{Do\+Initialize()} is called only the first time.

Subclasses are expected to override this method and chain up to their parent\textquotesingle{}s implementation once they are done. It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} and \hyperlink{classns3_1_1Object_a79dd435d300f3deca814553f561a2922}{Aggregate\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_af8482a521433409fb5c7f749398c9dbe}{ns3\+::\+Object}.


\begin{DoxyCode}
123 \{
124   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{keyword}{this});   
125 
126 
127   \textcolor{comment}{// we use a /8 net for all UEs}
128   \hyperlink{classns3_1_1EmuEpcHelper_ab57fc887c64c3f3aec6516957a84275d}{m\_ueAddressHelper}.\hyperlink{classns3_1_1Ipv4AddressHelper_acf7b16dd25bac67e00f5e25f90a9a035}{SetBase} (\textcolor{stringliteral}{"7.0.0.0"}, \textcolor{stringliteral}{"255.0.0.0"});
129   \hyperlink{classns3_1_1EmuEpcHelper_af71f1e0e4c76588bf8c7565484614c08}{m\_s1apIpv4AddressHelper}.\hyperlink{classns3_1_1Ipv4AddressHelper_acf7b16dd25bac67e00f5e25f90a9a035}{SetBase} (\textcolor{stringliteral}{"11.0.0.0"}, \textcolor{stringliteral}{"255.255.255.252"});
130   
131  
132   \textcolor{comment}{// create SgwPgwNode}
133   \hyperlink{classns3_1_1EmuEpcHelper_a5c68f673b82b8c80b5fb88ae986f8cea}{m\_sgwPgw} = CreateObject<Node> ();
134   InternetStackHelper internet;
135   internet.SetIpv4StackInstall (\textcolor{keyword}{true});
136   internet.Install (\hyperlink{classns3_1_1EmuEpcHelper_a5c68f673b82b8c80b5fb88ae986f8cea}{m\_sgwPgw});
137 
138   \textcolor{comment}{// create MmeNode}
139   \hyperlink{classns3_1_1EmuEpcHelper_aef136870f0ad1c40d3e139f34ff9f5d1}{m\_mmeNode} = CreateObject<Node> ();
140   internet.Install (\hyperlink{classns3_1_1EmuEpcHelper_aef136870f0ad1c40d3e139f34ff9f5d1}{m\_mmeNode});
141   
142   \textcolor{comment}{// create S1-U socket for SgwPgwNode}
143   Ptr<Socket> sgwPgwS1uSocket = \hyperlink{classns3_1_1Socket_ad448a62bb50ad3dbac59c879a885a8d2}{Socket::CreateSocket} (
      \hyperlink{classns3_1_1EmuEpcHelper_a5c68f673b82b8c80b5fb88ae986f8cea}{m\_sgwPgw}, \hyperlink{classns3_1_1TypeId_a119cf99c20931fdc294602cd360b180e}{TypeId::LookupByName} (\textcolor{stringliteral}{"ns3::UdpSocketFactory"}));
144   \textcolor{keywordtype}{int} retval = sgwPgwS1uSocket->Bind (InetSocketAddress (\hyperlink{classns3_1_1Ipv4Address_a7a39b330c8e701183a411d5779fca1a4}{Ipv4Address::GetAny} (), 
      \hyperlink{classns3_1_1EmuEpcHelper_a99fe0fcbc0bd3668f30cf6ae53377a22}{m\_gtpuUdpPort}));
145   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (retval == 0);
146 
147   \textcolor{comment}{// create S1-AP socket for MmeNode}
148   Ptr<Socket> mmeS1apSocket = \hyperlink{classns3_1_1Socket_ad448a62bb50ad3dbac59c879a885a8d2}{Socket::CreateSocket} (
      \hyperlink{classns3_1_1EmuEpcHelper_aef136870f0ad1c40d3e139f34ff9f5d1}{m\_mmeNode}, \hyperlink{classns3_1_1TypeId_a119cf99c20931fdc294602cd360b180e}{TypeId::LookupByName} (\textcolor{stringliteral}{"ns3::UdpSocketFactory"}));
149   retval = mmeS1apSocket->Bind (InetSocketAddress (\hyperlink{classns3_1_1Ipv4Address_a7a39b330c8e701183a411d5779fca1a4}{Ipv4Address::GetAny} (), 
      \hyperlink{classns3_1_1EmuEpcHelper_a40b9bb46dee69ea02ffe0722b462db8e}{m\_s1apUdpPort})); \textcolor{comment}{// it listens on any IP, port m\_s1apUdpPort}
150   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (retval == 0);
151 
152   \textcolor{comment}{// create TUN device implementing tunneling of user data over GTP-U/UDP/IP }
153   \hyperlink{classns3_1_1EmuEpcHelper_ababd4c0bb2cb44e0194c852e6411b501}{m\_tunDevice} = CreateObject<VirtualNetDevice> ();
154   \textcolor{comment}{// allow jumbo packets}
155   \hyperlink{classns3_1_1EmuEpcHelper_ababd4c0bb2cb44e0194c852e6411b501}{m\_tunDevice}->\hyperlink{classns3_1_1ObjectBase_ac60245d3ea4123bbc9b1d391f1f6592f}{SetAttribute} (\textcolor{stringliteral}{"Mtu"}, UintegerValue (30000));
156 
157   \textcolor{comment}{// yes we need this}
158   \hyperlink{classns3_1_1EmuEpcHelper_ababd4c0bb2cb44e0194c852e6411b501}{m\_tunDevice}->\hyperlink{classns3_1_1VirtualNetDevice_a560887abe97f9327f2973d748aa382e9}{SetAddress} (\hyperlink{classns3_1_1Mac48Address_a203b53c035649c0d4881fa1115aa2cdb}{Mac48Address::Allocate} ()); 
159 
160   \hyperlink{classns3_1_1EmuEpcHelper_a5c68f673b82b8c80b5fb88ae986f8cea}{m\_sgwPgw}->\hyperlink{classns3_1_1Node_a42ff83ee1d5d1649c770d3f5b62375de}{AddDevice} (\hyperlink{classns3_1_1EmuEpcHelper_ababd4c0bb2cb44e0194c852e6411b501}{m\_tunDevice});
161   NetDeviceContainer tunDeviceContainer;
162   tunDeviceContainer.Add (\hyperlink{classns3_1_1EmuEpcHelper_ababd4c0bb2cb44e0194c852e6411b501}{m\_tunDevice});
163   
164   \textcolor{comment}{// the TUN device is on the same subnet as the UEs, so when a packet}
165   \textcolor{comment}{// addressed to an UE arrives at the intenet to the WAN interface of}
166   \textcolor{comment}{// the PGW it will be forwarded to the TUN device. }
167   Ipv4InterfaceContainer tunDeviceIpv4IfContainer = \hyperlink{classns3_1_1EmuEpcHelper_ab57fc887c64c3f3aec6516957a84275d}{m\_ueAddressHelper}.
      \hyperlink{classns3_1_1Ipv4AddressHelper_af8e7f4a1a7e74c00014a1eac445a27af}{Assign} (tunDeviceContainer);  
168 
169   \textcolor{comment}{// create EpcSgwPgwApplication}
170   \hyperlink{classns3_1_1EmuEpcHelper_a9f3619ec9e8725d4fbb9794a4f21aaa4}{m\_sgwPgwApp} = CreateObject<EpcSgwPgwApplication> (\hyperlink{classns3_1_1EmuEpcHelper_ababd4c0bb2cb44e0194c852e6411b501}{m\_tunDevice}, sgwPgwS1uSocket);
171   \hyperlink{classns3_1_1EmuEpcHelper_a5c68f673b82b8c80b5fb88ae986f8cea}{m\_sgwPgw}->\hyperlink{classns3_1_1Node_ab98b4fdc4aadc86366b80e8a79a53f47}{AddApplication} (\hyperlink{classns3_1_1EmuEpcHelper_a9f3619ec9e8725d4fbb9794a4f21aaa4}{m\_sgwPgwApp});
172   
173   \textcolor{comment}{// connect SgwPgwApplication and virtual net device for tunneling}
174   m\_tunDevice->SetSendCallback (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1EpcSgwPgwApplication_aeea285ccd04a4350e4ddb77a359e97ca}{EpcSgwPgwApplication::RecvFromTunDevice}, 
      \hyperlink{classns3_1_1EmuEpcHelper_a9f3619ec9e8725d4fbb9794a4f21aaa4}{m\_sgwPgwApp}));
175 
176   \textcolor{comment}{// create S1apMme object and aggregate it with the m\_mmeNode}
177   Ptr<EpcS1apMme> s1apMme = CreateObject<EpcS1apMme> (mmeS1apSocket, 1); \textcolor{comment}{// for now, only one mme!}
178   \hyperlink{classns3_1_1EmuEpcHelper_aef136870f0ad1c40d3e139f34ff9f5d1}{m\_mmeNode}->\hyperlink{classns3_1_1Object_a79dd435d300f3deca814553f561a2922}{AggregateObject}(s1apMme);
179 
180   \textcolor{comment}{// create EpcMmeApplication and connect with SGW via S11 interface}
181   \hyperlink{classns3_1_1EmuEpcHelper_a20264a8bd8b295161b08d09e4794f02f}{m\_mmeApp} = CreateObject<EpcMmeApplication> ();
182   \hyperlink{classns3_1_1EmuEpcHelper_aef136870f0ad1c40d3e139f34ff9f5d1}{m\_mmeNode}->\hyperlink{classns3_1_1Node_ab98b4fdc4aadc86366b80e8a79a53f47}{AddApplication} (\hyperlink{classns3_1_1EmuEpcHelper_a20264a8bd8b295161b08d09e4794f02f}{m\_mmeApp});
183   \hyperlink{classns3_1_1EmuEpcHelper_a20264a8bd8b295161b08d09e4794f02f}{m\_mmeApp}->SetS11SapSgw (\hyperlink{classns3_1_1EmuEpcHelper_a9f3619ec9e8725d4fbb9794a4f21aaa4}{m\_sgwPgwApp}->GetS11SapSgw ());
184   \hyperlink{classns3_1_1EmuEpcHelper_a9f3619ec9e8725d4fbb9794a4f21aaa4}{m\_sgwPgwApp}->SetS11SapMme (\hyperlink{classns3_1_1EmuEpcHelper_a20264a8bd8b295161b08d09e4794f02f}{m\_mmeApp}->GetS11SapMme ());
185   \textcolor{comment}{// connect m\_mmeApp to the s1apMme}
186   \hyperlink{classns3_1_1EmuEpcHelper_a20264a8bd8b295161b08d09e4794f02f}{m\_mmeApp}->SetS1apSapMmeProvider(s1apMme->GetEpcS1apSapMmeProvider());
187   s1apMme->SetEpcS1apSapMmeUser(\hyperlink{classns3_1_1EmuEpcHelper_a20264a8bd8b295161b08d09e4794f02f}{m\_mmeApp}->GetS1apSapMme());
188 
189   \textcolor{comment}{// Create EmuFdNetDevice for SGW}
190   EmuFdNetDeviceHelper emu;
191   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"SGW device: "} << \hyperlink{classns3_1_1EmuEpcHelper_aaf7c6410b27ea82a8fabc136801bf0d4}{m\_sgwDeviceName});
192   emu.SetDeviceName (\hyperlink{classns3_1_1EmuEpcHelper_aaf7c6410b27ea82a8fabc136801bf0d4}{m\_sgwDeviceName});
193   NetDeviceContainer sgwDevices = emu.Install (\hyperlink{classns3_1_1EmuEpcHelper_a5c68f673b82b8c80b5fb88ae986f8cea}{m\_sgwPgw});
194   Ptr<NetDevice> sgwDevice = sgwDevices.Get (0);
195   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"MAC address of SGW: "} << \hyperlink{classns3_1_1EmuEpcHelper_abb2f5dec50c8361cb99e11c9c688bf5c}{m\_sgwMacAddress});
196   sgwDevice->SetAttribute (\textcolor{stringliteral}{"Address"}, Mac48AddressValue (\hyperlink{classns3_1_1EmuEpcHelper_abb2f5dec50c8361cb99e11c9c688bf5c}{m\_sgwMacAddress}.c\_str ()));
197 
198   \textcolor{comment}{// we use a /8 subnet so the SGW and the eNBs can talk directly to each other}
199   \hyperlink{classns3_1_1EmuEpcHelper_a53dccacd37ee9a31fbd739762a615c1b}{m\_epcIpv4AddressHelper}.\hyperlink{classns3_1_1Ipv4AddressHelper_acf7b16dd25bac67e00f5e25f90a9a035}{SetBase} (\textcolor{stringliteral}{"10.0.0.0"}, \textcolor{stringliteral}{"255.255.255.0"}, \textcolor{stringliteral}{"0.0.0.1"});  
200   \hyperlink{classns3_1_1EmuEpcHelper_aec4d868be3d7593b66f0e87fc59055f1}{m\_sgwIpIfaces} = \hyperlink{classns3_1_1EmuEpcHelper_a53dccacd37ee9a31fbd739762a615c1b}{m\_epcIpv4AddressHelper}.
      \hyperlink{classns3_1_1Ipv4AddressHelper_af8e7f4a1a7e74c00014a1eac445a27af}{Assign} (sgwDevices);
201   \hyperlink{classns3_1_1EmuEpcHelper_a53dccacd37ee9a31fbd739762a615c1b}{m\_epcIpv4AddressHelper}.\hyperlink{classns3_1_1Ipv4AddressHelper_acf7b16dd25bac67e00f5e25f90a9a035}{SetBase} (\textcolor{stringliteral}{"10.0.0.0"}, \textcolor{stringliteral}{"255.0.0.0"}, \textcolor{stringliteral}{"0.0.0.101"});  
202   
203   
204   \hyperlink{classns3_1_1Object_af8482a521433409fb5c7f749398c9dbe}{EpcHelper::DoInitialize} ();
205 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8


\index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!Get\+Pgw\+Node@{Get\+Pgw\+Node}}
\index{Get\+Pgw\+Node@{Get\+Pgw\+Node}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{Get\+Pgw\+Node()}{GetPgwNode()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Node} $>$ ns3\+::\+Emu\+Epc\+Helper\+::\+Get\+Pgw\+Node (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1EmuEpcHelper_a3442c3e768f3531ca65e23ba388420f9}{}\label{classns3_1_1EmuEpcHelper_a3442c3e768f3531ca65e23ba388420f9}
\begin{DoxyReturn}{Returns}
a pointer to the node implementing P\+GW functionality. Note that in this particular implementation this node will also hold the S\+GW functionality. The primary use intended for this method is to allow the user to configure the Gi interface of the P\+GW, i.\+e., to connect the P\+GW to the internet. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1EpcHelper_a5df840eab9ce83c2e1315a315c5161f1}{ns3\+::\+Epc\+Helper}.


\begin{DoxyCode}
438 \{
439   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1EmuEpcHelper_a5c68f673b82b8c80b5fb88ae986f8cea}{m\_sgwPgw};
440 \}
\end{DoxyCode}
\index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Emu\+Epc\+Helper\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1EmuEpcHelper_ac8293232dc3c4e65ef35373424ea75b2}{}\label{classns3_1_1EmuEpcHelper_ac8293232dc3c4e65ef35373424ea75b2}
Register this type. \begin{DoxyReturn}{Returns}
The object \hyperlink{classns3_1_1TypeId}{Type\+Id}. 
\end{DoxyReturn}

\begin{DoxyCode}
77 \{
78   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::EmuEpcHelper"})
79     .SetParent<\hyperlink{classns3_1_1EpcHelper_a419929e12a2c6273eb48cb766064436b}{EpcHelper}> ()
80     .SetGroupName(\textcolor{stringliteral}{"Lte"})
81     .AddConstructor<\hyperlink{classns3_1_1EmuEpcHelper_a10b42d66910c4ee73006f40eea1a1de1}{EmuEpcHelper}> ()
82     .AddAttribute (\textcolor{stringliteral}{"sgwDeviceName"}, 
83                    \textcolor{stringliteral}{"The name of the device used for the S1-U interface of the SGW"},
84                    StringValue (\textcolor{stringliteral}{"veth0"}),
85                    MakeStringAccessor (&\hyperlink{classns3_1_1EmuEpcHelper_aaf7c6410b27ea82a8fabc136801bf0d4}{EmuEpcHelper::m\_sgwDeviceName}),
86                    MakeStringChecker ())
87     .AddAttribute (\textcolor{stringliteral}{"enbDeviceName"}, 
88                    \textcolor{stringliteral}{"The name of the device used for the S1-U interface of the eNB"},
89                    StringValue (\textcolor{stringliteral}{"veth1"}),
90                    MakeStringAccessor (&\hyperlink{classns3_1_1EmuEpcHelper_a6bd1148381a5fb8d14a20673b4d50420}{EmuEpcHelper::m\_enbDeviceName}),
91                    MakeStringChecker ())
92     .AddAttribute (\textcolor{stringliteral}{"SgwMacAddress"}, 
93                    \textcolor{stringliteral}{"MAC address used for the SGW "},
94                    StringValue (\textcolor{stringliteral}{"00:00:00:59:00:aa"}),
95                    MakeStringAccessor (&\hyperlink{classns3_1_1EmuEpcHelper_abb2f5dec50c8361cb99e11c9c688bf5c}{EmuEpcHelper::m\_sgwMacAddress}),
96                    MakeStringChecker ())
97     .AddAttribute (\textcolor{stringliteral}{"EnbMacAddressBase"}, 
98                    \textcolor{stringliteral}{"First 5 bytes of the Enb MAC address base"},
99                    StringValue (\textcolor{stringliteral}{"00:00:00:eb:00"}),
100                    MakeStringAccessor (&\hyperlink{classns3_1_1EmuEpcHelper_a5958f60d6b9a984edace5ee351188e39}{EmuEpcHelper::m\_enbMacAddressBase})
      ,
101                    MakeStringChecker ())
102     .AddAttribute (\textcolor{stringliteral}{"S1apLinkDataRate"}, 
103                    \textcolor{stringliteral}{"The data rate to be used for the S1-AP link to be created"},
104                    DataRateValue (DataRate (\textcolor{stringliteral}{"10Mb/s"})),
105                    MakeDataRateAccessor (&\hyperlink{classns3_1_1EmuEpcHelper_ac0b5058393492c89ecacfe6324cdef69}{EmuEpcHelper::m\_s1apLinkDataRate})
      ,
106                    MakeDataRateChecker ())
107     .AddAttribute (\textcolor{stringliteral}{"S1apLinkDelay"}, 
108                    \textcolor{stringliteral}{"The delay to be used for the S1-AP link to be created"},
109                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (0.1)),
110                    MakeTimeAccessor (&\hyperlink{classns3_1_1EmuEpcHelper_a9e719fe27e97da61af652e8fe47640b6}{EmuEpcHelper::m\_s1apLinkDelay}),
111                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
112     .AddAttribute (\textcolor{stringliteral}{"S1apLinkMtu"}, 
113                    \textcolor{stringliteral}{"The MTU of the next S1-AP link to be created"},
114                    UintegerValue (2000),
115                    MakeUintegerAccessor (&\hyperlink{classns3_1_1EmuEpcHelper_a8ed5f99d60bfe51d3dac00c2ab445a17}{EmuEpcHelper::m\_s1apLinkMtu}),
116                    MakeUintegerChecker<uint16\_t> ())
117     ;
118   \textcolor{keywordflow}{return} tid;
119 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9


\index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!Get\+Ue\+Default\+Gateway\+Address@{Get\+Ue\+Default\+Gateway\+Address}}
\index{Get\+Ue\+Default\+Gateway\+Address@{Get\+Ue\+Default\+Gateway\+Address}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{Get\+Ue\+Default\+Gateway\+Address()}{GetUeDefaultGatewayAddress()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Address} ns3\+::\+Emu\+Epc\+Helper\+::\+Get\+Ue\+Default\+Gateway\+Address (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1EmuEpcHelper_a3bd27e33922c8053bff248c7a89f3404}{}\label{classns3_1_1EmuEpcHelper_a3bd27e33922c8053bff248c7a89f3404}
\begin{DoxyReturn}{Returns}
the address of the Default Gateway to be used by U\+Es to reach the internet 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1EpcHelper_aeec86083ad346813d44b261616333594}{ns3\+::\+Epc\+Helper}.


\begin{DoxyCode}
453 \{
454   \textcolor{comment}{// return the address of the tun device}
455   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1EmuEpcHelper_a5c68f673b82b8c80b5fb88ae986f8cea}{m\_sgwPgw}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv4> ()->GetAddress (1, 0).GetLocal ();
456 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10




\subsection{Member Data Documentation}
\index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!m\+\_\+enb\+Device\+Name@{m\+\_\+enb\+Device\+Name}}
\index{m\+\_\+enb\+Device\+Name@{m\+\_\+enb\+Device\+Name}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+enb\+Device\+Name}{m_enbDeviceName}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string ns3\+::\+Emu\+Epc\+Helper\+::m\+\_\+enb\+Device\+Name\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EmuEpcHelper_a6bd1148381a5fb8d14a20673b4d50420}{}\label{classns3_1_1EmuEpcHelper_a6bd1148381a5fb8d14a20673b4d50420}
The name of the device used for the S1-\/U interface of the e\+NB \index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!m\+\_\+enb\+Mac\+Address\+Base@{m\+\_\+enb\+Mac\+Address\+Base}}
\index{m\+\_\+enb\+Mac\+Address\+Base@{m\+\_\+enb\+Mac\+Address\+Base}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+enb\+Mac\+Address\+Base}{m_enbMacAddressBase}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string ns3\+::\+Emu\+Epc\+Helper\+::m\+\_\+enb\+Mac\+Address\+Base\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EmuEpcHelper_a5958f60d6b9a984edace5ee351188e39}{}\label{classns3_1_1EmuEpcHelper_a5958f60d6b9a984edace5ee351188e39}
First 5 bytes of the Enb M\+AC address base \index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!m\+\_\+epc\+Ipv4\+Address\+Helper@{m\+\_\+epc\+Ipv4\+Address\+Helper}}
\index{m\+\_\+epc\+Ipv4\+Address\+Helper@{m\+\_\+epc\+Ipv4\+Address\+Helper}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+epc\+Ipv4\+Address\+Helper}{m_epcIpv4AddressHelper}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Address\+Helper} ns3\+::\+Emu\+Epc\+Helper\+::m\+\_\+epc\+Ipv4\+Address\+Helper\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EmuEpcHelper_a53dccacd37ee9a31fbd739762a615c1b}{}\label{classns3_1_1EmuEpcHelper_a53dccacd37ee9a31fbd739762a615c1b}
helper to assign addresses to S1-\/U Net\+Devices \index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!m\+\_\+gtpu\+Udp\+Port@{m\+\_\+gtpu\+Udp\+Port}}
\index{m\+\_\+gtpu\+Udp\+Port@{m\+\_\+gtpu\+Udp\+Port}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+gtpu\+Udp\+Port}{m_gtpuUdpPort}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Emu\+Epc\+Helper\+::m\+\_\+gtpu\+Udp\+Port\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EmuEpcHelper_a99fe0fcbc0bd3668f30cf6ae53377a22}{}\label{classns3_1_1EmuEpcHelper_a99fe0fcbc0bd3668f30cf6ae53377a22}
U\+DP port where the G\+T\+P-\/U \hyperlink{classns3_1_1Socket}{Socket} is bound, fixed by the standard as 2152 \index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!m\+\_\+imsi\+Enb\+Device\+Map@{m\+\_\+imsi\+Enb\+Device\+Map}}
\index{m\+\_\+imsi\+Enb\+Device\+Map@{m\+\_\+imsi\+Enb\+Device\+Map}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+imsi\+Enb\+Device\+Map}{m_imsiEnbDeviceMap}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<$uint64\+\_\+t, {\bf Ptr}$<${\bf Net\+Device}$>$ $>$ ns3\+::\+Emu\+Epc\+Helper\+::m\+\_\+imsi\+Enb\+Device\+Map\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EmuEpcHelper_ac7fabf537680e203fa2456bc1854e764}{}\label{classns3_1_1EmuEpcHelper_ac7fabf537680e203fa2456bc1854e764}
Map storing for each I\+M\+SI the corresponding e\+NB \hyperlink{classns3_1_1NetDevice}{Net\+Device} \index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!m\+\_\+mme\+App@{m\+\_\+mme\+App}}
\index{m\+\_\+mme\+App@{m\+\_\+mme\+App}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+mme\+App}{m_mmeApp}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Epc\+Mme\+Application}$>$ ns3\+::\+Emu\+Epc\+Helper\+::m\+\_\+mme\+App\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EmuEpcHelper_a20264a8bd8b295161b08d09e4794f02f}{}\label{classns3_1_1EmuEpcHelper_a20264a8bd8b295161b08d09e4794f02f}
M\+ME application \index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!m\+\_\+mme\+Node@{m\+\_\+mme\+Node}}
\index{m\+\_\+mme\+Node@{m\+\_\+mme\+Node}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+mme\+Node}{m_mmeNode}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Node}$>$ ns3\+::\+Emu\+Epc\+Helper\+::m\+\_\+mme\+Node\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EmuEpcHelper_aef136870f0ad1c40d3e139f34ff9f5d1}{}\label{classns3_1_1EmuEpcHelper_aef136870f0ad1c40d3e139f34ff9f5d1}
M\+ME network element \index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!m\+\_\+s1ap\+Ipv4\+Address\+Helper@{m\+\_\+s1ap\+Ipv4\+Address\+Helper}}
\index{m\+\_\+s1ap\+Ipv4\+Address\+Helper@{m\+\_\+s1ap\+Ipv4\+Address\+Helper}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+s1ap\+Ipv4\+Address\+Helper}{m_s1apIpv4AddressHelper}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Address\+Helper} ns3\+::\+Emu\+Epc\+Helper\+::m\+\_\+s1ap\+Ipv4\+Address\+Helper\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EmuEpcHelper_af71f1e0e4c76588bf8c7565484614c08}{}\label{classns3_1_1EmuEpcHelper_af71f1e0e4c76588bf8c7565484614c08}
helper to assign addresses to S1-\/\+AP Net\+Devices \index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!m\+\_\+s1ap\+Link\+Data\+Rate@{m\+\_\+s1ap\+Link\+Data\+Rate}}
\index{m\+\_\+s1ap\+Link\+Data\+Rate@{m\+\_\+s1ap\+Link\+Data\+Rate}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+s1ap\+Link\+Data\+Rate}{m_s1apLinkDataRate}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Data\+Rate} ns3\+::\+Emu\+Epc\+Helper\+::m\+\_\+s1ap\+Link\+Data\+Rate\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EmuEpcHelper_ac0b5058393492c89ecacfe6324cdef69}{}\label{classns3_1_1EmuEpcHelper_ac0b5058393492c89ecacfe6324cdef69}
The data rate to be used for the next S1-\/\+AP link to be created \index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!m\+\_\+s1ap\+Link\+Delay@{m\+\_\+s1ap\+Link\+Delay}}
\index{m\+\_\+s1ap\+Link\+Delay@{m\+\_\+s1ap\+Link\+Delay}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+s1ap\+Link\+Delay}{m_s1apLinkDelay}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Emu\+Epc\+Helper\+::m\+\_\+s1ap\+Link\+Delay\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EmuEpcHelper_a9e719fe27e97da61af652e8fe47640b6}{}\label{classns3_1_1EmuEpcHelper_a9e719fe27e97da61af652e8fe47640b6}
The delay to be used for the next S1-\/\+AP link to be created \index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!m\+\_\+s1ap\+Link\+Mtu@{m\+\_\+s1ap\+Link\+Mtu}}
\index{m\+\_\+s1ap\+Link\+Mtu@{m\+\_\+s1ap\+Link\+Mtu}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+s1ap\+Link\+Mtu}{m_s1apLinkMtu}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Emu\+Epc\+Helper\+::m\+\_\+s1ap\+Link\+Mtu\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EmuEpcHelper_a8ed5f99d60bfe51d3dac00c2ab445a17}{}\label{classns3_1_1EmuEpcHelper_a8ed5f99d60bfe51d3dac00c2ab445a17}
The M\+TU of the next S1-\/\+AP link to be created. \index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!m\+\_\+s1ap\+Udp\+Port@{m\+\_\+s1ap\+Udp\+Port}}
\index{m\+\_\+s1ap\+Udp\+Port@{m\+\_\+s1ap\+Udp\+Port}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+s1ap\+Udp\+Port}{m_s1apUdpPort}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Emu\+Epc\+Helper\+::m\+\_\+s1ap\+Udp\+Port\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EmuEpcHelper_a40b9bb46dee69ea02ffe0722b462db8e}{}\label{classns3_1_1EmuEpcHelper_a40b9bb46dee69ea02ffe0722b462db8e}
U\+DP port where the U\+DP \hyperlink{classns3_1_1Socket}{Socket} is bound, fixed by the standard as 36412 (it should be sctp, but it is not supported in ns-\/3) \index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!m\+\_\+sgw\+Device\+Name@{m\+\_\+sgw\+Device\+Name}}
\index{m\+\_\+sgw\+Device\+Name@{m\+\_\+sgw\+Device\+Name}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+sgw\+Device\+Name}{m_sgwDeviceName}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string ns3\+::\+Emu\+Epc\+Helper\+::m\+\_\+sgw\+Device\+Name\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EmuEpcHelper_aaf7c6410b27ea82a8fabc136801bf0d4}{}\label{classns3_1_1EmuEpcHelper_aaf7c6410b27ea82a8fabc136801bf0d4}
The name of the device used for the S1-\/U interface of the S\+GW \index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!m\+\_\+sgw\+Ip\+Ifaces@{m\+\_\+sgw\+Ip\+Ifaces}}
\index{m\+\_\+sgw\+Ip\+Ifaces@{m\+\_\+sgw\+Ip\+Ifaces}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+sgw\+Ip\+Ifaces}{m_sgwIpIfaces}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Interface\+Container} ns3\+::\+Emu\+Epc\+Helper\+::m\+\_\+sgw\+Ip\+Ifaces\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EmuEpcHelper_aec4d868be3d7593b66f0e87fc59055f1}{}\label{classns3_1_1EmuEpcHelper_aec4d868be3d7593b66f0e87fc59055f1}
Container for Ipv4\+Interfaces of the S\+G\+W/\+P\+GW \index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!m\+\_\+sgw\+Mac\+Address@{m\+\_\+sgw\+Mac\+Address}}
\index{m\+\_\+sgw\+Mac\+Address@{m\+\_\+sgw\+Mac\+Address}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+sgw\+Mac\+Address}{m_sgwMacAddress}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string ns3\+::\+Emu\+Epc\+Helper\+::m\+\_\+sgw\+Mac\+Address\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EmuEpcHelper_abb2f5dec50c8361cb99e11c9c688bf5c}{}\label{classns3_1_1EmuEpcHelper_abb2f5dec50c8361cb99e11c9c688bf5c}
M\+AC address used for the S\+GW \index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!m\+\_\+sgw\+Pgw@{m\+\_\+sgw\+Pgw}}
\index{m\+\_\+sgw\+Pgw@{m\+\_\+sgw\+Pgw}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+sgw\+Pgw}{m_sgwPgw}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Node}$>$ ns3\+::\+Emu\+Epc\+Helper\+::m\+\_\+sgw\+Pgw\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EmuEpcHelper_a5c68f673b82b8c80b5fb88ae986f8cea}{}\label{classns3_1_1EmuEpcHelper_a5c68f673b82b8c80b5fb88ae986f8cea}
S\+G\+W-\/\+P\+GW network element \index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!m\+\_\+sgw\+Pgw\+App@{m\+\_\+sgw\+Pgw\+App}}
\index{m\+\_\+sgw\+Pgw\+App@{m\+\_\+sgw\+Pgw\+App}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+sgw\+Pgw\+App}{m_sgwPgwApp}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Epc\+Sgw\+Pgw\+Application}$>$ ns3\+::\+Emu\+Epc\+Helper\+::m\+\_\+sgw\+Pgw\+App\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EmuEpcHelper_a9f3619ec9e8725d4fbb9794a4f21aaa4}{}\label{classns3_1_1EmuEpcHelper_a9f3619ec9e8725d4fbb9794a4f21aaa4}
S\+G\+W-\/\+P\+GW application \index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!m\+\_\+tun\+Device@{m\+\_\+tun\+Device}}
\index{m\+\_\+tun\+Device@{m\+\_\+tun\+Device}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+tun\+Device}{m_tunDevice}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Virtual\+Net\+Device}$>$ ns3\+::\+Emu\+Epc\+Helper\+::m\+\_\+tun\+Device\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EmuEpcHelper_ababd4c0bb2cb44e0194c852e6411b501}{}\label{classns3_1_1EmuEpcHelper_ababd4c0bb2cb44e0194c852e6411b501}
T\+UN device implementing tunneling of user data over G\+T\+P-\/\+U/\+U\+D\+P/\+IP \index{ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}!m\+\_\+ue\+Address\+Helper@{m\+\_\+ue\+Address\+Helper}}
\index{m\+\_\+ue\+Address\+Helper@{m\+\_\+ue\+Address\+Helper}!ns3\+::\+Emu\+Epc\+Helper@{ns3\+::\+Emu\+Epc\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+ue\+Address\+Helper}{m_ueAddressHelper}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Address\+Helper} ns3\+::\+Emu\+Epc\+Helper\+::m\+\_\+ue\+Address\+Helper\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1EmuEpcHelper_ab57fc887c64c3f3aec6516957a84275d}{}\label{classns3_1_1EmuEpcHelper_ab57fc887c64c3f3aec6516957a84275d}
helper to assign addresses to UE devices as well as to the T\+UN device of the S\+G\+W/\+P\+GW 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
lte/helper/\hyperlink{emu-epc-helper_8h}{emu-\/epc-\/helper.\+h}\item 
lte/helper/\hyperlink{emu-epc-helper_8cc}{emu-\/epc-\/helper.\+cc}\end{DoxyCompactItemize}
