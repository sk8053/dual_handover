\hypertarget{classns3_1_1TcpTxBuffer}{}\section{ns3\+:\+:Tcp\+Tx\+Buffer Class Reference}
\label{classns3_1_1TcpTxBuffer}\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}


Tcp sender buffer.  




{\ttfamily \#include $<$tcp-\/tx-\/buffer.\+h$>$}



Inheritance diagram for ns3\+:\+:Tcp\+Tx\+Buffer\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Tcp\+Tx\+Buffer\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1TcpTxBuffer_afdb96487c75ba8447e475d0489ded790}{Tcp\+Tx\+Buffer} (uint32\+\_\+t \hyperlink{lte__link__budget__x2__handover__measures_8m_abdb05bc5a064cf642a06c83b3392f148}{n}=0)
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1TcpTxBuffer_a6175cedf45be31fdf72c0a2e16e804f5}{$\sim$\+Tcp\+Tx\+Buffer} (void)
\item 
\hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{Sequence\+Number32} \hyperlink{classns3_1_1TcpTxBuffer_a6c7cdcf53b722f2877372bd75a1541a7}{Head\+Sequence} (void) const 
\begin{DoxyCompactList}\small\item\em Get the sequence number of the buffer head. \end{DoxyCompactList}\item 
\hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{Sequence\+Number32} \hyperlink{classns3_1_1TcpTxBuffer_a1c2dbb57cd4581054e57ee8ae0cbfb06}{Tail\+Sequence} (void) const 
\begin{DoxyCompactList}\small\item\em Get the sequence number of the buffer tail (plus one) \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1TcpTxBuffer_a24621b9d6f583bbbe4567b239901176b}{Size} (void) const 
\begin{DoxyCompactList}\small\item\em Returns total number of bytes in this buffer. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1TcpTxBuffer_ac31145a6c4f814d5ddb95ab1c3bce972}{Max\+Buffer\+Size} (void) const 
\begin{DoxyCompactList}\small\item\em Get the maximum buffer size. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1TcpTxBuffer_acfcca2382edeeefb01f39369585b5d6b}{Set\+Max\+Buffer\+Size} (uint32\+\_\+t \hyperlink{lte__link__budget__x2__handover__measures_8m_abdb05bc5a064cf642a06c83b3392f148}{n})
\begin{DoxyCompactList}\small\item\em Set the maximum buffer size. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1TcpTxBuffer_a6063c2b280533f8e640296e6d0204ba2}{Available} (void) const 
\begin{DoxyCompactList}\small\item\em Returns the available capacity of this buffer. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1TcpTxBuffer_a275d96f2c58333c9e7c5fe0f1fa152e1}{Add} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p})
\begin{DoxyCompactList}\small\item\em Append a data packet to the end of the buffer. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1TcpTxBuffer_a6e44c34fdb2c14dcc11dbbe86d8b328a}{Size\+From\+Sequence} (const \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{Sequence\+Number32} \&seq) const 
\begin{DoxyCompactList}\small\item\em Returns the number of bytes from the buffer in the range \mbox{[}seq, tail\+Sequence) \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{classns3_1_1TcpTxBuffer_a5eb9c889cfad2cd11a5ccf996c506fd3}{Copy\+From\+Sequence} (uint32\+\_\+t num\+Bytes, const \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{Sequence\+Number32} \&seq)
\begin{DoxyCompactList}\small\item\em Copy data from the range \mbox{[}seq, seq+num\+Bytes) into a packet. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1TcpTxBuffer_ae9d25292f14d338abe26a2657e103921}{Set\+Head\+Sequence} (const \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{Sequence\+Number32} \&seq)
\begin{DoxyCompactList}\small\item\em Set the head sequence of the buffer. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1TcpTxBuffer_ad145a6de0122b3400fcbbff030d2acea}{Discard\+Up\+To} (const \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{Sequence\+Number32} \&seq)
\begin{DoxyCompactList}\small\item\em Discard data up to but not including this sequence number. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1TcpTxBuffer_abed2d31821b2d946068c517195f5cc61}{Update} (const \hyperlink{classns3_1_1TcpOptionSack_a2aa2d721c71424680d79ebaa079f264a}{Tcp\+Option\+Sack\+::\+Sack\+List} \&\hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{list})
\begin{DoxyCompactList}\small\item\em Update the scoreboard. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1TcpTxBuffer_add55043ebbafc30ba4e48d3f8aa9f064}{Is\+Lost} (const \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{Sequence\+Number32} \&seq, uint32\+\_\+t dup\+Thresh, uint32\+\_\+t segment\+Size) const 
\begin{DoxyCompactList}\small\item\em Check if a segment is lost per R\+FC 6675. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1TcpTxBuffer_ad08eadd0ba92849a4c4a6920b72acb69}{Next\+Seg} (\hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{Sequence\+Number32} $\ast$seq, uint32\+\_\+t dup\+Thresh, uint32\+\_\+t segment\+Size, bool is\+Recovery) const 
\begin{DoxyCompactList}\small\item\em Get the next sequence number to transmit, according to R\+FC 6675. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1TcpTxBuffer_a4c14562ad63e699927b3def1c1c12efa}{Bytes\+In\+Flight} (uint32\+\_\+t dup\+Thresh, uint32\+\_\+t segment\+Size) const 
\begin{DoxyCompactList}\small\item\em Return total bytes in flight. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1TcpTxBuffer_ae8f6a815193ad7280815a70b91aac72f}{Set\+Sent\+List\+Lost} ()
\begin{DoxyCompactList}\small\item\em Set the entire sent list as lost (typically after an R\+TO) \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1TcpTxBuffer_a6548f4b2cb53c40743988747229bd4ac}{Reset\+Scoreboard} ()
\begin{DoxyCompactList}\small\item\em Reset the Scoreboard from all S\+A\+CK informations. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1TcpTxBuffer_a547705cacaea905c9c3831225f17872b}{Is\+Head\+Retransmitted} () const 
\begin{DoxyCompactList}\small\item\em Check if the head is retransmitted. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1TcpTxBuffer_acefebd565120f38dfaec17264443eef9}{Reset\+Sent\+List} ()
\begin{DoxyCompactList}\small\item\em Reset the sent list. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1TcpTxBuffer_a61f519ff65cbadfb81099f866f1722f0}{Reset\+Last\+Segment\+Sent} ()
\begin{DoxyCompactList}\small\item\em Take the last segment sent and put it back into the un-\/sent list (at the beginning) \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1TcpOptionSack}{Tcp\+Option\+Sack} $>$ \hyperlink{classns3_1_1TcpTxBuffer_af49d6395ebebed5e4ca8697e7331b79e}{Craft\+Sack\+Option} (const \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{Sequence\+Number32} \&seq, uint8\+\_\+t available) const 
\begin{DoxyCompactList}\small\item\em Craft a S\+A\+CK block. Used in case the other end does not support S\+A\+CK. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1TcpTxBuffer_a0e303ee2cabca6bf9785ddac2a0fb392}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1TcpTxItem}{Tcp\+Tx\+Item} $\ast$ $>$ \hyperlink{classns3_1_1TcpTxBuffer_a4abe4f4a277dc558fb81c87ca71d5982}{Packet\+List}
\begin{DoxyCompactList}\small\item\em container for data stored in the buffer \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classns3_1_1TcpTxBuffer_abef1df59556801517ac6f99c3bf135cf}{Is\+Lost} (const \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{Sequence\+Number32} \&seq, const Packet\+List\+::const\+\_\+iterator \&segment, uint32\+\_\+t dup\+Thresh, uint32\+\_\+t segment\+Size) const 
\begin{DoxyCompactList}\small\item\em Check if a segment is lost per R\+FC 6675. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TcpTxItem}{Tcp\+Tx\+Item} $\ast$ \hyperlink{classns3_1_1TcpTxBuffer_a7f8012f60263f1184f63d68f95d9fed6}{Get\+New\+Segment} (uint32\+\_\+t num\+Bytes)
\begin{DoxyCompactList}\small\item\em Get a block of data not transmitted yet and move it into Sent\+List. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TcpTxItem}{Tcp\+Tx\+Item} $\ast$ \hyperlink{classns3_1_1TcpTxBuffer_a4de9715c65893a5cb8a869e72ed7bb10}{Get\+Transmitted\+Segment} (uint32\+\_\+t num\+Bytes, const \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{Sequence\+Number32} \&seq)
\begin{DoxyCompactList}\small\item\em Get a block of data previously transmitted. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TcpTxItem}{Tcp\+Tx\+Item} $\ast$ \hyperlink{classns3_1_1TcpTxBuffer_a0528a0261fe39fdb95526c24801f1091}{Get\+Packet\+From\+List} (\hyperlink{classns3_1_1TcpTxBuffer_a4abe4f4a277dc558fb81c87ca71d5982}{Packet\+List} \&\hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{list}, const \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{Sequence\+Number32} \&starting\+Seq, uint32\+\_\+t num\+Bytes, const \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{Sequence\+Number32} \&requested\+Seq, bool $\ast$list\+Edited) const 
\begin{DoxyCompactList}\small\item\em Get a block (which is returned as \hyperlink{classns3_1_1Packet}{Packet}) from a list. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1TcpTxBuffer_aee57c32104926f7d4bfdeb12f05a6db1}{Merge\+Items} (\hyperlink{classns3_1_1TcpTxItem}{Tcp\+Tx\+Item} \&t1, \hyperlink{classns3_1_1TcpTxItem}{Tcp\+Tx\+Item} \&t2) const 
\begin{DoxyCompactList}\small\item\em Merge two \hyperlink{classns3_1_1TcpTxItem}{Tcp\+Tx\+Item}. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1TcpTxBuffer_a34d85565e5a51b10a33444ed47415f2f}{Split\+Items} (\hyperlink{classns3_1_1TcpTxItem}{Tcp\+Tx\+Item} \&t1, \hyperlink{classns3_1_1TcpTxItem}{Tcp\+Tx\+Item} \&t2, uint32\+\_\+t size) const 
\begin{DoxyCompactList}\small\item\em Split one \hyperlink{classns3_1_1TcpTxItem}{Tcp\+Tx\+Item}. \end{DoxyCompactList}\item 
std\+::pair$<$ Tcp\+Tx\+Buffer\+::\+Packet\+List\+::const\+\_\+iterator, \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{Sequence\+Number32} $>$ \hyperlink{classns3_1_1TcpTxBuffer_a6c411d008d8905f81ea087566f0b473b}{Get\+Highest\+Sacked} () const 
\begin{DoxyCompactList}\small\item\em Find the highest S\+A\+CK byte. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1TcpTxBuffer_a4abe4f4a277dc558fb81c87ca71d5982}{Packet\+List} \hyperlink{classns3_1_1TcpTxBuffer_ac85673c102b50188282a70152cc542ca}{m\+\_\+app\+List}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Buffer}{Buffer} for application data. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TcpTxBuffer_a4abe4f4a277dc558fb81c87ca71d5982}{Packet\+List} \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\+\_\+sent\+List}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Buffer}{Buffer} for sent (but not acked) data. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1TcpTxBuffer_a4e661fb54fabfe319c6fc15f7080526f}{m\+\_\+max\+Buffer}
\begin{DoxyCompactList}\small\item\em Max number of data bytes in buffer (S\+N\+D.\+W\+ND) \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1TcpTxBuffer_ace81d07d65ea00d9609dcc65a926564c}{m\+\_\+size}
\begin{DoxyCompactList}\small\item\em Size of all data in this buffer. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1TcpTxBuffer_ae45302ec0a3b3d757b0f3ad85e88e363}{m\+\_\+sent\+Size}
\begin{DoxyCompactList}\small\item\em Size of sent (and not discarded) segments. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedValue}{Traced\+Value}$<$ \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{Sequence\+Number32} $>$ \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\+\_\+first\+Byte\+Seq}
\begin{DoxyCompactList}\small\item\em Sequence number of the first byte in data (S\+N\+D.\+U\+NA) \end{DoxyCompactList}\item 
std\+::pair$<$ Packet\+List\+::const\+\_\+iterator, \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{Sequence\+Number32} $>$ \hyperlink{classns3_1_1TcpTxBuffer_a224ded405afbf30d8828c8ddd16b29d9}{m\+\_\+highest\+Sack}
\begin{DoxyCompactList}\small\item\em Highest S\+A\+CK byte. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
std\+::ostream \& \hyperlink{classns3_1_1TcpTxBuffer_ac79ac25be6b4aef60bb3fdb7b6c64528}{operator$<$$<$} (std\+::ostream \&os, \hyperlink{classns3_1_1TcpTxBuffer}{Tcp\+Tx\+Buffer} const \&tcp\+Tx\+Buf)
\begin{DoxyCompactList}\small\item\em Output operator. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Tcp sender buffer. 

The class keeps track of all data that the application wishes to transmit to the other end. When the data is acknowledged, it is removed from the buffer. The buffer has a maximum size, and data is not saved if the amount exceeds the limit. Packets can be added to the class through the method \hyperlink{classns3_1_1TcpTxBuffer_a275d96f2c58333c9e7c5fe0f1fa152e1}{Add()}. An important thing to remember is that all the data managed is strictly sequential. It can be divided into blocks, but all the data follow a strict ordering. That order is managed through \hyperlink{classns3_1_1SequenceNumber}{Sequence\+Number}.

In other words, this buffer contains numbered bytes (e.\+g., 1,2,3), and the class is allowed to return only ordered (using \char`\"{}$<$\char`\"{} as operator) subsets (e.\+g. 1,2 or 2,3 or 1,2,3).

The data structure underlying this is composed by two distinct packet lists. The first (Sent\+List) is initially empty, and it contains the packets returned by the method Copy\+From\+Sequence. The second (App\+List) is initially empty, and it contains the packets coming from the applications, but that are not transmitted yet as segments. To discover how the chunks are managed and retrieved from these lists, check Copy\+From\+Sequence documentation.

The head of the data is represented by m\+\_\+first\+Byte\+Seq, and it is returned by \hyperlink{classns3_1_1TcpTxBuffer_a6c7cdcf53b722f2877372bd75a1541a7}{Head\+Sequence()}. The last byte is returned by \hyperlink{classns3_1_1TcpTxBuffer_a1c2dbb57cd4581054e57ee8ae0cbfb06}{Tail\+Sequence()}. In this class, we also store the size (in bytes) of the packets inside the Sent\+List in the variable m\+\_\+sent\+Size.

\subsubsection*{S\+A\+CK management }

The S\+A\+CK information is usually saved in a data structure referred as scoreboard. In this implementation, the scoreboard is developed on top of the existing classes. In particular, instead of keeping raw pointers to packets in \hyperlink{classns3_1_1TcpTxBuffer}{Tcp\+Tx\+Buffer} we added the capability to store some flags associated with every segment sent. This is done through the use of the class \hyperlink{classns3_1_1TcpTxItem}{Tcp\+Tx\+Item}\+: instead of storing a list of packets, we store a list of \hyperlink{classns3_1_1TcpTxItem}{Tcp\+Tx\+Item}. Each item has different flags (check the corresponding documentation) and maintaining the scoreboard is a matter of travelling the list and set the S\+A\+CK flag on the corresponding segment sent.

\subsubsection*{Inefficiencies }

The algorithms outlined in R\+FC 6675 are full of inefficiencies. In particular, traveling all the sent list each time it is needed to compute the bytes in flight is expensive. We try to overcome the issue by maintaining a pointer to the highest sequence S\+A\+C\+Ked; in this way, we can avoid traveling all the list in some cases. Another option could be keeping a count of each critical value (e.\+g., the number of packets sacked). However, this would be different from the algorithms in R\+FC. There are some other possible improvements; if you wish, take a look and try to add some earlier exit conditions in the loops.

\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1TcpTxBuffer_a24621b9d6f583bbbe4567b239901176b}{Size} 

\hyperlink{classns3_1_1TcpTxBuffer_a6e44c34fdb2c14dcc11dbbe86d8b328a}{Size\+From\+Sequence} 

\hyperlink{classns3_1_1TcpTxBuffer_a5eb9c889cfad2cd11a5ccf996c506fd3}{Copy\+From\+Sequence} 
\end{DoxySeeAlso}


\subsection{Member Typedef Documentation}
\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Packet\+List@{Packet\+List}}
\index{Packet\+List@{Packet\+List}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Packet\+List}{PacketList}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Tcp\+Tx\+Item}$\ast$$>$ {\bf ns3\+::\+Tcp\+Tx\+Buffer\+::\+Packet\+List}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpTxBuffer_a4abe4f4a277dc558fb81c87ca71d5982}{}\label{classns3_1_1TcpTxBuffer_a4abe4f4a277dc558fb81c87ca71d5982}


container for data stored in the buffer 



\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Tcp\+Tx\+Buffer@{Tcp\+Tx\+Buffer}}
\index{Tcp\+Tx\+Buffer@{Tcp\+Tx\+Buffer}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Tcp\+Tx\+Buffer(uint32\+\_\+t n=0)}{TcpTxBuffer(uint32_t n=0)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Tcp\+Tx\+Buffer\+::\+Tcp\+Tx\+Buffer (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{n = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpTxBuffer_afdb96487c75ba8447e475d0489ded790}{}\label{classns3_1_1TcpTxBuffer_afdb96487c75ba8447e475d0489ded790}


Constructor. 


\begin{DoxyParams}{Parameters}
{\em n} & initial Sequence number to be transmitted \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
115   : \hyperlink{classns3_1_1TcpTxBuffer_a4e661fb54fabfe319c6fc15f7080526f}{m\_maxBuffer} (32768), \hyperlink{classns3_1_1TcpTxBuffer_ace81d07d65ea00d9609dcc65a926564c}{m\_size} (0), \hyperlink{classns3_1_1TcpTxBuffer_ae45302ec0a3b3d757b0f3ad85e88e363}{m\_sentSize} (0), 
      \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq} (\hyperlink{namespacesample-rng-plot_aeb5ee5c431e338ef39b7ac5431242e1d}{n})
116 \{
117 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!````~Tcp\+Tx\+Buffer@{$\sim$\+Tcp\+Tx\+Buffer}}
\index{````~Tcp\+Tx\+Buffer@{$\sim$\+Tcp\+Tx\+Buffer}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{$\sim$\+Tcp\+Tx\+Buffer(void)}{~TcpTxBuffer(void)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Tcp\+Tx\+Buffer\+::$\sim$\+Tcp\+Tx\+Buffer (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TcpTxBuffer_a6175cedf45be31fdf72c0a2e16e804f5}{}\label{classns3_1_1TcpTxBuffer_a6175cedf45be31fdf72c0a2e16e804f5}

\begin{DoxyCode}
120 \{
121   PacketList::iterator it;
122 
123   \textcolor{keywordflow}{for} (it = \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.begin (); it != \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.end (); ++it)
124     \{
125       TcpTxItem *item = *it;
126       \hyperlink{classns3_1_1TcpTxBuffer_ae45302ec0a3b3d757b0f3ad85e88e363}{m\_sentSize} -= item->m\_packet->GetSize ();
127       \textcolor{keyword}{delete} item;
128     \}
129 
130   \textcolor{keywordflow}{for} (it = \hyperlink{classns3_1_1TcpTxBuffer_ac85673c102b50188282a70152cc542ca}{m\_appList}.begin (); it != \hyperlink{classns3_1_1TcpTxBuffer_ac85673c102b50188282a70152cc542ca}{m\_appList}.end (); ++it)
131     \{
132       TcpTxItem *item = *it;
133       \hyperlink{classns3_1_1TcpTxBuffer_ace81d07d65ea00d9609dcc65a926564c}{m\_size} -= item->m\_packet->GetSize ();
134       \textcolor{keyword}{delete} item;
135     \}
136 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2




\subsection{Member Function Documentation}
\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Add@{Add}}
\index{Add@{Add}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Add(\+Ptr$<$ Packet $>$ p)}{Add(Ptr< Packet > p)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Tcp\+Tx\+Buffer\+::\+Add (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpTxBuffer_a275d96f2c58333c9e7c5fe0f1fa152e1}{}\label{classns3_1_1TcpTxBuffer_a275d96f2c58333c9e7c5fe0f1fa152e1}


Append a data packet to the end of the buffer. 


\begin{DoxyParams}{Parameters}
{\em p} & The packet to be appended to the Tx buffer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Boolean to indicate success 
\end{DoxyReturn}

\begin{DoxyCode}
187 \{
188   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << p);
189   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Try to append "} << p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} () << \textcolor{stringliteral}{" bytes to window starting at "}
190                                 << \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq} << \textcolor{stringliteral}{", availSize="} << 
      \hyperlink{classns3_1_1TcpTxBuffer_a6063c2b280533f8e640296e6d0204ba2}{Available} ());
191   \textcolor{keywordflow}{if} (p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} () <= \hyperlink{classns3_1_1TcpTxBuffer_a6063c2b280533f8e640296e6d0204ba2}{Available} ())
192     \{
193       \textcolor{keywordflow}{if} (p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} () > 0)
194         \{
195           TcpTxItem *item = \textcolor{keyword}{new} TcpTxItem ();
196           item->m\_packet = \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p};
197           \hyperlink{classns3_1_1TcpTxBuffer_ac85673c102b50188282a70152cc542ca}{m\_appList}.insert (\hyperlink{classns3_1_1TcpTxBuffer_ac85673c102b50188282a70152cc542ca}{m\_appList}.end (), item);
198           \hyperlink{classns3_1_1TcpTxBuffer_ace81d07d65ea00d9609dcc65a926564c}{m\_size} += p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ();
199 
200           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Updated size="} << \hyperlink{classns3_1_1TcpTxBuffer_ace81d07d65ea00d9609dcc65a926564c}{m\_size} << \textcolor{stringliteral}{", lastSeq="} <<
201                        \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq} + \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} (
      \hyperlink{classns3_1_1TcpTxBuffer_ace81d07d65ea00d9609dcc65a926564c}{m\_size}));
202         \}
203       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
204     \}
205   \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Rejected. Not enough room to buffer packet."});
206   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
207 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3




Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Available@{Available}}
\index{Available@{Available}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Available(void) const }{Available(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Tcp\+Tx\+Buffer\+::\+Available (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1TcpTxBuffer_a6063c2b280533f8e640296e6d0204ba2}{}\label{classns3_1_1TcpTxBuffer_a6063c2b280533f8e640296e6d0204ba2}


Returns the available capacity of this buffer. 

\begin{DoxyReturn}{Returns}
available capacity in this Tx window 
\end{DoxyReturn}

\begin{DoxyCode}
170 \{
171   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpTxBuffer_a4e661fb54fabfe319c6fc15f7080526f}{m\_maxBuffer} - \hyperlink{classns3_1_1TcpTxBuffer_ace81d07d65ea00d9609dcc65a926564c}{m\_size};
172 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Bytes\+In\+Flight@{Bytes\+In\+Flight}}
\index{Bytes\+In\+Flight@{Bytes\+In\+Flight}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Bytes\+In\+Flight(uint32\+\_\+t dup\+Thresh, uint32\+\_\+t segment\+Size) const }{BytesInFlight(uint32_t dupThresh, uint32_t segmentSize) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Tcp\+Tx\+Buffer\+::\+Bytes\+In\+Flight (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{dup\+Thresh, }
\item[{uint32\+\_\+t}]{segment\+Size}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1TcpTxBuffer_a4c14562ad63e699927b3def1c1c12efa}{}\label{classns3_1_1TcpTxBuffer_a4c14562ad63e699927b3def1c1c12efa}


Return total bytes in flight. 

The routine follows the \char`\"{}\+Set\+Pipe\char`\"{} function in R\+FC 6675


\begin{DoxyParams}{Parameters}
{\em dup\+Thresh} & duplicate A\+CK threshold \\
\hline
{\em segment\+Size} & segment size \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
total bytes in flight 
\end{DoxyReturn}

\begin{DoxyCode}
959 \{
960   PacketList::const\_iterator it;
961   TcpTxItem *item;
962   uint32\_t size = 0; \textcolor{comment}{// "pipe" in RFC}
963   \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} beginOfCurrentPkt = \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq};
964 
965   \textcolor{comment}{// After initializing pipe to zero, the following steps are taken for each}
966   \textcolor{comment}{// octet 'S1' in the sequence space between HighACK and HighData that has not}
967   \textcolor{comment}{// been SACKed:}
968   \textcolor{comment}{/*for (it = m\_sentList.begin (); it != m\_sentList.end (); ++it)}
969 \textcolor{comment}{    \{}
970 \textcolor{comment}{      item = *it;}
971 \textcolor{comment}{      if (!item->m\_sacked)}
972 \textcolor{comment}{        \{}
973 \textcolor{comment}{          // (a) If IsLost (S1) returns false: Pipe is incremented by 1 octet.}
974 \textcolor{comment}{          if (!IsLost (beginOfCurrentPkt, it, dupThresh, segmentSize))}
975 \textcolor{comment}{            \{}
976 \textcolor{comment}{              size += item->m\_packet->GetSize ();}
977 \textcolor{comment}{            \}}
978 \textcolor{comment}{          // (b) If S1 <= HighRxt: Pipe is incremented by 1 octet.}
979 \textcolor{comment}{          // (NOTE: we use the m\_retrans flag instead of keeping and updating}
980 \textcolor{comment}{          // another variable). Only if the item is not marked as lost}
981 \textcolor{comment}{          else if (item->m\_retrans && !item->m\_lost)}
982 \textcolor{comment}{            \{}
983 \textcolor{comment}{              size += item->m\_packet->GetSize ();}
984 \textcolor{comment}{            \}}
985 \textcolor{comment}{        \}}
986 \textcolor{comment}{      beginOfCurrentPkt += item->m\_packet->GetSize ();}
987 \textcolor{comment}{    \}*/}
988   \textcolor{keywordtype}{bool} noLoss = \textcolor{keyword}{false};
989   \textcolor{keywordflow}{for} (it = \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.begin (); it != \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.end (); ++it)
990     \{
991       item = *it;
992       \textcolor{keywordflow}{if} (!item->m\_sacked)
993         \{
994           \textcolor{keywordflow}{if}(noLoss == \textcolor{keyword}{false})
995           \{
996           \textcolor{comment}{// (a) If IsLost (S1) returns false: Pipe is incremented by 1 octet.}
997           \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1TcpTxBuffer_add55043ebbafc30ba4e48d3f8aa9f064}{IsLost} (beginOfCurrentPkt, it, dupThresh, segmentSize))
998             \{
999                   noLoss = \textcolor{keyword}{true};
1000               size += item->m\_packet->GetSize ();
1001             \}
1002           \textcolor{comment}{// (b) If S1 <= HighRxt: Pipe is incremented by 1 octet.}
1003           \textcolor{comment}{// (NOTE: we use the m\_retrans flag instead of keeping and updating}
1004           \textcolor{comment}{// another variable). Only if the item is not marked as lost}
1005           \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (item->m\_retrans && !item->m\_lost)
1006             \{
1007               size += item->m\_packet->GetSize ();
1008             \}
1009           \}
1010           \textcolor{keywordflow}{else}
1011           \{
1012               \textcolor{keywordflow}{if} (!item->m\_lost)
1013                 \{
1014                   size += item->m\_packet->GetSize ();
1015                 \}
1016           \}
1017         \}
1018       beginOfCurrentPkt += item->m\_packet->GetSize ();
1019     \}
1020 
1021   \textcolor{keywordflow}{return} size;
1022 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6


\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Copy\+From\+Sequence@{Copy\+From\+Sequence}}
\index{Copy\+From\+Sequence@{Copy\+From\+Sequence}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Copy\+From\+Sequence(uint32\+\_\+t num\+Bytes, const Sequence\+Number32 \&seq)}{CopyFromSequence(uint32_t numBytes, const SequenceNumber32 &seq)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Packet} $>$ ns3\+::\+Tcp\+Tx\+Buffer\+::\+Copy\+From\+Sequence (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{num\+Bytes, }
\item[{const {\bf Sequence\+Number32} \&}]{seq}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpTxBuffer_a5eb9c889cfad2cd11a5ccf996c506fd3}{}\label{classns3_1_1TcpTxBuffer_a5eb9c889cfad2cd11a5ccf996c506fd3}


Copy data from the range \mbox{[}seq, seq+num\+Bytes) into a packet. 

In the following, we refer to the block \mbox{[}seq, seq+num\+Bytes) simply as \char`\"{}block\char`\"{}. We check the boundary of the block, and divide the possibilities in three cases\+:


\begin{DoxyItemize}
\item the block have already been transmitted (managed in Get\+Transmitted\+Segment)
\item the block have not been transmitted yet (managed in Get\+New\+Segment)
\end{DoxyItemize}

The last case is when the block is partially transmitted and partially not transmitted. We trick this case by requesting the portion not transmitted from Get\+New\+Segment, and then calling Get\+Transmitted\+Segment with the full block range.


\begin{DoxyParams}{Parameters}
{\em num\+Bytes} & number of bytes to copy \\
\hline
{\em seq} & start sequence number to extract \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a packet 
\end{DoxyReturn}

\begin{DoxyCode}
228 \{
229   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (*\textcolor{keyword}{this} << numBytes << seq);
230 
231   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq} > seq)
232     \{
233       \hyperlink{group__logging_ga0261a8db1d4ac5f79417d117634fd455}{NS\_LOG\_ERROR} (\textcolor{stringliteral}{"Requested a sequence number which is not in the buffer anymore"});
234       \textcolor{keywordflow}{return} Create<Packet> ();
235     \}
236 
237   \textcolor{comment}{// Real size to extract. Insure not beyond end of data}
238   uint32\_t \hyperlink{generate__test__data__lte__sinr_8m_ad83eeb3a142285d1243a08c6b7026df8}{s} = \hyperlink{80211b_8c_ac6afabdc09a49a433ee19d8a9486056d}{std::min} (numBytes, \hyperlink{classns3_1_1TcpTxBuffer_a6e44c34fdb2c14dcc11dbbe86d8b328a}{SizeFromSequence} (seq));
239 
240   \textcolor{keywordflow}{if} (s == 0)
241     \{
242       \textcolor{keywordflow}{return} Create<Packet> ();
243     \}
244 
245   TcpTxItem *outItem = 0;
246 
247   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq} + \hyperlink{classns3_1_1TcpTxBuffer_ae45302ec0a3b3d757b0f3ad85e88e363}{m\_sentSize} >= seq + s)
248     \{
249       \textcolor{comment}{// already sent this block completely}
250       outItem = \hyperlink{classns3_1_1TcpTxBuffer_a4de9715c65893a5cb8a869e72ed7bb10}{GetTransmittedSegment} (s, seq);
251       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (outItem != 0);
252       outItem->m\_retrans = \textcolor{keyword}{true};
253 
254       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Retransmitting ["} << seq << \textcolor{stringliteral}{";"} << seq + s << \textcolor{stringliteral}{"|"} << s <<
255                     \textcolor{stringliteral}{"] from "} << *\textcolor{keyword}{this});
256     \}
257   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq} + \hyperlink{classns3_1_1TcpTxBuffer_ae45302ec0a3b3d757b0f3ad85e88e363}{m\_sentSize} <= seq)
258     \{
259       \hyperlink{group__fatal_ga0bd3f62c55e7347ff814572f3aaa3864}{NS\_ABORT\_MSG\_UNLESS} (\hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq} + 
      \hyperlink{classns3_1_1TcpTxBuffer_ae45302ec0a3b3d757b0f3ad85e88e363}{m\_sentSize} == seq,
260                            \textcolor{stringliteral}{"Requesting a piece of new data with an hole"});
261 
262       \textcolor{comment}{// this is the first time we transmit this block}
263       outItem = \hyperlink{classns3_1_1TcpTxBuffer_a7f8012f60263f1184f63d68f95d9fed6}{GetNewSegment} (s);
264       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (outItem != 0);
265       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (outItem->m\_retrans == \textcolor{keyword}{false});
266 
267       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"New segment ["} << seq << \textcolor{stringliteral}{";"} << seq + s << \textcolor{stringliteral}{"|"} << s <<
268                     \textcolor{stringliteral}{"] from "} << *\textcolor{keyword}{this});
269     \}
270   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq} + \hyperlink{classns3_1_1TcpTxBuffer_ae45302ec0a3b3d757b0f3ad85e88e363}{m\_sentSize} > seq && 
      \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq} + \hyperlink{classns3_1_1TcpTxBuffer_ae45302ec0a3b3d757b0f3ad85e88e363}{m\_sentSize} < seq + s)
271     \{
272       \textcolor{comment}{// Partial: a part is retransmission, the remaining data is new}
273 
274       \textcolor{comment}{// Take the new data and move it into sent list}
275       uint32\_t amount = seq + s - \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq}.\hyperlink{classns3_1_1TracedValue_a10fddd1de961ac65acfbeb440a1e8551}{Get} () - 
      \hyperlink{classns3_1_1TcpTxBuffer_ae45302ec0a3b3d757b0f3ad85e88e363}{m\_sentSize};
276       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Moving segment ["} << \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq} + 
      \hyperlink{classns3_1_1TcpTxBuffer_ae45302ec0a3b3d757b0f3ad85e88e363}{m\_sentSize} << \textcolor{stringliteral}{";"} <<
277                     \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq} + \hyperlink{classns3_1_1TcpTxBuffer_ae45302ec0a3b3d757b0f3ad85e88e363}{m\_sentSize} + amount <<\textcolor{stringliteral}{"|"} << amount <<
278                     \textcolor{stringliteral}{"] from "} << *\textcolor{keyword}{this});
279 
280       outItem = \hyperlink{classns3_1_1TcpTxBuffer_a7f8012f60263f1184f63d68f95d9fed6}{GetNewSegment} (amount);
281       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (outItem != 0);
282 
283       \textcolor{comment}{// Now get outItem from the sent list (there will be a merge)}
284       \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpTxBuffer_a5eb9c889cfad2cd11a5ccf996c506fd3}{CopyFromSequence} (numBytes, seq);
285     \}
286 
287   outItem->m\_lost = \textcolor{keyword}{false};
288   outItem->m\_lastSent = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ();
289   Ptr<Packet> toRet = outItem->m\_packet->Copy ();
290 
291   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (toRet->GetSize () == \hyperlink{generate__test__data__lte__sinr_8m_ad83eeb3a142285d1243a08c6b7026df8}{s});
292 
293   \textcolor{keywordflow}{return} toRet;
294 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7




Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Craft\+Sack\+Option@{Craft\+Sack\+Option}}
\index{Craft\+Sack\+Option@{Craft\+Sack\+Option}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Craft\+Sack\+Option(const Sequence\+Number32 \&seq, uint8\+\_\+t available) const }{CraftSackOption(const SequenceNumber32 &seq, uint8_t available) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ const {\bf Tcp\+Option\+Sack} $>$ ns3\+::\+Tcp\+Tx\+Buffer\+::\+Craft\+Sack\+Option (
\begin{DoxyParamCaption}
\item[{const {\bf Sequence\+Number32} \&}]{seq, }
\item[{uint8\+\_\+t}]{available}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1TcpTxBuffer_af49d6395ebebed5e4ca8697e7331b79e}{}\label{classns3_1_1TcpTxBuffer_af49d6395ebebed5e4ca8697e7331b79e}


Craft a S\+A\+CK block. Used in case the other end does not support S\+A\+CK. 


\begin{DoxyParams}{Parameters}
{\em seq} & Look to usable block starting from this sequence number (seq will not be included in the block) \\
\hline
{\em available} & Space left in the header for that S\+A\+CK option \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a S\+A\+CK option that S\+A\+CK the first un-\/\+S\+A\+C\+Ked segment in our sent\+List. 
\end{DoxyReturn}

\begin{DoxyCode}
1115 \{
1116   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1117   Ptr<TcpOptionSack> sackBlock = 0;
1118   \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} beginOfCurrentPacket = \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq};
1119   Ptr<Packet> current;
1120   TcpTxItem *item;
1121 
1122   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Crafting a SACK block, available bytes: "} << (uint32\_t) available <<
1123                \textcolor{stringliteral}{" from seq: "} << seq << \textcolor{stringliteral}{" buffer starts at seq "} << 
      \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq});
1124 
1125   PacketList::const\_iterator it;
1126   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TcpTxBuffer_a224ded405afbf30d8828c8ddd16b29d9}{m\_highestSack}.first == \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.end ())
1127     \{
1128       it = \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.begin ();
1129     \}
1130   \textcolor{keywordflow}{else}
1131     \{
1132       it = \hyperlink{classns3_1_1TcpTxBuffer_a224ded405afbf30d8828c8ddd16b29d9}{m\_highestSack}.first;
1133       beginOfCurrentPacket = \hyperlink{classns3_1_1TcpTxBuffer_a224ded405afbf30d8828c8ddd16b29d9}{m\_highestSack}.second;
1134     \}
1135 
1136   \textcolor{keywordflow}{while} (it != \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.end ())
1137     \{
1138       item = *it;
1139       current = item->m\_packet;
1140 
1141       \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} endOfCurrentPacket = beginOfCurrentPacket + current->GetSize ();
1142 
1143       \textcolor{comment}{// The first segment could not be sacked.. otherwise would be a}
1144       \textcolor{comment}{// cumulative ACK :)}
1145       \textcolor{keywordflow}{if} (item->m\_sacked || it == \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.begin ())
1146         \{
1147           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Analyzing segment: ["} << beginOfCurrentPacket <<
1148                         \textcolor{stringliteral}{";"} << endOfCurrentPacket << \textcolor{stringliteral}{"], not usable, sacked="} <<
1149                         item->m\_sacked);
1150           beginOfCurrentPacket += current->GetSize ();
1151         \}
1152       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (seq > beginOfCurrentPacket)
1153         \{
1154           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Analyzing segment: ["} << beginOfCurrentPacket <<
1155                         \textcolor{stringliteral}{";"} << endOfCurrentPacket << \textcolor{stringliteral}{"], not usable, sacked="} <<
1156                         item->m\_sacked);
1157           beginOfCurrentPacket += current->GetSize ();
1158         \}
1159       \textcolor{keywordflow}{else}
1160         \{
1161           \textcolor{comment}{// RFC 2018: The first SACK block MUST specify the contiguous}
1162           \textcolor{comment}{// block of data containing the segment which triggered this ACK.}
1163           \textcolor{comment}{// Since we are hand-crafting this, select the first non-sacked block.}
1164           sackBlock = CreateObject <TcpOptionSack> ();
1165           sackBlock->AddSackBlock (\hyperlink{classns3_1_1TcpOptionSack_a9e1d07d8729fd3ac5ead7305794675c3}{TcpOptionSack::SackBlock} (beginOfCurrentPacket,
1166                                                              endOfCurrentPacket));
1167           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Analyzing segment: ["} << beginOfCurrentPacket <<
1168                         \textcolor{stringliteral}{";"} << endOfCurrentPacket << \textcolor{stringliteral}{"] and found to be usable"});
1169 
1170           \textcolor{comment}{// RFC 2018: The data receiver SHOULD include as many distinct SACK}
1171           \textcolor{comment}{// blocks as possible in the SACK option}
1172           \textcolor{comment}{// The SACK option SHOULD be filled out by repeating the most}
1173           \textcolor{comment}{// recently reported SACK blocks  that are not subsets of a SACK block}
1174           \textcolor{comment}{// already included}
1175           \textcolor{comment}{// This means go backward until we finish space and include already SACKed block}
1176           \textcolor{keywordflow}{while} (sackBlock->GetSerializedSize () + 8 < available)
1177             \{
1178               --it;
1179 
1180               \textcolor{keywordflow}{if} (it == \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.begin ())
1181                 \{
1182                   \textcolor{keywordflow}{return} sackBlock;
1183                 \}
1184 
1185               item = *it;
1186               current = item->m\_packet;
1187               endOfCurrentPacket = beginOfCurrentPacket;
1188               beginOfCurrentPacket -= current->GetSize ();
1189               sackBlock->AddSackBlock (\hyperlink{classns3_1_1TcpOptionSack_a9e1d07d8729fd3ac5ead7305794675c3}{TcpOptionSack::SackBlock} (
      beginOfCurrentPacket,
1190                                                                  endOfCurrentPacket));
1191               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Filling the option: Adding ["} << beginOfCurrentPacket <<
1192                             \textcolor{stringliteral}{";"} << endOfCurrentPacket << \textcolor{stringliteral}{"], available space now : "} <<
1193                             (uint32\_t) (available - sackBlock->GetSerializedSize ()));
1194               \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (beginOfCurrentPacket > \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq});
1195             \}
1196 
1197           \textcolor{keywordflow}{return} sackBlock;
1198         \}
1199 
1200       ++it;
1201     \}
1202 
1203   \textcolor{keywordflow}{return} sackBlock;
1204 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9




Here is the caller graph for this function\+:
% FIG 10


\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Discard\+Up\+To@{Discard\+Up\+To}}
\index{Discard\+Up\+To@{Discard\+Up\+To}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Discard\+Up\+To(const Sequence\+Number32 \&seq)}{DiscardUpTo(const SequenceNumber32 &seq)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+Tx\+Buffer\+::\+Discard\+Up\+To (
\begin{DoxyParamCaption}
\item[{const {\bf Sequence\+Number32} \&}]{seq}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpTxBuffer_ad145a6de0122b3400fcbbff030d2acea}{}\label{classns3_1_1TcpTxBuffer_ad145a6de0122b3400fcbbff030d2acea}


Discard data up to but not including this sequence number. 


\begin{DoxyParams}{Parameters}
{\em seq} & The first sequence number to maintain after discarding all the previous sequences. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
579 \{
580   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << seq);
581 
582   \textcolor{comment}{// Cases do not need to scan the buffer}
583   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq} >= seq)
584     \{
585       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Seq "} << seq << \textcolor{stringliteral}{" already discarded."});
586       \textcolor{keywordflow}{return};
587     \}
588 
589   \textcolor{comment}{// Scan the buffer and discard packets}
590   uint32\_t offset = seq - \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq}.\hyperlink{classns3_1_1TracedValue_a10fddd1de961ac65acfbeb440a1e8551}{Get} ();  \textcolor{comment}{// Number of bytes to remove}
591   uint32\_t pktSize;
592   PacketList::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.begin ();
593   \textcolor{keywordflow}{while} (\hyperlink{classns3_1_1TcpTxBuffer_ace81d07d65ea00d9609dcc65a926564c}{m\_size} > 0 && offset > 0)
594     \{
595       \textcolor{keywordflow}{if} (i == \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.end ())
596         \{
597           Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = \hyperlink{classns3_1_1TcpTxBuffer_a5eb9c889cfad2cd11a5ccf996c506fd3}{CopyFromSequence} (offset, 
      \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq});
598           \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (p != 0);
599           i = \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.begin ();
600           \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (i != \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.end ());
601         \}
602       TcpTxItem *item = *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
603       Ptr<Packet> p = item->m\_packet;
604       pktSize = p->GetSize ();
605 
606       \textcolor{keywordflow}{if} (offset >= pktSize)
607         \{ \textcolor{comment}{// This packet is behind the seqnum. Remove this packet from the buffer}
608           \hyperlink{classns3_1_1TcpTxBuffer_ace81d07d65ea00d9609dcc65a926564c}{m\_size} -= pktSize;
609           \hyperlink{classns3_1_1TcpTxBuffer_ae45302ec0a3b3d757b0f3ad85e88e363}{m\_sentSize} -= pktSize;
610           offset -= pktSize;
611           \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq} += pktSize;
612           i = \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.erase (i);
613           \textcolor{keyword}{delete} item;
614           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"While removing up to "} << seq <<
615                        \textcolor{stringliteral}{".Removed one packet of size "} << pktSize <<
616                        \textcolor{stringliteral}{" starting from "} << \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq} - pktSize <<
617                        \textcolor{stringliteral}{". Remaining data "} << \hyperlink{classns3_1_1TcpTxBuffer_ace81d07d65ea00d9609dcc65a926564c}{m\_size});
618         \}
619       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (offset > 0)
620         \{ \textcolor{comment}{// Part of the packet is behind the seqnum. Fragment}
621           pktSize -= offset;
622           \textcolor{comment}{// PacketTags are preserved when fragmenting}
623           item->m\_packet = item->m\_packet->CreateFragment (offset, pktSize);
624           \hyperlink{classns3_1_1TcpTxBuffer_ace81d07d65ea00d9609dcc65a926564c}{m\_size} -= offset;
625           \hyperlink{classns3_1_1TcpTxBuffer_ae45302ec0a3b3d757b0f3ad85e88e363}{m\_sentSize} -= offset;
626           \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq} += offset;
627           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Fragmented one packet by size "} << offset <<
628                        \textcolor{stringliteral}{", new size="} << pktSize);
629           \textcolor{keywordflow}{break};
630         \}
631     \}
632   \textcolor{comment}{// Catching the case of ACKing a FIN}
633   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TcpTxBuffer_ace81d07d65ea00d9609dcc65a926564c}{m\_size} == 0)
634     \{
635       \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq} = seq;
636     \}
637 
638   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.empty ())
639     \{
640       TcpTxItem *head = \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.front ();
641       \textcolor{keywordflow}{if} (head->m\_sacked)
642         \{
643           \textcolor{comment}{// It is not possible to have the UNA sacked; otherwise, it would}
644           \textcolor{comment}{// have been ACKed. This is, most likely, our wrong guessing}
645           \textcolor{comment}{// when crafting the SACK option for a non-SACK receiver.}
646           head->m\_sacked = \textcolor{keyword}{false};
647         \}
648     \}
649 
650   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TcpTxBuffer_a224ded405afbf30d8828c8ddd16b29d9}{m\_highestSack}.second <= \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq})
651     \{
652       \hyperlink{classns3_1_1TcpTxBuffer_a224ded405afbf30d8828c8ddd16b29d9}{m\_highestSack} = std::make\_pair (\hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.end (), 
      \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} (0));
653     \}
654 
655   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Discarded up to "} << seq);
656   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Buffer status after discarding data "} << *\textcolor{keyword}{this});
657   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq} >= seq);
658 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 11




Here is the caller graph for this function\+:
% FIG 12


\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Get\+Highest\+Sacked@{Get\+Highest\+Sacked}}
\index{Get\+Highest\+Sacked@{Get\+Highest\+Sacked}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Get\+Highest\+Sacked() const }{GetHighestSacked() const }}]{\setlength{\rightskip}{0pt plus 5cm}std\+::pair$<$ Tcp\+Tx\+Buffer\+::\+Packet\+List\+::const\+\_\+iterator, {\bf Sequence\+Number32} $>$ ns3\+::\+Tcp\+Tx\+Buffer\+::\+Get\+Highest\+Sacked (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpTxBuffer_a6c411d008d8905f81ea087566f0b473b}{}\label{classns3_1_1TcpTxBuffer_a6c411d008d8905f81ea087566f0b473b}


Find the highest S\+A\+CK byte. 

\begin{DoxyReturn}{Returns}
a pair with the highest byte and an iterator inside m\+\_\+sent\+List 
\end{DoxyReturn}

\begin{DoxyCode}
341 \{
342   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
343 
344   PacketList::const\_iterator it;
345   std::pair <TcpTxBuffer::PacketList::const\_iterator, SequenceNumber32> ret;
346   \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} beginOfCurrentPacket = \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq};
347 
348   ret = std::make\_pair (\hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.end (), \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} (0));
349 
350   \textcolor{keywordflow}{for} (it = \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.begin (); it != \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.end (); ++it)
351     \{
352       \textcolor{keyword}{const} TcpTxItem *item = *it;
353       \textcolor{keywordflow}{if} (item->m\_sacked)
354         \{
355           ret = std::make\_pair (it, beginOfCurrentPacket);
356         \}
357       beginOfCurrentPacket += item->m\_packet->GetSize ();
358     \}
359 
360   \textcolor{keywordflow}{return} ret;
361 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13




Here is the caller graph for this function\+:
% FIG 14


\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Get\+New\+Segment@{Get\+New\+Segment}}
\index{Get\+New\+Segment@{Get\+New\+Segment}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Get\+New\+Segment(uint32\+\_\+t num\+Bytes)}{GetNewSegment(uint32_t numBytes)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tcp\+Tx\+Item} $\ast$ ns3\+::\+Tcp\+Tx\+Buffer\+::\+Get\+New\+Segment (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{num\+Bytes}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpTxBuffer_a7f8012f60263f1184f63d68f95d9fed6}{}\label{classns3_1_1TcpTxBuffer_a7f8012f60263f1184f63d68f95d9fed6}


Get a block of data not transmitted yet and move it into Sent\+List. 

If the block is not yet transmitted, hopefully, seq is exactly the sequence number of the first byte of the first packet inside App\+List. We extract the block from App\+List and move it into the Sent\+List, before returning the block itself. We manage possible fragmentation (or merges) inside App\+List through Get\+Packet\+From\+List.

\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1TcpTxBuffer_a0528a0261fe39fdb95526c24801f1091}{Get\+Packet\+From\+List} 
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em num\+Bytes} & number of bytes to copy\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the item that contains the right packet 
\end{DoxyReturn}

\begin{DoxyCode}
298 \{
299   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << numBytes);
300 
301   \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} startOfAppList = \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq} + 
      \hyperlink{classns3_1_1TcpTxBuffer_ae45302ec0a3b3d757b0f3ad85e88e363}{m\_sentSize};
302 
303   \textcolor{keywordtype}{bool} listEdited = \textcolor{keyword}{false};
304   TcpTxItem *item = \hyperlink{classns3_1_1TcpTxBuffer_a0528a0261fe39fdb95526c24801f1091}{GetPacketFromList} (\hyperlink{classns3_1_1TcpTxBuffer_ac85673c102b50188282a70152cc542ca}{m\_appList}, startOfAppList,
305                                        numBytes, startOfAppList, &listEdited);
306 
307   (void) listEdited;
308 
309   \textcolor{comment}{// Move item from AppList to SentList (should be the first, not too complex)}
310   PacketList::iterator it = std::find (\hyperlink{classns3_1_1TcpTxBuffer_ac85673c102b50188282a70152cc542ca}{m\_appList}.begin (), \hyperlink{classns3_1_1TcpTxBuffer_ac85673c102b50188282a70152cc542ca}{m\_appList}.end (), item);
311   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (it != \hyperlink{classns3_1_1TcpTxBuffer_ac85673c102b50188282a70152cc542ca}{m\_appList}.end ());
312 
313   \hyperlink{classns3_1_1TcpTxBuffer_ac85673c102b50188282a70152cc542ca}{m\_appList}.erase (it);
314   \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.insert (\hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.end (), item);
315   m\_sentSize += item->m\_packet->GetSize ();
316 
317   \textcolor{keywordflow}{return} item;
318 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 15




Here is the caller graph for this function\+:
% FIG 16


\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Get\+Packet\+From\+List@{Get\+Packet\+From\+List}}
\index{Get\+Packet\+From\+List@{Get\+Packet\+From\+List}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Get\+Packet\+From\+List(\+Packet\+List \&list, const Sequence\+Number32 \&starting\+Seq, uint32\+\_\+t num\+Bytes, const Sequence\+Number32 \&requested\+Seq, bool $\ast$list\+Edited) const }{GetPacketFromList(PacketList &list, const SequenceNumber32 &startingSeq, uint32_t numBytes, const SequenceNumber32 &requestedSeq, bool *listEdited) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tcp\+Tx\+Item} $\ast$ ns3\+::\+Tcp\+Tx\+Buffer\+::\+Get\+Packet\+From\+List (
\begin{DoxyParamCaption}
\item[{{\bf Packet\+List} \&}]{list, }
\item[{const {\bf Sequence\+Number32} \&}]{starting\+Seq, }
\item[{uint32\+\_\+t}]{num\+Bytes, }
\item[{const {\bf Sequence\+Number32} \&}]{requested\+Seq, }
\item[{bool $\ast$}]{list\+Edited}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpTxBuffer_a0528a0261fe39fdb95526c24801f1091}{}\label{classns3_1_1TcpTxBuffer_a0528a0261fe39fdb95526c24801f1091}


Get a block (which is returned as \hyperlink{classns3_1_1Packet}{Packet}) from a list. 

This function extract a block \mbox{[}requested\+Seq,num\+Bytes) from the list, which starts at starting\+Seq.

The cases we need to manage are two, and they are depicted in the following image\+:

\begin{DoxyVerb}                     |------|     |----|     |----|
              list = |      | --> |    | --> |    |
                     |------|     |----|     |----|

                     ^      ^
                     | ^ ^  |         (1)
                   seq | |  seq + numBytes
                       | |
                       | |
                    seq   seq + numBytes     (2)\end{DoxyVerb}


The case 1 is easy to manage\+: the requested block is exactly a packet already stored. If one value (seq or seq + num\+Bytes) does not align to a packet boundary, or when both values does not align (case 2), it is a bit more complex.

Basically, we have two possible operations\+:


\begin{DoxyItemize}
\item fragment \+: split an existing packet in two
\item merge \+: merge two existing packets in one
\end{DoxyItemize}

and we reduce case (2) to case (1) through sequentially applying fragment or merge. For instance\+:

\begin{DoxyVerb}    |------|
    |      |
    |------|

    ^ ^  ^ ^
    | |  | |
start |  | |
      |  | end
     seq |
         seq + numBytes\end{DoxyVerb}


To reduce to case (1), we need to perform two fragment operations\+:


\begin{DoxyItemize}
\item fragment (start, seq)
\item fragment (seq + num\+Bytes, end)
\end{DoxyItemize}

After these operations, the requested block is exactly the resulting packet. Merge operation is required when the requested block span over two (or more) existing packets.

While this could be extremely slow in the worst possible scenario (one big packet which is split in small packets for transmission, and merged for re-\/transmission) that scenario is unlikely during a T\+CP transmission (since M\+SS can change, but it is stable, and retransmissions do not happen for each segment).


\begin{DoxyParams}{Parameters}
{\em list} & List to extract block from \\
\hline
{\em starting\+Seq} & Starting sequence of the list \\
\hline
{\em num\+Bytes} & Bytes to extract, starting from requested\+Seq \\
\hline
{\em requested\+Seq} & Requested sequence \\
\hline
{\em list\+Edited} & output parameter which indicates if the list has been edited \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the item that contains the right packet 
\end{DoxyReturn}

\begin{DoxyCode}
382 \{
383   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << numBytes << seq);
384 
385   \textcolor{comment}{/*}
386 \textcolor{comment}{   * Our possibilites are sketched out in the following:}
387 \textcolor{comment}{   *}
388 \textcolor{comment}{   *                    |------|     |----|     |----|}
389 \textcolor{comment}{   * GetList (m\_data) = |      | --> |    | --> |    |}
390 \textcolor{comment}{   *                    |------|     |----|     |----|}
391 \textcolor{comment}{   *}
392 \textcolor{comment}{   *                    ^ ^ ^  ^}
393 \textcolor{comment}{   *                    | | |  |         (1)}
394 \textcolor{comment}{   *                  seq | |  numBytes}
395 \textcolor{comment}{   *                      | |}
396 \textcolor{comment}{   *                      | |}
397 \textcolor{comment}{   *                    seq numBytes     (2)}
398 \textcolor{comment}{   *}
399 \textcolor{comment}{   * (1) seq and numBytes are the boundary of some packet}
400 \textcolor{comment}{   * (2) seq and numBytes are not the boundary of some packet}
401 \textcolor{comment}{   *}
402 \textcolor{comment}{   * We can have mixed case (e.g. seq over the boundary while numBytes not).}
403 \textcolor{comment}{   *}
404 \textcolor{comment}{   * If we discover that we are in (2) or in a mixed case, we split}
405 \textcolor{comment}{   * packets accordingly to the requested bounds and re-run the function.}
406 \textcolor{comment}{   *}
407 \textcolor{comment}{   * In (1), things are pretty easy, it's just a matter of walking the list and}
408 \textcolor{comment}{   * defragment packets, if needed (e.g. seq is the beginning of the first packet}
409 \textcolor{comment}{   * while maxBytes is the end of some packet next in the list).}
410 \textcolor{comment}{   */}
411 
412   Ptr<Packet> currentPacket = 0;
413   TcpTxItem *currentItem = 0;
414   TcpTxItem *outItem = 0;
415   PacketList::iterator it = \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{list}.begin ();
416   \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} beginOfCurrentPacket = listStartFrom;
417 
418   \textcolor{keywordflow}{while} (it != \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{list}.end ())
419     \{
420       currentItem = *it;
421       currentPacket = currentItem->m\_packet;
422 
423       \textcolor{comment}{// The objective of this snippet is to find (or to create) the packet}
424       \textcolor{comment}{// that begin with the sequence seq}
425 
426       \textcolor{keywordflow}{if} (seq < beginOfCurrentPacket + currentPacket->GetSize ())
427         \{
428           \textcolor{comment}{// seq is inside the current packet}
429           \textcolor{keywordflow}{if} (seq == beginOfCurrentPacket)
430             \{
431               \textcolor{comment}{// seq is the beginning of the current packet. Hurray!}
432               outItem = currentItem;
433               \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Current packet starts at seq "} << seq <<
434                            \textcolor{stringliteral}{" ends at "} << seq + currentPacket->GetSize ());
435             \}
436           \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (seq > beginOfCurrentPacket)
437             \{
438               \textcolor{comment}{// seq is inside the current packet but seq is not the beginning,}
439               \textcolor{comment}{// it's somewhere in the middle. Just fragment the beginning and}
440               \textcolor{comment}{// start again.}
441               \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"we are at "} << beginOfCurrentPacket <<
442                            \textcolor{stringliteral}{" searching for "} << seq <<
443                            \textcolor{stringliteral}{" and now we recurse because packet ends at "}
444                                         << beginOfCurrentPacket + currentPacket->GetSize ());
445               TcpTxItem *firstPart = \textcolor{keyword}{new} TcpTxItem ();
446               \hyperlink{classns3_1_1TcpTxBuffer_a34d85565e5a51b10a33444ed47415f2f}{SplitItems} (*firstPart, *currentItem, seq - beginOfCurrentPacket);
447 
448               \textcolor{comment}{// insert firstPart before currentItem}
449               \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{list}.insert (it, firstPart);
450               *listEdited = \textcolor{keyword}{true};
451 
452               \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpTxBuffer_a0528a0261fe39fdb95526c24801f1091}{GetPacketFromList} (\hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{list}, listStartFrom, numBytes, seq, listEdited
      );
453             \}
454           \textcolor{keywordflow}{else}
455             \{
456               \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"seq < beginOfCurrentPacket: our data is before"});
457             \}
458         \}
459       \textcolor{keywordflow}{else}
460         \{
461           \textcolor{comment}{// Walk the list, the current packet does not contain seq}
462           beginOfCurrentPacket += currentPacket->GetSize ();
463           it++;
464           \textcolor{keywordflow}{continue};
465         \}
466 
467       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (outItem != 0);
468 
469       \textcolor{comment}{// The objective of this snippet is to find (or to create) the packet}
470       \textcolor{comment}{// that ends after numBytes bytes. We are sure that outPacket starts}
471       \textcolor{comment}{// at seq.}
472 
473       \textcolor{keywordflow}{if} (seq + numBytes <= beginOfCurrentPacket + currentPacket->GetSize ())
474         \{
475           \textcolor{comment}{// the end boundary is inside the current packet}
476           \textcolor{keywordflow}{if} (numBytes == currentPacket->GetSize ())
477             \{
478               \textcolor{comment}{// the end boundary is exactly the end of the current packet. Hurray!}
479               \textcolor{keywordflow}{if} (currentItem->m\_packet == outItem->m\_packet)
480                 \{
481                   \textcolor{comment}{// A perfect match!}
482                   \textcolor{keywordflow}{return} outItem;
483                 \}
484               \textcolor{keywordflow}{else}
485                 \{
486                   \textcolor{comment}{// the end is exactly the end of current packet, but}
487                   \textcolor{comment}{// current > outPacket in the list. Merge current with the}
488                   \textcolor{comment}{// previous, and recurse.}
489                   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (it != \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{list}.begin ());
490                   TcpTxItem *previous = *(--it);
491 
492                   \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{list}.erase (it);
493 
494                   \hyperlink{classns3_1_1TcpTxBuffer_aee57c32104926f7d4bfdeb12f05a6db1}{MergeItems} (*previous, *currentItem);
495                   \textcolor{keyword}{delete} currentItem;
496                   *listEdited = \textcolor{keyword}{true};
497 
498                   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpTxBuffer_a0528a0261fe39fdb95526c24801f1091}{GetPacketFromList} (\hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{list}, listStartFrom, numBytes, seq, 
      listEdited);
499                 \}
500             \}
501           \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (numBytes < currentPacket->GetSize ())
502             \{
503               \textcolor{comment}{// the end is inside the current packet, but it isn't exactly}
504               \textcolor{comment}{// the packet end. Just fragment, fix the list, and return.}
505               TcpTxItem *firstPart = \textcolor{keyword}{new} TcpTxItem ();
506               \hyperlink{classns3_1_1TcpTxBuffer_a34d85565e5a51b10a33444ed47415f2f}{SplitItems} (*firstPart, *currentItem, numBytes);
507 
508               \textcolor{comment}{// insert firstPart before currentItem}
509               \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{list}.insert (it, firstPart);
510               *listEdited = \textcolor{keyword}{true};
511 
512               \textcolor{keywordflow}{return} firstPart;
513             \}
514         \}
515       \textcolor{keywordflow}{else}
516         \{
517           \textcolor{comment}{// The end isn't inside current packet, but there is an exception for}
518           \textcolor{comment}{// the merge and recurse strategy...}
519           \textcolor{keywordflow}{if} (++it == \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{list}.end ())
520             \{
521               \textcolor{comment}{// ...current is the last packet we sent. We have not more data;}
522               \textcolor{comment}{// Go for this one.}
523               \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Cannot reach the end, but this case is covered "}
524                            \textcolor{stringliteral}{"with conditional statements inside CopyFromSequence."}
525                            \textcolor{stringliteral}{"Something has gone wrong, report a bug"});
526               \textcolor{keywordflow}{return} outItem;
527             \}
528 
529           \textcolor{comment}{// The current packet does not contain the requested end. Merge current}
530           \textcolor{comment}{// with the packet that follows, and recurse}
531           TcpTxItem *next = (*it); \textcolor{comment}{// Please remember we have incremented it}
532                                    \textcolor{comment}{// in the previous if}
533 
534           \hyperlink{classns3_1_1TcpTxBuffer_aee57c32104926f7d4bfdeb12f05a6db1}{MergeItems} (*currentItem, *next);
535           \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{list}.erase (it);
536 
537           \textcolor{keyword}{delete} next;
538 
539           *listEdited = \textcolor{keyword}{true};
540 
541           \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpTxBuffer_a0528a0261fe39fdb95526c24801f1091}{GetPacketFromList} (\hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{list}, listStartFrom, numBytes, seq, listEdited);
542         \}
543     \}
544 
545   \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"This point is not reachable"});
546 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 17




Here is the caller graph for this function\+:
% FIG 18


\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Get\+Transmitted\+Segment@{Get\+Transmitted\+Segment}}
\index{Get\+Transmitted\+Segment@{Get\+Transmitted\+Segment}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Get\+Transmitted\+Segment(uint32\+\_\+t num\+Bytes, const Sequence\+Number32 \&seq)}{GetTransmittedSegment(uint32_t numBytes, const SequenceNumber32 &seq)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tcp\+Tx\+Item} $\ast$ ns3\+::\+Tcp\+Tx\+Buffer\+::\+Get\+Transmitted\+Segment (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{num\+Bytes, }
\item[{const {\bf Sequence\+Number32} \&}]{seq}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpTxBuffer_a4de9715c65893a5cb8a869e72ed7bb10}{}\label{classns3_1_1TcpTxBuffer_a4de9715c65893a5cb8a869e72ed7bb10}


Get a block of data previously transmitted. 

This is clearly a retransmission, and if everything is going well, the block requested is matching perfectly with another one requested in the past. If not, fragmentation or merge are required. We manage both inside Get\+Packet\+From\+List.

\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1TcpTxBuffer_a0528a0261fe39fdb95526c24801f1091}{Get\+Packet\+From\+List}
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em num\+Bytes} & number of bytes to copy \\
\hline
{\em seq} & sequence requested \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the item that contains the right packet 
\end{DoxyReturn}

\begin{DoxyCode}
322 \{
323   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << numBytes << seq);
324   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (seq >= \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq});
325   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (numBytes <= \hyperlink{classns3_1_1TcpTxBuffer_ae45302ec0a3b3d757b0f3ad85e88e363}{m\_sentSize});
326 
327   \textcolor{keywordtype}{bool} listEdited = \textcolor{keyword}{false};
328 
329   TcpTxItem *item = \hyperlink{classns3_1_1TcpTxBuffer_a0528a0261fe39fdb95526c24801f1091}{GetPacketFromList} (\hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}, 
      \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq}, numBytes, seq, &listEdited);
330 
331   \textcolor{keywordflow}{if} (listEdited && \hyperlink{classns3_1_1TcpTxBuffer_a224ded405afbf30d8828c8ddd16b29d9}{m\_highestSack}.second >= \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq})
332     \{
333       \hyperlink{classns3_1_1TcpTxBuffer_a224ded405afbf30d8828c8ddd16b29d9}{m\_highestSack} = \hyperlink{classns3_1_1TcpTxBuffer_a6c411d008d8905f81ea087566f0b473b}{GetHighestSacked} ();
334     \}
335 
336   \textcolor{keywordflow}{return} item;
337 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 19




Here is the caller graph for this function\+:
% FIG 20


\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Tcp\+Tx\+Buffer\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1TcpTxBuffer_a0e303ee2cabca6bf9785ddac2a0fb392}{}\label{classns3_1_1TcpTxBuffer_a0e303ee2cabca6bf9785ddac2a0fb392}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
94 \{
95   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::TcpTxBuffer"})
96     .SetParent<\hyperlink{classns3_1_1Object_a40860402e64d8008fb42329df7097cdb}{Object}> ()
97     .SetGroupName (\textcolor{stringliteral}{"Internet"})
98     .AddConstructor<\hyperlink{classns3_1_1TcpTxBuffer_afdb96487c75ba8447e475d0489ded790}{TcpTxBuffer}> ()
99     .AddTraceSource (\textcolor{stringliteral}{"UnackSequence"},
100                      \textcolor{stringliteral}{"First unacknowledged sequence number (SND.UNA)"},
101                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{TcpTxBuffer::m\_firstByteSeq}),
102                      \textcolor{stringliteral}{"ns3::SequenceNumber32TracedValueCallback"})
103   ;
104   \textcolor{keywordflow}{return} tid;
105 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 21


\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Head\+Sequence@{Head\+Sequence}}
\index{Head\+Sequence@{Head\+Sequence}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Head\+Sequence(void) const }{HeadSequence(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Sequence\+Number32} ns3\+::\+Tcp\+Tx\+Buffer\+::\+Head\+Sequence (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1TcpTxBuffer_a6c7cdcf53b722f2877372bd75a1541a7}{}\label{classns3_1_1TcpTxBuffer_a6c7cdcf53b722f2877372bd75a1541a7}


Get the sequence number of the buffer head. 

\begin{DoxyReturn}{Returns}
the first byte\textquotesingle{}s sequence number 
\end{DoxyReturn}

\begin{DoxyCode}
140 \{
141   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq};
142 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Is\+Head\+Retransmitted@{Is\+Head\+Retransmitted}}
\index{Is\+Head\+Retransmitted@{Is\+Head\+Retransmitted}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Is\+Head\+Retransmitted() const }{IsHeadRetransmitted() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Tcp\+Tx\+Buffer\+::\+Is\+Head\+Retransmitted (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1TcpTxBuffer_a547705cacaea905c9c3831225f17872b}{}\label{classns3_1_1TcpTxBuffer_a547705cacaea905c9c3831225f17872b}


Check if the head is retransmitted. 

\begin{DoxyReturn}{Returns}
true if the head is retransmitted, false in all other cases (including no segment sent) 
\end{DoxyReturn}

\begin{DoxyCode}
1101 \{
1102   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1103 
1104   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TcpTxBuffer_ae45302ec0a3b3d757b0f3ad85e88e363}{m\_sentSize} == 0)
1105     \{
1106       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1107     \}
1108 
1109   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.size () > 0);
1110   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.front ()->m\_retrans;
1111 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Is\+Lost@{Is\+Lost}}
\index{Is\+Lost@{Is\+Lost}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Is\+Lost(const Sequence\+Number32 \&seq, uint32\+\_\+t dup\+Thresh, uint32\+\_\+t segment\+Size) const }{IsLost(const SequenceNumber32 &seq, uint32_t dupThresh, uint32_t segmentSize) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Tcp\+Tx\+Buffer\+::\+Is\+Lost (
\begin{DoxyParamCaption}
\item[{const {\bf Sequence\+Number32} \&}]{seq, }
\item[{uint32\+\_\+t}]{dup\+Thresh, }
\item[{uint32\+\_\+t}]{segment\+Size}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1TcpTxBuffer_add55043ebbafc30ba4e48d3f8aa9f064}{}\label{classns3_1_1TcpTxBuffer_add55043ebbafc30ba4e48d3f8aa9f064}


Check if a segment is lost per R\+FC 6675. 


\begin{DoxyParams}{Parameters}
{\em seq} & sequence to check \\
\hline
{\em dup\+Thresh} & dup\+Ack threshold \\
\hline
{\em segment\+Size} & segment size \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the sequence is supposed to be lost, false otherwise 
\end{DoxyReturn}

\begin{DoxyCode}
795 \{
796   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << seq << dupThresh);
797 
798   \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} beginOfCurrentPacket = \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq};
799   PacketList::const\_iterator it;
800 
801   \textcolor{keywordflow}{if} (seq >= \hyperlink{classns3_1_1TcpTxBuffer_a224ded405afbf30d8828c8ddd16b29d9}{m\_highestSack}.second)
802     \{
803       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
804     \}
805 
806   \textcolor{comment}{// This O(n) method is called only once, and outside this class.}
807   \textcolor{comment}{// It should not harm the performance}
808   \textcolor{keywordflow}{for} (it = \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.begin (); it != \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.end (); ++it)
809     \{
810       \textcolor{comment}{// Search for the right iterator before calling IsLost()}
811       \textcolor{keywordflow}{if} (beginOfCurrentPacket >= seq)
812         \{
813           \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpTxBuffer_add55043ebbafc30ba4e48d3f8aa9f064}{IsLost} (beginOfCurrentPacket, it, dupThresh, segmentSize);
814         \}
815 
816       beginOfCurrentPacket += (*it)->m\_packet->GetSize ();
817     \}
818 
819   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
820 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 22


\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Is\+Lost@{Is\+Lost}}
\index{Is\+Lost@{Is\+Lost}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Is\+Lost(const Sequence\+Number32 \&seq, const Packet\+List\+::const\+\_\+iterator \&segment, uint32\+\_\+t dup\+Thresh, uint32\+\_\+t segment\+Size) const }{IsLost(const SequenceNumber32 &seq, const PacketList::const_iterator &segment, uint32_t dupThresh, uint32_t segmentSize) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Tcp\+Tx\+Buffer\+::\+Is\+Lost (
\begin{DoxyParamCaption}
\item[{const {\bf Sequence\+Number32} \&}]{seq, }
\item[{const Packet\+List\+::const\+\_\+iterator \&}]{segment, }
\item[{uint32\+\_\+t}]{dup\+Thresh, }
\item[{uint32\+\_\+t}]{segment\+Size}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpTxBuffer_abef1df59556801517ac6f99c3bf135cf}{}\label{classns3_1_1TcpTxBuffer_abef1df59556801517ac6f99c3bf135cf}


Check if a segment is lost per R\+FC 6675. 


\begin{DoxyParams}{Parameters}
{\em seq} & sequence to check \\
\hline
{\em segment} & Iterator pointing at seq \\
\hline
{\em dup\+Thresh} & dup\+Ack threshold \\
\hline
{\em segment\+Size} & segment size \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the sequence is supposed to be lost, false otherwise 
\end{DoxyReturn}

\begin{DoxyCode}
733 \{
734   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << seq << dupThresh << segmentSize);
735   uint32\_t count = 0;
736   uint32\_t bytes = 0;
737   PacketList::const\_iterator it;
738   TcpTxItem *item;
739   Ptr<const Packet> current;
740   \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} beginOfCurrentPacket = seq;
741 
742   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Checking if seq="} << seq << \textcolor{stringliteral}{" is lost from the buffer "});
743 
744   \textcolor{keywordflow}{if} ((*segment)->m\_lost == \textcolor{keyword}{true})
745     \{
746       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"seq="} << seq << \textcolor{stringliteral}{" is lost because of lost flag"});
747       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
748     \}
749 
750   \textcolor{keywordflow}{if} ((*segment)->m\_sacked == \textcolor{keyword}{true})
751     \{
752       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"seq="} << seq << \textcolor{stringliteral}{" is not lost because of sacked flag"});
753       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
754     \}
755 
756   \textcolor{comment}{// From RFC 6675:}
757   \textcolor{comment}{// > The routine returns true when either dupThresh discontiguous SACKed}
758   \textcolor{comment}{// > sequences have arrived above 'seq' or more than (dupThresh - 1) * SMSS bytes}
759   \textcolor{comment}{// > with sequence numbers greater than 'SeqNum' have been SACKed.  Otherwise, the}
760   \textcolor{comment}{// > routine returns false.}
761   \textcolor{keywordflow}{for} (it = segment; it != \hyperlink{classns3_1_1TcpTxBuffer_a224ded405afbf30d8828c8ddd16b29d9}{m\_highestSack}.first; ++it)
762     \{
763       \textcolor{keywordflow}{if} (beginOfCurrentPacket >= \hyperlink{classns3_1_1TcpTxBuffer_a224ded405afbf30d8828c8ddd16b29d9}{m\_highestSack}.second)
764         \{
765           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"seq="} << seq << \textcolor{stringliteral}{" is not lost because there are no sacked segment ahead"}
      );
766           \textcolor{keywordflow}{return} \textcolor{keyword}{false};
767         \}
768 
769       item = *it;
770       current = item->m\_packet;
771 
772       \textcolor{keywordflow}{if} (item->m\_sacked)
773         \{
774           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Segment ["} << beginOfCurrentPacket << \textcolor{stringliteral}{", "} <<
775                        beginOfCurrentPacket+item->m\_packet->GetSize () <<
776                        \textcolor{stringliteral}{"] found to be SACKed"});
777           ++count;
778           bytes += current->GetSize ();
779           \textcolor{keywordflow}{if} ((count >= dupThresh) || (bytes > (dupThresh-1) * segmentSize))
780             \{
781               \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"seq="} << seq << \textcolor{stringliteral}{" is lost because of 3 sacked blocks ahead"});
782               \textcolor{keywordflow}{return} \textcolor{keyword}{true};
783             \}
784         \}
785 
786       beginOfCurrentPacket += current->GetSize ();
787     \}
788 
789   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
790 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 23


\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Max\+Buffer\+Size@{Max\+Buffer\+Size}}
\index{Max\+Buffer\+Size@{Max\+Buffer\+Size}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Max\+Buffer\+Size(void) const }{MaxBufferSize(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Tcp\+Tx\+Buffer\+::\+Max\+Buffer\+Size (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1TcpTxBuffer_ac31145a6c4f814d5ddb95ab1c3bce972}{}\label{classns3_1_1TcpTxBuffer_ac31145a6c4f814d5ddb95ab1c3bce972}


Get the maximum buffer size. 

\begin{DoxyReturn}{Returns}
the Tx window size (in bytes) 
\end{DoxyReturn}

\begin{DoxyCode}
158 \{
159   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpTxBuffer_a4e661fb54fabfe319c6fc15f7080526f}{m\_maxBuffer};
160 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Merge\+Items@{Merge\+Items}}
\index{Merge\+Items@{Merge\+Items}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Merge\+Items(\+Tcp\+Tx\+Item \&t1, Tcp\+Tx\+Item \&t2) const }{MergeItems(TcpTxItem &t1, TcpTxItem &t2) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+Tx\+Buffer\+::\+Merge\+Items (
\begin{DoxyParamCaption}
\item[{{\bf Tcp\+Tx\+Item} \&}]{t1, }
\item[{{\bf Tcp\+Tx\+Item} \&}]{t2}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpTxBuffer_aee57c32104926f7d4bfdeb12f05a6db1}{}\label{classns3_1_1TcpTxBuffer_aee57c32104926f7d4bfdeb12f05a6db1}


Merge two \hyperlink{classns3_1_1TcpTxItem}{Tcp\+Tx\+Item}. 

Merge t2 in t1. It consists in copying the last\+Sent field if t2 is more recent than t1. Retransmitted field is copied only if it set in t2 but not in t1. Sacked is copied only if it is true in both items.


\begin{DoxyParams}{Parameters}
{\em t1} & first item \\
\hline
{\em t2} & second item \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
550 \{
551   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
552   \textcolor{keywordflow}{if} (t1.m\_sacked == \textcolor{keyword}{true} && t2.m\_sacked == \textcolor{keyword}{true})
553     \{
554       t1.m\_sacked = \textcolor{keyword}{true};
555     \}
556   \textcolor{keywordflow}{else}
557     \{
558       t1.m\_sacked = \textcolor{keyword}{false};
559     \}
560 
561   \textcolor{keywordflow}{if} (t2.m\_retrans == \textcolor{keyword}{true} && t1.m\_retrans == \textcolor{keyword}{false})
562     \{
563       t1.m\_retrans = \textcolor{keyword}{true};
564     \}
565   \textcolor{keywordflow}{if} (t1.m\_lastSent < t2.m\_lastSent)
566     \{
567       t1.m\_lastSent = t2.m\_lastSent;
568     \}
569   \textcolor{keywordflow}{if} (t2.m\_lost)
570     \{
571       t1.m\_lost = \textcolor{keyword}{true};
572     \}
573 
574   t1.m\_packet->AddAtEnd (t2.m\_packet);
575 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 24




Here is the caller graph for this function\+:
% FIG 25


\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Next\+Seg@{Next\+Seg}}
\index{Next\+Seg@{Next\+Seg}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Next\+Seg(\+Sequence\+Number32 $\ast$seq, uint32\+\_\+t dup\+Thresh, uint32\+\_\+t segment\+Size, bool is\+Recovery) const }{NextSeg(SequenceNumber32 *seq, uint32_t dupThresh, uint32_t segmentSize, bool isRecovery) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Tcp\+Tx\+Buffer\+::\+Next\+Seg (
\begin{DoxyParamCaption}
\item[{{\bf Sequence\+Number32} $\ast$}]{seq, }
\item[{uint32\+\_\+t}]{dup\+Thresh, }
\item[{uint32\+\_\+t}]{segment\+Size, }
\item[{bool}]{is\+Recovery}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1TcpTxBuffer_ad08eadd0ba92849a4c4a6920b72acb69}{}\label{classns3_1_1TcpTxBuffer_ad08eadd0ba92849a4c4a6920b72acb69}


Get the next sequence number to transmit, according to R\+FC 6675. 


\begin{DoxyParams}{Parameters}
{\em seq} & Next sequence number to transmit, based on the scoreboard information \\
\hline
{\em dup\+Thresh} & dup\+Ack threshold \\
\hline
{\em segment\+Size} & segment size \\
\hline
{\em is\+Recovery} & true if the socket congestion state is in recovery mode \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true is seq is updated, false otherwise 
\end{DoxyReturn}

\begin{DoxyCode}
825 \{
826   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
827 
828   \textcolor{comment}{/* RFC 6675, NextSeg definition.}
829 \textcolor{comment}{   *}
830 \textcolor{comment}{   * (1) If there exists a smallest unSACKed sequence number 'S2' that}
831 \textcolor{comment}{   *     meets the following three criteria for determining loss, the}
832 \textcolor{comment}{   *     sequence range of one segment of up to SMSS octets starting}
833 \textcolor{comment}{   *     with S2 MUST be returned.}
834 \textcolor{comment}{   *}
835 \textcolor{comment}{   *     (1.a) S2 is greater than HighRxt.}
836 \textcolor{comment}{   *}
837 \textcolor{comment}{   *     (1.b) S2 is less than the highest octet covered by any}
838 \textcolor{comment}{   *           received SACK.}
839 \textcolor{comment}{   *}
840 \textcolor{comment}{   *     (1.c) IsLost (S2) returns true.}
841 \textcolor{comment}{   */}
842   PacketList::const\_iterator it;
843   TcpTxItem *item;
844   \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} seqPerRule3;
845   \textcolor{keywordtype}{bool} isSeqPerRule3Valid = \textcolor{keyword}{false};
846   \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} beginOfCurrentPkt = \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq};
847 
848   \textcolor{comment}{/*for (it = m\_sentList.begin (); it != m\_sentList.end (); ++it)}
849 \textcolor{comment}{    \{}
850 \textcolor{comment}{      item = *it;}
851 \textcolor{comment}{}
852 \textcolor{comment}{      // Condition 1.a , 1.b , and 1.c}
853 \textcolor{comment}{      if (item->m\_retrans == false && item->m\_sacked == false)}
854 \textcolor{comment}{        \{}
855 \textcolor{comment}{          if (IsLost (beginOfCurrentPkt, it, dupThresh, segmentSize))}
856 \textcolor{comment}{            \{}
857 \textcolor{comment}{              *seq = beginOfCurrentPkt;}
858 \textcolor{comment}{              return true;}
859 \textcolor{comment}{            \}}
860 \textcolor{comment}{          else if (seqPerRule3.GetValue () == 0 && isRecovery)}
861 \textcolor{comment}{            \{}
862 \textcolor{comment}{              isSeqPerRule3Valid = true;}
863 \textcolor{comment}{              seqPerRule3 = beginOfCurrentPkt;}
864 \textcolor{comment}{            \}}
865 \textcolor{comment}{        \}}
866 \textcolor{comment}{}
867 \textcolor{comment}{      // Nothing found, iterate}
868 \textcolor{comment}{      beginOfCurrentPkt += item->m\_packet->GetSize ();}
869 \textcolor{comment}{    \}*/}
870 
871   \textcolor{keywordtype}{bool} detectLoss = \textcolor{keyword}{true};
872   \textcolor{keywordflow}{for} (it = \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.begin (); it != \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.end (); ++it)
873     \{
874       item = *it;
875 
876       \textcolor{comment}{// Condition 1.a , 1.b , and 1.c}
877       \textcolor{keywordflow}{if} (item->m\_retrans == \textcolor{keyword}{false} && item->m\_sacked == \textcolor{keyword}{false})
878         \{
879           \textcolor{keywordflow}{if} (detectLoss)
880           \{
881                           \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TcpTxBuffer_add55043ebbafc30ba4e48d3f8aa9f064}{IsLost} (beginOfCurrentPkt, it, dupThresh, segmentSize))
882                                 \{
883                                   *seq = beginOfCurrentPkt;
884                                   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
885                                 \}
886                           \textcolor{keywordflow}{else}
887                           \{
888                                   detectLoss = \textcolor{keyword}{false};
889                                   \textcolor{keywordflow}{if} (seqPerRule3.GetValue () == 0 && isRecovery)
890                                   \{
891                                         isSeqPerRule3Valid = \textcolor{keyword}{true};
892                                         seqPerRule3 = beginOfCurrentPkt;
893                                   \}
894 
895                           \}
896           \}
897           \textcolor{keywordflow}{else}
898           \{
899                   \textcolor{keywordflow}{if}(item->m\_lost)
900                   \{
901                                   *seq = beginOfCurrentPkt;
902                                   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
903                   \}
904               \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (seqPerRule3.GetValue () == 0 && isRecovery)
905                 \{
906                   isSeqPerRule3Valid = \textcolor{keyword}{true};
907                   seqPerRule3 = beginOfCurrentPkt;
908                 \}
909           \}
910 
911         \}
912 
913       \textcolor{comment}{// Nothing found, iterate}
914       beginOfCurrentPkt += item->m\_packet->GetSize ();
915     \}
916 
917 
918   \textcolor{comment}{/* (2) If no sequence number 'S2' per rule (1) exists but there}
919 \textcolor{comment}{   *     exists available unsent data and the receiver's advertised}
920 \textcolor{comment}{   *     window allows, the sequence range of one segment of up to SMSS}
921 \textcolor{comment}{   *     octets of previously unsent data starting with sequence number}
922 \textcolor{comment}{   *     HighData+1 MUST be returned.}
923 \textcolor{comment}{   */}
924   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TcpTxBuffer_a6e44c34fdb2c14dcc11dbbe86d8b328a}{SizeFromSequence} (\hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq} + 
      \hyperlink{classns3_1_1TcpTxBuffer_ae45302ec0a3b3d757b0f3ad85e88e363}{m\_sentSize}) > 0)
925     \{
926       *seq = \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq} + \hyperlink{classns3_1_1TcpTxBuffer_ae45302ec0a3b3d757b0f3ad85e88e363}{m\_sentSize};
927       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
928     \}
929 
930   \textcolor{comment}{/* (3) If the conditions for rules (1) and (2) fail, but there exists}
931 \textcolor{comment}{   *     an unSACKed sequence number 'S3' that meets the criteria for}
932 \textcolor{comment}{   *     detecting loss given in steps (1.a) and (1.b) above}
933 \textcolor{comment}{   *     (specifically excluding step (1.c)), then one segment of up to}
934 \textcolor{comment}{   *     SMSS octets starting with S3 SHOULD be returned.}
935 \textcolor{comment}{   */}
936   \textcolor{keywordflow}{if} (isSeqPerRule3Valid)
937     \{
938       *seq = seqPerRule3;
939       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
940     \}
941 
942   \textcolor{comment}{/* (4) If the conditions for (1), (2), and (3) fail, but there exists}
943 \textcolor{comment}{   *     outstanding unSACKed data, we provide the opportunity for a}
944 \textcolor{comment}{   *     single "rescue" retransmission per entry into loss recovery.}
945 \textcolor{comment}{   *     If HighACK is greater than RescueRxt (or RescueRxt is}
946 \textcolor{comment}{   *     undefined), then one segment of up to SMSS octets that MUST}
947 \textcolor{comment}{   *     include the highest outstanding unSACKed sequence number}
948 \textcolor{comment}{   *     SHOULD be returned, and RescueRxt set to RecoveryPoint.}
949 \textcolor{comment}{   *     HighRxt MUST NOT be updated.}
950 \textcolor{comment}{   *}
951 \textcolor{comment}{   * This point require too much interaction between us and TcpSocketBase.}
952 \textcolor{comment}{   * We choose to not respect the SHOULD (allowed from RFC MUST/SHOULD definition)}
953 \textcolor{comment}{   */}
954   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
955 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 26




Here is the caller graph for this function\+:
% FIG 27


\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Reset\+Last\+Segment\+Sent@{Reset\+Last\+Segment\+Sent}}
\index{Reset\+Last\+Segment\+Sent@{Reset\+Last\+Segment\+Sent}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Reset\+Last\+Segment\+Sent()}{ResetLastSegmentSent()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+Tx\+Buffer\+::\+Reset\+Last\+Segment\+Sent (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpTxBuffer_a61f519ff65cbadfb81099f866f1722f0}{}\label{classns3_1_1TcpTxBuffer_a61f519ff65cbadfb81099f866f1722f0}


Take the last segment sent and put it back into the un-\/sent list (at the beginning) 


\begin{DoxyCode}
1074 \{
1075   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1076   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.empty ())
1077     \{
1078       TcpTxItem *item = \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.back ();
1079 
1080       \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.pop\_back ();
1081       \hyperlink{classns3_1_1TcpTxBuffer_ae45302ec0a3b3d757b0f3ad85e88e363}{m\_sentSize} -= item->m\_packet->GetSize ();
1082       \hyperlink{classns3_1_1TcpTxBuffer_ac85673c102b50188282a70152cc542ca}{m\_appList}.insert (\hyperlink{classns3_1_1TcpTxBuffer_ac85673c102b50188282a70152cc542ca}{m\_appList}.begin (), item);
1083     \}
1084 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 28


\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Reset\+Scoreboard@{Reset\+Scoreboard}}
\index{Reset\+Scoreboard@{Reset\+Scoreboard}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Reset\+Scoreboard()}{ResetScoreboard()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+Tx\+Buffer\+::\+Reset\+Scoreboard (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpTxBuffer_a6548f4b2cb53c40743988747229bd4ac}{}\label{classns3_1_1TcpTxBuffer_a6548f4b2cb53c40743988747229bd4ac}


Reset the Scoreboard from all S\+A\+CK informations. 


\begin{DoxyCode}
1026 \{
1027   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1028 
1029   PacketList::iterator it;
1030   \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} beginOfCurrentPkt = \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq};
1031 
1032   \textcolor{keywordflow}{for} (it = \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.begin (); it != \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.end (); ++it)
1033     \{
1034       (*it)->m\_sacked = \textcolor{keyword}{false};
1035       beginOfCurrentPkt += (*it)->m\_packet->GetSize ();
1036     \}
1037 
1038   \hyperlink{classns3_1_1TcpTxBuffer_a224ded405afbf30d8828c8ddd16b29d9}{m\_highestSack} = std::make\_pair (\hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.end (), 
      \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} (0));
1039 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Reset\+Sent\+List@{Reset\+Sent\+List}}
\index{Reset\+Sent\+List@{Reset\+Sent\+List}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Reset\+Sent\+List()}{ResetSentList()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+Tx\+Buffer\+::\+Reset\+Sent\+List (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpTxBuffer_acefebd565120f38dfaec17264443eef9}{}\label{classns3_1_1TcpTxBuffer_acefebd565120f38dfaec17264443eef9}


Reset the sent list. 

Move all the packets (except the H\+E\+AD) from the sent list to the app\+List. The head is then marked as un-\/sacked, un-\/retransmitted, and lost. 
\begin{DoxyCode}
1043 \{
1044   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1045   TcpTxItem *item;
1046 
1047   \textcolor{comment}{// Keep the head; it will then marked as retransmitted.}
1048   \textcolor{keywordflow}{while} (\hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.size () > 1)
1049     \{
1050       item = \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.back ();
1051       item->m\_retrans = item->m\_sacked = \textcolor{keyword}{false};
1052       \hyperlink{classns3_1_1TcpTxBuffer_ac85673c102b50188282a70152cc542ca}{m\_appList}.push\_front (item);
1053       \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.pop\_back ();
1054     \}
1055 
1056   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.size () > 0)
1057     \{
1058       item = \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.back ();
1059       item->m\_lost = \textcolor{keyword}{true};
1060       item->m\_sacked = \textcolor{keyword}{false};
1061       item->m\_retrans = \textcolor{keyword}{false};
1062       \hyperlink{classns3_1_1TcpTxBuffer_ae45302ec0a3b3d757b0f3ad85e88e363}{m\_sentSize} = item->m\_packet->GetSize ();
1063     \}
1064   \textcolor{keywordflow}{else}
1065     \{
1066       \hyperlink{classns3_1_1TcpTxBuffer_ae45302ec0a3b3d757b0f3ad85e88e363}{m\_sentSize} = 0;
1067     \}
1068 
1069   \hyperlink{classns3_1_1TcpTxBuffer_a224ded405afbf30d8828c8ddd16b29d9}{m\_highestSack} = std::make\_pair (\hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.end (), 
      \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} (0));
1070 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 29


\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Set\+Head\+Sequence@{Set\+Head\+Sequence}}
\index{Set\+Head\+Sequence@{Set\+Head\+Sequence}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Set\+Head\+Sequence(const Sequence\+Number32 \&seq)}{SetHeadSequence(const SequenceNumber32 &seq)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+Tx\+Buffer\+::\+Set\+Head\+Sequence (
\begin{DoxyParamCaption}
\item[{const {\bf Sequence\+Number32} \&}]{seq}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpTxBuffer_ae9d25292f14d338abe26a2657e103921}{}\label{classns3_1_1TcpTxBuffer_ae9d25292f14d338abe26a2657e103921}


Set the head sequence of the buffer. 

Set the head (m\+\_\+first\+Byte\+Seq) to seq. Supposed to be called only when the connection is just set up and we did not send any data out yet. 
\begin{DoxyParams}{Parameters}
{\em seq} & The sequence number of the head byte \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
176 \{
177   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << seq);
178   \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq} = seq;
179 
180   \textcolor{comment}{// if you change the head with data already sent, something bad will happen}
181   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.size () == 0);
182   \hyperlink{classns3_1_1TcpTxBuffer_a224ded405afbf30d8828c8ddd16b29d9}{m\_highestSack} = std::make\_pair (\hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.end (), 
      \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} (0));
183 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 30


\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Set\+Max\+Buffer\+Size@{Set\+Max\+Buffer\+Size}}
\index{Set\+Max\+Buffer\+Size@{Set\+Max\+Buffer\+Size}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Set\+Max\+Buffer\+Size(uint32\+\_\+t n)}{SetMaxBufferSize(uint32_t n)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+Tx\+Buffer\+::\+Set\+Max\+Buffer\+Size (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{n}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpTxBuffer_acfcca2382edeeefb01f39369585b5d6b}{}\label{classns3_1_1TcpTxBuffer_acfcca2382edeeefb01f39369585b5d6b}


Set the maximum buffer size. 


\begin{DoxyParams}{Parameters}
{\em n} & Tx window size (in bytes) \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
164 \{
165   \hyperlink{classns3_1_1TcpTxBuffer_a4e661fb54fabfe319c6fc15f7080526f}{m\_maxBuffer} = \hyperlink{namespacesample-rng-plot_aeb5ee5c431e338ef39b7ac5431242e1d}{n};
166 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Set\+Sent\+List\+Lost@{Set\+Sent\+List\+Lost}}
\index{Set\+Sent\+List\+Lost@{Set\+Sent\+List\+Lost}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Set\+Sent\+List\+Lost()}{SetSentListLost()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+Tx\+Buffer\+::\+Set\+Sent\+List\+Lost (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpTxBuffer_ae8f6a815193ad7280815a70b91aac72f}{}\label{classns3_1_1TcpTxBuffer_ae8f6a815193ad7280815a70b91aac72f}


Set the entire sent list as lost (typically after an R\+TO) 

Used to set all the sent list as lost, so the bytes in flight is not counting them as in flight, but we will continue to use S\+A\+CK informations for recovering the timeout. 
\begin{DoxyCode}
1088 \{
1089   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1090 
1091   PacketList::iterator it;
1092 
1093   \textcolor{keywordflow}{for} (it = \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.begin (); it != \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.end (); ++it)
1094     \{
1095       (*it)->m\_lost = \textcolor{keyword}{true};
1096     \}
1097 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Size@{Size}}
\index{Size@{Size}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Size(void) const }{Size(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Tcp\+Tx\+Buffer\+::\+Size (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1TcpTxBuffer_a24621b9d6f583bbbe4567b239901176b}{}\label{classns3_1_1TcpTxBuffer_a24621b9d6f583bbbe4567b239901176b}


Returns total number of bytes in this buffer. 

\begin{DoxyReturn}{Returns}
total number of bytes in this Tx buffer 
\end{DoxyReturn}

\begin{DoxyCode}
152 \{
153   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpTxBuffer_ace81d07d65ea00d9609dcc65a926564c}{m\_size};
154 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 31


\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Size\+From\+Sequence@{Size\+From\+Sequence}}
\index{Size\+From\+Sequence@{Size\+From\+Sequence}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Size\+From\+Sequence(const Sequence\+Number32 \&seq) const }{SizeFromSequence(const SequenceNumber32 &seq) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Tcp\+Tx\+Buffer\+::\+Size\+From\+Sequence (
\begin{DoxyParamCaption}
\item[{const {\bf Sequence\+Number32} \&}]{seq}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1TcpTxBuffer_a6e44c34fdb2c14dcc11dbbe86d8b328a}{}\label{classns3_1_1TcpTxBuffer_a6e44c34fdb2c14dcc11dbbe86d8b328a}


Returns the number of bytes from the buffer in the range \mbox{[}seq, tail\+Sequence) 


\begin{DoxyParams}{Parameters}
{\em seq} & initial sequence number \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of bytes from the buffer in the range 
\end{DoxyReturn}

\begin{DoxyCode}
211 \{
212   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << seq);
213   \textcolor{comment}{// Sequence of last byte in buffer}
214   \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} lastSeq = \hyperlink{classns3_1_1TcpTxBuffer_a1c2dbb57cd4581054e57ee8ae0cbfb06}{TailSequence} ();
215 
216   \textcolor{keywordflow}{if} (lastSeq >= seq)
217     \{
218       \textcolor{keywordflow}{return} lastSeq - seq;
219     \}
220 
221   \hyperlink{group__logging_ga0261a8db1d4ac5f79417d117634fd455}{NS\_LOG\_ERROR} (\textcolor{stringliteral}{"Requested a sequence beyond our space ("} << seq << \textcolor{stringliteral}{" > "} << lastSeq <<
222                 \textcolor{stringliteral}{"). Returning 0 for convenience."});
223   \textcolor{keywordflow}{return} 0;
224 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 32




Here is the caller graph for this function\+:
% FIG 33


\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Split\+Items@{Split\+Items}}
\index{Split\+Items@{Split\+Items}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Split\+Items(\+Tcp\+Tx\+Item \&t1, Tcp\+Tx\+Item \&t2, uint32\+\_\+t size) const }{SplitItems(TcpTxItem &t1, TcpTxItem &t2, uint32_t size) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+Tx\+Buffer\+::\+Split\+Items (
\begin{DoxyParamCaption}
\item[{{\bf Tcp\+Tx\+Item} \&}]{t1, }
\item[{{\bf Tcp\+Tx\+Item} \&}]{t2, }
\item[{uint32\+\_\+t}]{size}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpTxBuffer_a34d85565e5a51b10a33444ed47415f2f}{}\label{classns3_1_1TcpTxBuffer_a34d85565e5a51b10a33444ed47415f2f}


Split one \hyperlink{classns3_1_1TcpTxItem}{Tcp\+Tx\+Item}. 

Move \char`\"{}size\char`\"{} bytes from t2 into t1, copying all the fields.


\begin{DoxyParams}{Parameters}
{\em t1} & first item \\
\hline
{\em t2} & second item \\
\hline
{\em size} & Size to split \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
366 \{
367   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << size);
368 
369   t1.m\_packet = t2.m\_packet->CreateFragment (0, size);
370   t2.m\_packet->RemoveAtStart (size);
371 
372   t1.m\_sacked = t2.m\_sacked;
373   t1.m\_lastSent = t2.m\_lastSent;
374   t1.m\_retrans = t2.m\_retrans;
375   t1.m\_lost = t2.m\_lost;
376 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 34




Here is the caller graph for this function\+:
% FIG 35


\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Tail\+Sequence@{Tail\+Sequence}}
\index{Tail\+Sequence@{Tail\+Sequence}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Tail\+Sequence(void) const }{TailSequence(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Sequence\+Number32} ns3\+::\+Tcp\+Tx\+Buffer\+::\+Tail\+Sequence (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1TcpTxBuffer_a1c2dbb57cd4581054e57ee8ae0cbfb06}{}\label{classns3_1_1TcpTxBuffer_a1c2dbb57cd4581054e57ee8ae0cbfb06}


Get the sequence number of the buffer tail (plus one) 

\begin{DoxyReturn}{Returns}
the last byte\textquotesingle{}s sequence number + 1 
\end{DoxyReturn}

\begin{DoxyCode}
146 \{
147   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq} + \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} (\hyperlink{classns3_1_1TcpTxBuffer_ace81d07d65ea00d9609dcc65a926564c}{m\_size});
148 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 36


\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!Update@{Update}}
\index{Update@{Update}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{Update(const Tcp\+Option\+Sack\+::\+Sack\+List \&list)}{Update(const TcpOptionSack::SackList &list)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Tcp\+Tx\+Buffer\+::\+Update (
\begin{DoxyParamCaption}
\item[{const {\bf Tcp\+Option\+Sack\+::\+Sack\+List} \&}]{list}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpTxBuffer_abed2d31821b2d946068c517195f5cc61}{}\label{classns3_1_1TcpTxBuffer_abed2d31821b2d946068c517195f5cc61}


Update the scoreboard. 


\begin{DoxyParams}{Parameters}
{\em list} & list of S\+A\+C\+Ked blocks \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true in case of an update 
\end{DoxyReturn}

\begin{DoxyCode}
662 \{
663   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
664 
665   \textcolor{keywordtype}{bool} modified = \textcolor{keyword}{false};
666   TcpOptionSack::SackList::const\_iterator option\_it;
667   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Updating scoreboard, got "} << \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{list}.size () << \textcolor{stringliteral}{" blocks to analyze"});
668   \textcolor{keywordflow}{for} (option\_it = \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{list}.begin (); option\_it != \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{list}.end (); ++option\_it)
669     \{
670       Ptr<Packet> current;
671       TcpTxItem *item;
672       \textcolor{keyword}{const} \hyperlink{classns3_1_1TcpOptionSack_a9e1d07d8729fd3ac5ead7305794675c3}{TcpOptionSack::SackBlock} \hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b} = (*option\_it);
673 
674       PacketList::iterator item\_it = \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.begin ();
675       \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} beginOfCurrentPacket = \hyperlink{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{m\_firstByteSeq};
676 
677       \textcolor{keywordflow}{while} (item\_it != \hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.end ())
678         \{
679           item = *item\_it;
680           current = item->m\_packet;
681 
682           \textcolor{comment}{// Check the boundary of this packet ... only mark as sacked if}
683           \textcolor{comment}{// it is precisely mapped over the option}
684           \textcolor{keywordflow}{if} (beginOfCurrentPacket >= b.first
685               && beginOfCurrentPacket + current->GetSize () <= b.second)
686             \{
687               \textcolor{keywordflow}{if} (item->m\_sacked)
688                 \{
689                   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Received block ["} << b.first << \textcolor{stringliteral}{";"} << b.second <<
690                                \textcolor{stringliteral}{", checking sentList for block "} << beginOfCurrentPacket <<
691                                \textcolor{stringliteral}{";"} << beginOfCurrentPacket + current->GetSize () <<
692                                \textcolor{stringliteral}{"], found in the sackboard already sacked"});
693                 \}
694               \textcolor{keywordflow}{else}
695                 \{
696                   item->m\_sacked = \textcolor{keyword}{true};
697                   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Received block ["} << b.first << \textcolor{stringliteral}{";"} << b.second <<
698                                \textcolor{stringliteral}{", checking sentList for block "} << beginOfCurrentPacket <<
699                                \textcolor{stringliteral}{";"} << beginOfCurrentPacket + current->GetSize () <<
700                                \textcolor{stringliteral}{"], found in the sackboard, sacking"});
701                   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TcpTxBuffer_a224ded405afbf30d8828c8ddd16b29d9}{m\_highestSack}.second <= beginOfCurrentPacket + current->GetSize ())
702                     \{
703                       PacketList::iterator new\_it = item\_it;
704                       \hyperlink{classns3_1_1TcpTxBuffer_a224ded405afbf30d8828c8ddd16b29d9}{m\_highestSack} = std::make\_pair (++new\_it, beginOfCurrentPacket+current->
      GetSize ());
705                     \}
706                 \}
707               modified = \textcolor{keyword}{true};
708             \}
709           \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (beginOfCurrentPacket + current->GetSize () > b.second)
710             \{
711               \textcolor{comment}{// we missed the block. It's useless to iterate again; Say "ciao"}
712               \textcolor{comment}{// to the loop for optimization purposes}
713               \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Received block ["} << b.first << \textcolor{stringliteral}{";"} << b.second <<
714                            \textcolor{stringliteral}{", checking sentList for block "} << beginOfCurrentPacket <<
715                            \textcolor{stringliteral}{";"} << beginOfCurrentPacket + current->GetSize () <<
716                            \textcolor{stringliteral}{"], not found, breaking loop"});
717               \textcolor{keywordflow}{break};
718             \}
719 
720           beginOfCurrentPacket += current->GetSize ();
721           ++item\_it;
722         \}
723     \}
724 
725   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} ((*(\hyperlink{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{m\_sentList}.begin ()))->m\_sacked == \textcolor{keyword}{false});
726 
727   \textcolor{keywordflow}{return} modified;
728 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 37




Here is the caller graph for this function\+:
% FIG 38




\subsection{Friends And Related Function Documentation}
\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{operator$<$$<$}{operator<<}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os, }
\item[{{\bf Tcp\+Tx\+Buffer} const \&}]{tcp\+Tx\+Buf}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [friend]}}\hypertarget{classns3_1_1TcpTxBuffer_ac79ac25be6b4aef60bb3fdb7b6c64528}{}\label{classns3_1_1TcpTxBuffer_ac79ac25be6b4aef60bb3fdb7b6c64528}


Output operator. 


\begin{DoxyParams}{Parameters}
{\em os} & The output stream. \\
\hline
{\em tcp\+Tx\+Buf} & the \hyperlink{classns3_1_1TcpTxBuffer}{Tcp\+Tx\+Buffer} to print. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The output stream. 
\end{DoxyReturn}

\begin{DoxyCode}
1208 \{
1209   TcpTxBuffer::PacketList::const\_iterator it;
1210   std::stringstream ss;
1211   \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} beginOfCurrentPacket = tcpTxBuf.m\_firstByteSeq;
1212   uint32\_t sentSize = 0, appSize = 0;
1213 
1214   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p};
1215   \textcolor{keywordflow}{for} (it = tcpTxBuf.m\_sentList.begin (); it != tcpTxBuf.m\_sentList.end (); ++it)
1216     \{
1217       p = (*it)->m\_packet;
1218       ss << \textcolor{stringliteral}{"["} << beginOfCurrentPacket << \textcolor{stringliteral}{";"}
1219          << beginOfCurrentPacket + p->GetSize () << \textcolor{stringliteral}{"|"} << p->GetSize () << \textcolor{stringliteral}{"|"};
1220       (*it)->Print (ss);
1221       ss << \textcolor{stringliteral}{"]"};
1222       sentSize += p->GetSize ();
1223       beginOfCurrentPacket += p->GetSize ();
1224     \}
1225 
1226   \textcolor{keywordflow}{for} (it = tcpTxBuf.m\_appList.begin (); it != tcpTxBuf.m\_appList.end (); ++it)
1227     \{
1228       appSize += (*it)->m\_packet->GetSize ();
1229     \}
1230 
1231   os << \textcolor{stringliteral}{"Sent list: "} << ss.str () << \textcolor{stringliteral}{", size = "} << tcpTxBuf.m\_sentList.size () <<
1232     \textcolor{stringliteral}{" Total size: "} << tcpTxBuf.m\_size <<
1233     \textcolor{stringliteral}{" m\_firstByteSeq = "} << tcpTxBuf.m\_firstByteSeq <<
1234     \textcolor{stringliteral}{" m\_sentSize = "} << tcpTxBuf.m\_sentSize;
1235 
1236   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (sentSize == tcpTxBuf.m\_sentSize);
1237   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (tcpTxBuf.m\_size - tcpTxBuf.m\_sentSize == appSize);
1238   \textcolor{keywordflow}{return} os;
1239 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!m\+\_\+app\+List@{m\+\_\+app\+List}}
\index{m\+\_\+app\+List@{m\+\_\+app\+List}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{m\+\_\+app\+List}{m_appList}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Packet\+List} ns3\+::\+Tcp\+Tx\+Buffer\+::m\+\_\+app\+List\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpTxBuffer_ac85673c102b50188282a70152cc542ca}{}\label{classns3_1_1TcpTxBuffer_ac85673c102b50188282a70152cc542ca}


\hyperlink{classns3_1_1Buffer}{Buffer} for application data. 

\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!m\+\_\+first\+Byte\+Seq@{m\+\_\+first\+Byte\+Seq}}
\index{m\+\_\+first\+Byte\+Seq@{m\+\_\+first\+Byte\+Seq}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{m\+\_\+first\+Byte\+Seq}{m_firstByteSeq}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Value}$<${\bf Sequence\+Number32}$>$ ns3\+::\+Tcp\+Tx\+Buffer\+::m\+\_\+first\+Byte\+Seq\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}{}\label{classns3_1_1TcpTxBuffer_a46b67e5cb3396b43a41dd3fd5b135346}


Sequence number of the first byte in data (S\+N\+D.\+U\+NA) 

\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!m\+\_\+highest\+Sack@{m\+\_\+highest\+Sack}}
\index{m\+\_\+highest\+Sack@{m\+\_\+highest\+Sack}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{m\+\_\+highest\+Sack}{m_highestSack}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::pair$<$Packet\+List\+::const\+\_\+iterator, {\bf Sequence\+Number32}$>$ ns3\+::\+Tcp\+Tx\+Buffer\+::m\+\_\+highest\+Sack\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpTxBuffer_a224ded405afbf30d8828c8ddd16b29d9}{}\label{classns3_1_1TcpTxBuffer_a224ded405afbf30d8828c8ddd16b29d9}


Highest S\+A\+CK byte. 

\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!m\+\_\+max\+Buffer@{m\+\_\+max\+Buffer}}
\index{m\+\_\+max\+Buffer@{m\+\_\+max\+Buffer}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Buffer}{m_maxBuffer}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Tcp\+Tx\+Buffer\+::m\+\_\+max\+Buffer\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpTxBuffer_a4e661fb54fabfe319c6fc15f7080526f}{}\label{classns3_1_1TcpTxBuffer_a4e661fb54fabfe319c6fc15f7080526f}


Max number of data bytes in buffer (S\+N\+D.\+W\+ND) 

\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!m\+\_\+sent\+List@{m\+\_\+sent\+List}}
\index{m\+\_\+sent\+List@{m\+\_\+sent\+List}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{m\+\_\+sent\+List}{m_sentList}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Packet\+List} ns3\+::\+Tcp\+Tx\+Buffer\+::m\+\_\+sent\+List\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}{}\label{classns3_1_1TcpTxBuffer_ae131f4743f4537f3606db664874440e5}


\hyperlink{classns3_1_1Buffer}{Buffer} for sent (but not acked) data. 

\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!m\+\_\+sent\+Size@{m\+\_\+sent\+Size}}
\index{m\+\_\+sent\+Size@{m\+\_\+sent\+Size}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{m\+\_\+sent\+Size}{m_sentSize}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Tcp\+Tx\+Buffer\+::m\+\_\+sent\+Size\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpTxBuffer_ae45302ec0a3b3d757b0f3ad85e88e363}{}\label{classns3_1_1TcpTxBuffer_ae45302ec0a3b3d757b0f3ad85e88e363}


Size of sent (and not discarded) segments. 

\index{ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}!m\+\_\+size@{m\+\_\+size}}
\index{m\+\_\+size@{m\+\_\+size}!ns3\+::\+Tcp\+Tx\+Buffer@{ns3\+::\+Tcp\+Tx\+Buffer}}
\subsubsection[{\texorpdfstring{m\+\_\+size}{m_size}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Tcp\+Tx\+Buffer\+::m\+\_\+size\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpTxBuffer_ace81d07d65ea00d9609dcc65a926564c}{}\label{classns3_1_1TcpTxBuffer_ace81d07d65ea00d9609dcc65a926564c}


Size of all data in this buffer. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/model/\hyperlink{tcp-tx-buffer_8h}{tcp-\/tx-\/buffer.\+h}\item 
internet/model/\hyperlink{tcp-tx-buffer_8cc}{tcp-\/tx-\/buffer.\+cc}\end{DoxyCompactItemize}
