\hypertarget{classns3_1_1TapFdNetDeviceHelper}{}\section{ns3\+:\+:Tap\+Fd\+Net\+Device\+Helper Class Reference}
\label{classns3_1_1TapFdNetDeviceHelper}\index{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}}


build a set of \hyperlink{classns3_1_1FdNetDevice}{Fd\+Net\+Device} objects attached to a virtual T\+AP network interface  




{\ttfamily \#include $<$tap-\/fd-\/net-\/device-\/helper.\+h$>$}



Inheritance diagram for ns3\+:\+:Tap\+Fd\+Net\+Device\+Helper\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Tap\+Fd\+Net\+Device\+Helper\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1TapFdNetDeviceHelper_a8fd2e74889845dd82ad218501fc84fe1}{Tap\+Fd\+Net\+Device\+Helper} ()
\item 
virtual \hyperlink{classns3_1_1TapFdNetDeviceHelper_ad29875a77f9624528fb62f428b3c763b}{$\sim$\+Tap\+Fd\+Net\+Device\+Helper} ()
\item 
void \hyperlink{classns3_1_1TapFdNetDeviceHelper_aa514fd85b9be3d13b2402c2dc0ac8a6d}{Set\+Mode\+Pi} (bool pi)
\item 
void \hyperlink{classns3_1_1TapFdNetDeviceHelper_aa1283be36ca8f45294ff480566994f97}{Set\+Tap\+Ipv4\+Address} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} address)
\item 
void \hyperlink{classns3_1_1TapFdNetDeviceHelper_a727c7402978ea7425cf4d4d16cb73783}{Set\+Tap\+Ipv4\+Mask} (\hyperlink{classns3_1_1Ipv4Mask}{Ipv4\+Mask} mask)
\item 
void \hyperlink{classns3_1_1TapFdNetDeviceHelper_ac908bf6fcd13070349828534ee99252c}{Set\+Tap\+Ipv6\+Address} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} address)
\item 
void \hyperlink{classns3_1_1TapFdNetDeviceHelper_a56f44b68da0b264d7927824cae50785a}{Set\+Tap\+Ipv6\+Prefix} (int prefix)
\item 
void \hyperlink{classns3_1_1TapFdNetDeviceHelper_a2446339448910b2895b5374895c57d4c}{Set\+Tap\+Mac\+Address} (\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} mac)
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ \hyperlink{classns3_1_1TapFdNetDeviceHelper_a5b95f44885b6b5a5285604be0c6fa413}{Install\+Priv} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node) const 
\item 
virtual void \hyperlink{classns3_1_1TapFdNetDeviceHelper_a8f1a78ce4fcf68db89d9acfccd6a3165}{Set\+File\+Descriptor} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1FdNetDevice}{Fd\+Net\+Device} $>$ device) const 
\item 
virtual int \hyperlink{classns3_1_1TapFdNetDeviceHelper_a096fe572156c6f315ca33f30d93e41c1}{Create\+File\+Descriptor} (void) const 
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classns3_1_1TapFdNetDeviceHelper_a4d9d824e6c5ac46ac9ebc34740cedd2b}{m\+\_\+mode\+Pi}
\item 
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \hyperlink{classns3_1_1TapFdNetDeviceHelper_a7f090cc7edb3f77def84e7a47614e3f4}{m\+\_\+tap\+Ip4}
\item 
\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} \hyperlink{classns3_1_1TapFdNetDeviceHelper_a6538c02cba836fd1b88779ea48d5d947}{m\+\_\+tap\+Ip6}
\item 
\hyperlink{classns3_1_1Ipv4Mask}{Ipv4\+Mask} \hyperlink{classns3_1_1TapFdNetDeviceHelper_a74e547cfb30f02bc0987a78c7c2465ee}{m\+\_\+tap\+Mask4}
\item 
int \hyperlink{classns3_1_1TapFdNetDeviceHelper_a9d2b4e1c9fcff1a2b254681f0e8f3719}{m\+\_\+tap\+Prefix6}
\item 
\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} \hyperlink{classns3_1_1TapFdNetDeviceHelper_a9a9956264595716d15dce3a036621437}{m\+\_\+tap\+Mac}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
build a set of \hyperlink{classns3_1_1FdNetDevice}{Fd\+Net\+Device} objects attached to a virtual T\+AP network interface 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}!Tap\+Fd\+Net\+Device\+Helper@{Tap\+Fd\+Net\+Device\+Helper}}
\index{Tap\+Fd\+Net\+Device\+Helper@{Tap\+Fd\+Net\+Device\+Helper}!ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{Tap\+Fd\+Net\+Device\+Helper()}{TapFdNetDeviceHelper()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Tap\+Fd\+Net\+Device\+Helper\+::\+Tap\+Fd\+Net\+Device\+Helper (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TapFdNetDeviceHelper_a8fd2e74889845dd82ad218501fc84fe1}{}\label{classns3_1_1TapFdNetDeviceHelper_a8fd2e74889845dd82ad218501fc84fe1}
Construct a \hyperlink{classns3_1_1TapFdNetDeviceHelper}{Tap\+Fd\+Net\+Device\+Helper}. 
\begin{DoxyCode}
64 \{
65   \hyperlink{classns3_1_1EmuFdNetDeviceHelper_a5c259590827f139ae1189a99addeca6a}{m\_deviceName} = \textcolor{stringliteral}{""};
66   \hyperlink{classns3_1_1TapFdNetDeviceHelper_a4d9d824e6c5ac46ac9ebc34740cedd2b}{m\_modePi} = \textcolor{keyword}{false};
67   \hyperlink{classns3_1_1TapFdNetDeviceHelper_a7f090cc7edb3f77def84e7a47614e3f4}{m\_tapIp4} = \hyperlink{classns3_1_1Ipv4Address_aeeb1c76b35d4ab612fda7bc51e99c5db}{Ipv4Address::GetZero} ();
68   \hyperlink{classns3_1_1TapFdNetDeviceHelper_a74e547cfb30f02bc0987a78c7c2465ee}{m\_tapMask4} = \hyperlink{classns3_1_1Ipv4Mask_ac2dda492011ede8350008d753d278998}{Ipv4Mask::GetZero} ();
69   \hyperlink{classns3_1_1TapFdNetDeviceHelper_a6538c02cba836fd1b88779ea48d5d947}{m\_tapIp6} = \hyperlink{classns3_1_1Ipv6Address_a63a34bdb1505e05fbdd07d316d0bd7e6}{Ipv6Address::GetZero} ();
70   \hyperlink{classns3_1_1TapFdNetDeviceHelper_a9d2b4e1c9fcff1a2b254681f0e8f3719}{m\_tapPrefix6} = 64;
71   \hyperlink{classns3_1_1TapFdNetDeviceHelper_a9a9956264595716d15dce3a036621437}{m\_tapMac} = \hyperlink{classns3_1_1Mac48Address_a203b53c035649c0d4881fa1115aa2cdb}{Mac48Address::Allocate} ();
72 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}!````~Tap\+Fd\+Net\+Device\+Helper@{$\sim$\+Tap\+Fd\+Net\+Device\+Helper}}
\index{````~Tap\+Fd\+Net\+Device\+Helper@{$\sim$\+Tap\+Fd\+Net\+Device\+Helper}!ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{$\sim$\+Tap\+Fd\+Net\+Device\+Helper()}{~TapFdNetDeviceHelper()}}]{\setlength{\rightskip}{0pt plus 5cm}virtual ns3\+::\+Tap\+Fd\+Net\+Device\+Helper\+::$\sim$\+Tap\+Fd\+Net\+Device\+Helper (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1TapFdNetDeviceHelper_ad29875a77f9624528fb62f428b3c763b}{}\label{classns3_1_1TapFdNetDeviceHelper_ad29875a77f9624528fb62f428b3c763b}

\begin{DoxyCode}
50   \{
51   \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3




\subsection{Member Function Documentation}
\index{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}!Create\+File\+Descriptor@{Create\+File\+Descriptor}}
\index{Create\+File\+Descriptor@{Create\+File\+Descriptor}!ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{Create\+File\+Descriptor(void) const }{CreateFileDescriptor(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Tap\+Fd\+Net\+Device\+Helper\+::\+Create\+File\+Descriptor (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1TapFdNetDeviceHelper_a096fe572156c6f315ca33f30d93e41c1}{}\label{classns3_1_1TapFdNetDeviceHelper_a096fe572156c6f315ca33f30d93e41c1}
Call out to a separate process running as suid root in order to create a T\+AP device and obtain the file descriptor associated to it. 

Reimplemented from \hyperlink{classns3_1_1EmuFdNetDeviceHelper_a64392b0acfeddf0121b251bc7e6e8906}{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper}.


\begin{DoxyCode}
146 \{
147   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
148 
149   \textcolor{comment}{//}
150   \textcolor{comment}{// We're going to fork and exec that program soon, but first we need to have}
151   \textcolor{comment}{// a socket to talk to it with.  So we create a local interprocess (Unix)}
152   \textcolor{comment}{// socket for that purpose.}
153   \textcolor{comment}{//}
154   \textcolor{keywordtype}{int} sock = socket (PF\_UNIX, SOCK\_DGRAM, 0);
155   \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (sock == -1, \textcolor{stringliteral}{"TapFdNetDeviceHelper::CreateFileDescriptor(): Unix socket
       creation error, errno = "} << strerror (errno));
156 
157   \textcolor{comment}{//}
158   \textcolor{comment}{// Bind to that socket and let the kernel allocate an endpoint}
159   \textcolor{comment}{//}
160   \textcolor{keyword}{struct }sockaddr\_un un;
161   memset (&un, 0, \textcolor{keyword}{sizeof} (un));
162   un.sun\_family = AF\_UNIX;
163   \textcolor{keywordtype}{int} status = bind (sock, (\textcolor{keyword}{struct} sockaddr*)&un, \textcolor{keyword}{sizeof} (sa\_family\_t));
164   \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (status == -1, \textcolor{stringliteral}{"TapFdNetDeviceHelper::CreateFileDescriptor(): Could not
       bind(): errno = "} << strerror (errno));
165   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Created Unix socket"});
166   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"sun\_family = "} << un.sun\_family);
167   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"sun\_path = "} << un.sun\_path);
168 
169   \textcolor{comment}{//}
170   \textcolor{comment}{// We have a socket here, but we want to get it there -- to the program we're}
171   \textcolor{comment}{// going to exec.  What we'll do is to do a getsockname and then encode the}
172   \textcolor{comment}{// resulting address information as a string, and then send the string to the}
173   \textcolor{comment}{// program as an argument.  So we need to get the sock name.}
174   \textcolor{comment}{//}
175   socklen\_t len = \textcolor{keyword}{sizeof} (un);
176   status = getsockname (sock, (\textcolor{keyword}{struct} sockaddr*)&un, &len);
177   \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (status == -1, \textcolor{stringliteral}{"TapFdNetDeviceHelper::CreateFileDescriptor(): Could not
       getsockname(): errno = "} << strerror (errno));
178 
179   \textcolor{comment}{//}
180   \textcolor{comment}{// Now encode that socket name (family and path) as a string of hex digits}
181   \textcolor{comment}{//}
182   std::string path = \hyperlink{namespacens3_a97907497171f00140c77ed054e3baad6}{BufferToString} ((uint8\_t *)&un, len);
183   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Encoded Unix socket as \(\backslash\)""} << path << \textcolor{stringliteral}{"\(\backslash\)""});
184 
185   \textcolor{comment}{//}
186   \textcolor{comment}{// Fork and exec the process to create our socket.  If we're us (the parent)}
187   \textcolor{comment}{// we wait for the child (the creator) to complete and read the socket it}
188   \textcolor{comment}{// created and passed back using the ancillary data mechanism.}
189   \textcolor{comment}{//}
190   pid\_t pid = ::fork ();
191   \textcolor{keywordflow}{if} (pid == 0)
192     \{
193       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Child process"});
194 
195       \textcolor{comment}{//}
196       \textcolor{comment}{// build a command line argument from the encoded endpoint string that}
197       \textcolor{comment}{// the socket creation process will use to figure out how to respond to}
198       \textcolor{comment}{// the (now) parent process.  We're going to have to give this program}
199       \textcolor{comment}{// quite a bit of information.}
200       \textcolor{comment}{//}
201       \textcolor{comment}{// -d<device-name> The name of the tap device we want to create;}
202       \textcolor{comment}{// -m<MAC-address> The MAC-48 address to assign to the new tap device;}
203       \textcolor{comment}{// -i<IPv4-address> The IP v4 address to assign to the new tap device;}
204       \textcolor{comment}{// -I<IPv6-address> The IP v6 address to assign to the new tap device;}
205       \textcolor{comment}{// -n<network-IPv4-mask> The network IPv4 mask to assign to the new tap device;}
206       \textcolor{comment}{// -N<network-IPv6-mask> The network IPv6 mask to assign to the new tap device;}
207       \textcolor{comment}{// -t Set teh IFF\_TAP flag}
208       \textcolor{comment}{// -h Set the IFF\_NO\_PI flag}
209       \textcolor{comment}{// -p<path> the path to the unix socket described above.}
210       \textcolor{comment}{//}
211       \textcolor{comment}{// Example tap-creator -dnewdev -i1.2.3.1 -m08:00:2e:00:01:23 -n255.255.255.0 -t -h -pblah}
212       \textcolor{comment}{//}
213 
214       \textcolor{comment}{//}
215       \textcolor{comment}{// The device-name is something we may want the system to make up in}
216       \textcolor{comment}{// every case.  We also rely on it being configured via an Attribute}
217       \textcolor{comment}{// through the helper.  By default, it is set to the empty string}
218       \textcolor{comment}{// which tells the system to make up a device name such as "tap123".}
219       \textcolor{comment}{//}
220       std::ostringstream ossDeviceName;
221       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1EmuFdNetDeviceHelper_a5c259590827f139ae1189a99addeca6a}{m\_deviceName} != \textcolor{stringliteral}{""})
222         \{
223           ossDeviceName << \textcolor{stringliteral}{"-d"} << \hyperlink{classns3_1_1EmuFdNetDeviceHelper_a5c259590827f139ae1189a99addeca6a}{m\_deviceName};
224         \}
225 
226       std::ostringstream ossMac;
227       ossMac << \textcolor{stringliteral}{"-m"} << \hyperlink{classns3_1_1TapFdNetDeviceHelper_a9a9956264595716d15dce3a036621437}{m\_tapMac};
228 
229       std::ostringstream ossIp4;
230       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TapFdNetDeviceHelper_a7f090cc7edb3f77def84e7a47614e3f4}{m\_tapIp4} != \hyperlink{classns3_1_1Ipv4Address_aeeb1c76b35d4ab612fda7bc51e99c5db}{Ipv4Address::GetZero} ())
231         \{
232           ossIp4 << \textcolor{stringliteral}{"-i"} << \hyperlink{classns3_1_1TapFdNetDeviceHelper_a7f090cc7edb3f77def84e7a47614e3f4}{m\_tapIp4};
233         \}
234 
235       std::ostringstream ossIp6;
236       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TapFdNetDeviceHelper_a6538c02cba836fd1b88779ea48d5d947}{m\_tapIp6} != \hyperlink{classns3_1_1Ipv6Address_a63a34bdb1505e05fbdd07d316d0bd7e6}{Ipv6Address::GetZero} ())
237         \{
238           ossIp6 << \textcolor{stringliteral}{"-I"} << \hyperlink{classns3_1_1TapFdNetDeviceHelper_a6538c02cba836fd1b88779ea48d5d947}{m\_tapIp6};
239         \}
240 
241       std::ostringstream ossNetmask4;
242       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TapFdNetDeviceHelper_a74e547cfb30f02bc0987a78c7c2465ee}{m\_tapMask4} != \hyperlink{classns3_1_1Ipv4Mask_ac2dda492011ede8350008d753d278998}{Ipv4Mask::GetZero} () )
243         \{
244           ossNetmask4 << \textcolor{stringliteral}{"-n"} << \hyperlink{classns3_1_1TapFdNetDeviceHelper_a74e547cfb30f02bc0987a78c7c2465ee}{m\_tapMask4};
245         \}
246 
247       std::ostringstream ossPrefix6;
248       ossPrefix6 << \textcolor{stringliteral}{"-P"} << \hyperlink{classns3_1_1TapFdNetDeviceHelper_a9d2b4e1c9fcff1a2b254681f0e8f3719}{m\_tapPrefix6};
249 
250       std::ostringstream ossMode;
251       ossMode << \textcolor{stringliteral}{"-t"};
252 
253       std::ostringstream ossPI;
254       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TapFdNetDeviceHelper_a4d9d824e6c5ac46ac9ebc34740cedd2b}{m\_modePi})
255         \{
256           ossPI << \textcolor{stringliteral}{"-h"};
257         \}
258 
259       std::ostringstream ossPath;
260       ossPath << \textcolor{stringliteral}{"-p"} << path;
261 
262       \textcolor{comment}{//}
263       \textcolor{comment}{// Execute the socket creation process image.}
264       \textcolor{comment}{//}
265       status = ::execlp (TAP\_DEV\_CREATOR,
266                          TAP\_DEV\_CREATOR,                       \textcolor{comment}{// argv[0] (filename)}
267                          ossDeviceName.str ().c\_str (),     \textcolor{comment}{// argv[1] (-d<device name>)}
268                          ossMac.str ().c\_str (),            \textcolor{comment}{// argv[2] (-m<MAC address>}
269                          ossIp4.str ().c\_str (),            \textcolor{comment}{// argv[3] (-i<IP v4 address>)}
270                          ossIp6.str ().c\_str (),            \textcolor{comment}{// argv[4] (-I<IP v6 address>)}
271                          ossNetmask4.str ().c\_str (),       \textcolor{comment}{// argv[5] (-n<IP v4 net mask>)}
272                          ossPrefix6.str ().c\_str (),        \textcolor{comment}{// argv[6] (-P<IP v6 prefix>)}
273                          ossMode.str ().c\_str (),           \textcolor{comment}{// argv[7] (-t <tap>)}
274                          ossPI.str ().c\_str (),             \textcolor{comment}{// argv[8] (-h <pi>)}
275                          ossPath.str ().c\_str (),           \textcolor{comment}{// argv[9] (-p<path>)}
276                          (\textcolor{keywordtype}{char} *)NULL);
277 
278       \textcolor{comment}{//}
279       \textcolor{comment}{// If the execlp successfully completes, it never returns.  If it returns it failed or the OS is}
280       \textcolor{comment}{// broken.  In either case, we bail.}
281       \textcolor{comment}{//}
282       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"TapFdNetDeviceHelper::CreateFileDescriptor(): Back from execlp(),
       status = "} <<
283                       status << \textcolor{stringliteral}{", errno = "} << ::strerror (errno));
284       \}
285   \textcolor{keywordflow}{else}
286     \{
287       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Parent process"});
288       \textcolor{comment}{//}
289       \textcolor{comment}{// We're the process running the emu net device.  We need to wait for the}
290       \textcolor{comment}{// socket creator process to finish its job.}
291       \textcolor{comment}{//}
292       \textcolor{keywordtype}{int} st;
293       pid\_t waited = waitpid (pid, &st, 0);
294       \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (waited == -1, \textcolor{stringliteral}{"TapFdNetDeviceHelper::CreateFileDescriptor():
       waitpid() fails, errno = "} << strerror (errno));
295       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (pid == waited, \textcolor{stringliteral}{"TapFdNetDeviceHelper::CreateFileDescriptor(): pid
       mismatch"});
296 
297       \textcolor{comment}{//}
298       \textcolor{comment}{// Check to see if the socket creator exited normally and then take a}
299       \textcolor{comment}{// look at the exit code.  If it bailed, so should we.  If it didn't}
300       \textcolor{comment}{// even exit normally, we bail too.}
301       \textcolor{comment}{//}
302       \textcolor{keywordflow}{if} (WIFEXITED (st))
303         \{
304           \textcolor{keywordtype}{int} exitStatus = WEXITSTATUS (st);
305           \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (exitStatus != 0,
306                            \textcolor{stringliteral}{"TapFdNetDeviceHelper::CreateFileDescriptor(): socket creator exited normally
       with status "} << exitStatus);
307         \}
308       \textcolor{keywordflow}{else}
309         \{
310           \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"TapFdNetDeviceHelper::CreateFileDescriptor(): socket creator
       exited abnormally"});
311         \}
312 
313       \textcolor{comment}{//}
314       \textcolor{comment}{// At this point, the socket creator has run successfully and should}
315       \textcolor{comment}{// have created our tap device, initialized it with the information we}
316       \textcolor{comment}{// passed and sent it back to the socket address we provided.  A socket}
317       \textcolor{comment}{// (fd) we can use to talk to this tap device should be waiting on the}
318       \textcolor{comment}{// Unix socket we set up to receive information back from the creator}
319       \textcolor{comment}{// program.  We've got to do a bunch of grunt work to get at it, though.}
320       \textcolor{comment}{//}
321       \textcolor{comment}{// The struct iovec below is part of a scatter-gather list.  It describes a}
322       \textcolor{comment}{// buffer.  In this case, it describes a buffer (an integer) that will}
323       \textcolor{comment}{// get the data that comes back from the socket creator process.  It will}
324       \textcolor{comment}{// be a magic number that we use as a consistency/sanity check.}
325       \textcolor{comment}{//}
326       \textcolor{keyword}{struct }iovec iov;
327       uint32\_t magic;
328       iov.iov\_base = &magic;
329       iov.iov\_len = \textcolor{keyword}{sizeof}(magic);
330 
331       \textcolor{comment}{//}
332       \textcolor{comment}{// The CMSG macros you'll see below are used to create and access control}
333       \textcolor{comment}{// messages (which is another name for ancillary data).  The ancillary}
334       \textcolor{comment}{// data is made up of pairs of struct cmsghdr structures and associated}
335       \textcolor{comment}{// data arrays.}
336       \textcolor{comment}{//}
337       \textcolor{comment}{// First, we're going to allocate a buffer on the stack to receive our}
338       \textcolor{comment}{// data array (that contains the socket).  Sometimes you'll see this called}
339       \textcolor{comment}{// an "ancillary element" but the msghdr uses the control message termimology}
340       \textcolor{comment}{// so we call it "control."}
341       \textcolor{comment}{//}
342       \textcolor{keywordtype}{size\_t} msg\_size = \textcolor{keyword}{sizeof}(int);
343       \textcolor{keywordtype}{char} control[CMSG\_SPACE (msg\_size)];
344 
345       \textcolor{comment}{//}
346       \textcolor{comment}{// There is a msghdr that is used to minimize the number of parameters}
347       \textcolor{comment}{// passed to recvmsg (which we will use to receive our ancillary data).}
348       \textcolor{comment}{// This structure uses terminology corresponding to control messages, so}
349       \textcolor{comment}{// you'll see msg\_control, which is the pointer to the ancillary data and}
350       \textcolor{comment}{// controllen which is the size of the ancillary data array.}
351       \textcolor{comment}{//}
352       \textcolor{comment}{// So, initialize the message header that describes the ancillary/control}
353       \textcolor{comment}{// data we expect to receive and point it to buffer.}
354       \textcolor{comment}{//}
355       \textcolor{keyword}{struct }msghdr msg;
356       msg.msg\_name = 0;
357       msg.msg\_namelen = 0;
358       msg.msg\_iov = &iov;
359       msg.msg\_iovlen = 1;
360       msg.msg\_control = control;
361       msg.msg\_controllen = \textcolor{keyword}{sizeof} (control);
362       msg.msg\_flags = 0;
363 
364       \textcolor{comment}{//}
365       \textcolor{comment}{// Now we can actually receive the interesting bits from the tap}
366       \textcolor{comment}{// creator process.  Lots of pain to get four bytes.}
367       \textcolor{comment}{//}
368       ssize\_t bytesRead = recvmsg (sock, &msg, 0);
369       \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (bytesRead != \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}), \textcolor{stringliteral}{"
      TapFdNetDeviceHelper::CreateFileDescriptor(): Wrong byte count from socket creator"});
370 
371       \textcolor{comment}{//}
372       \textcolor{comment}{// There may be a number of message headers/ancillary data arrays coming in.}
373       \textcolor{comment}{// Let's look for the one with a type SCM\_RIGHTS which indicates it's the}
374       \textcolor{comment}{// one we're interested in.}
375       \textcolor{comment}{//}
376       \textcolor{keyword}{struct }cmsghdr *cmsg;
377       \textcolor{keywordflow}{for} (cmsg = CMSG\_FIRSTHDR (&msg); cmsg != NULL; cmsg = CMSG\_NXTHDR (&msg, cmsg))
378         \{
379           \textcolor{keywordflow}{if} (cmsg->cmsg\_level == SOL\_SOCKET
380               && cmsg->cmsg\_type == SCM\_RIGHTS)
381             \{
382               \textcolor{comment}{//}
383               \textcolor{comment}{// This is the type of message we want.  Check to see if the magic}
384               \textcolor{comment}{// number is correct and then pull out the socket we care about if}
385               \textcolor{comment}{// it matches}
386               \textcolor{comment}{//}
387               \textcolor{keywordflow}{if} (magic == \hyperlink{tap-fd-net-device-helper_8cc_af9ac95d538205da6013d79a63fee2bd7}{TAP\_MAGIC})
388                 \{
389                   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Got SCM\_RIGHTS with correct magic "} << magic);
390                   \textcolor{keywordtype}{int} *rawSocket = (\textcolor{keywordtype}{int}*)CMSG\_DATA (cmsg);
391                   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Got the socket from the socket creator = "} << *rawSocket);
392                   \textcolor{keywordflow}{return} *rawSocket;
393                 \}
394               \textcolor{keywordflow}{else}
395                 \{
396                   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Got SCM\_RIGHTS, but with bad magic "} << magic);
397                 \}
398             \}
399         \}
400       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Did not get the raw socket from the socket creator"});
401     \}
402 
403 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4




Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}!Install\+Priv@{Install\+Priv}}
\index{Install\+Priv@{Install\+Priv}!ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{Install\+Priv(\+Ptr$<$ Node $>$ node) const }{InstallPriv(Ptr< Node > node) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Net\+Device} $>$ ns3\+::\+Tap\+Fd\+Net\+Device\+Helper\+::\+Install\+Priv (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1TapFdNetDeviceHelper_a5b95f44885b6b5a5285604be0c6fa413}{}\label{classns3_1_1TapFdNetDeviceHelper_a5b95f44885b6b5a5285604be0c6fa413}
This method creates an \hyperlink{classns3_1_1FdNetDevice}{ns3\+::\+Fd\+Net\+Device} attached to a virtual T\+AP network interface


\begin{DoxyParams}{Parameters}
{\em node} & The node to install the device in \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A container holding the added net device. 
\end{DoxyReturn}


Reimplemented from \hyperlink{classns3_1_1EmuFdNetDeviceHelper_a80562da33cef1c20d4b03b351fbbc21a}{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper}.


\begin{DoxyCode}
112 \{
113   Ptr<NetDevice> \hyperlink{buildings__pathloss_8m_a9f9b934daed17a4d3613b6886ff4cf4b}{d} = \hyperlink{classns3_1_1FdNetDeviceHelper_adf0e4f64b03f7203f7080b50f412a970}{FdNetDeviceHelper::InstallPriv} (node);
114   Ptr<FdNetDevice> device = d->GetObject<FdNetDevice> ();
115 
116   \textcolor{comment}{//}
117   \textcolor{comment}{// We need to explicitly set the encapsulation mode for the traffic}
118   \textcolor{comment}{// traversing the TAP device, so the FdNetDevice is able to know}
119   \textcolor{comment}{// how to treat the traffic in a way that in compatible with the}
120   \textcolor{comment}{// TAP device.}
121   \textcolor{comment}{//}
122   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TapFdNetDeviceHelper_a4d9d824e6c5ac46ac9ebc34740cedd2b}{m\_modePi})
123     \{
124       device->SetEncapsulationMode (\hyperlink{classns3_1_1FdNetDevice_abdacbf10c181f50998a98e7688016618abbad9c0d0fe0604652f21e33cf4d8798}{FdNetDevice::DIXPI});
125     \}
126 
127   \hyperlink{classns3_1_1TapFdNetDeviceHelper_a8f1a78ce4fcf68db89d9acfccd6a3165}{SetFileDescriptor} (device);
128   \textcolor{keywordflow}{return} device;
129 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6




Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}!Set\+File\+Descriptor@{Set\+File\+Descriptor}}
\index{Set\+File\+Descriptor@{Set\+File\+Descriptor}!ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{Set\+File\+Descriptor(\+Ptr$<$ Fd\+Net\+Device $>$ device) const }{SetFileDescriptor(Ptr< FdNetDevice > device) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tap\+Fd\+Net\+Device\+Helper\+::\+Set\+File\+Descriptor (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Fd\+Net\+Device} $>$}]{device}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1TapFdNetDeviceHelper_a8f1a78ce4fcf68db89d9acfccd6a3165}{}\label{classns3_1_1TapFdNetDeviceHelper_a8f1a78ce4fcf68db89d9acfccd6a3165}
Sets a file descriptor on the File\+Descriptor\+Net\+Device. 

Reimplemented from \hyperlink{classns3_1_1EmuFdNetDeviceHelper_ad48e0e01cd07bd76bdc6bf05ed4fa756}{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper}.


\begin{DoxyCode}
133 \{
134   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Creating TAP device"});
135 
136   \textcolor{comment}{//}
137   \textcolor{comment}{// Call out to a separate process running as suid root in order to create a}
138   \textcolor{comment}{// TAP device.  We do this to avoid having the entire simulation running as root.}
139   \textcolor{comment}{//}
140   \textcolor{keywordtype}{int} \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_a44f21d5190b5a6df8089f54799628d7e}{fd} = \hyperlink{classns3_1_1TapFdNetDeviceHelper_a096fe572156c6f315ca33f30d93e41c1}{CreateFileDescriptor} ();
141   device->SetFileDescriptor (fd);
142 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8




Here is the caller graph for this function\+:
% FIG 9


\index{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}!Set\+Mode\+Pi@{Set\+Mode\+Pi}}
\index{Set\+Mode\+Pi@{Set\+Mode\+Pi}!ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{Set\+Mode\+Pi(bool pi)}{SetModePi(bool pi)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tap\+Fd\+Net\+Device\+Helper\+::\+Set\+Mode\+Pi (
\begin{DoxyParamCaption}
\item[{bool}]{pi}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TapFdNetDeviceHelper_aa514fd85b9be3d13b2402c2dc0ac8a6d}{}\label{classns3_1_1TapFdNetDeviceHelper_aa514fd85b9be3d13b2402c2dc0ac8a6d}
Set flag I\+F\+F\+\_\+\+N\+O\+\_\+\+PI on the device.


\begin{DoxyParams}{Parameters}
{\em pi} & Set the I\+F\+F\+\_\+\+N\+O\+\_\+\+PI flag if pi is false. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
76 \{
77   \hyperlink{classns3_1_1TapFdNetDeviceHelper_a4d9d824e6c5ac46ac9ebc34740cedd2b}{m\_modePi} = modePi;
78 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 10


\index{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}!Set\+Tap\+Ipv4\+Address@{Set\+Tap\+Ipv4\+Address}}
\index{Set\+Tap\+Ipv4\+Address@{Set\+Tap\+Ipv4\+Address}!ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{Set\+Tap\+Ipv4\+Address(\+Ipv4\+Address address)}{SetTapIpv4Address(Ipv4Address address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tap\+Fd\+Net\+Device\+Helper\+::\+Set\+Tap\+Ipv4\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{address}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TapFdNetDeviceHelper_aa1283be36ca8f45294ff480566994f97}{}\label{classns3_1_1TapFdNetDeviceHelper_aa1283be36ca8f45294ff480566994f97}
Set the device I\+Pv4 address.


\begin{DoxyParams}{Parameters}
{\em address} & The I\+Pv4 address for the T\+AP device. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
82 \{
83   \hyperlink{classns3_1_1TapFdNetDeviceHelper_a7f090cc7edb3f77def84e7a47614e3f4}{m\_tapIp4} = address;
84 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}!Set\+Tap\+Ipv4\+Mask@{Set\+Tap\+Ipv4\+Mask}}
\index{Set\+Tap\+Ipv4\+Mask@{Set\+Tap\+Ipv4\+Mask}!ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{Set\+Tap\+Ipv4\+Mask(\+Ipv4\+Mask mask)}{SetTapIpv4Mask(Ipv4Mask mask)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tap\+Fd\+Net\+Device\+Helper\+::\+Set\+Tap\+Ipv4\+Mask (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Mask}}]{mask}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TapFdNetDeviceHelper_a727c7402978ea7425cf4d4d16cb73783}{}\label{classns3_1_1TapFdNetDeviceHelper_a727c7402978ea7425cf4d4d16cb73783}
Set the I\+Pv4 network mask for the T\+AP device.


\begin{DoxyParams}{Parameters}
{\em mask} & The I\+Pv4 network mask for the T\+AP device. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
88 \{
89   \hyperlink{classns3_1_1TapFdNetDeviceHelper_a74e547cfb30f02bc0987a78c7c2465ee}{m\_tapMask4} = mask;
90 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 12


\index{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}!Set\+Tap\+Ipv6\+Address@{Set\+Tap\+Ipv6\+Address}}
\index{Set\+Tap\+Ipv6\+Address@{Set\+Tap\+Ipv6\+Address}!ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{Set\+Tap\+Ipv6\+Address(\+Ipv6\+Address address)}{SetTapIpv6Address(Ipv6Address address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tap\+Fd\+Net\+Device\+Helper\+::\+Set\+Tap\+Ipv6\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{address}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TapFdNetDeviceHelper_ac908bf6fcd13070349828534ee99252c}{}\label{classns3_1_1TapFdNetDeviceHelper_ac908bf6fcd13070349828534ee99252c}
Set the device I\+Pv6 address.


\begin{DoxyParams}{Parameters}
{\em address} & The I\+Pv6 address for the T\+AP device. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
94 \{
95   \hyperlink{classns3_1_1TapFdNetDeviceHelper_a6538c02cba836fd1b88779ea48d5d947}{m\_tapIp6} = address;
96 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 13


\index{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}!Set\+Tap\+Ipv6\+Prefix@{Set\+Tap\+Ipv6\+Prefix}}
\index{Set\+Tap\+Ipv6\+Prefix@{Set\+Tap\+Ipv6\+Prefix}!ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{Set\+Tap\+Ipv6\+Prefix(int prefix)}{SetTapIpv6Prefix(int prefix)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tap\+Fd\+Net\+Device\+Helper\+::\+Set\+Tap\+Ipv6\+Prefix (
\begin{DoxyParamCaption}
\item[{int}]{prefix}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TapFdNetDeviceHelper_a56f44b68da0b264d7927824cae50785a}{}\label{classns3_1_1TapFdNetDeviceHelper_a56f44b68da0b264d7927824cae50785a}
Set the I\+Pv6 network mask for the T\+AP device.


\begin{DoxyParams}{Parameters}
{\em prefix} & The I\+Pv6 network prefix for the T\+AP device. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
100 \{
101   \hyperlink{classns3_1_1TapFdNetDeviceHelper_a9d2b4e1c9fcff1a2b254681f0e8f3719}{m\_tapPrefix6} = prefix;
102 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 14


\index{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}!Set\+Tap\+Mac\+Address@{Set\+Tap\+Mac\+Address}}
\index{Set\+Tap\+Mac\+Address@{Set\+Tap\+Mac\+Address}!ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{Set\+Tap\+Mac\+Address(\+Mac48\+Address mac)}{SetTapMacAddress(Mac48Address mac)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tap\+Fd\+Net\+Device\+Helper\+::\+Set\+Tap\+Mac\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Mac48\+Address}}]{mac}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TapFdNetDeviceHelper_a2446339448910b2895b5374895c57d4c}{}\label{classns3_1_1TapFdNetDeviceHelper_a2446339448910b2895b5374895c57d4c}
Set the M\+AC address for the T\+AP device.


\begin{DoxyParams}{Parameters}
{\em mac} & The M\+AC address the T\+AP device. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
106 \{
107   \hyperlink{classns3_1_1TapFdNetDeviceHelper_a9a9956264595716d15dce3a036621437}{m\_tapMac} = mac;
108 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 15




\subsection{Member Data Documentation}
\index{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}!m\+\_\+mode\+Pi@{m\+\_\+mode\+Pi}}
\index{m\+\_\+mode\+Pi@{m\+\_\+mode\+Pi}!ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+mode\+Pi}{m_modePi}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Tap\+Fd\+Net\+Device\+Helper\+::m\+\_\+mode\+Pi\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classns3_1_1TapFdNetDeviceHelper_a4d9d824e6c5ac46ac9ebc34740cedd2b}{}\label{classns3_1_1TapFdNetDeviceHelper_a4d9d824e6c5ac46ac9ebc34740cedd2b}
The T\+AP device flag I\+F\+F\+\_\+\+N\+O\+\_\+\+PI. \index{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}!m\+\_\+tap\+Ip4@{m\+\_\+tap\+Ip4}}
\index{m\+\_\+tap\+Ip4@{m\+\_\+tap\+Ip4}!ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+tap\+Ip4}{m_tapIp4}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Address} ns3\+::\+Tap\+Fd\+Net\+Device\+Helper\+::m\+\_\+tap\+Ip4\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classns3_1_1TapFdNetDeviceHelper_a7f090cc7edb3f77def84e7a47614e3f4}{}\label{classns3_1_1TapFdNetDeviceHelper_a7f090cc7edb3f77def84e7a47614e3f4}
The I\+Pv4 address for the T\+AP device. \index{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}!m\+\_\+tap\+Ip6@{m\+\_\+tap\+Ip6}}
\index{m\+\_\+tap\+Ip6@{m\+\_\+tap\+Ip6}!ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+tap\+Ip6}{m_tapIp6}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+Address} ns3\+::\+Tap\+Fd\+Net\+Device\+Helper\+::m\+\_\+tap\+Ip6\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classns3_1_1TapFdNetDeviceHelper_a6538c02cba836fd1b88779ea48d5d947}{}\label{classns3_1_1TapFdNetDeviceHelper_a6538c02cba836fd1b88779ea48d5d947}
The I\+Pv6 address for the T\+AP device. \index{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}!m\+\_\+tap\+Mac@{m\+\_\+tap\+Mac}}
\index{m\+\_\+tap\+Mac@{m\+\_\+tap\+Mac}!ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+tap\+Mac}{m_tapMac}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Mac48\+Address} ns3\+::\+Tap\+Fd\+Net\+Device\+Helper\+::m\+\_\+tap\+Mac\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classns3_1_1TapFdNetDeviceHelper_a9a9956264595716d15dce3a036621437}{}\label{classns3_1_1TapFdNetDeviceHelper_a9a9956264595716d15dce3a036621437}
The T\+AP device M\+AC address. \index{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}!m\+\_\+tap\+Mask4@{m\+\_\+tap\+Mask4}}
\index{m\+\_\+tap\+Mask4@{m\+\_\+tap\+Mask4}!ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+tap\+Mask4}{m_tapMask4}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Mask} ns3\+::\+Tap\+Fd\+Net\+Device\+Helper\+::m\+\_\+tap\+Mask4\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classns3_1_1TapFdNetDeviceHelper_a74e547cfb30f02bc0987a78c7c2465ee}{}\label{classns3_1_1TapFdNetDeviceHelper_a74e547cfb30f02bc0987a78c7c2465ee}
The network mask I\+Pv4 for the T\+AP device. \index{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}!m\+\_\+tap\+Prefix6@{m\+\_\+tap\+Prefix6}}
\index{m\+\_\+tap\+Prefix6@{m\+\_\+tap\+Prefix6}!ns3\+::\+Tap\+Fd\+Net\+Device\+Helper@{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+tap\+Prefix6}{m_tapPrefix6}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Tap\+Fd\+Net\+Device\+Helper\+::m\+\_\+tap\+Prefix6\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classns3_1_1TapFdNetDeviceHelper_a9d2b4e1c9fcff1a2b254681f0e8f3719}{}\label{classns3_1_1TapFdNetDeviceHelper_a9d2b4e1c9fcff1a2b254681f0e8f3719}
The network prefix I\+Pv6 for the T\+AP device. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
fd-\/net-\/device/helper/\hyperlink{tap-fd-net-device-helper_8h}{tap-\/fd-\/net-\/device-\/helper.\+h}\item 
fd-\/net-\/device/helper/\hyperlink{tap-fd-net-device-helper_8cc}{tap-\/fd-\/net-\/device-\/helper.\+cc}\end{DoxyCompactItemize}
