\hypertarget{classns3_1_1Ipv6RoutingProtocol}{}\section{ns3\+:\+:Ipv6\+Routing\+Protocol Class Reference}
\label{classns3_1_1Ipv6RoutingProtocol}\index{ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}}


Abstract base class for I\+Pv6 routing protocols.  




{\ttfamily \#include $<$ipv6-\/routing-\/protocol.\+h$>$}



Inheritance diagram for ns3\+:\+:Ipv6\+Routing\+Protocol\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Ipv6\+Routing\+Protocol\+:
% FIG 1
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classns3_1_1Callback}{Callback}$<$ void, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Route}{Ipv6\+Route} $>$, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$, const \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} \& $>$ \hyperlink{classns3_1_1Ipv6RoutingProtocol_a579fd6755ee873009819f7117371fea7}{Unicast\+Forward\+Callback}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Callback}{Callback} for unicast packets to be forwarded. \end{DoxyCompactList}\item 
typedef \hyperlink{classns3_1_1Callback}{Callback}$<$ void, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6MulticastRoute}{Ipv6\+Multicast\+Route} $>$, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$, const \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} \& $>$ \hyperlink{classns3_1_1Ipv6RoutingProtocol_a5f12e04512ce8e5808c3cceff6b8918f}{Multicast\+Forward\+Callback}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Callback}{Callback} for multicast packets to be forwarded. \end{DoxyCompactList}\item 
typedef \hyperlink{classns3_1_1Callback}{Callback}$<$ void, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$, const \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} \&, uint32\+\_\+t $>$ \hyperlink{classns3_1_1Ipv6RoutingProtocol_a93f6c06be1e024747e95f4299eba74a6}{Local\+Deliver\+Callback}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Callback}{Callback} for packets to be locally delivered. \end{DoxyCompactList}\item 
typedef \hyperlink{classns3_1_1Callback}{Callback}$<$ void, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$, const \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} \&, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket\+::\+Socket\+Errno} $>$ \hyperlink{classns3_1_1Ipv6RoutingProtocol_abfdf43594e2ae97e1a4dc340e3a086a5}{Error\+Callback}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Callback}{Callback} for routing errors (e.\+g., no route found) \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Route}{Ipv6\+Route} $>$ \hyperlink{classns3_1_1Ipv6RoutingProtocol_a92e79a0364ad272392ee635ffe50644d}{Route\+Output} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ oif, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket\+::\+Socket\+Errno} \&sockerr)=0
\begin{DoxyCompactList}\small\item\em Query routing cache for an existing route, for an outbound packet. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1Ipv6RoutingProtocol_a73c66cddf196bf84090305f8d64df33b}{Route\+Input} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ idev, \hyperlink{classns3_1_1Ipv6RoutingProtocol_a579fd6755ee873009819f7117371fea7}{Unicast\+Forward\+Callback} ucb, \hyperlink{classns3_1_1Ipv6RoutingProtocol_a5f12e04512ce8e5808c3cceff6b8918f}{Multicast\+Forward\+Callback} mcb, \hyperlink{classns3_1_1Ipv6RoutingProtocol_a93f6c06be1e024747e95f4299eba74a6}{Local\+Deliver\+Callback} lcb, \hyperlink{classns3_1_1Ipv6RoutingProtocol_abfdf43594e2ae97e1a4dc340e3a086a5}{Error\+Callback} ecb)=0
\begin{DoxyCompactList}\small\item\em Route an input packet (to be forwarded or locally delivered) \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6RoutingProtocol_a024dd60e2deb864565ba5993efc38300}{Notify\+Interface\+Up} (uint32\+\_\+t interface)=0
\begin{DoxyCompactList}\small\item\em Notify when specified interface goes UP. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6RoutingProtocol_aa9b4c21a3878a1b808c9ac9d26c914bf}{Notify\+Interface\+Down} (uint32\+\_\+t interface)=0
\begin{DoxyCompactList}\small\item\em Notify when specified interface goes D\+O\+WN. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6RoutingProtocol_ae8ef31faadbb3ddd1c9a8888c986cb57}{Notify\+Add\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv6InterfaceAddress}{Ipv6\+Interface\+Address} address)=0
\begin{DoxyCompactList}\small\item\em Notify when specified interface add an address. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6RoutingProtocol_a878ace2f28ea3b07417fe5751d9ec5fc}{Notify\+Remove\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv6InterfaceAddress}{Ipv6\+Interface\+Address} address)=0
\begin{DoxyCompactList}\small\item\em Notify when specified interface add an address. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6RoutingProtocol_ad5fee223bfdac0b1dde05de7702a87cf}{Notify\+Add\+Route} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dst, \hyperlink{classns3_1_1Ipv6Prefix}{Ipv6\+Prefix} mask, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} next\+Hop, uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} prefix\+To\+Use=\hyperlink{classns3_1_1Ipv6Address_a63a34bdb1505e05fbdd07d316d0bd7e6}{Ipv6\+Address\+::\+Get\+Zero}())=0
\begin{DoxyCompactList}\small\item\em Notify a new route. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6RoutingProtocol_afcd129c7be3b0fb78012fa68025bf553}{Notify\+Remove\+Route} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dst, \hyperlink{classns3_1_1Ipv6Prefix}{Ipv6\+Prefix} mask, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} next\+Hop, uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} prefix\+To\+Use=\hyperlink{classns3_1_1Ipv6Address_a63a34bdb1505e05fbdd07d316d0bd7e6}{Ipv6\+Address\+::\+Get\+Zero}())=0
\begin{DoxyCompactList}\small\item\em Notify route removing. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6RoutingProtocol_ab97e8194b12a2db1d1374fc881974903}{Set\+Ipv6} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6}{Ipv6} $>$ ipv6)=0
\begin{DoxyCompactList}\small\item\em Typically, invoked directly or indirectly from \hyperlink{classns3_1_1Ipv6_aa889d2174527a1df773d65974de83f8f}{ns3\+::\+Ipv6\+::\+Set\+Routing\+Protocol}. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6RoutingProtocol_a2d5f8412f903a1365a1e84c06ad3da43}{Print\+Routing\+Table} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream, \hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295a}{Time\+::\+Unit} unit=\hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295aade8622b06524a328cd3a59db6ccf76af}{Time\+::S}) const =0
\begin{DoxyCompactList}\small\item\em Print the Routing Table entries. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1Ipv6RoutingProtocol_a31d3d99b29f8852cbb732f0922c57e35}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Abstract base class for I\+Pv6 routing protocols. 

Defines two virtual functions for packet routing and forwarding. The first, Route\+Output (), is used for locally originated packets, and the second, Route\+Input (), is used for forwarding and/or delivering received packets. Also defines the signatures of four callbacks used in Route\+Input (). 

\subsection{Member Typedef Documentation}
\index{ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}!Error\+Callback@{Error\+Callback}}
\index{Error\+Callback@{Error\+Callback}!ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Error\+Callback}{ErrorCallback}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Callback}$<$void, {\bf Ptr}$<$const {\bf Packet}$>$, const {\bf Ipv6\+Header} \&, {\bf Socket\+::\+Socket\+Errno} $>$ {\bf ns3\+::\+Ipv6\+Routing\+Protocol\+::\+Error\+Callback}}\hypertarget{classns3_1_1Ipv6RoutingProtocol_abfdf43594e2ae97e1a4dc340e3a086a5}{}\label{classns3_1_1Ipv6RoutingProtocol_abfdf43594e2ae97e1a4dc340e3a086a5}


\hyperlink{classns3_1_1Callback}{Callback} for routing errors (e.\+g., no route found) 

\index{ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}!Local\+Deliver\+Callback@{Local\+Deliver\+Callback}}
\index{Local\+Deliver\+Callback@{Local\+Deliver\+Callback}!ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Local\+Deliver\+Callback}{LocalDeliverCallback}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Callback}$<$void, {\bf Ptr}$<$const {\bf Packet}$>$, const {\bf Ipv6\+Header} \&, uint32\+\_\+t $>$ {\bf ns3\+::\+Ipv6\+Routing\+Protocol\+::\+Local\+Deliver\+Callback}}\hypertarget{classns3_1_1Ipv6RoutingProtocol_a93f6c06be1e024747e95f4299eba74a6}{}\label{classns3_1_1Ipv6RoutingProtocol_a93f6c06be1e024747e95f4299eba74a6}


\hyperlink{classns3_1_1Callback}{Callback} for packets to be locally delivered. 

\index{ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}!Multicast\+Forward\+Callback@{Multicast\+Forward\+Callback}}
\index{Multicast\+Forward\+Callback@{Multicast\+Forward\+Callback}!ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Multicast\+Forward\+Callback}{MulticastForwardCallback}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Callback}$<$void, {\bf Ptr}$<$const {\bf Net\+Device}$>$, {\bf Ptr}$<${\bf Ipv6\+Multicast\+Route}$>$, {\bf Ptr}$<$const {\bf Packet}$>$, const {\bf Ipv6\+Header} \&$>$ {\bf ns3\+::\+Ipv6\+Routing\+Protocol\+::\+Multicast\+Forward\+Callback}}\hypertarget{classns3_1_1Ipv6RoutingProtocol_a5f12e04512ce8e5808c3cceff6b8918f}{}\label{classns3_1_1Ipv6RoutingProtocol_a5f12e04512ce8e5808c3cceff6b8918f}


\hyperlink{classns3_1_1Callback}{Callback} for multicast packets to be forwarded. 

\index{ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}!Unicast\+Forward\+Callback@{Unicast\+Forward\+Callback}}
\index{Unicast\+Forward\+Callback@{Unicast\+Forward\+Callback}!ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Unicast\+Forward\+Callback}{UnicastForwardCallback}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Callback}$<$void, {\bf Ptr}$<$const {\bf Net\+Device}$>$, {\bf Ptr}$<${\bf Ipv6\+Route}$>$, {\bf Ptr}$<$const {\bf Packet}$>$, const {\bf Ipv6\+Header} \&$>$ {\bf ns3\+::\+Ipv6\+Routing\+Protocol\+::\+Unicast\+Forward\+Callback}}\hypertarget{classns3_1_1Ipv6RoutingProtocol_a579fd6755ee873009819f7117371fea7}{}\label{classns3_1_1Ipv6RoutingProtocol_a579fd6755ee873009819f7117371fea7}


\hyperlink{classns3_1_1Callback}{Callback} for unicast packets to be forwarded. 



\subsection{Member Function Documentation}
\index{ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Ipv6\+Routing\+Protocol\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv6RoutingProtocol_a31d3d99b29f8852cbb732f0922c57e35}{}\label{classns3_1_1Ipv6RoutingProtocol_a31d3d99b29f8852cbb732f0922c57e35}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
32 \{
33   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::Ipv6RoutingProtocol"})
34     .SetParent<\hyperlink{classns3_1_1Object_a40860402e64d8008fb42329df7097cdb}{Object}> ()
35     .SetGroupName (\textcolor{stringliteral}{"Internet"})
36   ;
37   \textcolor{keywordflow}{return} tid;
38 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}!Notify\+Add\+Address@{Notify\+Add\+Address}}
\index{Notify\+Add\+Address@{Notify\+Add\+Address}!ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Notify\+Add\+Address(uint32\+\_\+t interface, Ipv6\+Interface\+Address address)=0}{NotifyAddAddress(uint32_t interface, Ipv6InterfaceAddress address)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv6\+Routing\+Protocol\+::\+Notify\+Add\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv6\+Interface\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6RoutingProtocol_ae8ef31faadbb3ddd1c9a8888c986cb57}{}\label{classns3_1_1Ipv6RoutingProtocol_ae8ef31faadbb3ddd1c9a8888c986cb57}


Notify when specified interface add an address. 

Protocols are expected to implement this method to be notified whenever a new address is added to an interface. Typically used to add a \textquotesingle{}network route\textquotesingle{} on an interface. Can be invoked on an up or down interface. 
\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
{\em address} & a new address being added to an interface \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classns3_1_1Ipv6StaticRouting_ab4f7777b5228f498fa3493c753d50b8f}{ns3\+::\+Ipv6\+Static\+Routing}, \hyperlink{classns3_1_1RipNg_a9d6ffbffc76b029e5dfc9f394549d670}{ns3\+::\+Rip\+Ng}, \hyperlink{classns3_1_1Ipv6ListRouting_a67d4f8e48b55a0c99d8e59ac5b74c498}{ns3\+::\+Ipv6\+List\+Routing}, \hyperlink{classIpv6BRouting_aeec816a2f4f34b1461d3121d9cbbe2e6}{Ipv6\+B\+Routing}, and \hyperlink{classIpv6ARouting_ac2913018e4f1d0cda7b48ca1e97bf9ef}{Ipv6\+A\+Routing}.

\index{ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}!Notify\+Add\+Route@{Notify\+Add\+Route}}
\index{Notify\+Add\+Route@{Notify\+Add\+Route}!ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Notify\+Add\+Route(\+Ipv6\+Address dst, Ipv6\+Prefix mask, Ipv6\+Address next\+Hop, uint32\+\_\+t interface, Ipv6\+Address prefix\+To\+Use=\+Ipv6\+Address\+::\+Get\+Zero())=0}{NotifyAddRoute(Ipv6Address dst, Ipv6Prefix mask, Ipv6Address nextHop, uint32_t interface, Ipv6Address prefixToUse=Ipv6Address::GetZero())=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv6\+Routing\+Protocol\+::\+Notify\+Add\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{dst, }
\item[{{\bf Ipv6\+Prefix}}]{mask, }
\item[{{\bf Ipv6\+Address}}]{next\+Hop, }
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv6\+Address}}]{prefix\+To\+Use = {\ttfamily {\bf Ipv6\+Address\+::\+Get\+Zero}()}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6RoutingProtocol_ad5fee223bfdac0b1dde05de7702a87cf}{}\label{classns3_1_1Ipv6RoutingProtocol_ad5fee223bfdac0b1dde05de7702a87cf}


Notify a new route. 

Typically this is used to add another route from I\+Pv6 stack (i.\+e. I\+C\+M\+Pv6 redirect case, ...). 
\begin{DoxyParams}{Parameters}
{\em dst} & destination address \\
\hline
{\em mask} & destination mask \\
\hline
{\em next\+Hop} & next\+Hop for this destination \\
\hline
{\em interface} & output interface \\
\hline
{\em prefix\+To\+Use} & prefix to use as source with this route \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classns3_1_1Ipv6StaticRouting_aaae863ba89a47ad659fb5dc3602c9e24}{ns3\+::\+Ipv6\+Static\+Routing}, \hyperlink{classns3_1_1RipNg_a57bee3de4b39e03ad66e3fd35abf4805}{ns3\+::\+Rip\+Ng}, \hyperlink{classns3_1_1Ipv6ListRouting_a39dddd9618719875abab8c2ed9eed081}{ns3\+::\+Ipv6\+List\+Routing}, \hyperlink{classIpv6BRouting_ad1975c8950305b2aa2125fd7d229d13c}{Ipv6\+B\+Routing}, and \hyperlink{classIpv6ARouting_adbd025ee04eb653e85f5a7d73a5d58c5}{Ipv6\+A\+Routing}.

\index{ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}!Notify\+Interface\+Down@{Notify\+Interface\+Down}}
\index{Notify\+Interface\+Down@{Notify\+Interface\+Down}!ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Notify\+Interface\+Down(uint32\+\_\+t interface)=0}{NotifyInterfaceDown(uint32_t interface)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv6\+Routing\+Protocol\+::\+Notify\+Interface\+Down (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6RoutingProtocol_aa9b4c21a3878a1b808c9ac9d26c914bf}{}\label{classns3_1_1Ipv6RoutingProtocol_aa9b4c21a3878a1b808c9ac9d26c914bf}


Notify when specified interface goes D\+O\+WN. 

Protocols are expected to implement this method to be notified of the state change of an interface in a node. 
\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classns3_1_1Ipv6StaticRouting_a1e917452e99ee697b9ffd5acebfc0a02}{ns3\+::\+Ipv6\+Static\+Routing}, \hyperlink{classns3_1_1RipNg_a2031124814e8d817d0a40dddb7327a1b}{ns3\+::\+Rip\+Ng}, \hyperlink{classns3_1_1Ipv6ListRouting_a24b3d4068e036c349699901558f0471c}{ns3\+::\+Ipv6\+List\+Routing}, \hyperlink{classIpv6BRouting_a7923a1de31b147fae4ceeeea8bcacc6a}{Ipv6\+B\+Routing}, and \hyperlink{classIpv6ARouting_a5dce30466f71204c0a4dfb6a99db6c2e}{Ipv6\+A\+Routing}.

\index{ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}!Notify\+Interface\+Up@{Notify\+Interface\+Up}}
\index{Notify\+Interface\+Up@{Notify\+Interface\+Up}!ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Notify\+Interface\+Up(uint32\+\_\+t interface)=0}{NotifyInterfaceUp(uint32_t interface)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv6\+Routing\+Protocol\+::\+Notify\+Interface\+Up (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6RoutingProtocol_a024dd60e2deb864565ba5993efc38300}{}\label{classns3_1_1Ipv6RoutingProtocol_a024dd60e2deb864565ba5993efc38300}


Notify when specified interface goes UP. 

Protocols are expected to implement this method to be notified of the state change of an interface in a node. 
\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classns3_1_1Ipv6StaticRouting_a9750930029ffe2eaafda77ba77918472}{ns3\+::\+Ipv6\+Static\+Routing}, \hyperlink{classns3_1_1RipNg_a588e191ae91316e498a8e5c84a9c77fb}{ns3\+::\+Rip\+Ng}, \hyperlink{classns3_1_1Ipv6ListRouting_afbeeaf6cd4dd9a81354e70617bf88811}{ns3\+::\+Ipv6\+List\+Routing}, \hyperlink{classIpv6BRouting_ab043d01b4e39e4777d43fe6f14120825}{Ipv6\+B\+Routing}, and \hyperlink{classIpv6ARouting_a70098c9eaf1435fef5f441a71e2dd452}{Ipv6\+A\+Routing}.

\index{ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}!Notify\+Remove\+Address@{Notify\+Remove\+Address}}
\index{Notify\+Remove\+Address@{Notify\+Remove\+Address}!ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Notify\+Remove\+Address(uint32\+\_\+t interface, Ipv6\+Interface\+Address address)=0}{NotifyRemoveAddress(uint32_t interface, Ipv6InterfaceAddress address)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv6\+Routing\+Protocol\+::\+Notify\+Remove\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv6\+Interface\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6RoutingProtocol_a878ace2f28ea3b07417fe5751d9ec5fc}{}\label{classns3_1_1Ipv6RoutingProtocol_a878ace2f28ea3b07417fe5751d9ec5fc}


Notify when specified interface add an address. 

Protocols are expected to implement this method to be notified whenever a new address is removed from an interface. Typically used to remove the \textquotesingle{}network route\textquotesingle{} of an interface. Can be invoked on an up or down interface. 
\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
{\em address} & a new address being added to an interface \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classns3_1_1Ipv6StaticRouting_ab100c4857d93e5f0cc980e8024838e68}{ns3\+::\+Ipv6\+Static\+Routing}, \hyperlink{classns3_1_1RipNg_a0658ff312aa09265ddc9ad8718789f0a}{ns3\+::\+Rip\+Ng}, \hyperlink{classns3_1_1Ipv6ListRouting_a46e2cf52e8552cc0b3373c6609be27cc}{ns3\+::\+Ipv6\+List\+Routing}, \hyperlink{classIpv6BRouting_aca9d5c58f60cdcfd8cc5b5a3114be91f}{Ipv6\+B\+Routing}, and \hyperlink{classIpv6ARouting_a9c751287bfcbee46e56a9f8696a548e1}{Ipv6\+A\+Routing}.

\index{ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}!Notify\+Remove\+Route@{Notify\+Remove\+Route}}
\index{Notify\+Remove\+Route@{Notify\+Remove\+Route}!ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Notify\+Remove\+Route(\+Ipv6\+Address dst, Ipv6\+Prefix mask, Ipv6\+Address next\+Hop, uint32\+\_\+t interface, Ipv6\+Address prefix\+To\+Use=\+Ipv6\+Address\+::\+Get\+Zero())=0}{NotifyRemoveRoute(Ipv6Address dst, Ipv6Prefix mask, Ipv6Address nextHop, uint32_t interface, Ipv6Address prefixToUse=Ipv6Address::GetZero())=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv6\+Routing\+Protocol\+::\+Notify\+Remove\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{dst, }
\item[{{\bf Ipv6\+Prefix}}]{mask, }
\item[{{\bf Ipv6\+Address}}]{next\+Hop, }
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv6\+Address}}]{prefix\+To\+Use = {\ttfamily {\bf Ipv6\+Address\+::\+Get\+Zero}()}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6RoutingProtocol_afcd129c7be3b0fb78012fa68025bf553}{}\label{classns3_1_1Ipv6RoutingProtocol_afcd129c7be3b0fb78012fa68025bf553}


Notify route removing. 


\begin{DoxyParams}{Parameters}
{\em dst} & destination address \\
\hline
{\em mask} & destination mask \\
\hline
{\em next\+Hop} & next\+Hop for this destination \\
\hline
{\em interface} & output interface \\
\hline
{\em prefix\+To\+Use} & prefix to use as source with this route \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classns3_1_1Ipv6StaticRouting_aee1c676f218334e82bbbaf695aa93514}{ns3\+::\+Ipv6\+Static\+Routing}, \hyperlink{classns3_1_1RipNg_a72de5c5fbbe3bd7f29a5b05d3dd46c16}{ns3\+::\+Rip\+Ng}, \hyperlink{classns3_1_1Ipv6ListRouting_a10a31c12272e77d51d1fd68b025ad2f5}{ns3\+::\+Ipv6\+List\+Routing}, \hyperlink{classIpv6BRouting_a0f1bfdc03e55422dd39a22eac3d1748c}{Ipv6\+B\+Routing}, and \hyperlink{classIpv6ARouting_a42019b27d60115b4c0450cd75c98f0b8}{Ipv6\+A\+Routing}.

\index{ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}!Print\+Routing\+Table@{Print\+Routing\+Table}}
\index{Print\+Routing\+Table@{Print\+Routing\+Table}!ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Print\+Routing\+Table(\+Ptr$<$ Output\+Stream\+Wrapper $>$ stream, Time\+::\+Unit unit=\+Time\+::\+S) const =0}{PrintRoutingTable(Ptr< OutputStreamWrapper > stream, Time::Unit unit=Time::S) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv6\+Routing\+Protocol\+::\+Print\+Routing\+Table (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream, }
\item[{{\bf Time\+::\+Unit}}]{unit = {\ttfamily {\bf Time\+::S}}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6RoutingProtocol_a2d5f8412f903a1365a1e84c06ad3da43}{}\label{classns3_1_1Ipv6RoutingProtocol_a2d5f8412f903a1365a1e84c06ad3da43}


Print the Routing Table entries. 


\begin{DoxyParams}{Parameters}
{\em stream} & The ostream the Routing table is printed to \\
\hline
{\em unit} & The time unit to be used in the report \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classns3_1_1Ipv6StaticRouting_a39ea5334065001c093c8165d6a282550}{ns3\+::\+Ipv6\+Static\+Routing}, \hyperlink{classns3_1_1RipNg_aec30027ca8085a46d680b98291e27480}{ns3\+::\+Rip\+Ng}, \hyperlink{classns3_1_1Ipv6ListRouting_a0c8272a6217b35e37b6e6ac247494890}{ns3\+::\+Ipv6\+List\+Routing}, \hyperlink{classIpv6BRouting_ad908ec5b086d92a81d827d7cb939c13b}{Ipv6\+B\+Routing}, and \hyperlink{classIpv6ARouting_a13eb58a576bf1357ae733891b0b6f27d}{Ipv6\+A\+Routing}.

\index{ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}!Route\+Input@{Route\+Input}}
\index{Route\+Input@{Route\+Input}!ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Route\+Input(\+Ptr$<$ const Packet $>$ p, const Ipv6\+Header \&header, Ptr$<$ const Net\+Device $>$ idev, Unicast\+Forward\+Callback ucb, Multicast\+Forward\+Callback mcb, Local\+Deliver\+Callback lcb, Error\+Callback ecb)=0}{RouteInput(Ptr< const Packet > p, const Ipv6Header &header, Ptr< const NetDevice > idev, UnicastForwardCallback ucb, MulticastForwardCallback mcb, LocalDeliverCallback lcb, ErrorCallback ecb)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool ns3\+::\+Ipv6\+Routing\+Protocol\+::\+Route\+Input (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv6\+Header} \&}]{header, }
\item[{{\bf Ptr}$<$ const {\bf Net\+Device} $>$}]{idev, }
\item[{{\bf Unicast\+Forward\+Callback}}]{ucb, }
\item[{{\bf Multicast\+Forward\+Callback}}]{mcb, }
\item[{{\bf Local\+Deliver\+Callback}}]{lcb, }
\item[{{\bf Error\+Callback}}]{ecb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6RoutingProtocol_a73c66cddf196bf84090305f8d64df33b}{}\label{classns3_1_1Ipv6RoutingProtocol_a73c66cddf196bf84090305f8d64df33b}


Route an input packet (to be forwarded or locally delivered) 

This lookup is used in the forwarding process. The packet is handed over to the \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol}, and will get forwarded onward by one of the callbacks. The Linux equivalent is ip\+\_\+route\+\_\+input (). There are four valid outcomes, and a matching callbacks to handle each.


\begin{DoxyParams}{Parameters}
{\em p} & received packet \\
\hline
{\em header} & input parameter used to form a search key for a route \\
\hline
{\em idev} & Pointer to ingress network device \\
\hline
{\em ucb} & \hyperlink{classns3_1_1Callback}{Callback} for the case in which the packet is to be forwarded as unicast \\
\hline
{\em mcb} & \hyperlink{classns3_1_1Callback}{Callback} for the case in which the packet is to be forwarded as multicast \\
\hline
{\em lcb} & \hyperlink{classns3_1_1Callback}{Callback} for the case in which the packet is to be locally delivered \\
\hline
{\em ecb} & \hyperlink{classns3_1_1Callback}{Callback} to call if there is an error in forwarding \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} takes responsibility for forwarding or delivering the packet, false otherwise 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv6StaticRouting_a33810db6250f018b4587dc34a43a80cb}{ns3\+::\+Ipv6\+Static\+Routing}, \hyperlink{classns3_1_1RipNg_ad85da69a6006cd5089e1a69e7a6be13b}{ns3\+::\+Rip\+Ng}, \hyperlink{classns3_1_1Ipv6ListRouting_a1b4d7867aad1029308cb7907f75e1035}{ns3\+::\+Ipv6\+List\+Routing}, \hyperlink{classIpv6BRouting_a5983fb97e371e496d202af629cb813c2}{Ipv6\+B\+Routing}, and \hyperlink{classIpv6ARouting_a6999910a5f726be9ece9891e1daa4cb9}{Ipv6\+A\+Routing}.

\index{ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}!Route\+Output@{Route\+Output}}
\index{Route\+Output@{Route\+Output}!ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Route\+Output(\+Ptr$<$ Packet $>$ p, const Ipv6\+Header \&header, Ptr$<$ Net\+Device $>$ oif, Socket\+::\+Socket\+Errno \&sockerr)=0}{RouteOutput(Ptr< Packet > p, const Ipv6Header &header, Ptr< NetDevice > oif, Socket::SocketErrno &sockerr)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Ptr}$<${\bf Ipv6\+Route}$>$ ns3\+::\+Ipv6\+Routing\+Protocol\+::\+Route\+Output (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv6\+Header} \&}]{header, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{oif, }
\item[{{\bf Socket\+::\+Socket\+Errno} \&}]{sockerr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6RoutingProtocol_a92e79a0364ad272392ee635ffe50644d}{}\label{classns3_1_1Ipv6RoutingProtocol_a92e79a0364ad272392ee635ffe50644d}


Query routing cache for an existing route, for an outbound packet. 

This lookup is used by transport protocols. It does not cause any packet to be forwarded, and is synchronous. Can be used for multicast or unicast. The Linux equivalent is ip\+\_\+route\+\_\+output ()


\begin{DoxyParams}{Parameters}
{\em p} & packet to be routed. Note that this method may modify the packet. Callers may also pass in a null pointer. \\
\hline
{\em header} & input parameter (used to form key to search for the route) \\
\hline
{\em oif} & Output interface device. May be zero, or may be bound via socket options to a particular output interface. \\
\hline
{\em sockerr} & Output parameter; socket errno\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a code that indicates what happened in the lookup 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv6StaticRouting_a494b7a870cc1af31ba11611128a067a6}{ns3\+::\+Ipv6\+Static\+Routing}, \hyperlink{classns3_1_1RipNg_acc42ebebc7e1b3ccb68c7be6b2f37f95}{ns3\+::\+Rip\+Ng}, \hyperlink{classns3_1_1Ipv6ListRouting_a17dd6df1ef25f2ff410b5ba759b6e5e7}{ns3\+::\+Ipv6\+List\+Routing}, \hyperlink{classIpv6BRouting_ab9014aef2ea98c6231436e9f4c906b80}{Ipv6\+B\+Routing}, and \hyperlink{classIpv6ARouting_a1e5c5092a6174c59041a66c9fcdfd86e}{Ipv6\+A\+Routing}.

\index{ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}!Set\+Ipv6@{Set\+Ipv6}}
\index{Set\+Ipv6@{Set\+Ipv6}!ns3\+::\+Ipv6\+Routing\+Protocol@{ns3\+::\+Ipv6\+Routing\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Ipv6(\+Ptr$<$ Ipv6 $>$ ipv6)=0}{SetIpv6(Ptr< Ipv6 > ipv6)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv6\+Routing\+Protocol\+::\+Set\+Ipv6 (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv6} $>$}]{ipv6}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6RoutingProtocol_ab97e8194b12a2db1d1374fc881974903}{}\label{classns3_1_1Ipv6RoutingProtocol_ab97e8194b12a2db1d1374fc881974903}


Typically, invoked directly or indirectly from \hyperlink{classns3_1_1Ipv6_aa889d2174527a1df773d65974de83f8f}{ns3\+::\+Ipv6\+::\+Set\+Routing\+Protocol}. 


\begin{DoxyParams}{Parameters}
{\em ipv6} & the ipv6 object this routing protocol is being associated with \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classns3_1_1Ipv6StaticRouting_a05569b3f3a6042a7e12a50fe88ee11e7}{ns3\+::\+Ipv6\+Static\+Routing}, \hyperlink{classns3_1_1RipNg_acd8e0a2b2453a28ecd4154729e45d324}{ns3\+::\+Rip\+Ng}, \hyperlink{classns3_1_1Ipv6ListRouting_ac660375f36097f4c760a2cc5e6f4aa8a}{ns3\+::\+Ipv6\+List\+Routing}, \hyperlink{classIpv6BRouting_af02c1868bf804683a45d2f4c4775c75f}{Ipv6\+B\+Routing}, and \hyperlink{classIpv6ARouting_a5cac88241076190c77179a637e548473}{Ipv6\+A\+Routing}.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/model/\hyperlink{ipv6-routing-protocol_8h}{ipv6-\/routing-\/protocol.\+h}\item 
internet/model/\hyperlink{ipv6-routing-protocol_8cc}{ipv6-\/routing-\/protocol.\+cc}\end{DoxyCompactItemize}
