\hypertarget{classns3_1_1TcpNewReno}{}\section{ns3\+:\+:Tcp\+New\+Reno Class Reference}
\label{classns3_1_1TcpNewReno}\index{ns3\+::\+Tcp\+New\+Reno@{ns3\+::\+Tcp\+New\+Reno}}


The New\+Reno implementation.  




{\ttfamily \#include $<$tcp-\/congestion-\/ops.\+h$>$}



Inheritance diagram for ns3\+:\+:Tcp\+New\+Reno\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Tcp\+New\+Reno\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1TcpNewReno_a81686cb1590be6d7c754029fc8d7cf4e}{Tcp\+New\+Reno} ()
\item 
\hyperlink{classns3_1_1TcpNewReno_aed0c36a533ba7521440f91ca321aa771}{Tcp\+New\+Reno} (const \hyperlink{classns3_1_1TcpNewReno}{Tcp\+New\+Reno} \&sock)
\begin{DoxyCompactList}\small\item\em Copy constructor. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TcpNewReno_abc9e89a0b1771a3507c3070f203f838b}{$\sim$\+Tcp\+New\+Reno} ()
\item 
std\+::string \hyperlink{classns3_1_1TcpNewReno_a0ecf92cb36c236c70e0ecaedfff6609e}{Get\+Name} () const 
\begin{DoxyCompactList}\small\item\em Get the name of the congestion control algorithm. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1TcpNewReno_a11db8ae90f4cebacc15524a793b0741a}{Increase\+Window} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1TcpSocketState}{Tcp\+Socket\+State} $>$ tcb, uint32\+\_\+t segments\+Acked)
\begin{DoxyCompactList}\small\item\em Try to increase the c\+Wnd following the New\+Reno specification. \end{DoxyCompactList}\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1TcpNewReno_a1cb467aaa4960dfe10b963ed9f3d5aa2}{Get\+Ss\+Thresh} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1TcpSocketState}{Tcp\+Socket\+State} $>$ tcb, uint32\+\_\+t bytes\+In\+Flight)
\begin{DoxyCompactList}\small\item\em Get the slow start threshold after a loss event. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1TcpCongestionOps}{Tcp\+Congestion\+Ops} $>$ \hyperlink{classns3_1_1TcpNewReno_a2606d5fcd01a1eb4d5f4e6beb7a33192}{Fork} ()
\begin{DoxyCompactList}\small\item\em Copy the congestion control algorithm across socket. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1TcpNewReno_af4f4778f724f72a8a441ac0af4cdd8fe}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1TcpNewReno_a1cf5fd9585eb3b745727f4f5beae0706}{Slow\+Start} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1TcpSocketState}{Tcp\+Socket\+State} $>$ tcb, uint32\+\_\+t segments\+Acked)
\begin{DoxyCompactList}\small\item\em Tcp New\+Reno slow start algorithm. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1TcpNewReno_a34a5eec0649a7b485852c74c825e14ba}{Congestion\+Avoidance} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1TcpSocketState}{Tcp\+Socket\+State} $>$ tcb, uint32\+\_\+t segments\+Acked)
\begin{DoxyCompactList}\small\item\em New\+Reno congestion avoidance. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
The New\+Reno implementation. 

New Reno introduces partial A\+C\+Ks inside the well-\/established Reno algorithm. This and other modifications are described in R\+FC 6582.

\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1TcpNewReno_a11db8ae90f4cebacc15524a793b0741a}{Increase\+Window} 
\end{DoxySeeAlso}


\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Tcp\+New\+Reno@{ns3\+::\+Tcp\+New\+Reno}!Tcp\+New\+Reno@{Tcp\+New\+Reno}}
\index{Tcp\+New\+Reno@{Tcp\+New\+Reno}!ns3\+::\+Tcp\+New\+Reno@{ns3\+::\+Tcp\+New\+Reno}}
\subsubsection[{\texorpdfstring{Tcp\+New\+Reno()}{TcpNewReno()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Tcp\+New\+Reno\+::\+Tcp\+New\+Reno (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpNewReno_a81686cb1590be6d7c754029fc8d7cf4e}{}\label{classns3_1_1TcpNewReno_a81686cb1590be6d7c754029fc8d7cf4e}

\begin{DoxyCode}
67                             : \hyperlink{classns3_1_1TcpCongestionOps_a044982d009b94a2bbf59ed27cdb14e91}{TcpCongestionOps} ()
68 \{
69   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
70 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+New\+Reno@{ns3\+::\+Tcp\+New\+Reno}!Tcp\+New\+Reno@{Tcp\+New\+Reno}}
\index{Tcp\+New\+Reno@{Tcp\+New\+Reno}!ns3\+::\+Tcp\+New\+Reno@{ns3\+::\+Tcp\+New\+Reno}}
\subsubsection[{\texorpdfstring{Tcp\+New\+Reno(const Tcp\+New\+Reno \&sock)}{TcpNewReno(const TcpNewReno &sock)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Tcp\+New\+Reno\+::\+Tcp\+New\+Reno (
\begin{DoxyParamCaption}
\item[{const {\bf Tcp\+New\+Reno} \&}]{sock}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpNewReno_aed0c36a533ba7521440f91ca321aa771}{}\label{classns3_1_1TcpNewReno_aed0c36a533ba7521440f91ca321aa771}


Copy constructor. 


\begin{DoxyParams}{Parameters}
{\em sock} & object to copy. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
73   : \hyperlink{classns3_1_1TcpCongestionOps_a044982d009b94a2bbf59ed27cdb14e91}{TcpCongestionOps} (sock)
74 \{
75   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
76 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+New\+Reno@{ns3\+::\+Tcp\+New\+Reno}!````~Tcp\+New\+Reno@{$\sim$\+Tcp\+New\+Reno}}
\index{````~Tcp\+New\+Reno@{$\sim$\+Tcp\+New\+Reno}!ns3\+::\+Tcp\+New\+Reno@{ns3\+::\+Tcp\+New\+Reno}}
\subsubsection[{\texorpdfstring{$\sim$\+Tcp\+New\+Reno()}{~TcpNewReno()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Tcp\+New\+Reno\+::$\sim$\+Tcp\+New\+Reno (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpNewReno_abc9e89a0b1771a3507c3070f203f838b}{}\label{classns3_1_1TcpNewReno_abc9e89a0b1771a3507c3070f203f838b}

\begin{DoxyCode}
79 \{
80 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Tcp\+New\+Reno@{ns3\+::\+Tcp\+New\+Reno}!Congestion\+Avoidance@{Congestion\+Avoidance}}
\index{Congestion\+Avoidance@{Congestion\+Avoidance}!ns3\+::\+Tcp\+New\+Reno@{ns3\+::\+Tcp\+New\+Reno}}
\subsubsection[{\texorpdfstring{Congestion\+Avoidance(\+Ptr$<$ Tcp\+Socket\+State $>$ tcb, uint32\+\_\+t segments\+Acked)}{CongestionAvoidance(Ptr< TcpSocketState > tcb, uint32_t segmentsAcked)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+New\+Reno\+::\+Congestion\+Avoidance (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Tcp\+Socket\+State} $>$}]{tcb, }
\item[{uint32\+\_\+t}]{segments\+Acked}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1TcpNewReno_a34a5eec0649a7b485852c74c825e14ba}{}\label{classns3_1_1TcpNewReno_a34a5eec0649a7b485852c74c825e14ba}


New\+Reno congestion avoidance. 

During congestion avoidance, cwnd is incremented by roughly 1 full-\/sized segment per round-\/trip time (R\+TT).


\begin{DoxyParams}{Parameters}
{\em tcb} & internal congestion state \\
\hline
{\em segments\+Acked} & count of segments acked \\
\hline
\end{DoxyParams}


Reimplemented in \hyperlink{classns3_1_1TcpLedbat_a592b6df30581c978ddabf095eb0300c6}{ns3\+::\+Tcp\+Ledbat}, \hyperlink{classns3_1_1TcpScalable_aa0c22097e0628f16f321d79addc58976}{ns3\+::\+Tcp\+Scalable}, \hyperlink{classns3_1_1TcpHighSpeed_ab241f8400ad52cff3e2f04ed8d00983c}{ns3\+::\+Tcp\+High\+Speed}, \hyperlink{classns3_1_1TcpHtcp_a5eb471eacd7966cf548024c3870cc3bf}{ns3\+::\+Tcp\+Htcp}, and \hyperlink{classns3_1_1TcpHybla_a10463113be84c3506fe85b5abfe8b186}{ns3\+::\+Tcp\+Hybla}.


\begin{DoxyCode}
150 \{
151   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << tcb << segmentsAcked);
152 
153   \textcolor{keywordflow}{if} (segmentsAcked > 0)
154     \{
155       \textcolor{keywordtype}{double} adder = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>} (tcb->\hyperlink{classns3_1_1TcpSocketState_a079872f7b0099ef5f3cab4ff47bd2edd}{m\_segmentSize} * tcb->
      \hyperlink{classns3_1_1TcpSocketState_a079872f7b0099ef5f3cab4ff47bd2edd}{m\_segmentSize}) / tcb->\hyperlink{classns3_1_1TcpSocketState_a7cd3d2156a483c1db436097477a0fd7f}{m\_cWnd}.\hyperlink{classns3_1_1TracedValue_a10fddd1de961ac65acfbeb440a1e8551}{Get} ();
156       adder = \hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{std::max} (1.0, adder);
157       tcb->\hyperlink{classns3_1_1TcpSocketState_a7cd3d2156a483c1db436097477a0fd7f}{m\_cWnd} += \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>} (adder);
158       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"In CongAvoid, updated to cwnd "} << tcb->\hyperlink{classns3_1_1TcpSocketState_a7cd3d2156a483c1db436097477a0fd7f}{m\_cWnd} <<
159                    \textcolor{stringliteral}{" ssthresh "} << tcb->\hyperlink{classns3_1_1TcpSocketState_aec003b6dba9d269bfb1036c7652ffbd6}{m\_ssThresh});
160     \}
161 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2




Here is the caller graph for this function\+:
% FIG 3


\index{ns3\+::\+Tcp\+New\+Reno@{ns3\+::\+Tcp\+New\+Reno}!Fork@{Fork}}
\index{Fork@{Fork}!ns3\+::\+Tcp\+New\+Reno@{ns3\+::\+Tcp\+New\+Reno}}
\subsubsection[{\texorpdfstring{Fork()}{Fork()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Tcp\+Congestion\+Ops} $>$ ns3\+::\+Tcp\+New\+Reno\+::\+Fork (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TcpNewReno_a2606d5fcd01a1eb4d5f4e6beb7a33192}{}\label{classns3_1_1TcpNewReno_a2606d5fcd01a1eb4d5f4e6beb7a33192}


Copy the congestion control algorithm across socket. 

\begin{DoxyReturn}{Returns}
a pointer of the copied object 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1TcpCongestionOps_a328ca18452bca8b4b62217e85fd29ac6}{ns3\+::\+Tcp\+Congestion\+Ops}.



Reimplemented in \hyperlink{classns3_1_1TcpYeah_a2e1b0c15fd6c8128cceb7fa395f49892}{ns3\+::\+Tcp\+Yeah}, \hyperlink{classns3_1_1TcpIllinois_a42f28764801115e88e38bff513d4b893}{ns3\+::\+Tcp\+Illinois}, \hyperlink{classns3_1_1TcpVeno_a32d40c4563a8ba8e0317b860c184c055}{ns3\+::\+Tcp\+Veno}, \hyperlink{classns3_1_1TcpVegas_afc91e9d8fb8814b417cf817538ec808d}{ns3\+::\+Tcp\+Vegas}, \hyperlink{classns3_1_1TcpLedbat_a76866fc3f6e142e996465e2c987e2629}{ns3\+::\+Tcp\+Ledbat}, \hyperlink{classns3_1_1TcpWestwood_ab601df846ac101da7fdd0e76ca8cffa0}{ns3\+::\+Tcp\+Westwood}, \hyperlink{classns3_1_1TcpScalable_a492457204d44b5cd3089aa913c78c1d2}{ns3\+::\+Tcp\+Scalable}, \hyperlink{classns3_1_1TcpHighSpeed_a299b55baaeb60eb3a3e81f0f2a27e34f}{ns3\+::\+Tcp\+High\+Speed}, \hyperlink{classns3_1_1TcpHybla_a43ce1d6a0ee818a29988fdc9f9b1f6bb}{ns3\+::\+Tcp\+Hybla}, and \hyperlink{classns3_1_1TcpHtcp_ac43b14656621c83a4f229e97052c633c}{ns3\+::\+Tcp\+Htcp}.


\begin{DoxyCode}
214 \{
215   \textcolor{keywordflow}{return} CopyObject<TcpNewReno> (\textcolor{keyword}{this});
216 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+New\+Reno@{ns3\+::\+Tcp\+New\+Reno}!Get\+Name@{Get\+Name}}
\index{Get\+Name@{Get\+Name}!ns3\+::\+Tcp\+New\+Reno@{ns3\+::\+Tcp\+New\+Reno}}
\subsubsection[{\texorpdfstring{Get\+Name() const }{GetName() const }}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string ns3\+::\+Tcp\+New\+Reno\+::\+Get\+Name (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TcpNewReno_a0ecf92cb36c236c70e0ecaedfff6609e}{}\label{classns3_1_1TcpNewReno_a0ecf92cb36c236c70e0ecaedfff6609e}


Get the name of the congestion control algorithm. 

\begin{DoxyReturn}{Returns}
A string identifying the name 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1TcpCongestionOps_afb778629819ba3dbf7aaf15b0d57e114}{ns3\+::\+Tcp\+Congestion\+Ops}.



Reimplemented in \hyperlink{classns3_1_1TcpIllinois_a4515a565bdc968d90a4f7dc160dbd3ff}{ns3\+::\+Tcp\+Illinois}, \hyperlink{classns3_1_1TcpYeah_a55437380bf00da00ede56cc44be0b5d2}{ns3\+::\+Tcp\+Yeah}, \hyperlink{classns3_1_1TcpVeno_a53f0c8ff201ea8972166ae6cca450d07}{ns3\+::\+Tcp\+Veno}, \hyperlink{classns3_1_1TcpLedbat_af3706fd2c991966e5a4e7f97e799395a}{ns3\+::\+Tcp\+Ledbat}, \hyperlink{classns3_1_1TcpVegas_a476e123ec5b2cfd44f68ac4063fe3f0c}{ns3\+::\+Tcp\+Vegas}, \hyperlink{classns3_1_1TcpScalable_a9284076eee672a0448d83ec0317d8c88}{ns3\+::\+Tcp\+Scalable}, \hyperlink{classns3_1_1TcpHybla_a5f2c0e4bbceebf35436b596effecf1a7}{ns3\+::\+Tcp\+Hybla}, \hyperlink{classns3_1_1TcpHighSpeed_a448ff7b3c5880d1ae8dba89b0f3d3745}{ns3\+::\+Tcp\+High\+Speed}, and \hyperlink{classns3_1_1TcpHtcp_ad59318c863c81cba937ca8e677a9b07e}{ns3\+::\+Tcp\+Htcp}.


\begin{DoxyCode}
199 \{
200   \textcolor{keywordflow}{return} \textcolor{stringliteral}{"TcpNewReno"};
201 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+New\+Reno@{ns3\+::\+Tcp\+New\+Reno}!Get\+Ss\+Thresh@{Get\+Ss\+Thresh}}
\index{Get\+Ss\+Thresh@{Get\+Ss\+Thresh}!ns3\+::\+Tcp\+New\+Reno@{ns3\+::\+Tcp\+New\+Reno}}
\subsubsection[{\texorpdfstring{Get\+Ss\+Thresh(\+Ptr$<$ const Tcp\+Socket\+State $>$ tcb, uint32\+\_\+t bytes\+In\+Flight)}{GetSsThresh(Ptr< const TcpSocketState > tcb, uint32_t bytesInFlight)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Tcp\+New\+Reno\+::\+Get\+Ss\+Thresh (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Tcp\+Socket\+State} $>$}]{tcb, }
\item[{uint32\+\_\+t}]{bytes\+In\+Flight}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TcpNewReno_a1cb467aaa4960dfe10b963ed9f3d5aa2}{}\label{classns3_1_1TcpNewReno_a1cb467aaa4960dfe10b963ed9f3d5aa2}


Get the slow start threshold after a loss event. 

Is guaranteed that the congestion control state (Tcp\+Ack\+State\+\_\+t) is changed B\+E\+F\+O\+RE the invocation of this method. The implementator should return the slow start threshold (and not change it directly) because, in the future, the T\+CP implementation may require to instantly recover from a loss event (e.\+g. when there is a network with an high reordering factor).


\begin{DoxyParams}{Parameters}
{\em tcb} & internal congestion state \\
\hline
{\em bytes\+In\+Flight} & total bytes in flight \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Slow start threshold 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1TcpCongestionOps_a504ab8e79dbf8e11c1f2b7120977a8c5}{ns3\+::\+Tcp\+Congestion\+Ops}.



Reimplemented in \hyperlink{classns3_1_1TcpYeah_a08fe03bc4dca7f6c36f40ac770335c1a}{ns3\+::\+Tcp\+Yeah}, \hyperlink{classns3_1_1TcpIllinois_a5c041aa5385217f81f97d1b730c90ca6}{ns3\+::\+Tcp\+Illinois}, \hyperlink{classns3_1_1TcpVeno_a03a169d4fd7653a6a56a7963578cc489}{ns3\+::\+Tcp\+Veno}, \hyperlink{classns3_1_1TcpVegas_af42952eb204ae641900b1d0ef4d39d97}{ns3\+::\+Tcp\+Vegas}, \hyperlink{classns3_1_1TcpLedbat_a8d228eff64ff4a9d8d64e939ee19d016}{ns3\+::\+Tcp\+Ledbat}, \hyperlink{classns3_1_1TcpWestwood_a9e3849fbc8244c5748e49ab2e8b149c4}{ns3\+::\+Tcp\+Westwood}, \hyperlink{classns3_1_1TcpScalable_afc28d1793481db0978085efc5b2c243e}{ns3\+::\+Tcp\+Scalable}, \hyperlink{classns3_1_1TcpHighSpeed_abc432f29ca437f1a62cd17d614568842}{ns3\+::\+Tcp\+High\+Speed}, and \hyperlink{classns3_1_1TcpHtcp_add36278610893b4eba23cf688f7779d8}{ns3\+::\+Tcp\+Htcp}.


\begin{DoxyCode}
206 \{
207   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << state << bytesInFlight);
208 
209   \textcolor{keywordflow}{return} \hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{std::max} (2 * state->m\_segmentSize, bytesInFlight / 2);
210 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::\+Tcp\+New\+Reno@{ns3\+::\+Tcp\+New\+Reno}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Tcp\+New\+Reno@{ns3\+::\+Tcp\+New\+Reno}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Tcp\+New\+Reno\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1TcpNewReno_af4f4778f724f72a8a441ac0af4cdd8fe}{}\label{classns3_1_1TcpNewReno_af4f4778f724f72a8a441ac0af4cdd8fe}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
58 \{
59   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::TcpNewReno"})
60     .SetParent<\hyperlink{classns3_1_1TcpCongestionOps_a044982d009b94a2bbf59ed27cdb14e91}{TcpCongestionOps}> ()
61     .SetGroupName (\textcolor{stringliteral}{"Internet"})
62     .AddConstructor<\hyperlink{classns3_1_1TcpNewReno_a81686cb1590be6d7c754029fc8d7cf4e}{TcpNewReno}> ()
63   ;
64   \textcolor{keywordflow}{return} tid;
65 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5




Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::\+Tcp\+New\+Reno@{ns3\+::\+Tcp\+New\+Reno}!Increase\+Window@{Increase\+Window}}
\index{Increase\+Window@{Increase\+Window}!ns3\+::\+Tcp\+New\+Reno@{ns3\+::\+Tcp\+New\+Reno}}
\subsubsection[{\texorpdfstring{Increase\+Window(\+Ptr$<$ Tcp\+Socket\+State $>$ tcb, uint32\+\_\+t segments\+Acked)}{IncreaseWindow(Ptr< TcpSocketState > tcb, uint32_t segmentsAcked)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+New\+Reno\+::\+Increase\+Window (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Tcp\+Socket\+State} $>$}]{tcb, }
\item[{uint32\+\_\+t}]{segments\+Acked}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TcpNewReno_a11db8ae90f4cebacc15524a793b0741a}{}\label{classns3_1_1TcpNewReno_a11db8ae90f4cebacc15524a793b0741a}


Try to increase the c\+Wnd following the New\+Reno specification. 

\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1TcpNewReno_a1cf5fd9585eb3b745727f4f5beae0706}{Slow\+Start} 

\hyperlink{classns3_1_1TcpNewReno_a34a5eec0649a7b485852c74c825e14ba}{Congestion\+Avoidance}
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em tcb} & internal congestion state \\
\hline
{\em segments\+Acked} & count of segments acked \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1TcpCongestionOps_a3cdceb0ace37bc606d34369ab3f920f0}{ns3\+::\+Tcp\+Congestion\+Ops}.



Reimplemented in \hyperlink{classns3_1_1TcpIllinois_aed96b4a9fcf68ca3c290e4e7114d13c7}{ns3\+::\+Tcp\+Illinois}, \hyperlink{classns3_1_1TcpYeah_aa1efa60adbcb1dfad8d188deef7ed2ea}{ns3\+::\+Tcp\+Yeah}, \hyperlink{classns3_1_1TcpVeno_a5865787a20ea7c2c8beee2df5cefcdaa}{ns3\+::\+Tcp\+Veno}, \hyperlink{classns3_1_1TcpVegas_ae80e9ac677116dada43dacda0f98a8b6}{ns3\+::\+Tcp\+Vegas}, and \hyperlink{classns3_1_1TcpLedbat_a9baf3c7c8d5572c3cf7c4249a2833748}{ns3\+::\+Tcp\+Ledbat}.


\begin{DoxyCode}
174 \{
175   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << tcb << segmentsAcked);
176 
177   \textcolor{keywordflow}{if} (tcb->\hyperlink{classns3_1_1TcpSocketState_a7cd3d2156a483c1db436097477a0fd7f}{m\_cWnd} < tcb->\hyperlink{classns3_1_1TcpSocketState_aec003b6dba9d269bfb1036c7652ffbd6}{m\_ssThresh})
178     \{
179       segmentsAcked = \hyperlink{classns3_1_1TcpNewReno_a1cf5fd9585eb3b745727f4f5beae0706}{SlowStart} (tcb, segmentsAcked);
180     \}
181 
182   \textcolor{keywordflow}{if} (tcb->\hyperlink{classns3_1_1TcpSocketState_a7cd3d2156a483c1db436097477a0fd7f}{m\_cWnd} >= tcb->\hyperlink{classns3_1_1TcpSocketState_aec003b6dba9d269bfb1036c7652ffbd6}{m\_ssThresh})
183     \{
184       \hyperlink{classns3_1_1TcpNewReno_a34a5eec0649a7b485852c74c825e14ba}{CongestionAvoidance} (tcb, segmentsAcked);
185     \}
186 
187   \textcolor{comment}{/* At this point, we could have segmentsAcked != 0. This because RFC says}
188 \textcolor{comment}{   * that in slow start, we should increase cWnd by min (N, SMSS); if in}
189 \textcolor{comment}{   * slow start we receive a cumulative ACK, it counts only for 1 SMSS of}
190 \textcolor{comment}{   * increase, wasting the others.}
191 \textcolor{comment}{   *}
192 \textcolor{comment}{   * // Uncorrect assert, I am sorry}
193 \textcolor{comment}{   * NS\_ASSERT (segmentsAcked == 0);}
194 \textcolor{comment}{   */}
195 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7




Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::\+Tcp\+New\+Reno@{ns3\+::\+Tcp\+New\+Reno}!Slow\+Start@{Slow\+Start}}
\index{Slow\+Start@{Slow\+Start}!ns3\+::\+Tcp\+New\+Reno@{ns3\+::\+Tcp\+New\+Reno}}
\subsubsection[{\texorpdfstring{Slow\+Start(\+Ptr$<$ Tcp\+Socket\+State $>$ tcb, uint32\+\_\+t segments\+Acked)}{SlowStart(Ptr< TcpSocketState > tcb, uint32_t segmentsAcked)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Tcp\+New\+Reno\+::\+Slow\+Start (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Tcp\+Socket\+State} $>$}]{tcb, }
\item[{uint32\+\_\+t}]{segments\+Acked}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1TcpNewReno_a1cf5fd9585eb3b745727f4f5beae0706}{}\label{classns3_1_1TcpNewReno_a1cf5fd9585eb3b745727f4f5beae0706}


Tcp New\+Reno slow start algorithm. 

Defined in R\+FC 5681 as

\begin{quote}
During slow start, a T\+CP increments cwnd by at most S\+M\+SS bytes for each A\+CK received that cumulatively acknowledges new data. Slow start ends when cwnd exceeds ssthresh (or, optionally, when it reaches it, as noted above) or when congestion is observed. While traditionally T\+CP implementations have increased cwnd by precisely S\+M\+SS bytes upon receipt of an A\+CK covering new data, we R\+E\+C\+O\+M\+M\+E\+ND that T\+CP implementations increase cwnd, per\+:

cwnd += min (N, S\+M\+SS) (2)

where N is the number of previously unacknowledged bytes acknowledged in the incoming A\+CK. \end{quote}


The ns-\/3 implementation respect the R\+FC definition. Linux does something different\+: \begin{DoxyVerb}u32 tcp_slow_start(struct tcp_sock *tp, u32 acked)
  {
    u32 cwnd = tp->snd_cwnd + acked;

    if (cwnd > tp->snd_ssthresh)
      cwnd = tp->snd_ssthresh + 1;
    acked -= cwnd - tp->snd_cwnd;
    tp->snd_cwnd = min(cwnd, tp->snd_cwnd_clamp);

    return acked;
  }\end{DoxyVerb}


As stated, we want to avoid the case when a cumulative A\+CK increases c\+Wnd more than a segment size, but we keep count of how many segments we have ignored, and return them.


\begin{DoxyParams}{Parameters}
{\em tcb} & internal congestion state \\
\hline
{\em segments\+Acked} & count of segments acked \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of segments not considered for increasing the c\+Wnd 
\end{DoxyReturn}


Reimplemented in \hyperlink{classns3_1_1TcpHybla_a374c804fcaf21e2cd4c51f0ff6003798}{ns3\+::\+Tcp\+Hybla}.


\begin{DoxyCode}
126 \{
127   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << tcb << segmentsAcked);
128 
129   \textcolor{keywordflow}{if} (segmentsAcked >= 1)
130     \{
131       tcb->\hyperlink{classns3_1_1TcpSocketState_a7cd3d2156a483c1db436097477a0fd7f}{m\_cWnd} += tcb->\hyperlink{classns3_1_1TcpSocketState_a079872f7b0099ef5f3cab4ff47bd2edd}{m\_segmentSize};
132       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"In SlowStart, updated to cwnd "} << tcb->\hyperlink{classns3_1_1TcpSocketState_a7cd3d2156a483c1db436097477a0fd7f}{m\_cWnd} << \textcolor{stringliteral}{" ssthresh "} << tcb
      ->\hyperlink{classns3_1_1TcpSocketState_aec003b6dba9d269bfb1036c7652ffbd6}{m\_ssThresh});
133       \textcolor{keywordflow}{return} segmentsAcked - 1;
134     \}
135 
136   \textcolor{keywordflow}{return} 0;
137 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 9




The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/model/\hyperlink{tcp-congestion-ops_8h}{tcp-\/congestion-\/ops.\+h}\item 
internet/model/\hyperlink{tcp-congestion-ops_8cc}{tcp-\/congestion-\/ops.\+cc}\end{DoxyCompactItemize}
