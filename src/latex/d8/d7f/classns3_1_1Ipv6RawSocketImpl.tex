\hypertarget{classns3_1_1Ipv6RawSocketImpl}{}\section{ns3\+:\+:Ipv6\+Raw\+Socket\+Impl Class Reference}
\label{classns3_1_1Ipv6RawSocketImpl}\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}


I\+Pv6 raw socket.  




{\ttfamily \#include $<$ipv6-\/raw-\/socket-\/impl.\+h$>$}



Inheritance diagram for ns3\+:\+:Ipv6\+Raw\+Socket\+Impl\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Ipv6\+Raw\+Socket\+Impl\+:
% FIG 1
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structns3_1_1Ipv6RawSocketImpl_1_1Data}{Data}
\begin{DoxyCompactList}\small\item\em I\+Pv6 raw data and additional information. \end{DoxyCompactList}\item 
struct \hyperlink{structns3_1_1Ipv6RawSocketImpl_1_1Icmpv6Filter}{Icmpv6\+Filter}
\begin{DoxyCompactList}\small\item\em Struct to hold the I\+C\+M\+Pv6 filter. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ipv6RawSocketImpl_aa3ee357e602db12a279eb34ba2968391}{Ipv6\+Raw\+Socket\+Impl} ()
\item 
virtual \hyperlink{classns3_1_1Ipv6RawSocketImpl_ac481e99e425628799233db0a0fbfcef4}{$\sim$\+Ipv6\+Raw\+Socket\+Impl} ()
\item 
void \hyperlink{classns3_1_1Ipv6RawSocketImpl_a227c78fa2bf8af76f79bf8c8f8e84c71}{Set\+Node} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node)
\begin{DoxyCompactList}\small\item\em Set the node associated with this socket. \end{DoxyCompactList}\item 
virtual enum \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket\+::\+Socket\+Errno} \hyperlink{classns3_1_1Ipv6RawSocketImpl_a0e89d09b36d374f55ff7942a1d87a8ca}{Get\+Errno} () const 
\begin{DoxyCompactList}\small\item\em Get last error number. \end{DoxyCompactList}\item 
virtual enum \hyperlink{classns3_1_1Socket_a698fbcc486a48b7a0d2b0e4ab863d571}{Socket\+::\+Socket\+Type} \hyperlink{classns3_1_1Ipv6RawSocketImpl_ac44d22012dfc6959efd11f1688ac15bd}{Get\+Socket\+Type} () const 
\begin{DoxyCompactList}\small\item\em Get socket type (N\+S3\+\_\+\+S\+O\+C\+K\+\_\+\+R\+AW) \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1Ipv6RawSocketImpl_a0e1459bc9485933deba1135dc70d7d6f}{Get\+Node} () const 
\begin{DoxyCompactList}\small\item\em Return the node this socket is associated with. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1Ipv6RawSocketImpl_a3c6150fb423e1a88bc12a9a1f0fa7243}{Bind} (const \hyperlink{classns3_1_1Address}{Address} \&address)
\begin{DoxyCompactList}\small\item\em Allocate a local endpoint for this socket. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1Ipv6RawSocketImpl_a603c1513edeb41a86ab7728c955e44f4}{Bind} ()
\begin{DoxyCompactList}\small\item\em Allocate a local I\+Pv4 endpoint for this socket. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1Ipv6RawSocketImpl_abcf2203adb441fb47bdff155bec17d19}{Bind6} ()
\begin{DoxyCompactList}\small\item\em Allocate a local I\+Pv6 endpoint for this socket. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1Ipv6RawSocketImpl_abeb2cea9c843ffd9dbe2697986384758}{Get\+Sock\+Name} (\hyperlink{classns3_1_1Address}{Address} \&address) const 
\begin{DoxyCompactList}\small\item\em Get socket address. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1Ipv6RawSocketImpl_ac04cccb682dbc921f8478b152fa115bd}{Get\+Peer\+Name} (\hyperlink{classns3_1_1Address}{Address} \&address) const 
\begin{DoxyCompactList}\small\item\em Get the peer address of a connected socket. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1Ipv6RawSocketImpl_a2abab77b9bf0cc99272ce5549690f8cb}{Close} ()
\begin{DoxyCompactList}\small\item\em Close a socket. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1Ipv6RawSocketImpl_ae485f899ce976e799770adb46a5fdd91}{Shutdown\+Send} ()
\item 
virtual int \hyperlink{classns3_1_1Ipv6RawSocketImpl_a7ce536d970b3546fe5bce17dbe9ab38d}{Shutdown\+Recv} ()
\item 
virtual int \hyperlink{classns3_1_1Ipv6RawSocketImpl_a497cee47b0eb1a7a585f88fbcf152aa9}{Connect} (const \hyperlink{classns3_1_1Address}{Address} \&address)
\begin{DoxyCompactList}\small\item\em Initiate a connection to a remote host. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1Ipv6RawSocketImpl_a1b0f410496348c5869a1c86437172b2a}{Listen} ()
\begin{DoxyCompactList}\small\item\em Listen for incoming connections. \end{DoxyCompactList}\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1Ipv6RawSocketImpl_a1edb9813fe9214132899b93da6e3684d}{Get\+Tx\+Available} () const 
\begin{DoxyCompactList}\small\item\em Returns the number of bytes which can be sent in a single call to Send. \end{DoxyCompactList}\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1Ipv6RawSocketImpl_af96fcf5ece8867992a4ccdad54ffc90b}{Get\+Rx\+Available} () const 
\item 
virtual int \hyperlink{classns3_1_1Ipv6RawSocketImpl_a889224d7c084b74b3a1a3511899a04f3}{Send} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, uint32\+\_\+t flags)
\begin{DoxyCompactList}\small\item\em Send data (or dummy data) to the remote host. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1Ipv6RawSocketImpl_aadff84e3c8a3ce3bc4f10a3d7a4dbac8}{Send\+To} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, uint32\+\_\+t flags, const \hyperlink{classns3_1_1Address}{Address} \&to\+Address)
\begin{DoxyCompactList}\small\item\em Send data to a specified peer. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{classns3_1_1Ipv6RawSocketImpl_a2e86d6b6c347fe37a577ba0d9fcb411d}{Recv} (uint32\+\_\+t max\+Size, uint32\+\_\+t flags)
\begin{DoxyCompactList}\small\item\em Read data from the socket. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{classns3_1_1Ipv6RawSocketImpl_a582900364192f1181e1c904b1a5af6a8}{Recv\+From} (uint32\+\_\+t max\+Size, uint32\+\_\+t flags, \hyperlink{classns3_1_1Address}{Address} \&from\+Address)
\begin{DoxyCompactList}\small\item\em Read a single packet from the socket and retrieve the sender address. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6RawSocketImpl_a8cb33ebfedf6ce3baaff6048fd41576c}{Ipv6\+Join\+Group} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} address, \hyperlink{classns3_1_1Socket_a96f39fe2b73d5691b319093a1e31615d}{Socket\+::\+Ipv6\+Multicast\+Filter\+Mode} filter\+Mode, std\+::vector$<$ \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} $>$ source\+Addresses)
\begin{DoxyCompactList}\small\item\em Joins a I\+Pv6 multicast group. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6RawSocketImpl_a063d026e3e6e82a05de4e49c06f41129}{Set\+Protocol} (uint16\+\_\+t protocol)
\begin{DoxyCompactList}\small\item\em Set protocol field. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Ipv6RawSocketImpl_a9b9d0def6375d0a3fbcaa552ebc3e03d}{Forward\+Up} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} hdr, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device)
\begin{DoxyCompactList}\small\item\em Forward up to receive method. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1Ipv6RawSocketImpl_a651705d6a9cbba054335a04c6c2eeb4c}{Set\+Allow\+Broadcast} (bool allow\+Broadcast)
\begin{DoxyCompactList}\small\item\em Configure whether broadcast datagram transmissions are allowed. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1Ipv6RawSocketImpl_aa66f85c6c47363fb210cbe7153dd041f}{Get\+Allow\+Broadcast} () const 
\begin{DoxyCompactList}\small\item\em Query whether broadcast datagram transmissions are allowed. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6RawSocketImpl_afbbc42522b8999a4dc097255db47920d}{Icmpv6\+Filter\+Set\+Pass\+All} ()
\begin{DoxyCompactList}\small\item\em Clean the I\+C\+M\+Pv6 filter structure. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6RawSocketImpl_a12e988b66bdb489166a963251e744a0a}{Icmpv6\+Filter\+Set\+Block\+All} ()
\begin{DoxyCompactList}\small\item\em Set the filter to block all the I\+C\+M\+Pv6 types. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6RawSocketImpl_aea0f1182fba44167195eaf8990a5e7b6}{Icmpv6\+Filter\+Set\+Pass} (uint8\+\_\+t \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type})
\begin{DoxyCompactList}\small\item\em Set the filter to pass one I\+C\+M\+Pv6 type. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6RawSocketImpl_a2f850eddcc724122f7a287fee390fa4d}{Icmpv6\+Filter\+Set\+Block} (uint8\+\_\+t \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type})
\begin{DoxyCompactList}\small\item\em Set the filter to block one I\+C\+M\+Pv6 type. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Ipv6RawSocketImpl_aa980b224df04ec9341eb6407cd9947df}{Icmpv6\+Filter\+Will\+Pass} (uint8\+\_\+t \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type})
\begin{DoxyCompactList}\small\item\em Ask the filter about the status of one I\+C\+M\+Pv6 type. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Ipv6RawSocketImpl_a033c506bc14bddc3f9ef47bc71efa328}{Icmpv6\+Filter\+Will\+Block} (uint8\+\_\+t \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type})
\begin{DoxyCompactList}\small\item\em Ask the filter about the status of one I\+C\+M\+Pv6 type. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1Ipv6RawSocketImpl_a5f950ca300c163fd1b3276668f77be47}{Get\+Type\+Id} ()
\begin{DoxyCompactList}\small\item\em Get the type ID of this class. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1Ipv6RawSocketImpl_a34d6a77e528c452f79a4feb25925b17e}{Do\+Dispose} ()
\begin{DoxyCompactList}\small\item\em Dispose object. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket\+::\+Socket\+Errno} \hyperlink{classns3_1_1Ipv6RawSocketImpl_afabd1db84eac91197faac4f4852d8681}{m\+\_\+err}
\begin{DoxyCompactList}\small\item\em Last error number. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1Ipv6RawSocketImpl_a2afa14d1f4c1f729c989c00e3ad350fb}{m\+\_\+node}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Node}{Node}. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} \hyperlink{classns3_1_1Ipv6RawSocketImpl_a33e8cd6e8ef2da88c6a8e954f23048d0}{m\+\_\+src}
\begin{DoxyCompactList}\small\item\em Source address. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} \hyperlink{classns3_1_1Ipv6RawSocketImpl_ac1bd7e150da6118befd78831b483c0ca}{m\+\_\+dst}
\begin{DoxyCompactList}\small\item\em Destination address. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1Ipv6RawSocketImpl_ac745a953c5ec673bd89b170eaadab548}{m\+\_\+protocol}
\begin{DoxyCompactList}\small\item\em Protocol. \end{DoxyCompactList}\item 
\hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{structns3_1_1Ipv6RawSocketImpl_1_1Data}{Data} $>$ \hyperlink{classns3_1_1Ipv6RawSocketImpl_ae01fe78981765eec9f036e4cd657c73a}{m\+\_\+data}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Packet}{Packet} waiting to be processed. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Ipv6RawSocketImpl_a974dfa7bfc98a6c070d74b42dbc1cb30}{m\+\_\+shutdown\+Send}
\begin{DoxyCompactList}\small\item\em Flag to shutdown send capability. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Ipv6RawSocketImpl_a6db5d278326c66329425f615ccdf63ec}{m\+\_\+shutdown\+Recv}
\begin{DoxyCompactList}\small\item\em Flag to shutdown receive capability. \end{DoxyCompactList}\item 
\hyperlink{structns3_1_1Ipv6RawSocketImpl_1_1Icmpv6Filter}{Icmpv6\+Filter} \hyperlink{classns3_1_1Ipv6RawSocketImpl_a38df054d5b81d3d1d29543fff42f44bb}{m\+\_\+icmp\+Filter}
\begin{DoxyCompactList}\small\item\em I\+C\+M\+Pv6 filter. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
I\+Pv6 raw socket. 

A R\+AW \hyperlink{classns3_1_1Socket}{Socket} typically is used to access specific IP layers not usually available through L4 sockets, e.\+g., I\+C\+MP. The implementer should take particular care to define the \hyperlink{classns3_1_1Ipv6RawSocketImpl}{Ipv6\+Raw\+Socket\+Impl} Attributes, and in particular the Protocol attribute. Not setting it will result in a zero protocol at IP level (corresponding to the Hop\+By\+Hop I\+Pv6 Extension header, i.\+e., \hyperlink{classns3_1_1Ipv6ExtensionHopByHopHeader}{Ipv6\+Extension\+Hop\+By\+Hop\+Header}) when sending data through the socket, which is probably not the intended behavior.

A correct example is (from src/applications/model/radvd.\+cc)\+: 
\begin{DoxyCode}
\textcolor{keywordflow}{if} (!m\_socket)
  \{
    TypeId tid = \hyperlink{classns3_1_1TypeId_a119cf99c20931fdc294602cd360b180e}{TypeId::LookupByName} (\textcolor{stringliteral}{"ns3::Ipv6RawSocketFactory"});
    m\_socket = \hyperlink{classns3_1_1Socket_ad448a62bb50ad3dbac59c879a885a8d2}{Socket::CreateSocket} (\hyperlink{classns3_1_1Ipv6RawSocketImpl_a0e1459bc9485933deba1135dc70d7d6f}{GetNode} (), tid);

    \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (m\_socket);

    m\_socket->SetAttribute (\textcolor{stringliteral}{"Protocol"}, UintegerValue(\hyperlink{classns3_1_1Ipv6Header_a226429221a066c5e3b1f260caf27d1e9a5a1ba2c977ece2a8089761a3bd2e5478}{Ipv6Header::IPV6\_ICMPV6}));
    m\_socket->SetRecvCallback (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&\hyperlink{classns3_1_1Radvd_a75cc828bc07117551ab886d986590045}{Radvd::HandleRead}, \textcolor{keyword}{this}));
  \}
\end{DoxyCode}
 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Ipv6\+Raw\+Socket\+Impl@{Ipv6\+Raw\+Socket\+Impl}}
\index{Ipv6\+Raw\+Socket\+Impl@{Ipv6\+Raw\+Socket\+Impl}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Ipv6\+Raw\+Socket\+Impl()}{Ipv6RawSocketImpl()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Ipv6\+Raw\+Socket\+Impl (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6RawSocketImpl_aa3ee357e602db12a279eb34ba2968391}{}\label{classns3_1_1Ipv6RawSocketImpl_aa3ee357e602db12a279eb34ba2968391}

\begin{DoxyCode}
59 \{
60   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
61   \hyperlink{classns3_1_1Ipv6RawSocketImpl_afabd1db84eac91197faac4f4852d8681}{m\_err} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaaa7eb006d73c5ad0117c5591fcb3469f7}{Socket::ERROR\_NOTERROR};
62   \hyperlink{classns3_1_1Ipv6RawSocketImpl_a2afa14d1f4c1f729c989c00e3ad350fb}{m\_node} = 0;
63   \hyperlink{classns3_1_1Ipv6RawSocketImpl_a33e8cd6e8ef2da88c6a8e954f23048d0}{m\_src} = \hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} ();
64   \hyperlink{classns3_1_1Ipv6RawSocketImpl_ac1bd7e150da6118befd78831b483c0ca}{m\_dst} = \hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} ();
65   \hyperlink{classns3_1_1Ipv6RawSocketImpl_ac745a953c5ec673bd89b170eaadab548}{m\_protocol} = 0;
66   \hyperlink{classns3_1_1Ipv6RawSocketImpl_a974dfa7bfc98a6c070d74b42dbc1cb30}{m\_shutdownSend} = \textcolor{keyword}{false};
67   \hyperlink{classns3_1_1Ipv6RawSocketImpl_a6db5d278326c66329425f615ccdf63ec}{m\_shutdownRecv} = \textcolor{keyword}{false};
68   \hyperlink{classns3_1_1Ipv6RawSocketImpl_afbbc42522b8999a4dc097255db47920d}{Icmpv6FilterSetPassAll}();
69 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!````~Ipv6\+Raw\+Socket\+Impl@{$\sim$\+Ipv6\+Raw\+Socket\+Impl}}
\index{````~Ipv6\+Raw\+Socket\+Impl@{$\sim$\+Ipv6\+Raw\+Socket\+Impl}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{$\sim$\+Ipv6\+Raw\+Socket\+Impl()}{~Ipv6RawSocketImpl()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::$\sim$\+Ipv6\+Raw\+Socket\+Impl (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_ac481e99e425628799233db0a0fbfcef4}{}\label{classns3_1_1Ipv6RawSocketImpl_ac481e99e425628799233db0a0fbfcef4}

\begin{DoxyCode}
72 \{
73 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Bind@{Bind}}
\index{Bind@{Bind}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Bind(const Address \&address)}{Bind(const Address &address)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Bind (
\begin{DoxyParamCaption}
\item[{const {\bf Address} \&}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_a3c6150fb423e1a88bc12a9a1f0fa7243}{}\label{classns3_1_1Ipv6RawSocketImpl_a3c6150fb423e1a88bc12a9a1f0fa7243}


Allocate a local endpoint for this socket. 


\begin{DoxyParams}{Parameters}
{\em address} & the address to try to allocate \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, -\/1 on failure. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_ada93439a43de2028b5a8fc6621dad482}{ns3\+::\+Socket}.


\begin{DoxyCode}
105 \{
106   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << address);
107 
108   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1Inet6SocketAddress_a4d928c54affbfb530a12076d6d7e0540}{Inet6SocketAddress::IsMatchingType} (address))
109     \{
110       \hyperlink{classns3_1_1Ipv6RawSocketImpl_afabd1db84eac91197faac4f4852d8681}{m\_err} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa4b98dd50740861229f8e03bcc36d379b}{Socket::ERROR\_INVAL};
111       \textcolor{keywordflow}{return} -1;
112     \}
113   Inet6SocketAddress ad = \hyperlink{classns3_1_1Inet6SocketAddress_a2177c66e1bcf17c85dcffb9d2a971f5a}{Inet6SocketAddress::ConvertFrom} (address);
114   \hyperlink{classns3_1_1Ipv6RawSocketImpl_a33e8cd6e8ef2da88c6a8e954f23048d0}{m\_src} = ad.GetIpv6 ();
115   \textcolor{keywordflow}{return} 0;
116 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Bind@{Bind}}
\index{Bind@{Bind}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Bind()}{Bind()}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Bind (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_a603c1513edeb41a86ab7728c955e44f4}{}\label{classns3_1_1Ipv6RawSocketImpl_a603c1513edeb41a86ab7728c955e44f4}


Allocate a local I\+Pv4 endpoint for this socket. 

\begin{DoxyReturn}{Returns}
0 on success, -\/1 on failure. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_a680c1edd8b3ec3adf4085e1ded1e8a0d}{ns3\+::\+Socket}.


\begin{DoxyCode}
119 \{
120   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
121   \hyperlink{classns3_1_1Ipv6RawSocketImpl_a33e8cd6e8ef2da88c6a8e954f23048d0}{m\_src} = \hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} ();
122   \textcolor{keywordflow}{return} 0;
123 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4




Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Bind6@{Bind6}}
\index{Bind6@{Bind6}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Bind6()}{Bind6()}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Bind6 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_abcf2203adb441fb47bdff155bec17d19}{}\label{classns3_1_1Ipv6RawSocketImpl_abcf2203adb441fb47bdff155bec17d19}


Allocate a local I\+Pv6 endpoint for this socket. 

\begin{DoxyReturn}{Returns}
0 on success, -\/1 on failure. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_a68a4f2bcd38dec94d5a6fd4d867a1f19}{ns3\+::\+Socket}.


\begin{DoxyCode}
126 \{
127   \textcolor{keywordflow}{return}(\hyperlink{classns3_1_1Ipv6RawSocketImpl_a603c1513edeb41a86ab7728c955e44f4}{Bind}());
128 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6


\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Close@{Close}}
\index{Close@{Close}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Close()}{Close()}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Close (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_a2abab77b9bf0cc99272ce5549690f8cb}{}\label{classns3_1_1Ipv6RawSocketImpl_a2abab77b9bf0cc99272ce5549690f8cb}


Close a socket. 

\begin{DoxyReturn}{Returns}
zero on success, -\/1 on failure.
\end{DoxyReturn}
After the Close call, the socket is no longer valid, and cannot safely be used for subsequent operations. 

Implements \hyperlink{classns3_1_1Socket_abdac6e2498c5aa2963ef361d4200ddf3}{ns3\+::\+Socket}.


\begin{DoxyCode}
154 \{
155   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
156   Ptr<Ipv6L3Protocol> ipv6 = \hyperlink{classns3_1_1Ipv6RawSocketImpl_a2afa14d1f4c1f729c989c00e3ad350fb}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv6L3Protocol> ();
157 
158   \hyperlink{classns3_1_1Socket_af70f1ddca0d73f98103a2b86bec4c85e}{Ipv6LeaveGroup} ();
159   \textcolor{keywordflow}{if} (ipv6)
160     \{
161       ipv6->DeleteRawSocket (\textcolor{keyword}{this});
162     \}
163   \textcolor{keywordflow}{return} 0;
164 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7


\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Connect@{Connect}}
\index{Connect@{Connect}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Connect(const Address \&address)}{Connect(const Address &address)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Connect (
\begin{DoxyParamCaption}
\item[{const {\bf Address} \&}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_a497cee47b0eb1a7a585f88fbcf152aa9}{}\label{classns3_1_1Ipv6RawSocketImpl_a497cee47b0eb1a7a585f88fbcf152aa9}


Initiate a connection to a remote host. 


\begin{DoxyParams}{Parameters}
{\em address} & \hyperlink{classns3_1_1Address}{Address} of remote. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, -\/1 on error (in which case errno is set). 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_a97f08aaf37b8fd7d4b5cad4dfdd4022a}{ns3\+::\+Socket}.


\begin{DoxyCode}
181 \{
182   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << address);
183 
184   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1Inet6SocketAddress_a4d928c54affbfb530a12076d6d7e0540}{Inet6SocketAddress::IsMatchingType} (address))
185     \{
186       \hyperlink{classns3_1_1Ipv6RawSocketImpl_afabd1db84eac91197faac4f4852d8681}{m\_err} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa4b98dd50740861229f8e03bcc36d379b}{Socket::ERROR\_INVAL};
187       \textcolor{keywordflow}{return} -1;
188     \}
189   Inet6SocketAddress ad = \hyperlink{classns3_1_1Inet6SocketAddress_a2177c66e1bcf17c85dcffb9d2a971f5a}{Inet6SocketAddress::ConvertFrom} (address);
190   \hyperlink{classns3_1_1Ipv6RawSocketImpl_ac1bd7e150da6118befd78831b483c0ca}{m\_dst} = ad.GetIpv6 ();
191 
192   \textcolor{keywordflow}{return} 0;
193 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8


\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Do\+Dispose()}{DoDispose()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_a34d6a77e528c452f79a4feb25925b17e}{}\label{classns3_1_1Ipv6RawSocketImpl_a34d6a77e528c452f79a4feb25925b17e}


Dispose object. 



Reimplemented from \hyperlink{classns3_1_1Socket_a5498f836b9b551dd7069562d05382e83}{ns3\+::\+Socket}.


\begin{DoxyCode}
76 \{
77   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
78   \hyperlink{classns3_1_1Ipv6RawSocketImpl_a2afa14d1f4c1f729c989c00e3ad350fb}{m\_node} = 0;
79   \hyperlink{classns3_1_1Socket_a5498f836b9b551dd7069562d05382e83}{Socket::DoDispose} ();
80 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9


\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Forward\+Up@{Forward\+Up}}
\index{Forward\+Up@{Forward\+Up}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Forward\+Up(\+Ptr$<$ const Packet $>$ p, Ipv6\+Header hdr, Ptr$<$ Net\+Device $>$ device)}{ForwardUp(Ptr< const Packet > p, Ipv6Header hdr, Ptr< NetDevice > device)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Forward\+Up (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p, }
\item[{{\bf Ipv6\+Header}}]{hdr, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{device}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6RawSocketImpl_a9b9d0def6375d0a3fbcaa552ebc3e03d}{}\label{classns3_1_1Ipv6RawSocketImpl_a9b9d0def6375d0a3fbcaa552ebc3e03d}


Forward up to receive method. 


\begin{DoxyParams}{Parameters}
{\em p} & packet \\
\hline
{\em hdr} & I\+Pv6 header \\
\hline
{\em device} & device \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if forwarded, false otherwise 
\end{DoxyReturn}

\begin{DoxyCode}
398 \{
399   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << *\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} << hdr << device);
400 
401   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6RawSocketImpl_a6db5d278326c66329425f615ccdf63ec}{m\_shutdownRecv})
402     \{
403       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
404     \}
405 
406   Ptr<NetDevice> boundNetDevice = \hyperlink{classns3_1_1Socket_a04ae6be2aded03caaa262e274dc8a2fd}{Socket::GetBoundNetDevice}();
407   \textcolor{keywordflow}{if} (boundNetDevice)
408     \{
409       \textcolor{keywordflow}{if} (boundNetDevice != device)
410         \{
411           \textcolor{keywordflow}{return} \textcolor{keyword}{false};
412         \}
413     \}
414 
415   \textcolor{keywordflow}{if} ((\hyperlink{classns3_1_1Ipv6RawSocketImpl_a33e8cd6e8ef2da88c6a8e954f23048d0}{m\_src} == \hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} () || hdr.GetDestinationAddress () == 
      \hyperlink{classns3_1_1Ipv6RawSocketImpl_a33e8cd6e8ef2da88c6a8e954f23048d0}{m\_src}) && 
416       (\hyperlink{classns3_1_1Ipv6RawSocketImpl_ac1bd7e150da6118befd78831b483c0ca}{m\_dst} == \hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} () || hdr.GetSourceAddress () == 
      \hyperlink{classns3_1_1Ipv6RawSocketImpl_ac1bd7e150da6118befd78831b483c0ca}{m\_dst}) &&
417       hdr.GetNextHeader () == \hyperlink{classns3_1_1Ipv6RawSocketImpl_ac745a953c5ec673bd89b170eaadab548}{m\_protocol})
418     \{
419       Ptr<Packet> copy = \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->Copy ();
420 
421       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6RawSocketImpl_ac745a953c5ec673bd89b170eaadab548}{m\_protocol} == \hyperlink{classns3_1_1Icmpv6L4Protocol_af845269e6c3f4509a4e287195c965afc}{Icmpv6L4Protocol::GetStaticProtocolNumber}
       ())
422         \{
423           \textcolor{comment}{/* filter */}
424           Icmpv6Header icmpHeader;
425           copy->PeekHeader (icmpHeader);
426           uint8\_t \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type} = icmpHeader.GetType ();
427 
428           \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6RawSocketImpl_a033c506bc14bddc3f9ef47bc71efa328}{Icmpv6FilterWillBlock}(type))
429             \{
430               \textcolor{comment}{/* packet filtered */}
431               \textcolor{keywordflow}{return} \textcolor{keyword}{false};
432             \}
433         \}
434 
435       \textcolor{comment}{// Should check via getsockopt ().}
436       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Socket_a104a42cdf0290b4e8867b4c0a77aadc2}{IsRecvPktInfo} ())
437         \{
438           Ipv6PacketInfoTag tag;
439           copy->RemovePacketTag (tag);
440           tag.SetRecvIf (device->GetIfIndex ());
441           copy->AddPacketTag (tag);
442         \}
443 
444       \textcolor{comment}{// Check only version 6 options}
445       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Socket_ad9b8d1ceb1e0b80609b7c6a1c1392eec}{IsIpv6RecvTclass} ())
446         \{
447           SocketIpv6TclassTag ipTclassTag;
448           ipTclassTag.SetTclass (hdr.GetTrafficClass ());
449           copy->AddPacketTag (ipTclassTag);
450         \}
451 
452       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Socket_a99fb541eff485b5b2c6fa7f0aac3abb9}{IsIpv6RecvHopLimit} ())
453         \{
454           SocketIpv6HopLimitTag ipHopLimitTag;
455           ipHopLimitTag.SetHopLimit (hdr.GetHopLimit ());
456           copy->AddPacketTag (ipHopLimitTag);
457         \}
458 
459       copy->AddHeader (hdr);
460       Data \hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data};
461       data.packet = copy;
462       data.fromIp = hdr.GetSourceAddress ();
463       data.fromProtocol = hdr.GetNextHeader ();
464       \hyperlink{classns3_1_1Ipv6RawSocketImpl_ae01fe78981765eec9f036e4cd657c73a}{m\_data}.push\_back (data);
465       \hyperlink{classns3_1_1Socket_a91fa3046bbd0a7644381f1d2481bdfef}{NotifyDataRecv} ();
466       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
467     \}
468   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
469 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10


\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Get\+Allow\+Broadcast@{Get\+Allow\+Broadcast}}
\index{Get\+Allow\+Broadcast@{Get\+Allow\+Broadcast}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Allow\+Broadcast() const }{GetAllowBroadcast() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Get\+Allow\+Broadcast (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_aa66f85c6c47363fb210cbe7153dd041f}{}\label{classns3_1_1Ipv6RawSocketImpl_aa66f85c6c47363fb210cbe7153dd041f}


Query whether broadcast datagram transmissions are allowed. 

This method corresponds to using getsockopt() S\+O\+\_\+\+B\+R\+O\+A\+D\+C\+A\+ST of real network or B\+SD sockets.

\begin{DoxyReturn}{Returns}
true if broadcast is allowed, false otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_a95338a1ac89330a492d6af5b4e172d34}{ns3\+::\+Socket}.


\begin{DoxyCode}
483 \{
484   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
485 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Get\+Errno@{Get\+Errno}}
\index{Get\+Errno@{Get\+Errno}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Errno() const }{GetErrno() const }}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Socket\+::\+Socket\+Errno} ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Get\+Errno (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_a0e89d09b36d374f55ff7942a1d87a8ca}{}\label{classns3_1_1Ipv6RawSocketImpl_a0e89d09b36d374f55ff7942a1d87a8ca}


Get last error number. 

\begin{DoxyReturn}{Returns}
the errno associated to the last call which failed in this socket. Each socket\textquotesingle{}s errno is initialized to zero when the socket is created. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_ae489616249d946f3c0dc831c05d0d711}{ns3\+::\+Socket}.


\begin{DoxyCode}
94 \{
95   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
96   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv6RawSocketImpl_afabd1db84eac91197faac4f4852d8681}{m\_err};
97 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Get\+Node@{Get\+Node}}
\index{Get\+Node@{Get\+Node}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Node() const }{GetNode() const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Node} $>$ ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Get\+Node (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_a0e1459bc9485933deba1135dc70d7d6f}{}\label{classns3_1_1Ipv6RawSocketImpl_a0e1459bc9485933deba1135dc70d7d6f}


Return the node this socket is associated with. 

\begin{DoxyReturn}{Returns}
the node 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_aba642ad4301c1df47befc0aa9afa2e48}{ns3\+::\+Socket}.


\begin{DoxyCode}
89 \{
90   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv6RawSocketImpl_a2afa14d1f4c1f729c989c00e3ad350fb}{m\_node};
91 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Get\+Peer\+Name@{Get\+Peer\+Name}}
\index{Get\+Peer\+Name@{Get\+Peer\+Name}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Peer\+Name(\+Address \&address) const }{GetPeerName(Address &address) const }}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Get\+Peer\+Name (
\begin{DoxyParamCaption}
\item[{{\bf Address} \&}]{address}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_ac04cccb682dbc921f8478b152fa115bd}{}\label{classns3_1_1Ipv6RawSocketImpl_ac04cccb682dbc921f8478b152fa115bd}


Get the peer address of a connected socket. 


\begin{DoxyParams}{Parameters}
{\em address} & the address this socket is connected to. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if success, -\/1 otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_a78a3c37a539d2e70869bb82cc60fbb09}{ns3\+::\+Socket}.


\begin{DoxyCode}
139 \{
140   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << address);
141 
142   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6RawSocketImpl_ac1bd7e150da6118befd78831b483c0ca}{m\_dst}.\hyperlink{classns3_1_1Ipv6Address_a6f15ff7a41a6ae2171cdeda2a53179b8}{IsAny} ())
143     \{
144       \hyperlink{classns3_1_1Ipv6RawSocketImpl_afabd1db84eac91197faac4f4852d8681}{m\_err} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaaeb1fd23c1f4965b496786597125bf0f6}{ERROR\_NOTCONN};
145       \textcolor{keywordflow}{return} -1;
146     \}
147 
148   address = Inet6SocketAddress (\hyperlink{classns3_1_1Ipv6RawSocketImpl_ac1bd7e150da6118befd78831b483c0ca}{m\_dst}, 0);
149 
150   \textcolor{keywordflow}{return} 0;
151 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 11


\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Get\+Rx\+Available@{Get\+Rx\+Available}}
\index{Get\+Rx\+Available@{Get\+Rx\+Available}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Rx\+Available() const }{GetRxAvailable() const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Get\+Rx\+Available (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_af96fcf5ece8867992a4ccdad54ffc90b}{}\label{classns3_1_1Ipv6RawSocketImpl_af96fcf5ece8867992a4ccdad54ffc90b}
Return number of bytes which can be returned from one or multiple calls to Recv. Must be possible to call this method from the Recv callback.

\begin{DoxyReturn}{Returns}
the number of bytes which can be returned from one or multiple Recv calls. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_ad35d8931e53ae0754ee864acb1cecd0e}{ns3\+::\+Socket}.


\begin{DoxyCode}
385 \{
386   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
387   uint32\_t rx = 0;
388 
389   \textcolor{keywordflow}{for} (std::list<Data>::const\_iterator it = \hyperlink{classns3_1_1Ipv6RawSocketImpl_ae01fe78981765eec9f036e4cd657c73a}{m\_data}.begin (); it != \hyperlink{classns3_1_1Ipv6RawSocketImpl_ae01fe78981765eec9f036e4cd657c73a}{m\_data}.end (); ++it)
390     \{
391       rx+= (it->packet)->GetSize ();
392     \}
393 
394   \textcolor{keywordflow}{return} rx;
395 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Get\+Socket\+Type@{Get\+Socket\+Type}}
\index{Get\+Socket\+Type@{Get\+Socket\+Type}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Socket\+Type() const }{GetSocketType() const }}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Socket\+::\+Socket\+Type} ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Get\+Socket\+Type (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_ac44d22012dfc6959efd11f1688ac15bd}{}\label{classns3_1_1Ipv6RawSocketImpl_ac44d22012dfc6959efd11f1688ac15bd}


Get socket type (N\+S3\+\_\+\+S\+O\+C\+K\+\_\+\+R\+AW) 

\begin{DoxyReturn}{Returns}
socket type 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_af9333cfc006d6ed9363f20d3822fedcb}{ns3\+::\+Socket}.


\begin{DoxyCode}
100 \{
101   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Socket_a698fbcc486a48b7a0d2b0e4ab863d571aa97c397d36e85f30278a64ef94d40e03}{NS3\_SOCK\_RAW};
102 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Get\+Sock\+Name@{Get\+Sock\+Name}}
\index{Get\+Sock\+Name@{Get\+Sock\+Name}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Sock\+Name(\+Address \&address) const }{GetSockName(Address &address) const }}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Get\+Sock\+Name (
\begin{DoxyParamCaption}
\item[{{\bf Address} \&}]{address}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_abeb2cea9c843ffd9dbe2697986384758}{}\label{classns3_1_1Ipv6RawSocketImpl_abeb2cea9c843ffd9dbe2697986384758}


Get socket address. 


\begin{DoxyParams}{Parameters}
{\em address} & the address name this socket is associated with. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if success, -\/1 otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_aa982ca9baab28bea412b0d9710e63b43}{ns3\+::\+Socket}.


\begin{DoxyCode}
131 \{
132   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
133   address = Inet6SocketAddress (\hyperlink{classns3_1_1Ipv6RawSocketImpl_a33e8cd6e8ef2da88c6a8e954f23048d0}{m\_src}, 0);
134   \textcolor{keywordflow}{return} 0;
135 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Get\+Tx\+Available@{Get\+Tx\+Available}}
\index{Get\+Tx\+Available@{Get\+Tx\+Available}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Tx\+Available() const }{GetTxAvailable() const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Get\+Tx\+Available (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_a1edb9813fe9214132899b93da6e3684d}{}\label{classns3_1_1Ipv6RawSocketImpl_a1edb9813fe9214132899b93da6e3684d}


Returns the number of bytes which can be sent in a single call to Send. 

For datagram sockets, this returns the number of bytes that can be passed atomically through the underlying protocol.

For stream sockets, this returns the available space in bytes left in the transmit buffer.

\begin{DoxyReturn}{Returns}
The number of bytes which can be sent in a single Send call. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_ae7cf62e3acf44106bfa1d40eaeaec151}{ns3\+::\+Socket}.


\begin{DoxyCode}
379 \{
380   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
381   \textcolor{keywordflow}{return} 0xffffffff;
382 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 12


\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id()}{GetTypeId()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_a5f950ca300c163fd1b3276668f77be47}{}\label{classns3_1_1Ipv6RawSocketImpl_a5f950ca300c163fd1b3276668f77be47}


Get the type ID of this class. 

\begin{DoxyReturn}{Returns}
type ID 
\end{DoxyReturn}

\begin{DoxyCode}
46 \{
47   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::Ipv6RawSocketImpl"})
48     .SetParent<\hyperlink{classns3_1_1Socket_a1e22267afc490a4b15b8a764289a4000}{Socket}> ()
49     .SetGroupName (\textcolor{stringliteral}{"Internet"})
50     .AddAttribute (\textcolor{stringliteral}{"Protocol"}, \textcolor{stringliteral}{"Protocol number to match."}, 
51                    UintegerValue (0),
52                    MakeUintegerAccessor (&\hyperlink{classns3_1_1Ipv6RawSocketImpl_ac745a953c5ec673bd89b170eaadab548}{Ipv6RawSocketImpl::m\_protocol}),
53                    MakeUintegerChecker<uint16\_t> ())
54   ;
55   \textcolor{keywordflow}{return} tid;
56 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13


\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Icmpv6\+Filter\+Set\+Block@{Icmpv6\+Filter\+Set\+Block}}
\index{Icmpv6\+Filter\+Set\+Block@{Icmpv6\+Filter\+Set\+Block}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Icmpv6\+Filter\+Set\+Block(uint8\+\_\+t type)}{Icmpv6FilterSetBlock(uint8_t type)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Icmpv6\+Filter\+Set\+Block (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{type}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6RawSocketImpl_a2f850eddcc724122f7a287fee390fa4d}{}\label{classns3_1_1Ipv6RawSocketImpl_a2f850eddcc724122f7a287fee390fa4d}


Set the filter to block one I\+C\+M\+Pv6 type. 


\begin{DoxyParams}{Parameters}
{\em type} & the I\+C\+M\+Pv6 type to block \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
507 \{
508   (\hyperlink{classns3_1_1Ipv6RawSocketImpl_a38df054d5b81d3d1d29543fff42f44bb}{m\_icmpFilter}.\hyperlink{structns3_1_1Ipv6RawSocketImpl_1_1Icmpv6Filter_a301eafaaac249d6da9cb3ed5d64062d8}{icmpv6Filt}[(\hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type}) >> 5]) &= ~(uint32\_t(1) << ((
      \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type}) & 31));
509 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Icmpv6\+Filter\+Set\+Block\+All@{Icmpv6\+Filter\+Set\+Block\+All}}
\index{Icmpv6\+Filter\+Set\+Block\+All@{Icmpv6\+Filter\+Set\+Block\+All}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Icmpv6\+Filter\+Set\+Block\+All()}{Icmpv6FilterSetBlockAll()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Icmpv6\+Filter\+Set\+Block\+All (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6RawSocketImpl_a12e988b66bdb489166a963251e744a0a}{}\label{classns3_1_1Ipv6RawSocketImpl_a12e988b66bdb489166a963251e744a0a}


Set the filter to block all the I\+C\+M\+Pv6 types. 


\begin{DoxyCode}
495 \{
496   memset(&\hyperlink{classns3_1_1Ipv6RawSocketImpl_a38df054d5b81d3d1d29543fff42f44bb}{m\_icmpFilter}, 0x00, \textcolor{keyword}{sizeof}(Icmpv6Filter));
497 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Icmpv6\+Filter\+Set\+Pass@{Icmpv6\+Filter\+Set\+Pass}}
\index{Icmpv6\+Filter\+Set\+Pass@{Icmpv6\+Filter\+Set\+Pass}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Icmpv6\+Filter\+Set\+Pass(uint8\+\_\+t type)}{Icmpv6FilterSetPass(uint8_t type)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Icmpv6\+Filter\+Set\+Pass (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{type}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6RawSocketImpl_aea0f1182fba44167195eaf8990a5e7b6}{}\label{classns3_1_1Ipv6RawSocketImpl_aea0f1182fba44167195eaf8990a5e7b6}


Set the filter to pass one I\+C\+M\+Pv6 type. 


\begin{DoxyParams}{Parameters}
{\em type} & the I\+C\+M\+Pv6 type to pass \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
501 \{
502   (\hyperlink{classns3_1_1Ipv6RawSocketImpl_a38df054d5b81d3d1d29543fff42f44bb}{m\_icmpFilter}.\hyperlink{structns3_1_1Ipv6RawSocketImpl_1_1Icmpv6Filter_a301eafaaac249d6da9cb3ed5d64062d8}{icmpv6Filt}[(\hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type}) >> 5]) |= (uint32\_t(1) << ((
      \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type}) & 31));
503 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Icmpv6\+Filter\+Set\+Pass\+All@{Icmpv6\+Filter\+Set\+Pass\+All}}
\index{Icmpv6\+Filter\+Set\+Pass\+All@{Icmpv6\+Filter\+Set\+Pass\+All}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Icmpv6\+Filter\+Set\+Pass\+All()}{Icmpv6FilterSetPassAll()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Icmpv6\+Filter\+Set\+Pass\+All (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6RawSocketImpl_afbbc42522b8999a4dc097255db47920d}{}\label{classns3_1_1Ipv6RawSocketImpl_afbbc42522b8999a4dc097255db47920d}


Clean the I\+C\+M\+Pv6 filter structure. 


\begin{DoxyCode}
489 \{
490   memset(&\hyperlink{classns3_1_1Ipv6RawSocketImpl_a38df054d5b81d3d1d29543fff42f44bb}{m\_icmpFilter}, 0xff, \textcolor{keyword}{sizeof}(Icmpv6Filter));
491 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 14


\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Icmpv6\+Filter\+Will\+Block@{Icmpv6\+Filter\+Will\+Block}}
\index{Icmpv6\+Filter\+Will\+Block@{Icmpv6\+Filter\+Will\+Block}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Icmpv6\+Filter\+Will\+Block(uint8\+\_\+t type)}{Icmpv6FilterWillBlock(uint8_t type)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Icmpv6\+Filter\+Will\+Block (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{type}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6RawSocketImpl_a033c506bc14bddc3f9ef47bc71efa328}{}\label{classns3_1_1Ipv6RawSocketImpl_a033c506bc14bddc3f9ef47bc71efa328}


Ask the filter about the status of one I\+C\+M\+Pv6 type. 


\begin{DoxyParams}{Parameters}
{\em type} & the I\+C\+M\+Pv6 type \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the I\+C\+MP type is being blocked 
\end{DoxyReturn}

\begin{DoxyCode}
519 \{
520   \textcolor{keywordflow}{return} (((\hyperlink{classns3_1_1Ipv6RawSocketImpl_a38df054d5b81d3d1d29543fff42f44bb}{m\_icmpFilter}.\hyperlink{structns3_1_1Ipv6RawSocketImpl_1_1Icmpv6Filter_a301eafaaac249d6da9cb3ed5d64062d8}{icmpv6Filt}[(\hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type}) >> 5]) & (uint32\_t(1) << ((
      \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type}) & 31))) == 0);
521 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 15


\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Icmpv6\+Filter\+Will\+Pass@{Icmpv6\+Filter\+Will\+Pass}}
\index{Icmpv6\+Filter\+Will\+Pass@{Icmpv6\+Filter\+Will\+Pass}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Icmpv6\+Filter\+Will\+Pass(uint8\+\_\+t type)}{Icmpv6FilterWillPass(uint8_t type)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Icmpv6\+Filter\+Will\+Pass (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{type}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6RawSocketImpl_aa980b224df04ec9341eb6407cd9947df}{}\label{classns3_1_1Ipv6RawSocketImpl_aa980b224df04ec9341eb6407cd9947df}


Ask the filter about the status of one I\+C\+M\+Pv6 type. 


\begin{DoxyParams}{Parameters}
{\em type} & the I\+C\+M\+Pv6 type \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the I\+C\+MP type is passing through 
\end{DoxyReturn}

\begin{DoxyCode}
513 \{
514   \textcolor{keywordflow}{return} (((\hyperlink{classns3_1_1Ipv6RawSocketImpl_a38df054d5b81d3d1d29543fff42f44bb}{m\_icmpFilter}.\hyperlink{structns3_1_1Ipv6RawSocketImpl_1_1Icmpv6Filter_a301eafaaac249d6da9cb3ed5d64062d8}{icmpv6Filt}[(\hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type}) >> 5]) & (uint32\_t(1) << ((
      \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type}) & 31))) != 0);
515 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Ipv6\+Join\+Group@{Ipv6\+Join\+Group}}
\index{Ipv6\+Join\+Group@{Ipv6\+Join\+Group}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Ipv6\+Join\+Group(\+Ipv6\+Address address, Socket\+::\+Ipv6\+Multicast\+Filter\+Mode filter\+Mode, std\+::vector$<$ Ipv6\+Address $>$ source\+Addresses)}{Ipv6JoinGroup(Ipv6Address address, Socket::Ipv6MulticastFilterMode filterMode, std::vector< Ipv6Address > sourceAddresses)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Ipv6\+Join\+Group (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{address, }
\item[{{\bf Socket\+::\+Ipv6\+Multicast\+Filter\+Mode}}]{filter\+Mode, }
\item[{std\+::vector$<$ {\bf Ipv6\+Address} $>$}]{source\+Addresses}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_a8cb33ebfedf6ce3baaff6048fd41576c}{}\label{classns3_1_1Ipv6RawSocketImpl_a8cb33ebfedf6ce3baaff6048fd41576c}


Joins a I\+Pv6 multicast group. 

Based on the filter mode and source addresses this can be interpreted as a join, leave, or modification to source filtering on a multicast group.

Mind that a socket can join only one multicast group. Any attempt to join another group will remove the old one.


\begin{DoxyParams}{Parameters}
{\em address} & Requested multicast address. \\
\hline
{\em filter\+Mode} & \hyperlink{classns3_1_1Socket}{Socket} filtering mode (I\+N\+C\+L\+U\+DE $\vert$ E\+X\+C\+L\+U\+DE). \\
\hline
{\em source\+Addresses} & All the source addresses on which socket is interested or not interested. \\
\hline
\end{DoxyParams}


Reimplemented from \hyperlink{classns3_1_1Socket_aa9c414660bee2cd56bf6cdc4111b4744}{ns3\+::\+Socket}.


\begin{DoxyCode}
336 \{
337   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << address << &filterMode << &sourceAddresses);
338 
339   \textcolor{comment}{// We can join only one multicast group (or change its params)}
340   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} ((\hyperlink{classns3_1_1Socket_a5745d9cdf891f3f0c06b124c4b679ef9}{m\_ipv6MulticastGroupAddress} == address || 
      \hyperlink{classns3_1_1Socket_a5745d9cdf891f3f0c06b124c4b679ef9}{m\_ipv6MulticastGroupAddress}.\hyperlink{classns3_1_1Ipv6Address_a6f15ff7a41a6ae2171cdeda2a53179b8}{IsAny} ()), \textcolor{stringliteral}{"Can join only one IPv6 multicast
       group."});
341 
342   \hyperlink{classns3_1_1Socket_a5745d9cdf891f3f0c06b124c4b679ef9}{m\_ipv6MulticastGroupAddress} = address;
343 
344   Ptr<Ipv6L3Protocol> ipv6l3 = \hyperlink{classns3_1_1Ipv6RawSocketImpl_a2afa14d1f4c1f729c989c00e3ad350fb}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject} <Ipv6L3Protocol> ();
345   \textcolor{keywordflow}{if} (ipv6l3)
346     \{
347       \textcolor{keywordflow}{if} (filterMode == \hyperlink{classns3_1_1Socket_a96f39fe2b73d5691b319093a1e31615da3518a166d4dda6c74bf8aaaade9edf7a}{INCLUDE} && sourceAddresses.empty ())
348         \{
349           \textcolor{comment}{// it is a leave}
350           \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Socket_a9781d8dfdb5e9364d5dce8f53b768bb5}{m\_boundnetdevice})
351             \{
352               int32\_t index = ipv6l3->GetInterfaceForDevice (\hyperlink{classns3_1_1Socket_a9781d8dfdb5e9364d5dce8f53b768bb5}{m\_boundnetdevice});
353               \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (index >= 0, \textcolor{stringliteral}{"Interface without a valid index"});
354               ipv6l3->RemoveMulticastAddress (address, index);
355             \}
356           \textcolor{keywordflow}{else}
357             \{
358               ipv6l3->RemoveMulticastAddress (address);
359             \}
360         \}
361       \textcolor{keywordflow}{else}
362         \{
363           \textcolor{comment}{// it is a join or a modification}
364           \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Socket_a9781d8dfdb5e9364d5dce8f53b768bb5}{m\_boundnetdevice})
365             \{
366               int32\_t index = ipv6l3->GetInterfaceForDevice (\hyperlink{classns3_1_1Socket_a9781d8dfdb5e9364d5dce8f53b768bb5}{m\_boundnetdevice});
367               \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (index >= 0, \textcolor{stringliteral}{"Interface without a valid index"});
368               ipv6l3->AddMulticastAddress (address, index);
369             \}
370           \textcolor{keywordflow}{else}
371             \{
372               ipv6l3->AddMulticastAddress (address);
373             \}
374         \}
375     \}
376 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 16


\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Listen@{Listen}}
\index{Listen@{Listen}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Listen()}{Listen()}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Listen (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_a1b0f410496348c5869a1c86437172b2a}{}\label{classns3_1_1Ipv6RawSocketImpl_a1b0f410496348c5869a1c86437172b2a}


Listen for incoming connections. 

\begin{DoxyReturn}{Returns}
0 on success, -\/1 on error (in which case errno is set). 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_a6b3529a32632cf1a56debf5f79e56c54}{ns3\+::\+Socket}.


\begin{DoxyCode}
196 \{
197   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
198   \hyperlink{classns3_1_1Ipv6RawSocketImpl_afabd1db84eac91197faac4f4852d8681}{m\_err} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa777b6c9712ef5485ebecfb96d5de4d54}{Socket::ERROR\_OPNOTSUPP};
199   \textcolor{keywordflow}{return} -1;
200 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Recv@{Recv}}
\index{Recv@{Recv}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Recv(uint32\+\_\+t max\+Size, uint32\+\_\+t flags)}{Recv(uint32_t maxSize, uint32_t flags)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Packet} $>$ ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Recv (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{max\+Size, }
\item[{uint32\+\_\+t}]{flags}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_a2e86d6b6c347fe37a577ba0d9fcb411d}{}\label{classns3_1_1Ipv6RawSocketImpl_a2e86d6b6c347fe37a577ba0d9fcb411d}


Read data from the socket. 

This function matches closely in semantics to the recv() function call in the standard C library (libc)\+: ssize\+\_\+t recv (int s, void $\ast$buf, size\+\_\+t len, int flags); except that the receive I/O is asynchronous. This is the primary Recv method at this low-\/level A\+PI and must be implemented by subclasses.

This method is normally used only on a connected socket. In a typical blocking sockets model, this call would block until at least one byte is returned or the connection closes. In ns-\/3 at this A\+PI, the call returns immediately in such a case and returns 0 if nothing is available to be read. However, an application can set a callback, ns3\+::\+Set\+Recv\+Callback, to be notified of data being available to be read (when it conceptually unblocks); this is an asynchronous I/O model for recv().

This variant of \hyperlink{classns3_1_1Socket_afb4e211a54a3f63ac3f79624a3a964f7}{Recv()} uses class \hyperlink{classns3_1_1Packet}{ns3\+::\+Packet} to encapsulate data, rather than providing a raw pointer and length field. This allows an ns-\/3 application to attach tags if desired (such as a flow ID) and may allow the simulator to avoid some data copies. Despite the appearance of receiving Packets on a stream socket, just think of it as a fancy byte buffer with streaming semantics.

The semantics depend on the type of socket. For a datagram socket, each \hyperlink{classns3_1_1Socket_afb4e211a54a3f63ac3f79624a3a964f7}{Recv()} returns the data from at most one \hyperlink{classns3_1_1Ipv6RawSocketImpl_a889224d7c084b74b3a1a3511899a04f3}{Send()}, and order is not necessarily preserved. For a stream socket, the bytes are delivered in order, and on-\/the-\/wire packet boundaries are not preserved.

The flags argument is formed by or\textquotesingle{}ing one or more of the values\+: M\+S\+G\+\_\+\+O\+OB process out-\/of-\/band data M\+S\+G\+\_\+\+P\+E\+EK peek at incoming message None of these flags are supported for now.

Some variants of \hyperlink{classns3_1_1Socket_afb4e211a54a3f63ac3f79624a3a964f7}{Recv()} are supported as additional A\+PI, including \hyperlink{classns3_1_1Ipv6RawSocketImpl_a582900364192f1181e1c904b1a5af6a8}{Recv\+From()}, overloaded \hyperlink{classns3_1_1Socket_afb4e211a54a3f63ac3f79624a3a964f7}{Recv()} without arguments, and variants that use raw character buffers.


\begin{DoxyParams}{Parameters}
{\em max\+Size} & reader will accept packet up to max\+Size \\
\hline
{\em flags} & \hyperlink{classns3_1_1Socket}{Socket} control flags \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{classns3_1_1Ptr}{Ptr$<$\+Packet$>$} of the next in-\/sequence packet. Returns 0 if the socket cannot return a next in-\/sequence packet conforming to the max\+Size and flags.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Socket_a243f7835ef1a85f9270fd3577e3a40da}{Set\+Recv\+Callback} 
\end{DoxySeeAlso}


Implements \hyperlink{classns3_1_1Socket_a8949b1f844aae563446f2f4c5be8827a}{ns3\+::\+Socket}.


\begin{DoxyCode}
301 \{
302   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << maxSize << flags);
303   Address tmp;
304   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv6RawSocketImpl_a582900364192f1181e1c904b1a5af6a8}{RecvFrom} (maxSize, flags, tmp);
305 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 17


\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Recv\+From@{Recv\+From}}
\index{Recv\+From@{Recv\+From}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Recv\+From(uint32\+\_\+t max\+Size, uint32\+\_\+t flags, Address \&from\+Address)}{RecvFrom(uint32_t maxSize, uint32_t flags, Address &fromAddress)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Packet} $>$ ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Recv\+From (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{max\+Size, }
\item[{uint32\+\_\+t}]{flags, }
\item[{{\bf Address} \&}]{from\+Address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_a582900364192f1181e1c904b1a5af6a8}{}\label{classns3_1_1Ipv6RawSocketImpl_a582900364192f1181e1c904b1a5af6a8}


Read a single packet from the socket and retrieve the sender address. 

Calls Recv(max\+Size, flags) with max\+Size implicitly set to maximum sized integer, and flags set to zero.

This method has similar semantics to Recv () but subclasses may want to provide checks on socket state, so the implementation is pushed to subclasses.


\begin{DoxyParams}{Parameters}
{\em max\+Size} & reader will accept packet up to max\+Size \\
\hline
{\em flags} & \hyperlink{classns3_1_1Socket}{Socket} control flags \\
\hline
{\em from\+Address} & output parameter that will return the address of the sender of the received packet, if any. Remains untouched if no packet is received. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{classns3_1_1Ptr}{Ptr$<$\+Packet$>$} of the next in-\/sequence packet. Returns 0 if the socket cannot return a next in-\/sequence packet. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_af22378d7af9a2745a9eada20210da215}{ns3\+::\+Socket}.


\begin{DoxyCode}
308 \{
309   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << maxSize << flags << fromAddress);
310 
311   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6RawSocketImpl_ae01fe78981765eec9f036e4cd657c73a}{m\_data}.empty ())
312     \{
313       \textcolor{keywordflow}{return} 0;
314     \}
315 
316   \textcolor{comment}{/* get packet */}
317   Data \hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data} = \hyperlink{classns3_1_1Ipv6RawSocketImpl_ae01fe78981765eec9f036e4cd657c73a}{m\_data}.front ();
318   \hyperlink{classns3_1_1Ipv6RawSocketImpl_ae01fe78981765eec9f036e4cd657c73a}{m\_data}.pop\_front ();
319   fromAddress = Inet6SocketAddress (data.fromIp, data.fromProtocol);
320   \textcolor{keywordflow}{if} (data.packet->GetSize () > maxSize)
321     \{
322       Ptr<Packet> first = data.packet->CreateFragment (0, maxSize);
323       \textcolor{keywordflow}{if} (!(flags & MSG\_PEEK))
324         \{
325           data.packet->RemoveAtStart (maxSize);
326         \}
327       \hyperlink{classns3_1_1Ipv6RawSocketImpl_ae01fe78981765eec9f036e4cd657c73a}{m\_data}.push\_front (data);
328       \textcolor{keywordflow}{return} first;
329     \}
330 
331   \textcolor{keywordflow}{return} data.packet;
332 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 18




Here is the caller graph for this function\+:
% FIG 19


\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Send@{Send}}
\index{Send@{Send}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Send(\+Ptr$<$ Packet $>$ p, uint32\+\_\+t flags)}{Send(Ptr< Packet > p, uint32_t flags)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Send (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{uint32\+\_\+t}]{flags}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_a889224d7c084b74b3a1a3511899a04f3}{}\label{classns3_1_1Ipv6RawSocketImpl_a889224d7c084b74b3a1a3511899a04f3}


Send data (or dummy data) to the remote host. 

This function matches closely in semantics to the send() function call in the standard C library (libc)\+: ssize\+\_\+t send (int s, const void $\ast$msg, size\+\_\+t len, int flags); except that the send I/O is asynchronous. This is the primary Send method at this low-\/level A\+PI and must be implemented by subclasses.

In a typical blocking sockets model, this call would block upon lack of space to hold the message to be sent. In ns-\/3 at this A\+PI, the call returns immediately in such a case, but the callback registered with \hyperlink{classns3_1_1Socket_a85ff5c8cc7d242823f301b49264c68a4}{Set\+Send\+Callback()} is invoked when the socket has space (when it conceptually unblocks); this is an asynchronous I/O model for send().

This variant of \hyperlink{classns3_1_1Ipv6RawSocketImpl_a889224d7c084b74b3a1a3511899a04f3}{Send()} uses class \hyperlink{classns3_1_1Packet}{ns3\+::\+Packet} to encapsulate data, rather than providing a raw pointer and length field. This allows an ns-\/3 application to attach tags if desired (such as a flow ID) and may allow the simulator to avoid some data copies. Despite the appearance of sending Packets on a stream socket, just think of it as a fancy byte buffer with streaming semantics.

If either the message buffer within the \hyperlink{classns3_1_1Packet}{Packet} is too long to pass atomically through the underlying protocol (for datagram sockets), or the message buffer cannot entirely fit in the transmit buffer (for stream sockets), -\/1 is returned and Socket\+Errno is set to E\+R\+R\+O\+R\+\_\+\+M\+S\+G\+S\+I\+ZE. If the packet does not fit, the caller can split the \hyperlink{classns3_1_1Packet}{Packet} (based on information obtained from Get\+Tx\+Available) and reattempt to send the data.

The flags argument is formed by or\textquotesingle{}ing one or more of the values\+: M\+S\+G\+\_\+\+O\+OB process out-\/of-\/band data M\+S\+G\+\_\+\+D\+O\+N\+T\+R\+O\+U\+TE bypass routing, use direct interface These flags are {\itshape unsupported} as of ns-\/3.\+1.


\begin{DoxyParams}{Parameters}
{\em p} & \hyperlink{classns3_1_1Packet}{ns3\+::\+Packet} to send \\
\hline
{\em flags} & \hyperlink{classns3_1_1Socket}{Socket} control flags \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of bytes accepted for transmission if no error occurs, and -\/1 otherwise.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Socket_a85ff5c8cc7d242823f301b49264c68a4}{Set\+Send\+Callback} 
\end{DoxySeeAlso}


Implements \hyperlink{classns3_1_1Socket_a036901c8f485fe5b6eab93b7f2ec289d}{ns3\+::\+Socket}.


\begin{DoxyCode}
203 \{
204   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << p << flags);
205   Inet6SocketAddress to = Inet6SocketAddress (\hyperlink{classns3_1_1Ipv6RawSocketImpl_ac1bd7e150da6118befd78831b483c0ca}{m\_dst}, \hyperlink{classns3_1_1Ipv6RawSocketImpl_ac745a953c5ec673bd89b170eaadab548}{m\_protocol});
206   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv6RawSocketImpl_aadff84e3c8a3ce3bc4f10a3d7a4dbac8}{SendTo} (p, flags, to);
207 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 20


\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Send\+To@{Send\+To}}
\index{Send\+To@{Send\+To}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Send\+To(\+Ptr$<$ Packet $>$ p, uint32\+\_\+t flags, const Address \&to\+Address)}{SendTo(Ptr< Packet > p, uint32_t flags, const Address &toAddress)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Send\+To (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{uint32\+\_\+t}]{flags, }
\item[{const {\bf Address} \&}]{to\+Address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_aadff84e3c8a3ce3bc4f10a3d7a4dbac8}{}\label{classns3_1_1Ipv6RawSocketImpl_aadff84e3c8a3ce3bc4f10a3d7a4dbac8}


Send data to a specified peer. 

This method has similar semantics to Send () but subclasses may want to provide checks on socket state, so the implementation is pushed to subclasses.


\begin{DoxyParams}{Parameters}
{\em p} & packet to send \\
\hline
{\em flags} & \hyperlink{classns3_1_1Socket}{Socket} control flags \\
\hline
{\em to\+Address} & IP \hyperlink{classns3_1_1Address}{Address} of remote host \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
-\/1 in case of error or the number of bytes copied in the internal buffer and accepted for transmission. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_af898fce6a58e0dbba23c1c6de1d4220e}{ns3\+::\+Socket}.


\begin{DoxyCode}
210 \{
211   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << p << flags << toAddress);
212 
213   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1Inet6SocketAddress_a4d928c54affbfb530a12076d6d7e0540}{Inet6SocketAddress::IsMatchingType} (toAddress))
214     \{
215       \hyperlink{classns3_1_1Ipv6RawSocketImpl_afabd1db84eac91197faac4f4852d8681}{m\_err} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa4b98dd50740861229f8e03bcc36d379b}{Socket::ERROR\_INVAL};
216       \textcolor{keywordflow}{return} -1;
217     \}
218 
219   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6RawSocketImpl_a974dfa7bfc98a6c070d74b42dbc1cb30}{m\_shutdownSend})
220     \{
221       \textcolor{keywordflow}{return} 0;
222     \}
223 
224   Inet6SocketAddress ad = \hyperlink{classns3_1_1Inet6SocketAddress_a2177c66e1bcf17c85dcffb9d2a971f5a}{Inet6SocketAddress::ConvertFrom} (toAddress);
225   Ptr<Ipv6L3Protocol> ipv6 = \hyperlink{classns3_1_1Ipv6RawSocketImpl_a2afa14d1f4c1f729c989c00e3ad350fb}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv6L3Protocol> ();
226   Ipv6Address dst = ad.GetIpv6 ();
227 
228   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Socket_a83858f6116bcdabecf1b63b37514ec8d}{IsManualIpv6Tclass} ())
229     \{
230       SocketIpv6TclassTag ipTclassTag;
231       ipTclassTag.SetTclass (\hyperlink{classns3_1_1Socket_aed62162f0b5f322b1fa23b7350c3c2ce}{GetIpv6Tclass} ());
232       p->\hyperlink{classns3_1_1Packet_a7400b8655852f5271c5957250d0141af}{AddPacketTag} (ipTclassTag);
233     \}
234 
235   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Socket_af537e44bad2f67bffe7ef6c1c86c2459}{IsManualIpv6HopLimit} () && \hyperlink{classns3_1_1Socket_ad78033887757bda28f40f4ab1f0620d0}{GetIpv6HopLimit} () != 0 && !dst.
      IsMulticast ())
236     \{
237       SocketIpv6HopLimitTag tag;
238       tag.SetHopLimit (\hyperlink{classns3_1_1Socket_ad78033887757bda28f40f4ab1f0620d0}{GetIpv6HopLimit} ());
239       p->\hyperlink{classns3_1_1Packet_a7400b8655852f5271c5957250d0141af}{AddPacketTag} (tag);
240     \}
241 
242   \textcolor{keywordflow}{if} (ipv6->GetRoutingProtocol ())
243     \{
244       Ipv6Header hdr;
245       hdr.SetDestinationAddress (dst);
246       \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{SocketErrno} err = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaaa7eb006d73c5ad0117c5591fcb3469f7}{ERROR\_NOTERROR};
247       Ptr<Ipv6Route> route = 0;
248       Ptr<NetDevice> oif = \hyperlink{classns3_1_1Socket_a9781d8dfdb5e9364d5dce8f53b768bb5}{m\_boundnetdevice}; \textcolor{comment}{//specify non-zero if bound to a specific
       device}
249 
250       \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1Ipv6RawSocketImpl_a33e8cd6e8ef2da88c6a8e954f23048d0}{m\_src}.\hyperlink{classns3_1_1Ipv6Address_a6f15ff7a41a6ae2171cdeda2a53179b8}{IsAny} ())
251         \{
252           int32\_t index = ipv6->GetInterfaceForAddress (\hyperlink{classns3_1_1Ipv6RawSocketImpl_a33e8cd6e8ef2da88c6a8e954f23048d0}{m\_src});
253           \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (index >= 0);
254           oif = ipv6->GetNetDevice (index);
255         \}
256 
257       route = ipv6->GetRoutingProtocol ()->RouteOutput (p, hdr, oif, err);
258 
259       \textcolor{keywordflow}{if} (route)
260         \{
261           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Route exists"});
262           \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6RawSocketImpl_ac745a953c5ec673bd89b170eaadab548}{m\_protocol} == \hyperlink{classns3_1_1Icmpv6L4Protocol_af845269e6c3f4509a4e287195c965afc}{Icmpv6L4Protocol::GetStaticProtocolNumber}
       ())
263             \{
264               \textcolor{comment}{/* calculate checksum here for ICMPv6 echo request (sent by ping6) }
265 \textcolor{comment}{               * as we cannot determine source IPv6 address at application level }
266 \textcolor{comment}{               */}
267               uint8\_t \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type};
268               p->\hyperlink{classns3_1_1Packet_a5a6d304b9e0d90733919ffe224b98f0d}{CopyData} (&type, \textcolor{keyword}{sizeof}(type));
269               \textcolor{keywordflow}{if} (type == \hyperlink{classns3_1_1Icmpv6Header_ad13fcbee075bf00f66ffbc57dfbecb70aee9d19b2f71a1cb9b076d170cfcd4231}{Icmpv6Header::ICMPV6\_ECHO\_REQUEST})
270                 \{
271                   Icmpv6Echo hdr (1);
272                   p->\hyperlink{classns3_1_1Packet_a0961eccf975d75f902d40956c93ba63e}{RemoveHeader} (hdr);
273                   hdr.CalculatePseudoHeaderChecksum (route->GetSource (), dst, p->
      \hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} () + hdr.GetSerializedSize (), 
      \hyperlink{classns3_1_1Icmpv6L4Protocol_af845269e6c3f4509a4e287195c965afc}{Icmpv6L4Protocol::GetStaticProtocolNumber} ());
274                   p->\hyperlink{classns3_1_1Packet_a465108c595a0bc592095cbcab1832ed8}{AddHeader} (hdr);
275                 \}
276             \}
277 
278           uint32\_t pktSize = p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ();
279           \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6RawSocketImpl_a33e8cd6e8ef2da88c6a8e954f23048d0}{m\_src}.\hyperlink{classns3_1_1Ipv6Address_a6f15ff7a41a6ae2171cdeda2a53179b8}{IsAny} ())
280             \{
281               ipv6->Send (p, route->GetSource (), dst, \hyperlink{classns3_1_1Ipv6RawSocketImpl_ac745a953c5ec673bd89b170eaadab548}{m\_protocol}, route);
282             \}
283           \textcolor{keywordflow}{else}
284             \{
285               ipv6->Send (p, \hyperlink{classns3_1_1Ipv6RawSocketImpl_a33e8cd6e8ef2da88c6a8e954f23048d0}{m\_src}, dst, \hyperlink{classns3_1_1Ipv6RawSocketImpl_ac745a953c5ec673bd89b170eaadab548}{m\_protocol}, route);
286             \}
287           \textcolor{comment}{// Return only payload size (as Linux does).}
288           \hyperlink{classns3_1_1Socket_ae478fc503f7041a1da5e9db361f1ae20}{NotifyDataSent} (pktSize);
289           \hyperlink{classns3_1_1Socket_a34cd5de5b9feeadd6ba8973b954c3d5f}{NotifySend} (\hyperlink{classns3_1_1Ipv6RawSocketImpl_a1edb9813fe9214132899b93da6e3684d}{GetTxAvailable} ());
290           \textcolor{keywordflow}{return} pktSize;
291         \}
292       \textcolor{keywordflow}{else}
293         \{
294           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"No route, dropped!"});
295         \}
296     \}
297   \textcolor{keywordflow}{return} 0;
298 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 21




Here is the caller graph for this function\+:
% FIG 22


\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Set\+Allow\+Broadcast@{Set\+Allow\+Broadcast}}
\index{Set\+Allow\+Broadcast@{Set\+Allow\+Broadcast}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Set\+Allow\+Broadcast(bool allow\+Broadcast)}{SetAllowBroadcast(bool allowBroadcast)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Set\+Allow\+Broadcast (
\begin{DoxyParamCaption}
\item[{bool}]{allow\+Broadcast}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_a651705d6a9cbba054335a04c6c2eeb4c}{}\label{classns3_1_1Ipv6RawSocketImpl_a651705d6a9cbba054335a04c6c2eeb4c}


Configure whether broadcast datagram transmissions are allowed. 

This method corresponds to using setsockopt() S\+O\+\_\+\+B\+R\+O\+A\+D\+C\+A\+ST of real network or B\+SD sockets. If set on a socket, this option will enable or disable packets to be transmitted to broadcast destination addresses.


\begin{DoxyParams}{Parameters}
{\em allow\+Broadcast} & Whether broadcast is allowed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if operation succeeds 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_a32b4fa27b732a63207c8d9054a817ed5}{ns3\+::\+Socket}.


\begin{DoxyCode}
473 \{
474   \textcolor{keywordflow}{if} (!allowBroadcast)
475     \{
476       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
477     \}
478   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
479 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Set\+Node@{Set\+Node}}
\index{Set\+Node@{Set\+Node}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Set\+Node(\+Ptr$<$ Node $>$ node)}{SetNode(Ptr< Node > node)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Set\+Node (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6RawSocketImpl_a227c78fa2bf8af76f79bf8c8f8e84c71}{}\label{classns3_1_1Ipv6RawSocketImpl_a227c78fa2bf8af76f79bf8c8f8e84c71}


Set the node associated with this socket. 


\begin{DoxyParams}{Parameters}
{\em node} & node to set \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
83 \{
84   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << node);
85   \hyperlink{classns3_1_1Ipv6RawSocketImpl_a2afa14d1f4c1f729c989c00e3ad350fb}{m\_node} = node;
86 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Set\+Protocol@{Set\+Protocol}}
\index{Set\+Protocol@{Set\+Protocol}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Set\+Protocol(uint16\+\_\+t protocol)}{SetProtocol(uint16_t protocol)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Set\+Protocol (
\begin{DoxyParamCaption}
\item[{uint16\+\_\+t}]{protocol}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6RawSocketImpl_a063d026e3e6e82a05de4e49c06f41129}{}\label{classns3_1_1Ipv6RawSocketImpl_a063d026e3e6e82a05de4e49c06f41129}


Set protocol field. 


\begin{DoxyParams}{Parameters}
{\em protocol} & protocol to set \\
\hline
\end{DoxyParams}
\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Shutdown\+Recv@{Shutdown\+Recv}}
\index{Shutdown\+Recv@{Shutdown\+Recv}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Shutdown\+Recv()}{ShutdownRecv()}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Shutdown\+Recv (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_a7ce536d970b3546fe5bce17dbe9ab38d}{}\label{classns3_1_1Ipv6RawSocketImpl_a7ce536d970b3546fe5bce17dbe9ab38d}
\begin{DoxyReturn}{Returns}
zero on success, -\/1 on failure.
\end{DoxyReturn}
Do not allow any further Recv calls. This method is typically implemented for Tcp sockets by a half close. 

Implements \hyperlink{classns3_1_1Socket_a5a6b835bb7ccf2cf43b54912e7cae600}{ns3\+::\+Socket}.


\begin{DoxyCode}
174 \{
175   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
176   \hyperlink{classns3_1_1Ipv6RawSocketImpl_a6db5d278326c66329425f615ccdf63ec}{m\_shutdownRecv} = \textcolor{keyword}{true};
177   \textcolor{keywordflow}{return} 0;
178 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!Shutdown\+Send@{Shutdown\+Send}}
\index{Shutdown\+Send@{Shutdown\+Send}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Shutdown\+Send()}{ShutdownSend()}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::\+Shutdown\+Send (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_ae485f899ce976e799770adb46a5fdd91}{}\label{classns3_1_1Ipv6RawSocketImpl_ae485f899ce976e799770adb46a5fdd91}
\begin{DoxyReturn}{Returns}
zero on success, -\/1 on failure.
\end{DoxyReturn}
Do not allow any further Send calls. This method is typically implemented for Tcp sockets by a half close. 

Implements \hyperlink{classns3_1_1Socket_a8186c87627fa3ece326d8f1c822d7f95}{ns3\+::\+Socket}.


\begin{DoxyCode}
167 \{
168   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
169   \hyperlink{classns3_1_1Ipv6RawSocketImpl_a974dfa7bfc98a6c070d74b42dbc1cb30}{m\_shutdownSend} = \textcolor{keyword}{true};
170   \textcolor{keywordflow}{return} 0;
171 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!m\+\_\+data@{m\+\_\+data}}
\index{m\+\_\+data@{m\+\_\+data}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+data}{m_data}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std\+::list}$<${\bf Data}$>$ ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::m\+\_\+data\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_ae01fe78981765eec9f036e4cd657c73a}{}\label{classns3_1_1Ipv6RawSocketImpl_ae01fe78981765eec9f036e4cd657c73a}


\hyperlink{classns3_1_1Packet}{Packet} waiting to be processed. 

\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!m\+\_\+dst@{m\+\_\+dst}}
\index{m\+\_\+dst@{m\+\_\+dst}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+dst}{m_dst}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+Address} ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::m\+\_\+dst\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_ac1bd7e150da6118befd78831b483c0ca}{}\label{classns3_1_1Ipv6RawSocketImpl_ac1bd7e150da6118befd78831b483c0ca}


Destination address. 

\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!m\+\_\+err@{m\+\_\+err}}
\index{m\+\_\+err@{m\+\_\+err}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+err}{m_err}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Socket\+::\+Socket\+Errno} ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::m\+\_\+err\hspace{0.3cm}{\ttfamily [mutable]}, {\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_afabd1db84eac91197faac4f4852d8681}{}\label{classns3_1_1Ipv6RawSocketImpl_afabd1db84eac91197faac4f4852d8681}


Last error number. 

\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!m\+\_\+icmp\+Filter@{m\+\_\+icmp\+Filter}}
\index{m\+\_\+icmp\+Filter@{m\+\_\+icmp\+Filter}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+icmp\+Filter}{m_icmpFilter}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Icmpv6\+Filter} ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::m\+\_\+icmp\+Filter\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_a38df054d5b81d3d1d29543fff42f44bb}{}\label{classns3_1_1Ipv6RawSocketImpl_a38df054d5b81d3d1d29543fff42f44bb}


I\+C\+M\+Pv6 filter. 

\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!m\+\_\+node@{m\+\_\+node}}
\index{m\+\_\+node@{m\+\_\+node}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+node}{m_node}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Node}$>$ ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::m\+\_\+node\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_a2afa14d1f4c1f729c989c00e3ad350fb}{}\label{classns3_1_1Ipv6RawSocketImpl_a2afa14d1f4c1f729c989c00e3ad350fb}


\hyperlink{classns3_1_1Node}{Node}. 

\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!m\+\_\+protocol@{m\+\_\+protocol}}
\index{m\+\_\+protocol@{m\+\_\+protocol}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+protocol}{m_protocol}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::m\+\_\+protocol\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_ac745a953c5ec673bd89b170eaadab548}{}\label{classns3_1_1Ipv6RawSocketImpl_ac745a953c5ec673bd89b170eaadab548}


Protocol. 

\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!m\+\_\+shutdown\+Recv@{m\+\_\+shutdown\+Recv}}
\index{m\+\_\+shutdown\+Recv@{m\+\_\+shutdown\+Recv}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+shutdown\+Recv}{m_shutdownRecv}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::m\+\_\+shutdown\+Recv\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_a6db5d278326c66329425f615ccdf63ec}{}\label{classns3_1_1Ipv6RawSocketImpl_a6db5d278326c66329425f615ccdf63ec}


Flag to shutdown receive capability. 

\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!m\+\_\+shutdown\+Send@{m\+\_\+shutdown\+Send}}
\index{m\+\_\+shutdown\+Send@{m\+\_\+shutdown\+Send}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+shutdown\+Send}{m_shutdownSend}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::m\+\_\+shutdown\+Send\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_a974dfa7bfc98a6c070d74b42dbc1cb30}{}\label{classns3_1_1Ipv6RawSocketImpl_a974dfa7bfc98a6c070d74b42dbc1cb30}


Flag to shutdown send capability. 

\index{ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}!m\+\_\+src@{m\+\_\+src}}
\index{m\+\_\+src@{m\+\_\+src}!ns3\+::\+Ipv6\+Raw\+Socket\+Impl@{ns3\+::\+Ipv6\+Raw\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+src}{m_src}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+Address} ns3\+::\+Ipv6\+Raw\+Socket\+Impl\+::m\+\_\+src\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6RawSocketImpl_a33e8cd6e8ef2da88c6a8e954f23048d0}{}\label{classns3_1_1Ipv6RawSocketImpl_a33e8cd6e8ef2da88c6a8e954f23048d0}


Source address. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/model/\hyperlink{ipv6-raw-socket-impl_8h}{ipv6-\/raw-\/socket-\/impl.\+h}\item 
internet/model/\hyperlink{ipv6-raw-socket-impl_8cc}{ipv6-\/raw-\/socket-\/impl.\+cc}\end{DoxyCompactItemize}
