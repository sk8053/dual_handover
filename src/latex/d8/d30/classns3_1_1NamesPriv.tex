\hypertarget{classns3_1_1NamesPriv}{}\section{ns3\+:\+:Names\+Priv Class Reference}
\label{classns3_1_1NamesPriv}\index{ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}}


Inheritance diagram for ns3\+:\+:Names\+Priv\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Names\+Priv\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1NamesPriv_aa89187c3753da65a97180b31cf77c958}{Names\+Priv} ()
\item 
\hyperlink{classns3_1_1NamesPriv_a903613cb232c09abd3c9d66432124d10}{$\sim$\+Names\+Priv} ()
\item 
bool \hyperlink{classns3_1_1NamesPriv_a1d9bc7794dedbcb88c7f875c084761bb}{Add} (std\+::string \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name}, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Object}{Object} $>$ object)
\begin{DoxyCompactList}\small\item\em Add the association between the string \char`\"{}name\char`\"{} and the Ptr$<$\+Object$>$ obj. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1NamesPriv_a3fba0ecac0cb448f429097581b7d61b3}{Add} (std\+::string path, std\+::string \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name}, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Object}{Object} $>$ object)
\begin{DoxyCompactList}\small\item\em An intermediate form of \hyperlink{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}{Names\+::\+Add} allowing you to provide a path to the parent object (under which you want this name to be defined) in the form of a name path string. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1NamesPriv_a26f071c8f39d3c0f07580e4b508087ca}{Add} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Object}{Object} $>$ context, std\+::string \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name}, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Object}{Object} $>$ object)
\begin{DoxyCompactList}\small\item\em A low-\/level form of \hyperlink{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}{Names\+::\+Add} allowing you to specify the path to the parent object (under which you want this name to be defined) in the form of a previously named object. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1NamesPriv_a51f6ec455739940fa02c6b46d1ea273a}{Rename} (std\+::string oldpath, std\+::string newname)
\begin{DoxyCompactList}\small\item\em Rename a previously associated name. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1NamesPriv_a6f0e7c4335aac3b5ed4abe0b7cc43ebc}{Rename} (std\+::string path, std\+::string oldname, std\+::string newname)
\begin{DoxyCompactList}\small\item\em An intermediate form of \hyperlink{classns3_1_1Names_a0ed4aa6358357bef3930cd19ba306373}{Names\+::\+Rename} allowing you to provide a path to the parent object (under which you want this name to be changed) in the form of a name path string. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1NamesPriv_aa8e3600d5c9144e472ddf263040e2f6b}{Rename} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Object}{Object} $>$ context, std\+::string oldname, std\+::string newname)
\begin{DoxyCompactList}\small\item\em A low-\/level form of \hyperlink{classns3_1_1Names_a0ed4aa6358357bef3930cd19ba306373}{Names\+::\+Rename} allowing you to specify the path to the parent object (under which you want this name to be changed) in the form of a previously named object. \end{DoxyCompactList}\item 
std\+::string \hyperlink{classns3_1_1NamesPriv_a7fbc3ac7b8924c08d86ddc79d96385fa}{Find\+Name} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Object}{Object} $>$ object)
\begin{DoxyCompactList}\small\item\em Given a pointer to an object, look to see if that object has a name associated with it and, if so, return the name of the object otherwise return an empty string. \end{DoxyCompactList}\item 
std\+::string \hyperlink{classns3_1_1NamesPriv_a4a2421dd19968986051239ce2615485f}{Find\+Path} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Object}{Object} $>$ object)
\begin{DoxyCompactList}\small\item\em Given a pointer to an object, look to see if that object has a name associated with it and return the fully qualified name path of the object otherwise return an empty string. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1NamesPriv_a7830244fafff9d2221a830e9b247b57a}{Clear} (void)
\begin{DoxyCompactList}\small\item\em Clear the list of objects associated with names. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Object}{Object} $>$ \hyperlink{classns3_1_1NamesPriv_aeb1553e055f77ec72919f4ed41e4aec2}{Find} (std\+::string path)
\begin{DoxyCompactList}\small\item\em Given a name path string, look to see if there\textquotesingle{}s an object in the system with that associated to it. If there is, do a Get\+Object on the resulting object to convert it to the requested typename and return it. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Object}{Object} $>$ \hyperlink{classns3_1_1NamesPriv_a712dfaa8882f8148ebe40e6ebcb10f9f}{Find} (std\+::string path, std\+::string \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name})
\begin{DoxyCompactList}\small\item\em Given a path to an object and an object name, look through the names defined under the path to see if there\textquotesingle{}s an object there with the given name. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Object}{Object} $>$ \hyperlink{classns3_1_1NamesPriv_ad6e9e999c0ef8292819648ac7d0d438d}{Find} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Object}{Object} $>$ context, std\+::string \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name})
\begin{DoxyCompactList}\small\item\em Given a path to an object and an object name, look through the names defined under the path to see if there\textquotesingle{}s an object there with the given name. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1NameNode}{Name\+Node} $\ast$ \hyperlink{classns3_1_1NamesPriv_a9867bf67ff8f138d1dd4d175e1fb0fde}{Is\+Named} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Object}{Object} $>$ object)
\item 
bool \hyperlink{classns3_1_1NamesPriv_a2596edf33333e7745eb47a620783c004}{Is\+Duplicate\+Name} (\hyperlink{classns3_1_1NameNode}{Name\+Node} $\ast$node, std\+::string \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name})
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1NameNode}{Name\+Node} \hyperlink{classns3_1_1NamesPriv_a24851b2ca8230416228472b2e4e1b587}{m\+\_\+root}
\item 
std\+::map$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Object}{Object} $>$, \hyperlink{classns3_1_1NameNode}{Name\+Node} $\ast$ $>$ \hyperlink{classns3_1_1NamesPriv_a19b615be3c0c142fe0ec7539db8598cf}{m\+\_\+object\+Map}
\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classns3_1_1NamesPriv_a8e6dace6fb74ee2b530528e4ecd0f22c}{Names}
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
The singleton root \hyperlink{classns3_1_1Names}{Names} object. 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}!Names\+Priv@{Names\+Priv}}
\index{Names\+Priv@{Names\+Priv}!ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}}
\subsubsection[{\texorpdfstring{Names\+Priv()}{NamesPriv()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Names\+Priv\+::\+Names\+Priv (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1NamesPriv_aa89187c3753da65a97180b31cf77c958}{}\label{classns3_1_1NamesPriv_aa89187c3753da65a97180b31cf77c958}
Constructor. 
\begin{DoxyCode}
203 \{
204   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
205 
206   \hyperlink{classns3_1_1NamesPriv_a24851b2ca8230416228472b2e4e1b587}{m\_root}.\hyperlink{classns3_1_1NameNode_a2c5fdd9118e10047488a9967428d9474}{m\_parent} = 0;
207   \hyperlink{classns3_1_1NamesPriv_a24851b2ca8230416228472b2e4e1b587}{m\_root}.\hyperlink{classns3_1_1NameNode_ae028fe25bbe0bde5cbe82a79a260acb9}{m\_name} = \textcolor{stringliteral}{"Names"};
208   \hyperlink{classns3_1_1NamesPriv_a24851b2ca8230416228472b2e4e1b587}{m\_root}.\hyperlink{classns3_1_1NameNode_ab5417732c84a06149e0820d35bc85a7c}{m\_object} = 0;
209 \}
\end{DoxyCode}
\index{ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}!````~Names\+Priv@{$\sim$\+Names\+Priv}}
\index{````~Names\+Priv@{$\sim$\+Names\+Priv}!ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}}
\subsubsection[{\texorpdfstring{$\sim$\+Names\+Priv()}{~NamesPriv()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Names\+Priv\+::$\sim$\+Names\+Priv (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1NamesPriv_a903613cb232c09abd3c9d66432124d10}{}\label{classns3_1_1NamesPriv_a903613cb232c09abd3c9d66432124d10}
Destructor. 
\begin{DoxyCode}
212 \{
213   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
214   \hyperlink{classns3_1_1NamesPriv_a7830244fafff9d2221a830e9b247b57a}{Clear} ();
215   \hyperlink{classns3_1_1NamesPriv_a24851b2ca8230416228472b2e4e1b587}{m\_root}.\hyperlink{classns3_1_1NameNode_ae028fe25bbe0bde5cbe82a79a260acb9}{m\_name} = \textcolor{stringliteral}{""};
216 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}!Add@{Add}}
\index{Add@{Add}!ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}}
\subsubsection[{\texorpdfstring{Add(std\+::string name, Ptr$<$ Object $>$ object)}{Add(std::string name, Ptr< Object > object)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Names\+Priv\+::\+Add (
\begin{DoxyParamCaption}
\item[{std\+::string}]{name, }
\item[{{\bf Ptr}$<$ {\bf Object} $>$}]{object}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1NamesPriv_a1d9bc7794dedbcb88c7f875c084761bb}{}\label{classns3_1_1NamesPriv_a1d9bc7794dedbcb88c7f875c084761bb}


Add the association between the string \char`\"{}name\char`\"{} and the Ptr$<$\+Object$>$ obj. 

The name may begin either with \char`\"{}/\+Names\char`\"{} to explicitly call out the fact that the name provided is installed under the root of the name space, or it may begin with the name of the first object in the path. For example, \hyperlink{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}{Names\+::\+Add} (\char`\"{}/\+Names/client\char`\"{}, obj) and \hyperlink{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}{Names\+::\+Add} (\char`\"{}client\char`\"{}, obj) accomplish exactly the same thing. A name at a given level in the name space path must be unique. In the case of the example above, it would be illegal to try and associate a different object with the same name\+: \char`\"{}client\char`\"{} at the same level (\char`\"{}/\+Names\char`\"{}) in the path.

As well as specifying a name at the root of the \char`\"{}/\+Names\char`\"{} namespace, the name parameter can contain a path that fully qualifies the name to be added. For example, if you previously have named an object \char`\"{}client\char`\"{} in the root namespace as above, you could name an object \char`\"{}under\char`\"{} that name by making a call like \hyperlink{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}{Names\+::\+Add} (\char`\"{}/\+Names/client/eth0\char`\"{}, obj). This will define the name \char`\"{}eth0\char`\"{} and make it reachable using the path specified. Note that \hyperlink{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}{Names\+::\+Add} (\char`\"{}client/eth0\char`\"{}, obj) would accomplish exactly the same thing.

Duplicate names are not allowed at the same level in a path, however you may associate similar names with different paths. For example, if you define \char`\"{}/\+Names/\+Client\char`\"{}, you may not define another \char`\"{}/\+Names/\+Client\char`\"{} just as you may not have two files with the same name in a classical filesystem. However, you may have \char`\"{}/\+Names/\+Client/eth0\char`\"{} and \char`\"{}/\+Names/\+Server/eth0\char`\"{} defined at the same time just as you might have different files of the same name under different directories.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em name} & The name of the object you want to associate; which may be prepended with a path to that object. \\
\hline
\mbox{\tt in}  & {\em object} & A smart pointer to the object itself. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily true} if the object was named successfully. 
\end{DoxyReturn}

\begin{DoxyCode}
242 \{
243   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name} << \textcolor{keywordtype}{object});
244   \textcolor{comment}{//}
245   \textcolor{comment}{// This is the simple, easy to use version of Add, so we want it to be flexible.}
246   \textcolor{comment}{// We don't want to force a user to always type the fully qualified namespace }
247   \textcolor{comment}{// name, so we allow the namespace name to be omitted.  For example, calling}
248   \textcolor{comment}{// Add ("Client/ath0", obj) should result in exactly the same behavior as}
249   \textcolor{comment}{// Add ("/Names/Client/ath0", obj).  Calling Add ("Client", obj) should have}
250   \textcolor{comment}{// the same effect as Add ("Names/Client", obj)}
251   \textcolor{comment}{//}
252   \textcolor{comment}{// The first thing to do, then, is to "canonicalize" the input string to always}
253   \textcolor{comment}{// be a fully qualified name.}
254   \textcolor{comment}{//}
255   \textcolor{comment}{// If we are given a name that begins with "/Names/" we assume that this is a}
256   \textcolor{comment}{// fully qualified path name to the object we want to create.  We split the name}
257   \textcolor{comment}{// into a path string and and a final segment (name) and then call the "Real" Add.}
258   \textcolor{comment}{//}
259   std::string namespaceName = \textcolor{stringliteral}{"/Names"};
260   std::string::size\_type offset = \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name}.find (namespaceName);
261   \textcolor{keywordflow}{if} (offset != 0)
262     \{
263       \textcolor{comment}{//}
264       \textcolor{comment}{// This must be a name that has the "/Names" namespace prefix omitted.}
265       \textcolor{comment}{// Do some reasonableness checking on the rest of the name.}
266       \textcolor{comment}{//}
267       offset = \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name}.find (\textcolor{stringliteral}{"/"});
268       \textcolor{keywordflow}{if} (offset == 0)
269         \{
270           \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\textcolor{keyword}{false}, \textcolor{stringliteral}{"NamesPriv::Add(): Name begins with '/' but not \(\backslash\)"/Names\(\backslash\)""});
271           \textcolor{keywordflow}{return} \textcolor{keyword}{false};
272         \}
273 
274       \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name} = \textcolor{stringliteral}{"/Names/"} + \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name};
275     \}
276 
277   \textcolor{comment}{//}
278   \textcolor{comment}{// There must now be a fully qualified path in the string.  All fully }
279   \textcolor{comment}{// qualified names begin with "/Names".  We have to split off the final }
280   \textcolor{comment}{// segment which will become the name of the object.  A '/' that}
281   \textcolor{comment}{// separates the path from the final segment had better be there since}
282   \textcolor{comment}{// we just made sure that at least the namespace name was there.}
283   \textcolor{comment}{//}
284   std::string::size\_type \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name}.rfind (\textcolor{stringliteral}{"/"});
285   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (i != std::string::npos, \textcolor{stringliteral}{"NamesPriv::Add(): Internal error.  Can't find '/' in
       name"});
286 
287   \textcolor{comment}{//}
288   \textcolor{comment}{// The slash we found cannot be the slash at the start of the namespaceName.}
289   \textcolor{comment}{// This would indicate there is no name in the path at all.  It can be}
290   \textcolor{comment}{// any other index.}
291   \textcolor{comment}{//}
292   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (i != 0, \textcolor{stringliteral}{"NamesPriv::Add(): Can't find a name in the path string"});
293 
294   \textcolor{comment}{//}
295   \textcolor{comment}{// We now know where the path string starts and ends, and where the}
296   \textcolor{comment}{// name starts and ends.  All we have to do is to call our available}
297   \textcolor{comment}{// function for adding a name under a path string.}
298   \textcolor{comment}{//}
299   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1NamesPriv_a1d9bc7794dedbcb88c7f875c084761bb}{Add} (\hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name}.substr (0, i), \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name}.substr (i + 1), object);
300 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 2


\index{ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}!Add@{Add}}
\index{Add@{Add}!ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}}
\subsubsection[{\texorpdfstring{Add(std\+::string path, std\+::string name, Ptr$<$ Object $>$ object)}{Add(std::string path, std::string name, Ptr< Object > object)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Names\+Priv\+::\+Add (
\begin{DoxyParamCaption}
\item[{std\+::string}]{path, }
\item[{std\+::string}]{name, }
\item[{{\bf Ptr}$<$ {\bf Object} $>$}]{object}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1NamesPriv_a3fba0ecac0cb448f429097581b7d61b3}{}\label{classns3_1_1NamesPriv_a3fba0ecac0cb448f429097581b7d61b3}


An intermediate form of \hyperlink{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}{Names\+::\+Add} allowing you to provide a path to the parent object (under which you want this name to be defined) in the form of a name path string. 

In some cases, it is desirable to break up the path used to describe an item in the names namespace into a path and a name. This is analogous to a file system operation in which you provide a directory name and a file name.

For example, consider a situation where you have previously named an object \char`\"{}/\+Names/server\char`\"{}. If you further want to create an association for between a Ptr$<$\+Object$>$ object that you want to live \char`\"{}under\char`\"{} the server in the name space -- perhaps \char`\"{}eth0\char`\"{} -- you could do this in two ways, depending on which was more convenient\+: \hyperlink{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}{Names\+::\+Add} (\char`\"{}/\+Names/server/eth0\char`\"{}, object) or, using the split path and name approach, \hyperlink{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}{Names\+::\+Add} (\char`\"{}/\+Names/server\char`\"{}, \char`\"{}eth0\char`\"{}, object).

Duplicate names are not allowed at the same level in a path, however you may associate similar names with different paths. For example, if you define \char`\"{}/\+Names/\+Client\char`\"{}, you may not define another \char`\"{}/\+Names/\+Client\char`\"{} just as you may not have two files with the same name in a classical filesystem. However, you may have \char`\"{}/\+Names/\+Client/eth0\char`\"{} and \char`\"{}/\+Names/\+Server/eth0\char`\"{} defined at the same time just as you might have different files of the same name under different directories.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path} & A path name describing a previously named object under which you want this new name to be defined. \\
\hline
\mbox{\tt in}  & {\em name} & The name of the object you want to associate. \\
\hline
\mbox{\tt in}  & {\em object} & A smart pointer to the object itself.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}{Names\+::\+Add} (Ptr$<$\+Object$>$,std\+::string,Ptr$<$\+Object$>$); 
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
{\ttfamily true} if the object was named successfully. 
\end{DoxyReturn}

\begin{DoxyCode}
304 \{
305   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << path << \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name} << \textcolor{keywordtype}{object});
306   \textcolor{keywordflow}{if} (path == \textcolor{stringliteral}{"/Names"})
307     \{
308       \textcolor{keywordflow}{return} \hyperlink{classns3_1_1NamesPriv_a1d9bc7794dedbcb88c7f875c084761bb}{Add} (Ptr<Object> (0, \textcolor{keyword}{false}), \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name}, \textcolor{keywordtype}{object});
309     \}
310   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1NamesPriv_a1d9bc7794dedbcb88c7f875c084761bb}{Add} (\hyperlink{classns3_1_1NamesPriv_aeb1553e055f77ec72919f4ed41e4aec2}{Find} (path), \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name}, \textcolor{keywordtype}{object});
311 \}
\end{DoxyCode}
\index{ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}!Add@{Add}}
\index{Add@{Add}!ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}}
\subsubsection[{\texorpdfstring{Add(\+Ptr$<$ Object $>$ context, std\+::string name, Ptr$<$ Object $>$ object)}{Add(Ptr< Object > context, std::string name, Ptr< Object > object)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Names\+Priv\+::\+Add (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Object} $>$}]{context, }
\item[{std\+::string}]{name, }
\item[{{\bf Ptr}$<$ {\bf Object} $>$}]{object}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1NamesPriv_a26f071c8f39d3c0f07580e4b508087ca}{}\label{classns3_1_1NamesPriv_a26f071c8f39d3c0f07580e4b508087ca}


A low-\/level form of \hyperlink{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}{Names\+::\+Add} allowing you to specify the path to the parent object (under which you want this name to be defined) in the form of a previously named object. 

In some use cases, it is desirable to break up the path in the names name space into a path and a name. This is analogous to a file system operation in which you provide a directory name and a file name. Recall that the path string actually refers to a previously named object, \char`\"{}under\char`\"{} which you want to accomplish some naming action.

However, the path is sometimes not available, and you only have the object that is represented by the path in the names name space. To support this use-\/case in a reasonably high-\/performance way, the path string is can be replaced by the object pointer to which that path would refer. In the spirit of the \hyperlink{namespacens3_1_1Config}{Config} code where this use-\/case is most prominent, we refer to this object as the \char`\"{}context\char`\"{} for the names operation.

You can think of the context roughly as the inode number of a directory file in Unix. The inode number can be used to look up the directory file which contains the list of file names defined at that directory level. Similarly the context is used to look up an internal name service entry which contains the names defined for that context.

For example, consider a situation where you have previously named an object \char`\"{}/\+Names/server\char`\"{}. If you further want to create an association for between a Ptr$<$\+Object$>$ object that you want to live \char`\"{}under\char`\"{} the server in the name space -- perhaps \char`\"{}eth0\char`\"{} -- you could do this by providing a complete path to the new name\+: \hyperlink{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}{Names\+::\+Add} (\char`\"{}/\+Names/server/eth0\char`\"{}, object). If, however, somewhere in your code you only had a pointer to the server, say \hyperlink{classns3_1_1Ptr}{Ptr$<$\+Node$>$} node, and not a handy path string, you could also accomplish this by \hyperlink{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}{Names\+::\+Add} (node, \char`\"{}eth0\char`\"{}, object).

Duplicate names are not allowed at the same level in a path. In the case of this method, the context object gives the same information as a path string. You may associate similar names with different paths. For example, if you define\char`\"{}/\+Names/\+Client\char`\"{}, you may not define another \char`\"{}/\+Names/\+Client\char`\"{} just as you may not have two files with the same name in a classical filesystem. However, you may have \char`\"{}/\+Names/\+Client/eth0\char`\"{} and \char`\"{}/\+Names/\+Server/eth0\char`\"{} defined at the same time just as you might have different files of the same name under different directories.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em context} & A smart pointer to an object that is used in place of the path under which you want this new name to be defined. \\
\hline
\mbox{\tt in}  & {\em name} & The name of the object you want to associate. \\
\hline
\mbox{\tt in}  & {\em object} & A smart pointer to the object itself. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily true} if the object was named successfully. 
\end{DoxyReturn}

\begin{DoxyCode}
315 \{
316   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << context << \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name} << \textcolor{keywordtype}{object});
317 
318   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1NamesPriv_a9867bf67ff8f138d1dd4d175e1fb0fde}{IsNamed} (\textcolor{keywordtype}{object}))
319     \{
320       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Object is already named"});
321       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
322     \}
323 
324   NameNode *node = 0;
325   \textcolor{keywordflow}{if} (context)
326     \{
327       node = \hyperlink{classns3_1_1NamesPriv_a9867bf67ff8f138d1dd4d175e1fb0fde}{IsNamed} (context);
328       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (node, \textcolor{stringliteral}{"NamesPriv::Name(): context must point to a previously named node"})
      ;
329     \}
330   \textcolor{keywordflow}{else}
331     \{
332       node = &\hyperlink{classns3_1_1NamesPriv_a24851b2ca8230416228472b2e4e1b587}{m\_root};
333     \}
334 
335   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1NamesPriv_a2596edf33333e7745eb47a620783c004}{IsDuplicateName} (node, \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name}))
336     \{
337       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Name is already taken"});
338       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
339     \}
340 
341   NameNode *newNode = \textcolor{keyword}{new} NameNode (node, \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name}, \textcolor{keywordtype}{object});
342   node->m\_nameMap[\hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name}] = newNode;
343   \hyperlink{classns3_1_1NamesPriv_a19b615be3c0c142fe0ec7539db8598cf}{m\_objectMap}[object] = newNode;
344 
345   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
346 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}!Clear@{Clear}}
\index{Clear@{Clear}!ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}}
\subsubsection[{\texorpdfstring{Clear(void)}{Clear(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Names\+Priv\+::\+Clear (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1NamesPriv_a7830244fafff9d2221a830e9b247b57a}{}\label{classns3_1_1NamesPriv_a7830244fafff9d2221a830e9b247b57a}


Clear the list of objects associated with names. 


\begin{DoxyCode}
220 \{
221   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
222   \textcolor{comment}{//}
223   \textcolor{comment}{// Every name is associated with an object in the object map, so freeing the}
224   \textcolor{comment}{// NameNodes in this map will free all of the memory allocated for the NameNodes}
225   \textcolor{comment}{//}
226   \textcolor{keywordflow}{for} (std::map<Ptr<Object>, NameNode *>::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1NamesPriv_a19b615be3c0c142fe0ec7539db8598cf}{m\_objectMap}.begin (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1NamesPriv_a19b615be3c0c142fe0ec7539db8598cf}{m\_objectMap}.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
227     \{
228       \textcolor{keyword}{delete} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second;
229       \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second = 0;
230     \}
231 
232   \hyperlink{classns3_1_1NamesPriv_a19b615be3c0c142fe0ec7539db8598cf}{m\_objectMap}.clear ();
233 
234   \hyperlink{classns3_1_1NamesPriv_a24851b2ca8230416228472b2e4e1b587}{m\_root}.\hyperlink{classns3_1_1NameNode_a2c5fdd9118e10047488a9967428d9474}{m\_parent} = 0;
235   \hyperlink{classns3_1_1NamesPriv_a24851b2ca8230416228472b2e4e1b587}{m\_root}.\hyperlink{classns3_1_1NameNode_ae028fe25bbe0bde5cbe82a79a260acb9}{m\_name} = \textcolor{stringliteral}{"Names"};
236   \hyperlink{classns3_1_1NamesPriv_a24851b2ca8230416228472b2e4e1b587}{m\_root}.\hyperlink{classns3_1_1NameNode_ab5417732c84a06149e0820d35bc85a7c}{m\_object} = 0;
237   \hyperlink{classns3_1_1NamesPriv_a24851b2ca8230416228472b2e4e1b587}{m\_root}.\hyperlink{classns3_1_1NameNode_a7fc4cf8060a6182da15ba8eb4c265344}{m\_nameMap}.clear ();
238 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}!Find@{Find}}
\index{Find@{Find}!ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}}
\subsubsection[{\texorpdfstring{Find(std\+::string path)}{Find(std::string path)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Object} $>$ ns3\+::\+Names\+Priv\+::\+Find (
\begin{DoxyParamCaption}
\item[{std\+::string}]{path}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1NamesPriv_aeb1553e055f77ec72919f4ed41e4aec2}{}\label{classns3_1_1NamesPriv_aeb1553e055f77ec72919f4ed41e4aec2}


Given a name path string, look to see if there\textquotesingle{}s an object in the system with that associated to it. If there is, do a Get\+Object on the resulting object to convert it to the requested typename and return it. 

An object can be referred to in two ways. Either you can talk about it using its fully qualified path name, for example, \char`\"{}/\+Names/client/eth0\char`\"{} or you can refer to it by its name, in this case \char`\"{}eth0\char`\"{}.

This method requires that the name path of the object be provided, e.\+g., \char`\"{}\+Names/client/eth0\char`\"{}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path} & A string containing a name space path used to locate the object.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A smart pointer to the named object converted to the requested type. 
\end{DoxyReturn}

\begin{DoxyCode}
518 \{
519   \textcolor{comment}{//}
520   \textcolor{comment}{// This is hooked in from simple, easy to use version of Find, so we want it}
521   \textcolor{comment}{// to be flexible.}
522   \textcolor{comment}{//}
523   \textcolor{comment}{// If we are provided a path that doesn't begin with "/Names", we assume }
524   \textcolor{comment}{// that the caller has simply given us a path starting with a name that}
525   \textcolor{comment}{// is in the root namespace.  This allows peole to omit the "/Names" prefix.}
526   \textcolor{comment}{// and simply do a Find ("Client/eth0") instead of having to always do a}
527   \textcolor{comment}{// Find ("/Names/Client/eth0");}
528   \textcolor{comment}{//}
529   \textcolor{comment}{// So, if we are given a name that begins with "/Names/" the upshot is that we}
530   \textcolor{comment}{// just remove that prefix and treat the rest of the string as starting with a }
531   \textcolor{comment}{// name in the root namespace.}
532   \textcolor{comment}{//}
533 
534   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << path);
535   std::string namespaceName = \textcolor{stringliteral}{"/Names/"};
536   std::string remaining;
537 
538   std::string::size\_type offset = path.find (namespaceName);
539   \textcolor{keywordflow}{if} (offset == 0)
540     \{
541       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (path << \textcolor{stringliteral}{" is a fully qualified name"});
542       remaining = path.substr (namespaceName.size ());
543     \}
544   \textcolor{keywordflow}{else}
545     \{
546       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (path << \textcolor{stringliteral}{" begins with a relative name"});
547       remaining = path;
548     \}
549 
550   NameNode *node = &\hyperlink{classns3_1_1NamesPriv_a24851b2ca8230416228472b2e4e1b587}{m\_root};
551 
552   \textcolor{comment}{//}
553   \textcolor{comment}{// The string <remaining> is now composed entirely of path segments in}
554   \textcolor{comment}{// the /Names name space and we have eaten the leading slash. e.g., }
555   \textcolor{comment}{// remaining = "ClientNode/eth0"}
556   \textcolor{comment}{//}
557   \textcolor{comment}{// The start of the search is always at the root of the name space.}
558   \textcolor{comment}{//}
559   \textcolor{keywordflow}{for} (;;)
560     \{
561       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Looking for the object of name "} << remaining);
562       offset = remaining.find (\textcolor{stringliteral}{"/"});
563       \textcolor{keywordflow}{if} (offset == std::string::npos)
564         \{
565           \textcolor{comment}{//}
566           \textcolor{comment}{// There are no remaining slashes so this is the last segment of the }
567           \textcolor{comment}{// specified name.  We're done when we find it}
568           \textcolor{comment}{//}
569           std::map<std::string, NameNode *>::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = node->m\_nameMap.find (remaining);
570           \textcolor{keywordflow}{if} (i == node->m\_nameMap.end ())
571             \{
572               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Name does not exist in name map"});
573               \textcolor{keywordflow}{return} 0;
574             \}
575           \textcolor{keywordflow}{else}
576             \{
577               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Name parsed, found object"});
578               \textcolor{keywordflow}{return} i->second->m\_object;
579             \}
580         \}
581       \textcolor{keywordflow}{else}
582         \{
583           \textcolor{comment}{//}
584           \textcolor{comment}{// There are more slashes so this is an intermediate segment of the }
585           \textcolor{comment}{// specified name.  We need to "recurse" when we find this segment.}
586           \textcolor{comment}{//}
587           offset = remaining.find (\textcolor{stringliteral}{"/"});
588           std::string segment = remaining.substr (0, offset);
589 
590           std::map<std::string, NameNode *>::iterator i = node->m\_nameMap.find (segment);
591           \textcolor{keywordflow}{if} (i == node->m\_nameMap.end ())
592             \{
593               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Name does not exist in name map"});
594               \textcolor{keywordflow}{return} 0;
595             \}
596           \textcolor{keywordflow}{else}
597             \{
598               node = i->second;
599               remaining = remaining.substr (offset + 1);
600               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Intermediate segment parsed"});
601               \textcolor{keywordflow}{continue};
602             \}
603         \}
604     \}
605 
606   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (node, \textcolor{stringliteral}{"NamesPriv::Find(): Internal error:  this can't happen"});
607   \textcolor{keywordflow}{return} 0;
608 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}!Find@{Find}}
\index{Find@{Find}!ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}}
\subsubsection[{\texorpdfstring{Find(std\+::string path, std\+::string name)}{Find(std::string path, std::string name)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Object} $>$ ns3\+::\+Names\+Priv\+::\+Find (
\begin{DoxyParamCaption}
\item[{std\+::string}]{path, }
\item[{std\+::string}]{name}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1NamesPriv_a712dfaa8882f8148ebe40e6ebcb10f9f}{}\label{classns3_1_1NamesPriv_a712dfaa8882f8148ebe40e6ebcb10f9f}


Given a path to an object and an object name, look through the names defined under the path to see if there\textquotesingle{}s an object there with the given name. 

In some cases, it is desirable to break up the path used to describe an item in the names namespace into a path and a name. This is analogous to a file system operation in which you provide a directory name and a file name.

For example, consider a situation where you have previously named an object \char`\"{}/\+Names/server/eth0\char`\"{}. If you want to discover the object which you associated with this path, you could do this in two ways, depending on which was more convenient\+: \hyperlink{classns3_1_1Names_a9d07094fb3d716d08733af05c1593555}{Names\+::\+Find} (\char`\"{}/\+Names/server/eth0\char`\"{}) or, using the split path and name approach, \hyperlink{classns3_1_1Names_a9d07094fb3d716d08733af05c1593555}{Names\+::\+Find} (\char`\"{}/\+Names/server\char`\"{}, \char`\"{}eth0\char`\"{}).


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path} & A path name describing a previously named object under which you want to look for the specified name. \\
\hline
\mbox{\tt in}  & {\em name} & A string containing a name to search for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A smart pointer to the named object converted to the requested type. 
\end{DoxyReturn}

\begin{DoxyCode}
612 \{
613   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << path << \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name});
614 
615   \textcolor{keywordflow}{if} (path == \textcolor{stringliteral}{"/Names"})
616     \{
617       \textcolor{keywordflow}{return} \hyperlink{classns3_1_1NamesPriv_aeb1553e055f77ec72919f4ed41e4aec2}{Find} (Ptr<Object> (0, \textcolor{keyword}{false}), \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name});
618     \}
619   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1NamesPriv_aeb1553e055f77ec72919f4ed41e4aec2}{Find} (\hyperlink{classns3_1_1NamesPriv_aeb1553e055f77ec72919f4ed41e4aec2}{Find} (path), \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name});
620 \}
\end{DoxyCode}
\index{ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}!Find@{Find}}
\index{Find@{Find}!ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}}
\subsubsection[{\texorpdfstring{Find(\+Ptr$<$ Object $>$ context, std\+::string name)}{Find(Ptr< Object > context, std::string name)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Object} $>$ ns3\+::\+Names\+Priv\+::\+Find (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Object} $>$}]{context, }
\item[{std\+::string}]{name}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1NamesPriv_ad6e9e999c0ef8292819648ac7d0d438d}{}\label{classns3_1_1NamesPriv_ad6e9e999c0ef8292819648ac7d0d438d}


Given a path to an object and an object name, look through the names defined under the path to see if there\textquotesingle{}s an object there with the given name. 

In some cases, it is desirable to break up the path used to describe an item in the names namespace into a path and a name. This is analogous to a file system operation in which you provide a directory name and a file name.

For example, consider a situation where you have previously named an object \char`\"{}/\+Names/server/eth0\char`\"{}. If you want to discover the object which you associated with this path, you could do this in two ways, depending on which was more convenient\+: \hyperlink{classns3_1_1Names_a9d07094fb3d716d08733af05c1593555}{Names\+::\+Find} (\char`\"{}/\+Names/server/eth0\char`\"{}) or, using the split path and name approach, \hyperlink{classns3_1_1Names_a9d07094fb3d716d08733af05c1593555}{Names\+::\+Find} (\char`\"{}/\+Names/server\char`\"{}, \char`\"{}eth0\char`\"{}).

However, the path is sometimes not available, and you only have the object that is represented by the path in the names name space. To support this use-\/case in a reasonably high-\/performance way, the path string is can be replaced by the object pointer to which that path would refer. In the spirit of the \hyperlink{namespacens3_1_1Config}{Config} code where this use-\/case is most prominent, we refer to this object as the \char`\"{}context\char`\"{} for the names operation.

You can think of the context roughly as the inode number of a directory file in Unix. The inode number can be used to look up the directory file which contains the list of file names defined at that directory level. Similarly the context is used to look up an internal name service entry which contains the names defined for that context.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em context} & A smart pointer to an object that is used in place of the path under which you want this new name to be defined. \\
\hline
\mbox{\tt in}  & {\em name} & A string containing a name to search for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A smart pointer to the named object converted to the requested type. 
\end{DoxyReturn}

\begin{DoxyCode}
624 \{
625   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << context << \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name});
626 
627   NameNode *node = 0;
628 
629   \textcolor{keywordflow}{if} (context == 0)
630     \{
631       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Zero context implies root NameNode"});
632       node = &\hyperlink{classns3_1_1NamesPriv_a24851b2ca8230416228472b2e4e1b587}{m\_root};
633     \}
634   \textcolor{keywordflow}{else}
635     \{
636       node = \hyperlink{classns3_1_1NamesPriv_a9867bf67ff8f138d1dd4d175e1fb0fde}{IsNamed} (context);
637       \textcolor{keywordflow}{if} (node == 0)
638         \{
639           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Context does not point to a previously named node"});
640           \textcolor{keywordflow}{return} 0;
641         \}
642     \}
643 
644   std::map<std::string, NameNode *>::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = node->m\_nameMap.find (\hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name});
645   \textcolor{keywordflow}{if} (i == node->m\_nameMap.end ())
646     \{
647       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Name does not exist in name map"});
648       \textcolor{keywordflow}{return} 0;
649     \}
650   \textcolor{keywordflow}{else}
651     \{
652       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Name exists in name map"});
653       \textcolor{keywordflow}{return} i->second->m\_object;
654     \}
655 \}
\end{DoxyCode}
\index{ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}!Find\+Name@{Find\+Name}}
\index{Find\+Name@{Find\+Name}!ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}}
\subsubsection[{\texorpdfstring{Find\+Name(\+Ptr$<$ Object $>$ object)}{FindName(Ptr< Object > object)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string ns3\+::\+Names\+Priv\+::\+Find\+Name (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Object} $>$}]{object}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1NamesPriv_a7fbc3ac7b8924c08d86ddc79d96385fa}{}\label{classns3_1_1NamesPriv_a7fbc3ac7b8924c08d86ddc79d96385fa}


Given a pointer to an object, look to see if that object has a name associated with it and, if so, return the name of the object otherwise return an empty string. 

An object can be referred to in two ways. Either you can talk about it using its fully qualified path name, for example, \char`\"{}/\+Names/client/eth0\char`\"{} or you can refer to it by its name, in this case \char`\"{}eth0\char`\"{}.

This method returns the name of the object, e.\+g., \char`\"{}eth0\char`\"{}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em object} & A smart pointer to an object for which you want to find its name.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A string containing the name of the object if found, otherwise the empty string. 
\end{DoxyReturn}

\begin{DoxyCode}
472 \{
473   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \textcolor{keywordtype}{object});
474 
475   std::map<Ptr<Object>, NameNode *>::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1NamesPriv_a19b615be3c0c142fe0ec7539db8598cf}{m\_objectMap}.find (\textcolor{keywordtype}{object});
476   \textcolor{keywordflow}{if} (i == \hyperlink{classns3_1_1NamesPriv_a19b615be3c0c142fe0ec7539db8598cf}{m\_objectMap}.end ())
477     \{
478       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Object does not exist in object map"});
479       \textcolor{keywordflow}{return} \textcolor{stringliteral}{""};
480     \}
481   \textcolor{keywordflow}{else}
482     \{
483       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Object exists in object map"});
484       \textcolor{keywordflow}{return} i->second->m\_name;
485     \}
486 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}!Find\+Path@{Find\+Path}}
\index{Find\+Path@{Find\+Path}!ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}}
\subsubsection[{\texorpdfstring{Find\+Path(\+Ptr$<$ Object $>$ object)}{FindPath(Ptr< Object > object)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string ns3\+::\+Names\+Priv\+::\+Find\+Path (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Object} $>$}]{object}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1NamesPriv_a4a2421dd19968986051239ce2615485f}{}\label{classns3_1_1NamesPriv_a4a2421dd19968986051239ce2615485f}


Given a pointer to an object, look to see if that object has a name associated with it and return the fully qualified name path of the object otherwise return an empty string. 

An object can be referred to in two ways. Either you can talk about it using its fully qualified path name, for example, \char`\"{}/\+Names/client/eth0\char`\"{} or you can refer to it by its name, in this case \char`\"{}eth0\char`\"{}.

This method returns the name path of the object, e.\+g., \char`\"{}\+Names/client/eth0\char`\"{}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em object} & A smart pointer to an object for which you want to find its fullname.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A string containing the name path of the object, otherwise the empty string. 
\end{DoxyReturn}

\begin{DoxyCode}
490 \{
491   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \textcolor{keywordtype}{object});
492 
493   std::map<Ptr<Object>, NameNode *>::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1NamesPriv_a19b615be3c0c142fe0ec7539db8598cf}{m\_objectMap}.find (\textcolor{keywordtype}{object});
494   \textcolor{keywordflow}{if} (i == \hyperlink{classns3_1_1NamesPriv_a19b615be3c0c142fe0ec7539db8598cf}{m\_objectMap}.end ())
495     \{
496       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Object does not exist in object map"});
497       \textcolor{keywordflow}{return} \textcolor{stringliteral}{""};
498     \}
499 
500   NameNode *\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = i->second;
501   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (p, \textcolor{stringliteral}{"NamesPriv::FindFullName(): Internal error: Invalid NameNode pointer from
       map"});
502 
503   std::string path;
504 
505   \textcolor{keywordflow}{do}
506     \{
507       path = \textcolor{stringliteral}{"/"} + p->m\_name + path;
508       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"path is "} << path);
509     \}
510   \textcolor{keywordflow}{while} ((p = p->m\_parent) != 0);
511 
512   \textcolor{keywordflow}{return} path;
513 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}!Is\+Duplicate\+Name@{Is\+Duplicate\+Name}}
\index{Is\+Duplicate\+Name@{Is\+Duplicate\+Name}!ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}}
\subsubsection[{\texorpdfstring{Is\+Duplicate\+Name(\+Name\+Node $\ast$node, std\+::string name)}{IsDuplicateName(NameNode *node, std::string name)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Names\+Priv\+::\+Is\+Duplicate\+Name (
\begin{DoxyParamCaption}
\item[{{\bf Name\+Node} $\ast$}]{node, }
\item[{std\+::string}]{name}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1NamesPriv_a2596edf33333e7745eb47a620783c004}{}\label{classns3_1_1NamesPriv_a2596edf33333e7745eb47a620783c004}
Check if a name already exists as a child of a \hyperlink{classns3_1_1NameNode}{Name\+Node}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em node} & The node to search. \\
\hline
\mbox{\tt in}  & {\em name} & The name to search for. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily true} if {\ttfamily name} already exists as a child of {\ttfamily node}. 
\end{DoxyReturn}

\begin{DoxyCode}
677 \{
678   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << node << \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name});
679 
680   std::map<std::string, NameNode *>::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = node->m\_nameMap.find (\hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name});
681   \textcolor{keywordflow}{if} (i == node->m\_nameMap.end ())
682     \{
683       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Name does not exist in name map"});
684       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
685     \}
686   \textcolor{keywordflow}{else}
687     \{
688       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Name exists in name map"});
689       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
690     \}
691 \}
\end{DoxyCode}
\index{ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}!Is\+Named@{Is\+Named}}
\index{Is\+Named@{Is\+Named}!ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}}
\subsubsection[{\texorpdfstring{Is\+Named(\+Ptr$<$ Object $>$ object)}{IsNamed(Ptr< Object > object)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Name\+Node} $\ast$ ns3\+::\+Names\+Priv\+::\+Is\+Named (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Object} $>$}]{object}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1NamesPriv_a9867bf67ff8f138d1dd4d175e1fb0fde}{}\label{classns3_1_1NamesPriv_a9867bf67ff8f138d1dd4d175e1fb0fde}
Check if an object has a name.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em object} & The object to check. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The corresponding \hyperlink{classns3_1_1NameNode}{Name\+Node}, if it exists. 
\end{DoxyReturn}

\begin{DoxyCode}
659 \{
660   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \textcolor{keywordtype}{object});
661 
662   std::map<Ptr<Object>, NameNode *>::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1NamesPriv_a19b615be3c0c142fe0ec7539db8598cf}{m\_objectMap}.find (\textcolor{keywordtype}{object});
663   \textcolor{keywordflow}{if} (i == \hyperlink{classns3_1_1NamesPriv_a19b615be3c0c142fe0ec7539db8598cf}{m\_objectMap}.end ())
664     \{
665       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Object does not exist in object map, returning NameNode 0"});
666       \textcolor{keywordflow}{return} 0;
667     \}
668   \textcolor{keywordflow}{else}
669     \{
670       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Object exists in object map, returning NameNode "} << &i->second);
671       \textcolor{keywordflow}{return} i->second;
672     \}
673 \}
\end{DoxyCode}
\index{ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}!Rename@{Rename}}
\index{Rename@{Rename}!ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}}
\subsubsection[{\texorpdfstring{Rename(std\+::string oldpath, std\+::string newname)}{Rename(std::string oldpath, std::string newname)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Names\+Priv\+::\+Rename (
\begin{DoxyParamCaption}
\item[{std\+::string}]{oldpath, }
\item[{std\+::string}]{newname}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1NamesPriv_a51f6ec455739940fa02c6b46d1ea273a}{}\label{classns3_1_1NamesPriv_a51f6ec455739940fa02c6b46d1ea273a}


Rename a previously associated name. 

The name may begin either with \char`\"{}/\+Names\char`\"{} to explicitly call out the fact that the name provided is installed under the root of the name space, or it may begin with the name of the first object in the path. For example, \hyperlink{classns3_1_1Names_a0ed4aa6358357bef3930cd19ba306373}{Names\+::\+Rename} (\char`\"{}/\+Names/client\char`\"{}, \char`\"{}server\char`\"{}) and \hyperlink{classns3_1_1Names_a0ed4aa6358357bef3930cd19ba306373}{Names\+::\+Rename} (\char`\"{}client\char`\"{}, \char`\"{}server\char`\"{}) accomplish exactly the same thing. \hyperlink{classns3_1_1Names}{Names} at a given level in the name space path must be unique. In the case of the example above, it would be illegal to try and rename a different object to the same name\+: \char`\"{}server\char`\"{} at the same level (\char`\"{}/\+Names\char`\"{}) in the path.

As well as specifying a name at the root of the \char`\"{}/\+Names\char`\"{} namespace, the name parameter can contain a path that fully qualifies the name to be changed. For example, if you previously have (re)named an object \char`\"{}server\char`\"{} in the root namespace as above, you could then rename an object \char`\"{}under\char`\"{} that name by making a call like \hyperlink{classns3_1_1Names_a0ed4aa6358357bef3930cd19ba306373}{Names\+::\+Rename} (\char`\"{}/\+Names/server/csma\char`\"{}, \char`\"{}eth0\char`\"{}). This will rename the object previously associated with \char`\"{}/\+Names/server/csma\char`\"{} to \char`\"{}eth0\char`\"{} and make leave it reachable using the path \char`\"{}/\+Names/server/eth0\char`\"{}. Note that \hyperlink{classns3_1_1Names_a0ed4aa6358357bef3930cd19ba306373}{Names\+::\+Rename} (\char`\"{}server/csma\char`\"{}, \char`\"{}eth0\char`\"{}) would accomplish exactly the same thing.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em oldpath} & The current path name to the object you want to change. \\
\hline
\mbox{\tt in}  & {\em newname} & The new name of the object you want to change.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Names_a5075ee36f97059d897cf6430ce61e592}{Names\+::\+Add} (std\+::string \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name}, Ptr$<$\+Object$>$ obj) 
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
{\ttfamily true} if the object was renamed successfully. 
\end{DoxyReturn}

\begin{DoxyCode}
350 \{
351   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << oldpath << newname);
352   \textcolor{comment}{//}
353   \textcolor{comment}{// This is the simple, easy to use version of Rename, so we want it to be }
354   \textcolor{comment}{// flexible.   We don't want to force a user to always type the fully }
355   \textcolor{comment}{// qualified namespace name, so we allow the namespace name to be omitted.}
356   \textcolor{comment}{// For example, calling Rename ("Client/ath0", "eth0") should result in }
357   \textcolor{comment}{// exactly the same behavior as Rename ("/Names/Client/ath0", "eth0").}
358   \textcolor{comment}{// Calling Rename ("Client", "Router") should have the same effect as }
359   \textcolor{comment}{// Rename ("Names/Client", "Router")}
360   \textcolor{comment}{//}
361   \textcolor{comment}{// The first thing to do, then, is to "canonicalize" the input string to always}
362   \textcolor{comment}{// be a fully qualified path.}
363   \textcolor{comment}{//}
364   \textcolor{comment}{// If we are given a name that begins with "/Names/" we assume that this is a}
365   \textcolor{comment}{// fully qualified path to the object we want to change.  We split the path into }
366   \textcolor{comment}{// path string (cf directory) and and a final segment (cf filename) and then call}
367   \textcolor{comment}{// the "Real" Rename.}
368   \textcolor{comment}{//}
369   std::string namespaceName = \textcolor{stringliteral}{"/Names"};
370   std::string::size\_type offset = oldpath.find (namespaceName);
371   \textcolor{keywordflow}{if} (offset != 0)
372     \{
373       \textcolor{comment}{//}
374       \textcolor{comment}{// This must be a name that has the "/Names" namespace prefix omitted.}
375       \textcolor{comment}{// Do some reasonableness checking on the rest of the name.}
376       \textcolor{comment}{//}
377       offset = oldpath.find (\textcolor{stringliteral}{"/"});
378       \textcolor{keywordflow}{if} (offset == 0)
379         \{
380           \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\textcolor{keyword}{false}, \textcolor{stringliteral}{"NamesPriv::Add(): Name begins with '/' but not \(\backslash\)"/Names\(\backslash\)""});
381           \textcolor{keywordflow}{return} \textcolor{keyword}{false};
382         \}
383 
384       oldpath = \textcolor{stringliteral}{"/Names/"} + oldpath;
385     \}
386 
387   \textcolor{comment}{//}
388   \textcolor{comment}{// There must now be a fully qualified path in the oldpath string.  All }
389   \textcolor{comment}{// fully qualified names begin with "/Names".  We have to split off the final }
390   \textcolor{comment}{// segment which will become the name we want to rename.  A '/' that}
391   \textcolor{comment}{// separates the path from the final segment (name) had better be there since}
392   \textcolor{comment}{// we just made sure that at least the namespace name was there.}
393   \textcolor{comment}{//}
394   std::string::size\_type \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = oldpath.rfind (\textcolor{stringliteral}{"/"});
395   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (i != std::string::npos, \textcolor{stringliteral}{"NamesPriv::Add(): Internal error.  Can't find '/' in
       name"});
396 
397   \textcolor{comment}{//}
398   \textcolor{comment}{// The slash we found cannot be the slash at the start of the namespaceName.}
399   \textcolor{comment}{// This would indicate there is no name in the path at all.  It can be}
400   \textcolor{comment}{// any other index.}
401   \textcolor{comment}{//}
402   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (i != 0, \textcolor{stringliteral}{"NamesPriv::Add(): Can't find a name in the path string"});
403 
404   \textcolor{comment}{//}
405   \textcolor{comment}{// We now know where the path part of the string starts and ends, and where the}
406   \textcolor{comment}{// name part starts and ends.  All we have to do is to call our available}
407   \textcolor{comment}{// function for creating adding a name under a path string.}
408   \textcolor{comment}{//}
409   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1NamesPriv_a51f6ec455739940fa02c6b46d1ea273a}{Rename} (oldpath.substr (0, i), oldpath.substr (i + 1), newname);
410 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}!Rename@{Rename}}
\index{Rename@{Rename}!ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}}
\subsubsection[{\texorpdfstring{Rename(std\+::string path, std\+::string oldname, std\+::string newname)}{Rename(std::string path, std::string oldname, std::string newname)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Names\+Priv\+::\+Rename (
\begin{DoxyParamCaption}
\item[{std\+::string}]{path, }
\item[{std\+::string}]{oldname, }
\item[{std\+::string}]{newname}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1NamesPriv_a6f0e7c4335aac3b5ed4abe0b7cc43ebc}{}\label{classns3_1_1NamesPriv_a6f0e7c4335aac3b5ed4abe0b7cc43ebc}


An intermediate form of \hyperlink{classns3_1_1Names_a0ed4aa6358357bef3930cd19ba306373}{Names\+::\+Rename} allowing you to provide a path to the parent object (under which you want this name to be changed) in the form of a name path string. 

In some cases, it is desirable to break up the path used to describe an item in the names namespace into a path and a name. This is analogous to a file system operation in which you provide a directory name and a file name.

For example, consider a situation where you have previously named an object \char`\"{}/\+Names/server/csma\char`\"{}. If you want to change the name \char`\"{}csma\char`\"{} to \char`\"{}eth0\char`\"{}, you could do this in two ways, depending on which was more convenient\+: \hyperlink{classns3_1_1Names_a0ed4aa6358357bef3930cd19ba306373}{Names\+::\+Rename} (\char`\"{}/\+Names/server/csma\char`\"{}, \char`\"{}eth0\char`\"{}) or, using the split path and name approach, \hyperlink{classns3_1_1Names_a0ed4aa6358357bef3930cd19ba306373}{Names\+::\+Rename} (\char`\"{}/\+Names/server\char`\"{}, \char`\"{}csma\char`\"{}, \char`\"{}eth0\char`\"{}).


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path} & A path name describing a previously named object under which you want this name change to occur (cf. directory). \\
\hline
\mbox{\tt in}  & {\em oldname} & The currently defined name of the object. \\
\hline
\mbox{\tt in}  & {\em newname} & The new name you want the object to have. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily true} if the object was renamed successfully. 
\end{DoxyReturn}

\begin{DoxyCode}
414 \{
415   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << path << oldname << newname);
416   \textcolor{keywordflow}{if} (path == \textcolor{stringliteral}{"/Names"})
417     \{
418       \textcolor{keywordflow}{return} \hyperlink{classns3_1_1NamesPriv_a51f6ec455739940fa02c6b46d1ea273a}{Rename} (Ptr<Object> (0, \textcolor{keyword}{false}), oldname, newname);
419     \}
420   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1NamesPriv_a51f6ec455739940fa02c6b46d1ea273a}{Rename} (\hyperlink{classns3_1_1NamesPriv_aeb1553e055f77ec72919f4ed41e4aec2}{Find} (path), oldname, newname);
421 \}
\end{DoxyCode}
\index{ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}!Rename@{Rename}}
\index{Rename@{Rename}!ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}}
\subsubsection[{\texorpdfstring{Rename(\+Ptr$<$ Object $>$ context, std\+::string oldname, std\+::string newname)}{Rename(Ptr< Object > context, std::string oldname, std::string newname)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Names\+Priv\+::\+Rename (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Object} $>$}]{context, }
\item[{std\+::string}]{oldname, }
\item[{std\+::string}]{newname}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1NamesPriv_aa8e3600d5c9144e472ddf263040e2f6b}{}\label{classns3_1_1NamesPriv_aa8e3600d5c9144e472ddf263040e2f6b}


A low-\/level form of \hyperlink{classns3_1_1Names_a0ed4aa6358357bef3930cd19ba306373}{Names\+::\+Rename} allowing you to specify the path to the parent object (under which you want this name to be changed) in the form of a previously named object. 

In some use cases, it is desirable to break up the path in the names name space into a path and a name. This is analogous to a file system operation in which you provide a directory name and a file name. Recall that the path string actually refers to a previously named object, \char`\"{}under\char`\"{} which you want to accomplish some naming action.

However, the path is sometimes not available, and you only have the object that is represented by the path in the names name space. To support this use-\/case in a reasonably high-\/performance way, the path string is can be replaced by the object pointer to which that path would refer. In the spirit of the \hyperlink{namespacens3_1_1Config}{Config} code where this use-\/case is most prominent, we refer to this object as the \char`\"{}context\char`\"{} for the names operation.

You can think of the context roughly as the inode number of a directory file in Unix. The inode number can be used to look up the directory file which contains the list of file names defined at that directory level. Similarly the context is used to look up an internal name service entry which contains the names defined for that context.

For example, consider a situation where you have previously named an object \char`\"{}/\+Names/server/csma\char`\"{}. If you later decide to rename the csma object to say \char`\"{}eth0\char`\"{} -- you could do this by providing a complete path as in \hyperlink{classns3_1_1Names_a0ed4aa6358357bef3930cd19ba306373}{Names\+::\+Rename} (\char`\"{}/\+Names/server/csma\char`\"{}, \char`\"{}eth0\char`\"{}). If, however, somewhere in your code you only had a pointer to the server, and not a handy path string, say \hyperlink{classns3_1_1Ptr}{Ptr$<$\+Node$>$} node, you could also accomplish this by \hyperlink{classns3_1_1Names_a0ed4aa6358357bef3930cd19ba306373}{Names\+::\+Rename} (node, \char`\"{}csma\char`\"{}, \char`\"{}eth0\char`\"{}).


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em context} & A smart pointer to an object that is used in place of the path under which you want this new name to be defined. \\
\hline
\mbox{\tt in}  & {\em oldname} & The current shortname of the object you want to change. \\
\hline
\mbox{\tt in}  & {\em newname} & The new shortname of the object you want to change. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily true} if the object was renamed successfully. 
\end{DoxyReturn}

\begin{DoxyCode}
425 \{
426   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << context << oldname << newname);
427 
428   NameNode *node = 0;
429   \textcolor{keywordflow}{if} (context)
430     \{
431       node = \hyperlink{classns3_1_1NamesPriv_a9867bf67ff8f138d1dd4d175e1fb0fde}{IsNamed} (context);
432       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (node, \textcolor{stringliteral}{"NamesPriv::Name(): context must point to a previously named node"})
      ;
433     \}
434   \textcolor{keywordflow}{else}
435     \{
436       node = &\hyperlink{classns3_1_1NamesPriv_a24851b2ca8230416228472b2e4e1b587}{m\_root};
437     \}
438 
439   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1NamesPriv_a2596edf33333e7745eb47a620783c004}{IsDuplicateName} (node, newname))
440     \{
441       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"New name is already taken"});
442       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
443     \}
444 
445   std::map<std::string, NameNode *>::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = node->m\_nameMap.find (oldname);
446   \textcolor{keywordflow}{if} (i == node->m\_nameMap.end ())
447     \{
448       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Old name does not exist in name map"});
449       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
450     \}
451   \textcolor{keywordflow}{else}
452     \{
453       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Old name exists in name map"});
454 
455       \textcolor{comment}{//}
456       \textcolor{comment}{// The rename process consists of:}
457       \textcolor{comment}{// 1.  Geting the pointer to the name node from the map and remembering it;}
458       \textcolor{comment}{// 2.  Removing the map entry corresponding to oldname from the map;}
459       \textcolor{comment}{// 3.  Changing the name string in the name node;}
460       \textcolor{comment}{// 4.  Adding the name node back in the map under the newname.}
461       \textcolor{comment}{//}
462       NameNode *changeNode = i->second;
463       node->m\_nameMap.erase (i);
464       changeNode->m\_name = newname;
465       node->m\_nameMap[newname] = changeNode;
466       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
467     \}
468 \}
\end{DoxyCode}


\subsection{Friends And Related Function Documentation}
\index{ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}!Names@{Names}}
\index{Names@{Names}!ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}}
\subsubsection[{\texorpdfstring{Names}{Names}}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf Names}\hspace{0.3cm}{\ttfamily [friend]}}\hypertarget{classns3_1_1NamesPriv_a8e6dace6fb74ee2b530528e4ecd0f22c}{}\label{classns3_1_1NamesPriv_a8e6dace6fb74ee2b530528e4ecd0f22c}


\subsection{Member Data Documentation}
\index{ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}!m\+\_\+object\+Map@{m\+\_\+object\+Map}}
\index{m\+\_\+object\+Map@{m\+\_\+object\+Map}!ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}}
\subsubsection[{\texorpdfstring{m\+\_\+object\+Map}{m_objectMap}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<${\bf Ptr}$<${\bf Object}$>$, {\bf Name\+Node} $\ast$$>$ ns3\+::\+Names\+Priv\+::m\+\_\+object\+Map\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1NamesPriv_a19b615be3c0c142fe0ec7539db8598cf}{}\label{classns3_1_1NamesPriv_a19b615be3c0c142fe0ec7539db8598cf}
Map from object pointers to their Name\+Nodes. \index{ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}!m\+\_\+root@{m\+\_\+root}}
\index{m\+\_\+root@{m\+\_\+root}!ns3\+::\+Names\+Priv@{ns3\+::\+Names\+Priv}}
\subsubsection[{\texorpdfstring{m\+\_\+root}{m_root}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Name\+Node} ns3\+::\+Names\+Priv\+::m\+\_\+root\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1NamesPriv_a24851b2ca8230416228472b2e4e1b587}{}\label{classns3_1_1NamesPriv_a24851b2ca8230416228472b2e4e1b587}
The root \hyperlink{classns3_1_1NameNode}{Name\+Node}. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
core/model/\hyperlink{names_8cc}{names.\+cc}\end{DoxyCompactItemize}
