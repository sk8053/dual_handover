\hypertarget{classns3_1_1Ipv6InterfaceContainer}{}\section{ns3\+:\+:Ipv6\+Interface\+Container Class Reference}
\label{classns3_1_1Ipv6InterfaceContainer}\index{ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}}


Keep track of a set of I\+Pv6 interfaces.  




{\ttfamily \#include $<$ipv6-\/interface-\/container.\+h$>$}



Collaboration diagram for ns3\+:\+:Ipv6\+Interface\+Container\+:
% FIG 0
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef std\+::vector$<$ std\+::pair$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6}{Ipv6} $>$, uint32\+\_\+t $>$ $>$\+::const\+\_\+iterator \hyperlink{classns3_1_1Ipv6InterfaceContainer_ad0dd912971eb260ce6a22cab34e809c0}{Iterator}
\begin{DoxyCompactList}\small\item\em Container Const Iterator for pairs of \hyperlink{classns3_1_1Ipv6}{Ipv6} smart pointer / Interface Index. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ipv6InterfaceContainer_a2e941841c63656f442cbe1cc2bdf6861}{Ipv6\+Interface\+Container} ()
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1Ipv6InterfaceContainer_a47ccf3f11e14bc7d5d6262261e31d15e}{GetN} (void) const 
\item 
uint32\+\_\+t \hyperlink{classns3_1_1Ipv6InterfaceContainer_a6d786a88b25dce189628ef09a66691f2}{Get\+Interface\+Index} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) const 
\begin{DoxyCompactList}\small\item\em Get the interface index for the specified node index. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} \hyperlink{classns3_1_1Ipv6InterfaceContainer_ac888a9b8e70b501e44fdb12e4adc7d79}{Get\+Address} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, uint32\+\_\+t j) const 
\begin{DoxyCompactList}\small\item\em Get the address for the specified index. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} \hyperlink{classns3_1_1Ipv6InterfaceContainer_abc3ff3c728f42053c381d74ce4e103c3}{Get\+Link\+Local\+Address} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
\begin{DoxyCompactList}\small\item\em Get the link-\/local address for the specified index. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} \hyperlink{classns3_1_1Ipv6InterfaceContainer_a80e63120102caaf616e953449c1e069c}{Get\+Link\+Local\+Address} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} address)
\begin{DoxyCompactList}\small\item\em Get the link-\/local address for the node with the specified global address. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6InterfaceContainer_ad9df7e1d407117aac8be4cea4deebb9b}{Add} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6}{Ipv6} $>$ ipv6, uint32\+\_\+t interface)
\begin{DoxyCompactList}\small\item\em Add a couple I\+Pv6/interface. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6InterfaceContainer_ad0dd912971eb260ce6a22cab34e809c0}{Iterator} \hyperlink{classns3_1_1Ipv6InterfaceContainer_a7cf8975399dfdb4cfb6df73a9209b882}{Begin} (void) const 
\begin{DoxyCompactList}\small\item\em Get an iterator which refers to the first pair in the container. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6InterfaceContainer_ad0dd912971eb260ce6a22cab34e809c0}{Iterator} \hyperlink{classns3_1_1Ipv6InterfaceContainer_af11b0ab74357a5edb40cee18aa7ed378}{End} (void) const 
\begin{DoxyCompactList}\small\item\em Get an iterator which indicates past-\/the-\/last \hyperlink{classns3_1_1Node}{Node} in the container. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6InterfaceContainer_a37305e7fb93869481d538f8f23392d33}{Add} (const \hyperlink{classns3_1_1Ipv6InterfaceContainer}{Ipv6\+Interface\+Container} \&\hyperlink{mmwave_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c})
\begin{DoxyCompactList}\small\item\em Fusion with another \hyperlink{classns3_1_1Ipv6InterfaceContainer}{Ipv6\+Interface\+Container}. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6InterfaceContainer_a6338f403aaf73f51d30833374883f5ca}{Add} (std\+::string ipv6\+Name, uint32\+\_\+t interface)
\begin{DoxyCompactList}\small\item\em Add a couple of name/interface. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6InterfaceContainer_a080aad6f43a52c6478053b237e5e6979}{Set\+Forwarding} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, bool state)
\begin{DoxyCompactList}\small\item\em Set the state of the stack (act as a router or as an host) for the specified index. This automatically sets all the node\textquotesingle{}s interfaces to the same forwarding state. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6InterfaceContainer_a3fb0cfdcb3780bc624b10a04e58ffbd0}{Set\+Default\+Route\+In\+All\+Nodes} (uint32\+\_\+t router)
\begin{DoxyCompactList}\small\item\em Set the default route for all the devices (except the router itself). \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6InterfaceContainer_a937b4894788e779b458f58ba3cd97409}{Set\+Default\+Route\+In\+All\+Nodes} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} router\+Addr)
\begin{DoxyCompactList}\small\item\em Set the default route for all the devices (except the router itself). Note that the route will be set to the link-\/local address of the node with the specified address. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6InterfaceContainer_a51c8dcf0566530d9e30788fd7ac6486c}{Set\+Default\+Route} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, uint32\+\_\+t router)
\begin{DoxyCompactList}\small\item\em Set the default route for the specified index. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6InterfaceContainer_a4e9c1b6b4191b318c1a64f7b3a7ef7f6}{Set\+Default\+Route} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} router\+Addr)
\begin{DoxyCompactList}\small\item\em Set the default route for the specified index. Note that the route will be set to the link-\/local address of the node with the specified address. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
typedef std\+::vector$<$ std\+::pair$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6}{Ipv6} $>$, uint32\+\_\+t $>$ $>$ \hyperlink{classns3_1_1Ipv6InterfaceContainer_a62c74212c187a719bf1038d30c87d4d5}{Interface\+Vector}
\begin{DoxyCompactList}\small\item\em Container for pairs of \hyperlink{classns3_1_1Ipv6}{Ipv6} smart pointer / Interface Index. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ipv6InterfaceContainer_a62c74212c187a719bf1038d30c87d4d5}{Interface\+Vector} \hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\+\_\+interfaces}
\begin{DoxyCompactList}\small\item\em List of I\+Pv6 stack and interfaces index. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Keep track of a set of I\+Pv6 interfaces. 

\subsection{Member Typedef Documentation}
\index{ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}!Interface\+Vector@{Interface\+Vector}}
\index{Interface\+Vector@{Interface\+Vector}!ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}}
\subsubsection[{\texorpdfstring{Interface\+Vector}{InterfaceVector}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::vector$<$std\+::pair$<${\bf Ptr}$<${\bf Ipv6}$>$, uint32\+\_\+t$>$ $>$ {\bf ns3\+::\+Ipv6\+Interface\+Container\+::\+Interface\+Vector}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6InterfaceContainer_a62c74212c187a719bf1038d30c87d4d5}{}\label{classns3_1_1Ipv6InterfaceContainer_a62c74212c187a719bf1038d30c87d4d5}


Container for pairs of \hyperlink{classns3_1_1Ipv6}{Ipv6} smart pointer / Interface Index. 

\index{ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}!Iterator@{Iterator}}
\index{Iterator@{Iterator}!ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}}
\subsubsection[{\texorpdfstring{Iterator}{Iterator}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::vector$<$std\+::pair$<${\bf Ptr}$<${\bf Ipv6}$>$, uint32\+\_\+t$>$ $>$\+::const\+\_\+iterator {\bf ns3\+::\+Ipv6\+Interface\+Container\+::\+Iterator}}\hypertarget{classns3_1_1Ipv6InterfaceContainer_ad0dd912971eb260ce6a22cab34e809c0}{}\label{classns3_1_1Ipv6InterfaceContainer_ad0dd912971eb260ce6a22cab34e809c0}


Container Const Iterator for pairs of \hyperlink{classns3_1_1Ipv6}{Ipv6} smart pointer / Interface Index. 



\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}!Ipv6\+Interface\+Container@{Ipv6\+Interface\+Container}}
\index{Ipv6\+Interface\+Container@{Ipv6\+Interface\+Container}!ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}}
\subsubsection[{\texorpdfstring{Ipv6\+Interface\+Container()}{Ipv6InterfaceContainer()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv6\+Interface\+Container\+::\+Ipv6\+Interface\+Container (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6InterfaceContainer_a2e941841c63656f442cbe1cc2bdf6861}{}\label{classns3_1_1Ipv6InterfaceContainer_a2e941841c63656f442cbe1cc2bdf6861}


Constructor. 


\begin{DoxyCode}
32 \{
33 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}!Add@{Add}}
\index{Add@{Add}!ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}}
\subsubsection[{\texorpdfstring{Add(\+Ptr$<$ Ipv6 $>$ ipv6, uint32\+\_\+t interface)}{Add(Ptr< Ipv6 > ipv6, uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Interface\+Container\+::\+Add (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv6} $>$}]{ipv6, }
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6InterfaceContainer_ad9df7e1d407117aac8be4cea4deebb9b}{}\label{classns3_1_1Ipv6InterfaceContainer_ad9df7e1d407117aac8be4cea4deebb9b}


Add a couple I\+Pv6/interface. 


\begin{DoxyParams}{Parameters}
{\em ipv6} & I\+Pv6 address \\
\hline
{\em interface} & interface index \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
65 \{
66   \hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}.push\_back (std::make\_pair (ipv6, interface));
67 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 1


\index{ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}!Add@{Add}}
\index{Add@{Add}!ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}}
\subsubsection[{\texorpdfstring{Add(const Ipv6\+Interface\+Container \&c)}{Add(const Ipv6InterfaceContainer &c)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Interface\+Container\+::\+Add (
\begin{DoxyParamCaption}
\item[{const {\bf Ipv6\+Interface\+Container} \&}]{c}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6InterfaceContainer_a37305e7fb93869481d538f8f23392d33}{}\label{classns3_1_1Ipv6InterfaceContainer_a37305e7fb93869481d538f8f23392d33}


Fusion with another \hyperlink{classns3_1_1Ipv6InterfaceContainer}{Ipv6\+Interface\+Container}. 


\begin{DoxyParams}{Parameters}
{\em c} & container \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
76 \{
77   \textcolor{keywordflow}{for} (InterfaceVector::const\_iterator it = \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c}.m\_interfaces.begin (); it != \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c}.m\_interfaces.end (); it++)
78     \{
79       \hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}.push\_back (*it);
80     \}
81 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}!Add@{Add}}
\index{Add@{Add}!ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}}
\subsubsection[{\texorpdfstring{Add(std\+::string ipv6\+Name, uint32\+\_\+t interface)}{Add(std::string ipv6Name, uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Interface\+Container\+::\+Add (
\begin{DoxyParamCaption}
\item[{std\+::string}]{ipv6\+Name, }
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6InterfaceContainer_a6338f403aaf73f51d30833374883f5ca}{}\label{classns3_1_1Ipv6InterfaceContainer_a6338f403aaf73f51d30833374883f5ca}


Add a couple of name/interface. 


\begin{DoxyParams}{Parameters}
{\em ipv6\+Name} & name of a node \\
\hline
{\em interface} & interface index to add \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
70 \{
71   Ptr<Ipv6> ipv6 = Names::Find<Ipv6> (ipv6Name);
72   \hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}.push\_back (std::make\_pair (ipv6, interface));
73 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}!Begin@{Begin}}
\index{Begin@{Begin}!ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}}
\subsubsection[{\texorpdfstring{Begin(void) const }{Begin(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+Interface\+Container\+::\+Iterator} ns3\+::\+Ipv6\+Interface\+Container\+::\+Begin (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv6InterfaceContainer_a7cf8975399dfdb4cfb6df73a9209b882}{}\label{classns3_1_1Ipv6InterfaceContainer_a7cf8975399dfdb4cfb6df73a9209b882}


Get an iterator which refers to the first pair in the container. 

Pairs can be retrieved from the container in two ways. First, directly by an index into the container, and second, using an iterator. This method is used in the iterator method and is typically used in a for-\/loop to run through the pairs


\begin{DoxyCode}
\hyperlink{classns3_1_1Ipv4InterfaceContainer_acedc286abfd3db405dfca5ddd73fd1d7}{Ipv4InterfaceContainer::Iterator} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
\textcolor{keywordflow}{for} (i = container.Begin (); i != container.End (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
  \{
    std::pair<Ptr<Ipv6>, uint32\_t> pair = *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
    method (pair.first, pair.second);  \textcolor{comment}{// use the pair}
  \}
\end{DoxyCode}


\begin{DoxyReturn}{Returns}
an iterator which refers to the first pair in the container. 
\end{DoxyReturn}

\begin{DoxyCode}
37 \{
38   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}.begin ();
39 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 2


\index{ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}!End@{End}}
\index{End@{End}!ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}}
\subsubsection[{\texorpdfstring{End(void) const }{End(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+Interface\+Container\+::\+Iterator} ns3\+::\+Ipv6\+Interface\+Container\+::\+End (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv6InterfaceContainer_af11b0ab74357a5edb40cee18aa7ed378}{}\label{classns3_1_1Ipv6InterfaceContainer_af11b0ab74357a5edb40cee18aa7ed378}


Get an iterator which indicates past-\/the-\/last \hyperlink{classns3_1_1Node}{Node} in the container. 

Nodes can be retrieved from the container in two ways. First, directly by an index into the container, and second, using an iterator. This method is used in the iterator method and is typically used in a for-\/loop to run through the Nodes


\begin{DoxyCode}
\hyperlink{classns3_1_1NodeContainer_aa1a9f2d2b09bfef7d066d3974bca2cc4}{NodeContainer::Iterator} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
\textcolor{keywordflow}{for} (i = container.Begin (); i != container.End (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
  \{
    std::pair<Ptr<Ipv6>, uint32\_t> pair = *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
    method (pair.first, pair.second);  \textcolor{comment}{// use the pair}
  \}
\end{DoxyCode}


\begin{DoxyReturn}{Returns}
an iterator which indicates an ending condition for a loop. 
\end{DoxyReturn}

\begin{DoxyCode}
43 \{
44   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}.end ();
45 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 3


\index{ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}!Get\+Address@{Get\+Address}}
\index{Get\+Address@{Get\+Address}!ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}}
\subsubsection[{\texorpdfstring{Get\+Address(uint32\+\_\+t i, uint32\+\_\+t j) const }{GetAddress(uint32_t i, uint32_t j) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+Address} ns3\+::\+Ipv6\+Interface\+Container\+::\+Get\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i, }
\item[{uint32\+\_\+t}]{j}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv6InterfaceContainer_ac888a9b8e70b501e44fdb12e4adc7d79}{}\label{classns3_1_1Ipv6InterfaceContainer_ac888a9b8e70b501e44fdb12e4adc7d79}


Get the address for the specified index. 


\begin{DoxyParams}{Parameters}
{\em i} & interface index \\
\hline
{\em j} & address index, generally index 0 is the link-\/local address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
I\+Pv6 address 
\end{DoxyReturn}

\begin{DoxyCode}
58 \{
59   Ptr<Ipv6> ipv6 = \hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}[\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}].first;
60   uint32\_t \textcolor{keyword}{interface }= \hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}[\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}].second;
61   \textcolor{keywordflow}{return} ipv6->GetAddress (interface, j).GetAddress ();
62 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}!Get\+Interface\+Index@{Get\+Interface\+Index}}
\index{Get\+Interface\+Index@{Get\+Interface\+Index}!ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}}
\subsubsection[{\texorpdfstring{Get\+Interface\+Index(uint32\+\_\+t i) const }{GetInterfaceIndex(uint32_t i) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Ipv6\+Interface\+Container\+::\+Get\+Interface\+Index (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv6InterfaceContainer_a6d786a88b25dce189628ef09a66691f2}{}\label{classns3_1_1Ipv6InterfaceContainer_a6d786a88b25dce189628ef09a66691f2}


Get the interface index for the specified node index. 


\begin{DoxyParams}{Parameters}
{\em i} & index of the node \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
interface index 
\end{DoxyReturn}

\begin{DoxyCode}
53 \{
54   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}[\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}].second;
55 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}!Get\+Link\+Local\+Address@{Get\+Link\+Local\+Address}}
\index{Get\+Link\+Local\+Address@{Get\+Link\+Local\+Address}!ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}}
\subsubsection[{\texorpdfstring{Get\+Link\+Local\+Address(uint32\+\_\+t i)}{GetLinkLocalAddress(uint32_t i)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+Address} ns3\+::\+Ipv6\+Interface\+Container\+::\+Get\+Link\+Local\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6InterfaceContainer_abc3ff3c728f42053c381d74ce4e103c3}{}\label{classns3_1_1Ipv6InterfaceContainer_abc3ff3c728f42053c381d74ce4e103c3}


Get the link-\/local address for the specified index. 


\begin{DoxyParams}{Parameters}
{\em i} & index \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the link-\/local address, or \char`\"{}\+::\char`\"{} if the interface has no link local address. 
\end{DoxyReturn}

\begin{DoxyCode}
208 \{
209   Ptr<Ipv6> ipv6 = \hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}[index].first;
210   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < ipv6->GetNAddresses (\hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}[index].second); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
211     \{
212       Ipv6InterfaceAddress iAddress;
213       iAddress = ipv6->GetAddress (\hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}[index].second, \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
214       \textcolor{keywordflow}{if} (iAddress.GetScope () == \hyperlink{classns3_1_1Ipv6InterfaceAddress_ad3f03debf9dae475b81ea9cdf81f4f27a29f5cd6ebe813216f28d906d89d4c56d}{Ipv6InterfaceAddress::LINKLOCAL})
215         \{
216           \textcolor{keywordflow}{return} iAddress.GetAddress ();
217         \}
218     \}
219   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} ();
220 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5




Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}!Get\+Link\+Local\+Address@{Get\+Link\+Local\+Address}}
\index{Get\+Link\+Local\+Address@{Get\+Link\+Local\+Address}!ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}}
\subsubsection[{\texorpdfstring{Get\+Link\+Local\+Address(\+Ipv6\+Address address)}{GetLinkLocalAddress(Ipv6Address address)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+Address} ns3\+::\+Ipv6\+Interface\+Container\+::\+Get\+Link\+Local\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{address}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6InterfaceContainer_a80e63120102caaf616e953449c1e069c}{}\label{classns3_1_1Ipv6InterfaceContainer_a80e63120102caaf616e953449c1e069c}


Get the link-\/local address for the node with the specified global address. 


\begin{DoxyParams}{Parameters}
{\em address} & the address to find. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the link-\/local address, or \char`\"{}\+::\char`\"{} if the interface has no link local address. 
\end{DoxyReturn}

\begin{DoxyCode}
223 \{
224   \textcolor{keywordflow}{if} (address.IsLinkLocal ())
225     \{
226       \textcolor{keywordflow}{return} address;
227     \}
228 
229   uint32\_t nodeIndex = 0;
230   \textcolor{keywordtype}{bool} found = \textcolor{keyword}{false};
231   \textcolor{keywordflow}{for} (uint32\_t index = 0; index < \hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}.size (); index++)
232     \{
233       Ptr<Ipv6> ipv6 = \hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}[index].first;
234       \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < ipv6->GetNAddresses (\hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}[index].second); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
235         \{
236           Ipv6Address addr = ipv6->GetAddress (\hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}[index].second, 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}).GetAddress ();
237           \textcolor{keywordflow}{if} (addr == address)
238             \{
239               nodeIndex = index;
240               found = \textcolor{keyword}{true};
241               \textcolor{keywordflow}{break};
242             \}
243         \}
244       \textcolor{keywordflow}{if} (found)
245         \{
246           \textcolor{keywordflow}{break};
247         \}
248     \}
249   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (found != \textcolor{keyword}{true}, \textcolor{stringliteral}{"No such address in the interfaces. Aborting."});
250 
251   Ptr<Ipv6> ipv6 = \hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}[nodeIndex].first;
252   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < ipv6->GetNAddresses (\hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}[nodeIndex].second); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
253     \{
254       Ipv6InterfaceAddress iAddress;
255       iAddress = ipv6->GetAddress (\hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}[nodeIndex].second, \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
256       \textcolor{keywordflow}{if} (iAddress.GetScope () == \hyperlink{classns3_1_1Ipv6InterfaceAddress_ad3f03debf9dae475b81ea9cdf81f4f27a29f5cd6ebe813216f28d906d89d4c56d}{Ipv6InterfaceAddress::LINKLOCAL})
257         \{
258           \textcolor{keywordflow}{return} iAddress.GetAddress ();
259         \}
260     \}
261   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} ();
262 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7


\index{ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}!GetN@{GetN}}
\index{GetN@{GetN}!ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}}
\subsubsection[{\texorpdfstring{Get\+N(void) const }{GetN(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Ipv6\+Interface\+Container\+::\+GetN (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv6InterfaceContainer_a47ccf3f11e14bc7d5d6262261e31d15e}{}\label{classns3_1_1Ipv6InterfaceContainer_a47ccf3f11e14bc7d5d6262261e31d15e}
\begin{DoxyReturn}{Returns}
the number of Ptr$<$\+Ipv6$>$ and interface pairs stored in this \hyperlink{classns3_1_1Ipv4InterfaceContainer}{Ipv4\+Interface\+Container}.
\end{DoxyReturn}
Pairs can be retrieved from the container in two ways. First, directly by an index into the container, and second, using an iterator. This method is used in the direct method and is typically used to define an ending condition in a for-\/loop that runs through the stored Nodes


\begin{DoxyCode}
uint32\_t nNodes = container.GetN ();
\textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0 \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < nNodes; ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
  \{
    std::pair<Ptr<Ipv6>, uint32\_t> pair = container.Get (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
    method (pair.first, pair.second);  \textcolor{comment}{// use the pair}
  \}
\end{DoxyCode}
 
\begin{DoxyCode}
48 \{
49   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}.size ();
50 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}!Set\+Default\+Route@{Set\+Default\+Route}}
\index{Set\+Default\+Route@{Set\+Default\+Route}!ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}}
\subsubsection[{\texorpdfstring{Set\+Default\+Route(uint32\+\_\+t i, uint32\+\_\+t router)}{SetDefaultRoute(uint32_t i, uint32_t router)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Interface\+Container\+::\+Set\+Default\+Route (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i, }
\item[{uint32\+\_\+t}]{router}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6InterfaceContainer_a51c8dcf0566530d9e30788fd7ac6486c}{}\label{classns3_1_1Ipv6InterfaceContainer_a51c8dcf0566530d9e30788fd7ac6486c}


Set the default route for the specified index. 


\begin{DoxyParams}{Parameters}
{\em i} & index \\
\hline
{\em router} & the default router \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
153 \{
154   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != router, \textcolor{stringliteral}{"A node shouldn't set itself as the default router, isn't it?
       Aborting."});
155 
156   Ptr<Ipv6> ipv6 = \hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}[\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}].first;
157 
158   Ipv6Address routerAddress = \hyperlink{classns3_1_1Ipv6InterfaceContainer_abc3ff3c728f42053c381d74ce4e103c3}{GetLinkLocalAddress} (router);
159   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (routerAddress != \hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} (), \textcolor{stringliteral}{"No link-local
       address found on router, aborting"});
160 
161   Ptr<Ipv6StaticRouting> routing = 0;
162   Ipv6StaticRoutingHelper routingHelper;
163 
164   routing = routingHelper.GetStaticRouting (ipv6);
165   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (routing != 0, \textcolor{stringliteral}{"Default router setup failed because no Ipv6StaticRouting was
       found on the node."});
166   routing->SetDefaultRoute (routerAddress, \hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}[\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}].second);
167 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8


\index{ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}!Set\+Default\+Route@{Set\+Default\+Route}}
\index{Set\+Default\+Route@{Set\+Default\+Route}!ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}}
\subsubsection[{\texorpdfstring{Set\+Default\+Route(uint32\+\_\+t i, Ipv6\+Address router\+Addr)}{SetDefaultRoute(uint32_t i, Ipv6Address routerAddr)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Interface\+Container\+::\+Set\+Default\+Route (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i, }
\item[{{\bf Ipv6\+Address}}]{router\+Addr}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6InterfaceContainer_a4e9c1b6b4191b318c1a64f7b3a7ef7f6}{}\label{classns3_1_1Ipv6InterfaceContainer_a4e9c1b6b4191b318c1a64f7b3a7ef7f6}


Set the default route for the specified index. Note that the route will be set to the link-\/local address of the node with the specified address. 


\begin{DoxyParams}{Parameters}
{\em i} & index \\
\hline
{\em router\+Addr} & the default router address \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
171 \{
172   uint32\_t routerIndex = 0;
173   \textcolor{keywordtype}{bool} found = \textcolor{keyword}{false};
174   \textcolor{keywordflow}{for} (uint32\_t index = 0; index < \hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}.size (); index++)
175     \{
176       Ptr<Ipv6> ipv6 = \hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}[index].first;
177       \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < ipv6->GetNAddresses (\hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}[index].second); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
178         \{
179           Ipv6Address addr = ipv6->GetAddress (\hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}[index].second, 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}).GetAddress ();
180           \textcolor{keywordflow}{if} (addr == routerAddr)
181             \{
182               routerIndex = index;
183               found = \textcolor{keyword}{true};
184               \textcolor{keywordflow}{break};
185             \}
186         \}
187       \textcolor{keywordflow}{if} (found)
188         \{
189           \textcolor{keywordflow}{break};
190         \}
191     \}
192   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (found != \textcolor{keyword}{true}, \textcolor{stringliteral}{"No such address in the interfaces. Aborting."});
193 
194   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != routerIndex, \textcolor{stringliteral}{"A node shouldn't set itself as the default router, isn't
       it? Aborting."});
195 
196   Ptr<Ipv6> ipv6 = \hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}[\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}].first;
197   Ipv6Address routerLinkLocalAddress = \hyperlink{classns3_1_1Ipv6InterfaceContainer_abc3ff3c728f42053c381d74ce4e103c3}{GetLinkLocalAddress} (routerIndex);
198   Ptr<Ipv6StaticRouting> routing = 0;
199   Ipv6StaticRoutingHelper routingHelper;
200 
201   routing = routingHelper.GetStaticRouting (ipv6);
202   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (routing != 0, \textcolor{stringliteral}{"Default router setup failed because no Ipv6StaticRouting was
       found on the node."});
203   routing->SetDefaultRoute (routerLinkLocalAddress, \hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}[\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}].second);
204 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9


\index{ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}!Set\+Default\+Route\+In\+All\+Nodes@{Set\+Default\+Route\+In\+All\+Nodes}}
\index{Set\+Default\+Route\+In\+All\+Nodes@{Set\+Default\+Route\+In\+All\+Nodes}!ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}}
\subsubsection[{\texorpdfstring{Set\+Default\+Route\+In\+All\+Nodes(uint32\+\_\+t router)}{SetDefaultRouteInAllNodes(uint32_t router)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Interface\+Container\+::\+Set\+Default\+Route\+In\+All\+Nodes (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{router}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6InterfaceContainer_a3fb0cfdcb3780bc624b10a04e58ffbd0}{}\label{classns3_1_1Ipv6InterfaceContainer_a3fb0cfdcb3780bc624b10a04e58ffbd0}


Set the default route for all the devices (except the router itself). 


\begin{DoxyParams}{Parameters}
{\em router} & the default router index \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
90 \{
91   Ptr<Ipv6> ipv6 = \hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}[router].first;
92   uint32\_t other;
93 
94   Ipv6Address routerAddress = \hyperlink{classns3_1_1Ipv6InterfaceContainer_abc3ff3c728f42053c381d74ce4e103c3}{GetLinkLocalAddress} (router);
95   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (routerAddress != \hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} (), \textcolor{stringliteral}{"No link-local
       address found on router, aborting"});
96 
97   \textcolor{keywordflow}{for} (other = 0; other < \hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}.size (); other++)
98     \{
99       \textcolor{keywordflow}{if} (other != router)
100         \{
101           Ptr<Ipv6StaticRouting> routing = 0;
102           Ipv6StaticRoutingHelper routingHelper;
103 
104           ipv6 = \hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}[other].first;
105           routing = routingHelper.GetStaticRouting (ipv6);
106           \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (routing != 0, \textcolor{stringliteral}{"Default router setup failed because no
       Ipv6StaticRouting was found on the node."});
107           routing->SetDefaultRoute (routerAddress, \hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}[other].second);
108         \}
109     \}
110 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10




Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}!Set\+Default\+Route\+In\+All\+Nodes@{Set\+Default\+Route\+In\+All\+Nodes}}
\index{Set\+Default\+Route\+In\+All\+Nodes@{Set\+Default\+Route\+In\+All\+Nodes}!ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}}
\subsubsection[{\texorpdfstring{Set\+Default\+Route\+In\+All\+Nodes(\+Ipv6\+Address router\+Addr)}{SetDefaultRouteInAllNodes(Ipv6Address routerAddr)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Interface\+Container\+::\+Set\+Default\+Route\+In\+All\+Nodes (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{router\+Addr}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6InterfaceContainer_a937b4894788e779b458f58ba3cd97409}{}\label{classns3_1_1Ipv6InterfaceContainer_a937b4894788e779b458f58ba3cd97409}


Set the default route for all the devices (except the router itself). Note that the route will be set to the link-\/local address of the node with the specified address. 


\begin{DoxyParams}{Parameters}
{\em router\+Addr} & the default router address \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
113 \{
114   uint32\_t routerIndex = 0;
115   \textcolor{keywordtype}{bool} found = \textcolor{keyword}{false};
116   \textcolor{keywordflow}{for} (uint32\_t index = 0; index < \hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}.size (); index++)
117     \{
118       Ptr<Ipv6> ipv6 = \hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}[index].first;
119       \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < ipv6->GetNAddresses (\hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}[index].second); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
120         \{
121           Ipv6Address addr = ipv6->GetAddress (\hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}[index].second, 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}).GetAddress ();
122           \textcolor{keywordflow}{if} (addr == routerAddress)
123             \{
124               routerIndex = index;
125               found = \textcolor{keyword}{true};
126               \textcolor{keywordflow}{break};
127             \}
128         \}
129       \textcolor{keywordflow}{if} (found)
130         \{
131           \textcolor{keywordflow}{break};
132         \}
133     \}
134   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (found != \textcolor{keyword}{true}, \textcolor{stringliteral}{"No such address in the interfaces. Aborting."});
135 
136   \textcolor{keywordflow}{for} (uint32\_t other = 0; other < \hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}.size (); other++)
137     \{
138       \textcolor{keywordflow}{if} (other != routerIndex)
139         \{
140           Ptr<Ipv6StaticRouting> routing = 0;
141           Ipv6StaticRoutingHelper routingHelper;
142 
143           Ptr<Ipv6> ipv6 = \hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}[other].first;
144           routing = routingHelper.GetStaticRouting (ipv6);
145           \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (routing != 0, \textcolor{stringliteral}{"Default router setup failed because no
       Ipv6StaticRouting was found on the node."});
146           routing->SetDefaultRoute (routerAddress, \hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}[other].second);
147         \}
148     \}
149 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12


\index{ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}!Set\+Forwarding@{Set\+Forwarding}}
\index{Set\+Forwarding@{Set\+Forwarding}!ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}}
\subsubsection[{\texorpdfstring{Set\+Forwarding(uint32\+\_\+t i, bool state)}{SetForwarding(uint32_t i, bool state)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Interface\+Container\+::\+Set\+Forwarding (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i, }
\item[{bool}]{state}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6InterfaceContainer_a080aad6f43a52c6478053b237e5e6979}{}\label{classns3_1_1Ipv6InterfaceContainer_a080aad6f43a52c6478053b237e5e6979}


Set the state of the stack (act as a router or as an host) for the specified index. This automatically sets all the node\textquotesingle{}s interfaces to the same forwarding state. 


\begin{DoxyParams}{Parameters}
{\em i} & index \\
\hline
{\em state} & true \+: is a router, false \+: is an host \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
84 \{
85   Ptr<Ipv6> ipv6 = \hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}[\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}].first;
86   ipv6->SetForwarding (\hyperlink{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{m\_interfaces}[\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}].second, router);
87 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 13




\subsection{Member Data Documentation}
\index{ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}!m\+\_\+interfaces@{m\+\_\+interfaces}}
\index{m\+\_\+interfaces@{m\+\_\+interfaces}!ns3\+::\+Ipv6\+Interface\+Container@{ns3\+::\+Ipv6\+Interface\+Container}}
\subsubsection[{\texorpdfstring{m\+\_\+interfaces}{m_interfaces}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Interface\+Vector} ns3\+::\+Ipv6\+Interface\+Container\+::m\+\_\+interfaces\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}{}\label{classns3_1_1Ipv6InterfaceContainer_a559846ada263de96a3a5d0408824712d}


List of I\+Pv6 stack and interfaces index. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/helper/\hyperlink{ipv6-interface-container_8h}{ipv6-\/interface-\/container.\+h}\item 
internet/helper/\hyperlink{ipv6-interface-container_8cc}{ipv6-\/interface-\/container.\+cc}\end{DoxyCompactItemize}
