\hypertarget{classns3_1_1dsr_1_1DsrOptionSR}{}\section{ns3\+:\+:dsr\+:\+:Dsr\+Option\+SR Class Reference}
\label{classns3_1_1dsr_1_1DsrOptionSR}\index{ns3\+::dsr\+::\+Dsr\+Option\+SR@{ns3\+::dsr\+::\+Dsr\+Option\+SR}}


Dsr Option Source Route.  




{\ttfamily \#include $<$dsr-\/options.\+h$>$}



Inheritance diagram for ns3\+:\+:dsr\+:\+:Dsr\+Option\+SR\+:
% FIG 0


Collaboration diagram for ns3\+:\+:dsr\+:\+:Dsr\+Option\+SR\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1dsr_1_1DsrOptionSR_a3d8b49c988d45c920d152f13b3136f27}{Get\+Instance\+Type\+Id} () const 
\begin{DoxyCompactList}\small\item\em Get the instance type ID. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1dsr_1_1DsrOptionSR_a92535429fbbfd562e5b89013045feeee}{Dsr\+Option\+SR} ()
\item 
virtual \hyperlink{classns3_1_1dsr_1_1DsrOptionSR_a7f04f3ecb5a38e2a4e87eb787b0572d1}{$\sim$\+Dsr\+Option\+SR} ()
\item 
virtual uint8\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrOptionSR_af7744385f5b6ca437cbb9400a71235bd}{Get\+Option\+Number} () const 
\begin{DoxyCompactList}\small\item\em Get the option number. \end{DoxyCompactList}\item 
virtual uint8\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrOptionSR_a3136e1503dc9a7cb1f8294d929c4e349}{Process} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ dsrP, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} ipv4\+Address, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} source, \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} const \&ipv4\+Header, uint8\+\_\+t protocol, bool \&is\+Promisc, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} promisc\+Source)
\begin{DoxyCompactList}\small\item\em Process method. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1dsr_1_1DsrOptionSR_abb6468d7c086f79537a9e1c6a52555ee}{Get\+Type\+Id} ()
\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const uint8\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrOptionSR_a6da9ac0656903ab8ecd89c7e147479b2}{O\+P\+T\+\_\+\+N\+U\+M\+B\+ER} = 96
\begin{DoxyCompactList}\small\item\em Source Route option number. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$ \hyperlink{classns3_1_1dsr_1_1DsrOptionSR_a6f9e883b6d334eec90f76d3206ff3e16}{m\+\_\+ipv4}
\begin{DoxyCompactList}\small\item\em The ip layer 3. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Dsr Option Source Route. 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::dsr\+::\+Dsr\+Option\+SR@{ns3\+::dsr\+::\+Dsr\+Option\+SR}!Dsr\+Option\+SR@{Dsr\+Option\+SR}}
\index{Dsr\+Option\+SR@{Dsr\+Option\+SR}!ns3\+::dsr\+::\+Dsr\+Option\+SR@{ns3\+::dsr\+::\+Dsr\+Option\+SR}}
\subsubsection[{\texorpdfstring{Dsr\+Option\+S\+R()}{DsrOptionSR()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::dsr\+::\+Dsr\+Option\+S\+R\+::\+Dsr\+Option\+SR (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrOptionSR_a92535429fbbfd562e5b89013045feeee}{}\label{classns3_1_1dsr_1_1DsrOptionSR_a92535429fbbfd562e5b89013045feeee}

\begin{DoxyCode}
1178 \{
1179   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
1180 \}
\end{DoxyCode}
\index{ns3\+::dsr\+::\+Dsr\+Option\+SR@{ns3\+::dsr\+::\+Dsr\+Option\+SR}!````~Dsr\+Option\+SR@{$\sim$\+Dsr\+Option\+SR}}
\index{````~Dsr\+Option\+SR@{$\sim$\+Dsr\+Option\+SR}!ns3\+::dsr\+::\+Dsr\+Option\+SR@{ns3\+::dsr\+::\+Dsr\+Option\+SR}}
\subsubsection[{\texorpdfstring{$\sim$\+Dsr\+Option\+S\+R()}{~DsrOptionSR()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::dsr\+::\+Dsr\+Option\+S\+R\+::$\sim$\+Dsr\+Option\+SR (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1dsr_1_1DsrOptionSR_a7f04f3ecb5a38e2a4e87eb787b0572d1}{}\label{classns3_1_1dsr_1_1DsrOptionSR_a7f04f3ecb5a38e2a4e87eb787b0572d1}

\begin{DoxyCode}
1183 \{
1184   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
1185 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::dsr\+::\+Dsr\+Option\+SR@{ns3\+::dsr\+::\+Dsr\+Option\+SR}!Get\+Instance\+Type\+Id@{Get\+Instance\+Type\+Id}}
\index{Get\+Instance\+Type\+Id@{Get\+Instance\+Type\+Id}!ns3\+::dsr\+::\+Dsr\+Option\+SR@{ns3\+::dsr\+::\+Dsr\+Option\+SR}}
\subsubsection[{\texorpdfstring{Get\+Instance\+Type\+Id() const }{GetInstanceTypeId() const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::dsr\+::\+Dsr\+Option\+S\+R\+::\+Get\+Instance\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1dsr_1_1DsrOptionSR_a3d8b49c988d45c920d152f13b3136f27}{}\label{classns3_1_1dsr_1_1DsrOptionSR_a3d8b49c988d45c920d152f13b3136f27}


Get the instance type ID. 

\begin{DoxyReturn}{Returns}
instance type ID 
\end{DoxyReturn}


Reimplemented from \hyperlink{classns3_1_1Object_a51e5994fa4b6eae32d719ad69f8fcbf5}{ns3\+::\+Object}.


\begin{DoxyCode}
1188 \{
1189   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1dsr_1_1DsrOptionSR_abb6468d7c086f79537a9e1c6a52555ee}{GetTypeId} ();
1190 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::dsr\+::\+Dsr\+Option\+SR@{ns3\+::dsr\+::\+Dsr\+Option\+SR}!Get\+Option\+Number@{Get\+Option\+Number}}
\index{Get\+Option\+Number@{Get\+Option\+Number}!ns3\+::dsr\+::\+Dsr\+Option\+SR@{ns3\+::dsr\+::\+Dsr\+Option\+SR}}
\subsubsection[{\texorpdfstring{Get\+Option\+Number() const }{GetOptionNumber() const }}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::dsr\+::\+Dsr\+Option\+S\+R\+::\+Get\+Option\+Number (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1dsr_1_1DsrOptionSR_af7744385f5b6ca437cbb9400a71235bd}{}\label{classns3_1_1dsr_1_1DsrOptionSR_af7744385f5b6ca437cbb9400a71235bd}


Get the option number. 

\begin{DoxyReturn}{Returns}
option number 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1dsr_1_1DsrOptions_a31407523e51950f30c95c89602580fc9}{ns3\+::dsr\+::\+Dsr\+Options}.


\begin{DoxyCode}
1193 \{
1194   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
1195   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1dsr_1_1DsrOptionSR_a6da9ac0656903ab8ecd89c7e147479b2}{OPT\_NUMBER};
1196 \}
\end{DoxyCode}
\index{ns3\+::dsr\+::\+Dsr\+Option\+SR@{ns3\+::dsr\+::\+Dsr\+Option\+SR}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::dsr\+::\+Dsr\+Option\+SR@{ns3\+::dsr\+::\+Dsr\+Option\+SR}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id()}{GetTypeId()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::dsr\+::\+Dsr\+Option\+S\+R\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1dsr_1_1DsrOptionSR_abb6468d7c086f79537a9e1c6a52555ee}{}\label{classns3_1_1dsr_1_1DsrOptionSR_abb6468d7c086f79537a9e1c6a52555ee}

\begin{DoxyCode}
1168 \{
1169   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::dsr::DsrOptionSR"})
1170     .SetParent<\hyperlink{classns3_1_1dsr_1_1DsrOptions_a26f9dda6f030963939c59ef1ab2a74c0}{DsrOptions}> ()
1171     .SetGroupName (\textcolor{stringliteral}{"Dsr"})
1172     .AddConstructor<\hyperlink{classns3_1_1dsr_1_1DsrOptionSR_a92535429fbbfd562e5b89013045feeee}{DsrOptionSR}> ()
1173   ;
1174   \textcolor{keywordflow}{return} tid;
1175 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::dsr\+::\+Dsr\+Option\+SR@{ns3\+::dsr\+::\+Dsr\+Option\+SR}!Process@{Process}}
\index{Process@{Process}!ns3\+::dsr\+::\+Dsr\+Option\+SR@{ns3\+::dsr\+::\+Dsr\+Option\+SR}}
\subsubsection[{\texorpdfstring{Process(\+Ptr$<$ Packet $>$ packet, Ptr$<$ Packet $>$ dsr\+P, Ipv4\+Address ipv4\+Address, Ipv4\+Address source, Ipv4\+Header const \&ipv4\+Header, uint8\+\_\+t protocol, bool \&is\+Promisc, Ipv4\+Address promisc\+Source)}{Process(Ptr< Packet > packet, Ptr< Packet > dsrP, Ipv4Address ipv4Address, Ipv4Address source, Ipv4Header const &ipv4Header, uint8_t protocol, bool &isPromisc, Ipv4Address promiscSource)}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::dsr\+::\+Dsr\+Option\+S\+R\+::\+Process (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{dsrP, }
\item[{{\bf Ipv4\+Address}}]{ipv4\+Address, }
\item[{{\bf Ipv4\+Address}}]{source, }
\item[{{\bf Ipv4\+Header} const \&}]{ipv4\+Header, }
\item[{uint8\+\_\+t}]{protocol, }
\item[{bool \&}]{is\+Promisc, }
\item[{{\bf Ipv4\+Address}}]{promisc\+Source}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1dsr_1_1DsrOptionSR_a3136e1503dc9a7cb1f8294d929c4e349}{}\label{classns3_1_1dsr_1_1DsrOptionSR_a3136e1503dc9a7cb1f8294d929c4e349}


Process method. 

Called from \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4908cdae502d8bdca8a244d4420311e6}{Dsr\+Routing\+::\+Receive}. 
\begin{DoxyParams}{Parameters}
{\em packet} & the packet \\
\hline
{\em dsrP} & the clean packet with payload \\
\hline
{\em ipv4\+Address} & the I\+Pv4 address \\
\hline
{\em source} & I\+Pv4 address of the source \\
\hline
{\em ipv4\+Header} & the I\+Pv4 header of packet received \\
\hline
{\em protocol} & the protocol number of the up layer \\
\hline
{\em is\+Promisc} & if the packet must be dropped \\
\hline
{\em promisc\+Source} & I\+Pv4 address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the processed size 
\end{DoxyReturn}
Safely terminate promiscuously received packet

When the option type is 160, means there is A\+CK request header after the source route, we need to send back acknowledgment 

Implements \hyperlink{classns3_1_1dsr_1_1DsrOptions_ac34fb87a95464f3ea9d82ad12253a5cc}{ns3\+::dsr\+::\+Dsr\+Options}.


\begin{DoxyCode}
1199 \{
1200   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << dsrP << ipv4Address << source << ipv4Address << 
      ipv4Header << (uint32\_t)protocol << isPromisc);
1201   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = packet->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} ();
1202   \textcolor{comment}{// Get the number of routers' address field}
1203   uint8\_t buf[2];
1204   p->\hyperlink{classns3_1_1Packet_a5a6d304b9e0d90733919ffe224b98f0d}{CopyData} (buf, \textcolor{keyword}{sizeof}(buf));
1205   uint8\_t numberAddress = (buf[1] - 2) / 4;
1206   DsrOptionSRHeader sourceRoute;
1207   sourceRoute.SetNumberAddress (numberAddress);
1208   p->RemoveHeader (sourceRoute);
1209 
1210   \textcolor{comment}{// The route size saved in the source route}
1211   std::vector<Ipv4Address> nodeList = sourceRoute.GetNodesAddress ();
1212   uint8\_t segsLeft = sourceRoute.GetSegmentsLeft ();
1213   uint8\_t salvage = sourceRoute.GetSalvage ();
1214   \textcolor{comment}{/*}
1215 \textcolor{comment}{   * Get the node from IP address and get the DSR extension object}
1216 \textcolor{comment}{   */}
1217   Ptr<Node> node = \hyperlink{classns3_1_1dsr_1_1DsrOptions_a1a91f820f3d754a477a54bad547ca659}{GetNodeWithAddress} (ipv4Address);
1218   Ptr<dsr::DsrRouting> dsr = node->GetObject<dsr::DsrRouting> ();
1219   \textcolor{comment}{/*}
1220 \textcolor{comment}{   * Get the source and destination address from ipv4 header}
1221 \textcolor{comment}{   */}
1222   Ipv4Address srcAddress = ipv4Header.GetSource ();
1223   Ipv4Address destAddress = ipv4Header.GetDestination ();
1224 
1225   \textcolor{comment}{// Get the node list destination}
1226   Ipv4Address destination = nodeList.back ();
1227   \textcolor{comment}{/*}
1228 \textcolor{comment}{   * If it's a promiscuous receive data packet,}
1229 \textcolor{comment}{   * 1. see if automatic route shortening possible or not}
1230 \textcolor{comment}{   * 2. see if it is a passive acknowledgment}
1231 \textcolor{comment}{   */}
1232   \textcolor{keywordflow}{if} (isPromisc)
1233     \{
1234       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"We process promiscuous receipt data packet"});
1235       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrOptions_a96e4b43dbea2ac49309abdd0f84a9b0a}{ContainAddressAfter} (ipv4Address, destAddress, nodeList))
1236         \{
1237           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Send back the gratuitous reply"});
1238           dsr->SendGratuitousReply (source, srcAddress, nodeList, protocol);
1239         \}
1240 
1241       uint16\_t fragmentOffset = ipv4Header.GetFragmentOffset ();
1242       uint16\_t identification = ipv4Header.GetIdentification ();
1243 
1244       \textcolor{keywordflow}{if} (destAddress != destination)
1245         \{
1246           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Process the promiscuously received packet"});
1247           \textcolor{keywordtype}{bool} findPassive = \textcolor{keyword}{false};
1248           int32\_t nNodes = \hyperlink{classns3_1_1NodeList_a1d110b1670005895dd5812baab13682a}{NodeList::GetNNodes} ();
1249           \textcolor{keywordflow}{for} (int32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < nNodes; ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
1250             \{
1251               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Working with node "} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
1252 
1253               Ptr<Node> node = \hyperlink{classns3_1_1NodeList_a80ac09977d48d29db5c704ac8483cf6c}{NodeList::GetNode} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
1254               Ptr<dsr::DsrRouting> dsrNode = node->GetObject<dsr::DsrRouting> ();
1255               \textcolor{comment}{// The source and destination addresses here are the real source and destination for the
       packet}
1256               findPassive = dsrNode->PassiveEntryCheck (packet, source, destination, segsLeft, 
      fragmentOffset, identification, \textcolor{keyword}{false});
1257               \textcolor{keywordflow}{if} (findPassive)
1258                 \{
1259                   \textcolor{keywordflow}{break};
1260                 \}
1261             \}
1262 
1263           \textcolor{keywordflow}{if} (findPassive)
1264             \{
1265               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"We find one previously received passive entry"});
1266               \textcolor{comment}{/*}
1267 \textcolor{comment}{               * Get the node from IP address and get the DSR extension object}
1268 \textcolor{comment}{               * the srcAddress would be the source address from ip header}
1269 \textcolor{comment}{               */}
1270               \hyperlink{classns3_1_1dsr_1_1DsrOptions_a44ae8e58769880ec9c0150bb28652350}{PrintVector} (nodeList);
1271 
1272               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"promisc source "} << promiscSource);
1273               Ptr<Node> node = \hyperlink{classns3_1_1dsr_1_1DsrOptions_a1a91f820f3d754a477a54bad547ca659}{GetNodeWithAddress} (promiscSource);
1274               Ptr<dsr::DsrRouting> dsrSrc = node->GetObject<dsr::DsrRouting> ();
1275               dsrSrc->CancelPassiveTimer (packet, source, destination, segsLeft);
1276             \}
1277           \textcolor{keywordflow}{else}
1278             \{
1279               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Saved the entry for further use"});
1280               dsr->PassiveEntryCheck (packet, source, destination, segsLeft, fragmentOffset, identification
      , \textcolor{keyword}{true});
1281             \}
1282         \}
1284       \textcolor{keywordflow}{return} 0;
1285     \}
1286   \textcolor{keywordflow}{else}
1287     \{
1288       \textcolor{comment}{/*}
1289 \textcolor{comment}{       * Get the number of address from the source route header}
1290 \textcolor{comment}{       */}
1291       uint8\_t length = sourceRoute.GetLength ();
1292       uint8\_t nextAddressIndex;
1293       Ipv4Address nextAddress;
1294 
1295       \textcolor{comment}{// Get the option type value}
1296       uint32\_t size = p->GetSize ();
1297       uint8\_t *\hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data} = \textcolor{keyword}{new} uint8\_t[size];
1298       p->CopyData (data, size);
1299       uint8\_t optionType = 0;
1300       optionType = *(\hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data});
1303       \textcolor{keywordflow}{if} (optionType == 160)
1304         \{
1305           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Remove the ack request header and add ack header to the packet"});
1306           \textcolor{comment}{// Here we remove the ack packet to the previous hop}
1307           DsrOptionAckReqHeader ackReq;
1308           p->RemoveHeader (ackReq);
1309           uint16\_t ackId = ackReq.GetAckId ();
1310           \textcolor{comment}{/*}
1311 \textcolor{comment}{           * Send back acknowledgment packet to the earlier hop}
1312 \textcolor{comment}{           * If the node list is not empty, find the previous hop from the node list,}
1313 \textcolor{comment}{           * otherwise, use srcAddress}
1314 \textcolor{comment}{           */}
1315           Ipv4Address ackAddress = srcAddress;
1316           \textcolor{keywordflow}{if} (!nodeList.empty ())
1317             \{
1318                 \textcolor{keywordflow}{if} (segsLeft > numberAddress) \textcolor{comment}{// The segmentsLeft field should not be larger than the total
       number of ip addresses}
1319                   \{
1320                     \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Malformed header. Drop!"});
1321                     \hyperlink{classns3_1_1dsr_1_1DsrOptions_a176bbc9efb58b6d750c14b9b03c525c4}{m\_dropTrace} (packet);
1322                     \textcolor{keywordflow}{return} 0;
1323                   \}
1324                 \textcolor{comment}{// -fstrict-overflow sensitive, see bug 1868}
1325                 \textcolor{keywordflow}{if} (numberAddress - segsLeft < 2) \textcolor{comment}{// The index is invalid}
1326                    \{
1327                       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Malformed header. Drop!"});
1328                       \hyperlink{classns3_1_1dsr_1_1DsrOptions_a176bbc9efb58b6d750c14b9b03c525c4}{m\_dropTrace} (packet);
1329                       \textcolor{keywordflow}{return} 0;
1330                    \}
1331                    ackAddress = nodeList[numberAddress - segsLeft - 2];
1332             \}
1333            \hyperlink{classns3_1_1dsr_1_1DsrOptions_ae4785209eae1d101cb8bd2d3b392d2ad}{m\_ipv4Route} = \hyperlink{classns3_1_1dsr_1_1DsrOptions_af749b76db4626ae64bc37001a5353b99}{SetRoute} (ackAddress, ipv4Address);
1334            \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Send back ACK to the earlier hop "} << ackAddress << \textcolor{stringliteral}{" from us "} << 
      ipv4Address);
1335            dsr->SendAck (ackId, ackAddress, source, destination, protocol, 
      \hyperlink{classns3_1_1dsr_1_1DsrOptions_ae4785209eae1d101cb8bd2d3b392d2ad}{m\_ipv4Route});
1336         \}
1337       \textcolor{comment}{/*}
1338 \textcolor{comment}{       * After send back ACK, check if the segments left value has turned to 0 or not, if yes, update the
       route entry}
1339 \textcolor{comment}{       * and return header length}
1340 \textcolor{comment}{       */}
1341       \textcolor{keywordflow}{if} (segsLeft == 0)
1342         \{
1343           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"This is the final destination"});
1344           isPromisc = \textcolor{keyword}{false};
1345           \textcolor{keywordflow}{return} sourceRoute.GetSerializedSize ();
1346         \}
1347 
1348       \textcolor{keywordflow}{if} (length % 2 != 0)
1349         \{
1350           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Malformed header. Drop!"});
1351           \hyperlink{classns3_1_1dsr_1_1DsrOptions_a176bbc9efb58b6d750c14b9b03c525c4}{m\_dropTrace} (packet);
1352           \textcolor{keywordflow}{return} 0;
1353         \}
1354 
1355       \textcolor{keywordflow}{if} (segsLeft > numberAddress) \textcolor{comment}{// The segmentsLeft field should not be larger than the total number of
       ip addresses}
1356         \{
1357           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Malformed header. Drop!"});
1358           \hyperlink{classns3_1_1dsr_1_1DsrOptions_a176bbc9efb58b6d750c14b9b03c525c4}{m\_dropTrace} (packet);
1359           \textcolor{keywordflow}{return} 0;
1360         \}
1361 
1362       DsrOptionSRHeader newSourceRoute;
1363       newSourceRoute.SetSegmentsLeft (segsLeft - 1);
1364       newSourceRoute.SetSalvage (salvage);
1365       newSourceRoute.SetNodesAddress (nodeList);
1366       nextAddressIndex = numberAddress - segsLeft;
1367       nextAddress = newSourceRoute.GetNodeAddress (nextAddressIndex);
1368       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The next address of source route option "} << nextAddress << \textcolor{stringliteral}{" and the
       nextAddressIndex: "} << (uint32\_t)nextAddressIndex << \textcolor{stringliteral}{" and the segments left : "} << (uint32\_t)segsLeft);
1369       \textcolor{comment}{/*}
1370 \textcolor{comment}{       * Get the target Address in the node list}
1371 \textcolor{comment}{       */}
1372       Ipv4Address targetAddress = nodeList.back ();
1373       Ipv4Address realSource = nodeList.front ();
1374       \textcolor{comment}{/*}
1375 \textcolor{comment}{       * Search the vector for next hop address}
1376 \textcolor{comment}{       */}
1377       Ipv4Address nextHop = \hyperlink{classns3_1_1dsr_1_1DsrOptions_a061c66ba810a71ae227371a45cc30cc0}{SearchNextHop} (ipv4Address, nodeList);
1378       \hyperlink{classns3_1_1dsr_1_1DsrOptions_a44ae8e58769880ec9c0150bb28652350}{PrintVector} (nodeList);
1379 
1380       \textcolor{keywordflow}{if} (nextHop == \textcolor{stringliteral}{"0.0.0.0"})
1381         \{
1382           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Before new packet "} << *dsrP);
1383           dsr->PacketNewRoute (dsrP, realSource, targetAddress, protocol);
1384           \textcolor{keywordflow}{return} 0;
1385         \}
1386 
1387       \textcolor{keywordflow}{if} (ipv4Address == nextHop)
1388         \{
1389           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"We have reached the destination"});
1390           newSourceRoute.SetSegmentsLeft (0);
1391           \textcolor{keywordflow}{return} newSourceRoute.GetSerializedSize ();
1392         \}
1393       \textcolor{comment}{// Verify the multicast address, leave it here for now}
1394       \textcolor{keywordflow}{if} (nextAddress.IsMulticast () || destAddress.IsMulticast ())
1395         \{
1396           \hyperlink{classns3_1_1dsr_1_1DsrOptions_a176bbc9efb58b6d750c14b9b03c525c4}{m\_dropTrace} (packet);
1397           \textcolor{keywordflow}{return} 0;
1398         \}
1399       \textcolor{comment}{// Set the route and forward the data packet}
1400       \hyperlink{classns3_1_1dsr_1_1DsrOptions_af749b76db4626ae64bc37001a5353b99}{SetRoute} (nextAddress, ipv4Address);
1401       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"dsr packet size "} << dsrP->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ());
1402       dsr->ForwardPacket (dsrP, newSourceRoute, ipv4Header, realSource, nextAddress, targetAddress, 
      protocol, \hyperlink{classns3_1_1dsr_1_1DsrOptions_ae4785209eae1d101cb8bd2d3b392d2ad}{m\_ipv4Route});
1403     \}
1404   \textcolor{keywordflow}{return} sourceRoute.GetSerializedSize ();
1405 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4




\subsection{Member Data Documentation}
\index{ns3\+::dsr\+::\+Dsr\+Option\+SR@{ns3\+::dsr\+::\+Dsr\+Option\+SR}!m\+\_\+ipv4@{m\+\_\+ipv4}}
\index{m\+\_\+ipv4@{m\+\_\+ipv4}!ns3\+::dsr\+::\+Dsr\+Option\+SR@{ns3\+::dsr\+::\+Dsr\+Option\+SR}}
\subsubsection[{\texorpdfstring{m\+\_\+ipv4}{m_ipv4}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Ipv4}$>$ ns3\+::dsr\+::\+Dsr\+Option\+S\+R\+::m\+\_\+ipv4\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrOptionSR_a6f9e883b6d334eec90f76d3206ff3e16}{}\label{classns3_1_1dsr_1_1DsrOptionSR_a6f9e883b6d334eec90f76d3206ff3e16}


The ip layer 3. 

\index{ns3\+::dsr\+::\+Dsr\+Option\+SR@{ns3\+::dsr\+::\+Dsr\+Option\+SR}!O\+P\+T\+\_\+\+N\+U\+M\+B\+ER@{O\+P\+T\+\_\+\+N\+U\+M\+B\+ER}}
\index{O\+P\+T\+\_\+\+N\+U\+M\+B\+ER@{O\+P\+T\+\_\+\+N\+U\+M\+B\+ER}!ns3\+::dsr\+::\+Dsr\+Option\+SR@{ns3\+::dsr\+::\+Dsr\+Option\+SR}}
\subsubsection[{\texorpdfstring{O\+P\+T\+\_\+\+N\+U\+M\+B\+ER}{OPT_NUMBER}}]{\setlength{\rightskip}{0pt plus 5cm}const uint8\+\_\+t ns3\+::dsr\+::\+Dsr\+Option\+S\+R\+::\+O\+P\+T\+\_\+\+N\+U\+M\+B\+ER = 96\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1dsr_1_1DsrOptionSR_a6da9ac0656903ab8ecd89c7e147479b2}{}\label{classns3_1_1dsr_1_1DsrOptionSR_a6da9ac0656903ab8ecd89c7e147479b2}


Source Route option number. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
dsr/model/\hyperlink{dsr-options_8h}{dsr-\/options.\+h}\item 
dsr/model/\hyperlink{dsr-options_8cc}{dsr-\/options.\+cc}\end{DoxyCompactItemize}
