\hypertarget{classns3_1_1UdpSocketImpl}{}\section{ns3\+:\+:Udp\+Socket\+Impl Class Reference}
\label{classns3_1_1UdpSocketImpl}\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}


A sockets interface to U\+DP.  




{\ttfamily \#include $<$udp-\/socket-\/impl.\+h$>$}



Inheritance diagram for ns3\+:\+:Udp\+Socket\+Impl\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Udp\+Socket\+Impl\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1UdpSocketImpl_a870b73927cd3bd748da198906b53fb2d}{Udp\+Socket\+Impl} ()
\item 
virtual \hyperlink{classns3_1_1UdpSocketImpl_a47080dd8189ab3065c5093470b123cec}{$\sim$\+Udp\+Socket\+Impl} ()
\item 
void \hyperlink{classns3_1_1UdpSocketImpl_abdbd6d194bd91c0c29f43698ddee2210}{Set\+Node} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node)
\begin{DoxyCompactList}\small\item\em Set the associated node. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1UdpSocketImpl_a0138b99fbde4ea810ce1aa2e4500dff4}{Set\+Udp} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UdpL4Protocol}{Udp\+L4\+Protocol} $>$ udp)
\begin{DoxyCompactList}\small\item\em Set the associated U\+DP L4 protocol. \end{DoxyCompactList}\item 
virtual enum \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket\+Errno} \hyperlink{classns3_1_1UdpSocketImpl_ac8559811caa54f721de6f68bb030910f}{Get\+Errno} (void) const 
\begin{DoxyCompactList}\small\item\em Get last error number. \end{DoxyCompactList}\item 
virtual enum \hyperlink{classns3_1_1Socket_a698fbcc486a48b7a0d2b0e4ab863d571}{Socket\+Type} \hyperlink{classns3_1_1UdpSocketImpl_aea31312dc3090dbc0b629569bb2aba9b}{Get\+Socket\+Type} (void) const 
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1UdpSocketImpl_ac0971130b8551291542586e2430410ff}{Get\+Node} (void) const 
\begin{DoxyCompactList}\small\item\em Return the node this socket is associated with. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1UdpSocketImpl_a02289f4c7fa69580c8426484fe3712c3}{Bind} (void)
\begin{DoxyCompactList}\small\item\em Allocate a local I\+Pv4 endpoint for this socket. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1UdpSocketImpl_a32b33c7a08d81248b1579882cebadcb6}{Bind6} (void)
\begin{DoxyCompactList}\small\item\em Allocate a local I\+Pv6 endpoint for this socket. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1UdpSocketImpl_a27d5153e9d75f95b1c04a74a7527cab1}{Bind} (const \hyperlink{classns3_1_1Address}{Address} \&address)
\begin{DoxyCompactList}\small\item\em Allocate a local endpoint for this socket. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1UdpSocketImpl_a9e81e9e088339d3608560afabf2d5f49}{Close} (void)
\begin{DoxyCompactList}\small\item\em Close a socket. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1UdpSocketImpl_a8a246f3ad4a45f0f397e2ccca71dc843}{Shutdown\+Send} (void)
\item 
virtual int \hyperlink{classns3_1_1UdpSocketImpl_a63d835c2b62497baa89b2a3ff7341fd4}{Shutdown\+Recv} (void)
\item 
virtual int \hyperlink{classns3_1_1UdpSocketImpl_a83f8fca9d8a21edeba0016d6de68fbf5}{Connect} (const \hyperlink{classns3_1_1Address}{Address} \&address)
\begin{DoxyCompactList}\small\item\em Initiate a connection to a remote host. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1UdpSocketImpl_a2a7b54e5e56efbd664e3e382bcfbb0f8}{Listen} (void)
\begin{DoxyCompactList}\small\item\em Listen for incoming connections. \end{DoxyCompactList}\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1UdpSocketImpl_a70191d0578ae26233f569631a26d608b}{Get\+Tx\+Available} (void) const 
\begin{DoxyCompactList}\small\item\em Returns the number of bytes which can be sent in a single call to Send. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1UdpSocketImpl_ac8e23c2e48d59b943ad5beda3c9b9cce}{Send} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, uint32\+\_\+t flags)
\begin{DoxyCompactList}\small\item\em Send data (or dummy data) to the remote host. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1UdpSocketImpl_a8157d2ad72321be1047493ebf97e55f5}{Send\+To} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, uint32\+\_\+t flags, const \hyperlink{classns3_1_1Address}{Address} \&address)
\begin{DoxyCompactList}\small\item\em Send data to a specified peer. \end{DoxyCompactList}\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1UdpSocketImpl_a1a6d616624492e2846516de890832f63}{Get\+Rx\+Available} (void) const 
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{classns3_1_1UdpSocketImpl_a7268e7d9604b790bf455a2d0e664eac1}{Recv} (uint32\+\_\+t max\+Size, uint32\+\_\+t flags)
\begin{DoxyCompactList}\small\item\em Read data from the socket. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{classns3_1_1UdpSocketImpl_a5e460efb45eaf5fab145970043614ec8}{Recv\+From} (uint32\+\_\+t max\+Size, uint32\+\_\+t flags, \hyperlink{classns3_1_1Address}{Address} \&from\+Address)
\begin{DoxyCompactList}\small\item\em Read a single packet from the socket and retrieve the sender address. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1UdpSocketImpl_a871428d5daa26d9f0b3566c8310e9769}{Get\+Sock\+Name} (\hyperlink{classns3_1_1Address}{Address} \&address) const 
\begin{DoxyCompactList}\small\item\em Get socket address. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1UdpSocketImpl_a73c3d2b1f7372550df82af8effb8bbe0}{Get\+Peer\+Name} (\hyperlink{classns3_1_1Address}{Address} \&address) const 
\begin{DoxyCompactList}\small\item\em Get the peer address of a connected socket. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1UdpSocketImpl_ae32570783dbdc0fdda43b22c2fbc9d53}{Multicast\+Join\+Group} (uint32\+\_\+t interface\+Index, const \hyperlink{classns3_1_1Address}{Address} \&group\+Address)
\begin{DoxyCompactList}\small\item\em Corresponds to socket option M\+C\+A\+S\+T\+\_\+\+J\+O\+I\+N\+\_\+\+G\+R\+O\+UP. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1UdpSocketImpl_a6eed2cfb6cf57309ac25e4526871b432}{Multicast\+Leave\+Group} (uint32\+\_\+t interface\+Index, const \hyperlink{classns3_1_1Address}{Address} \&group\+Address)
\begin{DoxyCompactList}\small\item\em Corresponds to socket option M\+C\+A\+S\+T\+\_\+\+L\+E\+A\+V\+E\+\_\+\+G\+R\+O\+UP. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1UdpSocketImpl_a93fa14afedc32353602551df1e5f2d59}{Bind\+To\+Net\+Device} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ netdevice)
\begin{DoxyCompactList}\small\item\em Bind a socket to specific device. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1UdpSocketImpl_a99fd369504ca05485b7be7a426fbb4d5}{Set\+Allow\+Broadcast} (bool allow\+Broadcast)
\begin{DoxyCompactList}\small\item\em Configure whether broadcast datagram transmissions are allowed. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1UdpSocketImpl_a9d2ef36ffe3fe414e861ec14d6d18fed}{Get\+Allow\+Broadcast} () const 
\begin{DoxyCompactList}\small\item\em Query whether broadcast datagram transmissions are allowed. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1UdpSocketImpl_a65ec9e22618155ac74695a2ac7e24695}{Ipv6\+Join\+Group} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} address, \hyperlink{classns3_1_1Socket_a96f39fe2b73d5691b319093a1e31615d}{Socket\+::\+Ipv6\+Multicast\+Filter\+Mode} filter\+Mode, std\+::vector$<$ \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} $>$ source\+Addresses)
\begin{DoxyCompactList}\small\item\em Joins a I\+Pv6 multicast group. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1UdpSocketImpl_a4412f79ef3f0597cc1ac0dcf8922ee3a}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1UdpSocketImpl_a002c494bd9a8b8e9283aacce41c081a9}{Set\+Rcv\+Buf\+Size} (uint32\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Set the receiving buffer size. \end{DoxyCompactList}\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1UdpSocketImpl_a416f9131c40452da19e02d86a8691ffd}{Get\+Rcv\+Buf\+Size} (void) const 
\begin{DoxyCompactList}\small\item\em Get the receiving buffer size. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1UdpSocketImpl_aff7e58ad0fc890d358d4f0d8eccddb95}{Set\+Ip\+Multicast\+Ttl} (uint8\+\_\+t ip\+Ttl)
\begin{DoxyCompactList}\small\item\em Set the IP multicast T\+TL. \end{DoxyCompactList}\item 
virtual uint8\+\_\+t \hyperlink{classns3_1_1UdpSocketImpl_af458fecb96042e1be40efa66db348e99}{Get\+Ip\+Multicast\+Ttl} (void) const 
\begin{DoxyCompactList}\small\item\em Get the IP multicast T\+TL. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1UdpSocketImpl_addfb5894a849eb136d084d5aac4d10ae}{Set\+Ip\+Multicast\+If} (int32\+\_\+t ip\+If)
\begin{DoxyCompactList}\small\item\em Set the IP multicast interface. \end{DoxyCompactList}\item 
virtual int32\+\_\+t \hyperlink{classns3_1_1UdpSocketImpl_aced96ba1ce213afb754231be7c25510a}{Get\+Ip\+Multicast\+If} (void) const 
\begin{DoxyCompactList}\small\item\em Get the IP multicast interface. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1UdpSocketImpl_a71747eac52a9dcace2fdd1febf3cab3e}{Set\+Ip\+Multicast\+Loop} (bool loop)
\begin{DoxyCompactList}\small\item\em Set the IP multicast loop capability. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1UdpSocketImpl_ae15a4f99d3a7f7f43068b02f1341abb5}{Get\+Ip\+Multicast\+Loop} (void) const 
\begin{DoxyCompactList}\small\item\em Get the IP multicast loop capability. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1UdpSocketImpl_a0f6987b77c5b5635ad779c4c465b8375}{Set\+Mtu\+Discover} (bool discover)
\begin{DoxyCompactList}\small\item\em Set the M\+TU discover capability. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1UdpSocketImpl_a3268aa9137eb2e0a02abbe147c82b5fa}{Get\+Mtu\+Discover} (void) const 
\begin{DoxyCompactList}\small\item\em Get the M\+TU discover capability. \end{DoxyCompactList}\item 
int \hyperlink{classns3_1_1UdpSocketImpl_ab176a2c5ea5e2ba0431a59cbc423c618}{Finish\+Bind} (void)
\item 
void \hyperlink{classns3_1_1UdpSocketImpl_ac7ad1051f59ee35a9083a457bd6c5642}{Forward\+Up} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} header, uint16\+\_\+t \hyperlink{visualizer-ideas_8txt_a21ff1c530daf8435e00048b7fc2c58e3}{port}, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} $>$ incoming\+Interface)
\begin{DoxyCompactList}\small\item\em Called by the L3 protocol when it received a packet to pass on to T\+CP. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1UdpSocketImpl_a1550f484c8c62c215a44e8c13694986b}{Forward\+Up6} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} header, uint16\+\_\+t \hyperlink{visualizer-ideas_8txt_a21ff1c530daf8435e00048b7fc2c58e3}{port}, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Interface}{Ipv6\+Interface} $>$ incoming\+Interface)
\begin{DoxyCompactList}\small\item\em Called by the L3 protocol when it received a packet to pass on to T\+CP. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1UdpSocketImpl_ab0f9092f8f28c5d246cae63476215fc8}{Destroy} (void)
\begin{DoxyCompactList}\small\item\em Kill this socket by zeroing its attributes (I\+Pv4) \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1UdpSocketImpl_a40198099b528e0edbcfa323287c676bd}{Destroy6} (void)
\begin{DoxyCompactList}\small\item\em Kill this socket by zeroing its attributes (I\+Pv6) \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1UdpSocketImpl_a06e34674acd7ec7f6c186e52767cdf2c}{Deallocate\+End\+Point} (void)
\begin{DoxyCompactList}\small\item\em Deallocate m\+\_\+end\+Point and m\+\_\+end\+Point6. \end{DoxyCompactList}\item 
int \hyperlink{classns3_1_1UdpSocketImpl_aeb7a2f7998edd56c9079ac6a3518cd89}{Do\+Send} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p})
\begin{DoxyCompactList}\small\item\em Send a packet. \end{DoxyCompactList}\item 
int \hyperlink{classns3_1_1UdpSocketImpl_a18b22c398f6e9a7806f92b6a3ca7b3e8}{Do\+Send\+To} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} daddr, uint16\+\_\+t dport, uint8\+\_\+t tos)
\begin{DoxyCompactList}\small\item\em Send a packet to a specific destination and port (I\+Pv4) \end{DoxyCompactList}\item 
int \hyperlink{classns3_1_1UdpSocketImpl_a4c3672c1127cbe31678d8d18751d3f4c}{Do\+Send\+To} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} daddr, uint16\+\_\+t dport)
\begin{DoxyCompactList}\small\item\em Send a packet to a specific destination and port (I\+Pv6) \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1UdpSocketImpl_a2f67e00e32fdb33ad58e1f429377a130}{Forward\+Icmp} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} icmp\+Source, uint8\+\_\+t icmp\+Ttl, uint8\+\_\+t icmp\+Type, uint8\+\_\+t icmp\+Code, uint32\+\_\+t icmp\+Info)
\begin{DoxyCompactList}\small\item\em Called by the L3 protocol when it received an I\+C\+MP packet to pass on to T\+CP. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1UdpSocketImpl_af83861011e4674d8f4c31b13f78c2204}{Forward\+Icmp6} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} icmp\+Source, uint8\+\_\+t icmp\+Ttl, uint8\+\_\+t icmp\+Type, uint8\+\_\+t icmp\+Code, uint32\+\_\+t icmp\+Info)
\begin{DoxyCompactList}\small\item\em Called by the L3 protocol when it received an I\+C\+M\+Pv6 packet to pass on to T\+CP. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ipv4EndPoint}{Ipv4\+End\+Point} $\ast$ \hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\+\_\+end\+Point}
\begin{DoxyCompactList}\small\item\em the I\+Pv4 endpoint \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6EndPoint}{Ipv6\+End\+Point} $\ast$ \hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\+\_\+end\+Point6}
\begin{DoxyCompactList}\small\item\em the I\+Pv6 endpoint \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1UdpSocketImpl_af6a19247be3d8917b582af77337730c3}{m\+\_\+node}
\begin{DoxyCompactList}\small\item\em the associated node \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UdpL4Protocol}{Udp\+L4\+Protocol} $>$ \hyperlink{classns3_1_1UdpSocketImpl_ace4b90c1ab6f4f302cdb4cd8da973514}{m\+\_\+udp}
\begin{DoxyCompactList}\small\item\em the associated U\+DP L4 protocol \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Callback}{Callback}$<$ void, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address}, uint8\+\_\+t, uint8\+\_\+t, uint8\+\_\+t, uint32\+\_\+t $>$ \hyperlink{classns3_1_1UdpSocketImpl_a0a595e39113e8854c86c820623ae6cd4}{m\+\_\+icmp\+Callback}
\begin{DoxyCompactList}\small\item\em I\+C\+MP callback. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Callback}{Callback}$<$ void, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address}, uint8\+\_\+t, uint8\+\_\+t, uint8\+\_\+t, uint32\+\_\+t $>$ \hyperlink{classns3_1_1UdpSocketImpl_aa4fbff077aa5ca080279196abaa87a04}{m\+\_\+icmp\+Callback6}
\begin{DoxyCompactList}\small\item\em I\+C\+M\+Pv6 callback. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1UdpSocketImpl_a820bb30415d2627cea60338649d19ccb}{m\+\_\+default\+Address}
\begin{DoxyCompactList}\small\item\em Default address. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1UdpSocketImpl_a990120b2cc768c47a6a2a2a1e53875c8}{m\+\_\+default\+Port}
\begin{DoxyCompactList}\small\item\em Default port. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1UdpSocketImpl_a786fed61e3c4c68280656c4036514c11}{m\+\_\+drop\+Trace}
\begin{DoxyCompactList}\small\item\em Trace for dropped packets. \end{DoxyCompactList}\item 
enum \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket\+Errno} \hyperlink{classns3_1_1UdpSocketImpl_ac35998e8aa2cc588e21752944b0a0095}{m\+\_\+errno}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Socket}{Socket} error code. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1UdpSocketImpl_a9ff4985bbd8bdc29bbe36ba0937149fa}{m\+\_\+shutdown\+Send}
\begin{DoxyCompactList}\small\item\em Send no longer allowed. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1UdpSocketImpl_abda20957e451801973534c38d9d74f4a}{m\+\_\+shutdown\+Recv}
\begin{DoxyCompactList}\small\item\em Receive no longer allowed. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1UdpSocketImpl_a2df1a2df7ba0f4c852ad1d2155b1fbcc}{m\+\_\+connected}
\begin{DoxyCompactList}\small\item\em Connection established. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1UdpSocketImpl_a071404252802565f1d1511b5c98b155a}{m\+\_\+allow\+Broadcast}
\begin{DoxyCompactList}\small\item\em Allow send broadcast packets. \end{DoxyCompactList}\item 
std\+::queue$<$ std\+::pair$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$, \hyperlink{classns3_1_1Address}{Address} $>$ $>$ \hyperlink{classns3_1_1UdpSocketImpl_a6a95636f11b186eab1f70727500d9233}{m\+\_\+delivery\+Queue}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Queue}{Queue} for incoming packets. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1UdpSocketImpl_a73e12067139eb298bbb4b0e2c2e56a6a}{m\+\_\+rx\+Available}
\begin{DoxyCompactList}\small\item\em Number of available bytes to be received. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1UdpSocketImpl_a81c69f998616d1d79a9c81c569b725e9}{m\+\_\+rcv\+Buf\+Size}
\begin{DoxyCompactList}\small\item\em Receive buffer size. \end{DoxyCompactList}\item 
uint8\+\_\+t \hyperlink{classns3_1_1UdpSocketImpl_a4849465356cef8573ed373d12a5a62ec}{m\+\_\+ip\+Multicast\+Ttl}
\begin{DoxyCompactList}\small\item\em Multicast T\+TL. \end{DoxyCompactList}\item 
int32\+\_\+t \hyperlink{classns3_1_1UdpSocketImpl_a4ff1b1c6db56fad154afe2563d985e08}{m\+\_\+ip\+Multicast\+If}
\begin{DoxyCompactList}\small\item\em Multicast Interface. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1UdpSocketImpl_aa201ce3516300da49c3e602e21cd6f6d}{m\+\_\+ip\+Multicast\+Loop}
\begin{DoxyCompactList}\small\item\em Allow multicast loop. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1UdpSocketImpl_ab5ae932e01b5746539b9ad20b3ff4f46}{m\+\_\+mtu\+Discover}
\begin{DoxyCompactList}\small\item\em Allow M\+TU discovery. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Related Functions}
(Note that these are not member functions.) \begin{DoxyCompactItemize}
\item 
class \hyperlink{classns3_1_1UdpSocketImpl_afba47205bf14e005b7444bb89be13029}{Udp\+Socket\+Factory}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1UdpSocketFactory}{Udp\+Socket\+Factory} friend class. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
A sockets interface to U\+DP. 

This class subclasses \hyperlink{classns3_1_1UdpSocket}{ns3\+::\+Udp\+Socket}, and provides a socket interface to \hyperlink{namespacens3}{ns3}\textquotesingle{}s implementation of U\+DP.

For I\+Pv4 packets, the T\+OS is set according to the following rules\+:
\begin{DoxyItemize}
\item if the socket is connected, the T\+OS set for the socket is used
\item if the socket is not connected, the T\+OS specified in the destination address passed to Send\+To is used, while the T\+OS set for the socket is ignored In both cases, a Socket\+Ip\+Tos tag is only added to the packet if the resulting T\+OS is non-\/null. The Bind and Connect operations set the T\+OS for the socket to the value specified in the provided address. If the T\+OS determined for a packet (as described above) is not null, the packet is assigned a priority based on that T\+OS value (according to the \hyperlink{classns3_1_1Socket_a81564620cc94d291f1dc5d79b2f13b4a}{Socket\+::\+Ip\+Tos2\+Priority} function). Otherwise, the priority set for the socket is assigned to the packet. Setting a T\+OS for a socket also sets a priority for the socket (according to the \hyperlink{classns3_1_1Socket_a81564620cc94d291f1dc5d79b2f13b4a}{Socket\+::\+Ip\+Tos2\+Priority} function). A Socket\+Priority tag is only added to the packet if the resulting priority is non-\/null. 
\end{DoxyItemize}

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Udp\+Socket\+Impl@{Udp\+Socket\+Impl}}
\index{Udp\+Socket\+Impl@{Udp\+Socket\+Impl}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Udp\+Socket\+Impl()}{UdpSocketImpl()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Udp\+Socket\+Impl\+::\+Udp\+Socket\+Impl (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UdpSocketImpl_a870b73927cd3bd748da198906b53fb2d}{}\label{classns3_1_1UdpSocketImpl_a870b73927cd3bd748da198906b53fb2d}
Create an unbound udp socket. 
\begin{DoxyCode}
79   : \hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint} (0),
80     \hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6} (0),
81     \hyperlink{classns3_1_1UdpSocketImpl_af6a19247be3d8917b582af77337730c3}{m\_node} (0),
82     \hyperlink{classns3_1_1UdpSocketImpl_ace4b90c1ab6f4f302cdb4cd8da973514}{m\_udp} (0),
83     \hyperlink{classns3_1_1UdpSocketImpl_ac35998e8aa2cc588e21752944b0a0095}{m\_errno} (\hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaaa7eb006d73c5ad0117c5591fcb3469f7}{ERROR\_NOTERROR}),
84     \hyperlink{classns3_1_1UdpSocketImpl_a9ff4985bbd8bdc29bbe36ba0937149fa}{m\_shutdownSend} (\textcolor{keyword}{false}),
85     \hyperlink{classns3_1_1UdpSocketImpl_abda20957e451801973534c38d9d74f4a}{m\_shutdownRecv} (\textcolor{keyword}{false}),
86     \hyperlink{classns3_1_1UdpSocketImpl_a2df1a2df7ba0f4c852ad1d2155b1fbcc}{m\_connected} (\textcolor{keyword}{false}),
87     \hyperlink{classns3_1_1UdpSocketImpl_a73e12067139eb298bbb4b0e2c2e56a6a}{m\_rxAvailable} (0)
88 \{
89   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
90   \hyperlink{classns3_1_1UdpSocketImpl_a071404252802565f1d1511b5c98b155a}{m\_allowBroadcast} = \textcolor{keyword}{false};
91 \}
\end{DoxyCode}
\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!````~Udp\+Socket\+Impl@{$\sim$\+Udp\+Socket\+Impl}}
\index{````~Udp\+Socket\+Impl@{$\sim$\+Udp\+Socket\+Impl}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{$\sim$\+Udp\+Socket\+Impl()}{~UdpSocketImpl()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Udp\+Socket\+Impl\+::$\sim$\+Udp\+Socket\+Impl (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_a47080dd8189ab3065c5093470b123cec}{}\label{classns3_1_1UdpSocketImpl_a47080dd8189ab3065c5093470b123cec}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000066}{Todo}]leave any multicast groups that have been joined \end{DoxyRefDesc}


Note\+: actually this function is called A\+F\+T\+ER \hyperlink{classns3_1_1UdpSocketImpl_ab0f9092f8f28c5d246cae63476215fc8}{Udp\+Socket\+Impl\+::\+Destroy} or \hyperlink{classns3_1_1UdpSocketImpl_a40198099b528e0edbcfa323287c676bd}{Udp\+Socket\+Impl\+::\+Destroy6} so the code below is unnecessary in normal operations

Note that this piece of code is a bit tricky\+: when De\+Allocate is called, it will call into Ipv4\+End\+Point\+Demux\+::\+Deallocate which triggers a delete of the associated end\+Point which triggers in turn a call to the method \hyperlink{classns3_1_1UdpSocketImpl_ab0f9092f8f28c5d246cae63476215fc8}{Udp\+Socket\+Impl\+::\+Destroy} below will will zero the m\+\_\+end\+Point field.

Note that this piece of code is a bit tricky\+: when De\+Allocate is called, it will call into Ipv4\+End\+Point\+Demux\+::\+Deallocate which triggers a delete of the associated end\+Point which triggers in turn a call to the method \hyperlink{classns3_1_1UdpSocketImpl_ab0f9092f8f28c5d246cae63476215fc8}{Udp\+Socket\+Impl\+::\+Destroy} below will will zero the m\+\_\+end\+Point field.
\begin{DoxyCode}
94 \{
95   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
96 
98   \hyperlink{classns3_1_1UdpSocketImpl_af6a19247be3d8917b582af77337730c3}{m\_node} = 0;
104   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint} != 0)
105     \{
106       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1UdpSocketImpl_ace4b90c1ab6f4f302cdb4cd8da973514}{m\_udp} != 0);
115       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint} != 0);
116       \hyperlink{classns3_1_1UdpSocketImpl_ace4b90c1ab6f4f302cdb4cd8da973514}{m\_udp}->DeAllocate (\hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint});
117       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint} == 0);
118     \}
119   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6} != 0)
120     \{
121       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1UdpSocketImpl_ace4b90c1ab6f4f302cdb4cd8da973514}{m\_udp} != 0);
130       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6} != 0);
131       \hyperlink{classns3_1_1UdpSocketImpl_ace4b90c1ab6f4f302cdb4cd8da973514}{m\_udp}->DeAllocate (\hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6});
132       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6} == 0);
133     \}
134   \hyperlink{classns3_1_1UdpSocketImpl_ace4b90c1ab6f4f302cdb4cd8da973514}{m\_udp} = 0;
135 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Bind@{Bind}}
\index{Bind@{Bind}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Bind(void)}{Bind(void)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Udp\+Socket\+Impl\+::\+Bind (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_a02289f4c7fa69580c8426484fe3712c3}{}\label{classns3_1_1UdpSocketImpl_a02289f4c7fa69580c8426484fe3712c3}


Allocate a local I\+Pv4 endpoint for this socket. 

\begin{DoxyReturn}{Returns}
0 on success, -\/1 on failure. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_a680c1edd8b3ec3adf4085e1ded1e8a0d}{ns3\+::\+Socket}.


\begin{DoxyCode}
233 \{
234   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
235   \hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint} = \hyperlink{classns3_1_1UdpSocketImpl_ace4b90c1ab6f4f302cdb4cd8da973514}{m\_udp}->Allocate ();
236   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UdpSocketImpl_ab176a2c5ea5e2ba0431a59cbc423c618}{FinishBind} ();
237 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2




Here is the caller graph for this function\+:
% FIG 3


\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Bind@{Bind}}
\index{Bind@{Bind}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Bind(const Address \&address)}{Bind(const Address &address)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Udp\+Socket\+Impl\+::\+Bind (
\begin{DoxyParamCaption}
\item[{const {\bf Address} \&}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_a27d5153e9d75f95b1c04a74a7527cab1}{}\label{classns3_1_1UdpSocketImpl_a27d5153e9d75f95b1c04a74a7527cab1}


Allocate a local endpoint for this socket. 


\begin{DoxyParams}{Parameters}
{\em address} & the address to try to allocate \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, -\/1 on failure. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_ada93439a43de2028b5a8fc6621dad482}{ns3\+::\+Socket}.


\begin{DoxyCode}
249 \{
250   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << address);
251 
252   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1InetSocketAddress_a9426766e34e928ce5dbdbeb9563a10df}{InetSocketAddress::IsMatchingType} (address))
253     \{
254       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint} == 0, \textcolor{stringliteral}{"Endpoint already allocated (maybe you used
       BindToNetDevice before Bind)."});
255 
256       InetSocketAddress transport = \hyperlink{classns3_1_1InetSocketAddress_ade776b1109e7b9a7be0b22ced49931e3}{InetSocketAddress::ConvertFrom} (address);
257       Ipv4Address ipv4 = transport.GetIpv4 ();
258       uint16\_t \hyperlink{dsdv-manet_8cc_a8e0798404bf2cf5dabb84c5ba9a4f236}{port} = transport.GetPort ();
259       \hyperlink{classns3_1_1Socket_a2a21a2d166ec2adf766b84d984d1cf65}{SetIpTos} (transport.GetTos ());
260       \textcolor{keywordflow}{if} (ipv4 == \hyperlink{classns3_1_1Ipv4Address_a7a39b330c8e701183a411d5779fca1a4}{Ipv4Address::GetAny} () && port == 0)
261         \{
262           \hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint} = \hyperlink{classns3_1_1UdpSocketImpl_ace4b90c1ab6f4f302cdb4cd8da973514}{m\_udp}->Allocate ();
263         \}
264       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ipv4 == \hyperlink{classns3_1_1Ipv4Address_a7a39b330c8e701183a411d5779fca1a4}{Ipv4Address::GetAny} () && port != 0)
265         \{
266           \hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint} = \hyperlink{classns3_1_1UdpSocketImpl_ace4b90c1ab6f4f302cdb4cd8da973514}{m\_udp}->Allocate (port);
267         \}
268       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ipv4 != \hyperlink{classns3_1_1Ipv4Address_a7a39b330c8e701183a411d5779fca1a4}{Ipv4Address::GetAny} () && port == 0)
269         \{
270           \hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint} = \hyperlink{classns3_1_1UdpSocketImpl_ace4b90c1ab6f4f302cdb4cd8da973514}{m\_udp}->Allocate (ipv4);
271         \}
272       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ipv4 != \hyperlink{classns3_1_1Ipv4Address_a7a39b330c8e701183a411d5779fca1a4}{Ipv4Address::GetAny} () && port != 0)
273         \{
274           \hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint} = \hyperlink{classns3_1_1UdpSocketImpl_ace4b90c1ab6f4f302cdb4cd8da973514}{m\_udp}->Allocate (ipv4, port);
275         \}
276       \textcolor{keywordflow}{if} (0 == \hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint})
277         \{
278           \hyperlink{classns3_1_1UdpSocketImpl_ac35998e8aa2cc588e21752944b0a0095}{m\_errno} = port ? \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa5ed359ef348d4ee7d288881b74cca81a}{ERROR\_ADDRINUSE} : 
      \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaae6ddc4aa97ebe6f3f71688337c9d3117}{ERROR\_ADDRNOTAVAIL};
279           \textcolor{keywordflow}{return} -1;
280         \}
281     \}
282   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Inet6SocketAddress_a4d928c54affbfb530a12076d6d7e0540}{Inet6SocketAddress::IsMatchingType} (address))
283     \{
284       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint} == 0, \textcolor{stringliteral}{"Endpoint already allocated (maybe you used
       BindToNetDevice before Bind)."});
285 
286       Inet6SocketAddress transport = \hyperlink{classns3_1_1Inet6SocketAddress_a2177c66e1bcf17c85dcffb9d2a971f5a}{Inet6SocketAddress::ConvertFrom} (
      address);
287       Ipv6Address ipv6 = transport.GetIpv6 ();
288       uint16\_t port = transport.GetPort ();
289       \textcolor{keywordflow}{if} (ipv6 == \hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} () && port == 0)
290         \{
291           \hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6} = \hyperlink{classns3_1_1UdpSocketImpl_ace4b90c1ab6f4f302cdb4cd8da973514}{m\_udp}->Allocate6 ();
292         \}
293       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ipv6 == \hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} () && port != 0)
294         \{
295           \hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6} = \hyperlink{classns3_1_1UdpSocketImpl_ace4b90c1ab6f4f302cdb4cd8da973514}{m\_udp}->Allocate6 (port);
296         \}
297       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ipv6 != \hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} () && port == 0)
298         \{
299           \hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6} = \hyperlink{classns3_1_1UdpSocketImpl_ace4b90c1ab6f4f302cdb4cd8da973514}{m\_udp}->Allocate6 (ipv6);
300         \}
301       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ipv6 != \hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} () && port != 0)
302         \{
303           \hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6} = \hyperlink{classns3_1_1UdpSocketImpl_ace4b90c1ab6f4f302cdb4cd8da973514}{m\_udp}->Allocate6 (ipv6, port);
304         \}
305       \textcolor{keywordflow}{if} (0 == \hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6})
306         \{
307           \hyperlink{classns3_1_1UdpSocketImpl_ac35998e8aa2cc588e21752944b0a0095}{m\_errno} = port ? \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa5ed359ef348d4ee7d288881b74cca81a}{ERROR\_ADDRINUSE} : 
      \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaae6ddc4aa97ebe6f3f71688337c9d3117}{ERROR\_ADDRNOTAVAIL};
308           \textcolor{keywordflow}{return} -1;
309         \}
310       \textcolor{keywordflow}{if} (ipv6.IsMulticast ())
311         \{
312           Ptr<Ipv6L3Protocol> ipv6l3 = \hyperlink{classns3_1_1UdpSocketImpl_af6a19247be3d8917b582af77337730c3}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject} <Ipv6L3Protocol> ();
313           \textcolor{keywordflow}{if} (ipv6l3)
314             \{
315               ipv6l3->AddMulticastAddress (ipv6);
316             \}
317         \}
318     \}
319   \textcolor{keywordflow}{else}
320     \{
321       \hyperlink{group__logging_ga0261a8db1d4ac5f79417d117634fd455}{NS\_LOG\_ERROR} (\textcolor{stringliteral}{"Not IsMatchingType"});
322       \hyperlink{classns3_1_1UdpSocketImpl_ac35998e8aa2cc588e21752944b0a0095}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa4b98dd50740861229f8e03bcc36d379b}{ERROR\_INVAL};
323       \textcolor{keywordflow}{return} -1;
324     \}
325 
326   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UdpSocketImpl_ab176a2c5ea5e2ba0431a59cbc423c618}{FinishBind} ();
327 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4


\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Bind6@{Bind6}}
\index{Bind6@{Bind6}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Bind6(void)}{Bind6(void)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Udp\+Socket\+Impl\+::\+Bind6 (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_a32b33c7a08d81248b1579882cebadcb6}{}\label{classns3_1_1UdpSocketImpl_a32b33c7a08d81248b1579882cebadcb6}


Allocate a local I\+Pv6 endpoint for this socket. 

\begin{DoxyReturn}{Returns}
0 on success, -\/1 on failure. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_a68a4f2bcd38dec94d5a6fd4d867a1f19}{ns3\+::\+Socket}.


\begin{DoxyCode}
241 \{
242   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
243   \hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6} = \hyperlink{classns3_1_1UdpSocketImpl_ace4b90c1ab6f4f302cdb4cd8da973514}{m\_udp}->Allocate6 ();
244   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UdpSocketImpl_ab176a2c5ea5e2ba0431a59cbc423c618}{FinishBind} ();
245 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5




Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Bind\+To\+Net\+Device@{Bind\+To\+Net\+Device}}
\index{Bind\+To\+Net\+Device@{Bind\+To\+Net\+Device}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Bind\+To\+Net\+Device(\+Ptr$<$ Net\+Device $>$ netdevice)}{BindToNetDevice(Ptr< NetDevice > netdevice)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Udp\+Socket\+Impl\+::\+Bind\+To\+Net\+Device (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{netdevice}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_a93fa14afedc32353602551df1e5f2d59}{}\label{classns3_1_1UdpSocketImpl_a93fa14afedc32353602551df1e5f2d59}


Bind a socket to specific device. 

This method corresponds to using setsockopt() S\+O\+\_\+\+B\+I\+N\+D\+T\+O\+D\+E\+V\+I\+CE of real network or B\+SD sockets. If set on a socket, this option will force packets to leave the bound device regardless of the device that IP routing would naturally choose. In the receive direction, only packets received from the bound interface will be delivered.

This option has no particular relationship to binding sockets to an address via \hyperlink{classns3_1_1Socket_ada93439a43de2028b5a8fc6621dad482}{Socket\+::\+Bind} (). It is possible to bind sockets to a specific IP address on the bound interface by calling both \hyperlink{classns3_1_1Socket_ada93439a43de2028b5a8fc6621dad482}{Socket\+::\+Bind} (address) and \hyperlink{classns3_1_1Socket_a9952cd10a2c8c108846027108cc9e44e}{Socket\+::\+Bind\+To\+Net\+Device} (device), but it is also possible to bind to mismatching device and address, even if the socket can not receive any packets as a result.

\begin{DoxyWarning}{Warning}
Bind\+To\+Net\+Device should be used {\itshape after} Bind. Otherwise it will perform a Bind itself.
\end{DoxyWarning}

\begin{DoxyParams}{Parameters}
{\em netdevice} & Pointer to Netdevice of desired interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
nothing 
\end{DoxyReturn}


Reimplemented from \hyperlink{classns3_1_1Socket_a9952cd10a2c8c108846027108cc9e44e}{ns3\+::\+Socket}.


\begin{DoxyCode}
949 \{
950   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (netdevice);
951 
952   \hyperlink{classns3_1_1Socket_a9952cd10a2c8c108846027108cc9e44e}{Socket::BindToNetDevice} (netdevice); \textcolor{comment}{// Includes sanity check}
953   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint} == 0)
954     \{
955       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_a02289f4c7fa69580c8426484fe3712c3}{Bind} () == -1)
956         \{
957           \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint} == 0);
958           \textcolor{keywordflow}{return};
959         \}
960       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint} != 0);
961     \}
962   \hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint}->\hyperlink{classns3_1_1Ipv4EndPoint_a0f4a3c34e81be074385dbbb7c19e17b6}{BindToNetDevice} (netdevice);
963 
964   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6} == 0)
965     \{
966       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_a32b33c7a08d81248b1579882cebadcb6}{Bind6} () == -1)
967         \{
968           \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6} == 0);
969           \textcolor{keywordflow}{return};
970         \}
971       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6} != 0);
972     \}
973   \hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6}->\hyperlink{classns3_1_1Ipv6EndPoint_aa8bfe996727cd7064564a9fbd34cd0f5}{BindToNetDevice} (netdevice);
974 
975   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6}->\hyperlink{classns3_1_1Ipv6EndPoint_a1972cd26240d42cd75f93e12d9182976}{GetLocalAddress} ().\hyperlink{classns3_1_1Ipv6Address_a0657bb007d3c5618f3f6000b5054df72}{IsMulticast} ())
976     \{
977       Ptr<Ipv6L3Protocol> ipv6l3 = \hyperlink{classns3_1_1UdpSocketImpl_af6a19247be3d8917b582af77337730c3}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject} <Ipv6L3Protocol> ();
978       \textcolor{keywordflow}{if} (ipv6l3)
979         \{
980           uint32\_t index = ipv6l3->GetInterfaceForDevice (netdevice);
981           ipv6l3->RemoveMulticastAddress (\hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6}->
      \hyperlink{classns3_1_1Ipv6EndPoint_a1972cd26240d42cd75f93e12d9182976}{GetLocalAddress} ());
982           ipv6l3->AddMulticastAddress (\hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6}->\hyperlink{classns3_1_1Ipv6EndPoint_a1972cd26240d42cd75f93e12d9182976}{GetLocalAddress} (), index);
983         \}
984     \}
985 
986   \textcolor{keywordflow}{return};
987 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7


\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Close@{Close}}
\index{Close@{Close}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Close(void)}{Close(void)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Udp\+Socket\+Impl\+::\+Close (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_a9e81e9e088339d3608560afabf2d5f49}{}\label{classns3_1_1UdpSocketImpl_a9e81e9e088339d3608560afabf2d5f49}


Close a socket. 

\begin{DoxyReturn}{Returns}
zero on success, -\/1 on failure.
\end{DoxyReturn}
After the Close call, the socket is no longer valid, and cannot safely be used for subsequent operations. 

Implements \hyperlink{classns3_1_1Socket_abdac6e2498c5aa2963ef361d4200ddf3}{ns3\+::\+Socket}.


\begin{DoxyCode}
355 \{
356   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
357   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_abda20957e451801973534c38d9d74f4a}{m\_shutdownRecv} == \textcolor{keyword}{true} && \hyperlink{classns3_1_1UdpSocketImpl_a9ff4985bbd8bdc29bbe36ba0937149fa}{m\_shutdownSend} == \textcolor{keyword}{true})
358     \{
359       \hyperlink{classns3_1_1UdpSocketImpl_ac35998e8aa2cc588e21752944b0a0095}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa9d232a0dd40ca7e637e974b88b973db9}{Socket::ERROR\_BADF};
360       \textcolor{keywordflow}{return} -1;
361     \}
362   \hyperlink{classns3_1_1Socket_af70f1ddca0d73f98103a2b86bec4c85e}{Ipv6LeaveGroup} ();
363   \hyperlink{classns3_1_1UdpSocketImpl_abda20957e451801973534c38d9d74f4a}{m\_shutdownRecv} = \textcolor{keyword}{true};
364   \hyperlink{classns3_1_1UdpSocketImpl_a9ff4985bbd8bdc29bbe36ba0937149fa}{m\_shutdownSend} = \textcolor{keyword}{true};
365   \hyperlink{classns3_1_1UdpSocketImpl_a06e34674acd7ec7f6c186e52767cdf2c}{DeallocateEndPoint} ();
366   \textcolor{keywordflow}{return} 0;
367 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8


\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Connect@{Connect}}
\index{Connect@{Connect}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Connect(const Address \&address)}{Connect(const Address &address)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Udp\+Socket\+Impl\+::\+Connect (
\begin{DoxyParamCaption}
\item[{const {\bf Address} \&}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_a83f8fca9d8a21edeba0016d6de68fbf5}{}\label{classns3_1_1UdpSocketImpl_a83f8fca9d8a21edeba0016d6de68fbf5}


Initiate a connection to a remote host. 


\begin{DoxyParams}{Parameters}
{\em address} & \hyperlink{classns3_1_1Address}{Address} of remote. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, -\/1 on error (in which case errno is set). 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_a97f08aaf37b8fd7d4b5cad4dfdd4022a}{ns3\+::\+Socket}.


\begin{DoxyCode}
371 \{
372   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << address);
373   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1InetSocketAddress_a9426766e34e928ce5dbdbeb9563a10df}{InetSocketAddress::IsMatchingType}(address) == \textcolor{keyword}{true})
374     \{
375       InetSocketAddress transport = \hyperlink{classns3_1_1InetSocketAddress_ade776b1109e7b9a7be0b22ced49931e3}{InetSocketAddress::ConvertFrom} (address);
376       \hyperlink{classns3_1_1UdpSocketImpl_a820bb30415d2627cea60338649d19ccb}{m\_defaultAddress} = Address(transport.GetIpv4 ());
377       \hyperlink{classns3_1_1UdpSocketImpl_a990120b2cc768c47a6a2a2a1e53875c8}{m\_defaultPort} = transport.GetPort ();
378       \hyperlink{classns3_1_1Socket_a2a21a2d166ec2adf766b84d984d1cf65}{SetIpTos} (transport.GetTos ());
379       \hyperlink{classns3_1_1UdpSocketImpl_a2df1a2df7ba0f4c852ad1d2155b1fbcc}{m\_connected} = \textcolor{keyword}{true};
380       \hyperlink{classns3_1_1Socket_a2f55d195304131b356818bc74134c5a7}{NotifyConnectionSucceeded} ();
381     \}
382   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Inet6SocketAddress_a4d928c54affbfb530a12076d6d7e0540}{Inet6SocketAddress::IsMatchingType}(address) == \textcolor{keyword}{true})
383     \{
384       Inet6SocketAddress transport = \hyperlink{classns3_1_1Inet6SocketAddress_a2177c66e1bcf17c85dcffb9d2a971f5a}{Inet6SocketAddress::ConvertFrom} (
      address);
385       \hyperlink{classns3_1_1UdpSocketImpl_a820bb30415d2627cea60338649d19ccb}{m\_defaultAddress} = Address(transport.GetIpv6 ());
386       m\_defaultPort = transport.GetPort ();
387       \hyperlink{classns3_1_1UdpSocketImpl_a2df1a2df7ba0f4c852ad1d2155b1fbcc}{m\_connected} = \textcolor{keyword}{true};
388       \hyperlink{classns3_1_1Socket_a2f55d195304131b356818bc74134c5a7}{NotifyConnectionSucceeded} ();
389     \}
390   \textcolor{keywordflow}{else}
391     \{
392       \hyperlink{classns3_1_1Socket_a34f83cdc8fb487ac8ea5436d184827c4}{NotifyConnectionFailed} ();
393       \textcolor{keywordflow}{return} -1;
394     \}
395 
396   \textcolor{keywordflow}{return} 0;
397 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9


\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Deallocate\+End\+Point@{Deallocate\+End\+Point}}
\index{Deallocate\+End\+Point@{Deallocate\+End\+Point}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Deallocate\+End\+Point(void)}{DeallocateEndPoint(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Udp\+Socket\+Impl\+::\+Deallocate\+End\+Point (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_a06e34674acd7ec7f6c186e52767cdf2c}{}\label{classns3_1_1UdpSocketImpl_a06e34674acd7ec7f6c186e52767cdf2c}


Deallocate m\+\_\+end\+Point and m\+\_\+end\+Point6. 


\begin{DoxyCode}
189 \{
190   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint} != 0)
191     \{
192       \hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint}->\hyperlink{classns3_1_1Ipv4EndPoint_a19ec16d98c501d3684e6549d7296ea0a}{SetDestroyCallback} (MakeNullCallback<void> ());
193       \hyperlink{classns3_1_1UdpSocketImpl_ace4b90c1ab6f4f302cdb4cd8da973514}{m\_udp}->DeAllocate (\hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint});
194       \hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint} = 0;
195     \}
196   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6} != 0)
197     \{
198       \hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6}->\hyperlink{classns3_1_1Ipv6EndPoint_af2922ef8f9f9ead0a2604c8391e90328}{SetDestroyCallback} (MakeNullCallback<void> ());
199       \hyperlink{classns3_1_1UdpSocketImpl_ace4b90c1ab6f4f302cdb4cd8da973514}{m\_udp}->DeAllocate (\hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6});
200       \hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6} = 0;
201     \}
202 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10




Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Destroy@{Destroy}}
\index{Destroy@{Destroy}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Destroy(void)}{Destroy(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Udp\+Socket\+Impl\+::\+Destroy (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_ab0f9092f8f28c5d246cae63476215fc8}{}\label{classns3_1_1UdpSocketImpl_ab0f9092f8f28c5d246cae63476215fc8}


Kill this socket by zeroing its attributes (I\+Pv4) 

This is a callback function configured to m\+\_\+endpoint in Setup\+Callback(), invoked when the endpoint is destroyed. 
\begin{DoxyCode}
174 \{
175   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
176   \hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint} = 0;
177 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 12


\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Destroy6@{Destroy6}}
\index{Destroy6@{Destroy6}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Destroy6(void)}{Destroy6(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Udp\+Socket\+Impl\+::\+Destroy6 (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_a40198099b528e0edbcfa323287c676bd}{}\label{classns3_1_1UdpSocketImpl_a40198099b528e0edbcfa323287c676bd}


Kill this socket by zeroing its attributes (I\+Pv6) 

This is a callback function configured to m\+\_\+endpoint in Setup\+Callback(), invoked when the endpoint is destroyed. 
\begin{DoxyCode}
181 \{
182   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
183   \hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6} = 0;
184 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 13


\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Do\+Send@{Do\+Send}}
\index{Do\+Send@{Do\+Send}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Do\+Send(\+Ptr$<$ Packet $>$ p)}{DoSend(Ptr< Packet > p)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Udp\+Socket\+Impl\+::\+Do\+Send (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_aeb7a2f7998edd56c9079ac6a3518cd89}{}\label{classns3_1_1UdpSocketImpl_aeb7a2f7998edd56c9079ac6a3518cd89}


Send a packet. 


\begin{DoxyParams}{Parameters}
{\em p} & packet \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, -\/1 on failure 
\end{DoxyReturn}

\begin{DoxyCode}
422 \{
423   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << p);
424   \textcolor{keywordflow}{if} ((\hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint} == 0) && (\hyperlink{classns3_1_1Ipv4Address_a7129db5e08739783b300976d28c0ced3}{Ipv4Address::IsMatchingType}(
      \hyperlink{classns3_1_1UdpSocketImpl_a820bb30415d2627cea60338649d19ccb}{m\_defaultAddress}) == \textcolor{keyword}{true}))
425     \{
426       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_a02289f4c7fa69580c8426484fe3712c3}{Bind} () == -1)
427         \{
428           \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint} == 0);
429           \textcolor{keywordflow}{return} -1;
430         \}
431       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint} != 0);
432     \}
433   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((\hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6} == 0) && (\hyperlink{classns3_1_1Ipv6Address_adbe329370b5a8f7c0f48659d6439dfd1}{Ipv6Address::IsMatchingType}(
      \hyperlink{classns3_1_1UdpSocketImpl_a820bb30415d2627cea60338649d19ccb}{m\_defaultAddress}) == \textcolor{keyword}{true}))
434     \{
435       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_a32b33c7a08d81248b1579882cebadcb6}{Bind6} () == -1)
436         \{
437           \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6} == 0);
438           \textcolor{keywordflow}{return} -1;
439         \}
440       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6} != 0);
441     \}
442   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_a9ff4985bbd8bdc29bbe36ba0937149fa}{m\_shutdownSend})
443     \{
444       \hyperlink{classns3_1_1UdpSocketImpl_ac35998e8aa2cc588e21752944b0a0095}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa471b853a7aed4ec0c5c64b0c5ad8e521}{ERROR\_SHUTDOWN};
445       \textcolor{keywordflow}{return} -1;
446     \} 
447 
448   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4Address_a7129db5e08739783b300976d28c0ced3}{Ipv4Address::IsMatchingType} (\hyperlink{classns3_1_1UdpSocketImpl_a820bb30415d2627cea60338649d19ccb}{m\_defaultAddress}))
449     \{
450       \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UdpSocketImpl_a18b22c398f6e9a7806f92b6a3ca7b3e8}{DoSendTo} (p, \hyperlink{classns3_1_1Ipv4Address_a5fd4a8f0f7bb75e35dad3d401ef4cbc1}{Ipv4Address::ConvertFrom} (
      \hyperlink{classns3_1_1UdpSocketImpl_a820bb30415d2627cea60338649d19ccb}{m\_defaultAddress}), \hyperlink{classns3_1_1UdpSocketImpl_a990120b2cc768c47a6a2a2a1e53875c8}{m\_defaultPort}, \hyperlink{classns3_1_1Socket_a95bd4732074d3d26d4a6949fc3499ccb}{GetIpTos} ());
451     \}
452   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6Address_adbe329370b5a8f7c0f48659d6439dfd1}{Ipv6Address::IsMatchingType} (
      \hyperlink{classns3_1_1UdpSocketImpl_a820bb30415d2627cea60338649d19ccb}{m\_defaultAddress}))
453     \{
454       \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UdpSocketImpl_a18b22c398f6e9a7806f92b6a3ca7b3e8}{DoSendTo} (p, \hyperlink{classns3_1_1Ipv6Address_ac00bc221a0b226b2090d05468aec4b79}{Ipv6Address::ConvertFrom} (
      \hyperlink{classns3_1_1UdpSocketImpl_a820bb30415d2627cea60338649d19ccb}{m\_defaultAddress}), \hyperlink{classns3_1_1UdpSocketImpl_a990120b2cc768c47a6a2a2a1e53875c8}{m\_defaultPort});
455     \}
456 
457   \hyperlink{classns3_1_1UdpSocketImpl_ac35998e8aa2cc588e21752944b0a0095}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa7f4cc7185e365fb30fc5e2a4ec9f1c24}{ERROR\_AFNOSUPPORT};
458   \textcolor{keywordflow}{return}(-1);
459 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 14




Here is the caller graph for this function\+:
% FIG 15


\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Do\+Send\+To@{Do\+Send\+To}}
\index{Do\+Send\+To@{Do\+Send\+To}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Do\+Send\+To(\+Ptr$<$ Packet $>$ p, Ipv4\+Address daddr, uint16\+\_\+t dport, uint8\+\_\+t tos)}{DoSendTo(Ptr< Packet > p, Ipv4Address daddr, uint16_t dport, uint8_t tos)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Udp\+Socket\+Impl\+::\+Do\+Send\+To (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{{\bf Ipv4\+Address}}]{daddr, }
\item[{uint16\+\_\+t}]{dport, }
\item[{uint8\+\_\+t}]{tos}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_a18b22c398f6e9a7806f92b6a3ca7b3e8}{}\label{classns3_1_1UdpSocketImpl_a18b22c398f6e9a7806f92b6a3ca7b3e8}


Send a packet to a specific destination and port (I\+Pv4) 


\begin{DoxyParams}{Parameters}
{\em p} & packet \\
\hline
{\em daddr} & destination address \\
\hline
{\em dport} & destination port \\
\hline
{\em tos} & ToS \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, -\/1 on failure 
\end{DoxyReturn}
std\+::cout $<$$<$ \char`\"{}hiee-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/\char`\"{} $<$$<$ std\+::endl; 
\begin{DoxyCode}
463 \{
464   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << p << dest << \hyperlink{dsdv-manet_8cc_a8e0798404bf2cf5dabb84c5ba9a4f236}{port} << (uint16\_t) tos);
465   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Socket_a9781d8dfdb5e9364d5dce8f53b768bb5}{m\_boundnetdevice})
466     \{
467       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Bound interface number "} << \hyperlink{classns3_1_1Socket_a9781d8dfdb5e9364d5dce8f53b768bb5}{m\_boundnetdevice}->GetIfIndex (
      ));
468     \}
469   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint} == 0)
470     \{
471       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_a02289f4c7fa69580c8426484fe3712c3}{Bind} () == -1)
472         \{
473           \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint} == 0);
474           \textcolor{keywordflow}{return} -1;
475         \}
476       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint} != 0);
477     \}
478   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_a9ff4985bbd8bdc29bbe36ba0937149fa}{m\_shutdownSend})
479     \{
480       \hyperlink{classns3_1_1UdpSocketImpl_ac35998e8aa2cc588e21752944b0a0095}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa471b853a7aed4ec0c5c64b0c5ad8e521}{ERROR\_SHUTDOWN};
481       \textcolor{keywordflow}{return} -1;
482     \}
483 
484   \textcolor{keywordflow}{if} (p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} () > \hyperlink{classns3_1_1UdpSocketImpl_a70191d0578ae26233f569631a26d608b}{GetTxAvailable} () )
485     \{
486       \hyperlink{classns3_1_1UdpSocketImpl_ac35998e8aa2cc588e21752944b0a0095}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaaeba174dbfeaed34194ce9463f6a469f1}{ERROR\_MSGSIZE};
487       \textcolor{keywordflow}{return} -1;
488     \}
489 
490   uint8\_t priority = \hyperlink{classns3_1_1Socket_a3e4788d61c0e841ccaa1c7fce6fda2c1}{GetPriority} ();
491   \textcolor{keywordflow}{if} (tos)
492     \{
493       SocketIpTosTag ipTosTag;
494       ipTosTag.SetTos (tos);
495       \textcolor{comment}{// This packet may already have a SocketIpTosTag (see BUG 2440)}
496       p->\hyperlink{classns3_1_1Packet_afb014ae9f4adddbfc51c64b085bfd405}{ReplacePacketTag} (ipTosTag);
497       priority = \hyperlink{classns3_1_1Socket_a81564620cc94d291f1dc5d79b2f13b4a}{IpTos2Priority} (tos);
498     \}
499 
500   \textcolor{keywordflow}{if} (priority)
501     \{
502       SocketPriorityTag priorityTag;
503       priorityTag.SetPriority (priority);
504       p->\hyperlink{classns3_1_1Packet_afb014ae9f4adddbfc51c64b085bfd405}{ReplacePacketTag} (priorityTag);
505     \}
506 
507   Ptr<Ipv4> ipv4 = \hyperlink{classns3_1_1UdpSocketImpl_af6a19247be3d8917b582af77337730c3}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv4> ();
508  \textcolor{comment}{// std::cout << "hiee---------------1" << std::endl;}
510 \textcolor{comment}{}  \textcolor{comment}{// Locally override the IP TTL for this socket}
511   \textcolor{comment}{// We cannot directly modify the TTL at this stage, so we set a Packet tag}
512   \textcolor{comment}{// The destination can be either multicast, unicast/anycast, or}
513   \textcolor{comment}{// either all-hosts broadcast or limited (subnet-directed) broadcast.}
514   \textcolor{comment}{// For the latter two broadcast types, the TTL will later be set to one}
515   \textcolor{comment}{// irrespective of what is set in these socket options.  So, this tagging}
516   \textcolor{comment}{// may end up setting the TTL of a limited broadcast packet to be}
517   \textcolor{comment}{// the same as a unicast, but it will be fixed further down the stack}
518   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_a4849465356cef8573ed373d12a5a62ec}{m\_ipMulticastTtl} != 0 && dest.IsMulticast ())
519     \{
520       SocketIpTtlTag tag;
521       tag.SetTtl (\hyperlink{classns3_1_1UdpSocketImpl_a4849465356cef8573ed373d12a5a62ec}{m\_ipMulticastTtl});
522       p->\hyperlink{classns3_1_1Packet_a7400b8655852f5271c5957250d0141af}{AddPacketTag} (tag);
523     \}
524   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Socket_afbbd0ecd7cda631cafc80eda33aa0b2c}{IsManualIpTtl} () && \hyperlink{classns3_1_1Socket_adf6420d12b8a0b6a20e46c37fe48830d}{GetIpTtl} () != 0 && !dest.IsMulticast () && !dest.
      IsBroadcast ())
525     \{
526       SocketIpTtlTag tag;
527       tag.SetTtl (\hyperlink{classns3_1_1Socket_adf6420d12b8a0b6a20e46c37fe48830d}{GetIpTtl} ());
528       p->\hyperlink{classns3_1_1Packet_a7400b8655852f5271c5957250d0141af}{AddPacketTag} (tag);
529     \}
530   \{
531     SocketSetDontFragmentTag tag;
532     \textcolor{keywordtype}{bool} found = p->\hyperlink{classns3_1_1Packet_a078fe922d976a417ab25ba2f3c2fd667}{RemovePacketTag} (tag);
533     \textcolor{keywordflow}{if} (!found)
534       \{
535         \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_ab5ae932e01b5746539b9ad20b3ff4f46}{m\_mtuDiscover})
536           \{
537             tag.Enable ();
538           \}
539         \textcolor{keywordflow}{else}
540           \{
541             tag.Disable ();
542           \}
543         p->\hyperlink{classns3_1_1Packet_a7400b8655852f5271c5957250d0141af}{AddPacketTag} (tag);
544       \}
545   \}
546   \textcolor{comment}{//}
547   \textcolor{comment}{// If dest is set to the limited broadcast address (all ones),}
548   \textcolor{comment}{// convert it to send a copy of the packet out of every }
549   \textcolor{comment}{// interface as a subnet-directed broadcast.}
550   \textcolor{comment}{// Exception:  if the interface has a /32 address, there is no}
551   \textcolor{comment}{// valid subnet-directed broadcast, so send it as limited broadcast}
552   \textcolor{comment}{// Note also that some systems will only send limited broadcast packets}
553   \textcolor{comment}{// out of the "default" interface; here we send it out all interfaces}
554   \textcolor{comment}{//}
555   \textcolor{keywordflow}{if} (dest.IsBroadcast ())
556     \{
557       \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1UdpSocketImpl_a071404252802565f1d1511b5c98b155a}{m\_allowBroadcast})
558         \{
559           \hyperlink{classns3_1_1UdpSocketImpl_ac35998e8aa2cc588e21752944b0a0095}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa777b6c9712ef5485ebecfb96d5de4d54}{ERROR\_OPNOTSUPP};
560           \textcolor{keywordflow}{return} -1;
561         \}
562       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Limited broadcast start."});
563       \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < ipv4->GetNInterfaces (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++ )
564         \{
565           \textcolor{comment}{// Get the primary address}
566           Ipv4InterfaceAddress iaddr = ipv4->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, 0);
567           Ipv4Address addri = iaddr.GetLocal ();
568           \textcolor{keywordflow}{if} (addri == Ipv4Address (\textcolor{stringliteral}{"127.0.0.1"}))
569             \textcolor{keywordflow}{continue};
570           \textcolor{comment}{// Check if interface-bound socket}
571           \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Socket_a9781d8dfdb5e9364d5dce8f53b768bb5}{m\_boundnetdevice}) 
572             \{
573               \textcolor{keywordflow}{if} (ipv4->GetNetDevice (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) != \hyperlink{classns3_1_1Socket_a9781d8dfdb5e9364d5dce8f53b768bb5}{m\_boundnetdevice})
574                 \textcolor{keywordflow}{continue};
575             \}
576           Ipv4Mask maski = iaddr.GetMask ();
577           \textcolor{keywordflow}{if} (maski == \hyperlink{classns3_1_1Ipv4Mask_af712cbdf28c039025d4aa45fa7e243dd}{Ipv4Mask::GetOnes} ())
578             \{
579               \textcolor{comment}{// if the network mask is 255.255.255.255, do not convert dest}
580               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Sending one copy from "} << addri << \textcolor{stringliteral}{" to "} << dest
581                                                      << \textcolor{stringliteral}{" (mask is "} << maski << \textcolor{stringliteral}{")"});
582               \hyperlink{classns3_1_1UdpSocketImpl_ace4b90c1ab6f4f302cdb4cd8da973514}{m\_udp}->Send (p->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} (), addri, dest,
583                            \hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint}->\hyperlink{classns3_1_1Ipv4EndPoint_aab137f64770abf94f0b8a81217a0b106}{GetLocalPort} (), 
      \hyperlink{dsdv-manet_8cc_a8e0798404bf2cf5dabb84c5ba9a4f236}{port});
584               \hyperlink{classns3_1_1Socket_ae478fc503f7041a1da5e9db361f1ae20}{NotifyDataSent} (p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ());
585               \hyperlink{classns3_1_1Socket_a34cd5de5b9feeadd6ba8973b954c3d5f}{NotifySend} (\hyperlink{classns3_1_1UdpSocketImpl_a70191d0578ae26233f569631a26d608b}{GetTxAvailable} ());
586             \}
587           \textcolor{keywordflow}{else}
588             \{
589               \textcolor{comment}{// Convert to subnet-directed broadcast}
590               Ipv4Address bcast = addri.GetSubnetDirectedBroadcast (maski);
591               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Sending one copy from "} << addri << \textcolor{stringliteral}{" to "} << bcast
592                                                      << \textcolor{stringliteral}{" (mask is "} << maski << \textcolor{stringliteral}{")"});
593               \hyperlink{classns3_1_1UdpSocketImpl_ace4b90c1ab6f4f302cdb4cd8da973514}{m\_udp}->Send (p->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} (), addri, bcast,
594                            \hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint}->\hyperlink{classns3_1_1Ipv4EndPoint_aab137f64770abf94f0b8a81217a0b106}{GetLocalPort} (), 
      \hyperlink{dsdv-manet_8cc_a8e0798404bf2cf5dabb84c5ba9a4f236}{port});
595               \hyperlink{classns3_1_1Socket_ae478fc503f7041a1da5e9db361f1ae20}{NotifyDataSent} (p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ());
596               \hyperlink{classns3_1_1Socket_a34cd5de5b9feeadd6ba8973b954c3d5f}{NotifySend} (\hyperlink{classns3_1_1UdpSocketImpl_a70191d0578ae26233f569631a26d608b}{GetTxAvailable} ());
597             \}
598         \}
599       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Limited broadcast end."});
600       \textcolor{keywordflow}{return} p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ();
601     \}
602   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint}->\hyperlink{classns3_1_1Ipv4EndPoint_ae08283e26ace5880c3172ea5d803b6f8}{GetLocalAddress} () != 
      \hyperlink{classns3_1_1Ipv4Address_a7a39b330c8e701183a411d5779fca1a4}{Ipv4Address::GetAny} ())
603     \{
604       \hyperlink{classns3_1_1UdpSocketImpl_ace4b90c1ab6f4f302cdb4cd8da973514}{m\_udp}->Send (p->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} (), \hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint}->\hyperlink{classns3_1_1Ipv4EndPoint_ae08283e26ace5880c3172ea5d803b6f8}{GetLocalAddress} (), dest,
605                    \hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint}->\hyperlink{classns3_1_1Ipv4EndPoint_aab137f64770abf94f0b8a81217a0b106}{GetLocalPort} (), \hyperlink{dsdv-manet_8cc_a8e0798404bf2cf5dabb84c5ba9a4f236}{port}, 0);
606       \hyperlink{classns3_1_1Socket_ae478fc503f7041a1da5e9db361f1ae20}{NotifyDataSent} (p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ());
607       \hyperlink{classns3_1_1Socket_a34cd5de5b9feeadd6ba8973b954c3d5f}{NotifySend} (\hyperlink{classns3_1_1UdpSocketImpl_a70191d0578ae26233f569631a26d608b}{GetTxAvailable} ());
608      \textcolor{comment}{// std::cout << "hiee---------------1--1" << std::endl;}
609 
610       \textcolor{keywordflow}{return} p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ();
611     \}
612   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ipv4->GetRoutingProtocol () != 0)
613     \{
614       Ipv4Header header;
615       header.SetDestination (dest);
616       header.SetProtocol (\hyperlink{classns3_1_1UdpL4Protocol_ad370801b3d1a166e831020a777c41047}{UdpL4Protocol::PROT\_NUMBER});
617       \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket::SocketErrno} errno\_;
618       Ptr<Ipv4Route> route;
619       Ptr<NetDevice> oif = \hyperlink{classns3_1_1Socket_a9781d8dfdb5e9364d5dce8f53b768bb5}{m\_boundnetdevice}; \textcolor{comment}{//specify non-zero if bound to a specific
       device}
620       \textcolor{comment}{// TBD-- we could cache the route and just check its validity}
621       route = ipv4->GetRoutingProtocol ()->RouteOutput (p, header, oif, errno\_); 
622       \textcolor{keywordflow}{if} (route != 0)
623         \{
624           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Route exists"});
625           \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1UdpSocketImpl_a071404252802565f1d1511b5c98b155a}{m\_allowBroadcast})
626             \{
627               uint32\_t outputIfIndex = ipv4->GetInterfaceForDevice (route->GetOutputDevice ());
628               uint32\_t ifNAddr = ipv4->GetNAddresses (outputIfIndex);
629               \textcolor{keywordflow}{for} (uint32\_t addrI = 0; addrI < ifNAddr; ++addrI)
630                 \{
631                   Ipv4InterfaceAddress ifAddr = ipv4->GetAddress (outputIfIndex, addrI);
632                   \textcolor{keywordflow}{if} (dest == ifAddr.GetBroadcast ())
633                     \{
634                       \hyperlink{classns3_1_1UdpSocketImpl_ac35998e8aa2cc588e21752944b0a0095}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa777b6c9712ef5485ebecfb96d5de4d54}{ERROR\_OPNOTSUPP};
635                       \textcolor{keywordflow}{return} -1;
636                     \}
637                 \}
638             \}
639 
640           header.SetSource (route->GetSource ());
641           \hyperlink{classns3_1_1UdpSocketImpl_ace4b90c1ab6f4f302cdb4cd8da973514}{m\_udp}->Send (p->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} (), header.GetSource (), header.GetDestination (),
642                        \hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint}->\hyperlink{classns3_1_1Ipv4EndPoint_aab137f64770abf94f0b8a81217a0b106}{GetLocalPort} (), \hyperlink{dsdv-manet_8cc_a8e0798404bf2cf5dabb84c5ba9a4f236}{port}, route);
643           \hyperlink{classns3_1_1Socket_ae478fc503f7041a1da5e9db361f1ae20}{NotifyDataSent} (p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ());
644           \textcolor{keywordflow}{return} p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ();
645         \}
646       \textcolor{keywordflow}{else} 
647         \{
648           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"No route to destination"});
649           \hyperlink{group__logging_ga0261a8db1d4ac5f79417d117634fd455}{NS\_LOG\_ERROR} (errno\_);
650           \hyperlink{classns3_1_1UdpSocketImpl_ac35998e8aa2cc588e21752944b0a0095}{m\_errno} = errno\_;
651           \textcolor{keywordflow}{return} -1;
652         \}
653     \}
654   \textcolor{keywordflow}{else}
655     \{
656       \hyperlink{group__logging_ga0261a8db1d4ac5f79417d117634fd455}{NS\_LOG\_ERROR} (\textcolor{stringliteral}{"ERROR\_NOROUTETOHOST"});
657       \hyperlink{classns3_1_1UdpSocketImpl_ac35998e8aa2cc588e21752944b0a0095}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{ERROR\_NOROUTETOHOST};
658       \textcolor{keywordflow}{return} -1;
659     \}
660   \textcolor{comment}{//std::cout << "hiee---------------2" << std::endl;}
661   \textcolor{keywordflow}{return} 0;
662 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 16




Here is the caller graph for this function\+:
% FIG 17


\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Do\+Send\+To@{Do\+Send\+To}}
\index{Do\+Send\+To@{Do\+Send\+To}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Do\+Send\+To(\+Ptr$<$ Packet $>$ p, Ipv6\+Address daddr, uint16\+\_\+t dport)}{DoSendTo(Ptr< Packet > p, Ipv6Address daddr, uint16_t dport)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Udp\+Socket\+Impl\+::\+Do\+Send\+To (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{{\bf Ipv6\+Address}}]{daddr, }
\item[{uint16\+\_\+t}]{dport}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_a4c3672c1127cbe31678d8d18751d3f4c}{}\label{classns3_1_1UdpSocketImpl_a4c3672c1127cbe31678d8d18751d3f4c}


Send a packet to a specific destination and port (I\+Pv6) 


\begin{DoxyParams}{Parameters}
{\em p} & packet \\
\hline
{\em daddr} & destination address \\
\hline
{\em dport} & destination port \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, -\/1 on failure 
\end{DoxyReturn}

\begin{DoxyCode}
666 \{
667   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << p << dest << \hyperlink{dsdv-manet_8cc_a8e0798404bf2cf5dabb84c5ba9a4f236}{port});
668 
669   \textcolor{keywordflow}{if} (dest.IsIpv4MappedAddress ())
670     \{
671         \textcolor{keywordflow}{return} (\hyperlink{classns3_1_1UdpSocketImpl_a18b22c398f6e9a7806f92b6a3ca7b3e8}{DoSendTo}(p, dest.GetIpv4MappedAddress (), \hyperlink{dsdv-manet_8cc_a8e0798404bf2cf5dabb84c5ba9a4f236}{port}, 0));
672     \}
673   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Socket_a9781d8dfdb5e9364d5dce8f53b768bb5}{m\_boundnetdevice})
674     \{
675       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Bound interface number "} << \hyperlink{classns3_1_1Socket_a9781d8dfdb5e9364d5dce8f53b768bb5}{m\_boundnetdevice}->GetIfIndex (
      ));
676     \}
677   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6} == 0)
678     \{
679       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_a32b33c7a08d81248b1579882cebadcb6}{Bind6} () == -1)
680         \{
681           \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6} == 0);
682           \textcolor{keywordflow}{return} -1;
683         \}
684       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6} != 0);
685     \}
686   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_a9ff4985bbd8bdc29bbe36ba0937149fa}{m\_shutdownSend})
687     \{
688       \hyperlink{classns3_1_1UdpSocketImpl_ac35998e8aa2cc588e21752944b0a0095}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa471b853a7aed4ec0c5c64b0c5ad8e521}{ERROR\_SHUTDOWN};
689       \textcolor{keywordflow}{return} -1;
690     \}
691 
692   \textcolor{keywordflow}{if} (p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} () > \hyperlink{classns3_1_1UdpSocketImpl_a70191d0578ae26233f569631a26d608b}{GetTxAvailable} () )
693     \{
694       \hyperlink{classns3_1_1UdpSocketImpl_ac35998e8aa2cc588e21752944b0a0095}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaaeba174dbfeaed34194ce9463f6a469f1}{ERROR\_MSGSIZE};
695       \textcolor{keywordflow}{return} -1;
696     \}
697 
698   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Socket_a83858f6116bcdabecf1b63b37514ec8d}{IsManualIpv6Tclass} ())
699     \{
700       SocketIpv6TclassTag ipTclassTag;
701       ipTclassTag.SetTclass (\hyperlink{classns3_1_1Socket_aed62162f0b5f322b1fa23b7350c3c2ce}{GetIpv6Tclass} ());
702       p->\hyperlink{classns3_1_1Packet_a7400b8655852f5271c5957250d0141af}{AddPacketTag} (ipTclassTag);
703     \}
704 
705   uint8\_t priority = \hyperlink{classns3_1_1Socket_a3e4788d61c0e841ccaa1c7fce6fda2c1}{GetPriority} ();
706   \textcolor{keywordflow}{if} (priority)
707     \{
708       SocketPriorityTag priorityTag;
709       priorityTag.SetPriority (priority);
710       p->\hyperlink{classns3_1_1Packet_afb014ae9f4adddbfc51c64b085bfd405}{ReplacePacketTag} (priorityTag);
711     \}
712 
713   Ptr<Ipv6> ipv6 = \hyperlink{classns3_1_1UdpSocketImpl_af6a19247be3d8917b582af77337730c3}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv6> ();
714 
715   \textcolor{comment}{// Locally override the IP TTL for this socket}
716   \textcolor{comment}{// We cannot directly modify the TTL at this stage, so we set a Packet tag}
717   \textcolor{comment}{// The destination can be either multicast, unicast/anycast, or}
718   \textcolor{comment}{// either all-hosts broadcast or limited (subnet-directed) broadcast.}
719   \textcolor{comment}{// For the latter two broadcast types, the TTL will later be set to one}
720   \textcolor{comment}{// irrespective of what is set in these socket options.  So, this tagging}
721   \textcolor{comment}{// may end up setting the TTL of a limited broadcast packet to be}
722   \textcolor{comment}{// the same as a unicast, but it will be fixed further down the stack}
723   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_a4849465356cef8573ed373d12a5a62ec}{m\_ipMulticastTtl} != 0 && dest.IsMulticast ())
724     \{
725       SocketIpv6HopLimitTag tag;
726       tag.SetHopLimit (\hyperlink{classns3_1_1UdpSocketImpl_a4849465356cef8573ed373d12a5a62ec}{m\_ipMulticastTtl});
727       p->\hyperlink{classns3_1_1Packet_a7400b8655852f5271c5957250d0141af}{AddPacketTag} (tag);
728     \}
729   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Socket_af537e44bad2f67bffe7ef6c1c86c2459}{IsManualIpv6HopLimit} () && \hyperlink{classns3_1_1Socket_ad78033887757bda28f40f4ab1f0620d0}{GetIpv6HopLimit} () != 0 && !dest.
      IsMulticast ())
730     \{
731       SocketIpv6HopLimitTag tag;
732       tag.SetHopLimit (\hyperlink{classns3_1_1Socket_ad78033887757bda28f40f4ab1f0620d0}{GetIpv6HopLimit} ());
733       p->\hyperlink{classns3_1_1Packet_a7400b8655852f5271c5957250d0141af}{AddPacketTag} (tag);
734     \}
735   \textcolor{comment}{// There is no analgous to an IPv4 broadcast address in IPv6.}
736   \textcolor{comment}{// Instead, we use a set of link-local, site-local, and global}
737   \textcolor{comment}{// multicast addresses.  The Ipv6 routing layers should all}
738   \textcolor{comment}{// provide an interface-specific route to these addresses such}
739   \textcolor{comment}{// that we can treat these multicast addresses as "not broadcast"}
740 
741   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6}->\hyperlink{classns3_1_1Ipv6EndPoint_a1972cd26240d42cd75f93e12d9182976}{GetLocalAddress} () != 
      \hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} ())
742     \{
743       \hyperlink{classns3_1_1UdpSocketImpl_ace4b90c1ab6f4f302cdb4cd8da973514}{m\_udp}->Send (p->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} (), \hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6}->\hyperlink{classns3_1_1Ipv6EndPoint_a1972cd26240d42cd75f93e12d9182976}{GetLocalAddress} (), dest,
744                    \hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6}->\hyperlink{classns3_1_1Ipv6EndPoint_a39a9fd4aa85a8ecbbf2d6c84d589080b}{GetLocalPort} (), \hyperlink{dsdv-manet_8cc_a8e0798404bf2cf5dabb84c5ba9a4f236}{port}, 0);
745       \hyperlink{classns3_1_1Socket_ae478fc503f7041a1da5e9db361f1ae20}{NotifyDataSent} (p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ());
746       \hyperlink{classns3_1_1Socket_a34cd5de5b9feeadd6ba8973b954c3d5f}{NotifySend} (\hyperlink{classns3_1_1UdpSocketImpl_a70191d0578ae26233f569631a26d608b}{GetTxAvailable} ());
747       \textcolor{keywordflow}{return} p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ();
748     \}
749   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ipv6->GetRoutingProtocol () != 0)
750     \{
751       Ipv6Header header;
752       header.SetDestinationAddress (dest);
753       header.SetNextHeader (\hyperlink{classns3_1_1UdpL4Protocol_ad370801b3d1a166e831020a777c41047}{UdpL4Protocol::PROT\_NUMBER});
754       \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket::SocketErrno} errno\_;
755       Ptr<Ipv6Route> route;
756       Ptr<NetDevice> oif = \hyperlink{classns3_1_1Socket_a9781d8dfdb5e9364d5dce8f53b768bb5}{m\_boundnetdevice}; \textcolor{comment}{//specify non-zero if bound to a specific
       device}
757       \textcolor{comment}{// TBD-- we could cache the route and just check its validity}
758       route = ipv6->GetRoutingProtocol ()->RouteOutput (p, header, oif, errno\_); 
759       \textcolor{keywordflow}{if} (route != 0)
760         \{
761           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Route exists"});
762           header.SetSourceAddress (route->GetSource ());
763           \hyperlink{classns3_1_1UdpSocketImpl_ace4b90c1ab6f4f302cdb4cd8da973514}{m\_udp}->Send (p->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} (), header.GetSourceAddress (), header.GetDestinationAddress (),
764                        \hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6}->\hyperlink{classns3_1_1Ipv6EndPoint_a39a9fd4aa85a8ecbbf2d6c84d589080b}{GetLocalPort} (), \hyperlink{dsdv-manet_8cc_a8e0798404bf2cf5dabb84c5ba9a4f236}{port}, route);
765           \hyperlink{classns3_1_1Socket_ae478fc503f7041a1da5e9db361f1ae20}{NotifyDataSent} (p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ());
766           \textcolor{keywordflow}{return} p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ();
767         \}
768       \textcolor{keywordflow}{else} 
769         \{
770           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"No route to destination"});
771           \hyperlink{group__logging_ga0261a8db1d4ac5f79417d117634fd455}{NS\_LOG\_ERROR} (errno\_);
772           \hyperlink{classns3_1_1UdpSocketImpl_ac35998e8aa2cc588e21752944b0a0095}{m\_errno} = errno\_;
773           \textcolor{keywordflow}{return} -1;
774         \}
775     \}
776   \textcolor{keywordflow}{else}
777     \{
778       \hyperlink{group__logging_ga0261a8db1d4ac5f79417d117634fd455}{NS\_LOG\_ERROR} (\textcolor{stringliteral}{"ERROR\_NOROUTETOHOST"});
779       \hyperlink{classns3_1_1UdpSocketImpl_ac35998e8aa2cc588e21752944b0a0095}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{ERROR\_NOROUTETOHOST};
780       \textcolor{keywordflow}{return} -1;
781     \}
782 
783   \textcolor{keywordflow}{return} 0;
784 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 18


\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Finish\+Bind@{Finish\+Bind}}
\index{Finish\+Bind@{Finish\+Bind}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Finish\+Bind(void)}{FinishBind(void)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Udp\+Socket\+Impl\+::\+Finish\+Bind (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_ab176a2c5ea5e2ba0431a59cbc423c618}{}\label{classns3_1_1UdpSocketImpl_ab176a2c5ea5e2ba0431a59cbc423c618}
Finish the binding process \begin{DoxyReturn}{Returns}
0 on success, -\/1 on failure 
\end{DoxyReturn}

\begin{DoxyCode}
207 \{
208   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
209   \textcolor{keywordtype}{bool} done = \textcolor{keyword}{false};
210   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint} != 0)
211     \{
212       \hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint}->\hyperlink{classns3_1_1Ipv4EndPoint_abf5a10aadc249f2ce275cad9bb26322d}{SetRxCallback} (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1UdpSocketImpl_ac7ad1051f59ee35a9083a457bd6c5642}{UdpSocketImpl::ForwardUp}, Ptr<UdpSocketImpl> (\textcolor{keyword}{this})));
213       \hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint}->\hyperlink{classns3_1_1Ipv4EndPoint_a96d3a484480565a8f7444eae41caa4b4}{SetIcmpCallback} (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1UdpSocketImpl_a2f67e00e32fdb33ad58e1f429377a130}{UdpSocketImpl::ForwardIcmp}, Ptr<UdpSocketImpl> (\textcolor{keyword}{this})));
214       \hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint}->\hyperlink{classns3_1_1Ipv4EndPoint_a19ec16d98c501d3684e6549d7296ea0a}{SetDestroyCallback} (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1UdpSocketImpl_ab0f9092f8f28c5d246cae63476215fc8}{UdpSocketImpl::Destroy}, Ptr<UdpSocketImpl> (\textcolor{keyword}{this})));
215       done = \textcolor{keyword}{true};
216     \}
217   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6} != 0)
218     \{
219       \hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6}->\hyperlink{classns3_1_1Ipv6EndPoint_adec9357acb2821c4bba0222bcc5638f1}{SetRxCallback} (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1UdpSocketImpl_a1550f484c8c62c215a44e8c13694986b}{UdpSocketImpl::ForwardUp6}, Ptr<UdpSocketImpl> (\textcolor{keyword}{this})));
220       \hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6}->\hyperlink{classns3_1_1Ipv6EndPoint_a482f65430f138b5780bb063bc716c514}{SetIcmpCallback} (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1UdpSocketImpl_af83861011e4674d8f4c31b13f78c2204}{UdpSocketImpl::ForwardIcmp6}, Ptr<UdpSocketImpl> (\textcolor{keyword}{this})));
221       \hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6}->\hyperlink{classns3_1_1Ipv6EndPoint_af2922ef8f9f9ead0a2604c8391e90328}{SetDestroyCallback} (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1UdpSocketImpl_a40198099b528e0edbcfa323287c676bd}{UdpSocketImpl::Destroy6}, Ptr<UdpSocketImpl> (\textcolor{keyword}{this})));
222       done = \textcolor{keyword}{true};
223     \}
224   \textcolor{keywordflow}{if} (done)
225     \{
226       \textcolor{keywordflow}{return} 0;
227     \}
228   \textcolor{keywordflow}{return} -1;
229 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 19




Here is the caller graph for this function\+:
% FIG 20


\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Forward\+Icmp@{Forward\+Icmp}}
\index{Forward\+Icmp@{Forward\+Icmp}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Forward\+Icmp(\+Ipv4\+Address icmp\+Source, uint8\+\_\+t icmp\+Ttl, uint8\+\_\+t icmp\+Type, uint8\+\_\+t icmp\+Code, uint32\+\_\+t icmp\+Info)}{ForwardIcmp(Ipv4Address icmpSource, uint8_t icmpTtl, uint8_t icmpType, uint8_t icmpCode, uint32_t icmpInfo)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Udp\+Socket\+Impl\+::\+Forward\+Icmp (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{icmp\+Source, }
\item[{uint8\+\_\+t}]{icmp\+Ttl, }
\item[{uint8\+\_\+t}]{icmp\+Type, }
\item[{uint8\+\_\+t}]{icmp\+Code, }
\item[{uint32\+\_\+t}]{icmp\+Info}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_a2f67e00e32fdb33ad58e1f429377a130}{}\label{classns3_1_1UdpSocketImpl_a2f67e00e32fdb33ad58e1f429377a130}


Called by the L3 protocol when it received an I\+C\+MP packet to pass on to T\+CP. 


\begin{DoxyParams}{Parameters}
{\em icmp\+Source} & the I\+C\+MP source address \\
\hline
{\em icmp\+Ttl} & the I\+C\+MP \hyperlink{classns3_1_1Time}{Time} to Live \\
\hline
{\em icmp\+Type} & the I\+C\+MP Type \\
\hline
{\em icmp\+Code} & the I\+C\+MP Code \\
\hline
{\em icmp\+Info} & the I\+C\+MP Info \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1108 \{
1109   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << icmpSource << (uint32\_t)icmpTtl << (uint32\_t)icmpType <<
1110                    (uint32\_t)icmpCode << icmpInfo);
1111   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1UdpSocketImpl_a0a595e39113e8854c86c820623ae6cd4}{m\_icmpCallback}.IsNull ())
1112     \{
1113       \hyperlink{classns3_1_1UdpSocketImpl_a0a595e39113e8854c86c820623ae6cd4}{m\_icmpCallback} (icmpSource, icmpTtl, icmpType, icmpCode, icmpInfo);
1114     \}
1115 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 21


\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Forward\+Icmp6@{Forward\+Icmp6}}
\index{Forward\+Icmp6@{Forward\+Icmp6}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Forward\+Icmp6(\+Ipv6\+Address icmp\+Source, uint8\+\_\+t icmp\+Ttl, uint8\+\_\+t icmp\+Type, uint8\+\_\+t icmp\+Code, uint32\+\_\+t icmp\+Info)}{ForwardIcmp6(Ipv6Address icmpSource, uint8_t icmpTtl, uint8_t icmpType, uint8_t icmpCode, uint32_t icmpInfo)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Udp\+Socket\+Impl\+::\+Forward\+Icmp6 (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{icmp\+Source, }
\item[{uint8\+\_\+t}]{icmp\+Ttl, }
\item[{uint8\+\_\+t}]{icmp\+Type, }
\item[{uint8\+\_\+t}]{icmp\+Code, }
\item[{uint32\+\_\+t}]{icmp\+Info}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_af83861011e4674d8f4c31b13f78c2204}{}\label{classns3_1_1UdpSocketImpl_af83861011e4674d8f4c31b13f78c2204}


Called by the L3 protocol when it received an I\+C\+M\+Pv6 packet to pass on to T\+CP. 


\begin{DoxyParams}{Parameters}
{\em icmp\+Source} & the I\+C\+MP source address \\
\hline
{\em icmp\+Ttl} & the I\+C\+MP \hyperlink{classns3_1_1Time}{Time} to Live \\
\hline
{\em icmp\+Type} & the I\+C\+MP Type \\
\hline
{\em icmp\+Code} & the I\+C\+MP Code \\
\hline
{\em icmp\+Info} & the I\+C\+MP Info \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1121 \{
1122   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << icmpSource << (uint32\_t)icmpTtl << (uint32\_t)icmpType <<
1123                    (uint32\_t)icmpCode << icmpInfo);
1124   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1UdpSocketImpl_aa4fbff077aa5ca080279196abaa87a04}{m\_icmpCallback6}.IsNull ())
1125     \{
1126       \hyperlink{classns3_1_1UdpSocketImpl_aa4fbff077aa5ca080279196abaa87a04}{m\_icmpCallback6} (icmpSource, icmpTtl, icmpType, icmpCode, icmpInfo);
1127     \}
1128 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 22


\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Forward\+Up@{Forward\+Up}}
\index{Forward\+Up@{Forward\+Up}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Forward\+Up(\+Ptr$<$ Packet $>$ packet, Ipv4\+Header header, uint16\+\_\+t port, Ptr$<$ Ipv4\+Interface $>$ incoming\+Interface)}{ForwardUp(Ptr< Packet > packet, Ipv4Header header, uint16_t port, Ptr< Ipv4Interface > incomingInterface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Udp\+Socket\+Impl\+::\+Forward\+Up (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Ipv4\+Header}}]{header, }
\item[{uint16\+\_\+t}]{port, }
\item[{{\bf Ptr}$<$ {\bf Ipv4\+Interface} $>$}]{incoming\+Interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_ac7ad1051f59ee35a9083a457bd6c5642}{}\label{classns3_1_1UdpSocketImpl_ac7ad1051f59ee35a9083a457bd6c5642}


Called by the L3 protocol when it received a packet to pass on to T\+CP. 


\begin{DoxyParams}{Parameters}
{\em packet} & the incoming packet \\
\hline
{\em header} & the packet\textquotesingle{}s I\+Pv4 header \\
\hline
{\em port} & the remote port \\
\hline
{\em incoming\+Interface} & the incoming interface \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
992 \{
993   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << header << \hyperlink{dsdv-manet_8cc_a8e0798404bf2cf5dabb84c5ba9a4f236}{port});
994 
995   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_abda20957e451801973534c38d9d74f4a}{m\_shutdownRecv})
996     \{
997       \textcolor{keywordflow}{return};
998     \}
999 
1000   \textcolor{comment}{// Should check via getsockopt ()..}
1001   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Socket_a104a42cdf0290b4e8867b4c0a77aadc2}{IsRecvPktInfo} ())
1002     \{
1003       Ipv4PacketInfoTag tag;
1004       packet->\hyperlink{classns3_1_1Packet_a078fe922d976a417ab25ba2f3c2fd667}{RemovePacketTag} (tag);
1005       tag.SetRecvIf (incomingInterface->GetDevice ()->GetIfIndex ());
1006       packet->\hyperlink{classns3_1_1Packet_a7400b8655852f5271c5957250d0141af}{AddPacketTag} (tag);
1007     \}
1008 
1009   \textcolor{comment}{//Check only version 4 options}
1010   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Socket_a5b5addd1a33e306c3113c547705835f9}{IsIpRecvTos} ())
1011     \{
1012       SocketIpTosTag ipTosTag;
1013       ipTosTag.SetTos (header.GetTos ());
1014       packet->\hyperlink{classns3_1_1Packet_a7400b8655852f5271c5957250d0141af}{AddPacketTag} (ipTosTag);
1015     \}
1016 
1017   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Socket_abc87245c3eec89fc043d4f043b0be35f}{IsIpRecvTtl} ())
1018     \{
1019       SocketIpTtlTag ipTtlTag;
1020       ipTtlTag.SetTtl (header.GetTtl ());
1021       packet->\hyperlink{classns3_1_1Packet_a7400b8655852f5271c5957250d0141af}{AddPacketTag} (ipTtlTag);
1022     \}
1023 
1024   \textcolor{comment}{// in case the packet still has a priority tag attached, remove it}
1025   SocketPriorityTag priorityTag;
1026   packet->\hyperlink{classns3_1_1Packet_a078fe922d976a417ab25ba2f3c2fd667}{RemovePacketTag} (priorityTag);
1027 
1028   \textcolor{keywordflow}{if} ((\hyperlink{classns3_1_1UdpSocketImpl_a73e12067139eb298bbb4b0e2c2e56a6a}{m\_rxAvailable} + packet->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ()) <= \hyperlink{classns3_1_1UdpSocketImpl_a81c69f998616d1d79a9c81c569b725e9}{m\_rcvBufSize})
1029     \{
1030       Address address = InetSocketAddress (header.GetSource (), \hyperlink{dsdv-manet_8cc_a8e0798404bf2cf5dabb84c5ba9a4f236}{port});
1031       \hyperlink{classns3_1_1UdpSocketImpl_a6a95636f11b186eab1f70727500d9233}{m\_deliveryQueue}.push (std::make\_pair (packet, address));
1032       \hyperlink{classns3_1_1UdpSocketImpl_a73e12067139eb298bbb4b0e2c2e56a6a}{m\_rxAvailable} += packet->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ();
1033       \hyperlink{classns3_1_1Socket_a91fa3046bbd0a7644381f1d2481bdfef}{NotifyDataRecv} ();
1034     \}
1035   \textcolor{keywordflow}{else}
1036     \{
1037       \textcolor{comment}{// In general, this case should not occur unless the}
1038       \textcolor{comment}{// receiving application reads data from this socket slowly}
1039       \textcolor{comment}{// in comparison to the arrival rate}
1040       \textcolor{comment}{//}
1041       \textcolor{comment}{// drop and trace packet}
1042       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"No receive buffer space available.  Drop."});
1043       \hyperlink{classns3_1_1UdpSocketImpl_a786fed61e3c4c68280656c4036514c11}{m\_dropTrace} (packet);
1044     \}
1045 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 23




Here is the caller graph for this function\+:
% FIG 24


\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Forward\+Up6@{Forward\+Up6}}
\index{Forward\+Up6@{Forward\+Up6}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Forward\+Up6(\+Ptr$<$ Packet $>$ packet, Ipv6\+Header header, uint16\+\_\+t port, Ptr$<$ Ipv6\+Interface $>$ incoming\+Interface)}{ForwardUp6(Ptr< Packet > packet, Ipv6Header header, uint16_t port, Ptr< Ipv6Interface > incomingInterface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Udp\+Socket\+Impl\+::\+Forward\+Up6 (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Ipv6\+Header}}]{header, }
\item[{uint16\+\_\+t}]{port, }
\item[{{\bf Ptr}$<$ {\bf Ipv6\+Interface} $>$}]{incoming\+Interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_a1550f484c8c62c215a44e8c13694986b}{}\label{classns3_1_1UdpSocketImpl_a1550f484c8c62c215a44e8c13694986b}


Called by the L3 protocol when it received a packet to pass on to T\+CP. 


\begin{DoxyParams}{Parameters}
{\em packet} & the incoming packet \\
\hline
{\em header} & the packet\textquotesingle{}s I\+Pv6 header \\
\hline
{\em port} & the remote port \\
\hline
{\em incoming\+Interface} & the incoming interface \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1049 \{
1050   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << header.GetSourceAddress () << 
      \hyperlink{dsdv-manet_8cc_a8e0798404bf2cf5dabb84c5ba9a4f236}{port});
1051 
1052   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_abda20957e451801973534c38d9d74f4a}{m\_shutdownRecv})
1053     \{
1054       \textcolor{keywordflow}{return};
1055     \}
1056 
1057   \textcolor{comment}{// Should check via getsockopt ().}
1058   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Socket_a104a42cdf0290b4e8867b4c0a77aadc2}{IsRecvPktInfo} ())
1059     \{
1060       Ipv6PacketInfoTag tag;
1061       packet->\hyperlink{classns3_1_1Packet_a078fe922d976a417ab25ba2f3c2fd667}{RemovePacketTag} (tag);
1062       tag.SetRecvIf (incomingInterface->GetDevice ()->GetIfIndex ());
1063       packet->\hyperlink{classns3_1_1Packet_a7400b8655852f5271c5957250d0141af}{AddPacketTag} (tag);
1064     \}
1065 
1066   \textcolor{comment}{// Check only version 6 options}
1067   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Socket_ad9b8d1ceb1e0b80609b7c6a1c1392eec}{IsIpv6RecvTclass} ())
1068     \{
1069       SocketIpv6TclassTag ipTclassTag;
1070       ipTclassTag.SetTclass (header.GetTrafficClass ());
1071       packet->\hyperlink{classns3_1_1Packet_a7400b8655852f5271c5957250d0141af}{AddPacketTag} (ipTclassTag);
1072     \}
1073 
1074   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Socket_a99fb541eff485b5b2c6fa7f0aac3abb9}{IsIpv6RecvHopLimit} ())
1075     \{
1076       SocketIpv6HopLimitTag ipHopLimitTag;
1077       ipHopLimitTag.SetHopLimit (header.GetHopLimit ());
1078       packet->\hyperlink{classns3_1_1Packet_a7400b8655852f5271c5957250d0141af}{AddPacketTag} (ipHopLimitTag);
1079     \}
1080 
1081   \textcolor{comment}{// in case the packet still has a priority tag attached, remove it}
1082   SocketPriorityTag priorityTag;
1083   packet->\hyperlink{classns3_1_1Packet_a078fe922d976a417ab25ba2f3c2fd667}{RemovePacketTag} (priorityTag);
1084 
1085   \textcolor{keywordflow}{if} ((\hyperlink{classns3_1_1UdpSocketImpl_a73e12067139eb298bbb4b0e2c2e56a6a}{m\_rxAvailable} + packet->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ()) <= \hyperlink{classns3_1_1UdpSocketImpl_a81c69f998616d1d79a9c81c569b725e9}{m\_rcvBufSize})
1086     \{
1087       Address address = Inet6SocketAddress (header.GetSourceAddress (), \hyperlink{dsdv-manet_8cc_a8e0798404bf2cf5dabb84c5ba9a4f236}{port});
1088       \hyperlink{classns3_1_1UdpSocketImpl_a6a95636f11b186eab1f70727500d9233}{m\_deliveryQueue}.push (std::make\_pair (packet, address));
1089       \hyperlink{classns3_1_1UdpSocketImpl_a73e12067139eb298bbb4b0e2c2e56a6a}{m\_rxAvailable} += packet->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ();
1090       \hyperlink{classns3_1_1Socket_a91fa3046bbd0a7644381f1d2481bdfef}{NotifyDataRecv} ();
1091     \}
1092   \textcolor{keywordflow}{else}
1093     \{
1094       \textcolor{comment}{// In general, this case should not occur unless the}
1095       \textcolor{comment}{// receiving application reads data from this socket slowly}
1096       \textcolor{comment}{// in comparison to the arrival rate}
1097       \textcolor{comment}{//}
1098       \textcolor{comment}{// drop and trace packet}
1099       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"No receive buffer space available.  Drop."});
1100       \hyperlink{classns3_1_1UdpSocketImpl_a786fed61e3c4c68280656c4036514c11}{m\_dropTrace} (packet);
1101     \}
1102 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 25




Here is the caller graph for this function\+:
% FIG 26


\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Get\+Allow\+Broadcast@{Get\+Allow\+Broadcast}}
\index{Get\+Allow\+Broadcast@{Get\+Allow\+Broadcast}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Allow\+Broadcast() const }{GetAllowBroadcast() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Udp\+Socket\+Impl\+::\+Get\+Allow\+Broadcast (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_a9d2ef36ffe3fe414e861ec14d6d18fed}{}\label{classns3_1_1UdpSocketImpl_a9d2ef36ffe3fe414e861ec14d6d18fed}


Query whether broadcast datagram transmissions are allowed. 

This method corresponds to using getsockopt() S\+O\+\_\+\+B\+R\+O\+A\+D\+C\+A\+ST of real network or B\+SD sockets.

\begin{DoxyReturn}{Returns}
true if broadcast is allowed, false otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_a95338a1ac89330a492d6af5b4e172d34}{ns3\+::\+Socket}.


\begin{DoxyCode}
1198 \{
1199   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UdpSocketImpl_a071404252802565f1d1511b5c98b155a}{m\_allowBroadcast};
1200 \}
\end{DoxyCode}
\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Get\+Errno@{Get\+Errno}}
\index{Get\+Errno@{Get\+Errno}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Errno(void) const }{GetErrno(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Socket\+::\+Socket\+Errno} ns3\+::\+Udp\+Socket\+Impl\+::\+Get\+Errno (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_ac8559811caa54f721de6f68bb030910f}{}\label{classns3_1_1UdpSocketImpl_ac8559811caa54f721de6f68bb030910f}


Get last error number. 

\begin{DoxyReturn}{Returns}
the errno associated to the last call which failed in this socket. Each socket\textquotesingle{}s errno is initialized to zero when the socket is created. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_ae489616249d946f3c0dc831c05d0d711}{ns3\+::\+Socket}.


\begin{DoxyCode}
154 \{
155   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
156   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UdpSocketImpl_ac35998e8aa2cc588e21752944b0a0095}{m\_errno};
157 \}
\end{DoxyCode}
\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Get\+Ip\+Multicast\+If@{Get\+Ip\+Multicast\+If}}
\index{Get\+Ip\+Multicast\+If@{Get\+Ip\+Multicast\+If}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Ip\+Multicast\+If(void) const }{GetIpMulticastIf(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}int32\+\_\+t ns3\+::\+Udp\+Socket\+Impl\+::\+Get\+Ip\+Multicast\+If (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_aced96ba1ce213afb754231be7c25510a}{}\label{classns3_1_1UdpSocketImpl_aced96ba1ce213afb754231be7c25510a}


Get the IP multicast interface. 

\begin{DoxyReturn}{Returns}
the IP multicast interface 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1UdpSocket_a47d613ffaa57a41bbceb80e6f4ea05e3}{ns3\+::\+Udp\+Socket}.


\begin{DoxyCode}
1162 \{
1163   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UdpSocketImpl_a4ff1b1c6db56fad154afe2563d985e08}{m\_ipMulticastIf};
1164 \}
\end{DoxyCode}
\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Get\+Ip\+Multicast\+Loop@{Get\+Ip\+Multicast\+Loop}}
\index{Get\+Ip\+Multicast\+Loop@{Get\+Ip\+Multicast\+Loop}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Ip\+Multicast\+Loop(void) const }{GetIpMulticastLoop(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Udp\+Socket\+Impl\+::\+Get\+Ip\+Multicast\+Loop (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_ae15a4f99d3a7f7f43068b02f1341abb5}{}\label{classns3_1_1UdpSocketImpl_ae15a4f99d3a7f7f43068b02f1341abb5}


Get the IP multicast loop capability. 

This means that the socket will receive the packets sent by itself on a multicast address. Equivalent to setsockopt I\+P\+\_\+\+M\+U\+L\+T\+I\+C\+A\+S\+T\+\_\+\+L\+O\+OP

\begin{DoxyReturn}{Returns}
the IP multicast loop capability 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1UdpSocket_a3e28f54eb34f07e684927abac9dbeb38}{ns3\+::\+Udp\+Socket}.


\begin{DoxyCode}
1174 \{
1175   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UdpSocketImpl_aa201ce3516300da49c3e602e21cd6f6d}{m\_ipMulticastLoop};
1176 \}
\end{DoxyCode}
\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Get\+Ip\+Multicast\+Ttl@{Get\+Ip\+Multicast\+Ttl}}
\index{Get\+Ip\+Multicast\+Ttl@{Get\+Ip\+Multicast\+Ttl}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Ip\+Multicast\+Ttl(void) const }{GetIpMulticastTtl(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::\+Udp\+Socket\+Impl\+::\+Get\+Ip\+Multicast\+Ttl (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_af458fecb96042e1be40efa66db348e99}{}\label{classns3_1_1UdpSocketImpl_af458fecb96042e1be40efa66db348e99}


Get the IP multicast T\+TL. 

\begin{DoxyReturn}{Returns}
the IP multicast T\+TL 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1UdpSocket_a2612696b076f094d3c76363e2e2b8d30}{ns3\+::\+Udp\+Socket}.


\begin{DoxyCode}
1150 \{
1151   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UdpSocketImpl_a4849465356cef8573ed373d12a5a62ec}{m\_ipMulticastTtl};
1152 \}
\end{DoxyCode}
\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Get\+Mtu\+Discover@{Get\+Mtu\+Discover}}
\index{Get\+Mtu\+Discover@{Get\+Mtu\+Discover}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Mtu\+Discover(void) const }{GetMtuDiscover(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Udp\+Socket\+Impl\+::\+Get\+Mtu\+Discover (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_a3268aa9137eb2e0a02abbe147c82b5fa}{}\label{classns3_1_1UdpSocketImpl_a3268aa9137eb2e0a02abbe147c82b5fa}


Get the M\+TU discover capability. 

\begin{DoxyReturn}{Returns}
the M\+TU discover capability 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1UdpSocket_abd9c668464d5f89f17780fcd932777c2}{ns3\+::\+Udp\+Socket}.


\begin{DoxyCode}
1185 \{
1186   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UdpSocketImpl_ab5ae932e01b5746539b9ad20b3ff4f46}{m\_mtuDiscover};
1187 \}
\end{DoxyCode}
\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Get\+Node@{Get\+Node}}
\index{Get\+Node@{Get\+Node}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Node(void) const }{GetNode(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Node} $>$ ns3\+::\+Udp\+Socket\+Impl\+::\+Get\+Node (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_ac0971130b8551291542586e2430410ff}{}\label{classns3_1_1UdpSocketImpl_ac0971130b8551291542586e2430410ff}


Return the node this socket is associated with. 

\begin{DoxyReturn}{Returns}
the node 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_aba642ad4301c1df47befc0aa9afa2e48}{ns3\+::\+Socket}.


\begin{DoxyCode}
167 \{
168   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
169   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UdpSocketImpl_af6a19247be3d8917b582af77337730c3}{m\_node};
170 \}
\end{DoxyCode}
\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Get\+Peer\+Name@{Get\+Peer\+Name}}
\index{Get\+Peer\+Name@{Get\+Peer\+Name}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Peer\+Name(\+Address \&address) const }{GetPeerName(Address &address) const }}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Udp\+Socket\+Impl\+::\+Get\+Peer\+Name (
\begin{DoxyParamCaption}
\item[{{\bf Address} \&}]{address}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_a73c3d2b1f7372550df82af8effb8bbe0}{}\label{classns3_1_1UdpSocketImpl_a73c3d2b1f7372550df82af8effb8bbe0}


Get the peer address of a connected socket. 


\begin{DoxyParams}{Parameters}
{\em address} & the address this socket is connected to. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if success, -\/1 otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_a78a3c37a539d2e70869bb82cc60fbb09}{ns3\+::\+Socket}.


\begin{DoxyCode}
890 \{
891   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << address);
892 
893   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1UdpSocketImpl_a2df1a2df7ba0f4c852ad1d2155b1fbcc}{m\_connected})
894     \{
895       \hyperlink{classns3_1_1UdpSocketImpl_ac35998e8aa2cc588e21752944b0a0095}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaaeb1fd23c1f4965b496786597125bf0f6}{ERROR\_NOTCONN};
896       \textcolor{keywordflow}{return} -1;
897     \}
898 
899   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4Address_a7129db5e08739783b300976d28c0ced3}{Ipv4Address::IsMatchingType} (\hyperlink{classns3_1_1UdpSocketImpl_a820bb30415d2627cea60338649d19ccb}{m\_defaultAddress}))
900     \{
901       Ipv4Address addr = \hyperlink{classns3_1_1Ipv4Address_a5fd4a8f0f7bb75e35dad3d401ef4cbc1}{Ipv4Address::ConvertFrom} (
      \hyperlink{classns3_1_1UdpSocketImpl_a820bb30415d2627cea60338649d19ccb}{m\_defaultAddress});
902       InetSocketAddress inet (addr, \hyperlink{classns3_1_1UdpSocketImpl_a990120b2cc768c47a6a2a2a1e53875c8}{m\_defaultPort});
903       inet.SetTos (\hyperlink{classns3_1_1Socket_a95bd4732074d3d26d4a6949fc3499ccb}{GetIpTos} ());
904       address = inet;
905     \}
906   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6Address_adbe329370b5a8f7c0f48659d6439dfd1}{Ipv6Address::IsMatchingType} (
      \hyperlink{classns3_1_1UdpSocketImpl_a820bb30415d2627cea60338649d19ccb}{m\_defaultAddress}))
907     \{
908       Ipv6Address addr = \hyperlink{classns3_1_1Ipv6Address_ac00bc221a0b226b2090d05468aec4b79}{Ipv6Address::ConvertFrom} (
      \hyperlink{classns3_1_1UdpSocketImpl_a820bb30415d2627cea60338649d19ccb}{m\_defaultAddress});
909       address = Inet6SocketAddress (addr, \hyperlink{classns3_1_1UdpSocketImpl_a990120b2cc768c47a6a2a2a1e53875c8}{m\_defaultPort});
910     \}
911   \textcolor{keywordflow}{else}
912     \{
913       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\textcolor{keyword}{false}, \textcolor{stringliteral}{"unexpected address type"});
914     \}
915 
916   \textcolor{keywordflow}{return} 0;
917 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 27


\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Get\+Rcv\+Buf\+Size@{Get\+Rcv\+Buf\+Size}}
\index{Get\+Rcv\+Buf\+Size@{Get\+Rcv\+Buf\+Size}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Rcv\+Buf\+Size(void) const }{GetRcvBufSize(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Udp\+Socket\+Impl\+::\+Get\+Rcv\+Buf\+Size (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_a416f9131c40452da19e02d86a8691ffd}{}\label{classns3_1_1UdpSocketImpl_a416f9131c40452da19e02d86a8691ffd}


Get the receiving buffer size. 

\begin{DoxyReturn}{Returns}
the buffer size 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1UdpSocket_aa222c9c8a78b860f1bceafdd72b54ae0}{ns3\+::\+Udp\+Socket}.


\begin{DoxyCode}
1138 \{
1139   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UdpSocketImpl_a81c69f998616d1d79a9c81c569b725e9}{m\_rcvBufSize};
1140 \}
\end{DoxyCode}
\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Get\+Rx\+Available@{Get\+Rx\+Available}}
\index{Get\+Rx\+Available@{Get\+Rx\+Available}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Rx\+Available(void) const }{GetRxAvailable(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Udp\+Socket\+Impl\+::\+Get\+Rx\+Available (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_a1a6d616624492e2846516de890832f63}{}\label{classns3_1_1UdpSocketImpl_a1a6d616624492e2846516de890832f63}
Return number of bytes which can be returned from one or multiple calls to Recv. Must be possible to call this method from the Recv callback.

\begin{DoxyReturn}{Returns}
the number of bytes which can be returned from one or multiple Recv calls. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_ad35d8931e53ae0754ee864acb1cecd0e}{ns3\+::\+Socket}.


\begin{DoxyCode}
824 \{
825   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
826   \textcolor{comment}{// We separately maintain this state to avoid walking the queue }
827   \textcolor{comment}{// every time this might be called}
828   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UdpSocketImpl_a73e12067139eb298bbb4b0e2c2e56a6a}{m\_rxAvailable};
829 \}
\end{DoxyCode}
\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Get\+Socket\+Type@{Get\+Socket\+Type}}
\index{Get\+Socket\+Type@{Get\+Socket\+Type}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Socket\+Type(void) const }{GetSocketType(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Socket\+::\+Socket\+Type} ns3\+::\+Udp\+Socket\+Impl\+::\+Get\+Socket\+Type (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_aea31312dc3090dbc0b629569bb2aba9b}{}\label{classns3_1_1UdpSocketImpl_aea31312dc3090dbc0b629569bb2aba9b}
\begin{DoxyReturn}{Returns}
the socket type, analogous to getsockopt (S\+O\+\_\+\+T\+Y\+PE) 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_af9333cfc006d6ed9363f20d3822fedcb}{ns3\+::\+Socket}.


\begin{DoxyCode}
161 \{
162   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Socket_a698fbcc486a48b7a0d2b0e4ab863d571a635a1582f4396f31f7bc2e78c105f3fb}{NS3\_SOCK\_DGRAM};
163 \}
\end{DoxyCode}
\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Get\+Sock\+Name@{Get\+Sock\+Name}}
\index{Get\+Sock\+Name@{Get\+Sock\+Name}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Sock\+Name(\+Address \&address) const }{GetSockName(Address &address) const }}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Udp\+Socket\+Impl\+::\+Get\+Sock\+Name (
\begin{DoxyParamCaption}
\item[{{\bf Address} \&}]{address}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_a871428d5daa26d9f0b3566c8310e9769}{}\label{classns3_1_1UdpSocketImpl_a871428d5daa26d9f0b3566c8310e9769}


Get socket address. 


\begin{DoxyParams}{Parameters}
{\em address} & the address name this socket is associated with. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if success, -\/1 otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_aa982ca9baab28bea412b0d9710e63b43}{ns3\+::\+Socket}.


\begin{DoxyCode}
869 \{
870   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
871   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint} != 0)
872     \{
873       address = InetSocketAddress (\hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint}->\hyperlink{classns3_1_1Ipv4EndPoint_ae08283e26ace5880c3172ea5d803b6f8}{GetLocalAddress} (), 
      \hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint}->\hyperlink{classns3_1_1Ipv4EndPoint_aab137f64770abf94f0b8a81217a0b106}{GetLocalPort} ());
874     \}
875   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6} != 0)
876     \{
877       address = Inet6SocketAddress (\hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6}->\hyperlink{classns3_1_1Ipv6EndPoint_a1972cd26240d42cd75f93e12d9182976}{GetLocalAddress} (), 
      \hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6}->\hyperlink{classns3_1_1Ipv6EndPoint_a39a9fd4aa85a8ecbbf2d6c84d589080b}{GetLocalPort} ());
878     \}
879   \textcolor{keywordflow}{else}
880     \{ \textcolor{comment}{// It is possible to call this method on a socket without a name}
881       \textcolor{comment}{// in which case, behavior is unspecified}
882       \textcolor{comment}{// Should this return an InetSocketAddress or an Inet6SocketAddress?}
883       address = InetSocketAddress (\hyperlink{classns3_1_1Ipv4Address_aeeb1c76b35d4ab612fda7bc51e99c5db}{Ipv4Address::GetZero} (), 0);
884     \}
885   \textcolor{keywordflow}{return} 0;
886 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 28


\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Get\+Tx\+Available@{Get\+Tx\+Available}}
\index{Get\+Tx\+Available@{Get\+Tx\+Available}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Tx\+Available(void) const }{GetTxAvailable(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Udp\+Socket\+Impl\+::\+Get\+Tx\+Available (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_a70191d0578ae26233f569631a26d608b}{}\label{classns3_1_1UdpSocketImpl_a70191d0578ae26233f569631a26d608b}


Returns the number of bytes which can be sent in a single call to Send. 

For datagram sockets, this returns the number of bytes that can be passed atomically through the underlying protocol.

For stream sockets, this returns the available space in bytes left in the transmit buffer.

\begin{DoxyReturn}{Returns}
The number of bytes which can be sent in a single Send call. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_ae7cf62e3acf44106bfa1d40eaeaec151}{ns3\+::\+Socket}.


\begin{DoxyCode}
792 \{
793   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
794   \textcolor{comment}{// No finite send buffer is modelled, but we must respect}
795   \textcolor{comment}{// the maximum size of an IP datagram (65535 bytes - headers).}
796   \textcolor{keywordflow}{return} \hyperlink{namespacens3_aa58af59d765a0ab7b6d3334147fe60b4}{MAX\_IPV4\_UDP\_DATAGRAM\_SIZE};
797 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 29


\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Udp\+Socket\+Impl\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1UdpSocketImpl_a4412f79ef3f0597cc1ac0dcf8922ee3a}{}\label{classns3_1_1UdpSocketImpl_a4412f79ef3f0597cc1ac0dcf8922ee3a}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
57 \{
58   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::UdpSocketImpl"})
59     .SetParent<\hyperlink{classns3_1_1UdpSocket_abbf25d1bcbd4a8d344c6266aa8c93bb5}{UdpSocket}> ()
60     .SetGroupName (\textcolor{stringliteral}{"Internet"})
61     .AddConstructor<\hyperlink{classns3_1_1UdpSocketImpl_a870b73927cd3bd748da198906b53fb2d}{UdpSocketImpl}> ()
62     .AddTraceSource (\textcolor{stringliteral}{"Drop"},
63                      \textcolor{stringliteral}{"Drop UDP packet due to receive buffer overflow"},
64                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1UdpSocketImpl_a786fed61e3c4c68280656c4036514c11}{UdpSocketImpl::m\_dropTrace}),
65                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
66     .AddAttribute (\textcolor{stringliteral}{"IcmpCallback"}, \textcolor{stringliteral}{"Callback invoked whenever an icmp error is received on this socket."},
67                    CallbackValue (),
68                    MakeCallbackAccessor (&\hyperlink{classns3_1_1UdpSocketImpl_a0a595e39113e8854c86c820623ae6cd4}{UdpSocketImpl::m\_icmpCallback}),
69                    MakeCallbackChecker ())
70     .AddAttribute (\textcolor{stringliteral}{"IcmpCallback6"}, \textcolor{stringliteral}{"Callback invoked whenever an icmpv6 error is received on this socket."}
      ,
71                    CallbackValue (),
72                    MakeCallbackAccessor (&\hyperlink{classns3_1_1UdpSocketImpl_aa4fbff077aa5ca080279196abaa87a04}{UdpSocketImpl::m\_icmpCallback6}),
73                    MakeCallbackChecker ())
74   ;
75   \textcolor{keywordflow}{return} tid;
76 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 30


\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Ipv6\+Join\+Group@{Ipv6\+Join\+Group}}
\index{Ipv6\+Join\+Group@{Ipv6\+Join\+Group}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Ipv6\+Join\+Group(\+Ipv6\+Address address, Socket\+::\+Ipv6\+Multicast\+Filter\+Mode filter\+Mode, std\+::vector$<$ Ipv6\+Address $>$ source\+Addresses)}{Ipv6JoinGroup(Ipv6Address address, Socket::Ipv6MulticastFilterMode filterMode, std::vector< Ipv6Address > sourceAddresses)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Udp\+Socket\+Impl\+::\+Ipv6\+Join\+Group (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{address, }
\item[{{\bf Socket\+::\+Ipv6\+Multicast\+Filter\+Mode}}]{filter\+Mode, }
\item[{std\+::vector$<$ {\bf Ipv6\+Address} $>$}]{source\+Addresses}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_a65ec9e22618155ac74695a2ac7e24695}{}\label{classns3_1_1UdpSocketImpl_a65ec9e22618155ac74695a2ac7e24695}


Joins a I\+Pv6 multicast group. 

Based on the filter mode and source addresses this can be interpreted as a join, leave, or modification to source filtering on a multicast group.

Mind that a socket can join only one multicast group. Any attempt to join another group will remove the old one.


\begin{DoxyParams}{Parameters}
{\em address} & Requested multicast address. \\
\hline
{\em filter\+Mode} & \hyperlink{classns3_1_1Socket}{Socket} filtering mode (I\+N\+C\+L\+U\+DE $\vert$ E\+X\+C\+L\+U\+DE). \\
\hline
{\em source\+Addresses} & All the source addresses on which socket is interested or not interested. \\
\hline
\end{DoxyParams}


Reimplemented from \hyperlink{classns3_1_1Socket_aa9c414660bee2cd56bf6cdc4111b4744}{ns3\+::\+Socket}.


\begin{DoxyCode}
1204 \{
1205   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << address << &filterMode << &sourceAddresses);
1206 
1207   \textcolor{comment}{// We can join only one multicast group (or change its params)}
1208   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} ((\hyperlink{classns3_1_1Socket_a5745d9cdf891f3f0c06b124c4b679ef9}{m\_ipv6MulticastGroupAddress} == address || 
      \hyperlink{classns3_1_1Socket_a5745d9cdf891f3f0c06b124c4b679ef9}{m\_ipv6MulticastGroupAddress}.\hyperlink{classns3_1_1Ipv6Address_a6f15ff7a41a6ae2171cdeda2a53179b8}{IsAny} ()), \textcolor{stringliteral}{"Can join only one IPv6 multicast
       group."});
1209 
1210   \hyperlink{classns3_1_1Socket_a5745d9cdf891f3f0c06b124c4b679ef9}{m\_ipv6MulticastGroupAddress} = address;
1211 
1212   Ptr<Ipv6L3Protocol> ipv6l3 = \hyperlink{classns3_1_1UdpSocketImpl_af6a19247be3d8917b582af77337730c3}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject} <Ipv6L3Protocol> ();
1213   \textcolor{keywordflow}{if} (ipv6l3)
1214     \{
1215       \textcolor{keywordflow}{if} (filterMode == \hyperlink{classns3_1_1Socket_a96f39fe2b73d5691b319093a1e31615da3518a166d4dda6c74bf8aaaade9edf7a}{INCLUDE} && sourceAddresses.empty ())
1216         \{
1217           \textcolor{comment}{// it is a leave}
1218           \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Socket_a9781d8dfdb5e9364d5dce8f53b768bb5}{m\_boundnetdevice})
1219             \{
1220               int32\_t index = ipv6l3->GetInterfaceForDevice (\hyperlink{classns3_1_1Socket_a9781d8dfdb5e9364d5dce8f53b768bb5}{m\_boundnetdevice});
1221               \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (index >= 0, \textcolor{stringliteral}{"Interface without a valid index"});
1222               ipv6l3->RemoveMulticastAddress (address, index);
1223             \}
1224           \textcolor{keywordflow}{else}
1225             \{
1226               ipv6l3->RemoveMulticastAddress (address);
1227             \}
1228         \}
1229       \textcolor{keywordflow}{else}
1230         \{
1231           \textcolor{comment}{// it is a join or a modification}
1232           \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Socket_a9781d8dfdb5e9364d5dce8f53b768bb5}{m\_boundnetdevice})
1233             \{
1234               int32\_t index = ipv6l3->GetInterfaceForDevice (\hyperlink{classns3_1_1Socket_a9781d8dfdb5e9364d5dce8f53b768bb5}{m\_boundnetdevice});
1235               \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (index >= 0, \textcolor{stringliteral}{"Interface without a valid index"});
1236               ipv6l3->AddMulticastAddress (address, index);
1237             \}
1238           \textcolor{keywordflow}{else}
1239             \{
1240               ipv6l3->AddMulticastAddress (address);
1241             \}
1242         \}
1243     \}
1244 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 31


\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Listen@{Listen}}
\index{Listen@{Listen}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Listen(void)}{Listen(void)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Udp\+Socket\+Impl\+::\+Listen (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_a2a7b54e5e56efbd664e3e382bcfbb0f8}{}\label{classns3_1_1UdpSocketImpl_a2a7b54e5e56efbd664e3e382bcfbb0f8}


Listen for incoming connections. 

\begin{DoxyReturn}{Returns}
0 on success, -\/1 on error (in which case errno is set). 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_a6b3529a32632cf1a56debf5f79e56c54}{ns3\+::\+Socket}.


\begin{DoxyCode}
401 \{
402   \hyperlink{classns3_1_1UdpSocketImpl_ac35998e8aa2cc588e21752944b0a0095}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa777b6c9712ef5485ebecfb96d5de4d54}{Socket::ERROR\_OPNOTSUPP};
403   \textcolor{keywordflow}{return} -1;
404 \}
\end{DoxyCode}
\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Multicast\+Join\+Group@{Multicast\+Join\+Group}}
\index{Multicast\+Join\+Group@{Multicast\+Join\+Group}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Multicast\+Join\+Group(uint32\+\_\+t interface\+Index, const Address \&group\+Address)}{MulticastJoinGroup(uint32_t interfaceIndex, const Address &groupAddress)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Udp\+Socket\+Impl\+::\+Multicast\+Join\+Group (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{const {\bf Address} \&}]{group\+Address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_ae32570783dbdc0fdda43b22c2fbc9d53}{}\label{classns3_1_1UdpSocketImpl_ae32570783dbdc0fdda43b22c2fbc9d53}


Corresponds to socket option M\+C\+A\+S\+T\+\_\+\+J\+O\+I\+N\+\_\+\+G\+R\+O\+UP. 


\begin{DoxyParams}{Parameters}
{\em interface} & interface number, or 0 \\
\hline
{\em group\+Address} & multicast group address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
on success, zero is returned. On error, -\/1 is returned, and errno is set appropriately
\end{DoxyReturn}
Enable reception of multicast datagrams for this socket on the interface number specified. If zero is specified as the interface, then a single local interface is chosen by system. In the future, this function will generate trigger I\+G\+MP joins as necessary when I\+G\+MP is implemented, but for now, this just enables multicast datagram reception in the system if not already enabled for this interface/group\+Address combination.

\begin{DoxyAttention}{Attention}
I\+G\+MP is not yet implemented in ns-\/3
\end{DoxyAttention}
This function may be called repeatedly on a given socket but each join must be for a different multicast address, or for the same multicast address but on a different interface from previous joins. This enables host multihoming, and the ability to join the same group on different interfaces. 

Implements \hyperlink{classns3_1_1UdpSocket_a3aa48fac00edf4dbd519a6fc7644f0b7}{ns3\+::\+Udp\+Socket}.


\begin{DoxyCode}
921 \{
922   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (interface << groupAddress);
923   \textcolor{comment}{/*}
924 \textcolor{comment}{   1) sanity check interface}
925 \textcolor{comment}{   2) sanity check that it has not been called yet on this interface/group}
926 \textcolor{comment}{   3) determine address family of groupAddress}
927 \textcolor{comment}{   4) locally store a list of (interface, groupAddress)}
928 \textcolor{comment}{   5) call ipv4->MulticastJoinGroup () or Ipv6->MulticastJoinGroup ()}
929 \textcolor{comment}{  */}
930   \textcolor{keywordflow}{return} 0;
931 \} 
\end{DoxyCode}
\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Multicast\+Leave\+Group@{Multicast\+Leave\+Group}}
\index{Multicast\+Leave\+Group@{Multicast\+Leave\+Group}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Multicast\+Leave\+Group(uint32\+\_\+t interface\+Index, const Address \&group\+Address)}{MulticastLeaveGroup(uint32_t interfaceIndex, const Address &groupAddress)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Udp\+Socket\+Impl\+::\+Multicast\+Leave\+Group (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{const {\bf Address} \&}]{group\+Address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_a6eed2cfb6cf57309ac25e4526871b432}{}\label{classns3_1_1UdpSocketImpl_a6eed2cfb6cf57309ac25e4526871b432}


Corresponds to socket option M\+C\+A\+S\+T\+\_\+\+L\+E\+A\+V\+E\+\_\+\+G\+R\+O\+UP. 


\begin{DoxyParams}{Parameters}
{\em interface} & interface number, or 0 \\
\hline
{\em group\+Address} & multicast group address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
on success, zero is returned. On error, -\/1 is returned, and errno is set appropriately
\end{DoxyReturn}
Disable reception of multicast datagrams for this socket on the interface number specified. If zero is specified as the interface\+Index, then a single local interface is chosen by system. In the future, this function will generate trigger I\+G\+MP leaves as necessary when I\+G\+MP is implemented, but for now, this just disables multicast datagram reception in the system if this socket is the last for this interface/group\+Address combination.

\begin{DoxyAttention}{Attention}
I\+G\+MP is not yet implemented in ns-\/3 
\end{DoxyAttention}


Implements \hyperlink{classns3_1_1UdpSocket_a27f70e37f597c9ed2c3af66d1a9f330e}{ns3\+::\+Udp\+Socket}.


\begin{DoxyCode}
935 \{
936   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (interface << groupAddress);
937   \textcolor{comment}{/*}
938 \textcolor{comment}{   1) sanity check interface}
939 \textcolor{comment}{   2) determine address family of groupAddress}
940 \textcolor{comment}{   3) delete from local list of (interface, groupAddress); raise a LOG\_WARN}
941 \textcolor{comment}{      if not already present (but return 0) }
942 \textcolor{comment}{   5) call ipv4->MulticastLeaveGroup () or Ipv6->MulticastLeaveGroup ()}
943 \textcolor{comment}{  */}
944   \textcolor{keywordflow}{return} 0;
945 \}
\end{DoxyCode}
\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Recv@{Recv}}
\index{Recv@{Recv}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Recv(uint32\+\_\+t max\+Size, uint32\+\_\+t flags)}{Recv(uint32_t maxSize, uint32_t flags)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Packet} $>$ ns3\+::\+Udp\+Socket\+Impl\+::\+Recv (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{max\+Size, }
\item[{uint32\+\_\+t}]{flags}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_a7268e7d9604b790bf455a2d0e664eac1}{}\label{classns3_1_1UdpSocketImpl_a7268e7d9604b790bf455a2d0e664eac1}


Read data from the socket. 

This function matches closely in semantics to the recv() function call in the standard C library (libc)\+: ssize\+\_\+t recv (int s, void $\ast$buf, size\+\_\+t len, int flags); except that the receive I/O is asynchronous. This is the primary Recv method at this low-\/level A\+PI and must be implemented by subclasses.

This method is normally used only on a connected socket. In a typical blocking sockets model, this call would block until at least one byte is returned or the connection closes. In ns-\/3 at this A\+PI, the call returns immediately in such a case and returns 0 if nothing is available to be read. However, an application can set a callback, ns3\+::\+Set\+Recv\+Callback, to be notified of data being available to be read (when it conceptually unblocks); this is an asynchronous I/O model for recv().

This variant of \hyperlink{classns3_1_1Socket_afb4e211a54a3f63ac3f79624a3a964f7}{Recv()} uses class \hyperlink{classns3_1_1Packet}{ns3\+::\+Packet} to encapsulate data, rather than providing a raw pointer and length field. This allows an ns-\/3 application to attach tags if desired (such as a flow ID) and may allow the simulator to avoid some data copies. Despite the appearance of receiving Packets on a stream socket, just think of it as a fancy byte buffer with streaming semantics.

The semantics depend on the type of socket. For a datagram socket, each \hyperlink{classns3_1_1Socket_afb4e211a54a3f63ac3f79624a3a964f7}{Recv()} returns the data from at most one \hyperlink{classns3_1_1UdpSocketImpl_ac8e23c2e48d59b943ad5beda3c9b9cce}{Send()}, and order is not necessarily preserved. For a stream socket, the bytes are delivered in order, and on-\/the-\/wire packet boundaries are not preserved.

The flags argument is formed by or\textquotesingle{}ing one or more of the values\+: M\+S\+G\+\_\+\+O\+OB process out-\/of-\/band data M\+S\+G\+\_\+\+P\+E\+EK peek at incoming message None of these flags are supported for now.

Some variants of \hyperlink{classns3_1_1Socket_afb4e211a54a3f63ac3f79624a3a964f7}{Recv()} are supported as additional A\+PI, including \hyperlink{classns3_1_1UdpSocketImpl_a5e460efb45eaf5fab145970043614ec8}{Recv\+From()}, overloaded \hyperlink{classns3_1_1Socket_afb4e211a54a3f63ac3f79624a3a964f7}{Recv()} without arguments, and variants that use raw character buffers.


\begin{DoxyParams}{Parameters}
{\em max\+Size} & reader will accept packet up to max\+Size \\
\hline
{\em flags} & \hyperlink{classns3_1_1Socket}{Socket} control flags \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{classns3_1_1Ptr}{Ptr$<$\+Packet$>$} of the next in-\/sequence packet. Returns 0 if the socket cannot return a next in-\/sequence packet conforming to the max\+Size and flags.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Socket_a243f7835ef1a85f9270fd3577e3a40da}{Set\+Recv\+Callback} 
\end{DoxySeeAlso}


Implements \hyperlink{classns3_1_1Socket_a8949b1f844aae563446f2f4c5be8827a}{ns3\+::\+Socket}.


\begin{DoxyCode}
833 \{
834   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << maxSize << flags);
835 
836   Address fromAddress;
837   Ptr<Packet> packet = \hyperlink{classns3_1_1UdpSocketImpl_a5e460efb45eaf5fab145970043614ec8}{RecvFrom} (maxSize, flags, fromAddress);
838   \textcolor{keywordflow}{return} packet;
839 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 32


\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Recv\+From@{Recv\+From}}
\index{Recv\+From@{Recv\+From}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Recv\+From(uint32\+\_\+t max\+Size, uint32\+\_\+t flags, Address \&from\+Address)}{RecvFrom(uint32_t maxSize, uint32_t flags, Address &fromAddress)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Packet} $>$ ns3\+::\+Udp\+Socket\+Impl\+::\+Recv\+From (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{max\+Size, }
\item[{uint32\+\_\+t}]{flags, }
\item[{{\bf Address} \&}]{from\+Address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_a5e460efb45eaf5fab145970043614ec8}{}\label{classns3_1_1UdpSocketImpl_a5e460efb45eaf5fab145970043614ec8}


Read a single packet from the socket and retrieve the sender address. 

Calls Recv(max\+Size, flags) with max\+Size implicitly set to maximum sized integer, and flags set to zero.

This method has similar semantics to Recv () but subclasses may want to provide checks on socket state, so the implementation is pushed to subclasses.


\begin{DoxyParams}{Parameters}
{\em max\+Size} & reader will accept packet up to max\+Size \\
\hline
{\em flags} & \hyperlink{classns3_1_1Socket}{Socket} control flags \\
\hline
{\em from\+Address} & output parameter that will return the address of the sender of the received packet, if any. Remains untouched if no packet is received. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{classns3_1_1Ptr}{Ptr$<$\+Packet$>$} of the next in-\/sequence packet. Returns 0 if the socket cannot return a next in-\/sequence packet. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_af22378d7af9a2745a9eada20210da215}{ns3\+::\+Socket}.


\begin{DoxyCode}
844 \{
845   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << maxSize << flags);
846 
847   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_a6a95636f11b186eab1f70727500d9233}{m\_deliveryQueue}.empty () )
848     \{
849       \hyperlink{classns3_1_1UdpSocketImpl_ac35998e8aa2cc588e21752944b0a0095}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa723fae47c9706428b1ed0368d508e8ba}{ERROR\_AGAIN};
850       \textcolor{keywordflow}{return} 0;
851     \}
852   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = \hyperlink{classns3_1_1UdpSocketImpl_a6a95636f11b186eab1f70727500d9233}{m\_deliveryQueue}.front ().first;
853   fromAddress = \hyperlink{classns3_1_1UdpSocketImpl_a6a95636f11b186eab1f70727500d9233}{m\_deliveryQueue}.front ().second;
854 
855   \textcolor{keywordflow}{if} (p->GetSize () <= maxSize)
856     \{
857       \hyperlink{classns3_1_1UdpSocketImpl_a6a95636f11b186eab1f70727500d9233}{m\_deliveryQueue}.pop ();
858       \hyperlink{classns3_1_1UdpSocketImpl_a73e12067139eb298bbb4b0e2c2e56a6a}{m\_rxAvailable} -= p->GetSize ();
859     \}
860   \textcolor{keywordflow}{else}
861     \{
862       p = 0;
863     \}
864   \textcolor{keywordflow}{return} \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p};
865 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 33




Here is the caller graph for this function\+:
% FIG 34


\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Send@{Send}}
\index{Send@{Send}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Send(\+Ptr$<$ Packet $>$ p, uint32\+\_\+t flags)}{Send(Ptr< Packet > p, uint32_t flags)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Udp\+Socket\+Impl\+::\+Send (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{uint32\+\_\+t}]{flags}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_ac8e23c2e48d59b943ad5beda3c9b9cce}{}\label{classns3_1_1UdpSocketImpl_ac8e23c2e48d59b943ad5beda3c9b9cce}


Send data (or dummy data) to the remote host. 

This function matches closely in semantics to the send() function call in the standard C library (libc)\+: ssize\+\_\+t send (int s, const void $\ast$msg, size\+\_\+t len, int flags); except that the send I/O is asynchronous. This is the primary Send method at this low-\/level A\+PI and must be implemented by subclasses.

In a typical blocking sockets model, this call would block upon lack of space to hold the message to be sent. In ns-\/3 at this A\+PI, the call returns immediately in such a case, but the callback registered with \hyperlink{classns3_1_1Socket_a85ff5c8cc7d242823f301b49264c68a4}{Set\+Send\+Callback()} is invoked when the socket has space (when it conceptually unblocks); this is an asynchronous I/O model for send().

This variant of \hyperlink{classns3_1_1UdpSocketImpl_ac8e23c2e48d59b943ad5beda3c9b9cce}{Send()} uses class \hyperlink{classns3_1_1Packet}{ns3\+::\+Packet} to encapsulate data, rather than providing a raw pointer and length field. This allows an ns-\/3 application to attach tags if desired (such as a flow ID) and may allow the simulator to avoid some data copies. Despite the appearance of sending Packets on a stream socket, just think of it as a fancy byte buffer with streaming semantics.

If either the message buffer within the \hyperlink{classns3_1_1Packet}{Packet} is too long to pass atomically through the underlying protocol (for datagram sockets), or the message buffer cannot entirely fit in the transmit buffer (for stream sockets), -\/1 is returned and Socket\+Errno is set to E\+R\+R\+O\+R\+\_\+\+M\+S\+G\+S\+I\+ZE. If the packet does not fit, the caller can split the \hyperlink{classns3_1_1Packet}{Packet} (based on information obtained from Get\+Tx\+Available) and reattempt to send the data.

The flags argument is formed by or\textquotesingle{}ing one or more of the values\+: M\+S\+G\+\_\+\+O\+OB process out-\/of-\/band data M\+S\+G\+\_\+\+D\+O\+N\+T\+R\+O\+U\+TE bypass routing, use direct interface These flags are {\itshape unsupported} as of ns-\/3.\+1.


\begin{DoxyParams}{Parameters}
{\em p} & \hyperlink{classns3_1_1Packet}{ns3\+::\+Packet} to send \\
\hline
{\em flags} & \hyperlink{classns3_1_1Socket}{Socket} control flags \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of bytes accepted for transmission if no error occurs, and -\/1 otherwise.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Socket_a85ff5c8cc7d242823f301b49264c68a4}{Set\+Send\+Callback} 
\end{DoxySeeAlso}


Implements \hyperlink{classns3_1_1Socket_a036901c8f485fe5b6eab93b7f2ec289d}{ns3\+::\+Socket}.


\begin{DoxyCode}
408 \{
409   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << p << flags);
410 
411   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1UdpSocketImpl_a2df1a2df7ba0f4c852ad1d2155b1fbcc}{m\_connected})
412     \{
413       \hyperlink{classns3_1_1UdpSocketImpl_ac35998e8aa2cc588e21752944b0a0095}{m\_errno} = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaaeb1fd23c1f4965b496786597125bf0f6}{ERROR\_NOTCONN};
414       \textcolor{keywordflow}{return} -1;
415     \}
416 
417   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UdpSocketImpl_aeb7a2f7998edd56c9079ac6a3518cd89}{DoSend} (p);
418 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 35


\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Send\+To@{Send\+To}}
\index{Send\+To@{Send\+To}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Send\+To(\+Ptr$<$ Packet $>$ p, uint32\+\_\+t flags, const Address \&address)}{SendTo(Ptr< Packet > p, uint32_t flags, const Address &address)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Udp\+Socket\+Impl\+::\+Send\+To (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{uint32\+\_\+t}]{flags, }
\item[{const {\bf Address} \&}]{to\+Address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_a8157d2ad72321be1047493ebf97e55f5}{}\label{classns3_1_1UdpSocketImpl_a8157d2ad72321be1047493ebf97e55f5}


Send data to a specified peer. 

This method has similar semantics to Send () but subclasses may want to provide checks on socket state, so the implementation is pushed to subclasses.


\begin{DoxyParams}{Parameters}
{\em p} & packet to send \\
\hline
{\em flags} & \hyperlink{classns3_1_1Socket}{Socket} control flags \\
\hline
{\em to\+Address} & IP \hyperlink{classns3_1_1Address}{Address} of remote host \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
-\/1 in case of error or the number of bytes copied in the internal buffer and accepted for transmission. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_af898fce6a58e0dbba23c1c6de1d4220e}{ns3\+::\+Socket}.


\begin{DoxyCode}
801 \{
802   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << p << flags << address);
803   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1InetSocketAddress_a9426766e34e928ce5dbdbeb9563a10df}{InetSocketAddress::IsMatchingType} (address))
804     \{
805       InetSocketAddress transport = \hyperlink{classns3_1_1InetSocketAddress_ade776b1109e7b9a7be0b22ced49931e3}{InetSocketAddress::ConvertFrom} (address);
806       Ipv4Address ipv4 = transport.GetIpv4 ();
807       uint16\_t \hyperlink{dsdv-manet_8cc_a8e0798404bf2cf5dabb84c5ba9a4f236}{port} = transport.GetPort ();
808       uint8\_t tos = transport.GetTos ();
809      \textcolor{comment}{// std::cout << ipv4 << std::endl;}
810       \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UdpSocketImpl_a18b22c398f6e9a7806f92b6a3ca7b3e8}{DoSendTo} (p, ipv4, port, tos);
811     \}
812   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Inet6SocketAddress_a4d928c54affbfb530a12076d6d7e0540}{Inet6SocketAddress::IsMatchingType} (address))
813     \{
814       Inet6SocketAddress transport = \hyperlink{classns3_1_1Inet6SocketAddress_a2177c66e1bcf17c85dcffb9d2a971f5a}{Inet6SocketAddress::ConvertFrom} (
      address);
815       Ipv6Address ipv6 = transport.GetIpv6 ();
816       uint16\_t port = transport.GetPort ();
817       \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UdpSocketImpl_a18b22c398f6e9a7806f92b6a3ca7b3e8}{DoSendTo} (p, ipv6, port);
818     \}
819   \textcolor{keywordflow}{return} -1;
820 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 36


\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Set\+Allow\+Broadcast@{Set\+Allow\+Broadcast}}
\index{Set\+Allow\+Broadcast@{Set\+Allow\+Broadcast}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Set\+Allow\+Broadcast(bool allow\+Broadcast)}{SetAllowBroadcast(bool allowBroadcast)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Udp\+Socket\+Impl\+::\+Set\+Allow\+Broadcast (
\begin{DoxyParamCaption}
\item[{bool}]{allow\+Broadcast}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_a99fd369504ca05485b7be7a426fbb4d5}{}\label{classns3_1_1UdpSocketImpl_a99fd369504ca05485b7be7a426fbb4d5}


Configure whether broadcast datagram transmissions are allowed. 

This method corresponds to using setsockopt() S\+O\+\_\+\+B\+R\+O\+A\+D\+C\+A\+ST of real network or B\+SD sockets. If set on a socket, this option will enable or disable packets to be transmitted to broadcast destination addresses.


\begin{DoxyParams}{Parameters}
{\em allow\+Broadcast} & Whether broadcast is allowed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if operation succeeds 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Socket_a32b4fa27b732a63207c8d9054a817ed5}{ns3\+::\+Socket}.


\begin{DoxyCode}
1191 \{
1192   \hyperlink{classns3_1_1UdpSocketImpl_a071404252802565f1d1511b5c98b155a}{m\_allowBroadcast} = allowBroadcast;
1193   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1194 \}
\end{DoxyCode}
\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Set\+Ip\+Multicast\+If@{Set\+Ip\+Multicast\+If}}
\index{Set\+Ip\+Multicast\+If@{Set\+Ip\+Multicast\+If}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Set\+Ip\+Multicast\+If(int32\+\_\+t ip\+If)}{SetIpMulticastIf(int32_t ipIf)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Udp\+Socket\+Impl\+::\+Set\+Ip\+Multicast\+If (
\begin{DoxyParamCaption}
\item[{int32\+\_\+t}]{ip\+If}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_addfb5894a849eb136d084d5aac4d10ae}{}\label{classns3_1_1UdpSocketImpl_addfb5894a849eb136d084d5aac4d10ae}


Set the IP multicast interface. 


\begin{DoxyParams}{Parameters}
{\em ip\+If} & the IP multicast interface \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1UdpSocket_a20d595600406785f84dd3bd999b3dce4}{ns3\+::\+Udp\+Socket}.


\begin{DoxyCode}
1156 \{
1157   \hyperlink{classns3_1_1UdpSocketImpl_a4ff1b1c6db56fad154afe2563d985e08}{m\_ipMulticastIf} = ipIf;
1158 \}
\end{DoxyCode}
\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Set\+Ip\+Multicast\+Loop@{Set\+Ip\+Multicast\+Loop}}
\index{Set\+Ip\+Multicast\+Loop@{Set\+Ip\+Multicast\+Loop}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Set\+Ip\+Multicast\+Loop(bool loop)}{SetIpMulticastLoop(bool loop)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Udp\+Socket\+Impl\+::\+Set\+Ip\+Multicast\+Loop (
\begin{DoxyParamCaption}
\item[{bool}]{loop}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_a71747eac52a9dcace2fdd1febf3cab3e}{}\label{classns3_1_1UdpSocketImpl_a71747eac52a9dcace2fdd1febf3cab3e}


Set the IP multicast loop capability. 

This means that the socket will receive the packets sent by itself on a multicast address. Equivalent to setsockopt I\+P\+\_\+\+M\+U\+L\+T\+I\+C\+A\+S\+T\+\_\+\+L\+O\+OP


\begin{DoxyParams}{Parameters}
{\em loop} & the IP multicast loop capability \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1UdpSocket_ab5c0ee492146d4639b717974ada67e93}{ns3\+::\+Udp\+Socket}.


\begin{DoxyCode}
1168 \{
1169   \hyperlink{classns3_1_1UdpSocketImpl_aa201ce3516300da49c3e602e21cd6f6d}{m\_ipMulticastLoop} = loop;
1170 \}
\end{DoxyCode}
\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Set\+Ip\+Multicast\+Ttl@{Set\+Ip\+Multicast\+Ttl}}
\index{Set\+Ip\+Multicast\+Ttl@{Set\+Ip\+Multicast\+Ttl}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Set\+Ip\+Multicast\+Ttl(uint8\+\_\+t ip\+Ttl)}{SetIpMulticastTtl(uint8_t ipTtl)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Udp\+Socket\+Impl\+::\+Set\+Ip\+Multicast\+Ttl (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{ip\+Ttl}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_aff7e58ad0fc890d358d4f0d8eccddb95}{}\label{classns3_1_1UdpSocketImpl_aff7e58ad0fc890d358d4f0d8eccddb95}


Set the IP multicast T\+TL. 


\begin{DoxyParams}{Parameters}
{\em ip\+Ttl} & the IP multicast T\+TL \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1UdpSocket_af62d9cab3ecae6be95c7c33850126889}{ns3\+::\+Udp\+Socket}.


\begin{DoxyCode}
1144 \{
1145   \hyperlink{classns3_1_1UdpSocketImpl_a4849465356cef8573ed373d12a5a62ec}{m\_ipMulticastTtl} = ipTtl;
1146 \}
\end{DoxyCode}
\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Set\+Mtu\+Discover@{Set\+Mtu\+Discover}}
\index{Set\+Mtu\+Discover@{Set\+Mtu\+Discover}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Set\+Mtu\+Discover(bool discover)}{SetMtuDiscover(bool discover)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Udp\+Socket\+Impl\+::\+Set\+Mtu\+Discover (
\begin{DoxyParamCaption}
\item[{bool}]{discover}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_a0f6987b77c5b5635ad779c4c465b8375}{}\label{classns3_1_1UdpSocketImpl_a0f6987b77c5b5635ad779c4c465b8375}


Set the M\+TU discover capability. 


\begin{DoxyParams}{Parameters}
{\em discover} & the M\+TU discover capability \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1UdpSocket_ae3f06fb2459a7c09f91068905a063a6a}{ns3\+::\+Udp\+Socket}.


\begin{DoxyCode}
1180 \{
1181   \hyperlink{classns3_1_1UdpSocketImpl_ab5ae932e01b5746539b9ad20b3ff4f46}{m\_mtuDiscover} = discover;
1182 \}
\end{DoxyCode}
\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Set\+Node@{Set\+Node}}
\index{Set\+Node@{Set\+Node}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Set\+Node(\+Ptr$<$ Node $>$ node)}{SetNode(Ptr< Node > node)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Udp\+Socket\+Impl\+::\+Set\+Node (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UdpSocketImpl_abdbd6d194bd91c0c29f43698ddee2210}{}\label{classns3_1_1UdpSocketImpl_abdbd6d194bd91c0c29f43698ddee2210}


Set the associated node. 


\begin{DoxyParams}{Parameters}
{\em node} & the node \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
139 \{
140   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
141   \hyperlink{classns3_1_1UdpSocketImpl_af6a19247be3d8917b582af77337730c3}{m\_node} = node;
142 
143 \}
\end{DoxyCode}
\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Set\+Rcv\+Buf\+Size@{Set\+Rcv\+Buf\+Size}}
\index{Set\+Rcv\+Buf\+Size@{Set\+Rcv\+Buf\+Size}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Set\+Rcv\+Buf\+Size(uint32\+\_\+t size)}{SetRcvBufSize(uint32_t size)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Udp\+Socket\+Impl\+::\+Set\+Rcv\+Buf\+Size (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_a002c494bd9a8b8e9283aacce41c081a9}{}\label{classns3_1_1UdpSocketImpl_a002c494bd9a8b8e9283aacce41c081a9}


Set the receiving buffer size. 


\begin{DoxyParams}{Parameters}
{\em size} & the buffer size \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1UdpSocket_a4d598f07e803641d6fa869c866caea44}{ns3\+::\+Udp\+Socket}.


\begin{DoxyCode}
1132 \{
1133   \hyperlink{classns3_1_1UdpSocketImpl_a81c69f998616d1d79a9c81c569b725e9}{m\_rcvBufSize} = size;
1134 \}
\end{DoxyCode}
\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Set\+Udp@{Set\+Udp}}
\index{Set\+Udp@{Set\+Udp}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Set\+Udp(\+Ptr$<$ Udp\+L4\+Protocol $>$ udp)}{SetUdp(Ptr< UdpL4Protocol > udp)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Udp\+Socket\+Impl\+::\+Set\+Udp (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Udp\+L4\+Protocol} $>$}]{udp}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UdpSocketImpl_a0138b99fbde4ea810ce1aa2e4500dff4}{}\label{classns3_1_1UdpSocketImpl_a0138b99fbde4ea810ce1aa2e4500dff4}


Set the associated U\+DP L4 protocol. 


\begin{DoxyParams}{Parameters}
{\em udp} & the U\+DP L4 protocol \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
146 \{
147   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
148   \hyperlink{classns3_1_1UdpSocketImpl_ace4b90c1ab6f4f302cdb4cd8da973514}{m\_udp} = udp;
149 \}
\end{DoxyCode}
\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Shutdown\+Recv@{Shutdown\+Recv}}
\index{Shutdown\+Recv@{Shutdown\+Recv}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Shutdown\+Recv(void)}{ShutdownRecv(void)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Udp\+Socket\+Impl\+::\+Shutdown\+Recv (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_a63d835c2b62497baa89b2a3ff7341fd4}{}\label{classns3_1_1UdpSocketImpl_a63d835c2b62497baa89b2a3ff7341fd4}
\begin{DoxyReturn}{Returns}
zero on success, -\/1 on failure.
\end{DoxyReturn}
Do not allow any further Recv calls. This method is typically implemented for Tcp sockets by a half close. 

Implements \hyperlink{classns3_1_1Socket_a5a6b835bb7ccf2cf43b54912e7cae600}{ns3\+::\+Socket}.


\begin{DoxyCode}
339 \{
340   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
341   \hyperlink{classns3_1_1UdpSocketImpl_abda20957e451801973534c38d9d74f4a}{m\_shutdownRecv} = \textcolor{keyword}{true};
342   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint})
343     \{
344       \hyperlink{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{m\_endPoint}->\hyperlink{classns3_1_1Ipv4EndPoint_a76b96b25ce48190143a423b62645579c}{SetRxEnabled} (\textcolor{keyword}{false});
345     \}
346   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6})
347     \{
348       \hyperlink{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{m\_endPoint6}->\hyperlink{classns3_1_1Ipv6EndPoint_ab580b3c4f007524be5178d5758ccea67}{SetRxEnabled} (\textcolor{keyword}{false});
349     \}
350   \textcolor{keywordflow}{return} 0;
351 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 37


\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Shutdown\+Send@{Shutdown\+Send}}
\index{Shutdown\+Send@{Shutdown\+Send}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Shutdown\+Send(void)}{ShutdownSend(void)}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Udp\+Socket\+Impl\+::\+Shutdown\+Send (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UdpSocketImpl_a8a246f3ad4a45f0f397e2ccca71dc843}{}\label{classns3_1_1UdpSocketImpl_a8a246f3ad4a45f0f397e2ccca71dc843}
\begin{DoxyReturn}{Returns}
zero on success, -\/1 on failure.
\end{DoxyReturn}
Do not allow any further Send calls. This method is typically implemented for Tcp sockets by a half close. 

Implements \hyperlink{classns3_1_1Socket_a8186c87627fa3ece326d8f1c822d7f95}{ns3\+::\+Socket}.


\begin{DoxyCode}
331 \{
332   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
333   \hyperlink{classns3_1_1UdpSocketImpl_a9ff4985bbd8bdc29bbe36ba0937149fa}{m\_shutdownSend} = \textcolor{keyword}{true};
334   \textcolor{keywordflow}{return} 0;
335 \}
\end{DoxyCode}


\subsection{Friends And Related Function Documentation}
\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!Udp\+Socket\+Factory@{Udp\+Socket\+Factory}}
\index{Udp\+Socket\+Factory@{Udp\+Socket\+Factory}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{Udp\+Socket\+Factory}{UdpSocketFactory}}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf Udp\+Socket\+Factory}\hspace{0.3cm}{\ttfamily [friend]}}\hypertarget{classns3_1_1UdpSocketImpl_afba47205bf14e005b7444bb89be13029}{}\label{classns3_1_1UdpSocketImpl_afba47205bf14e005b7444bb89be13029}


\hyperlink{classns3_1_1UdpSocketFactory}{Udp\+Socket\+Factory} friend class. 



\subsection{Member Data Documentation}
\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!m\+\_\+allow\+Broadcast@{m\+\_\+allow\+Broadcast}}
\index{m\+\_\+allow\+Broadcast@{m\+\_\+allow\+Broadcast}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+allow\+Broadcast}{m_allowBroadcast}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Udp\+Socket\+Impl\+::m\+\_\+allow\+Broadcast\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_a071404252802565f1d1511b5c98b155a}{}\label{classns3_1_1UdpSocketImpl_a071404252802565f1d1511b5c98b155a}


Allow send broadcast packets. 

\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!m\+\_\+connected@{m\+\_\+connected}}
\index{m\+\_\+connected@{m\+\_\+connected}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+connected}{m_connected}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Udp\+Socket\+Impl\+::m\+\_\+connected\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_a2df1a2df7ba0f4c852ad1d2155b1fbcc}{}\label{classns3_1_1UdpSocketImpl_a2df1a2df7ba0f4c852ad1d2155b1fbcc}


Connection established. 

\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!m\+\_\+default\+Address@{m\+\_\+default\+Address}}
\index{m\+\_\+default\+Address@{m\+\_\+default\+Address}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+default\+Address}{m_defaultAddress}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Udp\+Socket\+Impl\+::m\+\_\+default\+Address\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_a820bb30415d2627cea60338649d19ccb}{}\label{classns3_1_1UdpSocketImpl_a820bb30415d2627cea60338649d19ccb}


Default address. 

\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!m\+\_\+default\+Port@{m\+\_\+default\+Port}}
\index{m\+\_\+default\+Port@{m\+\_\+default\+Port}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+default\+Port}{m_defaultPort}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Udp\+Socket\+Impl\+::m\+\_\+default\+Port\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_a990120b2cc768c47a6a2a2a1e53875c8}{}\label{classns3_1_1UdpSocketImpl_a990120b2cc768c47a6a2a2a1e53875c8}


Default port. 

\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!m\+\_\+delivery\+Queue@{m\+\_\+delivery\+Queue}}
\index{m\+\_\+delivery\+Queue@{m\+\_\+delivery\+Queue}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+delivery\+Queue}{m_deliveryQueue}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::queue$<$std\+::pair$<${\bf Ptr}$<${\bf Packet}$>$, {\bf Address}$>$ $>$ ns3\+::\+Udp\+Socket\+Impl\+::m\+\_\+delivery\+Queue\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_a6a95636f11b186eab1f70727500d9233}{}\label{classns3_1_1UdpSocketImpl_a6a95636f11b186eab1f70727500d9233}


\hyperlink{classns3_1_1Queue}{Queue} for incoming packets. 

\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!m\+\_\+drop\+Trace@{m\+\_\+drop\+Trace}}
\index{m\+\_\+drop\+Trace@{m\+\_\+drop\+Trace}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+drop\+Trace}{m_dropTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Udp\+Socket\+Impl\+::m\+\_\+drop\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_a786fed61e3c4c68280656c4036514c11}{}\label{classns3_1_1UdpSocketImpl_a786fed61e3c4c68280656c4036514c11}


Trace for dropped packets. 

\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!m\+\_\+end\+Point@{m\+\_\+end\+Point}}
\index{m\+\_\+end\+Point@{m\+\_\+end\+Point}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+end\+Point}{m_endPoint}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+End\+Point}$\ast$ ns3\+::\+Udp\+Socket\+Impl\+::m\+\_\+end\+Point\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}{}\label{classns3_1_1UdpSocketImpl_a4ea3006a4e49185d06360beba92f4073}


the I\+Pv4 endpoint 

\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!m\+\_\+end\+Point6@{m\+\_\+end\+Point6}}
\index{m\+\_\+end\+Point6@{m\+\_\+end\+Point6}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+end\+Point6}{m_endPoint6}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+End\+Point}$\ast$ ns3\+::\+Udp\+Socket\+Impl\+::m\+\_\+end\+Point6\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}{}\label{classns3_1_1UdpSocketImpl_ad8b59997645c24d4550092d138270652}


the I\+Pv6 endpoint 

\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!m\+\_\+errno@{m\+\_\+errno}}
\index{m\+\_\+errno@{m\+\_\+errno}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+errno}{m_errno}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Socket\+Errno} ns3\+::\+Udp\+Socket\+Impl\+::m\+\_\+errno\hspace{0.3cm}{\ttfamily [mutable]}, {\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_ac35998e8aa2cc588e21752944b0a0095}{}\label{classns3_1_1UdpSocketImpl_ac35998e8aa2cc588e21752944b0a0095}


\hyperlink{classns3_1_1Socket}{Socket} error code. 

\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!m\+\_\+icmp\+Callback@{m\+\_\+icmp\+Callback}}
\index{m\+\_\+icmp\+Callback@{m\+\_\+icmp\+Callback}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+icmp\+Callback}{m_icmpCallback}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Callback}$<$void, {\bf Ipv4\+Address},uint8\+\_\+t,uint8\+\_\+t,uint8\+\_\+t,uint32\+\_\+t$>$ ns3\+::\+Udp\+Socket\+Impl\+::m\+\_\+icmp\+Callback\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_a0a595e39113e8854c86c820623ae6cd4}{}\label{classns3_1_1UdpSocketImpl_a0a595e39113e8854c86c820623ae6cd4}


I\+C\+MP callback. 

\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!m\+\_\+icmp\+Callback6@{m\+\_\+icmp\+Callback6}}
\index{m\+\_\+icmp\+Callback6@{m\+\_\+icmp\+Callback6}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+icmp\+Callback6}{m_icmpCallback6}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Callback}$<$void, {\bf Ipv6\+Address},uint8\+\_\+t,uint8\+\_\+t,uint8\+\_\+t,uint32\+\_\+t$>$ ns3\+::\+Udp\+Socket\+Impl\+::m\+\_\+icmp\+Callback6\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_aa4fbff077aa5ca080279196abaa87a04}{}\label{classns3_1_1UdpSocketImpl_aa4fbff077aa5ca080279196abaa87a04}


I\+C\+M\+Pv6 callback. 

\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!m\+\_\+ip\+Multicast\+If@{m\+\_\+ip\+Multicast\+If}}
\index{m\+\_\+ip\+Multicast\+If@{m\+\_\+ip\+Multicast\+If}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+ip\+Multicast\+If}{m_ipMulticastIf}}]{\setlength{\rightskip}{0pt plus 5cm}int32\+\_\+t ns3\+::\+Udp\+Socket\+Impl\+::m\+\_\+ip\+Multicast\+If\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_a4ff1b1c6db56fad154afe2563d985e08}{}\label{classns3_1_1UdpSocketImpl_a4ff1b1c6db56fad154afe2563d985e08}


Multicast Interface. 

\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!m\+\_\+ip\+Multicast\+Loop@{m\+\_\+ip\+Multicast\+Loop}}
\index{m\+\_\+ip\+Multicast\+Loop@{m\+\_\+ip\+Multicast\+Loop}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+ip\+Multicast\+Loop}{m_ipMulticastLoop}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Udp\+Socket\+Impl\+::m\+\_\+ip\+Multicast\+Loop\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_aa201ce3516300da49c3e602e21cd6f6d}{}\label{classns3_1_1UdpSocketImpl_aa201ce3516300da49c3e602e21cd6f6d}


Allow multicast loop. 

\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!m\+\_\+ip\+Multicast\+Ttl@{m\+\_\+ip\+Multicast\+Ttl}}
\index{m\+\_\+ip\+Multicast\+Ttl@{m\+\_\+ip\+Multicast\+Ttl}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+ip\+Multicast\+Ttl}{m_ipMulticastTtl}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::\+Udp\+Socket\+Impl\+::m\+\_\+ip\+Multicast\+Ttl\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_a4849465356cef8573ed373d12a5a62ec}{}\label{classns3_1_1UdpSocketImpl_a4849465356cef8573ed373d12a5a62ec}


Multicast T\+TL. 

\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!m\+\_\+mtu\+Discover@{m\+\_\+mtu\+Discover}}
\index{m\+\_\+mtu\+Discover@{m\+\_\+mtu\+Discover}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+mtu\+Discover}{m_mtuDiscover}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Udp\+Socket\+Impl\+::m\+\_\+mtu\+Discover\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_ab5ae932e01b5746539b9ad20b3ff4f46}{}\label{classns3_1_1UdpSocketImpl_ab5ae932e01b5746539b9ad20b3ff4f46}


Allow M\+TU discovery. 

\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!m\+\_\+node@{m\+\_\+node}}
\index{m\+\_\+node@{m\+\_\+node}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+node}{m_node}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Node}$>$ ns3\+::\+Udp\+Socket\+Impl\+::m\+\_\+node\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_af6a19247be3d8917b582af77337730c3}{}\label{classns3_1_1UdpSocketImpl_af6a19247be3d8917b582af77337730c3}


the associated node 

\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!m\+\_\+rcv\+Buf\+Size@{m\+\_\+rcv\+Buf\+Size}}
\index{m\+\_\+rcv\+Buf\+Size@{m\+\_\+rcv\+Buf\+Size}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+rcv\+Buf\+Size}{m_rcvBufSize}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Udp\+Socket\+Impl\+::m\+\_\+rcv\+Buf\+Size\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_a81c69f998616d1d79a9c81c569b725e9}{}\label{classns3_1_1UdpSocketImpl_a81c69f998616d1d79a9c81c569b725e9}


Receive buffer size. 

\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!m\+\_\+rx\+Available@{m\+\_\+rx\+Available}}
\index{m\+\_\+rx\+Available@{m\+\_\+rx\+Available}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+rx\+Available}{m_rxAvailable}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Udp\+Socket\+Impl\+::m\+\_\+rx\+Available\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_a73e12067139eb298bbb4b0e2c2e56a6a}{}\label{classns3_1_1UdpSocketImpl_a73e12067139eb298bbb4b0e2c2e56a6a}


Number of available bytes to be received. 

\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!m\+\_\+shutdown\+Recv@{m\+\_\+shutdown\+Recv}}
\index{m\+\_\+shutdown\+Recv@{m\+\_\+shutdown\+Recv}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+shutdown\+Recv}{m_shutdownRecv}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Udp\+Socket\+Impl\+::m\+\_\+shutdown\+Recv\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_abda20957e451801973534c38d9d74f4a}{}\label{classns3_1_1UdpSocketImpl_abda20957e451801973534c38d9d74f4a}


Receive no longer allowed. 

\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!m\+\_\+shutdown\+Send@{m\+\_\+shutdown\+Send}}
\index{m\+\_\+shutdown\+Send@{m\+\_\+shutdown\+Send}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+shutdown\+Send}{m_shutdownSend}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Udp\+Socket\+Impl\+::m\+\_\+shutdown\+Send\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_a9ff4985bbd8bdc29bbe36ba0937149fa}{}\label{classns3_1_1UdpSocketImpl_a9ff4985bbd8bdc29bbe36ba0937149fa}


Send no longer allowed. 

\index{ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}!m\+\_\+udp@{m\+\_\+udp}}
\index{m\+\_\+udp@{m\+\_\+udp}!ns3\+::\+Udp\+Socket\+Impl@{ns3\+::\+Udp\+Socket\+Impl}}
\subsubsection[{\texorpdfstring{m\+\_\+udp}{m_udp}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Udp\+L4\+Protocol}$>$ ns3\+::\+Udp\+Socket\+Impl\+::m\+\_\+udp\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UdpSocketImpl_ace4b90c1ab6f4f302cdb4cd8da973514}{}\label{classns3_1_1UdpSocketImpl_ace4b90c1ab6f4f302cdb4cd8da973514}


the associated U\+DP L4 protocol 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/model/\hyperlink{udp-socket-impl_8h}{udp-\/socket-\/impl.\+h}\item 
internet/model/\hyperlink{udp-socket-impl_8cc}{udp-\/socket-\/impl.\+cc}\end{DoxyCompactItemize}
