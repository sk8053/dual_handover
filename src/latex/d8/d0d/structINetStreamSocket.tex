\hypertarget{structINetStreamSocket}{}\section{I\+Net\+Stream\+Socket Struct Reference}
\label{structINetStreamSocket}\index{I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}}


Struct interface to N\+SC Stream (i.\+e., T\+CP) Sockets.  




{\ttfamily \#include $<$sim\+\_\+interface.\+h$>$}



Collaboration diagram for I\+Net\+Stream\+Socket\+:
% FIG 0
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual \hyperlink{structINetStreamSocket_a0eba64b33fce654161af0d798d821cf3}{$\sim$\+I\+Net\+Stream\+Socket} ()
\item 
virtual void \hyperlink{structINetStreamSocket_a9efb75e90465e3b182b21fb3ab856415}{connect} (const char $\ast$, int)=0
\begin{DoxyCompactList}\small\item\em Connect to a remote peer. \end{DoxyCompactList}\item 
virtual void \hyperlink{structINetStreamSocket_a902ff1a4caaab6e819e4bfae667a2108}{disconnect} ()=0
\begin{DoxyCompactList}\small\item\em Disconnect from a remote peer. \end{DoxyCompactList}\item 
virtual void \hyperlink{structINetStreamSocket_abbbe6a0061c5fcd1c5e223e2be3917ba}{listen} (int)=0
\begin{DoxyCompactList}\small\item\em Put the socket in Listening state on a port. \end{DoxyCompactList}\item 
virtual int \hyperlink{structINetStreamSocket_af2bd0b33de3a8a30f539eda297786188}{accept} (\hyperlink{structINetStreamSocket}{I\+Net\+Stream\+Socket} $\ast$$\ast$handler)=0
\begin{DoxyCompactList}\small\item\em Accept an incoming connection. \end{DoxyCompactList}\item 
virtual int \hyperlink{structINetStreamSocket_a112d5229b9dedebe7099fd4458ab28e4}{send\+\_\+data} (const void $\ast$\hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data}, int datalen)=0
\begin{DoxyCompactList}\small\item\em Send some data. \end{DoxyCompactList}\item 
virtual int \hyperlink{structINetStreamSocket_af040d53ef58b3b690e8930b7f71ec845}{read\+\_\+data} (void $\ast$buf, int $\ast$buflen)=0
\begin{DoxyCompactList}\small\item\em Read some data. \end{DoxyCompactList}\item 
virtual int \hyperlink{structINetStreamSocket_adb85eedd5265fd2fc546904848bb7001}{setsockopt} (char $\ast$optname, void $\ast$val, size\+\_\+t valsize)=0
\begin{DoxyCompactList}\small\item\em Set the socket options. \end{DoxyCompactList}\item 
virtual void \hyperlink{structINetStreamSocket_a0502550bedfd2199ee9a8169d84adbd6}{print\+\_\+state} (F\+I\+LE $\ast$)=0
\begin{DoxyCompactList}\small\item\em Print the socket state. \end{DoxyCompactList}\item 
virtual bool \hyperlink{structINetStreamSocket_ae12c5b0dc6d534b3fe6f185a7dc72265}{is\+\_\+connected} ()=0
\begin{DoxyCompactList}\small\item\em Check the connection state. \end{DoxyCompactList}\item 
virtual bool \hyperlink{structINetStreamSocket_a26fa9760ab071598a8b1b4da9e852b09}{is\+\_\+listening} ()=0
\begin{DoxyCompactList}\small\item\em Check the listening state. \end{DoxyCompactList}\item 
virtual int \hyperlink{structINetStreamSocket_aa24057febafbd91c96504e108ae7fabf}{getpeername} (struct sockaddr $\ast$sa, size\+\_\+t $\ast$salen)
\begin{DoxyCompactList}\small\item\em Get the peer name. \end{DoxyCompactList}\item 
virtual int \hyperlink{structINetStreamSocket_a3f72a54af5a17e8110e1e26b4d99f7a7}{getsockname} (struct sockaddr $\ast$sa, size\+\_\+t $\ast$salen)
\begin{DoxyCompactList}\small\item\em Get the socket local name. \end{DoxyCompactList}\item 
virtual bool \hyperlink{structINetStreamSocket_a74dfca7829db3bae193bbe09ad62c21c}{get\+\_\+var} (const char $\ast$var, char $\ast$result, int result\+\_\+len)
\begin{DoxyCompactList}\small\item\em Optional function used to get variables for this T\+CP connection. \end{DoxyCompactList}\item 
virtual bool \hyperlink{structINetStreamSocket_a1ea74df6dd886b976a686df92a08fb9d}{set\+\_\+var} (const char $\ast$var, const char $\ast$val)
\begin{DoxyCompactList}\small\item\em Optional function used to set variables for this T\+CP connection. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Struct interface to N\+SC Stream (i.\+e., T\+CP) Sockets. 

\subsection{Constructor \& Destructor Documentation}
\index{I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}!````~I\+Net\+Stream\+Socket@{$\sim$\+I\+Net\+Stream\+Socket}}
\index{````~I\+Net\+Stream\+Socket@{$\sim$\+I\+Net\+Stream\+Socket}!I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}}
\subsubsection[{\texorpdfstring{$\sim$\+I\+Net\+Stream\+Socket()}{~INetStreamSocket()}}]{\setlength{\rightskip}{0pt plus 5cm}virtual I\+Net\+Stream\+Socket\+::$\sim$\+I\+Net\+Stream\+Socket (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{structINetStreamSocket_a0eba64b33fce654161af0d798d821cf3}{}\label{structINetStreamSocket_a0eba64b33fce654161af0d798d821cf3}

\begin{DoxyCode}
261 \{\}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}!accept@{accept}}
\index{accept@{accept}!I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}}
\subsubsection[{\texorpdfstring{accept(\+I\+Net\+Stream\+Socket $\ast$$\ast$handler)=0}{accept(INetStreamSocket **handler)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual int I\+Net\+Stream\+Socket\+::accept (
\begin{DoxyParamCaption}
\item[{{\bf I\+Net\+Stream\+Socket} $\ast$$\ast$}]{handler}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{structINetStreamSocket_af2bd0b33de3a8a30f539eda297786188}{}\label{structINetStreamSocket_af2bd0b33de3a8a30f539eda297786188}


Accept an incoming connection. 


\begin{DoxyParams}{Parameters}
{\em handler} & a handler to the \hyperlink{structINetStreamSocket}{I\+Net\+Stream\+Socket}. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The status code. 
\end{DoxyReturn}


Here is the caller graph for this function\+:
% FIG 1


\index{I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}!connect@{connect}}
\index{connect@{connect}!I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}}
\subsubsection[{\texorpdfstring{connect(const char $\ast$, int)=0}{connect(const char *, int)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void I\+Net\+Stream\+Socket\+::connect (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{, }
\item[{int}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{structINetStreamSocket_a9efb75e90465e3b182b21fb3ab856415}{}\label{structINetStreamSocket_a9efb75e90465e3b182b21fb3ab856415}


Connect to a remote peer. 



Here is the caller graph for this function\+:
% FIG 2


\index{I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}!disconnect@{disconnect}}
\index{disconnect@{disconnect}!I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}}
\subsubsection[{\texorpdfstring{disconnect()=0}{disconnect()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void I\+Net\+Stream\+Socket\+::disconnect (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{structINetStreamSocket_a902ff1a4caaab6e819e4bfae667a2108}{}\label{structINetStreamSocket_a902ff1a4caaab6e819e4bfae667a2108}


Disconnect from a remote peer. 



Here is the caller graph for this function\+:
% FIG 3


\index{I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}!get\+\_\+var@{get\+\_\+var}}
\index{get\+\_\+var@{get\+\_\+var}!I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}}
\subsubsection[{\texorpdfstring{get\+\_\+var(const char $\ast$var, char $\ast$result, int result\+\_\+len)}{get_var(const char *var, char *result, int result_len)}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool I\+Net\+Stream\+Socket\+::get\+\_\+var (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{var, }
\item[{char $\ast$}]{result, }
\item[{int}]{result\+\_\+len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{structINetStreamSocket_a74dfca7829db3bae193bbe09ad62c21c}{}\label{structINetStreamSocket_a74dfca7829db3bae193bbe09ad62c21c}


Optional function used to get variables for this T\+CP connection. 

\begin{DoxyNote}{Note}
not implemented
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em var} & variable requested \\
\hline
{\em result} & result result \\
\hline
{\em result\+\_\+len} & result length \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
always false 
\end{DoxyReturn}

\begin{DoxyCode}
357   \{
358     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
359   \}
\end{DoxyCode}
\index{I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}!getpeername@{getpeername}}
\index{getpeername@{getpeername}!I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}}
\subsubsection[{\texorpdfstring{getpeername(struct sockaddr $\ast$sa, size\+\_\+t $\ast$salen)}{getpeername(struct sockaddr *sa, size_t *salen)}}]{\setlength{\rightskip}{0pt plus 5cm}virtual int I\+Net\+Stream\+Socket\+::getpeername (
\begin{DoxyParamCaption}
\item[{struct sockaddr $\ast$}]{sa, }
\item[{size\+\_\+t $\ast$}]{salen}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{structINetStreamSocket_aa24057febafbd91c96504e108ae7fabf}{}\label{structINetStreamSocket_aa24057febafbd91c96504e108ae7fabf}


Get the peer name. 

\begin{DoxyNote}{Note}
not implemented
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em sa} & sockaddr structure to fill \\
\hline
{\em salen} & sockaddr structure length \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
-\/1 on error (always returns -\/1) 
\end{DoxyReturn}

\begin{DoxyCode}
331                                                                \{
332     \textcolor{keywordflow}{return} -1;
333   \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 4


\index{I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}!getsockname@{getsockname}}
\index{getsockname@{getsockname}!I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}}
\subsubsection[{\texorpdfstring{getsockname(struct sockaddr $\ast$sa, size\+\_\+t $\ast$salen)}{getsockname(struct sockaddr *sa, size_t *salen)}}]{\setlength{\rightskip}{0pt plus 5cm}virtual int I\+Net\+Stream\+Socket\+::getsockname (
\begin{DoxyParamCaption}
\item[{struct sockaddr $\ast$}]{sa, }
\item[{size\+\_\+t $\ast$}]{salen}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{structINetStreamSocket_a3f72a54af5a17e8110e1e26b4d99f7a7}{}\label{structINetStreamSocket_a3f72a54af5a17e8110e1e26b4d99f7a7}


Get the socket local name. 

\begin{DoxyNote}{Note}
not implemented
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em sa} & sockaddr structure to fill \\
\hline
{\em salen} & sockaddr structure length \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
-\/1 on error (always returns -\/1) 
\end{DoxyReturn}

\begin{DoxyCode}
343                                                                \{
344     \textcolor{keywordflow}{return} -1;
345   \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 5


\index{I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}!is\+\_\+connected@{is\+\_\+connected}}
\index{is\+\_\+connected@{is\+\_\+connected}!I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}}
\subsubsection[{\texorpdfstring{is\+\_\+connected()=0}{is_connected()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool I\+Net\+Stream\+Socket\+::is\+\_\+connected (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{structINetStreamSocket_ae12c5b0dc6d534b3fe6f185a7dc72265}{}\label{structINetStreamSocket_ae12c5b0dc6d534b3fe6f185a7dc72265}


Check the connection state. 

\begin{DoxyReturn}{Returns}
true if socket is in connected state 
\end{DoxyReturn}


Here is the caller graph for this function\+:
% FIG 6


\index{I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}!is\+\_\+listening@{is\+\_\+listening}}
\index{is\+\_\+listening@{is\+\_\+listening}!I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}}
\subsubsection[{\texorpdfstring{is\+\_\+listening()=0}{is_listening()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool I\+Net\+Stream\+Socket\+::is\+\_\+listening (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{structINetStreamSocket_a26fa9760ab071598a8b1b4da9e852b09}{}\label{structINetStreamSocket_a26fa9760ab071598a8b1b4da9e852b09}


Check the listening state. 

\begin{DoxyReturn}{Returns}
true if socket is in listening state 
\end{DoxyReturn}


Here is the caller graph for this function\+:
% FIG 7


\index{I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}!listen@{listen}}
\index{listen@{listen}!I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}}
\subsubsection[{\texorpdfstring{listen(int)=0}{listen(int)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void I\+Net\+Stream\+Socket\+::listen (
\begin{DoxyParamCaption}
\item[{int}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{structINetStreamSocket_abbbe6a0061c5fcd1c5e223e2be3917ba}{}\label{structINetStreamSocket_abbbe6a0061c5fcd1c5e223e2be3917ba}


Put the socket in Listening state on a port. 



Here is the caller graph for this function\+:
% FIG 8


\index{I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}!print\+\_\+state@{print\+\_\+state}}
\index{print\+\_\+state@{print\+\_\+state}!I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}}
\subsubsection[{\texorpdfstring{print\+\_\+state(\+F\+I\+L\+E $\ast$)=0}{print_state(FILE *)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void I\+Net\+Stream\+Socket\+::print\+\_\+state (
\begin{DoxyParamCaption}
\item[{F\+I\+LE $\ast$}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{structINetStreamSocket_a0502550bedfd2199ee9a8169d84adbd6}{}\label{structINetStreamSocket_a0502550bedfd2199ee9a8169d84adbd6}


Print the socket state. 

\index{I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}!read\+\_\+data@{read\+\_\+data}}
\index{read\+\_\+data@{read\+\_\+data}!I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}}
\subsubsection[{\texorpdfstring{read\+\_\+data(void $\ast$buf, int $\ast$buflen)=0}{read_data(void *buf, int *buflen)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual int I\+Net\+Stream\+Socket\+::read\+\_\+data (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{buf, }
\item[{int $\ast$}]{buflen}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{structINetStreamSocket_af040d53ef58b3b690e8930b7f71ec845}{}\label{structINetStreamSocket_af040d53ef58b3b690e8930b7f71ec845}


Read some data. 


\begin{DoxyParams}{Parameters}
{\em buf} & the buffer to store the data \\
\hline
{\em buflen} & buffer length \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of data read or -\/1 on error 
\end{DoxyReturn}


Here is the caller graph for this function\+:
% FIG 9


\index{I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}!send\+\_\+data@{send\+\_\+data}}
\index{send\+\_\+data@{send\+\_\+data}!I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}}
\subsubsection[{\texorpdfstring{send\+\_\+data(const void $\ast$data, int datalen)=0}{send_data(const void *data, int datalen)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual int I\+Net\+Stream\+Socket\+::send\+\_\+data (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{data, }
\item[{int}]{datalen}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{structINetStreamSocket_a112d5229b9dedebe7099fd4458ab28e4}{}\label{structINetStreamSocket_a112d5229b9dedebe7099fd4458ab28e4}


Send some data. 


\begin{DoxyParams}{Parameters}
{\em data} & the data \\
\hline
{\em datalen} & data length \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of data sent or -\/1 on error 
\end{DoxyReturn}


Here is the caller graph for this function\+:
% FIG 10


\index{I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}!set\+\_\+var@{set\+\_\+var}}
\index{set\+\_\+var@{set\+\_\+var}!I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}}
\subsubsection[{\texorpdfstring{set\+\_\+var(const char $\ast$var, const char $\ast$val)}{set_var(const char *var, const char *val)}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool I\+Net\+Stream\+Socket\+::set\+\_\+var (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{var, }
\item[{const char $\ast$}]{val}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{structINetStreamSocket_a1ea74df6dd886b976a686df92a08fb9d}{}\label{structINetStreamSocket_a1ea74df6dd886b976a686df92a08fb9d}


Optional function used to set variables for this T\+CP connection. 

\begin{DoxyNote}{Note}
not implemented
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em var} & variable to set \\
\hline
{\em val} & value to set \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
always false 
\end{DoxyReturn}

\begin{DoxyCode}
370   \{
371     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
372   \}
\end{DoxyCode}
\index{I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}!setsockopt@{setsockopt}}
\index{setsockopt@{setsockopt}!I\+Net\+Stream\+Socket@{I\+Net\+Stream\+Socket}}
\subsubsection[{\texorpdfstring{setsockopt(char $\ast$optname, void $\ast$val, size\+\_\+t valsize)=0}{setsockopt(char *optname, void *val, size_t valsize)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual int I\+Net\+Stream\+Socket\+::setsockopt (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{optname, }
\item[{void $\ast$}]{val, }
\item[{size\+\_\+t}]{valsize}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{structINetStreamSocket_adb85eedd5265fd2fc546904848bb7001}{}\label{structINetStreamSocket_adb85eedd5265fd2fc546904848bb7001}


Set the socket options. 

We need to pass the option name in as a string here. The reason for this is that different operating systems you compile on will have different numbers defined for the constants S\+O\+\_\+\+S\+N\+D\+B\+UF and so on.


\begin{DoxyParams}{Parameters}
{\em optname} & name of the option \\
\hline
{\em val} & option value \\
\hline
{\em valsize} & size of the option value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}


The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
internet/model/\hyperlink{sim__interface_8h}{sim\+\_\+interface.\+h}\end{DoxyCompactItemize}
