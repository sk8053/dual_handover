\hypertarget{classns3_1_1TapBridge}{}\section{ns3\+:\+:Tap\+Bridge Class Reference}
\label{classns3_1_1TapBridge}\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}


A bridge to make it appear that a real host process is connected to an ns-\/3 net device.  




{\ttfamily \#include $<$tap-\/bridge.\+h$>$}



Inheritance diagram for ns3\+:\+:Tap\+Bridge\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Tap\+Bridge\+:
% FIG 1
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618d}{Mode} \{ \hyperlink{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618da4616b74b41720604c7516c9349b2d3fe}{I\+L\+L\+E\+G\+AL}, 
\hyperlink{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618daf2d0f6c8152d38e9400b2d9fd35f02a3}{C\+O\+N\+F\+I\+G\+U\+R\+E\+\_\+\+L\+O\+C\+AL}, 
\hyperlink{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618daa73ff9ba9e1659aeda35d7181b601c75}{U\+S\+E\+\_\+\+L\+O\+C\+AL}, 
\hyperlink{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618da33daa0eda93d6ec20fc491d7c440fc8d}{U\+S\+E\+\_\+\+B\+R\+I\+D\+GE}
 \}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1TapBridge_a59285065e82d8ba63306846fc4082f4b}{Tap\+Bridge} ()
\item 
virtual \hyperlink{classns3_1_1TapBridge_aa6f741dae2dda424601c96073422e992}{$\sim$\+Tap\+Bridge} ()
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ \hyperlink{classns3_1_1TapBridge_afc497fe420a336be2ff9076ab90cf713}{Get\+Bridged\+Net\+Device} (void)
\begin{DoxyCompactList}\small\item\em Get the bridged net device. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1TapBridge_a0889ae6308758421297e74cb4be9af5b}{Set\+Bridged\+Net\+Device} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ bridged\+Device)
\begin{DoxyCompactList}\small\item\em Set the ns-\/3 net device to bridge. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1TapBridge_a729662b8454d1c8202add94ebf389bb9}{Start} (\hyperlink{classns3_1_1Time}{Time} t\+Start)
\begin{DoxyCompactList}\small\item\em Set a start time for the device. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1TapBridge_ab94057d00c75768838fe783eaff278e3}{Stop} (\hyperlink{classns3_1_1Time}{Time} t\+Stop)
\item 
void \hyperlink{classns3_1_1TapBridge_a435d654af7e7970c365d14b4a5dc3044}{Set\+Mode} (\hyperlink{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618d}{Tap\+Bridge\+::\+Mode} mode)
\item 
\hyperlink{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618d}{Tap\+Bridge\+::\+Mode} \hyperlink{classns3_1_1TapBridge_a0d4f1ff39b0d57d463a16f1617e6d19f}{Get\+Mode} (void)
\item 
virtual void \hyperlink{classns3_1_1TapBridge_aab34bfe78791ad5401d23e21b7cff850}{Set\+If\+Index} (const uint32\+\_\+t index)
\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1TapBridge_ae7688d83bd817150755e48c8207b5633}{Get\+If\+Index} (void) const 
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Channel}{Channel} $>$ \hyperlink{classns3_1_1TapBridge_a2db1411e39ca9653ddcccc3000862ab1}{Get\+Channel} (void) const 
\item 
virtual void \hyperlink{classns3_1_1TapBridge_a3d3f981cb1ace70ecfa34744108ff2b7}{Set\+Address} (\hyperlink{classns3_1_1Address}{Address} address)
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1TapBridge_adad791a296c4d4015a6d2e2d022b6a63}{Get\+Address} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1TapBridge_af41aca6484197a8a139b8db0fbcb6b79}{Set\+Mtu} (const uint16\+\_\+t mtu)
\item 
virtual uint16\+\_\+t \hyperlink{classns3_1_1TapBridge_a9c10575ce501dfa92da9f45b32891407}{Get\+Mtu} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1TapBridge_a3d8af7dbe31c534dec551c38f2f66afa}{Is\+Link\+Up} (void) const 
\item 
virtual void \hyperlink{classns3_1_1TapBridge_a3f2e72b395d83fff19e5f3a09298aef3}{Add\+Link\+Change\+Callback} (\hyperlink{classns3_1_1Callback}{Callback}$<$ void $>$ callback)
\item 
virtual bool \hyperlink{classns3_1_1TapBridge_aae97d70b414626bf3662a3916ff9b64e}{Is\+Broadcast} (void) const 
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1TapBridge_ab0c6b045924ddf43fb33c2dc79581923}{Get\+Broadcast} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1TapBridge_a08b9d57e3a6a50f224ea517d241f3ee8}{Is\+Multicast} (void) const 
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1TapBridge_a76c7ce4e8ba5177450b62e386d2aeddf}{Get\+Multicast} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} multicast\+Group) const 
\begin{DoxyCompactList}\small\item\em Make and return a M\+AC multicast address using the provided multicast group. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1TapBridge_a6e884e1a4e268402f183e35953458d4a}{Is\+Point\+To\+Point} (void) const 
\begin{DoxyCompactList}\small\item\em Return true if the net device is on a point-\/to-\/point link. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1TapBridge_a95e3ba17b506b9aaae4d3cfd1b4356b0}{Is\+Bridge} (void) const 
\begin{DoxyCompactList}\small\item\em Return true if the net device is acting as a bridge. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1TapBridge_a3273f1c6353f38dea443e2abad4c3d21}{Send} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, const \hyperlink{classns3_1_1Address}{Address} \&dest, uint16\+\_\+t protocol\+Number)
\item 
virtual bool \hyperlink{classns3_1_1TapBridge_a6e6cf6042cc65529a8591e0d01518153}{Send\+From} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, const \hyperlink{classns3_1_1Address}{Address} \&source, const \hyperlink{classns3_1_1Address}{Address} \&dest, uint16\+\_\+t protocol\+Number)
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1TapBridge_ae200e9184e81dcad678e1016ff0375c6}{Get\+Node} (void) const 
\item 
virtual void \hyperlink{classns3_1_1TapBridge_a6e94660e371655a2c6c6f00b3f1e44c2}{Set\+Node} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node)
\item 
virtual bool \hyperlink{classns3_1_1TapBridge_a5a4660c9d4f687bfa6374e5998faae75}{Needs\+Arp} (void) const 
\item 
virtual void \hyperlink{classns3_1_1TapBridge_a44cd4720cc3fcc1a41536697e08320ac}{Set\+Receive\+Callback} (\hyperlink{classns3_1_1NetDevice_ad5e5e1ca187472bc2ba99575d8def568}{Net\+Device\+::\+Receive\+Callback} cb)
\item 
virtual void \hyperlink{classns3_1_1TapBridge_a6621dcd7bfce6367c3451b457fa8145c}{Set\+Promisc\+Receive\+Callback} (\hyperlink{classns3_1_1NetDevice_a427225795919f26c414bee2ea3f31ed2}{Net\+Device\+::\+Promisc\+Receive\+Callback} cb)
\item 
virtual bool \hyperlink{classns3_1_1TapBridge_a56859ceec9c6a575db34bf6acfd510f8}{Supports\+Send\+From} () const 
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1TapBridge_a2ebaad85807dd1d2fc8a354a46c69076}{Get\+Multicast} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} addr) const 
\begin{DoxyCompactList}\small\item\em Get the M\+AC multicast address corresponding to the I\+Pv6 address provided. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1TapBridge_a9ac80b6070b0e111d23367c42e411746}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1TapBridge_afb9e635e18724e9de7371ff492117599}{Do\+Dispose} (void)
\item 
bool \hyperlink{classns3_1_1TapBridge_ac065f518a2c18292b88609f8500a61bb}{Receive\+From\+Bridged\+Device} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, uint16\+\_\+t protocol, \hyperlink{classns3_1_1Address}{Address} const \&src, \hyperlink{classns3_1_1Address}{Address} const \&dst, \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2}{Packet\+Type} packet\+Type)
\item 
bool \hyperlink{classns3_1_1TapBridge_a1837b0aa11c479938664a05cc5794c5f}{Discard\+From\+Bridged\+Device} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, uint16\+\_\+t protocol, \hyperlink{classns3_1_1Address}{Address} const \&src)
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classns3_1_1TapBridge_ab8458214cc15eb045fa1048e36275432}{Create\+Tap} (void)
\item 
void \hyperlink{classns3_1_1TapBridge_a15e7ac0069167eb1e1d63b3cefe86002}{Start\+Tap\+Device} (void)
\item 
void \hyperlink{classns3_1_1TapBridge_a0daf7557c160441a6bf45b4915bc93c3}{Stop\+Tap\+Device} (void)
\item 
void \hyperlink{classns3_1_1TapBridge_a8cf7414db717096f2b3a2a0e7026ed8f}{Read\+Callback} (uint8\+\_\+t $\ast$buf, ssize\+\_\+t len)
\item 
void \hyperlink{classns3_1_1TapBridge_ab4390af3653278cc4ea265d3c7f4de15}{Forward\+To\+Bridged\+Device} (uint8\+\_\+t $\ast$buf, ssize\+\_\+t len)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{classns3_1_1TapBridge_aa141455ff96593217dcffd47d7bc48d0}{Filter} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Address}{Address} $\ast$src, \hyperlink{classns3_1_1Address}{Address} $\ast$dst, uint16\+\_\+t $\ast$\hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type})
\item 
void \hyperlink{classns3_1_1TapBridge_a845a502163a985d26b2b70c36493d945}{Notify\+Link\+Up} (void)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1NetDevice_ad5e5e1ca187472bc2ba99575d8def568}{Net\+Device\+::\+Receive\+Callback} \hyperlink{classns3_1_1TapBridge_a6e0e402ed4fc1b67796220bf915cfbae}{m\+\_\+rx\+Callback}
\item 
\hyperlink{classns3_1_1NetDevice_a427225795919f26c414bee2ea3f31ed2}{Net\+Device\+::\+Promisc\+Receive\+Callback} \hyperlink{classns3_1_1TapBridge_a4a1f6dcd199836a8bff03691a240af4a}{m\+\_\+promisc\+Rx\+Callback}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1TapBridge_aab85ad5d27b8de91e7a02e8d8ee4332e}{m\+\_\+node}
\item 
uint32\+\_\+t \hyperlink{classns3_1_1TapBridge_a5de0f6399c095a680978c72bcd90b228}{m\+\_\+if\+Index}
\item 
uint16\+\_\+t \hyperlink{classns3_1_1TapBridge_a8aca7b3808d23f6a5f8e6c212c0af618}{m\+\_\+mtu}
\item 
int \hyperlink{classns3_1_1TapBridge_a52d87d41aa840377feebe63b5c5f2f3c}{m\+\_\+sock}
\item 
\hyperlink{classns3_1_1EventId}{Event\+Id} \hyperlink{classns3_1_1TapBridge_ad3b52854cf5e27c04fcbf62030e725ec}{m\+\_\+start\+Event}
\item 
\hyperlink{classns3_1_1EventId}{Event\+Id} \hyperlink{classns3_1_1TapBridge_aab982f716ac96e92e054c82334a198c4}{m\+\_\+stop\+Event}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1TapBridgeFdReader}{Tap\+Bridge\+Fd\+Reader} $>$ \hyperlink{classns3_1_1TapBridge_a8a26ef8616fb40272a4bab45ec84f563}{m\+\_\+fd\+Reader}
\item 
\hyperlink{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618d}{Mode} \hyperlink{classns3_1_1TapBridge_aaae30bc9d5dd36e3a4d569cf9bcf40eb}{m\+\_\+mode}
\item 
\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} \hyperlink{classns3_1_1TapBridge_a70e331b3deb893d7aa013ef44a7ee4a7}{m\+\_\+address}
\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1TapBridge_ad6cde3114d24223d3edf0270ce4af231}{m\+\_\+t\+Start}
\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1TapBridge_ae91102625b83c3b447f48d1798041ab8}{m\+\_\+t\+Stop}
\item 
std\+::string \hyperlink{classns3_1_1TapBridge_af255e0f837eb4dd30c4de28448f862f6}{m\+\_\+tap\+Device\+Name}
\item 
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \hyperlink{classns3_1_1TapBridge_ad90dad655607615d92822a361ac21fb1}{m\+\_\+tap\+Gateway}
\item 
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \hyperlink{classns3_1_1TapBridge_a8cfe2b69cef36dbf048cb9006318b41b}{m\+\_\+tap\+Ip}
\item 
\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} \hyperlink{classns3_1_1TapBridge_afdaa87d8c5a5e249ee8d94f75183e91f}{m\+\_\+tap\+Mac}
\item 
\hyperlink{classns3_1_1Ipv4Mask}{Ipv4\+Mask} \hyperlink{classns3_1_1TapBridge_a9374f832e2a96385651d27a5fbc7ba57}{m\+\_\+tap\+Netmask}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ \hyperlink{classns3_1_1TapBridge_ac4ba97368116b628d632d318d5562420}{m\+\_\+bridged\+Device}
\item 
bool \hyperlink{classns3_1_1TapBridge_a3200dc6b4b46d2f0fb13c867fcb0d118}{m\+\_\+ns3\+Address\+Rewritten}
\item 
uint8\+\_\+t $\ast$ \hyperlink{classns3_1_1TapBridge_a32b939096e18f39f76a86401d182cda5}{m\+\_\+packet\+Buffer}
\item 
uint32\+\_\+t \hyperlink{classns3_1_1TapBridge_a2176c6e2dba8e66c1dc45145cb54d395}{m\+\_\+node\+Id}
\item 
bool \hyperlink{classns3_1_1TapBridge_a335b96cae7f60f5d5bcf60234af96339}{m\+\_\+link\+Up}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback} \hyperlink{classns3_1_1TapBridge_a3c5c9f53b15fc47d55420f4905297a06}{m\+\_\+link\+Change\+Callbacks}
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
A bridge to make it appear that a real host process is connected to an ns-\/3 net device. 

The \hyperlink{classns3_1_1Tap}{Tap} Bridge lives in a kind of a gray world somewhere between a Linux host and an ns-\/3 bridge device. From the Linux perspective, this code appears as the user mode handler for a \hyperlink{classns3_1_1Tap}{Tap} net device. That is, when the Linux host writes to a /dev/tap device (that is either manually or automatically created depending on basic operating mode -- more on this later), the write is redirected into the \hyperlink{classns3_1_1TapBridge}{Tap\+Bridge} that lives in the ns-\/3 world; and from this perspective, becomes a read. In other words, a Linux process writes a packet to a tap device and this packet is redirected to an ns-\/3 process where it is received by the \hyperlink{classns3_1_1TapBridge}{Tap\+Bridge} as a result of a read operation there. The \hyperlink{classns3_1_1TapBridge}{Tap\+Bridge} then sends the packet to the ns-\/3 net device to which it is bridged. In the other direction, a packet received by an ns-\/3 net device is bridged to the \hyperlink{classns3_1_1TapBridge}{Tap\+Bridge} (it appears via a callback from that net device. The \hyperlink{classns3_1_1TapBridge}{Tap\+Bridge} then takes that packet and writes it back to the host using the Linux T\+AP mechanism. This write to the device will then appear to the Linux host as if a packet has arrived on its device.

The upshot is that the \hyperlink{classns3_1_1Tap}{Tap} Bridge appears to bridge a tap device on a Linux host in the \char`\"{}real world\char`\"{} to an ns-\/3 net device in the simulation and make is appear that a ns-\/3 net device is actually installed in the Linux host. In order to do this on the ns-\/3 side, we need a \char`\"{}ghost
node\char`\"{} in the simulation to hold the bridged ns-\/3 net device and the \hyperlink{classns3_1_1TapBridge}{Tap\+Bridge}. This node should not actually do anything else in the simulation since its job is simply to make the net device appear in Linux. This is not just arbitrary policy, it is because\+:


\begin{DoxyItemize}
\item Bits sent to the \hyperlink{classns3_1_1Tap}{Tap} Bridge from higher layers in the ghost node (using the \hyperlink{classns3_1_1TapBridge}{Tap\+Bridge} \hyperlink{classns3_1_1TapBridge_a3273f1c6353f38dea443e2abad4c3d21}{Send()} method) are completely ignored. The \hyperlink{classns3_1_1Tap}{Tap} Bridge is not, itself, connected to any network, neither in Linux nor in ns-\/3;
\item The bridged ns-\/3 net device is has had its receive callback disconnected from the ns-\/3 node and reconnected to the \hyperlink{classns3_1_1Tap}{Tap} Bridge. All data received by a bridged device will be sent to the Linux host and will not be received by the node. From the perspective of the ghost node, you can send over this device but you cannot ever receive.
\end{DoxyItemize}

Of course, if you understand all of the issues you can take control of your own destiny and do whatever you want -- we do not actively prevent you from using the ghost node for anything you decide. You will be able to perform typical ns-\/3 operations on the ghost node if you so desire. The internet stack, for example, must be there and functional on that node in order to participate in IP address assignment and global routing. However, as mentioned above, interfaces talking any \hyperlink{classns3_1_1Tap}{Tap} Bridge or associated bridged net devices will not work completely. If you understand exactly what you are doing, you can set up other interfaces and devices on the ghost node and use them; or take advantage of the operational send side of the bridged devices to create traffic generators. We generally recommend that you treat this node as a ghost of the Linux host and leave it to itself, though. 

\subsection{Member Enumeration Documentation}
\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Mode@{Mode}}
\index{Mode@{Mode}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Mode}{Mode}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf ns3\+::\+Tap\+Bridge\+::\+Mode}}\hypertarget{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618d}{}\label{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618d}
Enumeration of the operating modes supported in the class. \begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{I\+L\+L\+E\+G\+AL@{I\+L\+L\+E\+G\+AL}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!I\+L\+L\+E\+G\+AL@{I\+L\+L\+E\+G\+AL}}\item[{\em 
I\+L\+L\+E\+G\+AL\hypertarget{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618da4616b74b41720604c7516c9349b2d3fe}{}\label{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618da4616b74b41720604c7516c9349b2d3fe}
}]mode not set \index{C\+O\+N\+F\+I\+G\+U\+R\+E\+\_\+\+L\+O\+C\+AL@{C\+O\+N\+F\+I\+G\+U\+R\+E\+\_\+\+L\+O\+C\+AL}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!C\+O\+N\+F\+I\+G\+U\+R\+E\+\_\+\+L\+O\+C\+AL@{C\+O\+N\+F\+I\+G\+U\+R\+E\+\_\+\+L\+O\+C\+AL}}\item[{\em 
C\+O\+N\+F\+I\+G\+U\+R\+E\+\_\+\+L\+O\+C\+AL\hypertarget{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618daf2d0f6c8152d38e9400b2d9fd35f02a3}{}\label{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618daf2d0f6c8152d38e9400b2d9fd35f02a3}
}]ns-\/3 creates and configures tap device \index{U\+S\+E\+\_\+\+L\+O\+C\+AL@{U\+S\+E\+\_\+\+L\+O\+C\+AL}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!U\+S\+E\+\_\+\+L\+O\+C\+AL@{U\+S\+E\+\_\+\+L\+O\+C\+AL}}\item[{\em 
U\+S\+E\+\_\+\+L\+O\+C\+AL\hypertarget{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618daa73ff9ba9e1659aeda35d7181b601c75}{}\label{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618daa73ff9ba9e1659aeda35d7181b601c75}
}]ns-\/3 uses a pre-\/created tap, without configuring it \index{U\+S\+E\+\_\+\+B\+R\+I\+D\+GE@{U\+S\+E\+\_\+\+B\+R\+I\+D\+GE}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!U\+S\+E\+\_\+\+B\+R\+I\+D\+GE@{U\+S\+E\+\_\+\+B\+R\+I\+D\+GE}}\item[{\em 
U\+S\+E\+\_\+\+B\+R\+I\+D\+GE\hypertarget{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618da33daa0eda93d6ec20fc491d7c440fc8d}{}\label{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618da33daa0eda93d6ec20fc491d7c440fc8d}
}]ns-\/3 uses a pre-\/created tap, and bridges to a bridging net device \end{description}
\end{Desc}

\begin{DoxyCode}
120             \{
121     \hyperlink{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618da4616b74b41720604c7516c9349b2d3fe}{ILLEGAL},         
122     \hyperlink{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618daf2d0f6c8152d38e9400b2d9fd35f02a3}{CONFIGURE\_LOCAL}, 
123     \hyperlink{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618daa73ff9ba9e1659aeda35d7181b601c75}{USE\_LOCAL},       
124     \hyperlink{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618da33daa0eda93d6ec20fc491d7c440fc8d}{USE\_BRIDGE}, 
125   \};
\end{DoxyCode}


\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Tap\+Bridge@{Tap\+Bridge}}
\index{Tap\+Bridge@{Tap\+Bridge}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Tap\+Bridge()}{TapBridge()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Tap\+Bridge\+::\+Tap\+Bridge (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TapBridge_a59285065e82d8ba63306846fc4082f4b}{}\label{classns3_1_1TapBridge_a59285065e82d8ba63306846fc4082f4b}

\begin{DoxyCode}
140   : \hyperlink{classns3_1_1TapBridge_aab85ad5d27b8de91e7a02e8d8ee4332e}{m\_node} (0),
141     \hyperlink{classns3_1_1TapBridge_a5de0f6399c095a680978c72bcd90b228}{m\_ifIndex} (0),
142     \hyperlink{classns3_1_1TapBridge_a52d87d41aa840377feebe63b5c5f2f3c}{m\_sock} (-1),
143     \hyperlink{classns3_1_1TapBridge_ad3b52854cf5e27c04fcbf62030e725ec}{m\_startEvent} (),
144     \hyperlink{classns3_1_1TapBridge_aab982f716ac96e92e054c82334a198c4}{m\_stopEvent} (),
145     \hyperlink{classns3_1_1TapBridge_a8a26ef8616fb40272a4bab45ec84f563}{m\_fdReader} (0),
146     \hyperlink{classns3_1_1TapBridge_a3200dc6b4b46d2f0fb13c867fcb0d118}{m\_ns3AddressRewritten} (\textcolor{keyword}{false})
147 \{
148   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
149   \hyperlink{classns3_1_1TapBridge_a32b939096e18f39f76a86401d182cda5}{m\_packetBuffer} = \textcolor{keyword}{new} uint8\_t[65536];
150   \hyperlink{classns3_1_1TapBridge_a729662b8454d1c8202add94ebf389bb9}{Start} (\hyperlink{classns3_1_1TapBridge_ad6cde3114d24223d3edf0270ce4af231}{m\_tStart});
151 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!````~Tap\+Bridge@{$\sim$\+Tap\+Bridge}}
\index{````~Tap\+Bridge@{$\sim$\+Tap\+Bridge}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{$\sim$\+Tap\+Bridge()}{~TapBridge()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Tap\+Bridge\+::$\sim$\+Tap\+Bridge (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TapBridge_aa6f741dae2dda424601c96073422e992}{}\label{classns3_1_1TapBridge_aa6f741dae2dda424601c96073422e992}

\begin{DoxyCode}
154 \{
155   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
156 
157   \hyperlink{classns3_1_1TapBridge_a0daf7557c160441a6bf45b4915bc93c3}{StopTapDevice} ();
158 
159   \textcolor{keyword}{delete} [] \hyperlink{classns3_1_1TapBridge_a32b939096e18f39f76a86401d182cda5}{m\_packetBuffer};
160   \hyperlink{classns3_1_1TapBridge_a32b939096e18f39f76a86401d182cda5}{m\_packetBuffer} = 0;
161 
162   \hyperlink{classns3_1_1TapBridge_ac4ba97368116b628d632d318d5562420}{m\_bridgedDevice} = 0;
163 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3




\subsection{Member Function Documentation}
\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Add\+Link\+Change\+Callback@{Add\+Link\+Change\+Callback}}
\index{Add\+Link\+Change\+Callback@{Add\+Link\+Change\+Callback}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Add\+Link\+Change\+Callback(\+Callback$<$ void $>$ callback)}{AddLinkChangeCallback(Callback< void > callback)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tap\+Bridge\+::\+Add\+Link\+Change\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Callback}$<$ void $>$}]{callback}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TapBridge_a3f2e72b395d83fff19e5f3a09298aef3}{}\label{classns3_1_1TapBridge_a3f2e72b395d83fff19e5f3a09298aef3}

\begin{DoxyParams}{Parameters}
{\em callback} & the callback to invoke\\
\hline
\end{DoxyParams}
Add a callback invoked whenever the link status changes to UP. This callback is typically used by the I\+P/\+A\+RP layer to flush the A\+RP cache and by I\+Pv6 stack to flush N\+D\+I\+SC cache whenever the link goes up. 

Implements \hyperlink{classns3_1_1NetDevice_aafb1bf869d38ef7a7112d11fab0163a3}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1084 \{
1085   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
1086   \hyperlink{classns3_1_1TapBridge_a3c5c9f53b15fc47d55420f4905297a06}{m\_linkChangeCallbacks}.\hyperlink{classns3_1_1TracedCallback_aacc251bf4e302e7d034e9f0e25a15980}{ConnectWithoutContext} (callback);
1087 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4


\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Create\+Tap@{Create\+Tap}}
\index{Create\+Tap@{Create\+Tap}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Create\+Tap(void)}{CreateTap(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tap\+Bridge\+::\+Create\+Tap (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_ab8458214cc15eb045fa1048e36275432}{}\label{classns3_1_1TapBridge_ab8458214cc15eb045fa1048e36275432}
Call out to a separate process running as suid root in order to get our tap device created. We do this to avoid having the entire simulation running as root. If this method returns, we\textquotesingle{}ll have a socket waiting for us in m\+\_\+sock that we can use to talk to the tap device. 
\begin{DoxyCode}
257 \{
258   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
259 
260   \textcolor{comment}{// }
261   \textcolor{comment}{// The TapBridge has three distinct operating modes.  At this point, the}
262   \textcolor{comment}{// differences revolve around who is responsible for creating and configuring}
263   \textcolor{comment}{// the underlying network tap that we use.  In ConfigureLocal mode, the }
264   \textcolor{comment}{// TapBridge has the responsibility for creating and configuring the TAP.}
265   \textcolor{comment}{//}
266   \textcolor{comment}{// In UseBridge or UseLocal modes, the user will provide us a configuration}
267   \textcolor{comment}{// and we have to adapt to it.  For example, in UseLocal mode, the user will}
268   \textcolor{comment}{// be configuring a tap device outside the scope of the ns-3 simulation and}
269   \textcolor{comment}{// will be expecting us to work with it.  The user will do something like:}
270   \textcolor{comment}{//}
271   \textcolor{comment}{//   sudo tunctl -t tap0}
272   \textcolor{comment}{//   sudo ifconfig tap0 hw ether 00:00:00:00:00:01}
273   \textcolor{comment}{//   sudo ifconfig tap0 10.1.1.1 netmask 255.255.255.0 up}
274   \textcolor{comment}{//}
275   \textcolor{comment}{// The user will then set the "Mode" Attribute of the TapBridge to "UseLocal"}
276   \textcolor{comment}{// and the "DeviceName" Attribute to "tap0" in this case.}
277   \textcolor{comment}{//}
278   \textcolor{comment}{// In ConfigureLocal mode, the user is asking the TapBridge to do the }
279   \textcolor{comment}{// configuration and create a TAP with the provided "DeviceName" with which }
280   \textcolor{comment}{// the user can later do what she wants.  We need to extract values for the}
281   \textcolor{comment}{// MAC address, IP address, net mask, etc, from the simualtion itself and }
282   \textcolor{comment}{// use them to initialize corresponding values on the created tap device.}
283   \textcolor{comment}{//}
284   \textcolor{comment}{// In UseBridge mode, the user is asking us to use an existing tap device}
285   \textcolor{comment}{// has been included in an OS bridge.  She is asking us to take the simulated}
286   \textcolor{comment}{// net device and logically add it to the existing bridge.  We expect that}
287   \textcolor{comment}{// the user has done something like:}
288   \textcolor{comment}{//}
289   \textcolor{comment}{//   sudo brctl addbr mybridge}
290   \textcolor{comment}{//   sudo tunctl -t mytap}
291   \textcolor{comment}{//   sudo ifconfig mytap hw ether 00:00:00:00:00:01}
292   \textcolor{comment}{//   sudo ifconfig mytap 0.0.0.0 up}
293   \textcolor{comment}{//   sudo brctl addif mybridge mytap}
294   \textcolor{comment}{//   sudo brctl addif mybridge ...}
295   \textcolor{comment}{//   sudo ifconfig mybridge 10.1.1.1 netmask 255.255.255.0 up}
296   \textcolor{comment}{//}
297   \textcolor{comment}{// The bottom line at this point is that we want to either create or use a }
298   \textcolor{comment}{// tap device on the host based on the verb part "Use" or "Configure" of the }
299   \textcolor{comment}{// operating mode.  Unfortunately for us you have to have root privileges to}
300   \textcolor{comment}{// do either.  Instead of running the entire simulation as root, we decided }
301   \textcolor{comment}{// to make a small program who's whole reason for being is to run as suid }
302   \textcolor{comment}{// root and do what it takes to create the tap.  We're just going to pass }
303   \textcolor{comment}{// off the configuration information to that program and let it deal with}
304   \textcolor{comment}{// the situation.}
305   \textcolor{comment}{//}
306   \textcolor{comment}{// We're going to fork and exec that program soon, but first we need to have }
307   \textcolor{comment}{// a socket to talk to it with.  So we create a local interprocess (Unix) }
308   \textcolor{comment}{// socket for that purpose.}
309   \textcolor{comment}{//}
310   \textcolor{keywordtype}{int} sock = socket (PF\_UNIX, SOCK\_DGRAM, 0);
311   \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (sock == -1, \textcolor{stringliteral}{"TapBridge::CreateTap(): Unix socket creation error, errno = 
      "} << std::strerror (errno));
312 
313   \textcolor{comment}{//}
314   \textcolor{comment}{// Bind to that socket and let the kernel allocate an endpoint}
315   \textcolor{comment}{//}
316   \textcolor{keyword}{struct }sockaddr\_un un;
317   memset (&un, 0, \textcolor{keyword}{sizeof} (un));
318   un.sun\_family = AF\_UNIX;
319   \textcolor{keywordtype}{int} status = bind (sock, (\textcolor{keyword}{struct} sockaddr*)&un, \textcolor{keyword}{sizeof} (sa\_family\_t));
320   \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (status == -1, \textcolor{stringliteral}{"TapBridge::CreateTap(): Could not bind(): errno = "} << 
      std::strerror (errno));
321   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Created Unix socket"});
322   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"sun\_family = "} << un.sun\_family);
323   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"sun\_path = "} << un.sun\_path);
324 
325   \textcolor{comment}{//}
326   \textcolor{comment}{// We have a socket here, but we want to get it there -- to the program we're}
327   \textcolor{comment}{// going to exec.  What we'll do is to do a getsockname and then encode the}
328   \textcolor{comment}{// resulting address information as a string, and then send the string to the}
329   \textcolor{comment}{// program as an argument.  So we need to get the sock name.}
330   \textcolor{comment}{//}
331   socklen\_t len = \textcolor{keyword}{sizeof} (un);
332   status = getsockname (sock, (\textcolor{keyword}{struct} sockaddr*)&un, &len);
333   \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (status == -1, \textcolor{stringliteral}{"TapBridge::CreateTap(): Could not getsockname(): errno = "}
       << std::strerror (errno));
334 
335   \textcolor{comment}{//}
336   \textcolor{comment}{// Now encode that socket name (family and path) as a string of hex digits}
337   \textcolor{comment}{//}
338   std::string path = \hyperlink{namespacens3_abf9f661689b523b4b37b97879c1ffc12}{TapBufferToString} ((uint8\_t *)&un, len);
339   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Encoded Unix socket as \(\backslash\)""} << path << \textcolor{stringliteral}{"\(\backslash\)""});
340 
341   \textcolor{comment}{//}
342   \textcolor{comment}{// Tom Goff reports the possiblility of a deadlock when trying to acquire the}
343   \textcolor{comment}{// python GIL here.  He says that this might be due to trying to access Python}
344   \textcolor{comment}{// objects after fork() without calling PyOS\_AfterFork() to properly reset }
345   \textcolor{comment}{// Python state (including the GIL).  Originally these next three lines were}
346   \textcolor{comment}{// done after the fork, but were moved here to work around the deadlock.}
347   \textcolor{comment}{//}
348   Ptr<NetDevice> nd = \hyperlink{classns3_1_1TapBridge_afc497fe420a336be2ff9076ab90cf713}{GetBridgedNetDevice} ();
349   Ptr<Node> \hyperlink{namespacesample-rng-plot_aeb5ee5c431e338ef39b7ac5431242e1d}{n} = nd->GetNode ();
350   Ptr<Ipv4> ipv4 = n->GetObject<Ipv4> ();
351 
352   \textcolor{comment}{//}
353   \textcolor{comment}{// Fork and exec the process to create our socket.  If we're us (the parent)}
354   \textcolor{comment}{// we wait for the child (the creator) to complete and read the socket it }
355   \textcolor{comment}{// created and passed back using the ancillary data mechanism.}
356   \textcolor{comment}{//}
357   pid\_t pid = ::fork ();
358   \textcolor{keywordflow}{if} (pid == 0)
359     \{
360       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Child process"});
361 
362       \textcolor{comment}{//}
363       \textcolor{comment}{// build a command line argument from the encoded endpoint string that }
364       \textcolor{comment}{// the socket creation process will use to figure out how to respond to}
365       \textcolor{comment}{// the (now) parent process.  We're going to have to give this program}
366       \textcolor{comment}{// quite a bit of information.}
367       \textcolor{comment}{//}
368       \textcolor{comment}{// -d<device-name> The name of the tap device we want to create;}
369       \textcolor{comment}{// -g<gateway-address> The IP address to use as the default gateway;}
370       \textcolor{comment}{// -i<IP-address> The IP address to assign to the new tap device;}
371       \textcolor{comment}{// -m<MAC-address> The MAC-48 address to assign to the new tap device;}
372       \textcolor{comment}{// -n<network-mask> The network mask to assign to the new tap device;}
373       \textcolor{comment}{// -o<operating mode> The operating mode of the bridge (1=ConfigureLocal, 2=UseLocal, 3=UseBridge)}
374       \textcolor{comment}{// -p<path> the path to the unix socket described above.}
375       \textcolor{comment}{//}
376       \textcolor{comment}{// Example tap-creator -dnewdev -g1.2.3.2 -i1.2.3.1 -m08:00:2e:00:01:23 -n255.255.255.0 -o1 -pblah}
377       \textcolor{comment}{//}
378       \textcolor{comment}{// We want to get as much of this stuff automagically as possible.}
379       \textcolor{comment}{//}
380       \textcolor{comment}{// For CONFIGURE\_LOCAL mode only:}
381       \textcolor{comment}{// <IP-address> is the IP address we are going to set in the newly }
382       \textcolor{comment}{// created Tap device on the Linux host.  At the point in the simulation}
383       \textcolor{comment}{// where devices are coming up, we should have all of our IP addresses}
384       \textcolor{comment}{// assigned.  That means that we can find the IP address to assign to }
385       \textcolor{comment}{// the new Tap device from the IP address associated with the bridged}
386       \textcolor{comment}{// net device.}
387       \textcolor{comment}{//}
388 
389       \textcolor{keywordtype}{bool} wantIp = (\hyperlink{classns3_1_1TapBridge_aaae30bc9d5dd36e3a4d569cf9bcf40eb}{m\_mode} == \hyperlink{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618daf2d0f6c8152d38e9400b2d9fd35f02a3}{CONFIGURE\_LOCAL});
390 
391       \textcolor{keywordflow}{if} (wantIp
392           && (ipv4 == 0)
393           && \hyperlink{classns3_1_1TapBridge_a8cfe2b69cef36dbf048cb9006318b41b}{m\_tapIp}.\hyperlink{classns3_1_1Ipv4Address_acff8d940bf4cc9282cf67c75eb9d777f}{IsBroadcast} ()
394           && \hyperlink{classns3_1_1TapBridge_a9374f832e2a96385651d27a5fbc7ba57}{m\_tapNetmask}.\hyperlink{classns3_1_1Ipv4Mask_a1428fba537359418d0b7d8c84a135a7e}{IsEqual} (\hyperlink{classns3_1_1Ipv4Mask_af712cbdf28c039025d4aa45fa7e243dd}{Ipv4Mask::GetOnes} ()))
395         \{
396           \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"TapBridge::CreateTap(): Tap device IP configuration requested but
       neither IP address nor IP netmask is provided"});
397         \}
398 
399       \textcolor{comment}{// Some stub values to make tap-creator happy}
400       Ipv4Address ipv4Address (\textcolor{stringliteral}{"255.255.255.255"});
401       Ipv4Mask ipv4Mask (\textcolor{stringliteral}{"255.255.255.255"});
402 
403       \textcolor{keywordflow}{if} (ipv4 != 0)
404         \{
405           uint32\_t index = ipv4->GetInterfaceForDevice (nd);
406           \textcolor{keywordflow}{if} (ipv4->GetNAddresses (index) > 1)
407             \{
408               \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Underlying bridged NetDevice has multiple IP addresses; using first
       one."});
409             \}
410           ipv4Address = ipv4->GetAddress (index, 0).GetLocal ();
411 
412           \textcolor{comment}{//}
413           \textcolor{comment}{// The net mask is sitting right there next to the ipv4 address.}
414           \textcolor{comment}{//}
415           ipv4Mask = ipv4->GetAddress (index, 0).GetMask ();
416         \}
417 
418       \textcolor{comment}{//}
419       \textcolor{comment}{// The MAC address should also already be assigned and waiting for us in}
420       \textcolor{comment}{// the bridged net device.}
421       \textcolor{comment}{//}
422       Address address = nd->GetAddress ();
423       Mac48Address mac48Address = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (address);
424 
425       \textcolor{comment}{//}
426       \textcolor{comment}{// The device-name is something we may want the system to make up in }
427       \textcolor{comment}{// every case.  We also rely on it being configured via an Attribute }
428       \textcolor{comment}{// through the helper.  By default, it is set to the empty string }
429       \textcolor{comment}{// which tells the system to make up a device name such as "tap123".}
430       \textcolor{comment}{//}
431       std::ostringstream ossDeviceName;
432       ossDeviceName << \textcolor{stringliteral}{"-d"} << \hyperlink{classns3_1_1TapBridge_af255e0f837eb4dd30c4de28448f862f6}{m\_tapDeviceName};
433 
434       \textcolor{comment}{//}
435       \textcolor{comment}{// The gateway-address is something we can't derive, so we rely on it}
436       \textcolor{comment}{// being configured via an Attribute through the helper.}
437       \textcolor{comment}{//}
438       std::ostringstream ossGateway;
439       ossGateway << \textcolor{stringliteral}{"-g"} << \hyperlink{classns3_1_1TapBridge_ad90dad655607615d92822a361ac21fb1}{m\_tapGateway};
440 
441       \textcolor{comment}{//}
442       \textcolor{comment}{// For flexibility, we do allow a client to override any of the values}
443       \textcolor{comment}{// above via attributes, so only use our found values if the Attribute}
444       \textcolor{comment}{// is not equal to its default value (empty string or broadcast address). }
445       \textcolor{comment}{//}
446       std::ostringstream ossIp;
447       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TapBridge_a8cfe2b69cef36dbf048cb9006318b41b}{m\_tapIp}.\hyperlink{classns3_1_1Ipv4Address_acff8d940bf4cc9282cf67c75eb9d777f}{IsBroadcast} ())
448         \{
449           ossIp << \textcolor{stringliteral}{"-i"} << ipv4Address;
450         \}
451       \textcolor{keywordflow}{else}
452         \{
453           ossIp << \textcolor{stringliteral}{"-i"} << \hyperlink{classns3_1_1TapBridge_a8cfe2b69cef36dbf048cb9006318b41b}{m\_tapIp};
454         \}
455 
456       std::ostringstream ossMac;
457       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TapBridge_afdaa87d8c5a5e249ee8d94f75183e91f}{m\_tapMac}.\hyperlink{classns3_1_1Mac48Address_ad9909ad21bac501799fb8810bfc58c1e}{IsBroadcast} ())
458         \{
459           ossMac << \textcolor{stringliteral}{"-m"} << mac48Address;
460         \}
461       \textcolor{keywordflow}{else}
462         \{
463           ossMac << \textcolor{stringliteral}{"-m"} << \hyperlink{classns3_1_1TapBridge_afdaa87d8c5a5e249ee8d94f75183e91f}{m\_tapMac};
464         \}
465 
466       std::ostringstream ossNetmask;
467       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TapBridge_a9374f832e2a96385651d27a5fbc7ba57}{m\_tapNetmask}.\hyperlink{classns3_1_1Ipv4Mask_a1428fba537359418d0b7d8c84a135a7e}{IsEqual} (\hyperlink{classns3_1_1Ipv4Mask_af712cbdf28c039025d4aa45fa7e243dd}{Ipv4Mask::GetOnes} ()))
468         \{
469           ossNetmask << \textcolor{stringliteral}{"-n"} << ipv4Mask;
470         \}
471       \textcolor{keywordflow}{else}
472         \{
473           ossNetmask << \textcolor{stringliteral}{"-n"} << \hyperlink{classns3_1_1TapBridge_a9374f832e2a96385651d27a5fbc7ba57}{m\_tapNetmask};
474         \}
475 
476       std::ostringstream ossMode;
477       ossMode << \textcolor{stringliteral}{"-o"};
478       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TapBridge_aaae30bc9d5dd36e3a4d569cf9bcf40eb}{m\_mode} == \hyperlink{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618daf2d0f6c8152d38e9400b2d9fd35f02a3}{CONFIGURE\_LOCAL})
479         \{
480           ossMode << \textcolor{stringliteral}{"1"};
481         \}
482       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TapBridge_aaae30bc9d5dd36e3a4d569cf9bcf40eb}{m\_mode} == \hyperlink{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618daa73ff9ba9e1659aeda35d7181b601c75}{USE\_LOCAL})
483         \{
484           ossMode << \textcolor{stringliteral}{"2"};
485         \}
486       \textcolor{keywordflow}{else}
487         \{
488           ossMode << \textcolor{stringliteral}{"3"};
489         \}
490 
491       std::ostringstream ossPath;
492       ossPath << \textcolor{stringliteral}{"-p"} << path;
493       \textcolor{comment}{//}
494       \textcolor{comment}{// Execute the socket creation process image.}
495       \textcolor{comment}{//}
496       status = ::execlp (TAP\_CREATOR, 
497                          TAP\_CREATOR,                       \textcolor{comment}{// argv[0] (filename)}
498                          ossDeviceName.str ().c\_str (),       \textcolor{comment}{// argv[1] (-d<device name>)}
499                          ossGateway.str ().c\_str (),          \textcolor{comment}{// argv[2] (-g<gateway>)}
500                          ossIp.str ().c\_str (),               \textcolor{comment}{// argv[3] (-i<IP address>)}
501                          ossMac.str ().c\_str (),              \textcolor{comment}{// argv[4] (-m<MAC address>)}
502                          ossNetmask.str ().c\_str (),          \textcolor{comment}{// argv[5] (-n<net mask>)}
503                          ossMode.str ().c\_str (),             \textcolor{comment}{// argv[6] (-o<operating mode>)}
504                          ossPath.str ().c\_str (),             \textcolor{comment}{// argv[7] (-p<path>)}
505                          (\textcolor{keywordtype}{char} *)NULL);
506 
507       \textcolor{comment}{//}
508       \textcolor{comment}{// If the execlp successfully completes, it never returns.  If it returns it failed or the OS is}
509       \textcolor{comment}{// broken.  In either case, we bail.}
510       \textcolor{comment}{//}
511       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"TapBridge::CreateTap(): Back from execlp(), status = "} << status <<
512                       \textcolor{stringliteral}{" errno = "} << ::strerror (errno));
513     \}
514   \textcolor{keywordflow}{else}
515     \{
516       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Parent process"});
517       \textcolor{comment}{//}
518       \textcolor{comment}{// We're the process running the emu net device.  We need to wait for the}
519       \textcolor{comment}{// socket creator process to finish its job.}
520       \textcolor{comment}{//}
521       \textcolor{keywordtype}{int} st;
522       pid\_t waited = waitpid (pid, &st, 0);
523       \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (waited == -1, \textcolor{stringliteral}{"TapBridge::CreateTap(): waitpid() fails, errno = "} << 
      std::strerror (errno));
524       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (pid == waited, \textcolor{stringliteral}{"TapBridge::CreateTap(): pid mismatch"});
525 
526       \textcolor{comment}{//}
527       \textcolor{comment}{// Check to see if the socket creator exited normally and then take a }
528       \textcolor{comment}{// look at the exit code.  If it bailed, so should we.  If it didn't}
529       \textcolor{comment}{// even exit normally, we bail too.}
530       \textcolor{comment}{//}
531       \textcolor{keywordflow}{if} (WIFEXITED (st))
532         \{
533           \textcolor{keywordtype}{int} exitStatus = WEXITSTATUS (st);
534           \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (exitStatus != 0, 
535                            \textcolor{stringliteral}{"TapBridge::CreateTap(): socket creator exited normally with status "} << 
      exitStatus);
536         \}
537       \textcolor{keywordflow}{else} 
538         \{
539           \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"TapBridge::CreateTap(): socket creator exited abnormally"});
540         \}
541 
542       \textcolor{comment}{//}
543       \textcolor{comment}{// At this point, the socket creator has run successfully and should }
544       \textcolor{comment}{// have created our tap device, initialized it with the information we}
545       \textcolor{comment}{// passed and sent it back to the socket address we provided.  A socket}
546       \textcolor{comment}{// (fd) we can use to talk to this tap device should be waiting on the }
547       \textcolor{comment}{// Unix socket we set up to receive information back from the creator}
548       \textcolor{comment}{// program.  We've got to do a bunch of grunt work to get at it, though.}
549       \textcolor{comment}{//}
550       \textcolor{comment}{// The struct iovec below is part of a scatter-gather list.  It describes a}
551       \textcolor{comment}{// buffer.  In this case, it describes a buffer (an integer) that will}
552       \textcolor{comment}{// get the data that comes back from the socket creator process.  It will}
553       \textcolor{comment}{// be a magic number that we use as a consistency/sanity check.}
554       \textcolor{comment}{// }
555       \textcolor{keyword}{struct }iovec iov;
556       uint32\_t magic;
557       iov.iov\_base = &magic;
558       iov.iov\_len = \textcolor{keyword}{sizeof}(magic);
559 
560       \textcolor{comment}{//}
561       \textcolor{comment}{// The CMSG macros you'll see below are used to create and access control }
562       \textcolor{comment}{// messages (which is another name for ancillary data).  The ancillary }
563       \textcolor{comment}{// data is made up of pairs of struct cmsghdr structures and associated}
564       \textcolor{comment}{// data arrays.}
565       \textcolor{comment}{//}
566       \textcolor{comment}{// First, we're going to allocate a buffer on the stack to receive our }
567       \textcolor{comment}{// data array (that contains the socket).  Sometimes you'll see this called}
568       \textcolor{comment}{// an "ancillary element" but the msghdr uses the control message termimology}
569       \textcolor{comment}{// so we call it "control."}
570       \textcolor{comment}{//}
571       \textcolor{keywordtype}{size\_t} msg\_size = \textcolor{keyword}{sizeof}(int);
572       \textcolor{keywordtype}{char} control[CMSG\_SPACE (msg\_size)];
573 
574       \textcolor{comment}{//}
575       \textcolor{comment}{// There is a msghdr that is used to minimize the number of parameters}
576       \textcolor{comment}{// passed to recvmsg (which we will use to receive our ancillary data).}
577       \textcolor{comment}{// This structure uses terminology corresponding to control messages, so}
578       \textcolor{comment}{// you'll see msg\_control, which is the pointer to the ancillary data and }
579       \textcolor{comment}{// controllen which is the size of the ancillary data array.}
580       \textcolor{comment}{//}
581       \textcolor{comment}{// So, initialize the message header that describes the ancillary/control}
582       \textcolor{comment}{// data we expect to receive and point it to buffer.}
583       \textcolor{comment}{//}
584       \textcolor{keyword}{struct }msghdr msg;
585       msg.msg\_name = 0;
586       msg.msg\_namelen = 0;
587       msg.msg\_iov = &iov;
588       msg.msg\_iovlen = 1;
589       msg.msg\_control = control;
590       msg.msg\_controllen = \textcolor{keyword}{sizeof} (control);
591       msg.msg\_flags = 0;
592 
593       \textcolor{comment}{//}
594       \textcolor{comment}{// Now we can actually receive the interesting bits from the tap}
595       \textcolor{comment}{// creator process.  Lots of pain to get four bytes.}
596       \textcolor{comment}{//}
597       ssize\_t bytesRead = recvmsg (sock, &msg, 0);
598       \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (bytesRead != \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}), \textcolor{stringliteral}{"TapBridge::CreateTap(): Wrong byte count
       from socket creator"});
599 
600       \textcolor{comment}{//}
601       \textcolor{comment}{// There may be a number of message headers/ancillary data arrays coming in.}
602       \textcolor{comment}{// Let's look for the one with a type SCM\_RIGHTS which indicates it's the}
603       \textcolor{comment}{// one we're interested in.}
604       \textcolor{comment}{//}
605       \textcolor{keyword}{struct }cmsghdr *cmsg;
606       \textcolor{keywordflow}{for} (cmsg = CMSG\_FIRSTHDR (&msg); cmsg != NULL; cmsg = CMSG\_NXTHDR (&msg, cmsg))
607         \{
608           \textcolor{keywordflow}{if} (cmsg->cmsg\_level == SOL\_SOCKET &&
609               cmsg->cmsg\_type == SCM\_RIGHTS)
610             \{
611               \textcolor{comment}{//}
612               \textcolor{comment}{// This is the type of message we want.  Check to see if the magic }
613               \textcolor{comment}{// number is correct and then pull out the socket we care about if}
614               \textcolor{comment}{// it matches}
615               \textcolor{comment}{//}
616               \textcolor{keywordflow}{if} (magic == \hyperlink{tap-bridge_8cc_af9ac95d538205da6013d79a63fee2bd7}{TAP\_MAGIC})
617                 \{
618                   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Got SCM\_RIGHTS with correct magic "} << magic);
619                   \textcolor{keywordtype}{int} *rawSocket = (\textcolor{keywordtype}{int}*)CMSG\_DATA (cmsg);
620                   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Got the socket from the socket creator = "} << *rawSocket);
621                   \hyperlink{classns3_1_1TapBridge_a52d87d41aa840377feebe63b5c5f2f3c}{m\_sock} = *rawSocket;
622                   \textcolor{keywordflow}{break};
623                 \}
624               \textcolor{keywordflow}{else}
625                 \{
626                   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Got SCM\_RIGHTS, but with bad magic "} << magic);
627                 \}
628             \}
629         \}
630       \textcolor{keywordflow}{if} (cmsg == NULL)
631         \{
632           \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Did not get the raw socket from the socket creator"});
633         \}
634 
635       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TapBridge_aaae30bc9d5dd36e3a4d569cf9bcf40eb}{m\_mode} == \hyperlink{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618daa73ff9ba9e1659aeda35d7181b601c75}{USE\_LOCAL} || \hyperlink{classns3_1_1TapBridge_aaae30bc9d5dd36e3a4d569cf9bcf40eb}{m\_mode} == \hyperlink{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618da33daa0eda93d6ec20fc491d7c440fc8d}{USE\_BRIDGE})
636         \{
637           \textcolor{comment}{//}
638           \textcolor{comment}{// Set the ns-3 device's mac address to the overlying container's}
639           \textcolor{comment}{// mac address}
640           \textcolor{comment}{//}
641           \textcolor{keyword}{struct }ifreq \hyperlink{generate__test__data__lte__sinr_8m_ad83eeb3a142285d1243a08c6b7026df8}{s};
642           strncpy (\hyperlink{generate__test__data__lte__sinr_8m_ad83eeb3a142285d1243a08c6b7026df8}{s}.ifr\_name, m\_tapDeviceName.c\_str (), \textcolor{keyword}{sizeof} (\hyperlink{generate__test__data__lte__sinr_8m_ad83eeb3a142285d1243a08c6b7026df8}{s}.ifr\_name));
643 
644           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Trying to get MacAddr of "} << m\_tapDeviceName);
645           \textcolor{keywordtype}{int} ioctlResult = ioctl (sock, SIOCGIFHWADDR, &\hyperlink{generate__test__data__lte__sinr_8m_ad83eeb3a142285d1243a08c6b7026df8}{s});
646           \textcolor{keywordflow}{if} (ioctlResult == 0)
647             \{
648               Mac48Address learnedMac;
649               learnedMac.CopyFrom ((uint8\_t *)\hyperlink{generate__test__data__lte__sinr_8m_ad83eeb3a142285d1243a08c6b7026df8}{s}.ifr\_hwaddr.sa\_data);
650               \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Learned Tap device MacAddr is "} << learnedMac << \textcolor{stringliteral}{": setting ns-3
       device to use this address"});
651               \hyperlink{classns3_1_1TapBridge_ac4ba97368116b628d632d318d5562420}{m\_bridgedDevice}->SetAddress (learnedMac);
652               \hyperlink{classns3_1_1TapBridge_a3200dc6b4b46d2f0fb13c867fcb0d118}{m\_ns3AddressRewritten} = \textcolor{keyword}{true};
653             \}
654 
655           \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1TapBridge_a3200dc6b4b46d2f0fb13c867fcb0d118}{m\_ns3AddressRewritten})
656             \{
657               \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Cannot get MacAddr of Tap device: "} << m\_tapDeviceName << \textcolor{stringliteral}{" while in
       USE\_LOCAL/USE\_BRIDGE mode: "} << std::strerror (errno));
658               \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Underlying ns-3 device will continue to use default address, what
       can lead to connectivity errors"});
659             \}
660         \}
661     \}
662 
663   close (sock);
664 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5




Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Discard\+From\+Bridged\+Device@{Discard\+From\+Bridged\+Device}}
\index{Discard\+From\+Bridged\+Device@{Discard\+From\+Bridged\+Device}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Discard\+From\+Bridged\+Device(\+Ptr$<$ Net\+Device $>$ device, Ptr$<$ const Packet $>$ packet, uint16\+\_\+t protocol, Address const \&src)}{DiscardFromBridgedDevice(Ptr< NetDevice > device, Ptr< const Packet > packet, uint16_t protocol, Address const &src)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Tap\+Bridge\+::\+Discard\+From\+Bridged\+Device (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{device, }
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{packet, }
\item[{uint16\+\_\+t}]{protocol, }
\item[{{\bf Address} const \&}]{src}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classns3_1_1TapBridge_a1837b0aa11c479938664a05cc5794c5f}{}\label{classns3_1_1TapBridge_a1837b0aa11c479938664a05cc5794c5f}
Receives a packet from a bridged Device 
\begin{DoxyParams}{Parameters}
{\em device} & the originating port \\
\hline
{\em packet} & the received packet \\
\hline
{\em protocol} & the packet protocol (e.\+g., Ethertype) \\
\hline
{\em src} & the packet source \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success 
\end{DoxyReturn}

\begin{DoxyCode}
922 \{
923   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (device << packet << protocol << src);
924   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Discarding packet stolen from bridged device "} << device);
925   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
926 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Do\+Dispose(void)}{DoDispose(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tap\+Bridge\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1TapBridge_afb9e635e18724e9de7371ff492117599}{}\label{classns3_1_1TapBridge_afb9e635e18724e9de7371ff492117599}
Call out to a separate process running as suid root in order to get our tap device created. We do this to avoid having the entire simulation running as root. If this method returns, we\textquotesingle{}ll have a socket waiting for us in m\+\_\+sock that we can use to talk to the tap device. 

Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.


\begin{DoxyCode}
167 \{
168   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
169   \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{NetDevice::DoDispose} ();
170 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8


\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Filter@{Filter}}
\index{Filter@{Filter}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Filter(\+Ptr$<$ Packet $>$ packet, Address $\ast$src, Address $\ast$dst, uint16\+\_\+t $\ast$type)}{Filter(Ptr< Packet > packet, Address *src, Address *dst, uint16_t *type)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Packet} $>$ ns3\+::\+Tap\+Bridge\+::\+Filter (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Address} $\ast$}]{src, }
\item[{{\bf Address} $\ast$}]{dst, }
\item[{uint16\+\_\+t $\ast$}]{type}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_aa141455ff96593217dcffd47d7bc48d0}{}\label{classns3_1_1TapBridge_aa141455ff96593217dcffd47d7bc48d0}
The host we are bridged to is in the evil real world. Do some sanity checking on a received packet to make sure it isn\textquotesingle{}t too evil for our poor naive virginal simulator to handle.


\begin{DoxyParams}{Parameters}
{\em packet} & The packet we received from the host, and which we need to check. \\
\hline
{\em src} & A pointer to the data structure that will get the source M\+AC address of the packet (extracted from the packet Ethernet header). \\
\hline
{\em dst} & A pointer to the data structure that will get the destination M\+AC address of the packet (extracted from the packet Ethernet header). \\
\hline
{\em type} & A pointer to the variable that will get the packet type from either the Ethernet header in the case of type interpretation (D\+IX framing) or from the 802.\+2 L\+LC header in the case of length interpretation (802.\+3 framing). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the packet, or null if the packet has been filtered. 
\end{DoxyReturn}

\begin{DoxyCode}
820 \{
821   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p});
822   uint32\_t pktSize;
823 
824   \textcolor{comment}{//}
825   \textcolor{comment}{// We have a candidate packet for injection into ns-3.  We expect that since}
826   \textcolor{comment}{// it came over a socket that provides Ethernet packets, it should be big }
827   \textcolor{comment}{// enough to hold an EthernetHeader.  If it can't, we signify the packet }
828   \textcolor{comment}{// should be filtered out by returning 0.}
829   \textcolor{comment}{//}
830   pktSize = \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->GetSize ();
831   EthernetHeader header (\textcolor{keyword}{false});
832   \textcolor{keywordflow}{if} (pktSize < header.GetSerializedSize ())
833     \{
834       \textcolor{keywordflow}{return} 0;
835     \}
836 
837   uint32\_t headerSize = \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->PeekHeader (header);
838   \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->RemoveAtStart (headerSize);
839 
840   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Pkt source is "} << header.GetSource ());
841   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Pkt destination is "} << header.GetDestination ());
842   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Pkt LengthType is "} << header.GetLengthType ());
843 
844   \textcolor{comment}{//}
845   \textcolor{comment}{// If the length/type is less than 1500, it corresponds to a length }
846   \textcolor{comment}{// interpretation packet.  In this case, it is an 802.3 packet and }
847   \textcolor{comment}{// will also have an 802.2 LLC header.  If greater than 1500, we}
848   \textcolor{comment}{// find the protocol number (Ethernet type) directly.}
849   \textcolor{comment}{//}
850   \textcolor{keywordflow}{if} (header.GetLengthType () <= 1500)
851     \{
852       *src = header.GetSource ();
853       *dst = header.GetDestination ();
854 
855       pktSize = \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->GetSize ();
856       LlcSnapHeader llc;
857       \textcolor{keywordflow}{if} (pktSize < llc.GetSerializedSize ())
858         \{
859           \textcolor{keywordflow}{return} 0;
860         \}
861 
862       \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->RemoveHeader (llc);
863       *\hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type} = llc.GetType ();
864     \}
865   \textcolor{keywordflow}{else}
866     \{
867       *src = header.GetSource ();
868       *dst = header.GetDestination ();
869       *\hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type} = header.GetLengthType ();
870     \}
871 
872   \textcolor{comment}{//}
873   \textcolor{comment}{// What we give back is a packet without the Ethernet header (nor the }
874   \textcolor{comment}{// possible llc/snap header) on it.  We think it is ready to send on}
875   \textcolor{comment}{// out the bridged net device.}
876   \textcolor{comment}{//}
877   \textcolor{keywordflow}{return} \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p};
878 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9




Here is the caller graph for this function\+:
% FIG 10


\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Forward\+To\+Bridged\+Device@{Forward\+To\+Bridged\+Device}}
\index{Forward\+To\+Bridged\+Device@{Forward\+To\+Bridged\+Device}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Forward\+To\+Bridged\+Device(uint8\+\_\+t $\ast$buf, ssize\+\_\+t len)}{ForwardToBridgedDevice(uint8_t *buf, ssize_t len)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tap\+Bridge\+::\+Forward\+To\+Bridged\+Device (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$}]{buf, }
\item[{ssize\+\_\+t}]{len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_ab4390af3653278cc4ea265d3c7f4de15}{}\label{classns3_1_1TapBridge_ab4390af3653278cc4ea265d3c7f4de15}
Forward a packet received from the tap device to the bridged ns-\/3 device


\begin{DoxyParams}{Parameters}
{\em buf} & A character buffer containing the actual packet bits that were received from the host. \\
\hline
{\em len} & The length of the buffer. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
693 \{
694   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (buf << len);
695 
696   \textcolor{comment}{//}
697   \textcolor{comment}{// There are three operating modes for the TapBridge}
698   \textcolor{comment}{//}
699   \textcolor{comment}{// CONFIGURE\_LOCAL means that ns-3 will create and configure a tap device}
700   \textcolor{comment}{// and we are expected to use it.  The tap device and the ns-3 net device}
701   \textcolor{comment}{// will have the same MAC address by definition.  Thus Send and SendFrom}
702   \textcolor{comment}{// are equivalent in this case.  We use Send to allow all ns-3 devices to}
703   \textcolor{comment}{// participate in this mode.}
704   \textcolor{comment}{//}
705   \textcolor{comment}{// USE\_LOCAL mode tells us that we have got to USE a pre-created tap device}
706   \textcolor{comment}{// that will have a different MAC address from the ns-3 net device.  We }
707   \textcolor{comment}{// also enforce the requirement that there will only be one MAC address}
708   \textcolor{comment}{// bridged on the Linux side so we can use Send (instead of SendFrom) in}
709   \textcolor{comment}{// the linux to ns-3 direction.  Again, all ns-3 devices can participate}
710   \textcolor{comment}{// in this mode.}
711   \textcolor{comment}{//}
712   \textcolor{comment}{// USE\_BRIDGE mode tells us that we are logically extending a Linux bridge}
713   \textcolor{comment}{// on which lies our tap device.  In this case there may be many linux}
714   \textcolor{comment}{// net devices on the other side of the bridge and so we must use SendFrom}
715   \textcolor{comment}{// to preserve the possibly many source addresses.  Thus, ns-3 devices }
716   \textcolor{comment}{// must support SendFrom in order to be considered for USE\_BRIDGE mode.}
717   \textcolor{comment}{//}
718 
719   \textcolor{comment}{//}
720   \textcolor{comment}{// First, create a packet out of the byte buffer we received and free that}
721   \textcolor{comment}{// buffer.}
722   \textcolor{comment}{//}
723   Ptr<Packet> packet = Create<Packet> (\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }uint8\_t *\textcolor{keyword}{>} (buf), len);
724   std::free (buf);
725   buf = 0;
726 
727   \textcolor{comment}{//}
728   \textcolor{comment}{// Make sure the packet we received is reasonable enough for the rest of the }
729   \textcolor{comment}{// system to handle and get it ready to be injected directly into an ns-3}
730   \textcolor{comment}{// device.  What should come back is a packet with the Ethernet header }
731   \textcolor{comment}{// (and possibly an LLC header as well) stripped off.}
732   \textcolor{comment}{//}
733   Address src, dst;
734   uint16\_t \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type};
735 
736   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Received packet from tap device"});
737 
738   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = \hyperlink{classns3_1_1TapBridge_aa141455ff96593217dcffd47d7bc48d0}{Filter} (packet, &src, &dst, &\hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type});
739   \textcolor{keywordflow}{if} (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} == 0)
740     \{
741       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"TapBridge::ForwardToBridgedDevice:  Discarding packet as unfit for ns-3
       consumption"});
742       \textcolor{keywordflow}{return};
743     \}
744 
745   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Pkt source is "} << src);
746   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Pkt destination is "} << dst);
747   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Pkt LengthType is "} << \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type});
748   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TapBridge_aaae30bc9d5dd36e3a4d569cf9bcf40eb}{m\_mode} == \hyperlink{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618daa73ff9ba9e1659aeda35d7181b601c75}{USE\_LOCAL})
749     \{
750       \textcolor{comment}{//}
751       \textcolor{comment}{// Packets we are going to forward should not be from a broadcast src}
752       \textcolor{comment}{//}
753       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (src) != Mac48Address 
      (\textcolor{stringliteral}{"ff:ff:ff:ff:ff:ff"}), 
754                      \textcolor{stringliteral}{"TapBridge::ForwardToBridgedDevice:  Source addr is broadcast"});
755       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TapBridge_a3200dc6b4b46d2f0fb13c867fcb0d118}{m\_ns3AddressRewritten} == \textcolor{keyword}{false})
756         \{
757           \textcolor{comment}{//}
758           \textcolor{comment}{// Set the ns-3 device's mac address to the overlying container's}
759           \textcolor{comment}{// mac address}
760           \textcolor{comment}{//}
761           Mac48Address learnedMac = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (src);
762           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Learned MacAddr is "} << learnedMac << \textcolor{stringliteral}{": setting ns-3 device to use
       this address"});
763           \hyperlink{classns3_1_1TapBridge_ac4ba97368116b628d632d318d5562420}{m\_bridgedDevice}->SetAddress (\hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (
      learnedMac));
764           \hyperlink{classns3_1_1TapBridge_a3200dc6b4b46d2f0fb13c867fcb0d118}{m\_ns3AddressRewritten} = \textcolor{keyword}{true};
765         \}
766       \textcolor{comment}{// }
767       \textcolor{comment}{// If we are operating in USE\_LOCAL mode, we may be attached to an ns-3}
768       \textcolor{comment}{// device that does not support bridging (SupportsSendFrom returns false).}
769       \textcolor{comment}{// But, since the mac addresses are now aligned, we can call Send()}
770       \textcolor{comment}{//}
771       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Forwarding packet to ns-3 device via Send()"});
772       \hyperlink{classns3_1_1TapBridge_ac4ba97368116b628d632d318d5562420}{m\_bridgedDevice}->Send (packet, dst, \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type});
773       \textcolor{keywordflow}{return};
774     \}
775 
776   \textcolor{comment}{//}
777   \textcolor{comment}{// If we are operating in USE\_BRIDGE mode, we have the }
778   \textcolor{comment}{// situation described below:}
779   \textcolor{comment}{//}
780   \textcolor{comment}{//  Other Device  <-bridge->  Tap Device  <-bridge-> ns3 device}
781   \textcolor{comment}{//   Mac Addr A               Mac Addr B             Mac Addr C}
782   \textcolor{comment}{//}
783   \textcolor{comment}{// In Linux, "Other Device" and "Tap Device" are bridged together.  By this}
784   \textcolor{comment}{// we mean that a user has sone something in Linux like:}
785   \textcolor{comment}{//}
786   \textcolor{comment}{//   brctl addbr mybridge}
787   \textcolor{comment}{//   brctl addif other-device}
788   \textcolor{comment}{//   brctl addif tap-device}
789   \textcolor{comment}{//}
790   \textcolor{comment}{// In USE\_BRIDGE mode, we want to logically extend this Linux behavior to the }
791   \textcolor{comment}{// simulated ns3 device and make it appear as if it is connected to the Linux}
792   \textcolor{comment}{// subnet.  As you may expect, this means that we need to act like a real}
793   \textcolor{comment}{// Linux bridge and take all packets that come from "Tap Device" and ask }
794   \textcolor{comment}{// "ns3 Device" to send them down its directly connected network.  Just like }
795   \textcolor{comment}{// in a normal everyday bridge we need to call SendFrom in order to preserve }
796   \textcolor{comment}{//the original packet's from address.}
797   \textcolor{comment}{//}
798   \textcolor{comment}{// If we are operating in CONFIGURE\_LOCAL mode, we simply simply take all packets}
799   \textcolor{comment}{// that come from "Tap Device" and ask "ns3 Device" to send them down its }
800   \textcolor{comment}{// directly connected network.  A normal bridge would need to call SendFrom}
801   \textcolor{comment}{// in order to preserve the original from address, but in CONFIGURE\_LOCAL mode}
802   \textcolor{comment}{// the tap device and the ns-3 device have the same MAC address by definition so }
803   \textcolor{comment}{// we can call Send.}
804   \textcolor{comment}{//}
805   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Forwarding packet"});
806 
807   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TapBridge_aaae30bc9d5dd36e3a4d569cf9bcf40eb}{m\_mode} == \hyperlink{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618da33daa0eda93d6ec20fc491d7c440fc8d}{USE\_BRIDGE})
808     \{
809       \hyperlink{classns3_1_1TapBridge_ac4ba97368116b628d632d318d5562420}{m\_bridgedDevice}->SendFrom (packet, src, dst, \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type});
810     \}
811   \textcolor{keywordflow}{else}
812     \{
813       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\hyperlink{classns3_1_1TapBridge_aaae30bc9d5dd36e3a4d569cf9bcf40eb}{m\_mode} == \hyperlink{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618daf2d0f6c8152d38e9400b2d9fd35f02a3}{CONFIGURE\_LOCAL}, \textcolor{stringliteral}{"
      TapBridge::ForwardToBridgedDevice(): Internal error"});
814       \hyperlink{classns3_1_1TapBridge_ac4ba97368116b628d632d318d5562420}{m\_bridgedDevice}->Send (packet, dst, \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type});
815     \}
816 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 11




Here is the caller graph for this function\+:
% FIG 12


\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Get\+Address@{Get\+Address}}
\index{Get\+Address@{Get\+Address}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Get\+Address(void) const }{GetAddress(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Tap\+Bridge\+::\+Get\+Address (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TapBridge_adad791a296c4d4015a6d2e2d022b6a63}{}\label{classns3_1_1TapBridge_adad791a296c4d4015a6d2e2d022b6a63}
\begin{DoxyReturn}{Returns}
the current \hyperlink{classns3_1_1Address}{Address} of this interface. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a671f99de496d6f09ae343bb715301fb2}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1030 \{
1031   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
1032   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TapBridge_a70e331b3deb893d7aa013ef44a7ee4a7}{m\_address};
1033 \}
\end{DoxyCode}
\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Get\+Bridged\+Net\+Device@{Get\+Bridged\+Net\+Device}}
\index{Get\+Bridged\+Net\+Device@{Get\+Bridged\+Net\+Device}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Get\+Bridged\+Net\+Device(void)}{GetBridgedNetDevice(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Net\+Device} $>$ ns3\+::\+Tap\+Bridge\+::\+Get\+Bridged\+Net\+Device (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TapBridge_afc497fe420a336be2ff9076ab90cf713}{}\label{classns3_1_1TapBridge_afc497fe420a336be2ff9076ab90cf713}


Get the bridged net device. 

The bridged net device is the ns-\/3 device to which this bridge is connected,

\begin{DoxyReturn}{Returns}
the bridged net device. 
\end{DoxyReturn}

\begin{DoxyCode}
882 \{
883   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
884   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TapBridge_ac4ba97368116b628d632d318d5562420}{m\_bridgedDevice};
885 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 13


\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Get\+Broadcast@{Get\+Broadcast}}
\index{Get\+Broadcast@{Get\+Broadcast}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Get\+Broadcast(void) const }{GetBroadcast(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Tap\+Bridge\+::\+Get\+Broadcast (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TapBridge_ab0c6b045924ddf43fb33c2dc79581923}{}\label{classns3_1_1TapBridge_ab0c6b045924ddf43fb33c2dc79581923}
\begin{DoxyReturn}{Returns}
the broadcast address supported by this netdevice.
\end{DoxyReturn}
Calling this method is invalid if Is\+Broadcast returns not true. 

Implements \hyperlink{classns3_1_1NetDevice_a4724e03bc548dd8e967cc4a7356197bd}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1098 \{
1099   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
1100   \textcolor{keywordflow}{return} Mac48Address (\textcolor{stringliteral}{"ff:ff:ff:ff:ff:ff"});
1101 \}
\end{DoxyCode}
\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Get\+Channel@{Get\+Channel}}
\index{Get\+Channel@{Get\+Channel}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Get\+Channel(void) const }{GetChannel(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Channel} $>$ ns3\+::\+Tap\+Bridge\+::\+Get\+Channel (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TapBridge_a2db1411e39ca9653ddcccc3000862ab1}{}\label{classns3_1_1TapBridge_a2db1411e39ca9653ddcccc3000862ab1}
\begin{DoxyReturn}{Returns}
the channel this \hyperlink{classns3_1_1NetDevice}{Net\+Device} is connected to. The value returned can be zero if the \hyperlink{classns3_1_1NetDevice}{Net\+Device} is not yet connected to any channel or if the underlying \hyperlink{classns3_1_1NetDevice}{Net\+Device} has no concept of a channel. i.\+e., callers {\itshape must} check for zero and be ready to handle it. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a3d810bd2738634e2e851661271828565}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1016 \{
1017   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
1018   \textcolor{keywordflow}{return} 0;
1019 \}
\end{DoxyCode}
\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Get\+If\+Index@{Get\+If\+Index}}
\index{Get\+If\+Index@{Get\+If\+Index}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Get\+If\+Index(void) const }{GetIfIndex(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Tap\+Bridge\+::\+Get\+If\+Index (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TapBridge_ae7688d83bd817150755e48c8207b5633}{}\label{classns3_1_1TapBridge_ae7688d83bd817150755e48c8207b5633}
\begin{DoxyReturn}{Returns}
index if\+Index of the device 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a8c1ae2ec8eadc4524dfc1e425bfa0850}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1009 \{
1010   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
1011   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TapBridge_a5de0f6399c095a680978c72bcd90b228}{m\_ifIndex};
1012 \}
\end{DoxyCode}
\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Get\+Mode@{Get\+Mode}}
\index{Get\+Mode@{Get\+Mode}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Get\+Mode(void)}{GetMode(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tap\+Bridge\+::\+Mode} ns3\+::\+Tap\+Bridge\+::\+Get\+Mode (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TapBridge_a0d4f1ff39b0d57d463a16f1617e6d19f}{}\label{classns3_1_1TapBridge_a0d4f1ff39b0d57d463a16f1617e6d19f}
Get the operating mode of this device.

\begin{DoxyReturn}{Returns}
The operating mode of this device. 
\end{DoxyReturn}

\begin{DoxyCode}
1044 \{
1045   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
1046   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TapBridge_aaae30bc9d5dd36e3a4d569cf9bcf40eb}{m\_mode};
1047 \}
\end{DoxyCode}
\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Get\+Mtu@{Get\+Mtu}}
\index{Get\+Mtu@{Get\+Mtu}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Get\+Mtu(void) const }{GetMtu(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Tap\+Bridge\+::\+Get\+Mtu (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TapBridge_a9c10575ce501dfa92da9f45b32891407}{}\label{classns3_1_1TapBridge_a9c10575ce501dfa92da9f45b32891407}
\begin{DoxyReturn}{Returns}
the link-\/level M\+TU in bytes for this interface.
\end{DoxyReturn}
This value is typically used by the IP layer to perform IP fragmentation when needed. 

Implements \hyperlink{classns3_1_1NetDevice_a91f4f5d01bc2d567c1e0a69b63a4cf14}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1059 \{
1060   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
1061   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TapBridge_a8aca7b3808d23f6a5f8e6c212c0af618}{m\_mtu};
1062 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 14


\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Get\+Multicast@{Get\+Multicast}}
\index{Get\+Multicast@{Get\+Multicast}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Get\+Multicast(\+Ipv4\+Address multicast\+Group) const }{GetMulticast(Ipv4Address multicastGroup) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Tap\+Bridge\+::\+Get\+Multicast (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{multicast\+Group}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TapBridge_a76c7ce4e8ba5177450b62e386d2aeddf}{}\label{classns3_1_1TapBridge_a76c7ce4e8ba5177450b62e386d2aeddf}


Make and return a M\+AC multicast address using the provided multicast group. 

\{1112\} says that an \hyperlink{classns3_1_1Ipv4}{Ipv4} host group address is mapped to an Ethernet multicast address by placing the low-\/order 23-\/bits of the IP address into the low-\/order 23 bits of the Ethernet multicast address 01-\/00-\/5\+E-\/00-\/00-\/00 (hex). Similar R\+F\+Cs exist for \hyperlink{classns3_1_1Ipv6}{Ipv6} and Eui64 mappings. This method performs the multicast address creation function appropriate to the underlying M\+AC address of the device. This M\+AC address is encapsulated in an abstract \hyperlink{classns3_1_1Address}{Address} to avoid dependencies on the exact M\+AC address format.

In the case of net devices that do not support multicast, clients are expected to test \hyperlink{classns3_1_1NetDevice_a1afb4848a9226540f1ff51f9b31ae95e}{Net\+Device\+::\+Is\+Multicast} and avoid attempting to map multicast packets. Subclasses of \hyperlink{classns3_1_1NetDevice}{Net\+Device} that do support multicasting are expected to override this method and provide an implementation appropriate to the particular device.


\begin{DoxyParams}{Parameters}
{\em multicast\+Group} & The IP address for the multicast group destination of the packet. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The M\+AC multicast \hyperlink{classns3_1_1Address}{Address} used to send packets to the provided multicast group.
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Calling this method is invalid if Is\+Multicast returns not true. 
\end{DoxyWarning}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1TapBridge_a08b9d57e3a6a50f224ea517d241f3ee8}{Is\+Multicast()} 
\end{DoxySeeAlso}


Implements \hyperlink{classns3_1_1NetDevice_a98aa4852df367b6a393c8cc1d88af0d9}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1112 \{
1113   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << multicastGroup);
1114   Mac48Address multicast = \hyperlink{classns3_1_1Mac48Address_a23d170f8c7a7d90a8110425620285819}{Mac48Address::GetMulticast} (multicastGroup);
1115   \textcolor{keywordflow}{return} multicast;
1116 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 15


\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Get\+Multicast@{Get\+Multicast}}
\index{Get\+Multicast@{Get\+Multicast}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Get\+Multicast(\+Ipv6\+Address addr) const }{GetMulticast(Ipv6Address addr) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Tap\+Bridge\+::\+Get\+Multicast (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{addr}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TapBridge_a2ebaad85807dd1d2fc8a354a46c69076}{}\label{classns3_1_1TapBridge_a2ebaad85807dd1d2fc8a354a46c69076}


Get the M\+AC multicast address corresponding to the I\+Pv6 address provided. 


\begin{DoxyParams}{Parameters}
{\em addr} & I\+Pv6 address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the M\+AC multicast address 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Calling this method is invalid if Is\+Multicast returns not true. 
\end{DoxyWarning}


Implements \hyperlink{classns3_1_1NetDevice_a46479a2c0101c6f9da9251ed4d7575bd}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1197 \{
1198   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << addr);
1199   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Mac48Address_a23d170f8c7a7d90a8110425620285819}{Mac48Address::GetMulticast} (addr);
1200 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 16


\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Get\+Node@{Get\+Node}}
\index{Get\+Node@{Get\+Node}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Get\+Node(void) const }{GetNode(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Node} $>$ ns3\+::\+Tap\+Bridge\+::\+Get\+Node (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TapBridge_ae200e9184e81dcad678e1016ff0375c6}{}\label{classns3_1_1TapBridge_ae200e9184e81dcad678e1016ff0375c6}
\begin{DoxyReturn}{Returns}
the node base class which contains this network interface.
\end{DoxyReturn}
When a subclass needs to get access to the underlying node base class to print the nodeid for example, it can invoke this method. 

Implements \hyperlink{classns3_1_1NetDevice_a098b6cc4339ac00c62e75cfa48c8aeac}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1156 \{
1157   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
1158   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TapBridge_aab85ad5d27b8de91e7a02e8d8ee4332e}{m\_node};
1159 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 17


\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Tap\+Bridge\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1TapBridge_a9ac80b6070b0e111d23367c42e411746}{}\label{classns3_1_1TapBridge_a9ac80b6070b0e111d23367c42e411746}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
80 \{
81   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::TapBridge"})
82     .SetParent<NetDevice> ()
83     .SetGroupName (\textcolor{stringliteral}{"TapBridge"})
84     .AddConstructor<\hyperlink{classns3_1_1TapBridge_a59285065e82d8ba63306846fc4082f4b}{TapBridge}> ()
85     .AddAttribute (\textcolor{stringliteral}{"Mtu"}, \textcolor{stringliteral}{"The MAC-level Maximum Transmission Unit"},
86                    UintegerValue (0),
87                    MakeUintegerAccessor (&\hyperlink{classns3_1_1TapBridge_af41aca6484197a8a139b8db0fbcb6b79}{TapBridge::SetMtu},
88                                          &\hyperlink{classns3_1_1TapBridge_a9c10575ce501dfa92da9f45b32891407}{TapBridge::GetMtu}),
89                    MakeUintegerChecker<uint16\_t> ())
90     .AddAttribute (\textcolor{stringliteral}{"DeviceName"}, 
91                    \textcolor{stringliteral}{"The name of the tap device to create."},
92                    StringValue (\textcolor{stringliteral}{""}),
93                    MakeStringAccessor (&\hyperlink{classns3_1_1TapBridge_af255e0f837eb4dd30c4de28448f862f6}{TapBridge::m\_tapDeviceName}),
94                    MakeStringChecker ())
95     .AddAttribute (\textcolor{stringliteral}{"Gateway"}, 
96                    \textcolor{stringliteral}{"The IP address of the default gateway to assign to the host machine, when in
       ConfigureLocal mode."},
97                    Ipv4AddressValue (\textcolor{stringliteral}{"255.255.255.255"}),
98                    MakeIpv4AddressAccessor (&\hyperlink{classns3_1_1TapBridge_ad90dad655607615d92822a361ac21fb1}{TapBridge::m\_tapGateway}),
99                    MakeIpv4AddressChecker ())
100     .AddAttribute (\textcolor{stringliteral}{"IpAddress"}, 
101                    \textcolor{stringliteral}{"The IP address to assign to the tap device, when in ConfigureLocal mode.  "}
102                    \textcolor{stringliteral}{"This address will override the discovered IP address of the simulated device."},
103                    Ipv4AddressValue (\textcolor{stringliteral}{"255.255.255.255"}),
104                    MakeIpv4AddressAccessor (&\hyperlink{classns3_1_1TapBridge_a8cfe2b69cef36dbf048cb9006318b41b}{TapBridge::m\_tapIp}),
105                    MakeIpv4AddressChecker ())
106     .AddAttribute (\textcolor{stringliteral}{"MacAddress"}, 
107                    \textcolor{stringliteral}{"The MAC address to assign to the tap device, when in ConfigureLocal mode.  "}
108                    \textcolor{stringliteral}{"This address will override the discovered MAC address of the simulated device."},
109                    Mac48AddressValue (Mac48Address (\textcolor{stringliteral}{"ff:ff:ff:ff:ff:ff"})),
110                    MakeMac48AddressAccessor (&\hyperlink{classns3_1_1TapBridge_afdaa87d8c5a5e249ee8d94f75183e91f}{TapBridge::m\_tapMac}),
111                    MakeMac48AddressChecker ())
112     .AddAttribute (\textcolor{stringliteral}{"Netmask"}, 
113                    \textcolor{stringliteral}{"The network mask to assign to the tap device, when in ConfigureLocal mode.  "}
114                    \textcolor{stringliteral}{"This address will override the discovered MAC address of the simulated device."},
115                    Ipv4MaskValue (\textcolor{stringliteral}{"255.255.255.255"}),
116                    MakeIpv4MaskAccessor (&\hyperlink{classns3_1_1TapBridge_a9374f832e2a96385651d27a5fbc7ba57}{TapBridge::m\_tapNetmask}),
117                    MakeIpv4MaskChecker ())
118     .AddAttribute (\textcolor{stringliteral}{"Start"}, 
119                    \textcolor{stringliteral}{"The simulation time at which to spin up the tap device read thread."},
120                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (0.)),
121                    MakeTimeAccessor (&\hyperlink{classns3_1_1TapBridge_ad6cde3114d24223d3edf0270ce4af231}{TapBridge::m\_tStart}),
122                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
123     .AddAttribute (\textcolor{stringliteral}{"Stop"}, 
124                    \textcolor{stringliteral}{"The simulation time at which to tear down the tap device read thread."},
125                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (0.)),
126                    MakeTimeAccessor (&\hyperlink{classns3_1_1TapBridge_ae91102625b83c3b447f48d1798041ab8}{TapBridge::m\_tStop}),
127                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
128     .AddAttribute (\textcolor{stringliteral}{"Mode"}, 
129                    \textcolor{stringliteral}{"The operating and configuration mode to use."},
130                    EnumValue (\hyperlink{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618daa73ff9ba9e1659aeda35d7181b601c75}{USE\_LOCAL}),
131                    \hyperlink{namespacens3_af5050739867ce63896dec011e332c8ec}{MakeEnumAccessor} (&\hyperlink{classns3_1_1TapBridge_a435d654af7e7970c365d14b4a5dc3044}{TapBridge::SetMode}),
132                    \hyperlink{namespacens3_a48832781a2b521d3d0091e05ece30615}{MakeEnumChecker} (\hyperlink{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618daf2d0f6c8152d38e9400b2d9fd35f02a3}{CONFIGURE\_LOCAL}, \textcolor{stringliteral}{"ConfigureLocal"},
133                                     \hyperlink{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618daa73ff9ba9e1659aeda35d7181b601c75}{USE\_LOCAL}, \textcolor{stringliteral}{"UseLocal"},
134                                     \hyperlink{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618da33daa0eda93d6ec20fc491d7c440fc8d}{USE\_BRIDGE}, \textcolor{stringliteral}{"UseBridge"}))
135   ;
136   \textcolor{keywordflow}{return} tid;
137 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 18


\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Is\+Bridge@{Is\+Bridge}}
\index{Is\+Bridge@{Is\+Bridge}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Is\+Bridge(void) const }{IsBridge(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Tap\+Bridge\+::\+Is\+Bridge (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TapBridge_a95e3ba17b506b9aaae4d3cfd1b4356b0}{}\label{classns3_1_1TapBridge_a95e3ba17b506b9aaae4d3cfd1b4356b0}


Return true if the net device is acting as a bridge. 

\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Bridge flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a9d34556a1c83a69dacb08698ca4a1d94}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1127 \{
1128   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
1129   \textcolor{comment}{//}
1130   \textcolor{comment}{// Returning false from IsBridge in a device called TapBridge may seem odd}
1131   \textcolor{comment}{// at first glance, but this test is for a device that bridges ns-3 devices}
1132   \textcolor{comment}{// together.  The Tap bridge doesn't do that -- it bridges an ns-3 device to}
1133   \textcolor{comment}{// a Linux device.  This is a completely different story.}
1134   \textcolor{comment}{// }
1135   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1136 \}
\end{DoxyCode}
\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Is\+Broadcast@{Is\+Broadcast}}
\index{Is\+Broadcast@{Is\+Broadcast}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Is\+Broadcast(void) const }{IsBroadcast(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Tap\+Bridge\+::\+Is\+Broadcast (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TapBridge_aae97d70b414626bf3662a3916ff9b64e}{}\label{classns3_1_1TapBridge_aae97d70b414626bf3662a3916ff9b64e}
\begin{DoxyReturn}{Returns}
true if this interface supports a broadcast address, false otherwise. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a67f992b20858cd7b397d8fba2feff141}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1091 \{
1092   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
1093   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1094 \}
\end{DoxyCode}
\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Is\+Link\+Up@{Is\+Link\+Up}}
\index{Is\+Link\+Up@{Is\+Link\+Up}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Is\+Link\+Up(void) const }{IsLinkUp(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Tap\+Bridge\+::\+Is\+Link\+Up (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TapBridge_a3d8af7dbe31c534dec551c38f2f66afa}{}\label{classns3_1_1TapBridge_a3d8af7dbe31c534dec551c38f2f66afa}
\begin{DoxyReturn}{Returns}
true if link is up; false otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_afe1822b79e19a05ab95f693c8fb64fc7}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1077 \{
1078   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
1079   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TapBridge_a335b96cae7f60f5d5bcf60234af96339}{m\_linkUp};
1080 \}
\end{DoxyCode}
\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Is\+Multicast@{Is\+Multicast}}
\index{Is\+Multicast@{Is\+Multicast}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Is\+Multicast(void) const }{IsMulticast(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Tap\+Bridge\+::\+Is\+Multicast (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TapBridge_a08b9d57e3a6a50f224ea517d241f3ee8}{}\label{classns3_1_1TapBridge_a08b9d57e3a6a50f224ea517d241f3ee8}
\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Multicast flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a1afb4848a9226540f1ff51f9b31ae95e}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1105 \{
1106   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
1107   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1108 \}
\end{DoxyCode}
\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Is\+Point\+To\+Point@{Is\+Point\+To\+Point}}
\index{Is\+Point\+To\+Point@{Is\+Point\+To\+Point}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Is\+Point\+To\+Point(void) const }{IsPointToPoint(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Tap\+Bridge\+::\+Is\+Point\+To\+Point (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TapBridge_a6e884e1a4e268402f183e35953458d4a}{}\label{classns3_1_1TapBridge_a6e884e1a4e268402f183e35953458d4a}


Return true if the net device is on a point-\/to-\/point link. 

\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Point\+To\+Point flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a718177f25efeaf2dbf8a18fcab87224d}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1120 \{
1121   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
1122   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1123 \}
\end{DoxyCode}
\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Needs\+Arp@{Needs\+Arp}}
\index{Needs\+Arp@{Needs\+Arp}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Needs\+Arp(void) const }{NeedsArp(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Tap\+Bridge\+::\+Needs\+Arp (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TapBridge_a5a4660c9d4f687bfa6374e5998faae75}{}\label{classns3_1_1TapBridge_a5a4660c9d4f687bfa6374e5998faae75}
\begin{DoxyReturn}{Returns}
true if A\+RP is needed, false otherwise.
\end{DoxyReturn}
Called by higher-\/layers to check if this \hyperlink{classns3_1_1NetDevice}{Net\+Device} requires A\+RP to be used. 

Implements \hyperlink{classns3_1_1NetDevice_ab1a133696310cad3dc2c3d1a4993f310}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1170 \{
1171   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
1172   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1173 \}
\end{DoxyCode}
\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Notify\+Link\+Up@{Notify\+Link\+Up}}
\index{Notify\+Link\+Up@{Notify\+Link\+Up}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Notify\+Link\+Up(void)}{NotifyLinkUp(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tap\+Bridge\+::\+Notify\+Link\+Up (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_a845a502163a985d26b2b70c36493d945}{}\label{classns3_1_1TapBridge_a845a502163a985d26b2b70c36493d945}
Notifies that the link is up and ready. 
\begin{DoxyCode}
1066 \{
1067   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
1068   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1TapBridge_a335b96cae7f60f5d5bcf60234af96339}{m\_linkUp})
1069     \{
1070       \hyperlink{classns3_1_1TapBridge_a335b96cae7f60f5d5bcf60234af96339}{m\_linkUp} = \textcolor{keyword}{true};
1071       \hyperlink{classns3_1_1TapBridge_a3c5c9f53b15fc47d55420f4905297a06}{m\_linkChangeCallbacks} ();
1072     \}
1073 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 19


\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Read\+Callback@{Read\+Callback}}
\index{Read\+Callback@{Read\+Callback}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Read\+Callback(uint8\+\_\+t $\ast$buf, ssize\+\_\+t len)}{ReadCallback(uint8_t *buf, ssize_t len)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tap\+Bridge\+::\+Read\+Callback (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$}]{buf, }
\item[{ssize\+\_\+t}]{len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_a8cf7414db717096f2b3a2a0e7026ed8f}{}\label{classns3_1_1TapBridge_a8cf7414db717096f2b3a2a0e7026ed8f}
\hyperlink{classns3_1_1Callback}{Callback} to process packets that are read 
\begin{DoxyCode}
668 \{
669   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
670 
671   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (buf != 0, \textcolor{stringliteral}{"invalid buf argument"});
672   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (len > 0, \textcolor{stringliteral}{"invalid len argument"});
673 
674   \textcolor{comment}{//}
675   \textcolor{comment}{// It's important to remember that we're in a completely different thread}
676   \textcolor{comment}{// than the simulator is running in.  We need to synchronize with that}
677   \textcolor{comment}{// other thread to get the packet up into ns-3.  What we will need to do}
678   \textcolor{comment}{// is to schedule a method to deal with the packet using the multithreaded}
679   \textcolor{comment}{// simulator we are most certainly running.  However, I just said it -- we}
680   \textcolor{comment}{// are talking about two threads here, so it is very, very dangerous to do}
681   \textcolor{comment}{// any kind of reference counting on a shared object.  Just don't do it.}
682   \textcolor{comment}{// So what we're going to do is pass the buffer allocated on the heap}
683   \textcolor{comment}{// into the ns-3 context thread where it will create the packet.}
684   \textcolor{comment}{//}
685 
686   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"TapBridge::ReadCallback(): Received packet on node "} << 
      \hyperlink{classns3_1_1TapBridge_a2176c6e2dba8e66c1dc45145cb54d395}{m\_nodeId});
687   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"TapBridge::ReadCallback(): Scheduling handler"});
688   \hyperlink{classns3_1_1Simulator_a86dbaef45a15a42365d7d2ae550449f6}{Simulator::ScheduleWithContext} (\hyperlink{classns3_1_1TapBridge_a2176c6e2dba8e66c1dc45145cb54d395}{m\_nodeId}, 
      \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (0.0), \hyperlink{group__makeeventfnptr_ga289a28a2497c18a9bd299e5e2014094b}{MakeEvent} (&\hyperlink{classns3_1_1TapBridge_ab4390af3653278cc4ea265d3c7f4de15}{TapBridge::ForwardToBridgedDevice}
      , \textcolor{keyword}{this}, buf, len));
689 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 20




Here is the caller graph for this function\+:
% FIG 21


\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Receive\+From\+Bridged\+Device@{Receive\+From\+Bridged\+Device}}
\index{Receive\+From\+Bridged\+Device@{Receive\+From\+Bridged\+Device}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Receive\+From\+Bridged\+Device(\+Ptr$<$ Net\+Device $>$ device, Ptr$<$ const Packet $>$ packet, uint16\+\_\+t protocol, Address const \&src, Address const \&dst, Packet\+Type packet\+Type)}{ReceiveFromBridgedDevice(Ptr< NetDevice > device, Ptr< const Packet > packet, uint16_t protocol, Address const &src, Address const &dst, PacketType packetType)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Tap\+Bridge\+::\+Receive\+From\+Bridged\+Device (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{device, }
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{packet, }
\item[{uint16\+\_\+t}]{protocol, }
\item[{{\bf Address} const \&}]{src, }
\item[{{\bf Address} const \&}]{dst, }
\item[{{\bf Packet\+Type}}]{packet\+Type}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classns3_1_1TapBridge_ac065f518a2c18292b88609f8500a61bb}{}\label{classns3_1_1TapBridge_ac065f518a2c18292b88609f8500a61bb}
Receives a packet from a bridged Device 
\begin{DoxyParams}{Parameters}
{\em device} & the originating port \\
\hline
{\em packet} & the received packet \\
\hline
{\em protocol} & the packet protocol (e.\+g., Ethertype) \\
\hline
{\em src} & the packet source \\
\hline
{\em dst} & the packet destination \\
\hline
{\em packet\+Type} & the packet type (e.\+g., host, broadcast, etc.) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success 
\end{DoxyReturn}

\begin{DoxyCode}
936 \{
937   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (device << packet << protocol << src << dst << packetType);
938   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (device == \hyperlink{classns3_1_1TapBridge_ac4ba97368116b628d632d318d5562420}{m\_bridgedDevice}, \textcolor{stringliteral}{"TapBridge::SetBridgedDevice: 
       Received packet from unexpected device"});
939   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Packet UID is "} << packet->GetUid ());
940 
941   \textcolor{comment}{//}
942   \textcolor{comment}{// There are three operating modes for the TapBridge}
943   \textcolor{comment}{//}
944   \textcolor{comment}{// CONFIGURE\_LOCAL means that ns-3 will create and configure a tap device}
945   \textcolor{comment}{// and we are expected to use it.  The tap device and the ns-3 net device}
946   \textcolor{comment}{// will have the same MAC address by definition.}
947   \textcolor{comment}{//}
948   \textcolor{comment}{// USE\_LOCAL mode tells us that we have got to USE a pre-created tap device}
949   \textcolor{comment}{// that will have a different MAC address from the ns-3 net device.  In this}
950   \textcolor{comment}{// case we will be spoofing the MAC address of a received packet to match}
951   \textcolor{comment}{// the single allowed address on the Linux side.}
952   \textcolor{comment}{//}
953   \textcolor{comment}{// USE\_BRIDGE mode tells us that we are logically extending a Linux bridge}
954   \textcolor{comment}{// on which lies our tap device.}
955   \textcolor{comment}{//}
956 
957   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TapBridge_aaae30bc9d5dd36e3a4d569cf9bcf40eb}{m\_mode} == \hyperlink{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618daf2d0f6c8152d38e9400b2d9fd35f02a3}{CONFIGURE\_LOCAL} && packetType == 
      \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2a60c00fab4286dd2903e2b197a9f8c6c8}{PACKET\_OTHERHOST})
958     \{
959       \textcolor{comment}{//}
960       \textcolor{comment}{// We hooked the promiscuous mode protocol handler so we could get the }
961       \textcolor{comment}{// destination address of the actual packet.  This means we will be }
962       \textcolor{comment}{// getting PACKET\_OTHERHOST packets (not broadcast, not multicast, not }
963       \textcolor{comment}{// unicast to the ns-3 net device, but to some other address).  In }
964       \textcolor{comment}{// CONFIGURE\_LOCAL mode we are not interested in these packets since they }
965       \textcolor{comment}{// don't refer to the single MAC address shared by the ns-3 device and }
966       \textcolor{comment}{// the TAP device.  If, however, we are in USE\_LOCAL or USE\_BRIDGE mode, }
967       \textcolor{comment}{// we want to act like a bridge and forward these PACKET\_OTHERHOST }
968       \textcolor{comment}{// packets.}
969       \textcolor{comment}{//}
970       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
971     \}
972 
973   Mac48Address \hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from} = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (src);
974   Mac48Address to = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (dst);
975 
976   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = packet->Copy ();
977   EthernetHeader header = EthernetHeader (\textcolor{keyword}{false});
978   header.SetSource (from);
979   header.SetDestination (to);
980 
981   header.SetLengthType (protocol);
982   p->AddHeader (header);
983 
984   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Writing packet to Linux host"});
985   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Pkt source is "} << header.GetSource ());
986   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Pkt destination is "} << header.GetDestination ());
987   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Pkt LengthType is "} << header.GetLengthType ());
988   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Pkt size is "} << p->GetSize ());
989 
990   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (p->GetSize () <= 65536, \textcolor{stringliteral}{"TapBridge::ReceiveFromBridgedDevice: Packet too big 
      "} << p->GetSize ());
991   p->CopyData (\hyperlink{classns3_1_1TapBridge_a32b939096e18f39f76a86401d182cda5}{m\_packetBuffer}, p->GetSize ());
992 
993   uint32\_t bytesWritten = write (\hyperlink{classns3_1_1TapBridge_a52d87d41aa840377feebe63b5c5f2f3c}{m\_sock}, \hyperlink{classns3_1_1TapBridge_a32b939096e18f39f76a86401d182cda5}{m\_packetBuffer}, p->GetSize ());
994   \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (bytesWritten != p->GetSize (), \textcolor{stringliteral}{"TapBridge::ReceiveFromBridgedDevice():
       Write error."});
995 
996   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"End of receive packet handling on node "} << \hyperlink{classns3_1_1TapBridge_aab85ad5d27b8de91e7a02e8d8ee4332e}{m\_node}->
      \hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} ());
997   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
998 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 22




Here is the caller graph for this function\+:
% FIG 23


\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Send@{Send}}
\index{Send@{Send}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Send(\+Ptr$<$ Packet $>$ packet, const Address \&dest, uint16\+\_\+t protocol\+Number)}{Send(Ptr< Packet > packet, const Address &dest, uint16_t protocolNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Tap\+Bridge\+::\+Send (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{const {\bf Address} \&}]{dest, }
\item[{uint16\+\_\+t}]{protocol\+Number}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TapBridge_a3273f1c6353f38dea443e2abad4c3d21}{}\label{classns3_1_1TapBridge_a3273f1c6353f38dea443e2abad4c3d21}

\begin{DoxyParams}{Parameters}
{\em packet} & packet sent from above down to Network Device \\
\hline
{\em dest} & mac address of the destination (already resolved) \\
\hline
{\em protocol\+Number} & identifies the type of payload contained in this packet. Used to call the right L3\+Protocol when the packet is received.\\
\hline
\end{DoxyParams}
Called from higher layer to send packet into Network Device to the specified destination \hyperlink{classns3_1_1Address}{Address}

\begin{DoxyReturn}{Returns}
whether the Send operation succeeded 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a59f41afb0fe8951bb94d5739cbe6ee7d}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1140 \{
1141   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (packet << dst << protocol);
1142   \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"TapBridge::Send: You may not call Send on a TapBridge directly"});
1143   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1144 \}
\end{DoxyCode}
\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Send\+From@{Send\+From}}
\index{Send\+From@{Send\+From}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Send\+From(\+Ptr$<$ Packet $>$ packet, const Address \&source, const Address \&dest, uint16\+\_\+t protocol\+Number)}{SendFrom(Ptr< Packet > packet, const Address &source, const Address &dest, uint16_t protocolNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Tap\+Bridge\+::\+Send\+From (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{const {\bf Address} \&}]{source, }
\item[{const {\bf Address} \&}]{dest, }
\item[{uint16\+\_\+t}]{protocol\+Number}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TapBridge_a6e6cf6042cc65529a8591e0d01518153}{}\label{classns3_1_1TapBridge_a6e6cf6042cc65529a8591e0d01518153}

\begin{DoxyParams}{Parameters}
{\em packet} & packet sent from above down to Network Device \\
\hline
{\em source} & source mac address (so called \char`\"{}\+M\+A\+C spoofing\char`\"{}) \\
\hline
{\em dest} & mac address of the destination (already resolved) \\
\hline
{\em protocol\+Number} & identifies the type of payload contained in this packet. Used to call the right L3\+Protocol when the packet is received.\\
\hline
\end{DoxyParams}
Called from higher layer to send packet into Network Device with the specified source and destination Addresses.

\begin{DoxyReturn}{Returns}
whether the Send operation succeeded 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a19d55a4746c1ae584bf7da69959a885b}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1148 \{
1149   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (packet << src << dst << protocol);
1150   \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"TapBridge::Send: You may not call SendFrom on a TapBridge directly"});
1151   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1152 \}
\end{DoxyCode}
\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Set\+Address@{Set\+Address}}
\index{Set\+Address@{Set\+Address}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Set\+Address(\+Address address)}{SetAddress(Address address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tap\+Bridge\+::\+Set\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TapBridge_a3d3f981cb1ace70ecfa34744108ff2b7}{}\label{classns3_1_1TapBridge_a3d3f981cb1ace70ecfa34744108ff2b7}
Set the address of this interface 
\begin{DoxyParams}{Parameters}
{\em address} & address to set \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1NetDevice_ab56dc36bc0547471ab3210eda60ee76c}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1023 \{
1024   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (address);
1025   \hyperlink{classns3_1_1TapBridge_a70e331b3deb893d7aa013ef44a7ee4a7}{m\_address} = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (address);
1026 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 24


\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Set\+Bridged\+Net\+Device@{Set\+Bridged\+Net\+Device}}
\index{Set\+Bridged\+Net\+Device@{Set\+Bridged\+Net\+Device}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Set\+Bridged\+Net\+Device(\+Ptr$<$ Net\+Device $>$ bridged\+Device)}{SetBridgedNetDevice(Ptr< NetDevice > bridgedDevice)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tap\+Bridge\+::\+Set\+Bridged\+Net\+Device (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{bridged\+Device}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TapBridge_a0889ae6308758421297e74cb4be9af5b}{}\label{classns3_1_1TapBridge_a0889ae6308758421297e74cb4be9af5b}


Set the ns-\/3 net device to bridge. 

This method tells the bridge which ns-\/3 net device it should use to connect the simulation side of the bridge.


\begin{DoxyParams}{Parameters}
{\em bridged\+Device} & device to set\\
\hline
\end{DoxyParams}
\begin{DoxyAttention}{Attention}
The ns-\/3 net device that is being set as the device must have an an IP address assigned to it before the simulation is run. This address will be used to set the hardware address of the host Linux device. 
\end{DoxyAttention}

\begin{DoxyCode}
889 \{
890   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (bridgedDevice);
891 
892   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\hyperlink{classns3_1_1TapBridge_aab85ad5d27b8de91e7a02e8d8ee4332e}{m\_node} != 0, \textcolor{stringliteral}{"TapBridge::SetBridgedDevice:  Bridge not installed in a
       node"});
893   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (bridgedDevice != \textcolor{keyword}{this}, \textcolor{stringliteral}{"TapBridge::SetBridgedDevice:  Cannot bridge to self"})
      ;
894   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\hyperlink{classns3_1_1TapBridge_ac4ba97368116b628d632d318d5562420}{m\_bridgedDevice} == 0, \textcolor{stringliteral}{"TapBridge::SetBridgedDevice:  Already
       bridged"});
895 
896   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1Mac48Address_a55cc1e3c6aa63fd1a4f8f7d9be4ae182}{Mac48Address::IsMatchingType} (bridgedDevice->GetAddress ()))
897     \{
898       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"TapBridge::SetBridgedDevice: Device does not support eui 48 addresses:
       cannot be added to bridge."});
899     \}
900 
901   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TapBridge_aaae30bc9d5dd36e3a4d569cf9bcf40eb}{m\_mode} == \hyperlink{classns3_1_1TapBridge_acac8d3ebe259ddfa9cd369515f04618da33daa0eda93d6ec20fc491d7c440fc8d}{USE\_BRIDGE} && !bridgedDevice->SupportsSendFrom ())
902     \{
903       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"TapBridge::SetBridgedDevice: Device does not support SendFrom: cannot
       be added to bridge."});
904     \}
905 
906   \textcolor{comment}{//}
907   \textcolor{comment}{// We need to disconnect the bridged device from the internet stack on our}
908   \textcolor{comment}{// node to ensure that only one stack responds to packets inbound over the}
909   \textcolor{comment}{// bridged device.  That one stack lives outside ns-3 so we just blatantly}
910   \textcolor{comment}{// steal the device callbacks.}
911   \textcolor{comment}{//}
912   \textcolor{comment}{// N.B This can be undone if someone does a RegisterProtocolHandler later }
913   \textcolor{comment}{// on this node.}
914   \textcolor{comment}{//}
915   bridgedDevice->SetReceiveCallback (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1TapBridge_a1837b0aa11c479938664a05cc5794c5f}{TapBridge::DiscardFromBridgedDevice}, \textcolor{keyword}{this}));
916   bridgedDevice->SetPromiscReceiveCallback (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1TapBridge_ac065f518a2c18292b88609f8500a61bb}{TapBridge::ReceiveFromBridgedDevice}, \textcolor{keyword}{this}));
917   \hyperlink{classns3_1_1TapBridge_ac4ba97368116b628d632d318d5562420}{m\_bridgedDevice} = bridgedDevice;
918 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 25


\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Set\+If\+Index@{Set\+If\+Index}}
\index{Set\+If\+Index@{Set\+If\+Index}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Set\+If\+Index(const uint32\+\_\+t index)}{SetIfIndex(const uint32_t index)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tap\+Bridge\+::\+Set\+If\+Index (
\begin{DoxyParamCaption}
\item[{const uint32\+\_\+t}]{index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TapBridge_aab34bfe78791ad5401d23e21b7cff850}{}\label{classns3_1_1TapBridge_aab34bfe78791ad5401d23e21b7cff850}

\begin{DoxyParams}{Parameters}
{\em index} & if\+Index of the device \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1NetDevice_a2e1ac6c1189cd565420305d85a193fb8}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1002 \{
1003   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
1004   \hyperlink{classns3_1_1TapBridge_a5de0f6399c095a680978c72bcd90b228}{m\_ifIndex} = index;
1005 \}
\end{DoxyCode}
\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Set\+Mode@{Set\+Mode}}
\index{Set\+Mode@{Set\+Mode}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Set\+Mode(\+Tap\+Bridge\+::\+Mode mode)}{SetMode(TapBridge::Mode mode)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tap\+Bridge\+::\+Set\+Mode (
\begin{DoxyParamCaption}
\item[{{\bf Tap\+Bridge\+::\+Mode}}]{mode}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TapBridge_a435d654af7e7970c365d14b4a5dc3044}{}\label{classns3_1_1TapBridge_a435d654af7e7970c365d14b4a5dc3044}
Set the operating mode of this device.


\begin{DoxyParams}{Parameters}
{\em mode} & The operating mode of this device. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1037 \{
1038   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (mode);
1039   \hyperlink{classns3_1_1TapBridge_aaae30bc9d5dd36e3a4d569cf9bcf40eb}{m\_mode} = mode;
1040 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 26


\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Set\+Mtu@{Set\+Mtu}}
\index{Set\+Mtu@{Set\+Mtu}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Set\+Mtu(const uint16\+\_\+t mtu)}{SetMtu(const uint16_t mtu)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Tap\+Bridge\+::\+Set\+Mtu (
\begin{DoxyParamCaption}
\item[{const uint16\+\_\+t}]{mtu}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TapBridge_af41aca6484197a8a139b8db0fbcb6b79}{}\label{classns3_1_1TapBridge_af41aca6484197a8a139b8db0fbcb6b79}

\begin{DoxyParams}{Parameters}
{\em mtu} & M\+TU value, in bytes, to set for the device \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether the M\+TU value was within legal bounds
\end{DoxyReturn}
Override for default M\+TU defined on a per-\/type basis. 

Implements \hyperlink{classns3_1_1NetDevice_a2ba4956d45cde68eab3cbdd6ede06df0}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1051 \{
1052   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
1053   \hyperlink{classns3_1_1TapBridge_a8aca7b3808d23f6a5f8e6c212c0af618}{m\_mtu} = mtu;
1054   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1055 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 27


\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Set\+Node@{Set\+Node}}
\index{Set\+Node@{Set\+Node}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Set\+Node(\+Ptr$<$ Node $>$ node)}{SetNode(Ptr< Node > node)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tap\+Bridge\+::\+Set\+Node (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TapBridge_a6e94660e371655a2c6c6f00b3f1e44c2}{}\label{classns3_1_1TapBridge_a6e94660e371655a2c6c6f00b3f1e44c2}

\begin{DoxyParams}{Parameters}
{\em node} & the node associated to this netdevice.\\
\hline
\end{DoxyParams}
This method is called from \hyperlink{classns3_1_1Node_a42ff83ee1d5d1649c770d3f5b62375de}{ns3\+::\+Node\+::\+Add\+Device}. 

Implements \hyperlink{classns3_1_1NetDevice_a3ae520ae06e93b957f0f56f113319a08}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1163 \{
1164   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
1165   \hyperlink{classns3_1_1TapBridge_aab85ad5d27b8de91e7a02e8d8ee4332e}{m\_node} = node;
1166 \}
\end{DoxyCode}
\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Set\+Promisc\+Receive\+Callback@{Set\+Promisc\+Receive\+Callback}}
\index{Set\+Promisc\+Receive\+Callback@{Set\+Promisc\+Receive\+Callback}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Set\+Promisc\+Receive\+Callback(\+Net\+Device\+::\+Promisc\+Receive\+Callback cb)}{SetPromiscReceiveCallback(NetDevice::PromiscReceiveCallback cb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tap\+Bridge\+::\+Set\+Promisc\+Receive\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Net\+Device\+::\+Promisc\+Receive\+Callback}}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TapBridge_a6621dcd7bfce6367c3451b457fa8145c}{}\label{classns3_1_1TapBridge_a6621dcd7bfce6367c3451b457fa8145c}

\begin{DoxyParams}{Parameters}
{\em cb} & callback to invoke whenever a packet has been received in promiscuous mode and must be forwarded to the higher layers.\\
\hline
\end{DoxyParams}
Enables netdevice promiscuous mode and sets the callback that will handle promiscuous mode packets. Note, promiscuous mode packets means {\itshape all} packets, including those packets that can be sensed by the netdevice but which are intended to be received by other hosts. 

Implements \hyperlink{classns3_1_1NetDevice_a3968946bdbb74d47d7b13612baad7d6d}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1184 \{
1185   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
1186   \hyperlink{classns3_1_1TapBridge_a4a1f6dcd199836a8bff03691a240af4a}{m\_promiscRxCallback} = cb;
1187 \}
\end{DoxyCode}
\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Set\+Receive\+Callback@{Set\+Receive\+Callback}}
\index{Set\+Receive\+Callback@{Set\+Receive\+Callback}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Set\+Receive\+Callback(\+Net\+Device\+::\+Receive\+Callback cb)}{SetReceiveCallback(NetDevice::ReceiveCallback cb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tap\+Bridge\+::\+Set\+Receive\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Net\+Device\+::\+Receive\+Callback}}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TapBridge_a44cd4720cc3fcc1a41536697e08320ac}{}\label{classns3_1_1TapBridge_a44cd4720cc3fcc1a41536697e08320ac}

\begin{DoxyParams}{Parameters}
{\em cb} & callback to invoke whenever a packet has been received and must be forwarded to the higher layers.\\
\hline
\end{DoxyParams}
Set the callback to be used to notify higher layers when a packet has been received. 

Implements \hyperlink{classns3_1_1NetDevice_ac63e4d5668e421fec4b5d37f32e7dd18}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1177 \{
1178   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
1179   \hyperlink{classns3_1_1TapBridge_a6e0e402ed4fc1b67796220bf915cfbae}{m\_rxCallback} = cb;
1180 \}
\end{DoxyCode}
\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Start@{Start}}
\index{Start@{Start}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Start(\+Time t\+Start)}{Start(Time tStart)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tap\+Bridge\+::\+Start (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{t\+Start}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TapBridge_a729662b8454d1c8202add94ebf389bb9}{}\label{classns3_1_1TapBridge_a729662b8454d1c8202add94ebf389bb9}


Set a start time for the device. 

The tap bridge consumes a non-\/trivial amount of time to start. It starts up in the context of a scheduled event to ensure that all configuration has been completed before extracting the configuration (IP addresses, etc.) In order to allow a more reasonable start-\/up sequence than a thundering herd of devices, the time at which each device starts is also configurable bot via the Attribute system and via this call.


\begin{DoxyParams}{Parameters}
{\em t\+Start} & the start time \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
174 \{
175   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (tStart);
176 
177   \textcolor{comment}{//}
178   \textcolor{comment}{// Cancel any pending start event and schedule a new one at some relative time in the future.}
179   \textcolor{comment}{//}
180   \hyperlink{classns3_1_1Simulator_a1b903a62d6117ef28f7ba3c6500689bf}{Simulator::Cancel} (\hyperlink{classns3_1_1TapBridge_ad3b52854cf5e27c04fcbf62030e725ec}{m\_startEvent});
181   \hyperlink{classns3_1_1TapBridge_ad3b52854cf5e27c04fcbf62030e725ec}{m\_startEvent} = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (tStart, &
      \hyperlink{classns3_1_1TapBridge_a15e7ac0069167eb1e1d63b3cefe86002}{TapBridge::StartTapDevice}, \textcolor{keyword}{this});
182 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 28




Here is the caller graph for this function\+:
% FIG 29


\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Start\+Tap\+Device@{Start\+Tap\+Device}}
\index{Start\+Tap\+Device@{Start\+Tap\+Device}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Start\+Tap\+Device(void)}{StartTapDevice(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tap\+Bridge\+::\+Start\+Tap\+Device (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_a15e7ac0069167eb1e1d63b3cefe86002}{}\label{classns3_1_1TapBridge_a15e7ac0069167eb1e1d63b3cefe86002}
Spin up the device 
\begin{DoxyCode}
197 \{
198   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
199 
200   \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (\hyperlink{classns3_1_1TapBridge_a52d87d41aa840377feebe63b5c5f2f3c}{m\_sock} != -1, \textcolor{stringliteral}{"TapBridge::StartTapDevice(): Tap is already started"}
      );
201 
202   \textcolor{comment}{//}
203   \textcolor{comment}{// A similar story exists for the node ID.  We can't just naively do a}
204   \textcolor{comment}{// GetNode ()->GetId () since GetNode is going to give us a Ptr<Node> which}
205   \textcolor{comment}{// is reference counted.  We need to stash away the node ID for use in the}
206   \textcolor{comment}{// read thread.}
207   \textcolor{comment}{//}
208   \hyperlink{classns3_1_1TapBridge_a2176c6e2dba8e66c1dc45145cb54d395}{m\_nodeId} = \hyperlink{classns3_1_1TapBridge_ae200e9184e81dcad678e1016ff0375c6}{GetNode} ()->\hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} ();
209 
210   \textcolor{comment}{//}
211   \textcolor{comment}{// Spin up the tap bridge and start receiving packets.}
212   \textcolor{comment}{//}
213   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Creating tap device"});
214 
215   \textcolor{comment}{//}
216   \textcolor{comment}{// Call out to a separate process running as suid root in order to get the }
217   \textcolor{comment}{// tap device allocated and set up.  We do this to avoid having the entire }
218   \textcolor{comment}{// simulation running as root.  If this method returns, we'll have a socket}
219   \textcolor{comment}{// waiting for us in m\_sock that we can use to talk to the newly created }
220   \textcolor{comment}{// tap device.}
221   \textcolor{comment}{//}
222   \hyperlink{classns3_1_1TapBridge_ab8458214cc15eb045fa1048e36275432}{CreateTap} ();
223 
224   \textcolor{comment}{// Declare the link up}
225   \hyperlink{classns3_1_1TapBridge_a845a502163a985d26b2b70c36493d945}{NotifyLinkUp} ();
226 
227   \textcolor{comment}{//}
228   \textcolor{comment}{// Now spin up a read thread to read packets from the tap device.}
229   \textcolor{comment}{//}
230   \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (\hyperlink{classns3_1_1TapBridge_a8a26ef8616fb40272a4bab45ec84f563}{m\_fdReader} != 0,\textcolor{stringliteral}{"TapBridge::StartTapDevice(): Receive thread is
       already running"});
231   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Spinning up read thread"});
232 
233   \hyperlink{classns3_1_1TapBridge_a8a26ef8616fb40272a4bab45ec84f563}{m\_fdReader} = Create<TapBridgeFdReader> ();
234   \hyperlink{classns3_1_1TapBridge_a8a26ef8616fb40272a4bab45ec84f563}{m\_fdReader}->Start (\hyperlink{classns3_1_1TapBridge_a52d87d41aa840377feebe63b5c5f2f3c}{m\_sock}, \hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1TapBridge_a8cf7414db717096f2b3a2a0e7026ed8f}{TapBridge::ReadCallback}, \textcolor{keyword}{this}));
235 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 30




Here is the caller graph for this function\+:
% FIG 31


\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Stop@{Stop}}
\index{Stop@{Stop}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Stop(\+Time t\+Stop)}{Stop(Time tStop)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tap\+Bridge\+::\+Stop (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{t\+Stop}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TapBridge_ab94057d00c75768838fe783eaff278e3}{}\label{classns3_1_1TapBridge_ab94057d00c75768838fe783eaff278e3}
Set a stop time for the device.


\begin{DoxyParams}{Parameters}
{\em t\+Stop} & the stop time\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1TapBridge_a729662b8454d1c8202add94ebf389bb9}{Tap\+Bridge\+::\+Start} 
\end{DoxySeeAlso}

\begin{DoxyCode}
186 \{
187   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (tStop);
188   \textcolor{comment}{//}
189   \textcolor{comment}{// Cancel any pending stop event and schedule a new one at some relative time in the future.}
190   \textcolor{comment}{//}
191   \hyperlink{classns3_1_1Simulator_a1b903a62d6117ef28f7ba3c6500689bf}{Simulator::Cancel} (\hyperlink{classns3_1_1TapBridge_aab982f716ac96e92e054c82334a198c4}{m\_stopEvent});
192   \hyperlink{classns3_1_1TapBridge_ad3b52854cf5e27c04fcbf62030e725ec}{m\_startEvent} = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (tStop, &
      \hyperlink{classns3_1_1TapBridge_a0daf7557c160441a6bf45b4915bc93c3}{TapBridge::StopTapDevice}, \textcolor{keyword}{this});
193 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 32


\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Stop\+Tap\+Device@{Stop\+Tap\+Device}}
\index{Stop\+Tap\+Device@{Stop\+Tap\+Device}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Stop\+Tap\+Device(void)}{StopTapDevice(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tap\+Bridge\+::\+Stop\+Tap\+Device (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_a0daf7557c160441a6bf45b4915bc93c3}{}\label{classns3_1_1TapBridge_a0daf7557c160441a6bf45b4915bc93c3}
Tear down the device 
\begin{DoxyCode}
239 \{
240   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
241 
242   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TapBridge_a8a26ef8616fb40272a4bab45ec84f563}{m\_fdReader} != 0)
243     \{
244       \hyperlink{classns3_1_1TapBridge_a8a26ef8616fb40272a4bab45ec84f563}{m\_fdReader}->Stop ();
245       \hyperlink{classns3_1_1TapBridge_a8a26ef8616fb40272a4bab45ec84f563}{m\_fdReader} = 0;
246     \}
247 
248   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TapBridge_a52d87d41aa840377feebe63b5c5f2f3c}{m\_sock} != -1)
249     \{
250       close (\hyperlink{classns3_1_1TapBridge_a52d87d41aa840377feebe63b5c5f2f3c}{m\_sock});
251       \hyperlink{classns3_1_1TapBridge_a52d87d41aa840377feebe63b5c5f2f3c}{m\_sock} = -1;
252     \}
253 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 33


\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!Supports\+Send\+From@{Supports\+Send\+From}}
\index{Supports\+Send\+From@{Supports\+Send\+From}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{Supports\+Send\+From() const }{SupportsSendFrom() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Tap\+Bridge\+::\+Supports\+Send\+From (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TapBridge_a56859ceec9c6a575db34bf6acfd510f8}{}\label{classns3_1_1TapBridge_a56859ceec9c6a575db34bf6acfd510f8}
\begin{DoxyReturn}{Returns}
true if this interface supports a bridging mode, false otherwise. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a04793d220b54c40e110ebf86dae5b25c}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1191 \{
1192   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
1193   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1194 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!m\+\_\+address@{m\+\_\+address}}
\index{m\+\_\+address@{m\+\_\+address}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{m\+\_\+address}{m_address}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Mac48\+Address} ns3\+::\+Tap\+Bridge\+::m\+\_\+address\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_a70e331b3deb893d7aa013ef44a7ee4a7}{}\label{classns3_1_1TapBridge_a70e331b3deb893d7aa013ef44a7ee4a7}
The (unused) M\+AC address of the \hyperlink{classns3_1_1TapBridge}{Tap\+Bridge} net device. Since the \hyperlink{classns3_1_1TapBridge}{Tap\+Bridge} is implemented as a ns-\/3 net device, it is required to implement certain functionality. In this case, the \hyperlink{classns3_1_1TapBridge}{Tap\+Bridge} is automatically assigned a M\+AC address, but it is not used. \index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!m\+\_\+bridged\+Device@{m\+\_\+bridged\+Device}}
\index{m\+\_\+bridged\+Device@{m\+\_\+bridged\+Device}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{m\+\_\+bridged\+Device}{m_bridgedDevice}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Net\+Device}$>$ ns3\+::\+Tap\+Bridge\+::m\+\_\+bridged\+Device\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_ac4ba97368116b628d632d318d5562420}{}\label{classns3_1_1TapBridge_ac4ba97368116b628d632d318d5562420}
The ns-\/3 net device to which we are bridging. \index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!m\+\_\+fd\+Reader@{m\+\_\+fd\+Reader}}
\index{m\+\_\+fd\+Reader@{m\+\_\+fd\+Reader}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{m\+\_\+fd\+Reader}{m_fdReader}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Tap\+Bridge\+Fd\+Reader}$>$ ns3\+::\+Tap\+Bridge\+::m\+\_\+fd\+Reader\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_a8a26ef8616fb40272a4bab45ec84f563}{}\label{classns3_1_1TapBridge_a8a26ef8616fb40272a4bab45ec84f563}
Includes the ns-\/3 read thread used to do blocking reads on the fd corresponding to the host device. \index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!m\+\_\+if\+Index@{m\+\_\+if\+Index}}
\index{m\+\_\+if\+Index@{m\+\_\+if\+Index}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{m\+\_\+if\+Index}{m_ifIndex}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Tap\+Bridge\+::m\+\_\+if\+Index\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_a5de0f6399c095a680978c72bcd90b228}{}\label{classns3_1_1TapBridge_a5de0f6399c095a680978c72bcd90b228}
The ns-\/3 interface index of this \hyperlink{classns3_1_1TapBridge}{Tap\+Bridge} net device. \index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!m\+\_\+link\+Change\+Callbacks@{m\+\_\+link\+Change\+Callbacks}}
\index{m\+\_\+link\+Change\+Callbacks@{m\+\_\+link\+Change\+Callbacks}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{m\+\_\+link\+Change\+Callbacks}{m_linkChangeCallbacks}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback} ns3\+::\+Tap\+Bridge\+::m\+\_\+link\+Change\+Callbacks\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_a3c5c9f53b15fc47d55420f4905297a06}{}\label{classns3_1_1TapBridge_a3c5c9f53b15fc47d55420f4905297a06}
Callbacks to fire if the link changes state (up or down). \index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!m\+\_\+link\+Up@{m\+\_\+link\+Up}}
\index{m\+\_\+link\+Up@{m\+\_\+link\+Up}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{m\+\_\+link\+Up}{m_linkUp}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Tap\+Bridge\+::m\+\_\+link\+Up\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_a335b96cae7f60f5d5bcf60234af96339}{}\label{classns3_1_1TapBridge_a335b96cae7f60f5d5bcf60234af96339}
Flag indicating whether or not the link is up. In this case, whether or not ns-\/3 is connected to the underlying T\+AP device with a file descriptor. \index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!m\+\_\+mode@{m\+\_\+mode}}
\index{m\+\_\+mode@{m\+\_\+mode}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{m\+\_\+mode}{m_mode}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Mode} ns3\+::\+Tap\+Bridge\+::m\+\_\+mode\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_aaae30bc9d5dd36e3a4d569cf9bcf40eb}{}\label{classns3_1_1TapBridge_aaae30bc9d5dd36e3a4d569cf9bcf40eb}
The operating mode of the bridge. Tells basically who creates and configures the underlying network tap. \index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!m\+\_\+mtu@{m\+\_\+mtu}}
\index{m\+\_\+mtu@{m\+\_\+mtu}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{m\+\_\+mtu}{m_mtu}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Tap\+Bridge\+::m\+\_\+mtu\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_a8aca7b3808d23f6a5f8e6c212c0af618}{}\label{classns3_1_1TapBridge_a8aca7b3808d23f6a5f8e6c212c0af618}
The common mtu to use for the net devices \index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!m\+\_\+node@{m\+\_\+node}}
\index{m\+\_\+node@{m\+\_\+node}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{m\+\_\+node}{m_node}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Node}$>$ ns3\+::\+Tap\+Bridge\+::m\+\_\+node\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_aab85ad5d27b8de91e7a02e8d8ee4332e}{}\label{classns3_1_1TapBridge_aab85ad5d27b8de91e7a02e8d8ee4332e}
Pointer to the (ghost) \hyperlink{classns3_1_1Node}{Node} to which we are connected. \index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!m\+\_\+node\+Id@{m\+\_\+node\+Id}}
\index{m\+\_\+node\+Id@{m\+\_\+node\+Id}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{m\+\_\+node\+Id}{m_nodeId}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Tap\+Bridge\+::m\+\_\+node\+Id\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_a2176c6e2dba8e66c1dc45145cb54d395}{}\label{classns3_1_1TapBridge_a2176c6e2dba8e66c1dc45145cb54d395}
a copy of the node id so the read thread doesn\textquotesingle{}t have to \hyperlink{classns3_1_1TapBridge_ae200e9184e81dcad678e1016ff0375c6}{Get\+Node()} in in order to find the node ID. Thread unsafe reference counting in multithreaded apps is not a good thing. \index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!m\+\_\+ns3\+Address\+Rewritten@{m\+\_\+ns3\+Address\+Rewritten}}
\index{m\+\_\+ns3\+Address\+Rewritten@{m\+\_\+ns3\+Address\+Rewritten}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{m\+\_\+ns3\+Address\+Rewritten}{m_ns3AddressRewritten}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Tap\+Bridge\+::m\+\_\+ns3\+Address\+Rewritten\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_a3200dc6b4b46d2f0fb13c867fcb0d118}{}\label{classns3_1_1TapBridge_a3200dc6b4b46d2f0fb13c867fcb0d118}
Whether the M\+AC address of the underlying ns-\/3 device has already been rewritten is stored in this variable (for Use\+Local/\+Use\+Bridge mode only). \index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!m\+\_\+packet\+Buffer@{m\+\_\+packet\+Buffer}}
\index{m\+\_\+packet\+Buffer@{m\+\_\+packet\+Buffer}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{m\+\_\+packet\+Buffer}{m_packetBuffer}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t$\ast$ ns3\+::\+Tap\+Bridge\+::m\+\_\+packet\+Buffer\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_a32b939096e18f39f76a86401d182cda5}{}\label{classns3_1_1TapBridge_a32b939096e18f39f76a86401d182cda5}
A 64K buffer to hold packet data while it is being sent. \index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!m\+\_\+promisc\+Rx\+Callback@{m\+\_\+promisc\+Rx\+Callback}}
\index{m\+\_\+promisc\+Rx\+Callback@{m\+\_\+promisc\+Rx\+Callback}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{m\+\_\+promisc\+Rx\+Callback}{m_promiscRxCallback}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Net\+Device\+::\+Promisc\+Receive\+Callback} ns3\+::\+Tap\+Bridge\+::m\+\_\+promisc\+Rx\+Callback\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_a4a1f6dcd199836a8bff03691a240af4a}{}\label{classns3_1_1TapBridge_a4a1f6dcd199836a8bff03691a240af4a}
\hyperlink{classns3_1_1Callback}{Callback} used to hook the promiscuous packet receive callback of the \hyperlink{classns3_1_1TapBridge}{Tap\+Bridge} ns-\/3 net device. This is never called, and therefore no packets will ever be received forwarded up the IP stack on the ghost node through this device.

Note that we intercept the similar callback in the bridged device in order to do the actual bridging between the bridged ns-\/3 net device and the \hyperlink{classns3_1_1Tap}{Tap} device on the host. \index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!m\+\_\+rx\+Callback@{m\+\_\+rx\+Callback}}
\index{m\+\_\+rx\+Callback@{m\+\_\+rx\+Callback}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{m\+\_\+rx\+Callback}{m_rxCallback}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Net\+Device\+::\+Receive\+Callback} ns3\+::\+Tap\+Bridge\+::m\+\_\+rx\+Callback\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_a6e0e402ed4fc1b67796220bf915cfbae}{}\label{classns3_1_1TapBridge_a6e0e402ed4fc1b67796220bf915cfbae}
\hyperlink{classns3_1_1Callback}{Callback} used to hook the standard packet receive callback of the \hyperlink{classns3_1_1TapBridge}{Tap\+Bridge} ns-\/3 net device. This is never called, and therefore no packets will ever be received forwarded up the IP stack on the ghost node through this device. \index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!m\+\_\+sock@{m\+\_\+sock}}
\index{m\+\_\+sock@{m\+\_\+sock}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{m\+\_\+sock}{m_sock}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Tap\+Bridge\+::m\+\_\+sock\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_a52d87d41aa840377feebe63b5c5f2f3c}{}\label{classns3_1_1TapBridge_a52d87d41aa840377feebe63b5c5f2f3c}
The socket (actually interpreted as fd) to use to talk to the \hyperlink{classns3_1_1Tap}{Tap} device on the real internet host. \index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!m\+\_\+start\+Event@{m\+\_\+start\+Event}}
\index{m\+\_\+start\+Event@{m\+\_\+start\+Event}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{m\+\_\+start\+Event}{m_startEvent}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Event\+Id} ns3\+::\+Tap\+Bridge\+::m\+\_\+start\+Event\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_ad3b52854cf5e27c04fcbf62030e725ec}{}\label{classns3_1_1TapBridge_ad3b52854cf5e27c04fcbf62030e725ec}
The ID of the ns-\/3 event used to schedule the start up of the underlying host \hyperlink{classns3_1_1Tap}{Tap} device and ns-\/3 read thread. \index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!m\+\_\+stop\+Event@{m\+\_\+stop\+Event}}
\index{m\+\_\+stop\+Event@{m\+\_\+stop\+Event}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{m\+\_\+stop\+Event}{m_stopEvent}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Event\+Id} ns3\+::\+Tap\+Bridge\+::m\+\_\+stop\+Event\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_aab982f716ac96e92e054c82334a198c4}{}\label{classns3_1_1TapBridge_aab982f716ac96e92e054c82334a198c4}
The ID of the ns-\/3 event used to schedule the tear down of the underlying host \hyperlink{classns3_1_1Tap}{Tap} device and ns-\/3 read thread. \index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!m\+\_\+tap\+Device\+Name@{m\+\_\+tap\+Device\+Name}}
\index{m\+\_\+tap\+Device\+Name@{m\+\_\+tap\+Device\+Name}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{m\+\_\+tap\+Device\+Name}{m_tapDeviceName}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string ns3\+::\+Tap\+Bridge\+::m\+\_\+tap\+Device\+Name\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_af255e0f837eb4dd30c4de28448f862f6}{}\label{classns3_1_1TapBridge_af255e0f837eb4dd30c4de28448f862f6}
The name of the device to create on the host. If the device name is the empty string, we allow the host kernel to choose a name. \index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!m\+\_\+tap\+Gateway@{m\+\_\+tap\+Gateway}}
\index{m\+\_\+tap\+Gateway@{m\+\_\+tap\+Gateway}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{m\+\_\+tap\+Gateway}{m_tapGateway}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Address} ns3\+::\+Tap\+Bridge\+::m\+\_\+tap\+Gateway\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_ad90dad655607615d92822a361ac21fb1}{}\label{classns3_1_1TapBridge_ad90dad655607615d92822a361ac21fb1}
The IP address to use as the device default gateway on the host. \index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!m\+\_\+tap\+Ip@{m\+\_\+tap\+Ip}}
\index{m\+\_\+tap\+Ip@{m\+\_\+tap\+Ip}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{m\+\_\+tap\+Ip}{m_tapIp}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Address} ns3\+::\+Tap\+Bridge\+::m\+\_\+tap\+Ip\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_a8cfe2b69cef36dbf048cb9006318b41b}{}\label{classns3_1_1TapBridge_a8cfe2b69cef36dbf048cb9006318b41b}
The IP address to use as the device IP on the host. \index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!m\+\_\+tap\+Mac@{m\+\_\+tap\+Mac}}
\index{m\+\_\+tap\+Mac@{m\+\_\+tap\+Mac}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{m\+\_\+tap\+Mac}{m_tapMac}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Mac48\+Address} ns3\+::\+Tap\+Bridge\+::m\+\_\+tap\+Mac\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_afdaa87d8c5a5e249ee8d94f75183e91f}{}\label{classns3_1_1TapBridge_afdaa87d8c5a5e249ee8d94f75183e91f}
The M\+AC address to use as the hardware address on the host; only used in Use\+Local mode. This value comes from the M\+AC address assigned to the bridged ns-\/3 net device and matches the M\+AC address of the underlying network T\+AP which we configured to have the same value. \index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!m\+\_\+tap\+Netmask@{m\+\_\+tap\+Netmask}}
\index{m\+\_\+tap\+Netmask@{m\+\_\+tap\+Netmask}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{m\+\_\+tap\+Netmask}{m_tapNetmask}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Mask} ns3\+::\+Tap\+Bridge\+::m\+\_\+tap\+Netmask\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_a9374f832e2a96385651d27a5fbc7ba57}{}\label{classns3_1_1TapBridge_a9374f832e2a96385651d27a5fbc7ba57}
The network mask to assign to the device created on the host. \index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!m\+\_\+t\+Start@{m\+\_\+t\+Start}}
\index{m\+\_\+t\+Start@{m\+\_\+t\+Start}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{m\+\_\+t\+Start}{m_tStart}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Tap\+Bridge\+::m\+\_\+t\+Start\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_ad6cde3114d24223d3edf0270ce4af231}{}\label{classns3_1_1TapBridge_ad6cde3114d24223d3edf0270ce4af231}
\hyperlink{classns3_1_1Time}{Time} to start spinning up the device \index{ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}!m\+\_\+t\+Stop@{m\+\_\+t\+Stop}}
\index{m\+\_\+t\+Stop@{m\+\_\+t\+Stop}!ns3\+::\+Tap\+Bridge@{ns3\+::\+Tap\+Bridge}}
\subsubsection[{\texorpdfstring{m\+\_\+t\+Stop}{m_tStop}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Tap\+Bridge\+::m\+\_\+t\+Stop\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TapBridge_ae91102625b83c3b447f48d1798041ab8}{}\label{classns3_1_1TapBridge_ae91102625b83c3b447f48d1798041ab8}
\hyperlink{classns3_1_1Time}{Time} to start tearing down the device 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
tap-\/bridge/model/\hyperlink{tap-bridge_8h}{tap-\/bridge.\+h}\item 
tap-\/bridge/model/\hyperlink{tap-bridge_8cc}{tap-\/bridge.\+cc}\end{DoxyCompactItemize}
