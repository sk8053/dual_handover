\hypertarget{classns3_1_1PcapFile}{}\section{ns3\+:\+:Pcap\+File Class Reference}
\label{classns3_1_1PcapFile}\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}


A class representing a pcap file.  




{\ttfamily \#include $<$pcap-\/file.\+h$>$}



Collaboration diagram for ns3\+:\+:Pcap\+File\+:
% FIG 0
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader}{Pcap\+File\+Header}
\begin{DoxyCompactList}\small\item\em Pcap file header. \end{DoxyCompactList}\item 
struct \hyperlink{structns3_1_1PcapFile_1_1PcapRecordHeader}{Pcap\+Record\+Header}
\begin{DoxyCompactList}\small\item\em Pcap record header. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1PcapFile_a6bfa1cf38e6845f9d2e77e3c034ed90d}{Pcap\+File} ()
\item 
\hyperlink{classns3_1_1PcapFile_ae70ee5d4e70678f92635233e36288764}{$\sim$\+Pcap\+File} ()
\item 
bool \hyperlink{classns3_1_1PcapFile_a2e00aa080890a0c9c3e9f5bd2d6c21d5}{Fail} (void) const 
\item 
bool \hyperlink{classns3_1_1PcapFile_ad8b9cd552beb5e1c348e04c98d3daffa}{Eof} (void) const 
\item 
void \hyperlink{classns3_1_1PcapFile_a4b593422b0941d936d98635151d1d8ce}{Clear} (void)
\item 
void \hyperlink{classns3_1_1PcapFile_a064e8494e28e823d0bb4e40549f9f483}{Open} (std\+::string const \&filename, std\+::ios\+::openmode mode)
\item 
void \hyperlink{classns3_1_1PcapFile_ad3b6c28d464742ee1fa3a64628339a5b}{Close} (void)
\item 
void \hyperlink{classns3_1_1PcapFile_a80c8adea1baa66e3f730df2927b0fc9b}{Init} (uint32\+\_\+t data\+Link\+Type, uint32\+\_\+t snap\+Len=\hyperlink{classns3_1_1PcapFile_ac5fda3d19b0cd0f85b0c151c2397681b}{S\+N\+A\+P\+L\+E\+N\+\_\+\+D\+E\+F\+A\+U\+LT}, int32\+\_\+t time\+Zone\+Correction=\hyperlink{classns3_1_1PcapFile_abd695588f972dc80b0c928aeda466dc0}{Z\+O\+N\+E\+\_\+\+D\+E\+F\+A\+U\+LT}, bool swap\+Mode=\hyperlink{lte__cqi__generation_8m_ab1bef239d413c4da139c4bac92cd657a}{false}, bool nanosec\+Mode=\hyperlink{lte__cqi__generation_8m_ab1bef239d413c4da139c4bac92cd657a}{false})
\item 
void \hyperlink{classns3_1_1PcapFile_a3920f5bae95ca0021875e6e9c2630ccf}{Write} (uint32\+\_\+t ts\+Sec, uint32\+\_\+t ts\+Usec, uint8\+\_\+t const $\ast$const \hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data}, uint32\+\_\+t total\+Len)
\begin{DoxyCompactList}\small\item\em Write next packet to file. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1PcapFile_a6b334e0b95629bf0897949e33e54479d}{Write} (uint32\+\_\+t ts\+Sec, uint32\+\_\+t ts\+Usec, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p})
\begin{DoxyCompactList}\small\item\em Write next packet to file. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1PcapFile_a057ede1e4feda72362d20d7f14c4e836}{Write} (uint32\+\_\+t ts\+Sec, uint32\+\_\+t ts\+Usec, const \hyperlink{classns3_1_1Header}{Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p})
\begin{DoxyCompactList}\small\item\em Write next packet to file. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1PcapFile_a18c5045735408fe45a8cbc9e6b34a4fb}{Read} (uint8\+\_\+t $\ast$const \hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data}, uint32\+\_\+t max\+Bytes, uint32\+\_\+t \&ts\+Sec, uint32\+\_\+t \&ts\+Usec, uint32\+\_\+t \&incl\+Len, uint32\+\_\+t \&orig\+Len, uint32\+\_\+t \&read\+Len)
\begin{DoxyCompactList}\small\item\em Read next packet from file. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1PcapFile_af4e258052b9350be97672eb30f3428c2}{Get\+Swap\+Mode} (void)
\begin{DoxyCompactList}\small\item\em Get the swap mode of the file. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1PcapFile_ab19447f457118e7b345d4dc971d11c77}{Is\+Nano\+Sec\+Mode} (void)
\begin{DoxyCompactList}\small\item\em Get the nanosecond mode of the file. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1PcapFile_ac32dd628aa09604ae0280ad87bafe105}{Get\+Magic} (void)
\begin{DoxyCompactList}\small\item\em Returns the magic number of the pcap file as defined by the magic\+\_\+number field in the pcap global header. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1PcapFile_a182c0d559994abde0e1c5691bbb6f2bd}{Get\+Version\+Major} (void)
\begin{DoxyCompactList}\small\item\em Returns the major version of the pcap file as defined by the version\+\_\+major field in the pcap global header. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1PcapFile_aec2a5893556ce03eface12adc8ef200d}{Get\+Version\+Minor} (void)
\begin{DoxyCompactList}\small\item\em Returns the minor version of the pcap file as defined by the version\+\_\+minor field in the pcap global header. \end{DoxyCompactList}\item 
int32\+\_\+t \hyperlink{classns3_1_1PcapFile_af2f76f02140b0cd7820f630382626d51}{Get\+Time\+Zone\+Offset} (void)
\begin{DoxyCompactList}\small\item\em Returns the time zone offset of the pcap file as defined by the thiszone field in the pcap global header. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1PcapFile_a7074106d671684484d083f5970723c07}{Get\+Sig\+Figs} (void)
\begin{DoxyCompactList}\small\item\em Returns the accuracy of timestamps field of the pcap file as defined by the sigfigs field in the pcap global header. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1PcapFile_a1ad2956ada10389364ee11fae1937e6b}{Get\+Snap\+Len} (void)
\begin{DoxyCompactList}\small\item\em Returns the max length of saved packets field of the pcap file as defined by the snaplen field in the pcap global header. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1PcapFile_aa3795e9a87e7a4151fb4d30747eaa072}{Get\+Data\+Link\+Type} (void)
\begin{DoxyCompactList}\small\item\em Returns the data link type field of the pcap file as defined by the network field in the pcap global header. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static bool \hyperlink{classns3_1_1PcapFile_a2819d3aa000846e3527b8c798a67598c}{Diff} (std\+::string const \&f1, std\+::string const \&f2, uint32\+\_\+t \&sec, uint32\+\_\+t \&usec, uint32\+\_\+t \&packets, uint32\+\_\+t snap\+Len=\hyperlink{classns3_1_1PcapFile_ac5fda3d19b0cd0f85b0c151c2397681b}{S\+N\+A\+P\+L\+E\+N\+\_\+\+D\+E\+F\+A\+U\+LT})
\begin{DoxyCompactList}\small\item\em Compare two P\+C\+AP files packet-\/by-\/packet. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const int32\+\_\+t \hyperlink{classns3_1_1PcapFile_abd695588f972dc80b0c928aeda466dc0}{Z\+O\+N\+E\+\_\+\+D\+E\+F\+A\+U\+LT} = 0
\item 
static const uint32\+\_\+t \hyperlink{classns3_1_1PcapFile_ac5fda3d19b0cd0f85b0c151c2397681b}{S\+N\+A\+P\+L\+E\+N\+\_\+\+D\+E\+F\+A\+U\+LT} = 65535
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
uint8\+\_\+t \hyperlink{classns3_1_1PcapFile_af5adf22a721473f1add1e002492f5587}{Swap} (uint8\+\_\+t val)
\begin{DoxyCompactList}\small\item\em Swap a value byte order. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1PcapFile_a626e8456233183d32aa229b53a629a43}{Swap} (uint16\+\_\+t val)
\begin{DoxyCompactList}\small\item\em Swap a value byte order. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1PcapFile_afe97f12e052ebd77a5c113c0d8f11d33}{Swap} (uint32\+\_\+t val)
\begin{DoxyCompactList}\small\item\em Swap a value byte order. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1PcapFile_a12aa14e48a7b27a43ea0ab8abffa4834}{Swap} (\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader}{Pcap\+File\+Header} $\ast$\hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from}, \hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader}{Pcap\+File\+Header} $\ast$to)
\begin{DoxyCompactList}\small\item\em Swap the byte order of a Pcap file header. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1PcapFile_af8cb5cf7b27cf92373709a577af671f4}{Swap} (\hyperlink{structns3_1_1PcapFile_1_1PcapRecordHeader}{Pcap\+Record\+Header} $\ast$\hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from}, \hyperlink{structns3_1_1PcapFile_1_1PcapRecordHeader}{Pcap\+Record\+Header} $\ast$to)
\begin{DoxyCompactList}\small\item\em Swap the byte order of a Pcap record header. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1PcapFile_a58124715fdc400c4ae0ff1c3ba8215ab}{Write\+File\+Header} (void)
\begin{DoxyCompactList}\small\item\em Write a Pcap file header. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1PcapFile_a49675e170416ab1665fea6883250bda3}{Write\+Packet\+Header} (uint32\+\_\+t ts\+Sec, uint32\+\_\+t ts\+Usec, uint32\+\_\+t total\+Len)
\begin{DoxyCompactList}\small\item\em Write a Pcap packet header. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1PcapFile_aa73a9f58350e911c34bdac1071e60e10}{Read\+And\+Verify\+File\+Header} (void)
\begin{DoxyCompactList}\small\item\em Read and verify a Pcap file header. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::string \hyperlink{classns3_1_1PcapFile_a352f69f3045f8e1ebbc42ab5ab540b68}{m\+\_\+filename}
\begin{DoxyCompactList}\small\item\em file name \end{DoxyCompactList}\item 
std\+::fstream \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\+\_\+file}
\begin{DoxyCompactList}\small\item\em file stream \end{DoxyCompactList}\item 
\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader}{Pcap\+File\+Header} \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\+\_\+file\+Header}
\begin{DoxyCompactList}\small\item\em file header \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1PcapFile_a179acfdfb216038a20ddb8cdc5fe182d}{m\+\_\+swap\+Mode}
\begin{DoxyCompactList}\small\item\em swap mode \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1PcapFile_ac4c31785ef8fe52e33615f5ee33cacf8}{m\+\_\+nanosec\+Mode}
\begin{DoxyCompactList}\small\item\em nanosecond timestamp mode \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
A class representing a pcap file. 

A class representing a pcap file. This allows easy creation, writing and reading of files composed of stored packets; which may be viewed using standard tools. 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!Pcap\+File@{Pcap\+File}}
\index{Pcap\+File@{Pcap\+File}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{Pcap\+File()}{PcapFile()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Pcap\+File\+::\+Pcap\+File (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PcapFile_a6bfa1cf38e6845f9d2e77e3c034ed90d}{}\label{classns3_1_1PcapFile_a6bfa1cf38e6845f9d2e77e3c034ed90d}

\begin{DoxyCode}
51   : \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file} (),
52     \hyperlink{classns3_1_1PcapFile_a179acfdfb216038a20ddb8cdc5fe182d}{m\_swapMode} (\textcolor{keyword}{false}),
53     \hyperlink{classns3_1_1PcapFile_ac4c31785ef8fe52e33615f5ee33cacf8}{m\_nanosecMode} (\textcolor{keyword}{false})
54 \{
55   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
56   \hyperlink{group__fatalimpl_gad552ca3d6d85b95147b8c6a2eb4d4579}{FatalImpl::RegisterStream} (&\hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}); 
57 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 1


\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!````~Pcap\+File@{$\sim$\+Pcap\+File}}
\index{````~Pcap\+File@{$\sim$\+Pcap\+File}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{$\sim$\+Pcap\+File()}{~PcapFile()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Pcap\+File\+::$\sim$\+Pcap\+File (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PcapFile_ae70ee5d4e70678f92635233e36288764}{}\label{classns3_1_1PcapFile_ae70ee5d4e70678f92635233e36288764}

\begin{DoxyCode}
60 \{
61   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
62   \hyperlink{group__fatalimpl_ga2bf70e98e990f01912527b4ccfac27d0}{FatalImpl::UnregisterStream} (&\hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file});
63   \hyperlink{classns3_1_1PcapFile_ad3b6c28d464742ee1fa3a64628339a5b}{Close} ();
64 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2




\subsection{Member Function Documentation}
\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!Clear@{Clear}}
\index{Clear@{Clear}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{Clear(void)}{Clear(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Pcap\+File\+::\+Clear (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PcapFile_a4b593422b0941d936d98635151d1d8ce}{}\label{classns3_1_1PcapFile_a4b593422b0941d936d98635151d1d8ce}
Clear all state bits of the underlying iostream. 
\begin{DoxyCode}
81 \{
82   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
83   \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.clear ();
84 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 3


\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!Close@{Close}}
\index{Close@{Close}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{Close(void)}{Close(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Pcap\+File\+::\+Close (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PcapFile_ad3b6c28d464742ee1fa3a64628339a5b}{}\label{classns3_1_1PcapFile_ad3b6c28d464742ee1fa3a64628339a5b}
Close the underlying file. 
\begin{DoxyCode}
89 \{
90   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
91   \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.close ();
92 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!Diff@{Diff}}
\index{Diff@{Diff}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{Diff(std\+::string const \&f1, std\+::string const \&f2, uint32\+\_\+t \&sec, uint32\+\_\+t \&usec, uint32\+\_\+t \&packets, uint32\+\_\+t snap\+Len=\+S\+N\+A\+P\+L\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T)}{Diff(std::string const &f1, std::string const &f2, uint32_t &sec, uint32_t &usec, uint32_t &packets, uint32_t snapLen=SNAPLEN_DEFAULT)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Pcap\+File\+::\+Diff (
\begin{DoxyParamCaption}
\item[{std\+::string const \&}]{f1, }
\item[{std\+::string const \&}]{f2, }
\item[{uint32\+\_\+t \&}]{sec, }
\item[{uint32\+\_\+t \&}]{usec, }
\item[{uint32\+\_\+t \&}]{packets, }
\item[{uint32\+\_\+t}]{snap\+Len = {\ttfamily {\bf S\+N\+A\+P\+L\+E\+N\+\_\+\+D\+E\+F\+A\+U\+LT}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1PcapFile_a2819d3aa000846e3527b8c798a67598c}{}\label{classns3_1_1PcapFile_a2819d3aa000846e3527b8c798a67598c}


Compare two P\+C\+AP files packet-\/by-\/packet. 

\begin{DoxyReturn}{Returns}
true if files are different, false otherwise
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em f1} & First P\+C\+AP file name \\
\hline
{\em f2} & Second P\+C\+AP file name \\
\hline
{\em sec} & \mbox{[}out\mbox{]} \hyperlink{classns3_1_1Time}{Time} stamp of first different packet, seconds. Undefined if files doesn\textquotesingle{}t differ. \\
\hline
{\em usec} & \mbox{[}out\mbox{]} \hyperlink{classns3_1_1Time}{Time} stamp of first different packet, microseconds. Undefined if files doesn\textquotesingle{}t differ. \\
\hline
{\em packets} & \mbox{[}out\mbox{]} \+Number of first different packet. Total number of parsed packets if files doesn\textquotesingle{}t differ. \\
\hline
{\em snap\+Len} & Snap length (if used) \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
531 \{
532   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (f1 << f2 << sec << usec << snapLen);
533   \hyperlink{classns3_1_1PcapFile_a6bfa1cf38e6845f9d2e77e3c034ed90d}{PcapFile} pcap1, pcap2;
534   pcap1.Open (f1, std::ios::in);
535   pcap2.Open (f2, std::ios::in);
536   \textcolor{keywordtype}{bool} bad = pcap1.Fail () || pcap2.Fail ();
537   \textcolor{keywordflow}{if} (bad)
538     \{
539       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
540     \}
541 
542   uint8\_t *data1 = \textcolor{keyword}{new} uint8\_t [snapLen] ();
543   uint8\_t *data2 = \textcolor{keyword}{new} uint8\_t [snapLen] ();
544   uint32\_t tsSec1 = 0;
545   uint32\_t tsSec2 = 0;
546   uint32\_t tsUsec1 = 0;
547   uint32\_t tsUsec2 = 0;
548   uint32\_t inclLen1 = 0;
549   uint32\_t inclLen2 = 0;
550   uint32\_t origLen1 = 0;
551   uint32\_t origLen2 = 0;
552   uint32\_t readLen1 = 0;
553   uint32\_t readLen2 = 0;
554   \textcolor{keywordtype}{bool} diff = \textcolor{keyword}{false};
555 
556   \textcolor{keywordflow}{while} (!pcap1.Eof () && !pcap2.Eof ())
557     \{
558       pcap1.Read (data1, snapLen, tsSec1, tsUsec1, inclLen1, origLen1, readLen1);
559       pcap2.Read (data2, snapLen, tsSec2, tsUsec2, inclLen2, origLen2, readLen2);
560 
561       \textcolor{keywordtype}{bool} same = pcap1.Fail () == pcap2.Fail ();
562       \textcolor{keywordflow}{if} (!same)
563         \{
564           diff = \textcolor{keyword}{true};
565           \textcolor{keywordflow}{break};
566         \}
567       \textcolor{keywordflow}{if} (pcap1.Eof ())
568         \{
569           \textcolor{keywordflow}{break};
570         \}
571 
572       ++packets;
573       
574       \textcolor{keywordflow}{if} (tsSec1 != tsSec2 || tsUsec1 != tsUsec2)
575         \{
576           diff = \textcolor{keyword}{true}; \textcolor{comment}{// Next packet timestamps do not match}
577           \textcolor{keywordflow}{break};
578         \}
579 
580       \textcolor{keywordflow}{if} (readLen1 != readLen2)
581         \{
582           diff = \textcolor{keyword}{true}; \textcolor{comment}{// Packet lengths do not match}
583           \textcolor{keywordflow}{break};
584         \}
585 
586       \textcolor{keywordflow}{if} (std::memcmp (data1, data2, readLen1) != 0)
587         \{
588           diff = \textcolor{keyword}{true}; \textcolor{comment}{// Packet data do not match}
589           \textcolor{keywordflow}{break};
590         \}
591     \}
592   sec = tsSec1;
593   usec = tsUsec1;
594 
595   bad = pcap1.Fail () || pcap2.Fail ();
596   \textcolor{keywordtype}{bool} eof = pcap1.Eof () && pcap2.Eof ();
597   \textcolor{keywordflow}{if} (bad && !eof)
598     \{
599       diff = \textcolor{keyword}{true};
600     \}
601 
602   \textcolor{keyword}{delete}[] data1;
603   \textcolor{keyword}{delete}[] data2;
604 
605   \textcolor{keywordflow}{return} diff;
606 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5


\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!Eof@{Eof}}
\index{Eof@{Eof}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{Eof(void) const }{Eof(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Pcap\+File\+::\+Eof (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1PcapFile_ad8b9cd552beb5e1c348e04c98d3daffa}{}\label{classns3_1_1PcapFile_ad8b9cd552beb5e1c348e04c98d3daffa}
\begin{DoxyReturn}{Returns}
true if the \textquotesingle{}eof\textquotesingle{} bit is set in the underlying iostream, false otherwise. 
\end{DoxyReturn}

\begin{DoxyCode}
75 \{
76   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
77   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.eof ();
78 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!Fail@{Fail}}
\index{Fail@{Fail}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{Fail(void) const }{Fail(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Pcap\+File\+::\+Fail (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1PcapFile_a2e00aa080890a0c9c3e9f5bd2d6c21d5}{}\label{classns3_1_1PcapFile_a2e00aa080890a0c9c3e9f5bd2d6c21d5}
\begin{DoxyReturn}{Returns}
true if the \textquotesingle{}fail\textquotesingle{} bit is set in the underlying iostream, false otherwise. 
\end{DoxyReturn}

\begin{DoxyCode}
69 \{
70   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
71   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.fail ();
72 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!Get\+Data\+Link\+Type@{Get\+Data\+Link\+Type}}
\index{Get\+Data\+Link\+Type@{Get\+Data\+Link\+Type}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{Get\+Data\+Link\+Type(void)}{GetDataLinkType(void)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Pcap\+File\+::\+Get\+Data\+Link\+Type (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PcapFile_aa3795e9a87e7a4151fb4d30747eaa072}{}\label{classns3_1_1PcapFile_aa3795e9a87e7a4151fb4d30747eaa072}


Returns the data link type field of the pcap file as defined by the network field in the pcap global header. 

See \href{http://wiki.wireshark.org/Development/LibpcapFileFormat}{\tt http\+://wiki.\+wireshark.\+org/\+Development/\+Libpcap\+File\+Format}

\begin{DoxyReturn}{Returns}
data link type field 
\end{DoxyReturn}

\begin{DoxyCode}
138 \{
139   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
140   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_ac3c13f02372a4db169cea201f028b4c1}{m\_type};
141 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!Get\+Magic@{Get\+Magic}}
\index{Get\+Magic@{Get\+Magic}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{Get\+Magic(void)}{GetMagic(void)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Pcap\+File\+::\+Get\+Magic (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PcapFile_ac32dd628aa09604ae0280ad87bafe105}{}\label{classns3_1_1PcapFile_ac32dd628aa09604ae0280ad87bafe105}


Returns the magic number of the pcap file as defined by the magic\+\_\+number field in the pcap global header. 

See \href{http://wiki.wireshark.org/Development/LibpcapFileFormat}{\tt http\+://wiki.\+wireshark.\+org/\+Development/\+Libpcap\+File\+Format}

\begin{DoxyReturn}{Returns}
magic number 
\end{DoxyReturn}

\begin{DoxyCode}
96 \{
97   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
98   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_a53c161466b08f8aadc7ec382daf85add}{m\_magicNumber};
99 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 9


\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!Get\+Sig\+Figs@{Get\+Sig\+Figs}}
\index{Get\+Sig\+Figs@{Get\+Sig\+Figs}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{Get\+Sig\+Figs(void)}{GetSigFigs(void)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Pcap\+File\+::\+Get\+Sig\+Figs (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PcapFile_a7074106d671684484d083f5970723c07}{}\label{classns3_1_1PcapFile_a7074106d671684484d083f5970723c07}


Returns the accuracy of timestamps field of the pcap file as defined by the sigfigs field in the pcap global header. 

See \href{http://wiki.wireshark.org/Development/LibpcapFileFormat}{\tt http\+://wiki.\+wireshark.\+org/\+Development/\+Libpcap\+File\+Format}

\begin{DoxyReturn}{Returns}
accuracy of timestamps 
\end{DoxyReturn}

\begin{DoxyCode}
124 \{
125   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
126   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_a76f5e60aad3d3cad6a316aa37186ac19}{m\_sigFigs};
127 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 10


\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!Get\+Snap\+Len@{Get\+Snap\+Len}}
\index{Get\+Snap\+Len@{Get\+Snap\+Len}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{Get\+Snap\+Len(void)}{GetSnapLen(void)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Pcap\+File\+::\+Get\+Snap\+Len (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PcapFile_a1ad2956ada10389364ee11fae1937e6b}{}\label{classns3_1_1PcapFile_a1ad2956ada10389364ee11fae1937e6b}


Returns the max length of saved packets field of the pcap file as defined by the snaplen field in the pcap global header. 

See \href{http://wiki.wireshark.org/Development/LibpcapFileFormat}{\tt http\+://wiki.\+wireshark.\+org/\+Development/\+Libpcap\+File\+Format}

\begin{DoxyReturn}{Returns}
max length of saved packets field 
\end{DoxyReturn}

\begin{DoxyCode}
131 \{
132   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
133   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_acadba930824bddafabd88a0b3f5e3289}{m\_snapLen};
134 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!Get\+Swap\+Mode@{Get\+Swap\+Mode}}
\index{Get\+Swap\+Mode@{Get\+Swap\+Mode}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{Get\+Swap\+Mode(void)}{GetSwapMode(void)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Pcap\+File\+::\+Get\+Swap\+Mode (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PcapFile_af4e258052b9350be97672eb30f3428c2}{}\label{classns3_1_1PcapFile_af4e258052b9350be97672eb30f3428c2}


Get the swap mode of the file. 

Pcap files use a magic number that is overloaded to identify both the format of the file itself and the byte ordering of the file. The magic number (and all data) is written into the file according to the native byte ordering of the writing system. If a reading application reads the magic number identically (for example 0xa1b2c3d4) then no byte swapping is required to correctly interpret the file data. If the reading application sees the magic number is byte swapped (for example 0xd4c3b2a1) then it knows that it needs to byteswap appropriate fields in the format.

Get\+S\+Wap\+Mode returns a value indicating whether or not the fields are being byteswapped. Used primarily for testing the class itself, but may be useful as a flag indicating a difference in endianness of the writing system.

\begin{DoxyReturn}{Returns}
swap mode of the file 
\end{DoxyReturn}

\begin{DoxyCode}
145 \{
146   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
147   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1PcapFile_a179acfdfb216038a20ddb8cdc5fe182d}{m\_swapMode};
148 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 12


\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!Get\+Time\+Zone\+Offset@{Get\+Time\+Zone\+Offset}}
\index{Get\+Time\+Zone\+Offset@{Get\+Time\+Zone\+Offset}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{Get\+Time\+Zone\+Offset(void)}{GetTimeZoneOffset(void)}}]{\setlength{\rightskip}{0pt plus 5cm}int32\+\_\+t ns3\+::\+Pcap\+File\+::\+Get\+Time\+Zone\+Offset (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PcapFile_af2f76f02140b0cd7820f630382626d51}{}\label{classns3_1_1PcapFile_af2f76f02140b0cd7820f630382626d51}


Returns the time zone offset of the pcap file as defined by the thiszone field in the pcap global header. 

See \href{http://wiki.wireshark.org/Development/LibpcapFileFormat}{\tt http\+://wiki.\+wireshark.\+org/\+Development/\+Libpcap\+File\+Format}

\begin{DoxyReturn}{Returns}
time zone offset 
\end{DoxyReturn}

\begin{DoxyCode}
117 \{
118   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
119   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_aaa76da3051b3fe9cf8b37129d5510b1c}{m\_zone};
120 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 13


\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!Get\+Version\+Major@{Get\+Version\+Major}}
\index{Get\+Version\+Major@{Get\+Version\+Major}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{Get\+Version\+Major(void)}{GetVersionMajor(void)}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Pcap\+File\+::\+Get\+Version\+Major (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PcapFile_a182c0d559994abde0e1c5691bbb6f2bd}{}\label{classns3_1_1PcapFile_a182c0d559994abde0e1c5691bbb6f2bd}


Returns the major version of the pcap file as defined by the version\+\_\+major field in the pcap global header. 

See \href{http://wiki.wireshark.org/Development/LibpcapFileFormat}{\tt http\+://wiki.\+wireshark.\+org/\+Development/\+Libpcap\+File\+Format}

\begin{DoxyReturn}{Returns}
major version 
\end{DoxyReturn}

\begin{DoxyCode}
103 \{
104   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
105   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_aad229620708f0556447252a2c737788d}{m\_versionMajor};
106 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 14


\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!Get\+Version\+Minor@{Get\+Version\+Minor}}
\index{Get\+Version\+Minor@{Get\+Version\+Minor}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{Get\+Version\+Minor(void)}{GetVersionMinor(void)}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Pcap\+File\+::\+Get\+Version\+Minor (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PcapFile_aec2a5893556ce03eface12adc8ef200d}{}\label{classns3_1_1PcapFile_aec2a5893556ce03eface12adc8ef200d}


Returns the minor version of the pcap file as defined by the version\+\_\+minor field in the pcap global header. 

See \href{http://wiki.wireshark.org/Development/LibpcapFileFormat}{\tt http\+://wiki.\+wireshark.\+org/\+Development/\+Libpcap\+File\+Format}

\begin{DoxyReturn}{Returns}
minor version 
\end{DoxyReturn}

\begin{DoxyCode}
110 \{
111   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
112   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_afb6cdefec3947135b53c8bbe05628927}{m\_versionMinor};
113 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 15


\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!Init@{Init}}
\index{Init@{Init}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{Init(uint32\+\_\+t data\+Link\+Type, uint32\+\_\+t snap\+Len=\+S\+N\+A\+P\+L\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T, int32\+\_\+t time\+Zone\+Correction=\+Z\+O\+N\+E\+\_\+\+D\+E\+F\+A\+U\+L\+T, bool swap\+Mode=false, bool nanosec\+Mode=false)}{Init(uint32_t dataLinkType, uint32_t snapLen=SNAPLEN_DEFAULT, int32_t timeZoneCorrection=ZONE_DEFAULT, bool swapMode=false, bool nanosecMode=false)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Pcap\+File\+::\+Init (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{data\+Link\+Type, }
\item[{uint32\+\_\+t}]{snap\+Len = {\ttfamily {\bf S\+N\+A\+P\+L\+E\+N\+\_\+\+D\+E\+F\+A\+U\+LT}}, }
\item[{int32\+\_\+t}]{time\+Zone\+Correction = {\ttfamily {\bf Z\+O\+N\+E\+\_\+\+D\+E\+F\+A\+U\+LT}}, }
\item[{bool}]{swap\+Mode = {\ttfamily {\bf false}}, }
\item[{bool}]{nanosec\+Mode = {\ttfamily {\bf false}}}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PcapFile_a80c8adea1baa66e3f730df2927b0fc9b}{}\label{classns3_1_1PcapFile_a80c8adea1baa66e3f730df2927b0fc9b}
Initialize the pcap file associated with this object. This file must have been previously opened with write permissions.


\begin{DoxyParams}{Parameters}
{\em data\+Link\+Type} & A data link type as defined in the pcap library. If you want to make resulting pcap files visible in existing tools, the data link type must match existing definitions, such as P\+C\+A\+P\+\_\+\+E\+T\+H\+E\+R\+N\+ET, P\+C\+A\+P\+\_\+\+P\+PP, P\+C\+A\+P\+\_\+80211, etc. If you are storing different kinds of packet data, such as naked T\+CP headers, you are at liberty to locally define your own data link types. According to the pcap-\/linktype man page, \char`\"{}well-\/known\char`\"{} pcap linktypes range from 0 to 263. If you use a large random number for your type, chances are small for a collision.\\
\hline
{\em snap\+Len} & An optional maximum size for packets written to the file. Defaults to 65535. If packets exceed this length they are truncated.\\
\hline
{\em time\+Zone\+Correction} & An integer describing the offset of your local time zone from U\+T\+C/\+G\+MT. For example, Pacific Standard \hyperlink{classns3_1_1Time}{Time} in the US is G\+M\+T-\/8, so one would enter -\/8 for that correction. Defaults to 0 (U\+TC).\\
\hline
{\em swap\+Mode} & Flag indicating a difference in endianness of the writing system. Defaults to false.\\
\hline
{\em nanosec\+Mode} & Flag indicating the time resolution of the writing system. Default to false.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
false if the open succeeds, true otherwise.
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Calling this method on an existing file will result in the loss any existing data. 
\end{DoxyWarning}

\begin{DoxyCode}
346 \{
347   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << dataLinkType << snapLen << timeZoneCorrection << swapMode);
348 
349   \textcolor{comment}{//}
350   \textcolor{comment}{// Initialize the magic number and nanosecond mode flag}
351   \textcolor{comment}{//}
352   \hyperlink{classns3_1_1PcapFile_ac4c31785ef8fe52e33615f5ee33cacf8}{m\_nanosecMode} = nanosecMode;
353   \textcolor{keywordflow}{if} (nanosecMode)
354     \{
355       \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_a53c161466b08f8aadc7ec382daf85add}{m\_magicNumber} = \hyperlink{namespacens3_aa3cf3e7390afab115718e01fb671fdb9}{NS\_MAGIC};
356     \}
357   \textcolor{keywordflow}{else}
358     \{
359       \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_a53c161466b08f8aadc7ec382daf85add}{m\_magicNumber} = \hyperlink{namespacens3_a19e4b16597efe38cbfa2033c9988f224}{MAGIC};
360     \}
361 
362   \textcolor{comment}{//}
363   \textcolor{comment}{// Initialize remainder of the in-memory file header.}
364   \textcolor{comment}{//}
365   \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_aad229620708f0556447252a2c737788d}{m\_versionMajor} = \hyperlink{namespacens3_ac952f36545c1876b7ea895dbd521afb9}{VERSION\_MAJOR};
366   \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_afb6cdefec3947135b53c8bbe05628927}{m\_versionMinor} = \hyperlink{namespacens3_a8aab01f6e71af7830eedfec5ff333ef4}{VERSION\_MINOR};
367   \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_aaa76da3051b3fe9cf8b37129d5510b1c}{m\_zone} = timeZoneCorrection;
368   \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_a76f5e60aad3d3cad6a316aa37186ac19}{m\_sigFigs} = 0;
369   \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_acadba930824bddafabd88a0b3f5e3289}{m\_snapLen} = snapLen;
370   \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_ac3c13f02372a4db169cea201f028b4c1}{m\_type} = dataLinkType;
371 
372   \textcolor{comment}{//}
373   \textcolor{comment}{// We use pcap files for regression testing.  We do byte-for-byte comparisons}
374   \textcolor{comment}{// in those tests to determine pass or fail.  If we allow big endian systems}
375   \textcolor{comment}{// to write big endian headers, they will end up byte-swapped and the}
376   \textcolor{comment}{// regression tests will fail.  Until we get rid of the regression tests, we}
377   \textcolor{comment}{// have to pick an endianness and stick with it.  The precedent is little}
378   \textcolor{comment}{// endian, so we set swap mode if required to pick little endian.}
379   \textcolor{comment}{//}
380   \textcolor{comment}{// We do want to allow a user or test suite to enable swapmode irrespective}
381   \textcolor{comment}{// of what we decide here, so we allow setting swapmode from formal parameter}
382   \textcolor{comment}{// as well.}
383   \textcolor{comment}{//}
384   \textcolor{comment}{// So, determine the endianness of the running system.}
385   \textcolor{comment}{//}
386   \textcolor{keyword}{union }\{
387     uint32\_t a;
388     uint8\_t  \hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b}[4];
389   \} u;
390 
391   u.a = 1;
392   \textcolor{keywordtype}{bool} bigEndian = u.b[3];
393 
394   \textcolor{comment}{//}
395   \textcolor{comment}{// And set swap mode if requested or we are on a big-endian system.}
396   \textcolor{comment}{//}
397   \hyperlink{classns3_1_1PcapFile_a179acfdfb216038a20ddb8cdc5fe182d}{m\_swapMode} = swapMode | bigEndian;
398 
399   \hyperlink{classns3_1_1PcapFile_a58124715fdc400c4ae0ff1c3ba8215ab}{WriteFileHeader} ();
400 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 16




Here is the caller graph for this function\+:
% FIG 17


\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!Is\+Nano\+Sec\+Mode@{Is\+Nano\+Sec\+Mode}}
\index{Is\+Nano\+Sec\+Mode@{Is\+Nano\+Sec\+Mode}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{Is\+Nano\+Sec\+Mode(void)}{IsNanoSecMode(void)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Pcap\+File\+::\+Is\+Nano\+Sec\+Mode (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PcapFile_ab19447f457118e7b345d4dc971d11c77}{}\label{classns3_1_1PcapFile_ab19447f457118e7b345d4dc971d11c77}


Get the nanosecond mode of the file. 

\begin{DoxyReturn}{Returns}
true if the packet timestamps in the P\+C\+AP file have nanosecond resolution. 
\end{DoxyReturn}

\begin{DoxyCode}
152 \{
153   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
154   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1PcapFile_ac4c31785ef8fe52e33615f5ee33cacf8}{m\_nanosecMode};
155 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 18


\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!Open@{Open}}
\index{Open@{Open}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{Open(std\+::string const \&filename, std\+::ios\+::openmode mode)}{Open(std::string const &filename, std::ios::openmode mode)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Pcap\+File\+::\+Open (
\begin{DoxyParamCaption}
\item[{std\+::string const \&}]{filename, }
\item[{std\+::ios\+::openmode}]{mode}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PcapFile_a064e8494e28e823d0bb4e40549f9f483}{}\label{classns3_1_1PcapFile_a064e8494e28e823d0bb4e40549f9f483}
Create a new pcap file or open an existing pcap file. Semantics are similar to the stdc++ io stream classes, but differ in that positions in the file are based on packets not characters. For example if the file is opened for reading, the file position indicator (seek position) points to the beginning of the first packet in the file, not zero (which would point to the start of the pcap header).

Since a pcap file is always a binary file, the file type is automatically selected as a binary file (fstream\+::binary is automatically ored with the mode field).


\begin{DoxyParams}{Parameters}
{\em filename} & String containing the name of the file.\\
\hline
{\em mode} & the access mode for the file. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
326 \{
327   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << filename << mode);
328   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} ((mode & std::ios::app) == 0);
329   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (!\hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.fail ());
330   \textcolor{comment}{//}
331   \textcolor{comment}{// All pcap files are binary files, so we just do this automatically.}
332   \textcolor{comment}{//}
333   mode |= std::ios::binary;
334 
335   \hyperlink{classns3_1_1PcapFile_a352f69f3045f8e1ebbc42ab5ab540b68}{m\_filename}=filename;
336   \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.open (filename.c\_str (), mode);
337   \textcolor{keywordflow}{if} (mode & std::ios::in)
338     \{
339       \textcolor{comment}{// will set the fail bit if file header is invalid.}
340       \hyperlink{classns3_1_1PcapFile_aa73a9f58350e911c34bdac1071e60e10}{ReadAndVerifyFileHeader} ();
341     \}
342 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 19




Here is the caller graph for this function\+:
% FIG 20


\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!Read@{Read}}
\index{Read@{Read}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{Read(uint8\+\_\+t $\ast$const data, uint32\+\_\+t max\+Bytes, uint32\+\_\+t \&ts\+Sec, uint32\+\_\+t \&ts\+Usec, uint32\+\_\+t \&incl\+Len, uint32\+\_\+t \&orig\+Len, uint32\+\_\+t \&read\+Len)}{Read(uint8_t *const data, uint32_t maxBytes, uint32_t &tsSec, uint32_t &tsUsec, uint32_t &inclLen, uint32_t &origLen, uint32_t &readLen)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Pcap\+File\+::\+Read (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$const}]{data, }
\item[{uint32\+\_\+t}]{max\+Bytes, }
\item[{uint32\+\_\+t \&}]{ts\+Sec, }
\item[{uint32\+\_\+t \&}]{ts\+Usec, }
\item[{uint32\+\_\+t \&}]{incl\+Len, }
\item[{uint32\+\_\+t \&}]{orig\+Len, }
\item[{uint32\+\_\+t \&}]{read\+Len}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PcapFile_a18c5045735408fe45a8cbc9e6b34a4fb}{}\label{classns3_1_1PcapFile_a18c5045735408fe45a8cbc9e6b34a4fb}


Read next packet from file. 


\begin{DoxyParams}{Parameters}
{\em data} & \mbox{[}out\mbox{]} Data buffer \\
\hline
{\em max\+Bytes} & Allocated data buffer size \\
\hline
{\em ts\+Sec} & \mbox{[}out\mbox{]} \hyperlink{classns3_1_1Packet}{Packet} timestamp, seconds \\
\hline
{\em ts\+Usec} & \mbox{[}out\mbox{]} \hyperlink{classns3_1_1Packet}{Packet} timestamp, microseconds \\
\hline
{\em incl\+Len} & \mbox{[}out\mbox{]} Included length \\
\hline
{\em orig\+Len} & \mbox{[}out\mbox{]} Original length \\
\hline
{\em read\+Len} & \mbox{[}out\mbox{]} Number of bytes read \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
477 \{
478   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << &\hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data} <<maxBytes << tsSec << tsUsec << inclLen << origLen << 
      readLen);
479   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.good ());
480 
481   PcapRecordHeader header;
482 
483   \textcolor{comment}{//}
484   \textcolor{comment}{// Watch out for memory alignment differences between machines, so read}
485   \textcolor{comment}{// them all individually.}
486   \textcolor{comment}{//}
487   \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.read ((\textcolor{keywordtype}{char} *)&header.m\_tsSec, \textcolor{keyword}{sizeof}(header.m\_tsSec));
488   \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.read ((\textcolor{keywordtype}{char} *)&header.m\_tsUsec, \textcolor{keyword}{sizeof}(header.m\_tsUsec));
489   \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.read ((\textcolor{keywordtype}{char} *)&header.m\_inclLen, \textcolor{keyword}{sizeof}(header.m\_inclLen));
490   \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.read ((\textcolor{keywordtype}{char} *)&header.m\_origLen, \textcolor{keyword}{sizeof}(header.m\_origLen));
491 
492   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.fail ())
493     \{
494       \textcolor{keywordflow}{return};
495     \}
496 
497   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PcapFile_a179acfdfb216038a20ddb8cdc5fe182d}{m\_swapMode})
498     \{
499       \hyperlink{classns3_1_1PcapFile_af5adf22a721473f1add1e002492f5587}{Swap} (&header, &header);
500     \}
501 
502   tsSec = header.m\_tsSec;
503   tsUsec = header.m\_tsUsec;
504   inclLen = header.m\_inclLen;
505   origLen = header.m\_origLen;
506 
507   \textcolor{comment}{//}
508   \textcolor{comment}{// We don't always want to force the client to keep a maximum length buffer }
509   \textcolor{comment}{// around so we allow her to specify a minimum number of bytes to read.}
510   \textcolor{comment}{// Usually 64 bytes is enough information to print all of the headers, so}
511   \textcolor{comment}{// it isn't typically necessary to read all thousand bytes of an echo packet,}
512   \textcolor{comment}{// for example, to figure out what is going on.}
513   \textcolor{comment}{//}
514   readLen = maxBytes < header.m\_inclLen ? maxBytes : header.m\_inclLen;
515   \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.read ((\textcolor{keywordtype}{char} *)\hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data}, readLen);
516 
517   \textcolor{comment}{//}
518   \textcolor{comment}{// To keep the file pointer pointed in the right place, however, we always}
519   \textcolor{comment}{// need to account for the entire packet as stored originally.}
520   \textcolor{comment}{//}
521   \textcolor{keywordflow}{if} (readLen < header.m\_inclLen)
522     \{
523       \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.seekg (header.m\_inclLen - readLen, std::ios::cur);
524     \}
525 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 21




Here is the caller graph for this function\+:
% FIG 22


\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!Read\+And\+Verify\+File\+Header@{Read\+And\+Verify\+File\+Header}}
\index{Read\+And\+Verify\+File\+Header@{Read\+And\+Verify\+File\+Header}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{Read\+And\+Verify\+File\+Header(void)}{ReadAndVerifyFileHeader(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Pcap\+File\+::\+Read\+And\+Verify\+File\+Header (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PcapFile_aa73a9f58350e911c34bdac1071e60e10}{}\label{classns3_1_1PcapFile_aa73a9f58350e911c34bdac1071e60e10}


Read and verify a Pcap file header. 


\begin{DoxyCode}
248 \{
249   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
250   \textcolor{comment}{//}
251   \textcolor{comment}{// Pcap file header is always at the start of the file}
252   \textcolor{comment}{//}
253   \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.seekg (0, std::ios::beg);
254 
255   \textcolor{comment}{//}
256   \textcolor{comment}{// Watch out for memory alignment differences between machines, so read}
257   \textcolor{comment}{// them all individually.}
258   \textcolor{comment}{//}
259   \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.read ((\textcolor{keywordtype}{char} *)&\hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_a53c161466b08f8aadc7ec382daf85add}{m\_magicNumber}, \textcolor{keyword}{sizeof}(
      \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_a53c161466b08f8aadc7ec382daf85add}{m\_magicNumber}));
260   \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.read ((\textcolor{keywordtype}{char} *)&\hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_aad229620708f0556447252a2c737788d}{m\_versionMajor}, \textcolor{keyword}{sizeof}(
      \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_aad229620708f0556447252a2c737788d}{m\_versionMajor}));
261   \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.read ((\textcolor{keywordtype}{char} *)&\hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_afb6cdefec3947135b53c8bbe05628927}{m\_versionMinor}, \textcolor{keyword}{sizeof}(
      \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_afb6cdefec3947135b53c8bbe05628927}{m\_versionMinor}));
262   \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.read ((\textcolor{keywordtype}{char} *)&\hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_aaa76da3051b3fe9cf8b37129d5510b1c}{m\_zone}, \textcolor{keyword}{sizeof}(
      \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_aaa76da3051b3fe9cf8b37129d5510b1c}{m\_zone}));
263   \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.read ((\textcolor{keywordtype}{char} *)&\hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_a76f5e60aad3d3cad6a316aa37186ac19}{m\_sigFigs}, \textcolor{keyword}{sizeof}(
      \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_a76f5e60aad3d3cad6a316aa37186ac19}{m\_sigFigs}));
264   \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.read ((\textcolor{keywordtype}{char} *)&\hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_acadba930824bddafabd88a0b3f5e3289}{m\_snapLen}, \textcolor{keyword}{sizeof}(
      \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_acadba930824bddafabd88a0b3f5e3289}{m\_snapLen}));
265   \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.read ((\textcolor{keywordtype}{char} *)&\hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_ac3c13f02372a4db169cea201f028b4c1}{m\_type}, \textcolor{keyword}{sizeof}(
      \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_ac3c13f02372a4db169cea201f028b4c1}{m\_type}));
266 
267   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.fail ())
268     \{
269       \textcolor{keywordflow}{return};
270     \}
271 
272   \textcolor{comment}{//}
273   \textcolor{comment}{// There are four possible magic numbers that can be there.  Normal and byte}
274   \textcolor{comment}{// swapped versions of the standard magic number, and normal and byte swapped}
275   \textcolor{comment}{// versions of the magic number indicating nanosecond resolution timestamps.}
276   \textcolor{comment}{//}
277   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_a53c161466b08f8aadc7ec382daf85add}{m\_magicNumber} != \hyperlink{namespacens3_a19e4b16597efe38cbfa2033c9988f224}{MAGIC} && 
      \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_a53c161466b08f8aadc7ec382daf85add}{m\_magicNumber} != \hyperlink{namespacens3_a687c5411ecbe4c7766c70c1226eef2d3}{SWAPPED\_MAGIC} && 
278       \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_a53c161466b08f8aadc7ec382daf85add}{m\_magicNumber} != \hyperlink{namespacens3_aa3cf3e7390afab115718e01fb671fdb9}{NS\_MAGIC} && 
      \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_a53c161466b08f8aadc7ec382daf85add}{m\_magicNumber} != \hyperlink{namespacens3_a244fa8ad695b47f296e942ea5f0bb46b}{NS\_SWAPPED\_MAGIC})
279     \{
280       \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.setstate (std::ios::failbit);
281     \}
282 
283   \textcolor{comment}{//}
284   \textcolor{comment}{// If the magic number is swapped, then we can assume that everything else we read}
285   \textcolor{comment}{// is swapped.}
286   \textcolor{comment}{//}
287   \hyperlink{classns3_1_1PcapFile_a179acfdfb216038a20ddb8cdc5fe182d}{m\_swapMode} = (\hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_a53c161466b08f8aadc7ec382daf85add}{m\_magicNumber} == 
      \hyperlink{namespacens3_a687c5411ecbe4c7766c70c1226eef2d3}{SWAPPED\_MAGIC} 
288                 || \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_a53c161466b08f8aadc7ec382daf85add}{m\_magicNumber} == 
      \hyperlink{namespacens3_a244fa8ad695b47f296e942ea5f0bb46b}{NS\_SWAPPED\_MAGIC}) ? \textcolor{keyword}{true} : \textcolor{keyword}{false};
289 
290   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PcapFile_a179acfdfb216038a20ddb8cdc5fe182d}{m\_swapMode})
291     \{
292       \hyperlink{classns3_1_1PcapFile_af5adf22a721473f1add1e002492f5587}{Swap} (&\hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}, &\hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader});
293     \}
294 
295   \textcolor{comment}{//}
296   \textcolor{comment}{// Timestamps can either be microsecond or nanosecond}
297   \textcolor{comment}{//}
298   \hyperlink{classns3_1_1PcapFile_ac4c31785ef8fe52e33615f5ee33cacf8}{m\_nanosecMode} = ((\hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_a53c161466b08f8aadc7ec382daf85add}{m\_magicNumber} == 
      \hyperlink{namespacens3_aa3cf3e7390afab115718e01fb671fdb9}{NS\_MAGIC}) ||
299                    (\hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_a53c161466b08f8aadc7ec382daf85add}{m\_magicNumber} == 
      \hyperlink{namespacens3_a244fa8ad695b47f296e942ea5f0bb46b}{NS\_SWAPPED\_MAGIC})) ? \textcolor{keyword}{true} : \textcolor{keyword}{false};
300 
301   \textcolor{comment}{//}
302   \textcolor{comment}{// We only deal with one version of the pcap file format.}
303   \textcolor{comment}{//}
304   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_aad229620708f0556447252a2c737788d}{m\_versionMajor} != \hyperlink{namespacens3_ac952f36545c1876b7ea895dbd521afb9}{VERSION\_MAJOR} || 
      \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_afb6cdefec3947135b53c8bbe05628927}{m\_versionMinor} != \hyperlink{namespacens3_a8aab01f6e71af7830eedfec5ff333ef4}{VERSION\_MINOR})
305     \{
306       \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.setstate (std::ios::failbit);
307     \}
308 
309   \textcolor{comment}{//}
310   \textcolor{comment}{// A quick test of reasonablness for the time zone offset corresponding to }
311   \textcolor{comment}{// a real place on the planet.}
312   \textcolor{comment}{//}
313   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_aaa76da3051b3fe9cf8b37129d5510b1c}{m\_zone} < -12 || \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.
      \hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_aaa76da3051b3fe9cf8b37129d5510b1c}{m\_zone} > 12)
314     \{
315       \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.setstate (std::ios::failbit);
316     \}
317 
318   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.fail ())
319     \{
320       \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.close ();
321     \}
322 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 23




Here is the caller graph for this function\+:
% FIG 24


\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!Swap@{Swap}}
\index{Swap@{Swap}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{Swap(uint8\+\_\+t val)}{Swap(uint8_t val)}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::\+Pcap\+File\+::\+Swap (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{val}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PcapFile_af5adf22a721473f1add1e002492f5587}{}\label{classns3_1_1PcapFile_af5adf22a721473f1add1e002492f5587}


Swap a value byte order. 


\begin{DoxyParams}{Parameters}
{\em val} & the value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the value with byte order swapped 
\end{DoxyReturn}

\begin{DoxyCode}
159 \{
160   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << static\_cast<uint32\_t> (val));
161   \textcolor{keywordflow}{return} val;
162 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 25


\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!Swap@{Swap}}
\index{Swap@{Swap}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{Swap(uint16\+\_\+t val)}{Swap(uint16_t val)}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Pcap\+File\+::\+Swap (
\begin{DoxyParamCaption}
\item[{uint16\+\_\+t}]{val}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PcapFile_a626e8456233183d32aa229b53a629a43}{}\label{classns3_1_1PcapFile_a626e8456233183d32aa229b53a629a43}


Swap a value byte order. 


\begin{DoxyParams}{Parameters}
{\em val} & the value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the value with byte order swapped 
\end{DoxyReturn}

\begin{DoxyCode}
166 \{
167   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << val);
168   \textcolor{keywordflow}{return} ((val >> 8) & 0x00ff) | ((val << 8) & 0xff00);
169 \}
\end{DoxyCode}
\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!Swap@{Swap}}
\index{Swap@{Swap}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{Swap(uint32\+\_\+t val)}{Swap(uint32_t val)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Pcap\+File\+::\+Swap (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{val}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PcapFile_afe97f12e052ebd77a5c113c0d8f11d33}{}\label{classns3_1_1PcapFile_afe97f12e052ebd77a5c113c0d8f11d33}


Swap a value byte order. 


\begin{DoxyParams}{Parameters}
{\em val} & the value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the value with byte order swapped 
\end{DoxyReturn}

\begin{DoxyCode}
173 \{
174   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << val);
175   \textcolor{keywordflow}{return} ((val >> 24) & 0x000000ff) | ((val >> 8) & 0x0000ff00) | ((val << 8) & 0x00ff0000) | ((val << 24) 
      & 0xff000000);
176 \}
\end{DoxyCode}
\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!Swap@{Swap}}
\index{Swap@{Swap}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{Swap(\+Pcap\+File\+Header $\ast$from, Pcap\+File\+Header $\ast$to)}{Swap(PcapFileHeader *from, PcapFileHeader *to)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Pcap\+File\+::\+Swap (
\begin{DoxyParamCaption}
\item[{{\bf Pcap\+File\+Header} $\ast$}]{from, }
\item[{{\bf Pcap\+File\+Header} $\ast$}]{to}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PcapFile_a12aa14e48a7b27a43ea0ab8abffa4834}{}\label{classns3_1_1PcapFile_a12aa14e48a7b27a43ea0ab8abffa4834}


Swap the byte order of a Pcap file header. 


\begin{DoxyParams}{Parameters}
{\em from} & original file header \\
\hline
{\em to} & swapped file header \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
180 \{
181   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from} << to);
182   to->m\_magicNumber = \hyperlink{classns3_1_1PcapFile_af5adf22a721473f1add1e002492f5587}{Swap} (\hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from}->m\_magicNumber);
183   to->m\_versionMajor = \hyperlink{classns3_1_1PcapFile_af5adf22a721473f1add1e002492f5587}{Swap} (\hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from}->m\_versionMajor);
184   to->m\_versionMinor = \hyperlink{classns3_1_1PcapFile_af5adf22a721473f1add1e002492f5587}{Swap} (\hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from}->m\_versionMinor);
185   to->m\_zone = \hyperlink{classns3_1_1PcapFile_af5adf22a721473f1add1e002492f5587}{Swap} (uint32\_t (\hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from}->m\_zone));
186   to->m\_sigFigs = \hyperlink{classns3_1_1PcapFile_af5adf22a721473f1add1e002492f5587}{Swap} (\hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from}->m\_sigFigs);
187   to->m\_snapLen = \hyperlink{classns3_1_1PcapFile_af5adf22a721473f1add1e002492f5587}{Swap} (\hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from}->m\_snapLen);
188   to->m\_type = \hyperlink{classns3_1_1PcapFile_af5adf22a721473f1add1e002492f5587}{Swap} (\hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from}->m\_type);
189 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 26


\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!Swap@{Swap}}
\index{Swap@{Swap}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{Swap(\+Pcap\+Record\+Header $\ast$from, Pcap\+Record\+Header $\ast$to)}{Swap(PcapRecordHeader *from, PcapRecordHeader *to)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Pcap\+File\+::\+Swap (
\begin{DoxyParamCaption}
\item[{{\bf Pcap\+Record\+Header} $\ast$}]{from, }
\item[{{\bf Pcap\+Record\+Header} $\ast$}]{to}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PcapFile_af8cb5cf7b27cf92373709a577af671f4}{}\label{classns3_1_1PcapFile_af8cb5cf7b27cf92373709a577af671f4}


Swap the byte order of a Pcap record header. 


\begin{DoxyParams}{Parameters}
{\em from} & original record header \\
\hline
{\em to} & swapped record header \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
193 \{
194   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from} << to);
195   to->m\_tsSec = \hyperlink{classns3_1_1PcapFile_af5adf22a721473f1add1e002492f5587}{Swap} (\hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from}->m\_tsSec);
196   to->m\_tsUsec = \hyperlink{classns3_1_1PcapFile_af5adf22a721473f1add1e002492f5587}{Swap} (\hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from}->m\_tsUsec);
197   to->m\_inclLen = \hyperlink{classns3_1_1PcapFile_af5adf22a721473f1add1e002492f5587}{Swap} (\hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from}->m\_inclLen);
198   to->m\_origLen = \hyperlink{classns3_1_1PcapFile_af5adf22a721473f1add1e002492f5587}{Swap} (\hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from}->m\_origLen);
199 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 27


\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!Write@{Write}}
\index{Write@{Write}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{Write(uint32\+\_\+t ts\+Sec, uint32\+\_\+t ts\+Usec, uint8\+\_\+t const $\ast$const data, uint32\+\_\+t total\+Len)}{Write(uint32_t tsSec, uint32_t tsUsec, uint8_t const *const data, uint32_t totalLen)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Pcap\+File\+::\+Write (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{ts\+Sec, }
\item[{uint32\+\_\+t}]{ts\+Usec, }
\item[{uint8\+\_\+t const $\ast$const}]{data, }
\item[{uint32\+\_\+t}]{total\+Len}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PcapFile_a3920f5bae95ca0021875e6e9c2630ccf}{}\label{classns3_1_1PcapFile_a3920f5bae95ca0021875e6e9c2630ccf}


Write next packet to file. 


\begin{DoxyParams}{Parameters}
{\em ts\+Sec} & \hyperlink{classns3_1_1Packet}{Packet} timestamp, seconds \\
\hline
{\em ts\+Usec} & \hyperlink{classns3_1_1Packet}{Packet} timestamp, microseconds \\
\hline
{\em data} & Data buffer \\
\hline
{\em total\+Len} & Total packet length \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
435 \{
436   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << tsSec << tsUsec << &\hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data} << totalLen);
437   uint32\_t inclLen = \hyperlink{classns3_1_1PcapFile_a49675e170416ab1665fea6883250bda3}{WritePacketHeader} (tsSec, tsUsec, totalLen);
438   \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.write ((\textcolor{keyword}{const} \textcolor{keywordtype}{char} *)\hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data}, inclLen);
439   \hyperlink{build-profile_8h_a8f46d39331904495b189a130c099c029}{NS\_BUILD\_DEBUG}(\hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.flush());
440 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 28




Here is the caller graph for this function\+:
% FIG 29


\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!Write@{Write}}
\index{Write@{Write}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{Write(uint32\+\_\+t ts\+Sec, uint32\+\_\+t ts\+Usec, Ptr$<$ const Packet $>$ p)}{Write(uint32_t tsSec, uint32_t tsUsec, Ptr< const Packet > p)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Pcap\+File\+::\+Write (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{ts\+Sec, }
\item[{uint32\+\_\+t}]{ts\+Usec, }
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PcapFile_a6b334e0b95629bf0897949e33e54479d}{}\label{classns3_1_1PcapFile_a6b334e0b95629bf0897949e33e54479d}


Write next packet to file. 


\begin{DoxyParams}{Parameters}
{\em ts\+Sec} & \hyperlink{classns3_1_1Packet}{Packet} timestamp, seconds \\
\hline
{\em ts\+Usec} & \hyperlink{classns3_1_1Packet}{Packet} timestamp, microseconds \\
\hline
{\em p} & \hyperlink{classns3_1_1Packet}{Packet} to write \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
444 \{
445   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << tsSec << tsUsec << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p});
446   uint32\_t inclLen = \hyperlink{classns3_1_1PcapFile_a49675e170416ab1665fea6883250bda3}{WritePacketHeader} (tsSec, tsUsec, \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->GetSize ());
447   \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->CopyData (&\hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}, inclLen);
448   \hyperlink{build-profile_8h_a8f46d39331904495b189a130c099c029}{NS\_BUILD\_DEBUG}(\hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.flush());
449 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 30


\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!Write@{Write}}
\index{Write@{Write}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{Write(uint32\+\_\+t ts\+Sec, uint32\+\_\+t ts\+Usec, const Header \&header, Ptr$<$ const Packet $>$ p)}{Write(uint32_t tsSec, uint32_t tsUsec, const Header &header, Ptr< const Packet > p)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Pcap\+File\+::\+Write (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{ts\+Sec, }
\item[{uint32\+\_\+t}]{ts\+Usec, }
\item[{const {\bf Header} \&}]{header, }
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PcapFile_a057ede1e4feda72362d20d7f14c4e836}{}\label{classns3_1_1PcapFile_a057ede1e4feda72362d20d7f14c4e836}


Write next packet to file. 


\begin{DoxyParams}{Parameters}
{\em ts\+Sec} & \hyperlink{classns3_1_1Packet}{Packet} timestamp, seconds \\
\hline
{\em ts\+Usec} & \hyperlink{classns3_1_1Packet}{Packet} timestamp, microseconds \\
\hline
{\em header} & \hyperlink{classns3_1_1Header}{Header} to write, in front of packet \\
\hline
{\em p} & \hyperlink{classns3_1_1Packet}{Packet} to write \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
453 \{
454   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << tsSec << tsUsec << &header << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p});
455   uint32\_t headerSize = header.GetSerializedSize ();
456   uint32\_t totalSize = headerSize + \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->GetSize ();
457   uint32\_t inclLen = \hyperlink{classns3_1_1PcapFile_a49675e170416ab1665fea6883250bda3}{WritePacketHeader} (tsSec, tsUsec, totalSize);
458 
459   Buffer headerBuffer;
460   headerBuffer.AddAtStart (headerSize);
461   header.Serialize (headerBuffer.Begin ());
462   uint32\_t toCopy = \hyperlink{80211b_8c_ac6afabdc09a49a433ee19d8a9486056d}{std::min} (headerSize, inclLen);
463   headerBuffer.CopyData (&\hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}, toCopy);
464   inclLen -= toCopy;
465   \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->CopyData (&\hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}, inclLen);
466 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 31


\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!Write\+File\+Header@{Write\+File\+Header}}
\index{Write\+File\+Header@{Write\+File\+Header}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{Write\+File\+Header(void)}{WriteFileHeader(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Pcap\+File\+::\+Write\+File\+Header (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PcapFile_a58124715fdc400c4ae0ff1c3ba8215ab}{}\label{classns3_1_1PcapFile_a58124715fdc400c4ae0ff1c3ba8215ab}


Write a Pcap file header. 


\begin{DoxyCode}
203 \{
204   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
205   \textcolor{comment}{//}
206   \textcolor{comment}{// If we're initializing the file, we need to write the pcap file header}
207   \textcolor{comment}{// at the start of the file.}
208   \textcolor{comment}{//}
209   \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.seekp (0, std::ios::beg);
210  
211   \textcolor{comment}{//}
212   \textcolor{comment}{// We have the ability to write out the pcap file header in a foreign endian}
213   \textcolor{comment}{// format, so we need a temp place to swap on the way out.}
214   \textcolor{comment}{//}
215   PcapFileHeader header;
216 
217   \textcolor{comment}{//}
218   \textcolor{comment}{// the pointer headerOut selects either the swapped or non-swapped version of}
219   \textcolor{comment}{// the pcap file header.}
220   \textcolor{comment}{//}
221   PcapFileHeader *headerOut = 0;
222 
223   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PcapFile_a179acfdfb216038a20ddb8cdc5fe182d}{m\_swapMode} == \textcolor{keyword}{false})
224     \{
225       headerOut = &\hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader};
226     \}
227   \textcolor{keywordflow}{else}
228     \{
229       \hyperlink{classns3_1_1PcapFile_af5adf22a721473f1add1e002492f5587}{Swap} (&\hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}, &header);
230       headerOut = &header;
231     \}
232 
233   \textcolor{comment}{//}
234   \textcolor{comment}{// Watch out for memory alignment differences between machines, so write}
235   \textcolor{comment}{// them all individually.}
236   \textcolor{comment}{//}
237   \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.write ((\textcolor{keyword}{const} \textcolor{keywordtype}{char} *)&headerOut->m\_magicNumber, \textcolor{keyword}{sizeof}(headerOut->m\_magicNumber));
238   \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.write ((\textcolor{keyword}{const} \textcolor{keywordtype}{char} *)&headerOut->m\_versionMajor, \textcolor{keyword}{sizeof}(headerOut->m\_versionMajor));
239   \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.write ((\textcolor{keyword}{const} \textcolor{keywordtype}{char} *)&headerOut->m\_versionMinor, \textcolor{keyword}{sizeof}(headerOut->m\_versionMinor));
240   \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.write ((\textcolor{keyword}{const} \textcolor{keywordtype}{char} *)&headerOut->m\_zone, \textcolor{keyword}{sizeof}(headerOut->m\_zone));
241   \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.write ((\textcolor{keyword}{const} \textcolor{keywordtype}{char} *)&headerOut->m\_sigFigs, \textcolor{keyword}{sizeof}(headerOut->m\_sigFigs));
242   \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.write ((\textcolor{keyword}{const} \textcolor{keywordtype}{char} *)&headerOut->m\_snapLen, \textcolor{keyword}{sizeof}(headerOut->m\_snapLen));
243   \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.write ((\textcolor{keyword}{const} \textcolor{keywordtype}{char} *)&headerOut->m\_type, \textcolor{keyword}{sizeof}(headerOut->m\_type));
244 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 32




Here is the caller graph for this function\+:
% FIG 33


\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!Write\+Packet\+Header@{Write\+Packet\+Header}}
\index{Write\+Packet\+Header@{Write\+Packet\+Header}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{Write\+Packet\+Header(uint32\+\_\+t ts\+Sec, uint32\+\_\+t ts\+Usec, uint32\+\_\+t total\+Len)}{WritePacketHeader(uint32_t tsSec, uint32_t tsUsec, uint32_t totalLen)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Pcap\+File\+::\+Write\+Packet\+Header (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{ts\+Sec, }
\item[{uint32\+\_\+t}]{ts\+Usec, }
\item[{uint32\+\_\+t}]{total\+Len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PcapFile_a49675e170416ab1665fea6883250bda3}{}\label{classns3_1_1PcapFile_a49675e170416ab1665fea6883250bda3}


Write a Pcap packet header. 

The pcap header has a fixed length of 24 bytes. The last 4 bytes represent the link-\/layer type


\begin{DoxyParams}{Parameters}
{\em ts\+Sec} & \hyperlink{classns3_1_1Time}{Time} stamp (seconds part) \\
\hline
{\em ts\+Usec} & \hyperlink{classns3_1_1Time}{Time} stamp (microseconds part) \\
\hline
{\em total\+Len} & total packet length \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the length of the packet to write in the Pcap file 
\end{DoxyReturn}

\begin{DoxyCode}
404 \{
405   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << tsSec << tsUsec << totalLen);
406   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.good ());
407 
408   uint32\_t inclLen = totalLen > \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_acadba930824bddafabd88a0b3f5e3289}{m\_snapLen} ? 
      \hyperlink{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{m\_fileHeader}.\hyperlink{structns3_1_1PcapFile_1_1PcapFileHeader_acadba930824bddafabd88a0b3f5e3289}{m\_snapLen} : totalLen;
409 
410   PcapRecordHeader header;
411   header.m\_tsSec = tsSec;
412   header.m\_tsUsec = tsUsec;
413   header.m\_inclLen = inclLen;
414   header.m\_origLen = totalLen;
415 
416   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PcapFile_a179acfdfb216038a20ddb8cdc5fe182d}{m\_swapMode})
417     \{
418       \hyperlink{classns3_1_1PcapFile_af5adf22a721473f1add1e002492f5587}{Swap} (&header, &header);
419     \}
420 
421   \textcolor{comment}{//}
422   \textcolor{comment}{// Watch out for memory alignment differences between machines, so write}
423   \textcolor{comment}{// them all individually.}
424   \textcolor{comment}{//}
425   \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.write ((\textcolor{keyword}{const} \textcolor{keywordtype}{char} *)&header.m\_tsSec, \textcolor{keyword}{sizeof}(header.m\_tsSec));
426   \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.write ((\textcolor{keyword}{const} \textcolor{keywordtype}{char} *)&header.m\_tsUsec, \textcolor{keyword}{sizeof}(header.m\_tsUsec));
427   \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.write ((\textcolor{keyword}{const} \textcolor{keywordtype}{char} *)&header.m\_inclLen, \textcolor{keyword}{sizeof}(header.m\_inclLen));
428   \hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.write ((\textcolor{keyword}{const} \textcolor{keywordtype}{char} *)&header.m\_origLen, \textcolor{keyword}{sizeof}(header.m\_origLen));
429   \hyperlink{build-profile_8h_a8f46d39331904495b189a130c099c029}{NS\_BUILD\_DEBUG}(\hyperlink{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{m\_file}.flush());
430   \textcolor{keywordflow}{return} inclLen;
431 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 34




Here is the caller graph for this function\+:
% FIG 35




\subsection{Member Data Documentation}
\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!m\+\_\+file@{m\+\_\+file}}
\index{m\+\_\+file@{m\+\_\+file}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{m\+\_\+file}{m_file}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::fstream ns3\+::\+Pcap\+File\+::m\+\_\+file\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}{}\label{classns3_1_1PcapFile_ac8ecc2d37ff1e2a5148901e10f855c26}


file stream 

\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!m\+\_\+file\+Header@{m\+\_\+file\+Header}}
\index{m\+\_\+file\+Header@{m\+\_\+file\+Header}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{m\+\_\+file\+Header}{m_fileHeader}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pcap\+File\+Header} ns3\+::\+Pcap\+File\+::m\+\_\+file\+Header\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}{}\label{classns3_1_1PcapFile_a44261d9566e738203968f357584e268c}


file header 

\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!m\+\_\+filename@{m\+\_\+filename}}
\index{m\+\_\+filename@{m\+\_\+filename}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{m\+\_\+filename}{m_filename}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string ns3\+::\+Pcap\+File\+::m\+\_\+filename\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PcapFile_a352f69f3045f8e1ebbc42ab5ab540b68}{}\label{classns3_1_1PcapFile_a352f69f3045f8e1ebbc42ab5ab540b68}


file name 

\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!m\+\_\+nanosec\+Mode@{m\+\_\+nanosec\+Mode}}
\index{m\+\_\+nanosec\+Mode@{m\+\_\+nanosec\+Mode}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{m\+\_\+nanosec\+Mode}{m_nanosecMode}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Pcap\+File\+::m\+\_\+nanosec\+Mode\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PcapFile_ac4c31785ef8fe52e33615f5ee33cacf8}{}\label{classns3_1_1PcapFile_ac4c31785ef8fe52e33615f5ee33cacf8}


nanosecond timestamp mode 

\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!m\+\_\+swap\+Mode@{m\+\_\+swap\+Mode}}
\index{m\+\_\+swap\+Mode@{m\+\_\+swap\+Mode}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{m\+\_\+swap\+Mode}{m_swapMode}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Pcap\+File\+::m\+\_\+swap\+Mode\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PcapFile_a179acfdfb216038a20ddb8cdc5fe182d}{}\label{classns3_1_1PcapFile_a179acfdfb216038a20ddb8cdc5fe182d}


swap mode 

\index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!S\+N\+A\+P\+L\+E\+N\+\_\+\+D\+E\+F\+A\+U\+LT@{S\+N\+A\+P\+L\+E\+N\+\_\+\+D\+E\+F\+A\+U\+LT}}
\index{S\+N\+A\+P\+L\+E\+N\+\_\+\+D\+E\+F\+A\+U\+LT@{S\+N\+A\+P\+L\+E\+N\+\_\+\+D\+E\+F\+A\+U\+LT}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{S\+N\+A\+P\+L\+E\+N\+\_\+\+D\+E\+F\+A\+U\+LT}{SNAPLEN_DEFAULT}}]{\setlength{\rightskip}{0pt plus 5cm}const uint32\+\_\+t ns3\+::\+Pcap\+File\+::\+S\+N\+A\+P\+L\+E\+N\+\_\+\+D\+E\+F\+A\+U\+LT = 65535\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1PcapFile_ac5fda3d19b0cd0f85b0c151c2397681b}{}\label{classns3_1_1PcapFile_ac5fda3d19b0cd0f85b0c151c2397681b}
Default value for maximum octets to save per packet \index{ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}!Z\+O\+N\+E\+\_\+\+D\+E\+F\+A\+U\+LT@{Z\+O\+N\+E\+\_\+\+D\+E\+F\+A\+U\+LT}}
\index{Z\+O\+N\+E\+\_\+\+D\+E\+F\+A\+U\+LT@{Z\+O\+N\+E\+\_\+\+D\+E\+F\+A\+U\+LT}!ns3\+::\+Pcap\+File@{ns3\+::\+Pcap\+File}}
\subsubsection[{\texorpdfstring{Z\+O\+N\+E\+\_\+\+D\+E\+F\+A\+U\+LT}{ZONE_DEFAULT}}]{\setlength{\rightskip}{0pt plus 5cm}const int32\+\_\+t ns3\+::\+Pcap\+File\+::\+Z\+O\+N\+E\+\_\+\+D\+E\+F\+A\+U\+LT = 0\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1PcapFile_abd695588f972dc80b0c928aeda466dc0}{}\label{classns3_1_1PcapFile_abd695588f972dc80b0c928aeda466dc0}
\hyperlink{classns3_1_1Time}{Time} zone offset for current location 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
network/utils/\hyperlink{pcap-file_8h}{pcap-\/file.\+h}\item 
network/utils/\hyperlink{pcap-file_8cc}{pcap-\/file.\+cc}\end{DoxyCompactItemize}
