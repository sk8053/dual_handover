\hypertarget{classns3_1_1TcpRxBuffer}{}\section{ns3\+:\+:Tcp\+Rx\+Buffer Class Reference}
\label{classns3_1_1TcpRxBuffer}\index{ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}}


Rx reordering buffer for T\+CP.  




{\ttfamily \#include $<$tcp-\/rx-\/buffer.\+h$>$}



Inheritance diagram for ns3\+:\+:Tcp\+Rx\+Buffer\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Tcp\+Rx\+Buffer\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1TcpRxBuffer_ab6270bb83cc9464c2449597927da47c7}{Tcp\+Rx\+Buffer} (uint32\+\_\+t \hyperlink{lte__link__budget__x2__handover__measures_8m_abdb05bc5a064cf642a06c83b3392f148}{n}=0)
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1TcpRxBuffer_a5ad973f8754413579704c8862eb4db5f}{$\sim$\+Tcp\+Rx\+Buffer} ()
\item 
\hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{Sequence\+Number32} \hyperlink{classns3_1_1TcpRxBuffer_ae994bf90329d10f17b59d32907b04ca9}{Next\+Rx\+Sequence} (void) const 
\begin{DoxyCompactList}\small\item\em Get Next Rx Sequence number. \end{DoxyCompactList}\item 
\hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{Sequence\+Number32} \hyperlink{classns3_1_1TcpRxBuffer_aa3c228adbcfac38756f78490eab605d5}{Max\+Rx\+Sequence} (void) const 
\begin{DoxyCompactList}\small\item\em Get the lowest sequence number that this \hyperlink{classns3_1_1TcpRxBuffer}{Tcp\+Rx\+Buffer} cannot accept. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1TcpRxBuffer_aec0ff49f5d3f1b2d47dd9a9c004bda2c}{Inc\+Next\+Rx\+Sequence} (void)
\begin{DoxyCompactList}\small\item\em Increment the Next Sequence number. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1TcpRxBuffer_a6bba147c19d638ec455b208ccbcaafb4}{Set\+Next\+Rx\+Sequence} (const \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{Sequence\+Number32} \&\hyperlink{generate__test__data__lte__sinr_8m_ad83eeb3a142285d1243a08c6b7026df8}{s})
\begin{DoxyCompactList}\small\item\em Set the Next Sequence number. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1TcpRxBuffer_a37b57ebcf0d9f922439f4f872b198086}{Set\+Fin\+Sequence} (const \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{Sequence\+Number32} \&\hyperlink{generate__test__data__lte__sinr_8m_ad83eeb3a142285d1243a08c6b7026df8}{s})
\begin{DoxyCompactList}\small\item\em Set the F\+IN Sequence number (i.\+e., the one closing the connection) \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1TcpRxBuffer_a93a1a92164515bd951bad115444eac00}{Max\+Buffer\+Size} (void) const 
\begin{DoxyCompactList}\small\item\em Get the Maximum buffer size. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1TcpRxBuffer_a3b37c1b3b91aa2e6e812cba3c2575f75}{Set\+Max\+Buffer\+Size} (uint32\+\_\+t \hyperlink{generate__test__data__lte__sinr_8m_ad83eeb3a142285d1243a08c6b7026df8}{s})
\begin{DoxyCompactList}\small\item\em Set the Maximum buffer size. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1TcpRxBuffer_a51938b2cb6cd42c1beedd6f67385f599}{Size} (void) const 
\begin{DoxyCompactList}\small\item\em Get the actual buffer occupancy. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1TcpRxBuffer_ab89d1bfde21bc59f35a319328b606283}{Available} () const 
\begin{DoxyCompactList}\small\item\em Get the actual number of bytes available to be read. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1TcpRxBuffer_a7674e0a088b55b67a2310c40360b9ed6}{Finished} (void)
\begin{DoxyCompactList}\small\item\em Check if the buffer did receive all the data (and the connection is closed) \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1TcpRxBuffer_a35a036383b8976cb79738c28aa01d5d0}{Add} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1TcpHeader}{Tcp\+Header} const \&tcph)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{classns3_1_1TcpRxBuffer_a0a1254a5afa4cec6307a40af3ff46d30}{Extract} (uint32\+\_\+t max\+Size)
\item 
\hyperlink{classns3_1_1TcpOptionSack_a2aa2d721c71424680d79ebaa079f264a}{Tcp\+Option\+Sack\+::\+Sack\+List} \hyperlink{classns3_1_1TcpRxBuffer_afc5d672da4595330754de1bb3933a9c7}{Get\+Sack\+List} () const 
\begin{DoxyCompactList}\small\item\em Get the sack list. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1TcpRxBuffer_a45cf4c1e281f0e009cfdb3d0e0979436}{Get\+Sack\+List\+Size} () const 
\begin{DoxyCompactList}\small\item\em Get the size of Sack list. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1TcpRxBuffer_a8a130d844a17947fc541b4f94389306f}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
typedef std\+::map$<$ \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{Sequence\+Number32}, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$\+::iterator \hyperlink{classns3_1_1TcpRxBuffer_a6d8a168521cf993cc3dec893067dcb62}{Buf\+Iterator}
\begin{DoxyCompactList}\small\item\em container for data stored in the buffer \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classns3_1_1TcpRxBuffer_abd2afbae9205cd763f48a458d001d2d5}{Update\+Sack\+List} (const \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{Sequence\+Number32} \&head, const \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{Sequence\+Number32} \&tail)
\begin{DoxyCompactList}\small\item\em Update the sack list, with the block seq starting at the beginning. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1TcpRxBuffer_ad80e59250353c41c8866f6f02b82801c}{Clear\+Sack\+List} (const \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{Sequence\+Number32} \&seq)
\begin{DoxyCompactList}\small\item\em Remove old blocks from the sack list. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1TcpOptionSack_a2aa2d721c71424680d79ebaa079f264a}{Tcp\+Option\+Sack\+::\+Sack\+List} \hyperlink{classns3_1_1TcpRxBuffer_aee4aac20f3e96f9108918d3650e58eb9}{m\+\_\+sack\+List}
\begin{DoxyCompactList}\small\item\em Sack list (updated constantly) \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedValue}{Traced\+Value}$<$ \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{Sequence\+Number32} $>$ \hyperlink{classns3_1_1TcpRxBuffer_ab4390502dee7085dad4f7c3f9ef8796b}{m\+\_\+next\+Rx\+Seq}
\begin{DoxyCompactList}\small\item\em Seqnum of the first missing byte in data (R\+C\+V.\+N\+XT) \end{DoxyCompactList}\item 
\hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{Sequence\+Number32} \hyperlink{classns3_1_1TcpRxBuffer_a6f63b30eaef4dfcd219cbb9b31fc1a9d}{m\+\_\+fin\+Seq}
\begin{DoxyCompactList}\small\item\em Seqnum of the F\+IN packet. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1TcpRxBuffer_ad87a9d034dcc4150cacb5ec45c1883ae}{m\+\_\+got\+Fin}
\begin{DoxyCompactList}\small\item\em Did I received F\+IN packet? \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1TcpRxBuffer_ad76a9d93027823422039c92e85d5d4ea}{m\+\_\+size}
\begin{DoxyCompactList}\small\item\em Number of total data bytes in the buffer, not necessarily contiguous. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1TcpRxBuffer_a9889bd68e8bf6b250e0ee363ab30f457}{m\+\_\+max\+Buffer}
\begin{DoxyCompactList}\small\item\em Upper bound of the number of data bytes in buffer (R\+C\+V.\+W\+ND) \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1TcpRxBuffer_a700ba510c9ea3ef08f11baf0de7244dc}{m\+\_\+avail\+Bytes}
\begin{DoxyCompactList}\small\item\em Number of bytes available to read, i.\+e. contiguous block at head. \end{DoxyCompactList}\item 
std\+::map$<$ \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{Sequence\+Number32}, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1TcpRxBuffer_a695c34ebc7bd328b49c507f101257aed}{m\+\_\+data}
\begin{DoxyCompactList}\small\item\em Corresponding data (may be null) \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Rx reordering buffer for T\+CP. 

The class is responsible to safely store the segments, and then returning them in-\/order to the application, where \char`\"{}in-\/order\char`\"{} does not means \char`\"{}network-\/order\char`\"{}, but \char`\"{}sender-\/order\char`\"{} \+: the bytes should be returned in the same order that the sender application used to push them down on wire.

The first useful sequence that this class is waiting is returned by the method Next\+Rx\+Sequence, and could be set at the beginning through Max\+Rx\+Sequence.

The max. size of this buffer is managed through Set\+Max\+Buffer\+Size, and could be retrieved using Max\+Buffer\+Size. The current size instead is returned by Size, while the amount of in-\/order data that could be extracted is returned by the method Available.

To store data, use Add; for retrieving a certain amount of ordered data, use the method Extract.

\subsubsection*{S\+A\+CK list }

An interesting feature of this class is the ability to mantain an ordered S\+A\+CK list, under the definition of R\+FC 2018. When a out-\/of-\/order segment reaches this buffer, an A\+CK will be sent out, and the S\+A\+CK list is generated or updated. From R\+FC 2018\+:

\begin{quote}
If sent at all, S\+A\+CK options S\+H\+O\+U\+LD be included in all A\+C\+Ks which do not A\+CK the highest sequence number in the data receiver\textquotesingle{}s queue. \end{quote}


For more information about the S\+A\+CK list, please check the documentation of the method Get\+Sack\+List.

\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1TcpRxBuffer_afc5d672da4595330754de1bb3933a9c7}{Get\+Sack\+List} 

\hyperlink{classns3_1_1TcpRxBuffer_abd2afbae9205cd763f48a458d001d2d5}{Update\+Sack\+List} 
\end{DoxySeeAlso}


\subsection{Member Typedef Documentation}
\index{ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}!Buf\+Iterator@{Buf\+Iterator}}
\index{Buf\+Iterator@{Buf\+Iterator}!ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}}
\subsubsection[{\texorpdfstring{Buf\+Iterator}{BufIterator}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::map$<${\bf Sequence\+Number32}, {\bf Ptr}$<${\bf Packet}$>$ $>$\+::iterator {\bf ns3\+::\+Tcp\+Rx\+Buffer\+::\+Buf\+Iterator}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpRxBuffer_a6d8a168521cf993cc3dec893067dcb62}{}\label{classns3_1_1TcpRxBuffer_a6d8a168521cf993cc3dec893067dcb62}


container for data stored in the buffer 



\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}!Tcp\+Rx\+Buffer@{Tcp\+Rx\+Buffer}}
\index{Tcp\+Rx\+Buffer@{Tcp\+Rx\+Buffer}!ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}}
\subsubsection[{\texorpdfstring{Tcp\+Rx\+Buffer(uint32\+\_\+t n=0)}{TcpRxBuffer(uint32_t n=0)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Tcp\+Rx\+Buffer\+::\+Tcp\+Rx\+Buffer (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{n = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpRxBuffer_ab6270bb83cc9464c2449597927da47c7}{}\label{classns3_1_1TcpRxBuffer_ab6270bb83cc9464c2449597927da47c7}


Constructor. 


\begin{DoxyParams}{Parameters}
{\em n} & initial Sequence number to be received \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
55   : \hyperlink{classns3_1_1TcpRxBuffer_ab4390502dee7085dad4f7c3f9ef8796b}{m\_nextRxSeq} (\hyperlink{namespacesample-rng-plot_aeb5ee5c431e338ef39b7ac5431242e1d}{n}), \hyperlink{classns3_1_1TcpRxBuffer_ad87a9d034dcc4150cacb5ec45c1883ae}{m\_gotFin} (\textcolor{keyword}{false}), \hyperlink{classns3_1_1TcpRxBuffer_ad76a9d93027823422039c92e85d5d4ea}{m\_size} (0), 
      \hyperlink{classns3_1_1TcpRxBuffer_a9889bd68e8bf6b250e0ee363ab30f457}{m\_maxBuffer} (32768), \hyperlink{classns3_1_1TcpRxBuffer_a700ba510c9ea3ef08f11baf0de7244dc}{m\_availBytes} (0)
56 \{
57 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}!````~Tcp\+Rx\+Buffer@{$\sim$\+Tcp\+Rx\+Buffer}}
\index{````~Tcp\+Rx\+Buffer@{$\sim$\+Tcp\+Rx\+Buffer}!ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}}
\subsubsection[{\texorpdfstring{$\sim$\+Tcp\+Rx\+Buffer()}{~TcpRxBuffer()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Tcp\+Rx\+Buffer\+::$\sim$\+Tcp\+Rx\+Buffer (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TcpRxBuffer_a5ad973f8754413579704c8862eb4db5f}{}\label{classns3_1_1TcpRxBuffer_a5ad973f8754413579704c8862eb4db5f}

\begin{DoxyCode}
60 \{
61 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}!Add@{Add}}
\index{Add@{Add}!ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}}
\subsubsection[{\texorpdfstring{Add(\+Ptr$<$ Packet $>$ p, Tcp\+Header const \&tcph)}{Add(Ptr< Packet > p, TcpHeader const &tcph)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Tcp\+Rx\+Buffer\+::\+Add (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{{\bf Tcp\+Header} const \&}]{tcph}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpRxBuffer_a35a036383b8976cb79738c28aa01d5d0}{}\label{classns3_1_1TcpRxBuffer_a35a036383b8976cb79738c28aa01d5d0}
Insert a packet into the buffer and update the avail\+Bytes counter to reflect the number of bytes ready to send to the application. This function handles overlap by triming the head of the inputted packet and removing data from the buffer that overlaps the tail of the inputted packet


\begin{DoxyParams}{Parameters}
{\em p} & packet \\
\hline
{\em tcph} & packet\textquotesingle{}s T\+CP header \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True when success, false otherwise. 
\end{DoxyReturn}

\begin{DoxyCode}
142 \{
143   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << p << tcph);
144 
145   uint32\_t pktSize = p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ();
146   \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} headSeq = tcph.GetSequenceNumber ();
147   \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} tailSeq = headSeq + \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} (pktSize);
148   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Add pkt "} << p << \textcolor{stringliteral}{" len="} << pktSize << \textcolor{stringliteral}{" seq="} << headSeq
149                            << \textcolor{stringliteral}{", when NextRxSeq="} << \hyperlink{classns3_1_1TcpRxBuffer_ab4390502dee7085dad4f7c3f9ef8796b}{m\_nextRxSeq} << \textcolor{stringliteral}{", buffsize="} << 
      \hyperlink{classns3_1_1TcpRxBuffer_ad76a9d93027823422039c92e85d5d4ea}{m\_size});
150 
151   \textcolor{comment}{// Trim packet to fit Rx window specification}
152   \textcolor{keywordflow}{if} (headSeq < \hyperlink{classns3_1_1TcpRxBuffer_ab4390502dee7085dad4f7c3f9ef8796b}{m\_nextRxSeq}) headSeq = \hyperlink{classns3_1_1TcpRxBuffer_ab4390502dee7085dad4f7c3f9ef8796b}{m\_nextRxSeq};
153   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TcpRxBuffer_a695c34ebc7bd328b49c507f101257aed}{m\_data}.size ())
154     \{
155       \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} maxSeq = \hyperlink{classns3_1_1TcpRxBuffer_a695c34ebc7bd328b49c507f101257aed}{m\_data}.begin ()->first + 
      \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} (\hyperlink{classns3_1_1TcpRxBuffer_a9889bd68e8bf6b250e0ee363ab30f457}{m\_maxBuffer});
156       \textcolor{keywordflow}{if} (maxSeq < tailSeq) tailSeq = maxSeq;
157       \textcolor{keywordflow}{if} (tailSeq < headSeq) headSeq = tailSeq;
158     \}
159   \textcolor{comment}{// Remove overlapped bytes from packet}
160   \hyperlink{classns3_1_1TcpRxBuffer_a6d8a168521cf993cc3dec893067dcb62}{BufIterator} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1TcpRxBuffer_a695c34ebc7bd328b49c507f101257aed}{m\_data}.begin ();
161   \textcolor{keywordflow}{while} (i != \hyperlink{classns3_1_1TcpRxBuffer_a695c34ebc7bd328b49c507f101257aed}{m\_data}.end () && i->first <= tailSeq)
162     \{
163       \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} lastByteSeq = i->first + \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} (i->second
      ->GetSize ());
164       \textcolor{keywordflow}{if} (lastByteSeq > headSeq)
165         \{
166           \textcolor{keywordflow}{if} (i->first > headSeq && lastByteSeq < tailSeq)
167             \{ \textcolor{comment}{// Rare case: Existing packet is embedded fully in the new packet}
168               \hyperlink{classns3_1_1TcpRxBuffer_ad76a9d93027823422039c92e85d5d4ea}{m\_size} -= i->second->GetSize ();
169               \hyperlink{classns3_1_1TcpRxBuffer_a695c34ebc7bd328b49c507f101257aed}{m\_data}.erase (i++);
170               \textcolor{keywordflow}{continue};
171             \}
172           \textcolor{keywordflow}{if} (i->first <= headSeq)
173             \{ \textcolor{comment}{// Incoming head is overlapped}
174               headSeq = lastByteSeq;
175             \}
176           \textcolor{keywordflow}{if} (lastByteSeq >= tailSeq)
177             \{ \textcolor{comment}{// Incoming tail is overlapped}
178               tailSeq = i->first;
179             \}
180         \}
181       ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
182     \}
183   \textcolor{comment}{// We now know how much we are going to store, trim the packet}
184   \textcolor{keywordflow}{if} (headSeq >= tailSeq)
185     \{
186       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Nothing to buffer"});
187       \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \textcolor{comment}{// Nothing to buffer anyway}
188     \}
189   \textcolor{keywordflow}{else}
190     \{
191       uint32\_t \hyperlink{namespacevisualizer_1_1core_a2a35e5d8a34af358b508dac8635754e0}{start} = headSeq - tcph.GetSequenceNumber ();
192       uint32\_t length = tailSeq - headSeq;
193       p = p->\hyperlink{classns3_1_1Packet_a16f6113606b355b2b346e2245fa2a3d0}{CreateFragment} (start, length);
194       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (length == p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ());
195     \}
196   \textcolor{comment}{// Insert packet into buffer}
197   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1TcpRxBuffer_a695c34ebc7bd328b49c507f101257aed}{m\_data}.find (headSeq) == \hyperlink{classns3_1_1TcpRxBuffer_a695c34ebc7bd328b49c507f101257aed}{m\_data}.end ()); \textcolor{comment}{// Shouldn't be there yet}
198   \hyperlink{classns3_1_1TcpRxBuffer_a695c34ebc7bd328b49c507f101257aed}{m\_data} [ headSeq ] = \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p};
199 
200   \textcolor{keywordflow}{if} (headSeq > \hyperlink{classns3_1_1TcpRxBuffer_ab4390502dee7085dad4f7c3f9ef8796b}{m\_nextRxSeq})
201     \{
202       \textcolor{comment}{// Generate a new SACK block}
203       \hyperlink{classns3_1_1TcpRxBuffer_abd2afbae9205cd763f48a458d001d2d5}{UpdateSackList} (headSeq, tailSeq);
204     \}
205 
206   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Buffered packet of seqno="} << headSeq << \textcolor{stringliteral}{" len="} << p->
      \hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ());
207   \textcolor{comment}{// Update variables}
208   \hyperlink{classns3_1_1TcpRxBuffer_ad76a9d93027823422039c92e85d5d4ea}{m\_size} += p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ();      \textcolor{comment}{// Occupancy}
209   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1TcpRxBuffer_a6d8a168521cf993cc3dec893067dcb62}{BufIterator} i = m\_data.begin (); i != m\_data.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
210     \{
211       \textcolor{keywordflow}{if} (i->first < \hyperlink{classns3_1_1TcpRxBuffer_ab4390502dee7085dad4f7c3f9ef8796b}{m\_nextRxSeq})
212         \{
213           \textcolor{keywordflow}{continue};
214         \}
215       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (i->first > \hyperlink{classns3_1_1TcpRxBuffer_ab4390502dee7085dad4f7c3f9ef8796b}{m\_nextRxSeq})
216         \{
217           \textcolor{keywordflow}{break};
218         \};
219       \hyperlink{classns3_1_1TcpRxBuffer_ab4390502dee7085dad4f7c3f9ef8796b}{m\_nextRxSeq} = i->first + \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} (i->second->GetSize ());
220       \hyperlink{classns3_1_1TcpRxBuffer_a700ba510c9ea3ef08f11baf0de7244dc}{m\_availBytes} += i->second->GetSize ();
221       \hyperlink{classns3_1_1TcpRxBuffer_ad80e59250353c41c8866f6f02b82801c}{ClearSackList} (\hyperlink{classns3_1_1TcpRxBuffer_ab4390502dee7085dad4f7c3f9ef8796b}{m\_nextRxSeq});
222     \}
223   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Updated buffer occupancy="} << m\_size << \textcolor{stringliteral}{" nextRxSeq="} << 
      \hyperlink{classns3_1_1TcpRxBuffer_ab4390502dee7085dad4f7c3f9ef8796b}{m\_nextRxSeq});
224   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TcpRxBuffer_ad87a9d034dcc4150cacb5ec45c1883ae}{m\_gotFin} && \hyperlink{classns3_1_1TcpRxBuffer_ab4390502dee7085dad4f7c3f9ef8796b}{m\_nextRxSeq} == \hyperlink{classns3_1_1TcpRxBuffer_a6f63b30eaef4dfcd219cbb9b31fc1a9d}{m\_finSeq})
225     \{ \textcolor{comment}{// Account for the FIN packet}
226       ++\hyperlink{classns3_1_1TcpRxBuffer_ab4390502dee7085dad4f7c3f9ef8796b}{m\_nextRxSeq};
227     \};
228   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
229 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2




Here is the caller graph for this function\+:
% FIG 3


\index{ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}!Available@{Available}}
\index{Available@{Available}!ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}}
\subsubsection[{\texorpdfstring{Available() const }{Available() const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Tcp\+Rx\+Buffer\+::\+Available (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1TcpRxBuffer_ab89d1bfde21bc59f35a319328b606283}{}\label{classns3_1_1TcpRxBuffer_ab89d1bfde21bc59f35a319328b606283}


Get the actual number of bytes available to be read. 

\begin{DoxyReturn}{Returns}
size of available data (in bytes) 
\end{DoxyReturn}

\begin{DoxyCode}
95 \{
96   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpRxBuffer_a700ba510c9ea3ef08f11baf0de7244dc}{m\_availBytes};
97 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}!Clear\+Sack\+List@{Clear\+Sack\+List}}
\index{Clear\+Sack\+List@{Clear\+Sack\+List}!ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}}
\subsubsection[{\texorpdfstring{Clear\+Sack\+List(const Sequence\+Number32 \&seq)}{ClearSackList(const SequenceNumber32 &seq)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+Rx\+Buffer\+::\+Clear\+Sack\+List (
\begin{DoxyParamCaption}
\item[{const {\bf Sequence\+Number32} \&}]{seq}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpRxBuffer_ad80e59250353c41c8866f6f02b82801c}{}\label{classns3_1_1TcpRxBuffer_ad80e59250353c41c8866f6f02b82801c}


Remove old blocks from the sack list. 

Used to remove blocks already delivered to the application.

After this call, in the S\+A\+CK list there will be only blocks with sequence numbers greater than seq; it is perfectly safe to call this function with an empty sack list.


\begin{DoxyParams}{Parameters}
{\em seq} & Last sequence to remove \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
338 \{
339   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << seq);
340 
341   TcpOptionSack::SackList::iterator it;
342   \textcolor{keywordflow}{for} (it = \hyperlink{classns3_1_1TcpRxBuffer_aee4aac20f3e96f9108918d3650e58eb9}{m\_sackList}.begin (); it != \hyperlink{classns3_1_1TcpRxBuffer_aee4aac20f3e96f9108918d3650e58eb9}{m\_sackList}.end (); ++it)
343     \{
344       \hyperlink{classns3_1_1TcpOptionSack_a9e1d07d8729fd3ac5ead7305794675c3}{TcpOptionSack::SackBlock} block = *it;
345       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (block.first < block.second);
346 
347       \textcolor{keywordflow}{if} (block.second <= seq)
348         \{
349           it = \hyperlink{classns3_1_1TcpRxBuffer_aee4aac20f3e96f9108918d3650e58eb9}{m\_sackList}.erase (it);
350         \}
351     \}
352 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}!Extract@{Extract}}
\index{Extract@{Extract}!ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}}
\subsubsection[{\texorpdfstring{Extract(uint32\+\_\+t max\+Size)}{Extract(uint32_t maxSize)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Packet} $>$ ns3\+::\+Tcp\+Rx\+Buffer\+::\+Extract (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{max\+Size}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpRxBuffer_a0a1254a5afa4cec6307a40af3ff46d30}{}\label{classns3_1_1TcpRxBuffer_a0a1254a5afa4cec6307a40af3ff46d30}
Extract data from the head of the buffer as indicated by next\+Rx\+Seq. The extracted data is going to be forwarded to the application.


\begin{DoxyParams}{Parameters}
{\em max\+Size} & maximum number of bytes to extract \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a packet 
\end{DoxyReturn}

\begin{DoxyCode}
362 \{
363   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << maxSize);
364 
365   uint32\_t extractSize = \hyperlink{80211b_8c_ac6afabdc09a49a433ee19d8a9486056d}{std::min} (maxSize, \hyperlink{classns3_1_1TcpRxBuffer_a700ba510c9ea3ef08f11baf0de7244dc}{m\_availBytes});
366   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Requested to extract "} << extractSize << \textcolor{stringliteral}{" bytes from TcpRxBuffer of size="} <<
       \hyperlink{classns3_1_1TcpRxBuffer_ad76a9d93027823422039c92e85d5d4ea}{m\_size});
367   \textcolor{keywordflow}{if} (extractSize == 0) \textcolor{keywordflow}{return} 0;  \textcolor{comment}{// No contiguous block to return}
368   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1TcpRxBuffer_a695c34ebc7bd328b49c507f101257aed}{m\_data}.size ()); \textcolor{comment}{// At least we have something to extract}
369   Ptr<Packet> outPkt = Create<Packet> (); \textcolor{comment}{// The packet that contains all the data to return}
370   \hyperlink{classns3_1_1TcpRxBuffer_a6d8a168521cf993cc3dec893067dcb62}{BufIterator} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
371   \textcolor{keywordflow}{while} (extractSize)
372     \{ \textcolor{comment}{// Check the buffered data for delivery}
373       i = \hyperlink{classns3_1_1TcpRxBuffer_a695c34ebc7bd328b49c507f101257aed}{m\_data}.begin ();
374       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (i->first <= \hyperlink{classns3_1_1TcpRxBuffer_ab4390502dee7085dad4f7c3f9ef8796b}{m\_nextRxSeq}); \textcolor{comment}{// in-sequence data expected}
375       \textcolor{comment}{// Check if we send the whole pkt or just a partial}
376       uint32\_t pktSize = i->second->GetSize ();
377       \textcolor{keywordflow}{if} (pktSize <= extractSize)
378         \{ \textcolor{comment}{// Whole packet is extracted}
379           outPkt->AddAtEnd (i->second);
380           \hyperlink{classns3_1_1TcpRxBuffer_a695c34ebc7bd328b49c507f101257aed}{m\_data}.erase (i);
381           \hyperlink{classns3_1_1TcpRxBuffer_ad76a9d93027823422039c92e85d5d4ea}{m\_size} -= pktSize;
382           \hyperlink{classns3_1_1TcpRxBuffer_a700ba510c9ea3ef08f11baf0de7244dc}{m\_availBytes} -= pktSize;
383           extractSize -= pktSize;
384         \}
385       \textcolor{keywordflow}{else}
386         \{ \textcolor{comment}{// Partial is extracted and done}
387           outPkt->AddAtEnd (i->second->CreateFragment (0, extractSize));
388           \hyperlink{classns3_1_1TcpRxBuffer_a695c34ebc7bd328b49c507f101257aed}{m\_data}[i->first + \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} (extractSize)] = i->second->
      CreateFragment (extractSize, pktSize - extractSize);
389           \hyperlink{classns3_1_1TcpRxBuffer_a695c34ebc7bd328b49c507f101257aed}{m\_data}.erase (i);
390           \hyperlink{classns3_1_1TcpRxBuffer_ad76a9d93027823422039c92e85d5d4ea}{m\_size} -= extractSize;
391           \hyperlink{classns3_1_1TcpRxBuffer_a700ba510c9ea3ef08f11baf0de7244dc}{m\_availBytes} -= extractSize;
392           extractSize = 0;
393         \}
394     \}
395   \textcolor{keywordflow}{if} (outPkt->GetSize () == 0)
396     \{
397       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Nothing extracted."});
398       \textcolor{keywordflow}{return} 0;
399     \}
400   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Extracted "} << outPkt->GetSize ( ) << \textcolor{stringliteral}{" bytes, bufsize="} << 
      \hyperlink{classns3_1_1TcpRxBuffer_ad76a9d93027823422039c92e85d5d4ea}{m\_size}
401                              << \textcolor{stringliteral}{", num pkts in buffer="} << \hyperlink{classns3_1_1TcpRxBuffer_a695c34ebc7bd328b49c507f101257aed}{m\_data}.size ());
402   \textcolor{keywordflow}{return} outPkt;
403 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}!Finished@{Finished}}
\index{Finished@{Finished}!ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}}
\subsubsection[{\texorpdfstring{Finished(void)}{Finished(void)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Tcp\+Rx\+Buffer\+::\+Finished (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpRxBuffer_a7674e0a088b55b67a2310c40360b9ed6}{}\label{classns3_1_1TcpRxBuffer_a7674e0a088b55b67a2310c40360b9ed6}


Check if the buffer did receive all the data (and the connection is closed) 

\begin{DoxyReturn}{Returns}
true if all data have been received 
\end{DoxyReturn}

\begin{DoxyCode}
136 \{
137   \textcolor{keywordflow}{return} (\hyperlink{classns3_1_1TcpRxBuffer_ad87a9d034dcc4150cacb5ec45c1883ae}{m\_gotFin} && \hyperlink{classns3_1_1TcpRxBuffer_a6f63b30eaef4dfcd219cbb9b31fc1a9d}{m\_finSeq} < \hyperlink{classns3_1_1TcpRxBuffer_ab4390502dee7085dad4f7c3f9ef8796b}{m\_nextRxSeq});
138 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}!Get\+Sack\+List@{Get\+Sack\+List}}
\index{Get\+Sack\+List@{Get\+Sack\+List}!ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}}
\subsubsection[{\texorpdfstring{Get\+Sack\+List() const }{GetSackList() const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tcp\+Option\+Sack\+::\+Sack\+List} ns3\+::\+Tcp\+Rx\+Buffer\+::\+Get\+Sack\+List (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1TcpRxBuffer_afc5d672da4595330754de1bb3933a9c7}{}\label{classns3_1_1TcpRxBuffer_afc5d672da4595330754de1bb3933a9c7}


Get the sack list. 

The sack list can be empty, and it is updated each time Add or Extract are called through the private method Update\+Sack\+List.

\begin{DoxyReturn}{Returns}
a list of isolated blocks 
\end{DoxyReturn}

\begin{DoxyCode}
356 \{
357   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpRxBuffer_aee4aac20f3e96f9108918d3650e58eb9}{m\_sackList};
358 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}!Get\+Sack\+List\+Size@{Get\+Sack\+List\+Size}}
\index{Get\+Sack\+List\+Size@{Get\+Sack\+List\+Size}!ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}}
\subsubsection[{\texorpdfstring{Get\+Sack\+List\+Size() const }{GetSackListSize() const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Tcp\+Rx\+Buffer\+::\+Get\+Sack\+List\+Size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1TcpRxBuffer_a45cf4c1e281f0e009cfdb3d0e0979436}{}\label{classns3_1_1TcpRxBuffer_a45cf4c1e281f0e009cfdb3d0e0979436}


Get the size of Sack list. 

\begin{DoxyReturn}{Returns}
the size of the sack block list; can be empty 
\end{DoxyReturn}

\begin{DoxyCode}
233 \{
234   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
235 
236   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpRxBuffer_aee4aac20f3e96f9108918d3650e58eb9}{m\_sackList}.size ();
237 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Tcp\+Rx\+Buffer\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1TcpRxBuffer_a8a130d844a17947fc541b4f94389306f}{}\label{classns3_1_1TcpRxBuffer_a8a130d844a17947fc541b4f94389306f}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
34 \{
35   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::TcpRxBuffer"})
36     .SetParent<\hyperlink{classns3_1_1Object_a40860402e64d8008fb42329df7097cdb}{Object}> ()
37     .SetGroupName (\textcolor{stringliteral}{"Internet"})
38     .AddConstructor<\hyperlink{classns3_1_1TcpRxBuffer_ab6270bb83cc9464c2449597927da47c7}{TcpRxBuffer}> ()
39     .AddTraceSource (\textcolor{stringliteral}{"NextRxSequence"},
40                      \textcolor{stringliteral}{"Next sequence number expected (RCV.NXT)"},
41                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1TcpRxBuffer_ab4390502dee7085dad4f7c3f9ef8796b}{TcpRxBuffer::m\_nextRxSeq}),
42                      \textcolor{stringliteral}{"ns3::SequenceNumber32TracedValueCallback"})
43   ;
44   \textcolor{keywordflow}{return} tid;
45 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6


\index{ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}!Inc\+Next\+Rx\+Sequence@{Inc\+Next\+Rx\+Sequence}}
\index{Inc\+Next\+Rx\+Sequence@{Inc\+Next\+Rx\+Sequence}!ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}}
\subsubsection[{\texorpdfstring{Inc\+Next\+Rx\+Sequence(void)}{IncNextRxSequence(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+Rx\+Buffer\+::\+Inc\+Next\+Rx\+Sequence (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpRxBuffer_aec0ff49f5d3f1b2d47dd9a9c004bda2c}{}\label{classns3_1_1TcpRxBuffer_aec0ff49f5d3f1b2d47dd9a9c004bda2c}


Increment the Next Sequence number. 


\begin{DoxyCode}
101 \{
102   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
103   \textcolor{comment}{// Increment nextRxSeq is valid only if we don't have any data buffered,}
104   \textcolor{comment}{// this is supposed to be called only during the three-way handshake}
105   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1TcpRxBuffer_ad76a9d93027823422039c92e85d5d4ea}{m\_size} == 0);
106   \hyperlink{classns3_1_1TcpRxBuffer_ab4390502dee7085dad4f7c3f9ef8796b}{m\_nextRxSeq}++;
107 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}!Max\+Buffer\+Size@{Max\+Buffer\+Size}}
\index{Max\+Buffer\+Size@{Max\+Buffer\+Size}!ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}}
\subsubsection[{\texorpdfstring{Max\+Buffer\+Size(void) const }{MaxBufferSize(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Tcp\+Rx\+Buffer\+::\+Max\+Buffer\+Size (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1TcpRxBuffer_a93a1a92164515bd951bad115444eac00}{}\label{classns3_1_1TcpRxBuffer_a93a1a92164515bd951bad115444eac00}


Get the Maximum buffer size. 

\begin{DoxyReturn}{Returns}
the Maximum buffer size 
\end{DoxyReturn}

\begin{DoxyCode}
77 \{
78   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpRxBuffer_a9889bd68e8bf6b250e0ee363ab30f457}{m\_maxBuffer};
79 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}!Max\+Rx\+Sequence@{Max\+Rx\+Sequence}}
\index{Max\+Rx\+Sequence@{Max\+Rx\+Sequence}!ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}}
\subsubsection[{\texorpdfstring{Max\+Rx\+Sequence(void) const }{MaxRxSequence(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Sequence\+Number32} ns3\+::\+Tcp\+Rx\+Buffer\+::\+Max\+Rx\+Sequence (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1TcpRxBuffer_aa3c228adbcfac38756f78490eab605d5}{}\label{classns3_1_1TcpRxBuffer_aa3c228adbcfac38756f78490eab605d5}


Get the lowest sequence number that this \hyperlink{classns3_1_1TcpRxBuffer}{Tcp\+Rx\+Buffer} cannot accept. 

\begin{DoxyReturn}{Returns}
the lowest sequence number that this \hyperlink{classns3_1_1TcpRxBuffer}{Tcp\+Rx\+Buffer} cannot accept 
\end{DoxyReturn}

\begin{DoxyCode}
112 \{
113   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TcpRxBuffer_ad87a9d034dcc4150cacb5ec45c1883ae}{m\_gotFin})
114     \{ \textcolor{comment}{// No data allowed beyond FIN}
115       \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpRxBuffer_a6f63b30eaef4dfcd219cbb9b31fc1a9d}{m\_finSeq};
116     \}
117   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TcpRxBuffer_a695c34ebc7bd328b49c507f101257aed}{m\_data}.size () && \hyperlink{classns3_1_1TcpRxBuffer_ab4390502dee7085dad4f7c3f9ef8796b}{m\_nextRxSeq} > \hyperlink{classns3_1_1TcpRxBuffer_a695c34ebc7bd328b49c507f101257aed}{m\_data}.begin ()->first)
118     \{ \textcolor{comment}{// No data allowed beyond Rx window allowed}
119       \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpRxBuffer_a695c34ebc7bd328b49c507f101257aed}{m\_data}.begin ()->first + \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} (
      \hyperlink{classns3_1_1TcpRxBuffer_a9889bd68e8bf6b250e0ee363ab30f457}{m\_maxBuffer});
120     \}
121   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpRxBuffer_ab4390502dee7085dad4f7c3f9ef8796b}{m\_nextRxSeq} + \hyperlink{group__network_gacb2070e4e98d2d5135c9bede58f07a03}{SequenceNumber32} (\hyperlink{classns3_1_1TcpRxBuffer_a9889bd68e8bf6b250e0ee363ab30f457}{m\_maxBuffer});
122 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}!Next\+Rx\+Sequence@{Next\+Rx\+Sequence}}
\index{Next\+Rx\+Sequence@{Next\+Rx\+Sequence}!ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}}
\subsubsection[{\texorpdfstring{Next\+Rx\+Sequence(void) const }{NextRxSequence(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Sequence\+Number32} ns3\+::\+Tcp\+Rx\+Buffer\+::\+Next\+Rx\+Sequence (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1TcpRxBuffer_ae994bf90329d10f17b59d32907b04ca9}{}\label{classns3_1_1TcpRxBuffer_ae994bf90329d10f17b59d32907b04ca9}


Get Next Rx Sequence number. 

\begin{DoxyReturn}{Returns}
Next Rx Sequence number 
\end{DoxyReturn}

\begin{DoxyCode}
65 \{
66   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpRxBuffer_ab4390502dee7085dad4f7c3f9ef8796b}{m\_nextRxSeq};
67 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}!Set\+Fin\+Sequence@{Set\+Fin\+Sequence}}
\index{Set\+Fin\+Sequence@{Set\+Fin\+Sequence}!ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}}
\subsubsection[{\texorpdfstring{Set\+Fin\+Sequence(const Sequence\+Number32 \&s)}{SetFinSequence(const SequenceNumber32 &s)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+Rx\+Buffer\+::\+Set\+Fin\+Sequence (
\begin{DoxyParamCaption}
\item[{const {\bf Sequence\+Number32} \&}]{s}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpRxBuffer_a37b57ebcf0d9f922439f4f872b198086}{}\label{classns3_1_1TcpRxBuffer_a37b57ebcf0d9f922439f4f872b198086}


Set the F\+IN Sequence number (i.\+e., the one closing the connection) 


\begin{DoxyParams}{Parameters}
{\em s} & the Sequence number \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
126 \{
127   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
128 
129   \hyperlink{classns3_1_1TcpRxBuffer_ad87a9d034dcc4150cacb5ec45c1883ae}{m\_gotFin} = \textcolor{keyword}{true};
130   \hyperlink{classns3_1_1TcpRxBuffer_a6f63b30eaef4dfcd219cbb9b31fc1a9d}{m\_finSeq} = \hyperlink{generate__test__data__lte__sinr_8m_ad83eeb3a142285d1243a08c6b7026df8}{s};
131   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TcpRxBuffer_ab4390502dee7085dad4f7c3f9ef8796b}{m\_nextRxSeq} == \hyperlink{classns3_1_1TcpRxBuffer_a6f63b30eaef4dfcd219cbb9b31fc1a9d}{m\_finSeq}) ++\hyperlink{classns3_1_1TcpRxBuffer_ab4390502dee7085dad4f7c3f9ef8796b}{m\_nextRxSeq};
132 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}!Set\+Max\+Buffer\+Size@{Set\+Max\+Buffer\+Size}}
\index{Set\+Max\+Buffer\+Size@{Set\+Max\+Buffer\+Size}!ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}}
\subsubsection[{\texorpdfstring{Set\+Max\+Buffer\+Size(uint32\+\_\+t s)}{SetMaxBufferSize(uint32_t s)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+Rx\+Buffer\+::\+Set\+Max\+Buffer\+Size (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{s}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpRxBuffer_a3b37c1b3b91aa2e6e812cba3c2575f75}{}\label{classns3_1_1TcpRxBuffer_a3b37c1b3b91aa2e6e812cba3c2575f75}


Set the Maximum buffer size. 


\begin{DoxyParams}{Parameters}
{\em s} & the Maximum buffer size \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
83 \{
84   \hyperlink{classns3_1_1TcpRxBuffer_a9889bd68e8bf6b250e0ee363ab30f457}{m\_maxBuffer} = \hyperlink{generate__test__data__lte__sinr_8m_ad83eeb3a142285d1243a08c6b7026df8}{s};
85 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}!Set\+Next\+Rx\+Sequence@{Set\+Next\+Rx\+Sequence}}
\index{Set\+Next\+Rx\+Sequence@{Set\+Next\+Rx\+Sequence}!ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}}
\subsubsection[{\texorpdfstring{Set\+Next\+Rx\+Sequence(const Sequence\+Number32 \&s)}{SetNextRxSequence(const SequenceNumber32 &s)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+Rx\+Buffer\+::\+Set\+Next\+Rx\+Sequence (
\begin{DoxyParamCaption}
\item[{const {\bf Sequence\+Number32} \&}]{s}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TcpRxBuffer_a6bba147c19d638ec455b208ccbcaafb4}{}\label{classns3_1_1TcpRxBuffer_a6bba147c19d638ec455b208ccbcaafb4}


Set the Next Sequence number. 


\begin{DoxyParams}{Parameters}
{\em s} & the Sequence number \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
71 \{
72   \hyperlink{classns3_1_1TcpRxBuffer_ab4390502dee7085dad4f7c3f9ef8796b}{m\_nextRxSeq} = \hyperlink{generate__test__data__lte__sinr_8m_ad83eeb3a142285d1243a08c6b7026df8}{s};
73 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}!Size@{Size}}
\index{Size@{Size}!ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}}
\subsubsection[{\texorpdfstring{Size(void) const }{Size(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Tcp\+Rx\+Buffer\+::\+Size (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1TcpRxBuffer_a51938b2cb6cd42c1beedd6f67385f599}{}\label{classns3_1_1TcpRxBuffer_a51938b2cb6cd42c1beedd6f67385f599}


Get the actual buffer occupancy. 

\begin{DoxyReturn}{Returns}
buffer occupancy (in bytes) 
\end{DoxyReturn}

\begin{DoxyCode}
89 \{
90   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TcpRxBuffer_ad76a9d93027823422039c92e85d5d4ea}{m\_size};
91 \}
\end{DoxyCode}
\index{ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}!Update\+Sack\+List@{Update\+Sack\+List}}
\index{Update\+Sack\+List@{Update\+Sack\+List}!ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}}
\subsubsection[{\texorpdfstring{Update\+Sack\+List(const Sequence\+Number32 \&head, const Sequence\+Number32 \&tail)}{UpdateSackList(const SequenceNumber32 &head, const SequenceNumber32 &tail)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Tcp\+Rx\+Buffer\+::\+Update\+Sack\+List (
\begin{DoxyParamCaption}
\item[{const {\bf Sequence\+Number32} \&}]{head, }
\item[{const {\bf Sequence\+Number32} \&}]{tail}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpRxBuffer_abd2afbae9205cd763f48a458d001d2d5}{}\label{classns3_1_1TcpRxBuffer_abd2afbae9205cd763f48a458d001d2d5}


Update the sack list, with the block seq starting at the beginning. 

Note\+: the maximum size of the block list is 4. Caller is free to drop blocks at the end to accomodate header size; from R\+FC 2018\+:

\begin{quote}
The data receiver S\+H\+O\+U\+LD include as many distinct S\+A\+CK blocks as possible in the S\+A\+CK option. Note that the maximum available option space may not be sufficient to report all blocks present in the receiver\textquotesingle{}s queue. \end{quote}


In fact, the maximum amount of blocks is 4, and if we consider the timestamp (or other) options, it is even less. For more detail about this function, please see the source code and in-\/line comments.


\begin{DoxyParams}{Parameters}
{\em head} & sequence number of the block at the beginning \\
\hline
{\em tail} & sequence number of the block at the end \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
241 \{
242   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << head << tail);
243   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (head > \hyperlink{classns3_1_1TcpRxBuffer_ab4390502dee7085dad4f7c3f9ef8796b}{m\_nextRxSeq});
244 
245   \hyperlink{classns3_1_1TcpOptionSack_a9e1d07d8729fd3ac5ead7305794675c3}{TcpOptionSack::SackBlock} current;
246   current.first = head;
247   current.second = tail;
248 
249   \textcolor{comment}{// The block "current" has been safely stored. Now we need to build the SACK}
250   \textcolor{comment}{// list, to be advertised. From RFC 2018:}
251   \textcolor{comment}{// (a) The first SACK block (i.e., the one immediately following the}
252   \textcolor{comment}{//     kind and length fields in the option) MUST specify the contiguous}
253   \textcolor{comment}{//     block of data containing the segment which triggered this ACK,}
254   \textcolor{comment}{//     unless that segment advanced the Acknowledgment Number field in}
255   \textcolor{comment}{//     the header.  This assures that the ACK with the SACK option}
256   \textcolor{comment}{//     reflects the most recent change in the data receiver's buffer}
257   \textcolor{comment}{//     queue.}
258   \textcolor{comment}{//}
259   \textcolor{comment}{// (b) The data receiver SHOULD include as many distinct SACK blocks as}
260   \textcolor{comment}{//     possible in the SACK option.  Note that the maximum available}
261   \textcolor{comment}{//     option space may not be sufficient to report all blocks present in}
262   \textcolor{comment}{//     the receiver's queue.}
263   \textcolor{comment}{//}
264   \textcolor{comment}{// (c) The SACK option SHOULD be filled out by repeating the most}
265   \textcolor{comment}{//     recently reported SACK blocks (based on first SACK blocks in}
266   \textcolor{comment}{//     previous SACK options) that are not subsets of a SACK block}
267   \textcolor{comment}{//     already included in the SACK option being constructed.  This}
268   \textcolor{comment}{//     assures that in normal operation, any segment remaining part of a}
269   \textcolor{comment}{//     non-contiguous block of data held by the data receiver is reported}
270   \textcolor{comment}{//     in at least three successive SACK options, even for large-window}
271   \textcolor{comment}{//     TCP implementations [RFC1323]).  After the first SACK block, the}
272   \textcolor{comment}{//     following SACK blocks in the SACK option may be listed in}
273   \textcolor{comment}{//     arbitrary order.}
274 
275   \hyperlink{classns3_1_1TcpRxBuffer_aee4aac20f3e96f9108918d3650e58eb9}{m\_sackList}.push\_front (current);
276 
277   \textcolor{comment}{// We have inserted the block at the beginning of the list. Now, we should}
278   \textcolor{comment}{// check if any existing blocks overlap with that.}
279   \textcolor{keywordtype}{bool} updated = \textcolor{keyword}{false};
280   TcpOptionSack::SackList::iterator it = \hyperlink{classns3_1_1TcpRxBuffer_aee4aac20f3e96f9108918d3650e58eb9}{m\_sackList}.begin ();
281   \hyperlink{classns3_1_1TcpOptionSack_a9e1d07d8729fd3ac5ead7305794675c3}{TcpOptionSack::SackBlock} begin = *it;
282   \hyperlink{classns3_1_1TcpOptionSack_a9e1d07d8729fd3ac5ead7305794675c3}{TcpOptionSack::SackBlock} merged;
283   ++it;
284 
285   \textcolor{comment}{// Iterates until we examined all blocks in the list (maximum 4)}
286   \textcolor{keywordflow}{while} (it != \hyperlink{classns3_1_1TcpRxBuffer_aee4aac20f3e96f9108918d3650e58eb9}{m\_sackList}.end ())
287     \{
288       \hyperlink{classns3_1_1TcpOptionSack_a9e1d07d8729fd3ac5ead7305794675c3}{TcpOptionSack::SackBlock} current = *it;
289 
290       \textcolor{comment}{// This is a left merge:}
291       \textcolor{comment}{// [current\_first; current\_second] [beg\_first; beg\_second]}
292       \textcolor{keywordflow}{if} (begin.first == current.second)
293         \{
294           \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (current.first < begin.second);
295           merged = \hyperlink{classns3_1_1TcpOptionSack_a9e1d07d8729fd3ac5ead7305794675c3}{TcpOptionSack::SackBlock} (current.first, begin.second);
296           updated = \textcolor{keyword}{true};
297         \}
298       \textcolor{comment}{// while this is a right merge}
299       \textcolor{comment}{// [begin\_first; begin\_second] [current\_first; current\_second]}
300       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (begin.second == current.first)
301         \{
302           \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (begin.first < current.second);
303           merged = \hyperlink{classns3_1_1TcpOptionSack_a9e1d07d8729fd3ac5ead7305794675c3}{TcpOptionSack::SackBlock} (begin.first, current.second);
304           updated = \textcolor{keyword}{true};
305         \}
306 
307       \textcolor{comment}{// If we have merged the blocks (and the result is in merged) we should}
308       \textcolor{comment}{// delete the current block (it), the first block, and insert the merged}
309       \textcolor{comment}{// one at the beginning.}
310       \textcolor{keywordflow}{if} (updated)
311         \{
312           \hyperlink{classns3_1_1TcpRxBuffer_aee4aac20f3e96f9108918d3650e58eb9}{m\_sackList}.erase (it);
313           \hyperlink{classns3_1_1TcpRxBuffer_aee4aac20f3e96f9108918d3650e58eb9}{m\_sackList}.pop\_front ();
314           \hyperlink{classns3_1_1TcpRxBuffer_aee4aac20f3e96f9108918d3650e58eb9}{m\_sackList}.push\_front (merged);
315           it = \hyperlink{classns3_1_1TcpRxBuffer_aee4aac20f3e96f9108918d3650e58eb9}{m\_sackList}.begin ();
316           begin = *it;
317           updated = \textcolor{keyword}{false};
318         \}
319 
320       ++it;
321     \}
322 
323   \textcolor{comment}{// Since the maximum blocks that fits into a TCP header are 4, there's no}
324   \textcolor{comment}{// point on maintaining the others.}
325   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TcpRxBuffer_aee4aac20f3e96f9108918d3650e58eb9}{m\_sackList}.size () > 4)
326     \{
327       \hyperlink{classns3_1_1TcpRxBuffer_aee4aac20f3e96f9108918d3650e58eb9}{m\_sackList}.pop\_back ();
328     \}
329 
330   \textcolor{comment}{// Please note that, if a block b is discarded and then a block contiguos}
331   \textcolor{comment}{// to b is received, only that new block (without the b part) is reported.}
332   \textcolor{comment}{// This is perfectly fine for the RFC point (a), given that we do not report any}
333   \textcolor{comment}{// overlapping blocks shortly after.}
334 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 9




\subsection{Member Data Documentation}
\index{ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}!m\+\_\+avail\+Bytes@{m\+\_\+avail\+Bytes}}
\index{m\+\_\+avail\+Bytes@{m\+\_\+avail\+Bytes}!ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}}
\subsubsection[{\texorpdfstring{m\+\_\+avail\+Bytes}{m_availBytes}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Tcp\+Rx\+Buffer\+::m\+\_\+avail\+Bytes\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpRxBuffer_a700ba510c9ea3ef08f11baf0de7244dc}{}\label{classns3_1_1TcpRxBuffer_a700ba510c9ea3ef08f11baf0de7244dc}


Number of bytes available to read, i.\+e. contiguous block at head. 

\index{ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}!m\+\_\+data@{m\+\_\+data}}
\index{m\+\_\+data@{m\+\_\+data}!ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}}
\subsubsection[{\texorpdfstring{m\+\_\+data}{m_data}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<${\bf Sequence\+Number32}, {\bf Ptr}$<${\bf Packet}$>$ $>$ ns3\+::\+Tcp\+Rx\+Buffer\+::m\+\_\+data\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpRxBuffer_a695c34ebc7bd328b49c507f101257aed}{}\label{classns3_1_1TcpRxBuffer_a695c34ebc7bd328b49c507f101257aed}


Corresponding data (may be null) 

\index{ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}!m\+\_\+fin\+Seq@{m\+\_\+fin\+Seq}}
\index{m\+\_\+fin\+Seq@{m\+\_\+fin\+Seq}!ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}}
\subsubsection[{\texorpdfstring{m\+\_\+fin\+Seq}{m_finSeq}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Sequence\+Number32} ns3\+::\+Tcp\+Rx\+Buffer\+::m\+\_\+fin\+Seq\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpRxBuffer_a6f63b30eaef4dfcd219cbb9b31fc1a9d}{}\label{classns3_1_1TcpRxBuffer_a6f63b30eaef4dfcd219cbb9b31fc1a9d}


Seqnum of the F\+IN packet. 

\index{ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}!m\+\_\+got\+Fin@{m\+\_\+got\+Fin}}
\index{m\+\_\+got\+Fin@{m\+\_\+got\+Fin}!ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}}
\subsubsection[{\texorpdfstring{m\+\_\+got\+Fin}{m_gotFin}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Tcp\+Rx\+Buffer\+::m\+\_\+got\+Fin\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpRxBuffer_ad87a9d034dcc4150cacb5ec45c1883ae}{}\label{classns3_1_1TcpRxBuffer_ad87a9d034dcc4150cacb5ec45c1883ae}


Did I received F\+IN packet? 

\index{ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}!m\+\_\+max\+Buffer@{m\+\_\+max\+Buffer}}
\index{m\+\_\+max\+Buffer@{m\+\_\+max\+Buffer}!ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Buffer}{m_maxBuffer}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Tcp\+Rx\+Buffer\+::m\+\_\+max\+Buffer\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpRxBuffer_a9889bd68e8bf6b250e0ee363ab30f457}{}\label{classns3_1_1TcpRxBuffer_a9889bd68e8bf6b250e0ee363ab30f457}


Upper bound of the number of data bytes in buffer (R\+C\+V.\+W\+ND) 

\index{ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}!m\+\_\+next\+Rx\+Seq@{m\+\_\+next\+Rx\+Seq}}
\index{m\+\_\+next\+Rx\+Seq@{m\+\_\+next\+Rx\+Seq}!ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}}
\subsubsection[{\texorpdfstring{m\+\_\+next\+Rx\+Seq}{m_nextRxSeq}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Value}$<${\bf Sequence\+Number32}$>$ ns3\+::\+Tcp\+Rx\+Buffer\+::m\+\_\+next\+Rx\+Seq\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpRxBuffer_ab4390502dee7085dad4f7c3f9ef8796b}{}\label{classns3_1_1TcpRxBuffer_ab4390502dee7085dad4f7c3f9ef8796b}


Seqnum of the first missing byte in data (R\+C\+V.\+N\+XT) 

\index{ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}!m\+\_\+sack\+List@{m\+\_\+sack\+List}}
\index{m\+\_\+sack\+List@{m\+\_\+sack\+List}!ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}}
\subsubsection[{\texorpdfstring{m\+\_\+sack\+List}{m_sackList}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tcp\+Option\+Sack\+::\+Sack\+List} ns3\+::\+Tcp\+Rx\+Buffer\+::m\+\_\+sack\+List\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpRxBuffer_aee4aac20f3e96f9108918d3650e58eb9}{}\label{classns3_1_1TcpRxBuffer_aee4aac20f3e96f9108918d3650e58eb9}


Sack list (updated constantly) 

\index{ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}!m\+\_\+size@{m\+\_\+size}}
\index{m\+\_\+size@{m\+\_\+size}!ns3\+::\+Tcp\+Rx\+Buffer@{ns3\+::\+Tcp\+Rx\+Buffer}}
\subsubsection[{\texorpdfstring{m\+\_\+size}{m_size}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Tcp\+Rx\+Buffer\+::m\+\_\+size\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TcpRxBuffer_ad76a9d93027823422039c92e85d5d4ea}{}\label{classns3_1_1TcpRxBuffer_ad76a9d93027823422039c92e85d5d4ea}


Number of total data bytes in the buffer, not necessarily contiguous. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/model/\hyperlink{tcp-rx-buffer_8h}{tcp-\/rx-\/buffer.\+h}\item 
internet/model/\hyperlink{tcp-rx-buffer_8cc}{tcp-\/rx-\/buffer.\+cc}\end{DoxyCompactItemize}
