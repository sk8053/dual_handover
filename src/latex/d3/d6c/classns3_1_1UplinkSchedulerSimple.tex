\hypertarget{classns3_1_1UplinkSchedulerSimple}{}\section{ns3\+:\+:Uplink\+Scheduler\+Simple Class Reference}
\label{classns3_1_1UplinkSchedulerSimple}\index{ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}}


{\ttfamily \#include $<$bs-\/uplink-\/scheduler-\/simple.\+h$>$}



Inheritance diagram for ns3\+:\+:Uplink\+Scheduler\+Simple\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Uplink\+Scheduler\+Simple\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1UplinkSchedulerSimple_a25b347f80fb5729b6e439f017dee9031}{Uplink\+Scheduler\+Simple} (void)
\item 
\hyperlink{classns3_1_1UplinkSchedulerSimple_a54305a726288dde444d3d21c215c5515}{Uplink\+Scheduler\+Simple} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1BaseStationNetDevice}{Base\+Station\+Net\+Device} $>$ bs)
\item 
\hyperlink{classns3_1_1UplinkSchedulerSimple_adbf77197f0dd8c8a37ae2446759c4761}{$\sim$\+Uplink\+Scheduler\+Simple} (void)
\item 
\hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1OfdmUlMapIe}{Ofdm\+Ul\+Map\+Ie} $>$ \hyperlink{classns3_1_1UplinkSchedulerSimple_a8bb843591afbf1d05891a1394674a42b}{Get\+Uplink\+Allocations} (void) const 
\item 
void \hyperlink{classns3_1_1UplinkSchedulerSimple_ae2e28db89d928dbd6e0b1795d21a2393}{Get\+Channel\+Descriptors\+To\+Update} (bool \&, bool \&, bool \&, bool \&)
\begin{DoxyCompactList}\small\item\em Determines if channel descriptors sent in the current frame are required to be updated. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1UplinkSchedulerSimple_a51027095bc6bc9487e2203f532f2ee9d}{Calculate\+Allocation\+Start\+Time} (void)
\item 
void \hyperlink{classns3_1_1UplinkSchedulerSimple_a078c18f311ce90cbceab11a54cd4606e}{Add\+Uplink\+Allocation} (\hyperlink{classns3_1_1OfdmUlMapIe}{Ofdm\+Ul\+Map\+Ie} \&ul\+Map\+Ie, const uint32\+\_\+t \&allocation\+Size, uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)
\item 
void \hyperlink{classns3_1_1UplinkSchedulerSimple_a227a6c6e858bcff7dc626064d12df9df}{Schedule} (void)
\item 
void \hyperlink{classns3_1_1UplinkSchedulerSimple_ab30024e72d773b5d0838b7d2222c8a1d}{Service\+Unsolicited\+Grants} (const \hyperlink{classns3_1_1SSRecord}{S\+S\+Record} $\ast$ss\+Record, enum \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235}{Service\+Flow\+::\+Scheduling\+Type} scheduling\+Type, \hyperlink{classns3_1_1OfdmUlMapIe}{Ofdm\+Ul\+Map\+Ie} \&ul\+Map\+Ie, const \hyperlink{classns3_1_1WimaxPhy_a044c5d8a48ca992c39c2a946f6e755fa}{Wimax\+Phy\+::\+Modulation\+Type} modulation\+Type, uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)
\item 
void \hyperlink{classns3_1_1UplinkSchedulerSimple_ad420cfa439ba7c319fab7dd0db299408}{Service\+Bandwidth\+Requests} (const \hyperlink{classns3_1_1SSRecord}{S\+S\+Record} $\ast$ss\+Record, enum \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235}{Service\+Flow\+::\+Scheduling\+Type} scheduling\+Type, \hyperlink{classns3_1_1OfdmUlMapIe}{Ofdm\+Ul\+Map\+Ie} \&ul\+Map\+Ie, const \hyperlink{classns3_1_1WimaxPhy_a044c5d8a48ca992c39c2a946f6e755fa}{Wimax\+Phy\+::\+Modulation\+Type} modulation\+Type, uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)
\item 
bool \hyperlink{classns3_1_1UplinkSchedulerSimple_a0e90e6596f780980d49cf6968cebb5c2}{Service\+Bandwidth\+Requests} (\hyperlink{classns3_1_1ServiceFlow}{Service\+Flow} $\ast$service\+Flow, enum \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235}{Service\+Flow\+::\+Scheduling\+Type} scheduling\+Type, \hyperlink{classns3_1_1OfdmUlMapIe}{Ofdm\+Ul\+Map\+Ie} \&ul\+Map\+Ie, const \hyperlink{classns3_1_1WimaxPhy_a044c5d8a48ca992c39c2a946f6e755fa}{Wimax\+Phy\+::\+Modulation\+Type} modulation\+Type, uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)
\item 
void \hyperlink{classns3_1_1UplinkSchedulerSimple_a113550ccdc47d1ee91efe0b3cc801824}{Allocate\+Initial\+Ranging\+Interval} (uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)
\item 
void \hyperlink{classns3_1_1UplinkSchedulerSimple_a88882b7e7a40a90dc2e9e7e1fb836004}{Setup\+Service\+Flow} (\hyperlink{classns3_1_1SSRecord}{S\+S\+Record} $\ast$ss\+Record, \hyperlink{classns3_1_1ServiceFlow}{Service\+Flow} $\ast$service\+Flow)
\item 
void \hyperlink{classns3_1_1UplinkSchedulerSimple_a6a9666857171c7bbeb29e85e731c2f23}{Process\+Bandwidth\+Request} (const \hyperlink{classns3_1_1BandwidthRequestHeader}{Bandwidth\+Request\+Header} \&bw\+Request\+Hdr)
\item 
void \hyperlink{classns3_1_1UplinkSchedulerSimple_a075911b46c3528c4adc05ef7236fdad6}{Init\+Once} (void)
\begin{DoxyCompactList}\small\item\em Init once function. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1UplinkSchedulerSimple_aaa8e256d55a73d4fd25a04c556e4104a}{On\+Set\+Requested\+Bandwidth} (\hyperlink{classns3_1_1ServiceFlowRecord}{Service\+Flow\+Record} $\ast$sfr)
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1UplinkSchedulerSimple_aa369eae60e7e1d0ed2f3b1a7965afa15}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1OfdmUlMapIe}{Ofdm\+Ul\+Map\+Ie} $>$ \hyperlink{classns3_1_1UplinkSchedulerSimple_a81eb434b3223cb1a0641c5cd82b04009}{m\+\_\+uplink\+Allocations}
\begin{DoxyCompactList}\small\item\em uplink allocations \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}!Uplink\+Scheduler\+Simple@{Uplink\+Scheduler\+Simple}}
\index{Uplink\+Scheduler\+Simple@{Uplink\+Scheduler\+Simple}!ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}}
\subsubsection[{\texorpdfstring{Uplink\+Scheduler\+Simple(void)}{UplinkSchedulerSimple(void)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Uplink\+Scheduler\+Simple\+::\+Uplink\+Scheduler\+Simple (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UplinkSchedulerSimple_a25b347f80fb5729b6e439f017dee9031}{}\label{classns3_1_1UplinkSchedulerSimple_a25b347f80fb5729b6e439f017dee9031}

\begin{DoxyCode}
42 \{
43   \hyperlink{classns3_1_1UplinkScheduler_a28a8d5aa6e61d4ea91388ac3c76e759f}{SetBs} (0);
44   \hyperlink{classns3_1_1UplinkScheduler_ad6e89aef6cf4a9d485762f8bd08ec24e}{SetTimeStampIrInterval} (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (0));
45   \hyperlink{classns3_1_1UplinkScheduler_a19208ce138c5e13b1a7019a67adef892}{SetNrIrOppsAllocated} (0);
46   \hyperlink{classns3_1_1UplinkScheduler_a3eee0d06486678eab4d352a274676d95}{SetIsIrIntrvlAllocated} (\textcolor{keyword}{false});
47   \hyperlink{classns3_1_1UplinkScheduler_a766e3b6c032052002929eb351934e42b}{SetIsInvIrIntrvlAllocated} (\textcolor{keyword}{false});
48   \hyperlink{classns3_1_1UplinkScheduler_a18ccfd91b3f58a55f7249bbafb858f5c}{SetDcdTimeStamp} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ());
49   \hyperlink{classns3_1_1UplinkScheduler_a0dff82b69865688622c0453a35bffe98}{SetUcdTimeStamp} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ());
50 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}!Uplink\+Scheduler\+Simple@{Uplink\+Scheduler\+Simple}}
\index{Uplink\+Scheduler\+Simple@{Uplink\+Scheduler\+Simple}!ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}}
\subsubsection[{\texorpdfstring{Uplink\+Scheduler\+Simple(\+Ptr$<$ Base\+Station\+Net\+Device $>$ bs)}{UplinkSchedulerSimple(Ptr< BaseStationNetDevice > bs)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Uplink\+Scheduler\+Simple\+::\+Uplink\+Scheduler\+Simple (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Base\+Station\+Net\+Device} $>$}]{bs}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UplinkSchedulerSimple_a54305a726288dde444d3d21c215c5515}{}\label{classns3_1_1UplinkSchedulerSimple_a54305a726288dde444d3d21c215c5515}
Constructor


\begin{DoxyParams}{Parameters}
{\em bs} & base station device \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
53 \{
54   \hyperlink{classns3_1_1UplinkScheduler_a28a8d5aa6e61d4ea91388ac3c76e759f}{SetBs} (bs);
55   \hyperlink{classns3_1_1UplinkScheduler_ad6e89aef6cf4a9d485762f8bd08ec24e}{SetTimeStampIrInterval} (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (0));
56   \hyperlink{classns3_1_1UplinkScheduler_a19208ce138c5e13b1a7019a67adef892}{SetNrIrOppsAllocated} (0);
57   \hyperlink{classns3_1_1UplinkScheduler_a3eee0d06486678eab4d352a274676d95}{SetIsIrIntrvlAllocated} (\textcolor{keyword}{false});
58   \hyperlink{classns3_1_1UplinkScheduler_a766e3b6c032052002929eb351934e42b}{SetIsInvIrIntrvlAllocated} (\textcolor{keyword}{false});
59   \hyperlink{classns3_1_1UplinkScheduler_a18ccfd91b3f58a55f7249bbafb858f5c}{SetDcdTimeStamp} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ());
60   \hyperlink{classns3_1_1UplinkScheduler_a0dff82b69865688622c0453a35bffe98}{SetUcdTimeStamp} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ());
61 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}!````~Uplink\+Scheduler\+Simple@{$\sim$\+Uplink\+Scheduler\+Simple}}
\index{````~Uplink\+Scheduler\+Simple@{$\sim$\+Uplink\+Scheduler\+Simple}!ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}}
\subsubsection[{\texorpdfstring{$\sim$\+Uplink\+Scheduler\+Simple(void)}{~UplinkSchedulerSimple(void)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Uplink\+Scheduler\+Simple\+::$\sim$\+Uplink\+Scheduler\+Simple (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UplinkSchedulerSimple_adbf77197f0dd8c8a37ae2446759c4761}{}\label{classns3_1_1UplinkSchedulerSimple_adbf77197f0dd8c8a37ae2446759c4761}

\begin{DoxyCode}
64 \{
65   \hyperlink{classns3_1_1UplinkScheduler_a28a8d5aa6e61d4ea91388ac3c76e759f}{SetBs} (0);
66   \hyperlink{classns3_1_1UplinkSchedulerSimple_a81eb434b3223cb1a0641c5cd82b04009}{m\_uplinkAllocations}.clear ();
67 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4




\subsection{Member Function Documentation}
\index{ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}!Add\+Uplink\+Allocation@{Add\+Uplink\+Allocation}}
\index{Add\+Uplink\+Allocation@{Add\+Uplink\+Allocation}!ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}}
\subsubsection[{\texorpdfstring{Add\+Uplink\+Allocation(\+Ofdm\+Ul\+Map\+Ie \&ul\+Map\+Ie, const uint32\+\_\+t \&allocation\+Size, uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)}{AddUplinkAllocation(OfdmUlMapIe &ulMapIe, const uint32_t &allocationSize, uint32_t &symbolsToAllocation, uint32_t &availableSymbols)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+Simple\+::\+Add\+Uplink\+Allocation (
\begin{DoxyParamCaption}
\item[{{\bf Ofdm\+Ul\+Map\+Ie} \&}]{ul\+Map\+Ie, }
\item[{const uint32\+\_\+t \&}]{allocation\+Size, }
\item[{uint32\+\_\+t \&}]{symbols\+To\+Allocation, }
\item[{uint32\+\_\+t \&}]{available\+Symbols}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerSimple_a078c18f311ce90cbceab11a54cd4606e}{}\label{classns3_1_1UplinkSchedulerSimple_a078c18f311ce90cbceab11a54cd4606e}
Add uplink allocation 
\begin{DoxyParams}{Parameters}
{\em ul\+Map\+Ie} & the UL map IE \\
\hline
{\em allocation\+Size} & the allocation size \\
\hline
{\em symbols\+To\+Allocation} & the symbols to allocation \\
\hline
{\em available\+Symbols} & the available symbols \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1UplinkScheduler_a9bb05ef2a73f18c5004a812aefece8b6}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
162 \{
163   ulMapIe.SetDuration (allocationSize);
164   ulMapIe.SetStartTime (symbolsToAllocation);
165   \hyperlink{classns3_1_1UplinkSchedulerSimple_a81eb434b3223cb1a0641c5cd82b04009}{m\_uplinkAllocations}.push\_back (ulMapIe);
166   symbolsToAllocation += allocationSize;
167   availableSymbols -= allocationSize;
168 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5




Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}!Allocate\+Initial\+Ranging\+Interval@{Allocate\+Initial\+Ranging\+Interval}}
\index{Allocate\+Initial\+Ranging\+Interval@{Allocate\+Initial\+Ranging\+Interval}!ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}}
\subsubsection[{\texorpdfstring{Allocate\+Initial\+Ranging\+Interval(uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)}{AllocateInitialRangingInterval(uint32_t &symbolsToAllocation, uint32_t &availableSymbols)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+Simple\+::\+Allocate\+Initial\+Ranging\+Interval (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t \&}]{symbols\+To\+Allocation, }
\item[{uint32\+\_\+t \&}]{available\+Symbols}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerSimple_a113550ccdc47d1ee91efe0b3cc801824}{}\label{classns3_1_1UplinkSchedulerSimple_a113550ccdc47d1ee91efe0b3cc801824}
Allocate Initial Ranging Interval function


\begin{DoxyParams}{Parameters}
{\em symbols\+To\+Allocation} & symbols to allocation for Up\+Link Subframe \\
\hline
{\em available\+Symbols} & available symbols for rt\+PS flows \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1UplinkScheduler_ae6094447ffd6d3946a70723246faed42}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
480 \{
481   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} ssUlStartTime = \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (\hyperlink{classns3_1_1UplinkSchedulerSimple_a51027095bc6bc9487e2203f532f2ee9d}{CalculateAllocationStartTime} () * 
      \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPsDuration ().GetSeconds ());
482   \hyperlink{classns3_1_1UplinkScheduler_a19208ce138c5e13b1a7019a67adef892}{SetNrIrOppsAllocated} (\hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetLinkManager ()->
      CalculateRangingOppsToAllocate ());
483   uint32\_t allocationSize = \hyperlink{classns3_1_1UplinkScheduler_a9a2cbb04c1e84a028fc1545e8f054b80}{GetNrIrOppsAllocated} () * \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetRangReqOppSize 
      ();
484   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} timeSinceLastIrInterval = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} () - 
      \hyperlink{classns3_1_1UplinkScheduler_aa7516e5a55b513a7640035a9783369c7}{GetTimeStampIrInterval} ();
485 
486   \textcolor{comment}{// adding one frame because may be the time has not elapsed now but will elapse before the next frame is
       sent}
487   \textcolor{keywordflow}{if} (timeSinceLastIrInterval + \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetFrameDuration () > 
      \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetInitialRangingInterval ()
488       && availableSymbols >= allocationSize)
489     \{
490       \hyperlink{classns3_1_1UplinkScheduler_a3eee0d06486678eab4d352a274676d95}{SetIsIrIntrvlAllocated} (\textcolor{keyword}{true});
491       OfdmUlMapIe ulMapIeIr;
492       ulMapIeIr.SetCid ((\hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetBroadcastConnection ())->GetCid ());
493       ulMapIeIr.SetStartTime (symbolsToAllocation);
494       ulMapIeIr.SetUiuc (\hyperlink{classns3_1_1OfdmUlBurstProfile_ae528783c4b3c6700ff49dfd7a555cb3daaea7b6256d4bcd0125f0248c0560c94e}{OfdmUlBurstProfile::UIUC\_INITIAL\_RANGING});
495 
496       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"BS uplink scheduler, initial ranging allocation, size: "} << allocationSize
       << \textcolor{stringliteral}{" symbols"}
497                                                                               << \textcolor{stringliteral}{", modulation: BPSK 1/2"});
498 
499       \textcolor{comment}{// marking start and end of each TO, only for debugging}
500       \textcolor{keywordflow}{for} (uint8\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1UplinkScheduler_a9a2cbb04c1e84a028fc1545e8f054b80}{GetNrIrOppsAllocated} (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
501         \{
502           \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->MarkRangingOppStart (ssUlStartTime + \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (symbolsToAllocation
503                                                                   * \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetSymbolDuration ().
      GetSeconds ()) + \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} * \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetRangReqOppSize ()
504                                                                                                            
                        * \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetSymbolDuration ().GetSeconds ()));
505         \}
506 
507       \hyperlink{classns3_1_1UplinkSchedulerSimple_a078c18f311ce90cbceab11a54cd4606e}{AddUplinkAllocation} (ulMapIeIr, allocationSize, symbolsToAllocation, 
      availableSymbols);
508       \hyperlink{classns3_1_1UplinkScheduler_ad6e89aef6cf4a9d485762f8bd08ec24e}{SetTimeStampIrInterval} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ());
509     \}
510 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7




Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}!Calculate\+Allocation\+Start\+Time@{Calculate\+Allocation\+Start\+Time}}
\index{Calculate\+Allocation\+Start\+Time@{Calculate\+Allocation\+Start\+Time}!ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}}
\subsubsection[{\texorpdfstring{Calculate\+Allocation\+Start\+Time(void)}{CalculateAllocationStartTime(void)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Uplink\+Scheduler\+Simple\+::\+Calculate\+Allocation\+Start\+Time (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerSimple_a51027095bc6bc9487e2203f532f2ee9d}{}\label{classns3_1_1UplinkSchedulerSimple_a51027095bc6bc9487e2203f532f2ee9d}
\begin{DoxyReturn}{Returns}
the calculated allocation start time 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1UplinkScheduler_a10d8a099202072dee74f879d9ae2479b}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
153 \{
154   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetNrDlSymbols () * \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetPsPerSymbol () + 
      \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetTtg ();
155 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9




Here is the caller graph for this function\+:
% FIG 10


\index{ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}!Get\+Channel\+Descriptors\+To\+Update@{Get\+Channel\+Descriptors\+To\+Update}}
\index{Get\+Channel\+Descriptors\+To\+Update@{Get\+Channel\+Descriptors\+To\+Update}!ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}}
\subsubsection[{\texorpdfstring{Get\+Channel\+Descriptors\+To\+Update(bool \&, bool \&, bool \&, bool \&)}{GetChannelDescriptorsToUpdate(bool &, bool &, bool &, bool &)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+Simple\+::\+Get\+Channel\+Descriptors\+To\+Update (
\begin{DoxyParamCaption}
\item[{bool \&}]{update\+Dcd, }
\item[{bool \&}]{update\+Ucd, }
\item[{bool \&}]{send\+Dcd, }
\item[{bool \&}]{send\+Ucd}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerSimple_ae2e28db89d928dbd6e0b1795d21a2393}{}\label{classns3_1_1UplinkSchedulerSimple_ae2e28db89d928dbd6e0b1795d21a2393}


Determines if channel descriptors sent in the current frame are required to be updated. 



Implements \hyperlink{classns3_1_1UplinkScheduler_ae500207af8583a3595da89edcc20b851}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
97 \{
98   \textcolor{comment}{/*DCD and UCD shall actually be updated when channel or burst profile definitions}
99 \textcolor{comment}{   change. burst profiles are updated based on number of SSs, network conditions and etc.}
100 \textcolor{comment}{   for now temporarily assuming DCD/UCD shall be updated everytime */}
101 
102   uint32\_t randNr = rand ();
103   \textcolor{keywordflow}{if} (randNr % 5 == 0 || \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetNrDcdSent () == 0)
104     \{
105       sendDcd = \textcolor{keyword}{true};
106     \}
107 
108   randNr = rand ();
109   \textcolor{keywordflow}{if} (randNr % 5 == 0 || \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetNrUcdSent () == 0)
110     \{
111       sendUcd = \textcolor{keyword}{true};
112     \}
113 
114   \textcolor{comment}{// -------------------------------------}
115   \textcolor{comment}{// additional, just to send more frequently}
116   \textcolor{keywordflow}{if} (!sendDcd)
117     \{
118       randNr = rand ();
119       \textcolor{keywordflow}{if} (randNr % 4 == 0)
120         \{
121           sendDcd = \textcolor{keyword}{true};
122         \}
123     \}
124 
125   \textcolor{keywordflow}{if} (!sendUcd)
126     \{
127       randNr = rand ();
128       \textcolor{keywordflow}{if} (randNr % 4 == 0)
129         \{
130           sendUcd = \textcolor{keyword}{true};
131         \}
132     \}
133   \textcolor{comment}{// -------------------------------------}
134 
135   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} timeSinceLastDcd = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} () - \hyperlink{classns3_1_1UplinkScheduler_a3db19e92a24c71af7d6aff5e94d488fe}{GetDcdTimeStamp} ();
136   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} timeSinceLastUcd = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} () - \hyperlink{classns3_1_1UplinkScheduler_a709e1a0e3c5ab174b0e1bc123dcfd676}{GetUcdTimeStamp} ();
137 
138   \textcolor{keywordflow}{if} (timeSinceLastDcd > \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetDcdInterval ())
139     \{
140       sendDcd = \textcolor{keyword}{true};
141       \hyperlink{classns3_1_1UplinkScheduler_a18ccfd91b3f58a55f7249bbafb858f5c}{SetDcdTimeStamp} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ());
142     \}
143 
144   \textcolor{keywordflow}{if} (timeSinceLastUcd > \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetUcdInterval ())
145     \{
146       sendUcd = \textcolor{keyword}{true};
147       \hyperlink{classns3_1_1UplinkScheduler_a0dff82b69865688622c0453a35bffe98}{SetUcdTimeStamp} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ());
148     \}
149 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 11


\index{ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Uplink\+Scheduler\+Simple\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1UplinkSchedulerSimple_aa369eae60e7e1d0ed2f3b1a7965afa15}{}\label{classns3_1_1UplinkSchedulerSimple_aa369eae60e7e1d0ed2f3b1a7965afa15}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
77 \{
78   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::UplinkSchedulerSimple"})
79     .SetParent<\hyperlink{classns3_1_1UplinkScheduler_a49c38d7e63903d62bb825c38ba3be0fa}{UplinkScheduler}> ()
80     .SetGroupName(\textcolor{stringliteral}{"Wimax"})
81     .AddConstructor<\hyperlink{classns3_1_1UplinkSchedulerSimple_a25b347f80fb5729b6e439f017dee9031}{UplinkSchedulerSimple}> ()
82     ;
83   \textcolor{keywordflow}{return} tid;
84 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12


\index{ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}!Get\+Uplink\+Allocations@{Get\+Uplink\+Allocations}}
\index{Get\+Uplink\+Allocations@{Get\+Uplink\+Allocations}!ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}}
\subsubsection[{\texorpdfstring{Get\+Uplink\+Allocations(void) const }{GetUplinkAllocations(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std\+::list}$<$ {\bf Ofdm\+Ul\+Map\+Ie} $>$ ns3\+::\+Uplink\+Scheduler\+Simple\+::\+Get\+Uplink\+Allocations (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerSimple_a8bb843591afbf1d05891a1394674a42b}{}\label{classns3_1_1UplinkSchedulerSimple_a8bb843591afbf1d05891a1394674a42b}
\begin{DoxyReturn}{Returns}
uplink allocations 
\end{DoxyReturn}


Reimplemented from \hyperlink{classns3_1_1UplinkScheduler_a7170d8d32d3af5c07febafc2c6712f8c}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
88 \{
89   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UplinkSchedulerSimple_a81eb434b3223cb1a0641c5cd82b04009}{m\_uplinkAllocations};
90 \}
\end{DoxyCode}
\index{ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}!Init\+Once@{Init\+Once}}
\index{Init\+Once@{Init\+Once}!ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}}
\subsubsection[{\texorpdfstring{Init\+Once(void)}{InitOnce(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+Simple\+::\+Init\+Once (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerSimple_a075911b46c3528c4adc05ef7236fdad6}{}\label{classns3_1_1UplinkSchedulerSimple_a075911b46c3528c4adc05ef7236fdad6}


Init once function. 



Implements \hyperlink{classns3_1_1UplinkScheduler_ae427e6144919f70a361c047ddcfd5c4c}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
71 \{
72 
73 \}
\end{DoxyCode}
\index{ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}!On\+Set\+Requested\+Bandwidth@{On\+Set\+Requested\+Bandwidth}}
\index{On\+Set\+Requested\+Bandwidth@{On\+Set\+Requested\+Bandwidth}!ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}}
\subsubsection[{\texorpdfstring{On\+Set\+Requested\+Bandwidth(\+Service\+Flow\+Record $\ast$sfr)}{OnSetRequestedBandwidth(ServiceFlowRecord *sfr)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+Simple\+::\+On\+Set\+Requested\+Bandwidth (
\begin{DoxyParamCaption}
\item[{{\bf Service\+Flow\+Record} $\ast$}]{sfr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerSimple_aaa8e256d55a73d4fd25a04c556e4104a}{}\label{classns3_1_1UplinkSchedulerSimple_aaa8e256d55a73d4fd25a04c556e4104a}
Set requested bandwidth function 
\begin{DoxyParams}{Parameters}
{\em sfr} & the service flow record \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1UplinkScheduler_a7bd17c3434380b9a57f8dcae6f4f289c}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
583 \{
584   \textcolor{comment}{// m\_grantedBandwidth must be reset to zero}
585   uint32\_t grantedBandwidth = 0;
586   sfr->SetGrantedBandwidth (grantedBandwidth);
587 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13


\index{ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}!Process\+Bandwidth\+Request@{Process\+Bandwidth\+Request}}
\index{Process\+Bandwidth\+Request@{Process\+Bandwidth\+Request}!ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}}
\subsubsection[{\texorpdfstring{Process\+Bandwidth\+Request(const Bandwidth\+Request\+Header \&bw\+Request\+Hdr)}{ProcessBandwidthRequest(const BandwidthRequestHeader &bwRequestHdr)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+Simple\+::\+Process\+Bandwidth\+Request (
\begin{DoxyParamCaption}
\item[{const {\bf Bandwidth\+Request\+Header} \&}]{bw\+Request\+Hdr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerSimple_a6a9666857171c7bbeb29e85e731c2f23}{}\label{classns3_1_1UplinkSchedulerSimple_a6a9666857171c7bbeb29e85e731c2f23}
Process bandwidth requet function 
\begin{DoxyParams}{Parameters}
{\em bw\+Request\+Hdr} & the bandwidth request header \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1UplinkScheduler_afca8bc8fcb079d7ee97c1d1f14a0ee2f}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
576 \{
577   \textcolor{comment}{// virtual function on UplinkScheduler}
578   \textcolor{comment}{// this is not necessary on this implementation}
579 \}
\end{DoxyCode}
\index{ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}!Schedule@{Schedule}}
\index{Schedule@{Schedule}!ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}}
\subsubsection[{\texorpdfstring{Schedule(void)}{Schedule(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+Simple\+::\+Schedule (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerSimple_a227a6c6e858bcff7dc626064d12df9df}{}\label{classns3_1_1UplinkSchedulerSimple_a227a6c6e858bcff7dc626064d12df9df}
Schedule function 

Implements \hyperlink{classns3_1_1UplinkScheduler_a36fc5c58146f1fb828f21f109cb1634c}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
172 \{
173   \hyperlink{classns3_1_1UplinkSchedulerSimple_a81eb434b3223cb1a0641c5cd82b04009}{m\_uplinkAllocations}.clear ();
174   \hyperlink{classns3_1_1UplinkScheduler_a3eee0d06486678eab4d352a274676d95}{SetIsIrIntrvlAllocated} (\textcolor{keyword}{false});
175   \hyperlink{classns3_1_1UplinkScheduler_a766e3b6c032052002929eb351934e42b}{SetIsInvIrIntrvlAllocated} (\textcolor{keyword}{false});
176   \textcolor{keywordtype}{bool} allocationForDsa = \textcolor{keyword}{false};
177 
178   uint32\_t symbolsToAllocation = 0;
179   uint32\_t allocationSize = 0; \textcolor{comment}{// size in symbols}
180   uint32\_t availableSymbols = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetNrUlSymbols ();
181 
182   \hyperlink{classns3_1_1UplinkSchedulerSimple_a113550ccdc47d1ee91efe0b3cc801824}{AllocateInitialRangingInterval} (symbolsToAllocation, availableSymbols);
183 
184   std::vector<SSRecord*> *ssRecords = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetSSManager ()->GetSSRecords ();
185   \textcolor{keywordflow}{for} (std::vector<SSRecord*>::iterator iter = ssRecords->begin (); iter != ssRecords->end (); ++iter)
186     \{
187       SSRecord *ssRecord = *iter;
188 
189       \textcolor{keywordflow}{if} (ssRecord->GetIsBroadcastSS ())
190         \{
191           \textcolor{keywordflow}{continue};
192         \}
193       Cid cid = ssRecord->GetBasicCid ();
194       OfdmUlMapIe ulMapIe;
195       ulMapIe.SetCid (cid);
196 
197       \textcolor{keywordflow}{if} (ssRecord->GetPollForRanging () && ssRecord->GetRangingStatus () == 
      \hyperlink{classns3_1_1WimaxNetDevice_a2a74c0f01e51abc1851a630242e7b591ace0a03105b6d7cf2c6ec79e9789dc3a6}{WimaxNetDevice::RANGING\_STATUS\_CONTINUE})
198         \{
199 
200           \textcolor{comment}{// SS's ranging is not yet complete}
201           \textcolor{comment}{// allocating invited initial ranging interval}
202           ulMapIe.SetUiuc (\hyperlink{classns3_1_1OfdmUlBurstProfile_ae528783c4b3c6700ff49dfd7a555cb3daaea7b6256d4bcd0125f0248c0560c94e}{OfdmUlBurstProfile::UIUC\_INITIAL\_RANGING}
      );
203           allocationSize = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetRangReqOppSize ();
204           \hyperlink{classns3_1_1UplinkScheduler_a766e3b6c032052002929eb351934e42b}{SetIsInvIrIntrvlAllocated} (\textcolor{keyword}{true});
205 
206           \textcolor{keywordflow}{if} (availableSymbols >= allocationSize)
207             \{
208               \hyperlink{classns3_1_1UplinkSchedulerSimple_a078c18f311ce90cbceab11a54cd4606e}{AddUplinkAllocation} (ulMapIe, allocationSize, symbolsToAllocation, 
      availableSymbols);
209             \}
210           \textcolor{keywordflow}{else}
211             \{
212 
213               \textcolor{keywordflow}{break};
214             \}
215         \}
216       \textcolor{keywordflow}{else}
217         \{
218           \hyperlink{classns3_1_1WimaxPhy_a044c5d8a48ca992c39c2a946f6e755fa}{WimaxPhy::ModulationType} modulationType = ssRecord->GetModulationType ();
219 
220           \textcolor{comment}{// need to update because modulation/FEC to UIUC mapping may vary over time}
221           ulMapIe.SetUiuc (\hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetBurstProfileManager ()->GetBurstProfile (modulationType,
222                                                                                  
      \hyperlink{classns3_1_1WimaxNetDevice_a194b6cf7eb59582328eb2531dc9ed884ad37a477621d1df190ff8d8fb933349cd}{WimaxNetDevice::DIRECTION\_UPLINK}));
223 
224           \textcolor{comment}{// establish service flows for SS}
225           \textcolor{keywordflow}{if} (ssRecord->GetRangingStatus () == 
      \hyperlink{classns3_1_1WimaxNetDevice_a2a74c0f01e51abc1851a630242e7b591a2a48f503c20971a1a5901af0b6d0746c}{WimaxNetDevice::RANGING\_STATUS\_SUCCESS}
226               && !ssRecord->GetAreServiceFlowsAllocated ())
227             \{
228 
229               \textcolor{comment}{// allocating grant (with arbitrary size) to allow SS to send DSA messages DSA-REQ and
       DSA-ACK}
230               \textcolor{comment}{// only one DSA allocation per frame}
231               \textcolor{keywordflow}{if} (!allocationForDsa)
232                 \{
233                   allocationSize = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetNrSymbols (\textcolor{keyword}{sizeof}(DsaReq), modulationType);
234 
235                   \textcolor{keywordflow}{if} (availableSymbols >= allocationSize)
236                     \{
237                       \hyperlink{classns3_1_1UplinkSchedulerSimple_a078c18f311ce90cbceab11a54cd4606e}{AddUplinkAllocation} (ulMapIe, allocationSize, symbolsToAllocation,
       availableSymbols);
238                       allocationForDsa = \textcolor{keyword}{true};
239                     \}
240                   \textcolor{keywordflow}{else}
241                     \{
242                       \textcolor{keywordflow}{break};
243                     \}
244                 \}
245             \}
246           \textcolor{keywordflow}{else}
247             \{
248               \textcolor{comment}{// all service flows associated to SS are established now}
249 
250               \textcolor{comment}{/*allocating grants for data transmission for UGS flows (Data Grant Burst Type IEs,
       6.3.7.4.3.3)}
251 \textcolor{comment}{               (grant has been referred by different names e.g. transmission opportunity, slot, uplink
       allocation, etc)*/}
252               \hyperlink{classns3_1_1UplinkSchedulerSimple_ab30024e72d773b5d0838b7d2222c8a1d}{ServiceUnsolicitedGrants} (ssRecord,
253                                         \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a969e0b62fa12fef1dbb23913744ed594}{ServiceFlow::SF\_TYPE\_UGS},
254                                         ulMapIe,
255                                         modulationType,
256                                         symbolsToAllocation,
257                                         availableSymbols);
258 
259               \textcolor{comment}{// allocate unicast polls for rtPS flows if bandwidth is available}
260               \textcolor{keywordflow}{if} (availableSymbols)
261                 \{
262                   \hyperlink{classns3_1_1UplinkSchedulerSimple_ab30024e72d773b5d0838b7d2222c8a1d}{ServiceUnsolicitedGrants} (ssRecord,
263                                             \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a0e98ff713b932a029acad7e5b24bbf55}{ServiceFlow::SF\_TYPE\_RTPS},
264                                             ulMapIe,
265                                             modulationType,
266                                             symbolsToAllocation,
267                                             availableSymbols);
268                 \}
269               \textcolor{comment}{// allocate unicast polls for nrtPS flows if bandwidth is available}
270               \textcolor{keywordflow}{if} (availableSymbols)
271                 \{
272                   \hyperlink{classns3_1_1UplinkSchedulerSimple_ab30024e72d773b5d0838b7d2222c8a1d}{ServiceUnsolicitedGrants} (ssRecord,
273                                             \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a7f8577f851a9f01d159442a3a3fcdf48}{ServiceFlow::SF\_TYPE\_NRTPS},
274                                             ulMapIe,
275                                             modulationType,
276                                             symbolsToAllocation,
277                                             availableSymbols);
278                 \}
279               \textcolor{comment}{// finally allocate unicast polls for BE flows if bandwidth is available}
280               \textcolor{keywordflow}{if} (availableSymbols)
281                 \{
282                   \hyperlink{classns3_1_1UplinkSchedulerSimple_ab30024e72d773b5d0838b7d2222c8a1d}{ServiceUnsolicitedGrants} (ssRecord,
283                                             \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235af93a8bd8fce654e688f957f6f362e5c7}{ServiceFlow::SF\_TYPE\_BE},
284                                             ulMapIe,
285                                             modulationType,
286                                             symbolsToAllocation,
287                                             availableSymbols);
288                 \}
289 
290               \textcolor{comment}{// now allocating grants for non-UGS flows (i.e., in response of bandwidth requests)}
291 
292               \textcolor{keywordflow}{if} (availableSymbols)
293                 \{
294                   \hyperlink{classns3_1_1UplinkSchedulerSimple_ad420cfa439ba7c319fab7dd0db299408}{ServiceBandwidthRequests} (ssRecord,
295                                             \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a0e98ff713b932a029acad7e5b24bbf55}{ServiceFlow::SF\_TYPE\_RTPS},
296                                             ulMapIe,
297                                             modulationType,
298                                             symbolsToAllocation,
299                                             availableSymbols);
300                 \}
301               \textcolor{comment}{// allocate unicast polls for nrtPS flows if bandwidth is available}
302               \textcolor{keywordflow}{if} (availableSymbols)
303                 \{
304                   \hyperlink{classns3_1_1UplinkSchedulerSimple_ad420cfa439ba7c319fab7dd0db299408}{ServiceBandwidthRequests} (ssRecord,
305                                             \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a7f8577f851a9f01d159442a3a3fcdf48}{ServiceFlow::SF\_TYPE\_NRTPS},
306                                             ulMapIe,
307                                             modulationType,
308                                             symbolsToAllocation,
309                                             availableSymbols);
310                 \}
311               \textcolor{comment}{// finally allocate unicast polls for BE flows if bandwidth is available}
312               \textcolor{keywordflow}{if} (availableSymbols)
313                 \{
314                   \hyperlink{classns3_1_1UplinkSchedulerSimple_ad420cfa439ba7c319fab7dd0db299408}{ServiceBandwidthRequests} (ssRecord,
315                                             \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235af93a8bd8fce654e688f957f6f362e5c7}{ServiceFlow::SF\_TYPE\_BE},
316                                             ulMapIe,
317                                             modulationType,
318                                             symbolsToAllocation,
319                                             availableSymbols);
320                 \}
321             \}
322         \}
323     \}
324   OfdmUlMapIe ulMapIeEnd;
325 
326   ulMapIeEnd.SetCid (\hyperlink{classns3_1_1Cid_a5c204ab0df783c7594c764bae1611436}{Cid::InitialRanging} ());
327   ulMapIeEnd.SetStartTime (symbolsToAllocation);
328   ulMapIeEnd.SetUiuc (\hyperlink{classns3_1_1OfdmUlBurstProfile_ae528783c4b3c6700ff49dfd7a555cb3dabef491e8d426af16beba1541b947b7e9}{OfdmUlBurstProfile::UIUC\_END\_OF\_MAP});
329   ulMapIeEnd.SetDuration (0);
330   \hyperlink{classns3_1_1UplinkSchedulerSimple_a81eb434b3223cb1a0641c5cd82b04009}{m\_uplinkAllocations}.push\_back (ulMapIeEnd);
331 
332   \textcolor{comment}{// setting DL/UL subframe allocation for the next frame}
333   \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetBandwidthManager ()->SetSubframeRatio ();
334 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 14


\index{ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}!Service\+Bandwidth\+Requests@{Service\+Bandwidth\+Requests}}
\index{Service\+Bandwidth\+Requests@{Service\+Bandwidth\+Requests}!ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}}
\subsubsection[{\texorpdfstring{Service\+Bandwidth\+Requests(const S\+S\+Record $\ast$ss\+Record, enum Service\+Flow\+::\+Scheduling\+Type scheduling\+Type, Ofdm\+Ul\+Map\+Ie \&ul\+Map\+Ie, const Wimax\+Phy\+::\+Modulation\+Type modulation\+Type, uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)}{ServiceBandwidthRequests(const SSRecord *ssRecord, enum ServiceFlow::SchedulingType schedulingType, OfdmUlMapIe &ulMapIe, const WimaxPhy::ModulationType modulationType, uint32_t &symbolsToAllocation, uint32_t &availableSymbols)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+Simple\+::\+Service\+Bandwidth\+Requests (
\begin{DoxyParamCaption}
\item[{const {\bf S\+S\+Record} $\ast$}]{ss\+Record, }
\item[{enum {\bf Service\+Flow\+::\+Scheduling\+Type}}]{scheduling\+Type, }
\item[{{\bf Ofdm\+Ul\+Map\+Ie} \&}]{ul\+Map\+Ie, }
\item[{const {\bf Wimax\+Phy\+::\+Modulation\+Type}}]{modulation\+Type, }
\item[{uint32\+\_\+t \&}]{symbols\+To\+Allocation, }
\item[{uint32\+\_\+t \&}]{available\+Symbols}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerSimple_ad420cfa439ba7c319fab7dd0db299408}{}\label{classns3_1_1UplinkSchedulerSimple_ad420cfa439ba7c319fab7dd0db299408}
Service Bandwidth Requests function 
\begin{DoxyParams}{Parameters}
{\em ss\+Record} & Subscriber station record \\
\hline
{\em scheduling\+Type} & the scheduling type \\
\hline
{\em ul\+Map\+Ie} & the UL map IE \\
\hline
{\em modulation\+Type} & the modulation type \\
\hline
{\em symbols\+To\+Allocation} & the symbols to allocation \\
\hline
{\em available\+Symbols} & the available symbols \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1UplinkScheduler_ae6bbcbf3cae55770d0f100692e8af16b}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
412 \{
413   std::vector<ServiceFlow*> serviceFlows = ssRecord->GetServiceFlows (schedulingType);
414 
415   \textcolor{keywordflow}{for} (std::vector<ServiceFlow*>::iterator iter = serviceFlows.begin (); iter != serviceFlows.end (); ++
      iter)
416     \{
417       \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1UplinkSchedulerSimple_ad420cfa439ba7c319fab7dd0db299408}{ServiceBandwidthRequests} (*iter,
418                                      schedulingType,
419                                      ulMapIe,
420                                      modulationType,
421                                      symbolsToAllocation,
422                                      availableSymbols))
423         \{
424           \textcolor{keywordflow}{break};
425         \}
426     \}
427 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 15




Here is the caller graph for this function\+:
% FIG 16


\index{ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}!Service\+Bandwidth\+Requests@{Service\+Bandwidth\+Requests}}
\index{Service\+Bandwidth\+Requests@{Service\+Bandwidth\+Requests}!ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}}
\subsubsection[{\texorpdfstring{Service\+Bandwidth\+Requests(\+Service\+Flow $\ast$service\+Flow, enum Service\+Flow\+::\+Scheduling\+Type scheduling\+Type, Ofdm\+Ul\+Map\+Ie \&ul\+Map\+Ie, const Wimax\+Phy\+::\+Modulation\+Type modulation\+Type, uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)}{ServiceBandwidthRequests(ServiceFlow *serviceFlow, enum ServiceFlow::SchedulingType schedulingType, OfdmUlMapIe &ulMapIe, const WimaxPhy::ModulationType modulationType, uint32_t &symbolsToAllocation, uint32_t &availableSymbols)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Uplink\+Scheduler\+Simple\+::\+Service\+Bandwidth\+Requests (
\begin{DoxyParamCaption}
\item[{{\bf Service\+Flow} $\ast$}]{service\+Flow, }
\item[{enum {\bf Service\+Flow\+::\+Scheduling\+Type}}]{scheduling\+Type, }
\item[{{\bf Ofdm\+Ul\+Map\+Ie} \&}]{ul\+Map\+Ie, }
\item[{const {\bf Wimax\+Phy\+::\+Modulation\+Type}}]{modulation\+Type, }
\item[{uint32\+\_\+t \&}]{symbols\+To\+Allocation, }
\item[{uint32\+\_\+t \&}]{available\+Symbols}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerSimple_a0e90e6596f780980d49cf6968cebb5c2}{}\label{classns3_1_1UplinkSchedulerSimple_a0e90e6596f780980d49cf6968cebb5c2}
Service bandwidth requests function 
\begin{DoxyParams}{Parameters}
{\em service\+Flow} & the service flow \\
\hline
{\em scheduling\+Type} & the scheduling type \\
\hline
{\em ul\+Map\+Ie} & the UL map IE \\
\hline
{\em modulation\+Type} & the modulation type \\
\hline
{\em symbols\+To\+Allocation} & the symbols to allocation \\
\hline
{\em available\+Symbols} & the available symbols \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if successful 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1UplinkScheduler_a6e702b7f0bdb490a762b5e2b9b13c362}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
436 \{
437   uint32\_t allocSizeBytes = 0;
438   uint32\_t allocSizeSymbols = 0;
439   uint16\_t sduSize = 0;
440 
441   ServiceFlowRecord *record = serviceFlow->GetRecord ();
442   sduSize = serviceFlow->GetSduSize ();
443 
444   uint32\_t requiredBandwidth = record->GetRequestedBandwidth () - record->GetGrantedBandwidth ();
445   \textcolor{keywordflow}{if} (requiredBandwidth > 0)
446     \{
447       \textcolor{keywordflow}{if} (sduSize > 0)
448         \{
449           \textcolor{comment}{// if SDU size is mentioned, allocate grant of that size}
450           allocSizeBytes = sduSize;
451           allocSizeSymbols = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetNrSymbols (sduSize, modulationType);
452         \}
453       \textcolor{keywordflow}{else}
454         \{
455           allocSizeBytes = requiredBandwidth;
456           allocSizeSymbols = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetNrSymbols (requiredBandwidth, modulationType);
457         \}
458 
459       \textcolor{keywordflow}{if} (availableSymbols >= allocSizeSymbols)
460         \{
461           record->UpdateGrantedBandwidth (allocSizeBytes);
462 
463           \textcolor{keywordflow}{if} (schedulingType == \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a7f8577f851a9f01d159442a3a3fcdf48}{ServiceFlow::SF\_TYPE\_NRTPS})
464             \{
465               record->SetBwSinceLastExpiry (allocSizeBytes);
466             \}
467 
468           \hyperlink{classns3_1_1UplinkSchedulerSimple_a078c18f311ce90cbceab11a54cd4606e}{AddUplinkAllocation} (ulMapIe, allocSizeSymbols, symbolsToAllocation, 
      availableSymbols);
469         \}
470       \textcolor{keywordflow}{else}
471         \{
472           \textcolor{keywordflow}{return} \textcolor{keyword}{false};
473         \}
474     \}
475   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
476 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 17


\index{ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}!Service\+Unsolicited\+Grants@{Service\+Unsolicited\+Grants}}
\index{Service\+Unsolicited\+Grants@{Service\+Unsolicited\+Grants}!ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}}
\subsubsection[{\texorpdfstring{Service\+Unsolicited\+Grants(const S\+S\+Record $\ast$ss\+Record, enum Service\+Flow\+::\+Scheduling\+Type scheduling\+Type, Ofdm\+Ul\+Map\+Ie \&ul\+Map\+Ie, const Wimax\+Phy\+::\+Modulation\+Type modulation\+Type, uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)}{ServiceUnsolicitedGrants(const SSRecord *ssRecord, enum ServiceFlow::SchedulingType schedulingType, OfdmUlMapIe &ulMapIe, const WimaxPhy::ModulationType modulationType, uint32_t &symbolsToAllocation, uint32_t &availableSymbols)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+Simple\+::\+Service\+Unsolicited\+Grants (
\begin{DoxyParamCaption}
\item[{const {\bf S\+S\+Record} $\ast$}]{ss\+Record, }
\item[{enum {\bf Service\+Flow\+::\+Scheduling\+Type}}]{scheduling\+Type, }
\item[{{\bf Ofdm\+Ul\+Map\+Ie} \&}]{ul\+Map\+Ie, }
\item[{const {\bf Wimax\+Phy\+::\+Modulation\+Type}}]{modulation\+Type, }
\item[{uint32\+\_\+t \&}]{symbols\+To\+Allocation, }
\item[{uint32\+\_\+t \&}]{available\+Symbols}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerSimple_ab30024e72d773b5d0838b7d2222c8a1d}{}\label{classns3_1_1UplinkSchedulerSimple_ab30024e72d773b5d0838b7d2222c8a1d}
Service Unsolicited Grants function 
\begin{DoxyParams}{Parameters}
{\em ss\+Record} & Subscriber station record \\
\hline
{\em scheduling\+Type} & the scheduling type \\
\hline
{\em ul\+Map\+Ie} & the UL map IE \\
\hline
{\em modulation\+Type} & the modulation type \\
\hline
{\em symbols\+To\+Allocation} & the symbols to allocation \\
\hline
{\em available\+Symbols} & the available symbols \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1UplinkScheduler_ab0fb68e0b8923cbec983dbcffbe7a63f}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
343 \{
344   uint32\_t allocationSize = 0; \textcolor{comment}{// size in symbols}
345   uint8\_t uiuc = ulMapIe.GetUiuc (); \textcolor{comment}{// SS's burst profile}
346   std::vector<ServiceFlow*> serviceFlows = ssRecord->GetServiceFlows (schedulingType);
347 
348   \textcolor{keywordflow}{for} (std::vector<ServiceFlow*>::iterator iter = serviceFlows.begin (); iter != serviceFlows.end (); ++
      iter)
349     \{
350       ServiceFlow *serviceFlow = *iter;
351 
352       \textcolor{comment}{/* in case of rtPS, nrtPS and BE, allocating unicast polls for bandwidth requests (Request IEs,
       6.3.7.4.3.1).}
353 \textcolor{comment}{       in case of UGS, allocating grants for data transmission (Data Grant Burst Type IEs, 6.3.7.4.3.3)
       (grant has}
354 \textcolor{comment}{       been referred in this code by different names e.g. transmission opportunity, slot, allocation, etc) 
      */}
355 
356       allocationSize = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetBandwidthManager ()->CalculateAllocationSize (ssRecord, 
      serviceFlow);
357       \textcolor{comment}{// verifying that minimum reserved traffic rate of nrtPS flow is maintained}
358       \textcolor{keywordflow}{if} (serviceFlow->GetSchedulingType () == \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a7f8577f851a9f01d159442a3a3fcdf48}{ServiceFlow::SF\_TYPE\_NRTPS})
359         \{
360           \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} currentTime = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ();
361           ServiceFlowRecord *record = serviceFlow->GetRecord ();
362           \textcolor{keywordflow}{if} (currentTime - record->GetGrantTimeStamp () > \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (1))
363             \{
364               uint32\_t bps = (record->GetBwSinceLastExpiry () * 8);
365               \textcolor{keywordflow}{if} (bps < serviceFlow->GetMinReservedTrafficRate ())
366                 \{
367                   \hyperlink{classns3_1_1UplinkSchedulerSimple_ad420cfa439ba7c319fab7dd0db299408}{ServiceBandwidthRequests} (serviceFlow,
368                                             schedulingType,
369                                             ulMapIe,
370                                             modulationType,
371                                             symbolsToAllocation,
372                                             availableSymbols);
373                   record->SetBwSinceLastExpiry (0);
374                   record->SetGrantTimeStamp (currentTime);
375                 \}
376             \}
377         \}
378 
379       \textcolor{keywordflow}{if} (availableSymbols < allocationSize)
380         \{
381           \textcolor{keywordflow}{break};
382         \}
383 
384       \textcolor{keywordflow}{if} (allocationSize > 0)
385         \{
386           ulMapIe.SetStartTime (symbolsToAllocation);
387           \textcolor{keywordflow}{if} (serviceFlow->GetSchedulingType () != \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a969e0b62fa12fef1dbb23913744ed594}{ServiceFlow::SF\_TYPE\_UGS})
388             \{
389               \textcolor{comment}{// special burst profile with most robust modulation type is used for unicast polls (Request
       IEs)}
390               ulMapIe.SetUiuc (\hyperlink{classns3_1_1OfdmUlBurstProfile_ae528783c4b3c6700ff49dfd7a555cb3daae074d10caa7fe18da973227c7f9942f}{OfdmUlBurstProfile::UIUC\_REQ\_REGION\_FULL}
      );
391             \}
392         \}
393       \textcolor{keywordflow}{else}
394         \{
395           \textcolor{keywordflow}{continue};
396         \}
397 
398       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{", CID: "} << serviceFlow->GetConnection ()->GetCid () << \textcolor{stringliteral}{", SFID: "} << 
      serviceFlow->GetSfid ());
399 
400       \hyperlink{classns3_1_1UplinkSchedulerSimple_a078c18f311ce90cbceab11a54cd4606e}{AddUplinkAllocation} (ulMapIe, allocationSize, symbolsToAllocation, 
      availableSymbols);
401       ulMapIe.SetUiuc (uiuc);
402     \}
403 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 18




Here is the caller graph for this function\+:
% FIG 19


\index{ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}!Setup\+Service\+Flow@{Setup\+Service\+Flow}}
\index{Setup\+Service\+Flow@{Setup\+Service\+Flow}!ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}}
\subsubsection[{\texorpdfstring{Setup\+Service\+Flow(\+S\+S\+Record $\ast$ss\+Record, Service\+Flow $\ast$service\+Flow)}{SetupServiceFlow(SSRecord *ssRecord, ServiceFlow *serviceFlow)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+Simple\+::\+Setup\+Service\+Flow (
\begin{DoxyParamCaption}
\item[{{\bf S\+S\+Record} $\ast$}]{ss\+Record, }
\item[{{\bf Service\+Flow} $\ast$}]{service\+Flow}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerSimple_a88882b7e7a40a90dc2e9e7e1fb836004}{}\label{classns3_1_1UplinkSchedulerSimple_a88882b7e7a40a90dc2e9e7e1fb836004}
Setup service flow function 
\begin{DoxyParams}{Parameters}
{\em ss\+Record} & Subscriber station record \\
\hline
{\em service\+Flow} & the service flow \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1UplinkScheduler_a101bce0939ff2315db3d2e3b75b4fed6}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
514 \{
515   uint8\_t delayNrFrames = 1;
516   uint32\_t bitsPerSecond = serviceFlow->GetMinReservedTrafficRate ();
517   \hyperlink{classns3_1_1WimaxPhy_a044c5d8a48ca992c39c2a946f6e755fa}{WimaxPhy::ModulationType} modulation;
518   uint32\_t bytesPerFrame =
519     (uint32\_t ((\textcolor{keywordtype}{double})(bitsPerSecond) * \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetFrameDuration ().GetSeconds ())) / 8;
520   uint32\_t frameDurationMSec = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetFrameDuration ().GetMilliSeconds ();
521 
522   \textcolor{keywordflow}{switch} (serviceFlow->GetSchedulingType ())
523     \{
524     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a969e0b62fa12fef1dbb23913744ed594}{ServiceFlow::SF\_TYPE\_UGS}:
525       \{
526         \textcolor{keywordflow}{if} (serviceFlow->GetIsMulticast () == \textcolor{keyword}{true})
527           \{
528             modulation = serviceFlow->GetModulation ();
529           \}
530         \textcolor{keywordflow}{else}
531           \{
532             modulation = ssRecord->GetModulationType ();
533           \}
534         uint32\_t grantSize = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetNrSymbols (bytesPerFrame, modulation);
535         serviceFlow->GetRecord ()->SetGrantSize (grantSize);
536 
537         uint32\_t toleratedJitter = serviceFlow->GetToleratedJitter ();
538 
539         \textcolor{keywordflow}{if} (toleratedJitter > frameDurationMSec)
540           \{
541             delayNrFrames = (uint8\_t)(toleratedJitter / frameDurationMSec);
542           \}
543 
544         uint16\_t interval = delayNrFrames * frameDurationMSec;
545         serviceFlow->SetUnsolicitedGrantInterval (interval);
546       \}
547       \textcolor{keywordflow}{break};
548     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a0e98ff713b932a029acad7e5b24bbf55}{ServiceFlow::SF\_TYPE\_RTPS}:
549       \{
550         \textcolor{keywordflow}{if} (serviceFlow->GetSduSize () > bytesPerFrame)
551           \{
552             delayNrFrames = (uint8\_t)(serviceFlow->GetSduSize () / bytesPerFrame);
553           \}
554 
555         uint16\_t interval = delayNrFrames * frameDurationMSec;
556         serviceFlow->SetUnsolicitedPollingInterval (interval);
557       \}
558       \textcolor{keywordflow}{break};
559     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a7f8577f851a9f01d159442a3a3fcdf48}{ServiceFlow::SF\_TYPE\_NRTPS}:
560       \{
561         \textcolor{comment}{// no real-time guarantees are given to NRTPS, serviced based on available bandwidth}
562       \}
563       \textcolor{keywordflow}{break};
564     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235af93a8bd8fce654e688f957f6f362e5c7}{ServiceFlow::SF\_TYPE\_BE}:
565       \{
566         \textcolor{comment}{// no real-time guarantees are given to BE, serviced based on available bandwidth}
567       \}
568       \textcolor{keywordflow}{break};
569     \textcolor{keywordflow}{default}:
570       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Invalid scheduling type"});
571     \}
572 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 20




\subsection{Member Data Documentation}
\index{ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}!m\+\_\+uplink\+Allocations@{m\+\_\+uplink\+Allocations}}
\index{m\+\_\+uplink\+Allocations@{m\+\_\+uplink\+Allocations}!ns3\+::\+Uplink\+Scheduler\+Simple@{ns3\+::\+Uplink\+Scheduler\+Simple}}
\subsubsection[{\texorpdfstring{m\+\_\+uplink\+Allocations}{m_uplinkAllocations}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std\+::list}$<${\bf Ofdm\+Ul\+Map\+Ie}$>$ ns3\+::\+Uplink\+Scheduler\+Simple\+::m\+\_\+uplink\+Allocations\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UplinkSchedulerSimple_a81eb434b3223cb1a0641c5cd82b04009}{}\label{classns3_1_1UplinkSchedulerSimple_a81eb434b3223cb1a0641c5cd82b04009}


uplink allocations 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
wimax/model/\hyperlink{bs-uplink-scheduler-simple_8h}{bs-\/uplink-\/scheduler-\/simple.\+h}\item 
wimax/model/\hyperlink{bs-uplink-scheduler-simple_8cc}{bs-\/uplink-\/scheduler-\/simple.\+cc}\end{DoxyCompactItemize}
