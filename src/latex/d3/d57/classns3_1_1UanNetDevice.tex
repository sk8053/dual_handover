\hypertarget{classns3_1_1UanNetDevice}{}\section{ns3\+:\+:Uan\+Net\+Device Class Reference}
\label{classns3_1_1UanNetDevice}\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}


{\ttfamily \#include $<$uan-\/net-\/device.\+h$>$}



Inheritance diagram for ns3\+:\+:Uan\+Net\+Device\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Uan\+Net\+Device\+:
% FIG 1
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UanPhy}{Uan\+Phy} $>$ $>$ \hyperlink{classns3_1_1UanNetDevice_af5cc3a49adad7bd3b0013fd88288c1c7}{Uan\+Phy\+List}
\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UanTransducer}{Uan\+Transducer} $>$ $>$ \hyperlink{classns3_1_1UanNetDevice_a83cab60a440452000efb1a8ad3630598}{Uan\+Transducer\+List}
\item 
typedef void($\ast$ \hyperlink{classns3_1_1UanNetDevice_af6b97ffb33aa8fd61b222d8e86494c62}{Rx\+Tx\+Traced\+Callback}) (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1UanAddress}{Uan\+Address} address)
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1UanNetDevice_a3347d13fb75cee52d72ed5713fe90278}{Uan\+Net\+Device} ()
\item 
virtual \hyperlink{classns3_1_1UanNetDevice_ae3975db51c8c4096f7fa7765a29dae0f}{$\sim$\+Uan\+Net\+Device} ()
\item 
void \hyperlink{classns3_1_1UanNetDevice_a7225cfda064ecc308e224eb1b11397b5}{Set\+Mac} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UanMac}{Uan\+Mac} $>$ mac)
\item 
void \hyperlink{classns3_1_1UanNetDevice_af6d039ecff08a8f794738fd62956f917}{Set\+Phy} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UanPhy}{Uan\+Phy} $>$ phy)
\item 
void \hyperlink{classns3_1_1UanNetDevice_a987daa8c043146fad8975cb43fbb24e5}{Set\+Channel} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UanChannel}{Uan\+Channel} $>$ channel)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UanMac}{Uan\+Mac} $>$ \hyperlink{classns3_1_1UanNetDevice_adb4ad57f640b285d238687713c9826b3}{Get\+Mac} (void) const 
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UanPhy}{Uan\+Phy} $>$ \hyperlink{classns3_1_1UanNetDevice_abff3efdff8f4c31c2bb0ea780a6b99a8}{Get\+Phy} (void) const 
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UanTransducer}{Uan\+Transducer} $>$ \hyperlink{classns3_1_1UanNetDevice_a28fd8d3e52558859abd0757f48e8d478}{Get\+Transducer} (void) const 
\item 
void \hyperlink{classns3_1_1UanNetDevice_ad91b46a001ee99241d7579800f93eab5}{Set\+Transducer} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UanTransducer}{Uan\+Transducer} $>$ trans)
\item 
void \hyperlink{classns3_1_1UanNetDevice_a06bccd3e7a4db7ea5d65819301d267dc}{Clear} (void)
\item 
void \hyperlink{classns3_1_1UanNetDevice_a933871471c1026cb15486a156648f7a8}{Set\+Sleep\+Mode} (bool sleep)
\item 
virtual void \hyperlink{classns3_1_1UanNetDevice_a2d877f8da3c474bc75f5c41049e06cac}{Set\+If\+Index} (const uint32\+\_\+t index)
\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1UanNetDevice_acf7b3a85853c4160d1a134a02647e0b3}{Get\+If\+Index} (void) const 
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Channel}{Channel} $>$ \hyperlink{classns3_1_1UanNetDevice_a5254720ba19b94e1123beea1d3744c29}{Get\+Channel} (void) const 
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1UanNetDevice_a82f8ad21dacb782e82a4aff50c32a5d7}{Get\+Address} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1UanNetDevice_a2e7ad23d65650a02984e6c6afaa1744b}{Set\+Mtu} (const uint16\+\_\+t mtu)
\item 
virtual uint16\+\_\+t \hyperlink{classns3_1_1UanNetDevice_a56a7bf94f2d58cde6c564465eacc47ad}{Get\+Mtu} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1UanNetDevice_aecf041a5878cf1aab62e155fe007e52f}{Is\+Link\+Up} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1UanNetDevice_a813bf46757bd911908aa92a10c1a7d15}{Is\+Broadcast} (void) const 
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1UanNetDevice_a0a7b435a96c84f3ad394df300946a5af}{Get\+Broadcast} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1UanNetDevice_ad5245f51eb712c75c30d99ac97b3706b}{Is\+Multicast} (void) const 
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1UanNetDevice_af79d030e9e0d8fc4bb53483ac500f99b}{Get\+Multicast} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} multicast\+Group) const 
\begin{DoxyCompactList}\small\item\em Make and return a M\+AC multicast address using the provided multicast group. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1UanNetDevice_ace5aeef735e5b5d314a4c9a3802c244b}{Get\+Multicast} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} addr) const 
\begin{DoxyCompactList}\small\item\em Get the M\+AC multicast address corresponding to the I\+Pv6 address provided. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1UanNetDevice_a18646020a7efafd7f74217d7ad9edf76}{Is\+Bridge} (void) const 
\begin{DoxyCompactList}\small\item\em Return true if the net device is acting as a bridge. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1UanNetDevice_a914ed77672de3652a366a84b1e582de7}{Is\+Point\+To\+Point} (void) const 
\begin{DoxyCompactList}\small\item\em Return true if the net device is on a point-\/to-\/point link. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1UanNetDevice_aca7865bf58e980106b68a177d41d346b}{Send} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, const \hyperlink{classns3_1_1Address}{Address} \&dest, uint16\+\_\+t protocol\+Number)
\item 
virtual bool \hyperlink{classns3_1_1UanNetDevice_acbce400d57951dd7b9207068ad080191}{Send\+From} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, const \hyperlink{classns3_1_1Address}{Address} \&source, const \hyperlink{classns3_1_1Address}{Address} \&dest, uint16\+\_\+t protocol\+Number)
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1UanNetDevice_a5568381797d83e788086ac2dcd34b14d}{Get\+Node} (void) const 
\item 
virtual void \hyperlink{classns3_1_1UanNetDevice_a8996251b8e755fa575acd4746538d5a3}{Set\+Node} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node)
\item 
virtual bool \hyperlink{classns3_1_1UanNetDevice_a82a4180f4ae1538878aec6a882794e91}{Needs\+Arp} (void) const 
\item 
virtual void \hyperlink{classns3_1_1UanNetDevice_acee91182c836cd8dfbbd8e46271dc9be}{Set\+Receive\+Callback} (\hyperlink{classns3_1_1NetDevice_ad5e5e1ca187472bc2ba99575d8def568}{Net\+Device\+::\+Receive\+Callback} cb)
\item 
virtual void \hyperlink{classns3_1_1UanNetDevice_a446e2bdaff56460e8f64374c954642cb}{Set\+Promisc\+Receive\+Callback} (\hyperlink{classns3_1_1NetDevice_a427225795919f26c414bee2ea3f31ed2}{Promisc\+Receive\+Callback} cb)
\item 
virtual bool \hyperlink{classns3_1_1UanNetDevice_a874384b989b22f6b00bd55fdb2927e39}{Supports\+Send\+From} (void) const 
\item 
virtual void \hyperlink{classns3_1_1UanNetDevice_ac2a471c884f18f1c5779503371bdf3cc}{Add\+Link\+Change\+Callback} (\hyperlink{classns3_1_1Callback}{Callback}$<$ void $>$ callback)
\item 
virtual void \hyperlink{classns3_1_1UanNetDevice_a4e0c30c0b67bae0eb769336688799e02}{Set\+Address} (\hyperlink{classns3_1_1Address}{Address} address)
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1UanNetDevice_a8dc58ba9c4e22e1468f987fa047e565b}{Get\+Type\+Id} (void)
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1UanNetDevice_a6a794cc7b9f0194213bddba0bfb16f92}{Do\+Dispose} ()
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1UanNetDevice_a6bd742bff7683658efa38d726619b8c4}{Forward\+Up} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ pkt, const \hyperlink{classns3_1_1UanAddress}{Uan\+Address} \&src)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UanChannel}{Uan\+Channel} $>$ \hyperlink{classns3_1_1UanNetDevice_a9bd7ab08d599a1781c7a36826777f623}{Do\+Get\+Channel} (void) const 
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UanTransducer}{Uan\+Transducer} $>$ \hyperlink{classns3_1_1UanNetDevice_a9576fcd3b2e1f07fbb0c7125f905f0e0}{m\+\_\+trans}
\begin{DoxyCompactList}\small\item\em The Transducer attached to this device. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1UanNetDevice_a762b0c54b288f7df70ecc7a701d6a720}{m\+\_\+node}
\begin{DoxyCompactList}\small\item\em The node hosting this device. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UanChannel}{Uan\+Channel} $>$ \hyperlink{classns3_1_1UanNetDevice_ab528925b6ada30cd1e9a8acc23a4f9dd}{m\+\_\+channel}
\begin{DoxyCompactList}\small\item\em The channel attached to this device. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UanMac}{Uan\+Mac} $>$ \hyperlink{classns3_1_1UanNetDevice_af07aff40dbb010fd62ad0fdcbf394995}{m\+\_\+mac}
\begin{DoxyCompactList}\small\item\em The M\+AC layer attached to this device. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UanPhy}{Uan\+Phy} $>$ \hyperlink{classns3_1_1UanNetDevice_a844d7ac9f29552eebf86d2f7cbf3c39c}{m\+\_\+phy}
\begin{DoxyCompactList}\small\item\em The P\+HY layer attached to this device. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1UanNetDevice_a3416bb182a67acc209637bfe619a76f6}{m\+\_\+if\+Index}
\begin{DoxyCompactList}\small\item\em The interface index of this device. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1UanNetDevice_ae7c34c0bb24052fba7fbdcfb50f94214}{m\+\_\+mtu}
\begin{DoxyCompactList}\small\item\em The device M\+TU value, in bytes. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1UanNetDevice_a983f3b724d8d8926b09e9228d0b5a7b2}{m\+\_\+linkup}
\begin{DoxyCompactList}\small\item\em The link state, true if up. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback} \hyperlink{classns3_1_1UanNetDevice_ab061747ef6929cb5ba1288d68ab5a679}{m\+\_\+link\+Changes}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Callback}{Callback} to invoke when the link state changes to UP. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1NetDevice_ad5e5e1ca187472bc2ba99575d8def568}{Receive\+Callback} \hyperlink{classns3_1_1UanNetDevice_aee4321afad0167cdb8f3a6956be03983}{m\+\_\+forward\+Up}
\begin{DoxyCompactList}\small\item\em The receive callback. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$, \hyperlink{classns3_1_1UanAddress}{Uan\+Address} $>$ \hyperlink{classns3_1_1UanNetDevice_a427c15bb70e38facb1c50fe76bfe1979}{m\+\_\+rx\+Logger}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$, \hyperlink{classns3_1_1UanAddress}{Uan\+Address} $>$ \hyperlink{classns3_1_1UanNetDevice_ab1ed35043886ee497c4ea96267c50b79}{m\+\_\+tx\+Logger}
\item 
bool \hyperlink{classns3_1_1UanNetDevice_a94db1f444365c0961e0dc9b2faee00cf}{m\+\_\+cleared}
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Net device for U\+AN models. 

\subsection{Member Typedef Documentation}
\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Rx\+Tx\+Traced\+Callback@{Rx\+Tx\+Traced\+Callback}}
\index{Rx\+Tx\+Traced\+Callback@{Rx\+Tx\+Traced\+Callback}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Rx\+Tx\+Traced\+Callback}{RxTxTracedCallback}}]{\setlength{\rightskip}{0pt plus 5cm}typedef void($\ast$  ns3\+::\+Uan\+Net\+Device\+::\+Rx\+Tx\+Traced\+Callback) ({\bf Ptr}$<$ const {\bf Packet} $>$ packet, {\bf Uan\+Address} address)}\hypertarget{classns3_1_1UanNetDevice_af6b97ffb33aa8fd61b222d8e86494c62}{}\label{classns3_1_1UanNetDevice_af6b97ffb33aa8fd61b222d8e86494c62}
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback} signature for M\+AC send/receive events.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em packet} & The \hyperlink{classns3_1_1Packet}{Packet}. \\
\hline
\mbox{\tt in}  & {\em address} & The source address. \\
\hline
\end{DoxyParams}
\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Uan\+Phy\+List@{Uan\+Phy\+List}}
\index{Uan\+Phy\+List@{Uan\+Phy\+List}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Uan\+Phy\+List}{UanPhyList}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Ptr}$<${\bf Uan\+Phy}$>$ $>$ {\bf ns3\+::\+Uan\+Net\+Device\+::\+Uan\+Phy\+List}}\hypertarget{classns3_1_1UanNetDevice_af5cc3a49adad7bd3b0013fd88288c1c7}{}\label{classns3_1_1UanNetDevice_af5cc3a49adad7bd3b0013fd88288c1c7}
List of \hyperlink{classns3_1_1UanPhy}{Uan\+Phy} objects. \index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Uan\+Transducer\+List@{Uan\+Transducer\+List}}
\index{Uan\+Transducer\+List@{Uan\+Transducer\+List}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Uan\+Transducer\+List}{UanTransducerList}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Ptr}$<${\bf Uan\+Transducer}$>$ $>$ {\bf ns3\+::\+Uan\+Net\+Device\+::\+Uan\+Transducer\+List}}\hypertarget{classns3_1_1UanNetDevice_a83cab60a440452000efb1a8ad3630598}{}\label{classns3_1_1UanNetDevice_a83cab60a440452000efb1a8ad3630598}
List of \hyperlink{classns3_1_1UanTransducer}{Uan\+Transducer} objects. 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Uan\+Net\+Device@{Uan\+Net\+Device}}
\index{Uan\+Net\+Device@{Uan\+Net\+Device}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Uan\+Net\+Device()}{UanNetDevice()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Uan\+Net\+Device\+::\+Uan\+Net\+Device (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UanNetDevice_a3347d13fb75cee52d72ed5713fe90278}{}\label{classns3_1_1UanNetDevice_a3347d13fb75cee52d72ed5713fe90278}
Default constructor 
\begin{DoxyCode}
40   : NetDevice (),
41     \hyperlink{classns3_1_1UanNetDevice_ae7c34c0bb24052fba7fbdcfb50f94214}{m\_mtu} (64000),
42     \hyperlink{classns3_1_1UanNetDevice_a94db1f444365c0961e0dc9b2faee00cf}{m\_cleared} (\textcolor{keyword}{false})
43 \{
44 \}
\end{DoxyCode}
\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!````~Uan\+Net\+Device@{$\sim$\+Uan\+Net\+Device}}
\index{````~Uan\+Net\+Device@{$\sim$\+Uan\+Net\+Device}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{$\sim$\+Uan\+Net\+Device()}{~UanNetDevice()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Uan\+Net\+Device\+::$\sim$\+Uan\+Net\+Device (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UanNetDevice_ae3975db51c8c4096f7fa7765a29dae0f}{}\label{classns3_1_1UanNetDevice_ae3975db51c8c4096f7fa7765a29dae0f}
Dummy destructor, Do\+Dispose. 
\begin{DoxyCode}
47 \{
48 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Add\+Link\+Change\+Callback@{Add\+Link\+Change\+Callback}}
\index{Add\+Link\+Change\+Callback@{Add\+Link\+Change\+Callback}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Add\+Link\+Change\+Callback(\+Callback$<$ void $>$ callback)}{AddLinkChangeCallback(Callback< void > callback)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uan\+Net\+Device\+::\+Add\+Link\+Change\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Callback}$<$ void $>$}]{callback}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UanNetDevice_ac2a471c884f18f1c5779503371bdf3cc}{}\label{classns3_1_1UanNetDevice_ac2a471c884f18f1c5779503371bdf3cc}

\begin{DoxyParams}{Parameters}
{\em callback} & the callback to invoke\\
\hline
\end{DoxyParams}
Add a callback invoked whenever the link status changes to UP. This callback is typically used by the I\+P/\+A\+RP layer to flush the A\+RP cache and by I\+Pv6 stack to flush N\+D\+I\+SC cache whenever the link goes up. 

Implements \hyperlink{classns3_1_1NetDevice_aafb1bf869d38ef7a7112d11fab0163a3}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
368 \{
369   \hyperlink{classns3_1_1UanNetDevice_ab061747ef6929cb5ba1288d68ab5a679}{m\_linkChanges}.\hyperlink{classns3_1_1TracedCallback_aacc251bf4e302e7d034e9f0e25a15980}{ConnectWithoutContext} (callback);
370 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Clear@{Clear}}
\index{Clear@{Clear}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Clear(void)}{Clear(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uan\+Net\+Device\+::\+Clear (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UanNetDevice_a06bccd3e7a4db7ea5d65819301d267dc}{}\label{classns3_1_1UanNetDevice_a06bccd3e7a4db7ea5d65819301d267dc}
Clear all pointer references. 
\begin{DoxyCode}
52 \{
53   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UanNetDevice_a94db1f444365c0961e0dc9b2faee00cf}{m\_cleared})
54     \{
55       \textcolor{keywordflow}{return};
56     \}
57   \hyperlink{classns3_1_1UanNetDevice_a94db1f444365c0961e0dc9b2faee00cf}{m\_cleared} = \textcolor{keyword}{true};
58   \hyperlink{classns3_1_1UanNetDevice_a762b0c54b288f7df70ecc7a701d6a720}{m\_node} = 0;
59   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UanNetDevice_ab528925b6ada30cd1e9a8acc23a4f9dd}{m\_channel})
60     \{
61       \hyperlink{classns3_1_1UanNetDevice_ab528925b6ada30cd1e9a8acc23a4f9dd}{m\_channel}->Clear ();
62       \hyperlink{classns3_1_1UanNetDevice_ab528925b6ada30cd1e9a8acc23a4f9dd}{m\_channel} = 0;
63     \}
64   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UanNetDevice_af07aff40dbb010fd62ad0fdcbf394995}{m\_mac})
65     \{
66       \hyperlink{classns3_1_1UanNetDevice_af07aff40dbb010fd62ad0fdcbf394995}{m\_mac}->Clear ();
67       \hyperlink{classns3_1_1UanNetDevice_af07aff40dbb010fd62ad0fdcbf394995}{m\_mac} = 0;
68     \}
69   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UanNetDevice_a844d7ac9f29552eebf86d2f7cbf3c39c}{m\_phy})
70     \{
71       \hyperlink{classns3_1_1UanNetDevice_a844d7ac9f29552eebf86d2f7cbf3c39c}{m\_phy}->Clear ();
72       \hyperlink{classns3_1_1UanNetDevice_a844d7ac9f29552eebf86d2f7cbf3c39c}{m\_phy} = 0;
73     \}
74   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UanNetDevice_a9576fcd3b2e1f07fbb0c7125f905f0e0}{m\_trans})
75     \{
76       \hyperlink{classns3_1_1UanNetDevice_a9576fcd3b2e1f07fbb0c7125f905f0e0}{m\_trans}->Clear ();
77       \hyperlink{classns3_1_1UanNetDevice_a9576fcd3b2e1f07fbb0c7125f905f0e0}{m\_trans} = 0;
78     \}
79 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 3


\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Do\+Dispose()}{DoDispose()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uan\+Net\+Device\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1UanNetDevice_a6a794cc7b9f0194213bddba0bfb16f92}{}\label{classns3_1_1UanNetDevice_a6a794cc7b9f0194213bddba0bfb16f92}
Destructor implementation.

This method is called by \hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose()} or by the \hyperlink{classns3_1_1Object}{Object}\textquotesingle{}s destructor, whichever comes first.

Subclasses are expected to implement their real destruction code in an overriden version of this method and chain up to their parent\textquotesingle{}s implementation once they are done. {\itshape i.\+e}, for simplicity, the destructor of every subclass should be empty and its content should be moved to the associated \hyperlink{classns3_1_1UanNetDevice_a6a794cc7b9f0194213bddba0bfb16f92}{Do\+Dispose()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.


\begin{DoxyCode}
83 \{
84   \hyperlink{classns3_1_1UanNetDevice_a06bccd3e7a4db7ea5d65819301d267dc}{Clear} ();
85   \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{NetDevice::DoDispose} ();
86 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4


\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Do\+Get\+Channel@{Do\+Get\+Channel}}
\index{Do\+Get\+Channel@{Do\+Get\+Channel}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Do\+Get\+Channel(void) const }{DoGetChannel(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Uan\+Channel} $>$ ns3\+::\+Uan\+Net\+Device\+::\+Do\+Get\+Channel (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UanNetDevice_a9bd7ab08d599a1781c7a36826777f623}{}\label{classns3_1_1UanNetDevice_a9bd7ab08d599a1781c7a36826777f623}
\begin{DoxyReturn}{Returns}
The channel attached to this device. 
\end{DoxyReturn}

\begin{DoxyCode}
187 \{
188   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UanNetDevice_ab528925b6ada30cd1e9a8acc23a4f9dd}{m\_channel};
189 
190 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Forward\+Up@{Forward\+Up}}
\index{Forward\+Up@{Forward\+Up}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Forward\+Up(\+Ptr$<$ Packet $>$ pkt, const Uan\+Address \&src)}{ForwardUp(Ptr< Packet > pkt, const UanAddress &src)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uan\+Net\+Device\+::\+Forward\+Up (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{pkt, }
\item[{const {\bf Uan\+Address} \&}]{src}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1UanNetDevice_a6bd742bff7683658efa38d726619b8c4}{}\label{classns3_1_1UanNetDevice_a6bd742bff7683658efa38d726619b8c4}
Forward the packet to a higher level, set with Set\+Receive\+Callback.


\begin{DoxyParams}{Parameters}
{\em pkt} & The packet. \\
\hline
{\em src} & The source address. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
330 \{
331   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Forwarding packet up to application"});
332   \hyperlink{classns3_1_1UanNetDevice_a427c15bb70e38facb1c50fe76bfe1979}{m\_rxLogger} (pkt, src);
333   \hyperlink{classns3_1_1UanNetDevice_aee4321afad0167cdb8f3a6956be03983}{m\_forwardUp} (\textcolor{keyword}{this}, pkt, 0, src);
334 
335 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Get\+Address@{Get\+Address}}
\index{Get\+Address@{Get\+Address}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Address(void) const }{GetAddress(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Uan\+Net\+Device\+::\+Get\+Address (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UanNetDevice_a82f8ad21dacb782e82a4aff50c32a5d7}{}\label{classns3_1_1UanNetDevice_a82f8ad21dacb782e82a4aff50c32a5d7}
\begin{DoxyReturn}{Returns}
the current \hyperlink{classns3_1_1Address}{Address} of this interface. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a671f99de496d6f09ae343bb715301fb2}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
223 \{
224   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UanNetDevice_af07aff40dbb010fd62ad0fdcbf394995}{m\_mac}->GetAddress ();
225 \}
\end{DoxyCode}
\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Get\+Broadcast@{Get\+Broadcast}}
\index{Get\+Broadcast@{Get\+Broadcast}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Broadcast(void) const }{GetBroadcast(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Uan\+Net\+Device\+::\+Get\+Broadcast (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UanNetDevice_a0a7b435a96c84f3ad394df300946a5af}{}\label{classns3_1_1UanNetDevice_a0a7b435a96c84f3ad394df300946a5af}
\begin{DoxyReturn}{Returns}
the broadcast address supported by this netdevice.
\end{DoxyReturn}
Calling this method is invalid if Is\+Broadcast returns not true. 

Implements \hyperlink{classns3_1_1NetDevice_a4724e03bc548dd8e967cc4a7356197bd}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
256 \{
257   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UanNetDevice_af07aff40dbb010fd62ad0fdcbf394995}{m\_mac}->GetBroadcast ();
258 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Get\+Channel@{Get\+Channel}}
\index{Get\+Channel@{Get\+Channel}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Channel(void) const }{GetChannel(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Channel} $>$ ns3\+::\+Uan\+Net\+Device\+::\+Get\+Channel (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UanNetDevice_a5254720ba19b94e1123beea1d3744c29}{}\label{classns3_1_1UanNetDevice_a5254720ba19b94e1123beea1d3744c29}
\begin{DoxyReturn}{Returns}
the channel this \hyperlink{classns3_1_1NetDevice}{Net\+Device} is connected to. The value returned can be zero if the \hyperlink{classns3_1_1NetDevice}{Net\+Device} is not yet connected to any channel or if the underlying \hyperlink{classns3_1_1NetDevice}{Net\+Device} has no concept of a channel. i.\+e., callers {\itshape must} check for zero and be ready to handle it. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a3d810bd2738634e2e851661271828565}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
217 \{
218   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UanNetDevice_ab528925b6ada30cd1e9a8acc23a4f9dd}{m\_channel};
219 \}
\end{DoxyCode}
\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Get\+If\+Index@{Get\+If\+Index}}
\index{Get\+If\+Index@{Get\+If\+Index}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+If\+Index(void) const }{GetIfIndex(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Uan\+Net\+Device\+::\+Get\+If\+Index (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UanNetDevice_acf7b3a85853c4160d1a134a02647e0b3}{}\label{classns3_1_1UanNetDevice_acf7b3a85853c4160d1a134a02647e0b3}
\begin{DoxyReturn}{Returns}
index if\+Index of the device 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a8c1ae2ec8eadc4524dfc1e425bfa0850}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
211 \{
212   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UanNetDevice_a3416bb182a67acc209637bfe619a76f6}{m\_ifIndex};
213 \}
\end{DoxyCode}
\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Get\+Mac@{Get\+Mac}}
\index{Get\+Mac@{Get\+Mac}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Mac(void) const }{GetMac(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Uan\+Mac} $>$ ns3\+::\+Uan\+Net\+Device\+::\+Get\+Mac (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1UanNetDevice_adb4ad57f640b285d238687713c9826b3}{}\label{classns3_1_1UanNetDevice_adb4ad57f640b285d238687713c9826b3}
Get the M\+AC used by this device.

\begin{DoxyReturn}{Returns}
The M\+AC. 
\end{DoxyReturn}

\begin{DoxyCode}
193 \{
194   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UanNetDevice_af07aff40dbb010fd62ad0fdcbf394995}{m\_mac};
195 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Get\+Mtu@{Get\+Mtu}}
\index{Get\+Mtu@{Get\+Mtu}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Mtu(void) const }{GetMtu(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Uan\+Net\+Device\+::\+Get\+Mtu (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UanNetDevice_a56a7bf94f2d58cde6c564465eacc47ad}{}\label{classns3_1_1UanNetDevice_a56a7bf94f2d58cde6c564465eacc47ad}
\begin{DoxyReturn}{Returns}
the link-\/level M\+TU in bytes for this interface.
\end{DoxyReturn}
This value is typically used by the IP layer to perform IP fragmentation when needed. 

Implements \hyperlink{classns3_1_1NetDevice_a91f4f5d01bc2d567c1e0a69b63a4cf14}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
238 \{
239   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UanNetDevice_ae7c34c0bb24052fba7fbdcfb50f94214}{m\_mtu};
240 \}
\end{DoxyCode}
\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Get\+Multicast@{Get\+Multicast}}
\index{Get\+Multicast@{Get\+Multicast}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Multicast(\+Ipv4\+Address multicast\+Group) const }{GetMulticast(Ipv4Address multicastGroup) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Uan\+Net\+Device\+::\+Get\+Multicast (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{multicast\+Group}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UanNetDevice_af79d030e9e0d8fc4bb53483ac500f99b}{}\label{classns3_1_1UanNetDevice_af79d030e9e0d8fc4bb53483ac500f99b}


Make and return a M\+AC multicast address using the provided multicast group. 

\{1112\} says that an \hyperlink{classns3_1_1Ipv4}{Ipv4} host group address is mapped to an Ethernet multicast address by placing the low-\/order 23-\/bits of the IP address into the low-\/order 23 bits of the Ethernet multicast address 01-\/00-\/5\+E-\/00-\/00-\/00 (hex). Similar R\+F\+Cs exist for \hyperlink{classns3_1_1Ipv6}{Ipv6} and Eui64 mappings. This method performs the multicast address creation function appropriate to the underlying M\+AC address of the device. This M\+AC address is encapsulated in an abstract \hyperlink{classns3_1_1Address}{Address} to avoid dependencies on the exact M\+AC address format.

In the case of net devices that do not support multicast, clients are expected to test \hyperlink{classns3_1_1NetDevice_a1afb4848a9226540f1ff51f9b31ae95e}{Net\+Device\+::\+Is\+Multicast} and avoid attempting to map multicast packets. Subclasses of \hyperlink{classns3_1_1NetDevice}{Net\+Device} that do support multicasting are expected to override this method and provide an implementation appropriate to the particular device.


\begin{DoxyParams}{Parameters}
{\em multicast\+Group} & The IP address for the multicast group destination of the packet. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The M\+AC multicast \hyperlink{classns3_1_1Address}{Address} used to send packets to the provided multicast group.
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Calling this method is invalid if Is\+Multicast returns not true. 
\end{DoxyWarning}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1UanNetDevice_ad5245f51eb712c75c30d99ac97b3706b}{Is\+Multicast()} 
\end{DoxySeeAlso}


Implements \hyperlink{classns3_1_1NetDevice_a98aa4852df367b6a393c8cc1d88af0d9}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
268 \{
269   \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"UanNetDevice does not support multicast"});
270   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UanNetDevice_af07aff40dbb010fd62ad0fdcbf394995}{m\_mac}->GetBroadcast ();
271 \}
\end{DoxyCode}
\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Get\+Multicast@{Get\+Multicast}}
\index{Get\+Multicast@{Get\+Multicast}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Multicast(\+Ipv6\+Address addr) const }{GetMulticast(Ipv6Address addr) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Uan\+Net\+Device\+::\+Get\+Multicast (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{addr}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UanNetDevice_ace5aeef735e5b5d314a4c9a3802c244b}{}\label{classns3_1_1UanNetDevice_ace5aeef735e5b5d314a4c9a3802c244b}


Get the M\+AC multicast address corresponding to the I\+Pv6 address provided. 


\begin{DoxyParams}{Parameters}
{\em addr} & I\+Pv6 address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the M\+AC multicast address 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Calling this method is invalid if Is\+Multicast returns not true. 
\end{DoxyWarning}


Implements \hyperlink{classns3_1_1NetDevice_a46479a2c0101c6f9da9251ed4d7575bd}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
275 \{
276   \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"UanNetDevice does not support multicast"});
277   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UanNetDevice_af07aff40dbb010fd62ad0fdcbf394995}{m\_mac}->GetBroadcast ();
278 \}
\end{DoxyCode}
\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Get\+Node@{Get\+Node}}
\index{Get\+Node@{Get\+Node}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Node(void) const }{GetNode(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Node} $>$ ns3\+::\+Uan\+Net\+Device\+::\+Get\+Node (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UanNetDevice_a5568381797d83e788086ac2dcd34b14d}{}\label{classns3_1_1UanNetDevice_a5568381797d83e788086ac2dcd34b14d}
\begin{DoxyReturn}{Returns}
the node base class which contains this network interface.
\end{DoxyReturn}
When a subclass needs to get access to the underlying node base class to print the nodeid for example, it can invoke this method. 

Implements \hyperlink{classns3_1_1NetDevice_a098b6cc4339ac00c62e75cfa48c8aeac}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
306 \{
307   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UanNetDevice_a762b0c54b288f7df70ecc7a701d6a720}{m\_node};
308 \}
\end{DoxyCode}
\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Get\+Phy@{Get\+Phy}}
\index{Get\+Phy@{Get\+Phy}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Phy(void) const }{GetPhy(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Uan\+Phy} $>$ ns3\+::\+Uan\+Net\+Device\+::\+Get\+Phy (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1UanNetDevice_abff3efdff8f4c31c2bb0ea780a6b99a8}{}\label{classns3_1_1UanNetDevice_abff3efdff8f4c31c2bb0ea780a6b99a8}
Get the Phy used by this device.

\begin{DoxyReturn}{Returns}
The Phy. 
\end{DoxyReturn}

\begin{DoxyCode}
199 \{
200   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UanNetDevice_a844d7ac9f29552eebf86d2f7cbf3c39c}{m\_phy};
201 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 9


\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Get\+Transducer@{Get\+Transducer}}
\index{Get\+Transducer@{Get\+Transducer}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Transducer(void) const }{GetTransducer(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Uan\+Transducer} $>$ ns3\+::\+Uan\+Net\+Device\+::\+Get\+Transducer (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1UanNetDevice_a28fd8d3e52558859abd0757f48e8d478}{}\label{classns3_1_1UanNetDevice_a28fd8d3e52558859abd0757f48e8d478}
Get the transducer associated with this device.

\begin{DoxyReturn}{Returns}
The transducer. 
\end{DoxyReturn}

\begin{DoxyCode}
339 \{
340   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UanNetDevice_a9576fcd3b2e1f07fbb0c7125f905f0e0}{m\_trans};
341 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 10


\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Uan\+Net\+Device\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1UanNetDevice_a8dc58ba9c4e22e1468f987fa047e565b}{}\label{classns3_1_1UanNetDevice_a8dc58ba9c4e22e1468f987fa047e565b}
Register this type. \begin{DoxyReturn}{Returns}
The \hyperlink{classns3_1_1TypeId}{Type\+Id}. 
\end{DoxyReturn}

\begin{DoxyCode}
90 \{
91   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::UanNetDevice"})
92     .SetParent<NetDevice> ()
93     .SetGroupName (\textcolor{stringliteral}{"Uan"})
94     .AddAttribute (\textcolor{stringliteral}{"Channel"}, \textcolor{stringliteral}{"The channel attached to this device."},
95                    PointerValue (),
96                    MakePointerAccessor (&\hyperlink{classns3_1_1UanNetDevice_a9bd7ab08d599a1781c7a36826777f623}{UanNetDevice::DoGetChannel}, &
      \hyperlink{classns3_1_1UanNetDevice_a987daa8c043146fad8975cb43fbb24e5}{UanNetDevice::SetChannel}),
97                    MakePointerChecker<UanChannel> ())
98     .AddAttribute (\textcolor{stringliteral}{"Phy"}, \textcolor{stringliteral}{"The PHY layer attached to this device."},
99                    PointerValue (),
100                    MakePointerAccessor (&\hyperlink{classns3_1_1UanNetDevice_abff3efdff8f4c31c2bb0ea780a6b99a8}{UanNetDevice::GetPhy}, &
      \hyperlink{classns3_1_1UanNetDevice_af6d039ecff08a8f794738fd62956f917}{UanNetDevice::SetPhy}),
101                    MakePointerChecker<UanPhy> ())
102     .AddAttribute (\textcolor{stringliteral}{"Mac"}, \textcolor{stringliteral}{"The MAC layer attached to this device."},
103                    PointerValue (),
104                    MakePointerAccessor (&\hyperlink{classns3_1_1UanNetDevice_adb4ad57f640b285d238687713c9826b3}{UanNetDevice::GetMac}, &
      \hyperlink{classns3_1_1UanNetDevice_a7225cfda064ecc308e224eb1b11397b5}{UanNetDevice::SetMac}),
105                    MakePointerChecker<UanMac> ())
106     .AddAttribute (\textcolor{stringliteral}{"Transducer"}, \textcolor{stringliteral}{"The Transducer attached to this device."},
107                    PointerValue (),
108                    MakePointerAccessor (&\hyperlink{classns3_1_1UanNetDevice_a28fd8d3e52558859abd0757f48e8d478}{UanNetDevice::GetTransducer},
109                                         &\hyperlink{classns3_1_1UanNetDevice_ad91b46a001ee99241d7579800f93eab5}{UanNetDevice::SetTransducer}),
110                    MakePointerChecker<UanTransducer> ())
111     .AddTraceSource (\textcolor{stringliteral}{"Rx"}, \textcolor{stringliteral}{"Received payload from the MAC layer."},
112                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1UanNetDevice_a427c15bb70e38facb1c50fe76bfe1979}{UanNetDevice::m\_rxLogger}),
113                      \textcolor{stringliteral}{"ns3::UanNetDevice::RxTxTracedCallback"})
114     .AddTraceSource (\textcolor{stringliteral}{"Tx"}, \textcolor{stringliteral}{"Send payload to the MAC layer."},
115                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1UanNetDevice_ab1ed35043886ee497c4ea96267c50b79}{UanNetDevice::m\_txLogger}),
116                      \textcolor{stringliteral}{"ns3::UanNetDevice::RxTxTracedCallback"})
117   ;
118   \textcolor{keywordflow}{return} tid;
119 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 11


\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Is\+Bridge@{Is\+Bridge}}
\index{Is\+Bridge@{Is\+Bridge}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Bridge(void) const }{IsBridge(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Uan\+Net\+Device\+::\+Is\+Bridge (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UanNetDevice_a18646020a7efafd7f74217d7ad9edf76}{}\label{classns3_1_1UanNetDevice_a18646020a7efafd7f74217d7ad9edf76}


Return true if the net device is acting as a bridge. 

\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Bridge flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a9d34556a1c83a69dacb08698ca4a1d94}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
282 \{
283   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
284 \}
\end{DoxyCode}
\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Is\+Broadcast@{Is\+Broadcast}}
\index{Is\+Broadcast@{Is\+Broadcast}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Broadcast(void) const }{IsBroadcast(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Uan\+Net\+Device\+::\+Is\+Broadcast (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UanNetDevice_a813bf46757bd911908aa92a10c1a7d15}{}\label{classns3_1_1UanNetDevice_a813bf46757bd911908aa92a10c1a7d15}
\begin{DoxyReturn}{Returns}
true if this interface supports a broadcast address, false otherwise. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a67f992b20858cd7b397d8fba2feff141}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
250 \{
251   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
252 \}
\end{DoxyCode}
\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Is\+Link\+Up@{Is\+Link\+Up}}
\index{Is\+Link\+Up@{Is\+Link\+Up}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Link\+Up(void) const }{IsLinkUp(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Uan\+Net\+Device\+::\+Is\+Link\+Up (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UanNetDevice_aecf041a5878cf1aab62e155fe007e52f}{}\label{classns3_1_1UanNetDevice_aecf041a5878cf1aab62e155fe007e52f}
\begin{DoxyReturn}{Returns}
true if link is up; false otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_afe1822b79e19a05ab95f693c8fb64fc7}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
244 \{
245   \textcolor{keywordflow}{return}  (\hyperlink{classns3_1_1UanNetDevice_a983f3b724d8d8926b09e9228d0b5a7b2}{m\_linkup} && (\hyperlink{classns3_1_1UanNetDevice_a844d7ac9f29552eebf86d2f7cbf3c39c}{m\_phy} != 0));
246 \}
\end{DoxyCode}
\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Is\+Multicast@{Is\+Multicast}}
\index{Is\+Multicast@{Is\+Multicast}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Multicast(void) const }{IsMulticast(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Uan\+Net\+Device\+::\+Is\+Multicast (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UanNetDevice_ad5245f51eb712c75c30d99ac97b3706b}{}\label{classns3_1_1UanNetDevice_ad5245f51eb712c75c30d99ac97b3706b}
\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Multicast flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a1afb4848a9226540f1ff51f9b31ae95e}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
262 \{
263   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
264 \}
\end{DoxyCode}
\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Is\+Point\+To\+Point@{Is\+Point\+To\+Point}}
\index{Is\+Point\+To\+Point@{Is\+Point\+To\+Point}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Point\+To\+Point(void) const }{IsPointToPoint(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Uan\+Net\+Device\+::\+Is\+Point\+To\+Point (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UanNetDevice_a914ed77672de3652a366a84b1e582de7}{}\label{classns3_1_1UanNetDevice_a914ed77672de3652a366a84b1e582de7}


Return true if the net device is on a point-\/to-\/point link. 

\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Point\+To\+Point flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a718177f25efeaf2dbf8a18fcab87224d}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
287 \{
288   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
289 \}
\end{DoxyCode}
\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Needs\+Arp@{Needs\+Arp}}
\index{Needs\+Arp@{Needs\+Arp}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Needs\+Arp(void) const }{NeedsArp(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Uan\+Net\+Device\+::\+Needs\+Arp (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UanNetDevice_a82a4180f4ae1538878aec6a882794e91}{}\label{classns3_1_1UanNetDevice_a82a4180f4ae1538878aec6a882794e91}
\begin{DoxyReturn}{Returns}
true if A\+RP is needed, false otherwise.
\end{DoxyReturn}
Called by higher-\/layers to check if this \hyperlink{classns3_1_1NetDevice}{Net\+Device} requires A\+RP to be used. 

Implements \hyperlink{classns3_1_1NetDevice_ab1a133696310cad3dc2c3d1a4993f310}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
318 \{
319   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
320 \}
\end{DoxyCode}
\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Send@{Send}}
\index{Send@{Send}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Send(\+Ptr$<$ Packet $>$ packet, const Address \&dest, uint16\+\_\+t protocol\+Number)}{Send(Ptr< Packet > packet, const Address &dest, uint16_t protocolNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Uan\+Net\+Device\+::\+Send (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{const {\bf Address} \&}]{dest, }
\item[{uint16\+\_\+t}]{protocol\+Number}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UanNetDevice_aca7865bf58e980106b68a177d41d346b}{}\label{classns3_1_1UanNetDevice_aca7865bf58e980106b68a177d41d346b}

\begin{DoxyParams}{Parameters}
{\em packet} & packet sent from above down to Network Device \\
\hline
{\em dest} & mac address of the destination (already resolved) \\
\hline
{\em protocol\+Number} & identifies the type of payload contained in this packet. Used to call the right L3\+Protocol when the packet is received.\\
\hline
\end{DoxyParams}
Called from higher layer to send packet into Network Device to the specified destination \hyperlink{classns3_1_1Address}{Address}

\begin{DoxyReturn}{Returns}
whether the Send operation succeeded 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a59f41afb0fe8951bb94d5739cbe6ee7d}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
293 \{
294   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UanNetDevice_af07aff40dbb010fd62ad0fdcbf394995}{m\_mac}->Enqueue (packet, dest, protocolNumber);
295 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 12


\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Send\+From@{Send\+From}}
\index{Send\+From@{Send\+From}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Send\+From(\+Ptr$<$ Packet $>$ packet, const Address \&source, const Address \&dest, uint16\+\_\+t protocol\+Number)}{SendFrom(Ptr< Packet > packet, const Address &source, const Address &dest, uint16_t protocolNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Uan\+Net\+Device\+::\+Send\+From (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{const {\bf Address} \&}]{source, }
\item[{const {\bf Address} \&}]{dest, }
\item[{uint16\+\_\+t}]{protocol\+Number}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UanNetDevice_acbce400d57951dd7b9207068ad080191}{}\label{classns3_1_1UanNetDevice_acbce400d57951dd7b9207068ad080191}

\begin{DoxyParams}{Parameters}
{\em packet} & packet sent from above down to Network Device \\
\hline
{\em source} & source mac address (so called \char`\"{}\+M\+A\+C spoofing\char`\"{}) \\
\hline
{\em dest} & mac address of the destination (already resolved) \\
\hline
{\em protocol\+Number} & identifies the type of payload contained in this packet. Used to call the right L3\+Protocol when the packet is received.\\
\hline
\end{DoxyParams}
Called from higher layer to send packet into Network Device with the specified source and destination Addresses.

\begin{DoxyReturn}{Returns}
whether the Send operation succeeded 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a19d55a4746c1ae584bf7da69959a885b}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
299 \{
300   \textcolor{comment}{// Not yet implemented}
301   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (0, \textcolor{stringliteral}{"Not yet implemented"});
302   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
303 \}
\end{DoxyCode}
\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Set\+Address@{Set\+Address}}
\index{Set\+Address@{Set\+Address}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Address(\+Address address)}{SetAddress(Address address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uan\+Net\+Device\+::\+Set\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UanNetDevice_a4e0c30c0b67bae0eb769336688799e02}{}\label{classns3_1_1UanNetDevice_a4e0c30c0b67bae0eb769336688799e02}
Set the address of this interface 
\begin{DoxyParams}{Parameters}
{\em address} & address to set \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1NetDevice_ab56dc36bc0547471ab3210eda60ee76c}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
388 \{
389   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (0, \textcolor{stringliteral}{"Tried to set MAC address with no MAC"});
390   \hyperlink{classns3_1_1UanNetDevice_af07aff40dbb010fd62ad0fdcbf394995}{m\_mac}->SetAddress (\hyperlink{classns3_1_1UanAddress_a43ffcb02795ab454a8ba0e0fdd5fdb41}{UanAddress::ConvertFrom} (address));
391 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13


\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Set\+Channel@{Set\+Channel}}
\index{Set\+Channel@{Set\+Channel}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Channel(\+Ptr$<$ Uan\+Channel $>$ channel)}{SetChannel(Ptr< UanChannel > channel)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uan\+Net\+Device\+::\+Set\+Channel (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Uan\+Channel} $>$}]{channel}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UanNetDevice_a987daa8c043146fad8975cb43fbb24e5}{}\label{classns3_1_1UanNetDevice_a987daa8c043146fad8975cb43fbb24e5}
Attach a channel.


\begin{DoxyParams}{Parameters}
{\em channel} & The channel. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
165 \{
166   \textcolor{keywordflow}{if} (channel != 0)
167     \{
168       \hyperlink{classns3_1_1UanNetDevice_ab528925b6ada30cd1e9a8acc23a4f9dd}{m\_channel} = channel;
169       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Set CHANNEL"});
170       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UanNetDevice_a9576fcd3b2e1f07fbb0c7125f905f0e0}{m\_trans} != 0)
171         \{
172 
173           \hyperlink{classns3_1_1UanNetDevice_ab528925b6ada30cd1e9a8acc23a4f9dd}{m\_channel}->AddDevice (\textcolor{keyword}{this}, \hyperlink{classns3_1_1UanNetDevice_a9576fcd3b2e1f07fbb0c7125f905f0e0}{m\_trans});
174           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Added self to channel device list"});
175           \hyperlink{classns3_1_1UanNetDevice_a9576fcd3b2e1f07fbb0c7125f905f0e0}{m\_trans}->SetChannel (\hyperlink{classns3_1_1UanNetDevice_ab528925b6ada30cd1e9a8acc23a4f9dd}{m\_channel});
176           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Set Transducer channel"});
177         \}
178       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UanNetDevice_a844d7ac9f29552eebf86d2f7cbf3c39c}{m\_phy} != 0 )
179         \{
180           \hyperlink{classns3_1_1UanNetDevice_a844d7ac9f29552eebf86d2f7cbf3c39c}{m\_phy}->SetChannel (channel);
181         \}
182     \}
183 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 14


\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Set\+If\+Index@{Set\+If\+Index}}
\index{Set\+If\+Index@{Set\+If\+Index}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+If\+Index(const uint32\+\_\+t index)}{SetIfIndex(const uint32_t index)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uan\+Net\+Device\+::\+Set\+If\+Index (
\begin{DoxyParamCaption}
\item[{const uint32\+\_\+t}]{index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UanNetDevice_a2d877f8da3c474bc75f5c41049e06cac}{}\label{classns3_1_1UanNetDevice_a2d877f8da3c474bc75f5c41049e06cac}

\begin{DoxyParams}{Parameters}
{\em index} & if\+Index of the device \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1NetDevice_a2e1ac6c1189cd565420305d85a193fb8}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
205 \{
206   \hyperlink{classns3_1_1UanNetDevice_a3416bb182a67acc209637bfe619a76f6}{m\_ifIndex} = index;
207 \}
\end{DoxyCode}
\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Set\+Mac@{Set\+Mac}}
\index{Set\+Mac@{Set\+Mac}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Mac(\+Ptr$<$ Uan\+Mac $>$ mac)}{SetMac(Ptr< UanMac > mac)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uan\+Net\+Device\+::\+Set\+Mac (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Uan\+Mac} $>$}]{mac}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UanNetDevice_a7225cfda064ecc308e224eb1b11397b5}{}\label{classns3_1_1UanNetDevice_a7225cfda064ecc308e224eb1b11397b5}
Set the M\+AC layer for this device.


\begin{DoxyParams}{Parameters}
{\em mac} & The M\+AC layer. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
123 \{
124   \textcolor{keywordflow}{if} (mac != 0)
125     \{
126       \hyperlink{classns3_1_1UanNetDevice_af07aff40dbb010fd62ad0fdcbf394995}{m\_mac} = mac;
127       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Set MAC"});
128 
129       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UanNetDevice_a844d7ac9f29552eebf86d2f7cbf3c39c}{m\_phy} != 0)
130         \{
131           \hyperlink{classns3_1_1UanNetDevice_a844d7ac9f29552eebf86d2f7cbf3c39c}{m\_phy}->SetMac (mac);
132           \hyperlink{classns3_1_1UanNetDevice_af07aff40dbb010fd62ad0fdcbf394995}{m\_mac}->AttachPhy (\hyperlink{classns3_1_1UanNetDevice_a844d7ac9f29552eebf86d2f7cbf3c39c}{m\_phy});
133           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Attached MAC to PHY"});
134         \}
135       \hyperlink{classns3_1_1UanNetDevice_af07aff40dbb010fd62ad0fdcbf394995}{m\_mac}->SetForwardUpCb (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1UanNetDevice_a6bd742bff7683658efa38d726619b8c4}{UanNetDevice::ForwardUp}, \textcolor{keyword}{this}));
136     \}
137 
138 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 15




Here is the caller graph for this function\+:
% FIG 16


\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Set\+Mtu@{Set\+Mtu}}
\index{Set\+Mtu@{Set\+Mtu}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Mtu(const uint16\+\_\+t mtu)}{SetMtu(const uint16_t mtu)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Uan\+Net\+Device\+::\+Set\+Mtu (
\begin{DoxyParamCaption}
\item[{const uint16\+\_\+t}]{mtu}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UanNetDevice_a2e7ad23d65650a02984e6c6afaa1744b}{}\label{classns3_1_1UanNetDevice_a2e7ad23d65650a02984e6c6afaa1744b}

\begin{DoxyParams}{Parameters}
{\em mtu} & M\+TU value, in bytes, to set for the device \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether the M\+TU value was within legal bounds
\end{DoxyReturn}
Override for default M\+TU defined on a per-\/type basis. \begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000163}{Todo}]Check this in M\+AC \end{DoxyRefDesc}


Implements \hyperlink{classns3_1_1NetDevice_a2ba4956d45cde68eab3cbdd6ede06df0}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
229 \{
231   \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"UanNetDevice:  MTU is not implemented"});
232   \hyperlink{classns3_1_1UanNetDevice_ae7c34c0bb24052fba7fbdcfb50f94214}{m\_mtu} = mtu;
233   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
234 \}
\end{DoxyCode}
\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Set\+Node@{Set\+Node}}
\index{Set\+Node@{Set\+Node}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Node(\+Ptr$<$ Node $>$ node)}{SetNode(Ptr< Node > node)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uan\+Net\+Device\+::\+Set\+Node (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UanNetDevice_a8996251b8e755fa575acd4746538d5a3}{}\label{classns3_1_1UanNetDevice_a8996251b8e755fa575acd4746538d5a3}

\begin{DoxyParams}{Parameters}
{\em node} & the node associated to this netdevice.\\
\hline
\end{DoxyParams}
This method is called from \hyperlink{classns3_1_1Node_a42ff83ee1d5d1649c770d3f5b62375de}{ns3\+::\+Node\+::\+Add\+Device}. 

Implements \hyperlink{classns3_1_1NetDevice_a3ae520ae06e93b957f0f56f113319a08}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
312 \{
313   \hyperlink{classns3_1_1UanNetDevice_a762b0c54b288f7df70ecc7a701d6a720}{m\_node} = node;
314 \}
\end{DoxyCode}
\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Set\+Phy@{Set\+Phy}}
\index{Set\+Phy@{Set\+Phy}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Phy(\+Ptr$<$ Uan\+Phy $>$ phy)}{SetPhy(Ptr< UanPhy > phy)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uan\+Net\+Device\+::\+Set\+Phy (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Uan\+Phy} $>$}]{phy}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UanNetDevice_af6d039ecff08a8f794738fd62956f917}{}\label{classns3_1_1UanNetDevice_af6d039ecff08a8f794738fd62956f917}
Set the Phy layer for this device.


\begin{DoxyParams}{Parameters}
{\em phy} & The P\+HY layer. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
142 \{
143   \textcolor{keywordflow}{if} (phy != 0)
144     \{
145       \hyperlink{classns3_1_1UanNetDevice_a844d7ac9f29552eebf86d2f7cbf3c39c}{m\_phy} = phy;
146       \hyperlink{classns3_1_1UanNetDevice_a844d7ac9f29552eebf86d2f7cbf3c39c}{m\_phy}->SetDevice (Ptr<UanNetDevice> (\textcolor{keyword}{this}));
147       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Set PHY"});
148       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UanNetDevice_af07aff40dbb010fd62ad0fdcbf394995}{m\_mac} != 0)
149         \{
150           \hyperlink{classns3_1_1UanNetDevice_af07aff40dbb010fd62ad0fdcbf394995}{m\_mac}->AttachPhy (phy);
151           \hyperlink{classns3_1_1UanNetDevice_a844d7ac9f29552eebf86d2f7cbf3c39c}{m\_phy}->SetMac (\hyperlink{classns3_1_1UanNetDevice_af07aff40dbb010fd62ad0fdcbf394995}{m\_mac});
152           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Attached PHY to MAC"});
153         \}
154       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UanNetDevice_a9576fcd3b2e1f07fbb0c7125f905f0e0}{m\_trans} != 0)
155         \{
156           \hyperlink{classns3_1_1UanNetDevice_a844d7ac9f29552eebf86d2f7cbf3c39c}{m\_phy}->SetTransducer (\hyperlink{classns3_1_1UanNetDevice_a9576fcd3b2e1f07fbb0c7125f905f0e0}{m\_trans});
157           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Added PHY to trans"});
158         \}
159 
160     \}
161 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 17


\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Set\+Promisc\+Receive\+Callback@{Set\+Promisc\+Receive\+Callback}}
\index{Set\+Promisc\+Receive\+Callback@{Set\+Promisc\+Receive\+Callback}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Promisc\+Receive\+Callback(\+Promisc\+Receive\+Callback cb)}{SetPromiscReceiveCallback(PromiscReceiveCallback cb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uan\+Net\+Device\+::\+Set\+Promisc\+Receive\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Promisc\+Receive\+Callback}}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UanNetDevice_a446e2bdaff56460e8f64374c954642cb}{}\label{classns3_1_1UanNetDevice_a446e2bdaff56460e8f64374c954642cb}

\begin{DoxyParams}{Parameters}
{\em cb} & callback to invoke whenever a packet has been received in promiscuous mode and must be forwarded to the higher layers.\\
\hline
\end{DoxyParams}
Enables netdevice promiscuous mode and sets the callback that will handle promiscuous mode packets. Note, promiscuous mode packets means {\itshape all} packets, including those packets that can be sensed by the netdevice but which are intended to be received by other hosts. 

Implements \hyperlink{classns3_1_1NetDevice_a3968946bdbb74d47d7b13612baad7d6d}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
375 \{
376   \textcolor{comment}{// Not implemented yet}
377   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (0, \textcolor{stringliteral}{"Not yet implemented"});
378 \}
\end{DoxyCode}
\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Set\+Receive\+Callback@{Set\+Receive\+Callback}}
\index{Set\+Receive\+Callback@{Set\+Receive\+Callback}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Receive\+Callback(\+Net\+Device\+::\+Receive\+Callback cb)}{SetReceiveCallback(NetDevice::ReceiveCallback cb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uan\+Net\+Device\+::\+Set\+Receive\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Net\+Device\+::\+Receive\+Callback}}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UanNetDevice_acee91182c836cd8dfbbd8e46271dc9be}{}\label{classns3_1_1UanNetDevice_acee91182c836cd8dfbbd8e46271dc9be}

\begin{DoxyParams}{Parameters}
{\em cb} & callback to invoke whenever a packet has been received and must be forwarded to the higher layers.\\
\hline
\end{DoxyParams}
Set the callback to be used to notify higher layers when a packet has been received. 

Implements \hyperlink{classns3_1_1NetDevice_ac63e4d5668e421fec4b5d37f32e7dd18}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
324 \{
325   \hyperlink{classns3_1_1UanNetDevice_aee4321afad0167cdb8f3a6956be03983}{m\_forwardUp} = cb;
326 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 18


\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Set\+Sleep\+Mode@{Set\+Sleep\+Mode}}
\index{Set\+Sleep\+Mode@{Set\+Sleep\+Mode}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Sleep\+Mode(bool sleep)}{SetSleepMode(bool sleep)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uan\+Net\+Device\+::\+Set\+Sleep\+Mode (
\begin{DoxyParamCaption}
\item[{bool}]{sleep}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UanNetDevice_a933871471c1026cb15486a156648f7a8}{}\label{classns3_1_1UanNetDevice_a933871471c1026cb15486a156648f7a8}
Set the Phy S\+L\+E\+EP mode.


\begin{DoxyParams}{Parameters}
{\em sleep} & S\+L\+E\+EP on or off. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
395 \{
396   \hyperlink{classns3_1_1UanNetDevice_a844d7ac9f29552eebf86d2f7cbf3c39c}{m\_phy}->SetSleepMode (sleep);
397 \}
\end{DoxyCode}
\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Set\+Transducer@{Set\+Transducer}}
\index{Set\+Transducer@{Set\+Transducer}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Transducer(\+Ptr$<$ Uan\+Transducer $>$ trans)}{SetTransducer(Ptr< UanTransducer > trans)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uan\+Net\+Device\+::\+Set\+Transducer (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Uan\+Transducer} $>$}]{trans}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UanNetDevice_ad91b46a001ee99241d7579800f93eab5}{}\label{classns3_1_1UanNetDevice_ad91b46a001ee99241d7579800f93eab5}
Set the transdcuer used by this device.


\begin{DoxyParams}{Parameters}
{\em trans} & The transducer. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
344 \{
345 
346   \textcolor{keywordflow}{if} (trans != 0)
347     \{
348       \hyperlink{classns3_1_1UanNetDevice_a9576fcd3b2e1f07fbb0c7125f905f0e0}{m\_trans} = trans;
349       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Set Transducer"});
350       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UanNetDevice_a844d7ac9f29552eebf86d2f7cbf3c39c}{m\_phy} != 0)
351         \{
352           \hyperlink{classns3_1_1UanNetDevice_a844d7ac9f29552eebf86d2f7cbf3c39c}{m\_phy}->SetTransducer (\hyperlink{classns3_1_1UanNetDevice_a9576fcd3b2e1f07fbb0c7125f905f0e0}{m\_trans});
353           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Attached Phy to transducer"});
354         \}
355 
356       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1UanNetDevice_ab528925b6ada30cd1e9a8acc23a4f9dd}{m\_channel} != 0)
357         \{
358           \hyperlink{classns3_1_1UanNetDevice_ab528925b6ada30cd1e9a8acc23a4f9dd}{m\_channel}->AddDevice (\textcolor{keyword}{this}, \hyperlink{classns3_1_1UanNetDevice_a9576fcd3b2e1f07fbb0c7125f905f0e0}{m\_trans});
359           \hyperlink{classns3_1_1UanNetDevice_a9576fcd3b2e1f07fbb0c7125f905f0e0}{m\_trans}->SetChannel (\hyperlink{classns3_1_1UanNetDevice_ab528925b6ada30cd1e9a8acc23a4f9dd}{m\_channel});
360           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Added self to channel device list"});
361         \}
362     \}
363 
364 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 19


\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!Supports\+Send\+From@{Supports\+Send\+From}}
\index{Supports\+Send\+From@{Supports\+Send\+From}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{Supports\+Send\+From(void) const }{SupportsSendFrom(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Uan\+Net\+Device\+::\+Supports\+Send\+From (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UanNetDevice_a874384b989b22f6b00bd55fdb2927e39}{}\label{classns3_1_1UanNetDevice_a874384b989b22f6b00bd55fdb2927e39}
\begin{DoxyReturn}{Returns}
true if this interface supports a bridging mode, false otherwise. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a04793d220b54c40e110ebf86dae5b25c}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
382 \{
383   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
384 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!m\+\_\+channel@{m\+\_\+channel}}
\index{m\+\_\+channel@{m\+\_\+channel}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+channel}{m_channel}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Uan\+Channel}$>$ ns3\+::\+Uan\+Net\+Device\+::m\+\_\+channel\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UanNetDevice_ab528925b6ada30cd1e9a8acc23a4f9dd}{}\label{classns3_1_1UanNetDevice_ab528925b6ada30cd1e9a8acc23a4f9dd}


The channel attached to this device. 

\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!m\+\_\+cleared@{m\+\_\+cleared}}
\index{m\+\_\+cleared@{m\+\_\+cleared}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+cleared}{m_cleared}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Uan\+Net\+Device\+::m\+\_\+cleared\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UanNetDevice_a94db1f444365c0961e0dc9b2faee00cf}{}\label{classns3_1_1UanNetDevice_a94db1f444365c0961e0dc9b2faee00cf}
Flag when we\textquotesingle{}ve been cleared. \index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!m\+\_\+forward\+Up@{m\+\_\+forward\+Up}}
\index{m\+\_\+forward\+Up@{m\+\_\+forward\+Up}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+forward\+Up}{m_forwardUp}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Receive\+Callback} ns3\+::\+Uan\+Net\+Device\+::m\+\_\+forward\+Up\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UanNetDevice_aee4321afad0167cdb8f3a6956be03983}{}\label{classns3_1_1UanNetDevice_aee4321afad0167cdb8f3a6956be03983}


The receive callback. 

\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!m\+\_\+if\+Index@{m\+\_\+if\+Index}}
\index{m\+\_\+if\+Index@{m\+\_\+if\+Index}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+if\+Index}{m_ifIndex}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Uan\+Net\+Device\+::m\+\_\+if\+Index\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UanNetDevice_a3416bb182a67acc209637bfe619a76f6}{}\label{classns3_1_1UanNetDevice_a3416bb182a67acc209637bfe619a76f6}


The interface index of this device. 

\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!m\+\_\+link\+Changes@{m\+\_\+link\+Changes}}
\index{m\+\_\+link\+Changes@{m\+\_\+link\+Changes}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+link\+Changes}{m_linkChanges}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback} ns3\+::\+Uan\+Net\+Device\+::m\+\_\+link\+Changes\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UanNetDevice_ab061747ef6929cb5ba1288d68ab5a679}{}\label{classns3_1_1UanNetDevice_ab061747ef6929cb5ba1288d68ab5a679}


\hyperlink{classns3_1_1Callback}{Callback} to invoke when the link state changes to UP. 

\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!m\+\_\+linkup@{m\+\_\+linkup}}
\index{m\+\_\+linkup@{m\+\_\+linkup}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+linkup}{m_linkup}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Uan\+Net\+Device\+::m\+\_\+linkup\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UanNetDevice_a983f3b724d8d8926b09e9228d0b5a7b2}{}\label{classns3_1_1UanNetDevice_a983f3b724d8d8926b09e9228d0b5a7b2}


The link state, true if up. 

\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!m\+\_\+mac@{m\+\_\+mac}}
\index{m\+\_\+mac@{m\+\_\+mac}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+mac}{m_mac}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Uan\+Mac}$>$ ns3\+::\+Uan\+Net\+Device\+::m\+\_\+mac\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UanNetDevice_af07aff40dbb010fd62ad0fdcbf394995}{}\label{classns3_1_1UanNetDevice_af07aff40dbb010fd62ad0fdcbf394995}


The M\+AC layer attached to this device. 

\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!m\+\_\+mtu@{m\+\_\+mtu}}
\index{m\+\_\+mtu@{m\+\_\+mtu}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+mtu}{m_mtu}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Uan\+Net\+Device\+::m\+\_\+mtu\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UanNetDevice_ae7c34c0bb24052fba7fbdcfb50f94214}{}\label{classns3_1_1UanNetDevice_ae7c34c0bb24052fba7fbdcfb50f94214}


The device M\+TU value, in bytes. 

\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!m\+\_\+node@{m\+\_\+node}}
\index{m\+\_\+node@{m\+\_\+node}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+node}{m_node}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Node}$>$ ns3\+::\+Uan\+Net\+Device\+::m\+\_\+node\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UanNetDevice_a762b0c54b288f7df70ecc7a701d6a720}{}\label{classns3_1_1UanNetDevice_a762b0c54b288f7df70ecc7a701d6a720}


The node hosting this device. 

\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!m\+\_\+phy@{m\+\_\+phy}}
\index{m\+\_\+phy@{m\+\_\+phy}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+phy}{m_phy}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Uan\+Phy}$>$ ns3\+::\+Uan\+Net\+Device\+::m\+\_\+phy\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UanNetDevice_a844d7ac9f29552eebf86d2f7cbf3c39c}{}\label{classns3_1_1UanNetDevice_a844d7ac9f29552eebf86d2f7cbf3c39c}


The P\+HY layer attached to this device. 

\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!m\+\_\+rx\+Logger@{m\+\_\+rx\+Logger}}
\index{m\+\_\+rx\+Logger@{m\+\_\+rx\+Logger}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+rx\+Logger}{m_rxLogger}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$, {\bf Uan\+Address}$>$ ns3\+::\+Uan\+Net\+Device\+::m\+\_\+rx\+Logger\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UanNetDevice_a427c15bb70e38facb1c50fe76bfe1979}{}\label{classns3_1_1UanNetDevice_a427c15bb70e38facb1c50fe76bfe1979}
Trace source triggered when forwarding up received payload from the M\+AC layer. \index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!m\+\_\+trans@{m\+\_\+trans}}
\index{m\+\_\+trans@{m\+\_\+trans}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+trans}{m_trans}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Uan\+Transducer}$>$ ns3\+::\+Uan\+Net\+Device\+::m\+\_\+trans\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UanNetDevice_a9576fcd3b2e1f07fbb0c7125f905f0e0}{}\label{classns3_1_1UanNetDevice_a9576fcd3b2e1f07fbb0c7125f905f0e0}


The Transducer attached to this device. 

\index{ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}!m\+\_\+tx\+Logger@{m\+\_\+tx\+Logger}}
\index{m\+\_\+tx\+Logger@{m\+\_\+tx\+Logger}!ns3\+::\+Uan\+Net\+Device@{ns3\+::\+Uan\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+tx\+Logger}{m_txLogger}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$, {\bf Uan\+Address}$>$ ns3\+::\+Uan\+Net\+Device\+::m\+\_\+tx\+Logger\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UanNetDevice_ab1ed35043886ee497c4ea96267c50b79}{}\label{classns3_1_1UanNetDevice_ab1ed35043886ee497c4ea96267c50b79}
Trace source triggered when sending to the M\+AC layer 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
uan/model/\hyperlink{uan-net-device_8h}{uan-\/net-\/device.\+h}\item 
uan/model/\hyperlink{uan-net-device_8cc}{uan-\/net-\/device.\+cc}\end{DoxyCompactItemize}
