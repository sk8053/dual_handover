\hypertarget{classns3_1_1BandwidthManager}{}\section{ns3\+:\+:Bandwidth\+Manager Class Reference}
\label{classns3_1_1BandwidthManager}\index{ns3\+::\+Bandwidth\+Manager@{ns3\+::\+Bandwidth\+Manager}}


This class manage the bandwidth request and grant mechanism. The bandwidth request and grant mechanism is supported by the Bandwidth Manager. Both BS and SS maintain a bandwidth manager. Furthermore BS\textquotesingle{}s bandwidth manager works together with the uplink scheduler to determine total bandwidth available and allocation size for each service flow. Bandwidth request mechanism is a key feature of the Wi\+M\+AX scheduler since all three non-\/\+U\+GS services explicitly request for bandwidth by sending a bandwidth request to BS.  




{\ttfamily \#include $<$bandwidth-\/manager.\+h$>$}



Inheritance diagram for ns3\+:\+:Bandwidth\+Manager\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Bandwidth\+Manager\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1BandwidthManager_a8e3c71fe101cbac029c780c1e81e5c4f}{Bandwidth\+Manager} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1WimaxNetDevice}{Wimax\+Net\+Device} $>$ device)
\item 
\hyperlink{classns3_1_1BandwidthManager_aa45d4a864547427e916c5ecbe34d2989}{$\sim$\+Bandwidth\+Manager} (void)
\item 
void \hyperlink{classns3_1_1BandwidthManager_a0743fe984259718af12a5cd98e3b8c4a}{Do\+Dispose} (void)
\item 
uint32\+\_\+t \hyperlink{classns3_1_1BandwidthManager_a60dbf098a04a926224fe4ac331e1e99c}{Calculate\+Allocation\+Size} (const \hyperlink{classns3_1_1SSRecord}{S\+S\+Record} $\ast$ss\+Record, const \hyperlink{classns3_1_1ServiceFlow}{Service\+Flow} $\ast$service\+Flow)
\item 
\hyperlink{classns3_1_1ServiceFlow}{Service\+Flow} $\ast$ \hyperlink{classns3_1_1BandwidthManager_a6ca1dc2064996be0c67fdd6697be9654}{Select\+Flow\+For\+Request} (uint32\+\_\+t \&bytes\+To\+Request)
\item 
void \hyperlink{classns3_1_1BandwidthManager_acbe780c5080f4001b2a1a117f446dd74}{Send\+Bandwidth\+Request} (uint8\+\_\+t uiuc, uint16\+\_\+t allocation\+Size)
\item 
void \hyperlink{classns3_1_1BandwidthManager_aa9e0e7e0c12acb2bac6076dc2520f134}{Process\+Bandwidth\+Request} (const \hyperlink{classns3_1_1BandwidthRequestHeader}{Bandwidth\+Request\+Header} \&bw\+Request\+Hdr)
\item 
void \hyperlink{classns3_1_1BandwidthManager_a2347150df25b7d6497947d5b755b6dd9}{Set\+Subframe\+Ratio} (void)
\begin{DoxyCompactList}\small\item\em Set subframe ratio. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1BandwidthManager_a8176b51c99d998010eed72d1bee7782d}{Get\+Symbols\+Per\+Frame\+Allocated} (void)
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1BandwidthManager_af2ab4110e0cbbd912bbb284353146871}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1BandwidthManager_a55e9833ade6726f77e582e1452728412}{Bandwidth\+Manager} (const \hyperlink{classns3_1_1BandwidthManager}{Bandwidth\+Manager} \&)
\begin{DoxyCompactList}\small\item\em Bandwidth manager type conversion operator. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1BandwidthManager}{Bandwidth\+Manager} \& \hyperlink{classns3_1_1BandwidthManager_a9bed6c6968629ab4d8ea50f6878f3f20}{operator=} (const \hyperlink{classns3_1_1BandwidthManager}{Bandwidth\+Manager} \&)
\begin{DoxyCompactList}\small\item\em Bandwidth manager assignement operator. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1WimaxNetDevice}{Wimax\+Net\+Device} $>$ \hyperlink{classns3_1_1BandwidthManager_a55eadfdb1964dad9875f14dfcf48eaed}{m\+\_\+device}
\begin{DoxyCompactList}\small\item\em the device \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1BandwidthManager_a18a831b18bb05ea6c9c48b77c3f1ac17}{m\+\_\+nr\+Bw\+Reqs\+Sent}
\begin{DoxyCompactList}\small\item\em bandwith requests sent \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
This class manage the bandwidth request and grant mechanism. The bandwidth request and grant mechanism is supported by the Bandwidth Manager. Both BS and SS maintain a bandwidth manager. Furthermore BS\textquotesingle{}s bandwidth manager works together with the uplink scheduler to determine total bandwidth available and allocation size for each service flow. Bandwidth request mechanism is a key feature of the Wi\+M\+AX scheduler since all three non-\/\+U\+GS services explicitly request for bandwidth by sending a bandwidth request to BS. 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Bandwidth\+Manager@{ns3\+::\+Bandwidth\+Manager}!Bandwidth\+Manager@{Bandwidth\+Manager}}
\index{Bandwidth\+Manager@{Bandwidth\+Manager}!ns3\+::\+Bandwidth\+Manager@{ns3\+::\+Bandwidth\+Manager}}
\subsubsection[{\texorpdfstring{Bandwidth\+Manager(\+Ptr$<$ Wimax\+Net\+Device $>$ device)}{BandwidthManager(Ptr< WimaxNetDevice > device)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Bandwidth\+Manager\+::\+Bandwidth\+Manager (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Wimax\+Net\+Device} $>$}]{device}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BandwidthManager_a8e3c71fe101cbac029c780c1e81e5c4f}{}\label{classns3_1_1BandwidthManager_a8e3c71fe101cbac029c780c1e81e5c4f}
Constructor


\begin{DoxyParams}{Parameters}
{\em device} & W\+I\+M\+AX device \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
51   : \hyperlink{classns3_1_1BandwidthManager_a55eadfdb1964dad9875f14dfcf48eaed}{m\_device} (device),
52     \hyperlink{classns3_1_1BandwidthManager_a18a831b18bb05ea6c9c48b77c3f1ac17}{m\_nrBwReqsSent} (0)
53 \{
54 \}
\end{DoxyCode}
\index{ns3\+::\+Bandwidth\+Manager@{ns3\+::\+Bandwidth\+Manager}!````~Bandwidth\+Manager@{$\sim$\+Bandwidth\+Manager}}
\index{````~Bandwidth\+Manager@{$\sim$\+Bandwidth\+Manager}!ns3\+::\+Bandwidth\+Manager@{ns3\+::\+Bandwidth\+Manager}}
\subsubsection[{\texorpdfstring{$\sim$\+Bandwidth\+Manager(void)}{~BandwidthManager(void)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Bandwidth\+Manager\+::$\sim$\+Bandwidth\+Manager (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BandwidthManager_aa45d4a864547427e916c5ecbe34d2989}{}\label{classns3_1_1BandwidthManager_aa45d4a864547427e916c5ecbe34d2989}

\begin{DoxyCode}
57 \{
58 \}
\end{DoxyCode}
\index{ns3\+::\+Bandwidth\+Manager@{ns3\+::\+Bandwidth\+Manager}!Bandwidth\+Manager@{Bandwidth\+Manager}}
\index{Bandwidth\+Manager@{Bandwidth\+Manager}!ns3\+::\+Bandwidth\+Manager@{ns3\+::\+Bandwidth\+Manager}}
\subsubsection[{\texorpdfstring{Bandwidth\+Manager(const Bandwidth\+Manager \&)}{BandwidthManager(const BandwidthManager &)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Bandwidth\+Manager\+::\+Bandwidth\+Manager (
\begin{DoxyParamCaption}
\item[{const {\bf Bandwidth\+Manager} \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BandwidthManager_a55e9833ade6726f77e582e1452728412}{}\label{classns3_1_1BandwidthManager_a55e9833ade6726f77e582e1452728412}


Bandwidth manager type conversion operator. 



\subsection{Member Function Documentation}
\index{ns3\+::\+Bandwidth\+Manager@{ns3\+::\+Bandwidth\+Manager}!Calculate\+Allocation\+Size@{Calculate\+Allocation\+Size}}
\index{Calculate\+Allocation\+Size@{Calculate\+Allocation\+Size}!ns3\+::\+Bandwidth\+Manager@{ns3\+::\+Bandwidth\+Manager}}
\subsubsection[{\texorpdfstring{Calculate\+Allocation\+Size(const S\+S\+Record $\ast$ss\+Record, const Service\+Flow $\ast$service\+Flow)}{CalculateAllocationSize(const SSRecord *ssRecord, const ServiceFlow *serviceFlow)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Bandwidth\+Manager\+::\+Calculate\+Allocation\+Size (
\begin{DoxyParamCaption}
\item[{const {\bf S\+S\+Record} $\ast$}]{ss\+Record, }
\item[{const {\bf Service\+Flow} $\ast$}]{service\+Flow}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BandwidthManager_a60dbf098a04a926224fe4ac331e1e99c}{}\label{classns3_1_1BandwidthManager_a60dbf098a04a926224fe4ac331e1e99c}
Calculate allocation size function 
\begin{DoxyParams}{Parameters}
{\em ss\+Record} & the SS record \\
\hline
{\em service\+Flow} & the service flow \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the allocation size 
\end{DoxyReturn}

\begin{DoxyCode}
68 \{
69   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} currentTime = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ();
70   Ptr<BaseStationNetDevice> bs = \hyperlink{classns3_1_1BandwidthManager_a55eadfdb1964dad9875f14dfcf48eaed}{m\_device}->GetObject<BaseStationNetDevice> ();
71   uint32\_t allocationSize = 0;
72 
73   \textcolor{comment}{// if SS has a UGS flow then it must set poll-me bit in order to be polled for non-UGS flows}
74   \textcolor{keywordflow}{if} (serviceFlow->GetSchedulingType () != \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a969e0b62fa12fef1dbb23913744ed594}{ServiceFlow::SF\_TYPE\_UGS}
75       && ssRecord->GetHasServiceFlowUgs ()
76       && !ssRecord->GetPollMeBit ())
77     \{
78       \textcolor{keywordflow}{return} 0;
79     \}
80 
81   \textcolor{keywordflow}{switch} (serviceFlow->GetSchedulingType ())
82     \{
83     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a969e0b62fa12fef1dbb23913744ed594}{ServiceFlow::SF\_TYPE\_UGS}:
84       \{
85         \textcolor{keywordflow}{if} ((currentTime - serviceFlow->GetRecord ()->GetGrantTimeStamp ()).GetMilliSeconds ()
86             >= serviceFlow->GetUnsolicitedGrantInterval ())
87           \{
88             allocationSize = serviceFlow->GetRecord ()->GetGrantSize ();
89             serviceFlow->GetRecord ()->SetGrantTimeStamp (currentTime);
90           \}
91       \}
92       \textcolor{keywordflow}{break};
93     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a0e98ff713b932a029acad7e5b24bbf55}{ServiceFlow::SF\_TYPE\_RTPS}:
94       \{
95         \textcolor{keywordflow}{if} ((currentTime - serviceFlow->GetRecord ()->GetGrantTimeStamp ()).GetMilliSeconds ()
96             >= serviceFlow->GetUnsolicitedPollingInterval ())
97           \{
98             allocationSize = bs->GetBwReqOppSize ();
99             serviceFlow->GetRecord ()->SetGrantTimeStamp (currentTime);
100           \}
101       \}
102       \textcolor{keywordflow}{break};
103     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a7f8577f851a9f01d159442a3a3fcdf48}{ServiceFlow::SF\_TYPE\_NRTPS}:
104       \{
105         \textcolor{comment}{/* nrtPS shall be serviced only if sufficient bandwidth is available after servicing}
106 \textcolor{comment}{         UGS and rtPS scheduling types, hence no specific service interval is used */}
107 
108         allocationSize = bs->GetBwReqOppSize ();
109       \}
110       \textcolor{keywordflow}{break};
111     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235af93a8bd8fce654e688f957f6f362e5c7}{ServiceFlow::SF\_TYPE\_BE}:
112       \{
113         \textcolor{comment}{/* BE shall be serviced only if sufficient bandwidth is available after servicing}
114 \textcolor{comment}{         the rest of three scheduling types, hence no specific service interval is used */}
115 
116         allocationSize = bs->GetBwReqOppSize ();
117       \}
118       \textcolor{keywordflow}{break};
119     \textcolor{keywordflow}{default}:
120       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Invalid scheduling type"});
121     \}
122 
123   \textcolor{keywordflow}{return} allocationSize;
124 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Bandwidth\+Manager@{ns3\+::\+Bandwidth\+Manager}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Bandwidth\+Manager@{ns3\+::\+Bandwidth\+Manager}}
\subsubsection[{\texorpdfstring{Do\+Dispose(void)}{DoDispose(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Bandwidth\+Manager\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1BandwidthManager_a0743fe984259718af12a5cd98e3b8c4a}{}\label{classns3_1_1BandwidthManager_a0743fe984259718af12a5cd98e3b8c4a}
Destructor implementation.

This method is called by \hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose()} or by the \hyperlink{classns3_1_1Object}{Object}\textquotesingle{}s destructor, whichever comes first.

Subclasses are expected to implement their real destruction code in an overriden version of this method and chain up to their parent\textquotesingle{}s implementation once they are done. {\itshape i.\+e}, for simplicity, the destructor of every subclass should be empty and its content should be moved to the associated \hyperlink{classns3_1_1BandwidthManager_a0743fe984259718af12a5cd98e3b8c4a}{Do\+Dispose()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.


\begin{DoxyCode}
62 \{
63   \hyperlink{classns3_1_1BandwidthManager_a55eadfdb1964dad9875f14dfcf48eaed}{m\_device} = 0;
64 \}
\end{DoxyCode}
\index{ns3\+::\+Bandwidth\+Manager@{ns3\+::\+Bandwidth\+Manager}!Get\+Symbols\+Per\+Frame\+Allocated@{Get\+Symbols\+Per\+Frame\+Allocated}}
\index{Get\+Symbols\+Per\+Frame\+Allocated@{Get\+Symbols\+Per\+Frame\+Allocated}!ns3\+::\+Bandwidth\+Manager@{ns3\+::\+Bandwidth\+Manager}}
\subsubsection[{\texorpdfstring{Get\+Symbols\+Per\+Frame\+Allocated(void)}{GetSymbolsPerFrameAllocated(void)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Bandwidth\+Manager\+::\+Get\+Symbols\+Per\+Frame\+Allocated (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BandwidthManager_a8176b51c99d998010eed72d1bee7782d}{}\label{classns3_1_1BandwidthManager_a8176b51c99d998010eed72d1bee7782d}
Get symbols per frame allocated \begin{DoxyReturn}{Returns}
the symbols per the frame allocated 
\end{DoxyReturn}

\begin{DoxyCode}
219 \{
220   Ptr<BaseStationNetDevice> bs = \hyperlink{classns3_1_1BandwidthManager_a55eadfdb1964dad9875f14dfcf48eaed}{m\_device}->GetObject<BaseStationNetDevice> ();
221 
222   uint32\_t allocationPerFrame = 0;
223 
224   std::vector<SSRecord*> *ssRecords = bs->GetSSManager ()->GetSSRecords ();
225   \textcolor{keywordflow}{for} (std::vector<SSRecord*>::iterator iter1 = ssRecords->begin (); iter1 != ssRecords->end (); ++iter1)
226     \{
227       \textcolor{keywordflow}{for} (std::vector<ServiceFlow*>::iterator iter2 = (*iter1)->GetServiceFlows (
      \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235aaf7e58e43027cc9d351cd100a9d6dee3}{ServiceFlow::SF\_TYPE\_ALL}).begin ();
228            iter2 != (*iter1)->GetServiceFlows (\hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235aaf7e58e43027cc9d351cd100a9d6dee3}{ServiceFlow::SF\_TYPE\_ALL}).end (); ++
      iter2)
229         \{
230           allocationPerFrame += (*iter2)->GetRecord ()->GetGrantSize ();
231         \}
232     \}
233   \textcolor{keywordflow}{return} allocationPerFrame;
234 \}
\end{DoxyCode}
\index{ns3\+::\+Bandwidth\+Manager@{ns3\+::\+Bandwidth\+Manager}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Bandwidth\+Manager@{ns3\+::\+Bandwidth\+Manager}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Bandwidth\+Manager\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1BandwidthManager_af2ab4110e0cbbd912bbb284353146871}{}\label{classns3_1_1BandwidthManager_af2ab4110e0cbbd912bbb284353146871}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
43 \{
44   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::BandwidthManager"})
45     .SetParent<\hyperlink{classns3_1_1Object_a40860402e64d8008fb42329df7097cdb}{Object}> ()
46     .SetGroupName(\textcolor{stringliteral}{"Wimax"});
47   \textcolor{keywordflow}{return} tid;
48 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::\+Bandwidth\+Manager@{ns3\+::\+Bandwidth\+Manager}!operator=@{operator=}}
\index{operator=@{operator=}!ns3\+::\+Bandwidth\+Manager@{ns3\+::\+Bandwidth\+Manager}}
\subsubsection[{\texorpdfstring{operator=(const Bandwidth\+Manager \&)}{operator=(const BandwidthManager &)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Bandwidth\+Manager}\& ns3\+::\+Bandwidth\+Manager\+::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf Bandwidth\+Manager} \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BandwidthManager_a9bed6c6968629ab4d8ea50f6878f3f20}{}\label{classns3_1_1BandwidthManager_a9bed6c6968629ab4d8ea50f6878f3f20}


Bandwidth manager assignement operator. 

\index{ns3\+::\+Bandwidth\+Manager@{ns3\+::\+Bandwidth\+Manager}!Process\+Bandwidth\+Request@{Process\+Bandwidth\+Request}}
\index{Process\+Bandwidth\+Request@{Process\+Bandwidth\+Request}!ns3\+::\+Bandwidth\+Manager@{ns3\+::\+Bandwidth\+Manager}}
\subsubsection[{\texorpdfstring{Process\+Bandwidth\+Request(const Bandwidth\+Request\+Header \&bw\+Request\+Hdr)}{ProcessBandwidthRequest(const BandwidthRequestHeader &bwRequestHdr)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Bandwidth\+Manager\+::\+Process\+Bandwidth\+Request (
\begin{DoxyParamCaption}
\item[{const {\bf Bandwidth\+Request\+Header} \&}]{bw\+Request\+Hdr}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BandwidthManager_aa9e0e7e0c12acb2bac6076dc2520f134}{}\label{classns3_1_1BandwidthManager_aa9e0e7e0c12acb2bac6076dc2520f134}
Process bandwidth request 
\begin{DoxyParams}{Parameters}
{\em bw\+Request\+Hdr} & the bandwidth request \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
185 \{
186   Ptr<BaseStationNetDevice> bs = \hyperlink{classns3_1_1BandwidthManager_a55eadfdb1964dad9875f14dfcf48eaed}{m\_device}->GetObject<BaseStationNetDevice> ();
187 
188   ServiceFlow *serviceFlow = bs->GetConnectionManager ()->GetConnection (bwRequestHdr.GetCid ())->
      GetServiceFlow ();
189   \textcolor{keywordflow}{if} (bwRequestHdr.GetType () == (uint8\_t) 
      \hyperlink{classns3_1_1BandwidthRequestHeader_abbaf4abd8f160828930369dff9a3d657aec4eaf7a3d70d48c897447b9ee676b7b}{BandwidthRequestHeader::HEADER\_TYPE\_INCREMENTAL})
190     \{
191       serviceFlow->GetRecord ()->UpdateRequestedBandwidth (bwRequestHdr.GetBr ());
192     \}
193   \textcolor{keywordflow}{else}
194     \{
195       serviceFlow->GetRecord ()->SetRequestedBandwidth (bwRequestHdr.GetBr ());
196       bs->GetUplinkScheduler ()->OnSetRequestedBandwidth (serviceFlow->GetRecord ());
197     \}
198   bs->GetUplinkScheduler ()->ProcessBandwidthRequest (bwRequestHdr);
199   \textcolor{comment}{// update backlogged}
200   serviceFlow->GetRecord ()->IncreaseBacklogged (bwRequestHdr.GetBr ());
201 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4


\index{ns3\+::\+Bandwidth\+Manager@{ns3\+::\+Bandwidth\+Manager}!Select\+Flow\+For\+Request@{Select\+Flow\+For\+Request}}
\index{Select\+Flow\+For\+Request@{Select\+Flow\+For\+Request}!ns3\+::\+Bandwidth\+Manager@{ns3\+::\+Bandwidth\+Manager}}
\subsubsection[{\texorpdfstring{Select\+Flow\+For\+Request(uint32\+\_\+t \&bytes\+To\+Request)}{SelectFlowForRequest(uint32_t &bytesToRequest)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Service\+Flow} $\ast$ ns3\+::\+Bandwidth\+Manager\+::\+Select\+Flow\+For\+Request (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t \&}]{bytes\+To\+Request}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BandwidthManager_a6ca1dc2064996be0c67fdd6697be9654}{}\label{classns3_1_1BandwidthManager_a6ca1dc2064996be0c67fdd6697be9654}
Select flow for request function 
\begin{DoxyParams}{Parameters}
{\em bytes\+To\+Request} & bytes to request \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a service flow 
\end{DoxyReturn}

\begin{DoxyCode}
128 \{
129   Ptr<Packet> packet;
130   ServiceFlow *serviceFlow = 0;
131 
132   Ptr<SubscriberStationNetDevice> ss = \hyperlink{classns3_1_1BandwidthManager_a55eadfdb1964dad9875f14dfcf48eaed}{m\_device}->GetObject<SubscriberStationNetDevice> ();
133   std::vector<ServiceFlow*> serviceFlows = ss->GetServiceFlowManager ()->GetServiceFlows (
      \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235aaf7e58e43027cc9d351cd100a9d6dee3}{ServiceFlow::SF\_TYPE\_ALL});
134 
135   \textcolor{keywordflow}{for} (std::vector<ServiceFlow*>::iterator iter = serviceFlows.begin (); iter != serviceFlows.end (); ++
      iter)
136     \{
137       serviceFlow = *iter;
138       \textcolor{keywordflow}{if} (serviceFlow->GetSchedulingType () == \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a0e98ff713b932a029acad7e5b24bbf55}{ServiceFlow::SF\_TYPE\_RTPS}
139           || serviceFlow->GetSchedulingType () == \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a7f8577f851a9f01d159442a3a3fcdf48}{ServiceFlow::SF\_TYPE\_NRTPS}
140           || serviceFlow->GetSchedulingType () == \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235af93a8bd8fce654e688f957f6f362e5c7}{ServiceFlow::SF\_TYPE\_BE})
141         \{
142           \textcolor{keywordflow}{if} (serviceFlow->HasPackets (\hyperlink{classns3_1_1MacHeaderType_a54d8fc8bc93a2b7865627965cdd31c20a48fe5b2f20cadf78008c71469b518403}{MacHeaderType::HEADER\_TYPE\_GENERIC}
      ))
143             \{
144               \textcolor{comment}{// bandwidth is requested for all packets}
145               bytesToRequest = serviceFlow->GetQueue ()->GetQueueLengthWithMACOverhead ();
146               \textcolor{keywordflow}{break};
147             \}
148         \}
149     \}
150 
151   \textcolor{keywordflow}{return} serviceFlow;
152 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5




Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::\+Bandwidth\+Manager@{ns3\+::\+Bandwidth\+Manager}!Send\+Bandwidth\+Request@{Send\+Bandwidth\+Request}}
\index{Send\+Bandwidth\+Request@{Send\+Bandwidth\+Request}!ns3\+::\+Bandwidth\+Manager@{ns3\+::\+Bandwidth\+Manager}}
\subsubsection[{\texorpdfstring{Send\+Bandwidth\+Request(uint8\+\_\+t uiuc, uint16\+\_\+t allocation\+Size)}{SendBandwidthRequest(uint8_t uiuc, uint16_t allocationSize)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Bandwidth\+Manager\+::\+Send\+Bandwidth\+Request (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{uiuc, }
\item[{uint16\+\_\+t}]{allocation\+Size}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BandwidthManager_acbe780c5080f4001b2a1a117f446dd74}{}\label{classns3_1_1BandwidthManager_acbe780c5080f4001b2a1a117f446dd74}
Send bandwidth request 
\begin{DoxyParams}{Parameters}
{\em uiuc} & the U\+I\+UC \\
\hline
{\em allocation\+Size} & the allocation size \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
156 \{
157   Ptr<SubscriberStationNetDevice> ss = \hyperlink{classns3_1_1BandwidthManager_a55eadfdb1964dad9875f14dfcf48eaed}{m\_device}->GetObject<SubscriberStationNetDevice> ();
158 
159   uint32\_t bytesToRequest = 0;
160   ServiceFlow *serviceFlow = \hyperlink{classns3_1_1BandwidthManager_a6ca1dc2064996be0c67fdd6697be9654}{SelectFlowForRequest} (bytesToRequest);
161 
162   \textcolor{keywordflow}{if} (!serviceFlow || !bytesToRequest)
163     \{
164       \textcolor{keywordflow}{return};
165     \}
166   BandwidthRequestHeader bwRequestHdr;
167 
168   \textcolor{comment}{// bytesToRequest is the queue length of Service Flow and so,}
169   \textcolor{comment}{// the header type must be HEADER\_TYPE\_AGGREGATE!}
170 
171   bwRequestHdr.SetType ((uint8\_t) \hyperlink{classns3_1_1BandwidthRequestHeader_abbaf4abd8f160828930369dff9a3d657ab6d7315b06d931e9c2db56f749a7d337}{BandwidthRequestHeader::HEADER\_TYPE\_AGGREGATE}
      );
172   bwRequestHdr.SetCid (serviceFlow->GetConnection ()->GetCid ());
173   bwRequestHdr.SetBr (bytesToRequest);
174 
175   Ptr<Packet> packet = Create<Packet> ();
176   packet->AddHeader (bwRequestHdr);
177   ss->Enqueue (packet, MacHeaderType (\hyperlink{classns3_1_1MacHeaderType_a54d8fc8bc93a2b7865627965cdd31c20a10501251f4c20ab02eb98217c4171e0e}{MacHeaderType::HEADER\_TYPE\_BANDWIDTH}
      ), serviceFlow->GetConnection ());
178   \hyperlink{classns3_1_1BandwidthManager_a18a831b18bb05ea6c9c48b77c3f1ac17}{m\_nrBwReqsSent}++;
179   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (uiuc == \hyperlink{classns3_1_1OfdmUlBurstProfile_ae528783c4b3c6700ff49dfd7a555cb3daae074d10caa7fe18da973227c7f9942f}{OfdmUlBurstProfile::UIUC\_REQ\_REGION\_FULL}
      , \textcolor{stringliteral}{"Send Bandwidth Request: !UIUC\_REQ\_REGION\_FULL"});
180   ss->SendBurst (uiuc, allocationSize, serviceFlow->GetConnection (), 
      \hyperlink{classns3_1_1MacHeaderType_a54d8fc8bc93a2b7865627965cdd31c20a10501251f4c20ab02eb98217c4171e0e}{MacHeaderType::HEADER\_TYPE\_BANDWIDTH});
181 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7




Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::\+Bandwidth\+Manager@{ns3\+::\+Bandwidth\+Manager}!Set\+Subframe\+Ratio@{Set\+Subframe\+Ratio}}
\index{Set\+Subframe\+Ratio@{Set\+Subframe\+Ratio}!ns3\+::\+Bandwidth\+Manager@{ns3\+::\+Bandwidth\+Manager}}
\subsubsection[{\texorpdfstring{Set\+Subframe\+Ratio(void)}{SetSubframeRatio(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Bandwidth\+Manager\+::\+Set\+Subframe\+Ratio (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BandwidthManager_a2347150df25b7d6497947d5b755b6dd9}{}\label{classns3_1_1BandwidthManager_a2347150df25b7d6497947d5b755b6dd9}


Set subframe ratio. 


\begin{DoxyCode}
205 \{
206   \textcolor{comment}{// sets ratio of the DL and UL subframes}
207 
208   Ptr<BaseStationNetDevice> bs = \hyperlink{classns3_1_1BandwidthManager_a55eadfdb1964dad9875f14dfcf48eaed}{m\_device}->GetObject<BaseStationNetDevice> ();
209 
210   uint32\_t symbolsPerFrame = bs->GetPhy ()->GetSymbolsPerFrame ();
211 
212   \textcolor{comment}{/* temporarily divided in half (360 symbols each), shall actually be determined based on UL and DL
       traffic*/}
213   bs->SetNrDlSymbols (symbolsPerFrame / 2);
214   bs->SetNrUlSymbols (symbolsPerFrame / 2);
215 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{ns3\+::\+Bandwidth\+Manager@{ns3\+::\+Bandwidth\+Manager}!m\+\_\+device@{m\+\_\+device}}
\index{m\+\_\+device@{m\+\_\+device}!ns3\+::\+Bandwidth\+Manager@{ns3\+::\+Bandwidth\+Manager}}
\subsubsection[{\texorpdfstring{m\+\_\+device}{m_device}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Wimax\+Net\+Device}$>$ ns3\+::\+Bandwidth\+Manager\+::m\+\_\+device\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BandwidthManager_a55eadfdb1964dad9875f14dfcf48eaed}{}\label{classns3_1_1BandwidthManager_a55eadfdb1964dad9875f14dfcf48eaed}


the device 

\index{ns3\+::\+Bandwidth\+Manager@{ns3\+::\+Bandwidth\+Manager}!m\+\_\+nr\+Bw\+Reqs\+Sent@{m\+\_\+nr\+Bw\+Reqs\+Sent}}
\index{m\+\_\+nr\+Bw\+Reqs\+Sent@{m\+\_\+nr\+Bw\+Reqs\+Sent}!ns3\+::\+Bandwidth\+Manager@{ns3\+::\+Bandwidth\+Manager}}
\subsubsection[{\texorpdfstring{m\+\_\+nr\+Bw\+Reqs\+Sent}{m_nrBwReqsSent}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Bandwidth\+Manager\+::m\+\_\+nr\+Bw\+Reqs\+Sent\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BandwidthManager_a18a831b18bb05ea6c9c48b77c3f1ac17}{}\label{classns3_1_1BandwidthManager_a18a831b18bb05ea6c9c48b77c3f1ac17}


bandwith requests sent 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
wimax/model/\hyperlink{bandwidth-manager_8h}{bandwidth-\/manager.\+h}\item 
wimax/model/\hyperlink{bandwidth-manager_8cc}{bandwidth-\/manager.\+cc}\end{DoxyCompactItemize}
