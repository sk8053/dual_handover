\hypertarget{classns3_1_1Ipv6RoutingHelper}{}\section{ns3\+:\+:Ipv6\+Routing\+Helper Class Reference}
\label{classns3_1_1Ipv6RoutingHelper}\index{ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}}


A factory to create \hyperlink{classns3_1_1Ipv6RoutingProtocol}{ns3\+::\+Ipv6\+Routing\+Protocol} objects.  




{\ttfamily \#include $<$ipv6-\/routing-\/helper.\+h$>$}



Inheritance diagram for ns3\+:\+:Ipv6\+Routing\+Helper\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Ipv6\+Routing\+Helper\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual \hyperlink{classns3_1_1Ipv6RoutingHelper_aabadb66ac986e5978239526292d5a346}{$\sim$\+Ipv6\+Routing\+Helper} ()
\begin{DoxyCompactList}\small\item\em Destroy an \hyperlink{classns3_1_1Ipv6}{Ipv6} \hyperlink{classns3_1_1Ipv6RoutingHelper}{Ipv6\+Routing\+Helper}. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ipv6RoutingHelper}{Ipv6\+Routing\+Helper} $\ast$ \hyperlink{classns3_1_1Ipv6RoutingHelper_a324f924df9565843a0964e844e35927c}{Copy} (void) const =0
\begin{DoxyCompactList}\small\item\em virtual constructor \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} $>$ \hyperlink{classns3_1_1Ipv6RoutingHelper_aee8501a0e661843ccf9da08e3e56614b}{Create} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node) const =0
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static void \hyperlink{classns3_1_1Ipv6RoutingHelper_a02468528d712df0b6358c6d7bc56b23b}{Print\+Routing\+Table\+All\+At} (\hyperlink{classns3_1_1Time}{Time} print\+Time, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream, \hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295a}{Time\+::\+Unit} unit=\hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295aade8622b06524a328cd3a59db6ccf76af}{Time\+::S})
\begin{DoxyCompactList}\small\item\em prints the routing tables of all nodes at a particular time. \end{DoxyCompactList}\item 
static void \hyperlink{classns3_1_1Ipv6RoutingHelper_a716a9e0881c5c0d1f8f3c728556a4473}{Print\+Routing\+Table\+All\+Every} (\hyperlink{classns3_1_1Time}{Time} print\+Interval, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream, \hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295a}{Time\+::\+Unit} unit=\hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295aade8622b06524a328cd3a59db6ccf76af}{Time\+::S})
\begin{DoxyCompactList}\small\item\em prints the routing tables of all nodes at regular intervals specified by user. \end{DoxyCompactList}\item 
static void \hyperlink{classns3_1_1Ipv6RoutingHelper_a4f7287245996b0bb7bdfe9d27adac329}{Print\+Routing\+Table\+At} (\hyperlink{classns3_1_1Time}{Time} print\+Time, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream, \hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295a}{Time\+::\+Unit} unit=\hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295aade8622b06524a328cd3a59db6ccf76af}{Time\+::S})
\begin{DoxyCompactList}\small\item\em prints the routing tables of a node at a particular time. \end{DoxyCompactList}\item 
static void \hyperlink{classns3_1_1Ipv6RoutingHelper_a802767089cd111e52aea8fef65dfd32e}{Print\+Routing\+Table\+Every} (\hyperlink{classns3_1_1Time}{Time} print\+Interval, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream, \hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295a}{Time\+::\+Unit} unit=\hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295aade8622b06524a328cd3a59db6ccf76af}{Time\+::S})
\begin{DoxyCompactList}\small\item\em prints the routing tables of a node at regular intervals specified by user. \end{DoxyCompactList}\item 
static void \hyperlink{classns3_1_1Ipv6RoutingHelper_a3fb619b1828a73f8c4a77ba1a64c6417}{Print\+Neighbor\+Cache\+All\+At} (\hyperlink{classns3_1_1Time}{Time} print\+Time, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream)
\begin{DoxyCompactList}\small\item\em prints the neighbor cache of all nodes at a particular time. \end{DoxyCompactList}\item 
static void \hyperlink{classns3_1_1Ipv6RoutingHelper_a623d584ad005d7b9f5c6d43b34007243}{Print\+Neighbor\+Cache\+All\+Every} (\hyperlink{classns3_1_1Time}{Time} print\+Interval, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream)
\begin{DoxyCompactList}\small\item\em prints the neighbor cache of all nodes at regular intervals specified by user. \end{DoxyCompactList}\item 
static void \hyperlink{classns3_1_1Ipv6RoutingHelper_a8906443d390d97c41fdb09df227051aa}{Print\+Neighbor\+Cache\+At} (\hyperlink{classns3_1_1Time}{Time} print\+Time, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream)
\begin{DoxyCompactList}\small\item\em prints the neighbor cache of a node at a particular time. \end{DoxyCompactList}\item 
static void \hyperlink{classns3_1_1Ipv6RoutingHelper_ac904dfdcd8d047f61fd20cec6ee73cda}{Print\+Neighbor\+Cache\+Every} (\hyperlink{classns3_1_1Time}{Time} print\+Interval, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream)
\begin{DoxyCompactList}\small\item\em prints the neighbor cache of a node at regular intervals specified by user. \end{DoxyCompactList}\item 
{\footnotesize template$<$class T $>$ }\\static \hyperlink{classns3_1_1Ptr}{Ptr}$<$ T $>$ \hyperlink{classns3_1_1Ipv6RoutingHelper_a22afb76ebdd74e8ccecace410c9c3ff7}{Get\+Routing} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} $>$ protocol)
\begin{DoxyCompactList}\small\item\em Request a specified routing protocol $<$T$>$ from \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} protocol. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Private Member Functions}
\begin{DoxyCompactItemize}
\item 
static void \hyperlink{classns3_1_1Ipv6RoutingHelper_ac01611050813aedf80458c31d303d3b1}{Print} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream, \hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295a}{Time\+::\+Unit} unit)
\begin{DoxyCompactList}\small\item\em prints the routing tables of a node. \end{DoxyCompactList}\item 
static void \hyperlink{classns3_1_1Ipv6RoutingHelper_affe6938b3ce8f3590a382c6ba8d8dd74}{Print\+Every} (\hyperlink{classns3_1_1Time}{Time} print\+Interval, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream, \hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295a}{Time\+::\+Unit} unit)
\begin{DoxyCompactList}\small\item\em prints the routing tables of a node at regular intervals specified by user. \end{DoxyCompactList}\item 
static void \hyperlink{classns3_1_1Ipv6RoutingHelper_a582eac0a7c42f77cdc5b8319f1c25897}{Print\+Ndisc\+Cache} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream)
\begin{DoxyCompactList}\small\item\em prints the neighbor cache of a node. \end{DoxyCompactList}\item 
static void \hyperlink{classns3_1_1Ipv6RoutingHelper_a6b83234c9aa93f14576ba9f12c87a64b}{Print\+Ndisc\+Cache\+Every} (\hyperlink{classns3_1_1Time}{Time} print\+Interval, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream)
\begin{DoxyCompactList}\small\item\em prints the neighbor cache of a node at regular intervals specified by user. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
A factory to create \hyperlink{classns3_1_1Ipv6RoutingProtocol}{ns3\+::\+Ipv6\+Routing\+Protocol} objects. 

For each new routing protocol created as a subclass of \hyperlink{classns3_1_1Ipv6RoutingProtocol}{ns3\+::\+Ipv6\+Routing\+Protocol}, you need to create a subclass of \hyperlink{classns3_1_1Ipv6RoutingHelper}{ns3\+::\+Ipv6\+Routing\+Helper} which can be used by \hyperlink{classns3_1_1InternetStackHelper_a3e382c02df022dec79952a7eca8cd5ba}{ns3\+::\+Internet\+Stack\+Helper\+::\+Set\+Routing\+Helper} and \hyperlink{classns3_1_1InternetStackHelper_a6645b412f31283d2d9bc3d8a95cebbc0}{ns3\+::\+Internet\+Stack\+Helper\+::\+Install}. 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}!````~Ipv6\+Routing\+Helper@{$\sim$\+Ipv6\+Routing\+Helper}}
\index{````~Ipv6\+Routing\+Helper@{$\sim$\+Ipv6\+Routing\+Helper}!ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{$\sim$\+Ipv6\+Routing\+Helper()}{~Ipv6RoutingHelper()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv6\+Routing\+Helper\+::$\sim$\+Ipv6\+Routing\+Helper (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6RoutingHelper_aabadb66ac986e5978239526292d5a346}{}\label{classns3_1_1Ipv6RoutingHelper_aabadb66ac986e5978239526292d5a346}


Destroy an \hyperlink{classns3_1_1Ipv6}{Ipv6} \hyperlink{classns3_1_1Ipv6RoutingHelper}{Ipv6\+Routing\+Helper}. 


\begin{DoxyCode}
35 \{
36 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}!Copy@{Copy}}
\index{Copy@{Copy}!ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Copy(void) const =0}{Copy(void) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Ipv6\+Routing\+Helper}$\ast$ ns3\+::\+Ipv6\+Routing\+Helper\+::\+Copy (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6RoutingHelper_a324f924df9565843a0964e844e35927c}{}\label{classns3_1_1Ipv6RoutingHelper_a324f924df9565843a0964e844e35927c}


virtual constructor 

\begin{DoxyReturn}{Returns}
pointer to clone of this \hyperlink{classns3_1_1Ipv6RoutingHelper}{Ipv6\+Routing\+Helper}
\end{DoxyReturn}
This method is mainly for internal use by the other helpers; clients are expected to free the dynamic memory allocated by this method 

Implemented in \hyperlink{classns3_1_1Ipv6ListRoutingHelper_a6866f4f303796ccad404cc90f491156e}{ns3\+::\+Ipv6\+List\+Routing\+Helper}, \hyperlink{classns3_1_1RipNgHelper_a5a1c7104dea83c98eee84d4b7be1f308}{ns3\+::\+Rip\+Ng\+Helper}, and \hyperlink{classns3_1_1Ipv6StaticRoutingHelper_a984170f1188bad7e980a21c81990a304}{ns3\+::\+Ipv6\+Static\+Routing\+Helper}.



Here is the caller graph for this function\+:
% FIG 2


\index{ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}!Create@{Create}}
\index{Create@{Create}!ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Create(\+Ptr$<$ Node $>$ node) const =0}{Create(Ptr< Node > node) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Ptr}$<${\bf Ipv6\+Routing\+Protocol}$>$ ns3\+::\+Ipv6\+Routing\+Helper\+::\+Create (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6RoutingHelper_aee8501a0e661843ccf9da08e3e56614b}{}\label{classns3_1_1Ipv6RoutingHelper_aee8501a0e661843ccf9da08e3e56614b}

\begin{DoxyParams}{Parameters}
{\em node} & the node within which the new routing protocol will run \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a newly-\/created routing protocol 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv6ListRoutingHelper_ac027288962db9db7bff901e02b7d558e}{ns3\+::\+Ipv6\+List\+Routing\+Helper}, \hyperlink{classns3_1_1RipNgHelper_a92474bbd2a8816e8e847deb32f240525}{ns3\+::\+Rip\+Ng\+Helper}, and \hyperlink{classns3_1_1Ipv6StaticRoutingHelper_aeed733513c2f46bbe03fcd2c0370f493}{ns3\+::\+Ipv6\+Static\+Routing\+Helper}.



Here is the caller graph for this function\+:
% FIG 3


\index{ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}!Get\+Routing@{Get\+Routing}}
\index{Get\+Routing@{Get\+Routing}!ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Get\+Routing(\+Ptr$<$ Ipv6\+Routing\+Protocol $>$ protocol)}{GetRouting(Ptr< Ipv6RoutingProtocol > protocol)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ {\bf Ptr}$<$ T $>$ ns3\+::\+Ipv6\+Routing\+Helper\+::\+Get\+Routing (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv6\+Routing\+Protocol} $>$}]{protocol}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv6RoutingHelper_a22afb76ebdd74e8ccecace410c9c3ff7}{}\label{classns3_1_1Ipv6RoutingHelper_a22afb76ebdd74e8ccecace410c9c3ff7}


Request a specified routing protocol $<$T$>$ from \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} protocol. 

If protocol is \hyperlink{classns3_1_1Ipv6ListRouting}{Ipv6\+List\+Routing}, then protocol will be searched in the list, otherwise a simple Dynamic\+Cast will be performed


\begin{DoxyParams}{Parameters}
{\em protocol} & Smart pointer to \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} object \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a Smart Pointer to the requested protocol (zero if the protocol can\textquotesingle{}t be found) 
\end{DoxyReturn}

\begin{DoxyCode}
262 \{
263   Ptr<T> ret = DynamicCast<T> (protocol);
264   \textcolor{keywordflow}{if} (ret == 0)
265     \{
266       \textcolor{comment}{// trying to check if protocol is a list routing}
267       Ptr<Ipv6ListRouting> lrp = DynamicCast<Ipv6ListRouting> (protocol);
268       \textcolor{keywordflow}{if} (lrp != 0)
269         \{
270           \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < lrp->GetNRoutingProtocols ();  \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
271             \{
272               int16\_t priority;
273               ret = GetRouting<T> (lrp->GetRoutingProtocol (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, priority)); \textcolor{comment}{// potential recursion, if
       inside ListRouting is ListRouting}
274               \textcolor{keywordflow}{if} (ret != 0)
275                 \textcolor{keywordflow}{break};
276             \}
277         \}
278     \}
279 
280   \textcolor{keywordflow}{return} ret;
281 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}!Print@{Print}}
\index{Print@{Print}!ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Print(\+Ptr$<$ Node $>$ node, Ptr$<$ Output\+Stream\+Wrapper $>$ stream, Time\+::\+Unit unit)}{Print(Ptr< Node > node, Ptr< OutputStreamWrapper > stream, Time::Unit unit)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Routing\+Helper\+::\+Print (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node, }
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream, }
\item[{{\bf Time\+::\+Unit}}]{unit}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6RoutingHelper_ac01611050813aedf80458c31d303d3b1}{}\label{classns3_1_1Ipv6RoutingHelper_ac01611050813aedf80458c31d303d3b1}


prints the routing tables of a node. 


\begin{DoxyParams}{Parameters}
{\em node} & The node ptr for which we need the routing table to be printed \\
\hline
{\em stream} & The output stream object to use \\
\hline
{\em unit} & The time unit to be used in the report\\
\hline
\end{DoxyParams}
This method calls the Print\+Routing\+Table() method of the \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} stored in the \hyperlink{classns3_1_1Ipv6}{Ipv6} object; the output format is routing protocol-\/specific. 
\begin{DoxyCode}
72 \{
73   Ptr<Ipv6> ipv6 = node->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv6> ();
74   \textcolor{keywordflow}{if} (ipv6)
75     \{
76       Ptr<Ipv6RoutingProtocol> rp = ipv6->GetRoutingProtocol ();
77       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (rp);
78       rp->PrintRoutingTable (stream, unit);
79     \}
80 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4




Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}!Print\+Every@{Print\+Every}}
\index{Print\+Every@{Print\+Every}!ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Print\+Every(\+Time print\+Interval, Ptr$<$ Node $>$ node, Ptr$<$ Output\+Stream\+Wrapper $>$ stream, Time\+::\+Unit unit)}{PrintEvery(Time printInterval, Ptr< Node > node, Ptr< OutputStreamWrapper > stream, Time::Unit unit)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Routing\+Helper\+::\+Print\+Every (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{print\+Interval, }
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node, }
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream, }
\item[{{\bf Time\+::\+Unit}}]{unit}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6RoutingHelper_affe6938b3ce8f3590a382c6ba8d8dd74}{}\label{classns3_1_1Ipv6RoutingHelper_affe6938b3ce8f3590a382c6ba8d8dd74}


prints the routing tables of a node at regular intervals specified by user. 


\begin{DoxyParams}{Parameters}
{\em print\+Interval} & the time interval for which the routing table is supposed to be printed. \\
\hline
{\em node} & The node ptr for which we need the routing table to be printed \\
\hline
{\em stream} & The output stream object to use \\
\hline
{\em unit} & The time unit to be used in the report\\
\hline
\end{DoxyParams}
This method calls the Print\+Routing\+Table() method of the \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} stored in the \hyperlink{classns3_1_1Ipv6}{Ipv6} object, for the selected node at the specified interval; the output format is routing protocol-\/specific. 
\begin{DoxyCode}
84 \{
85   Ptr<Ipv6> ipv6 = node->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv6> ();
86   \textcolor{keywordflow}{if} (ipv6)
87     \{
88       Ptr<Ipv6RoutingProtocol> rp = ipv6->GetRoutingProtocol ();
89       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (rp);
90       rp->PrintRoutingTable (stream, unit);
91       \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (printInterval, &
      \hyperlink{classns3_1_1Ipv6RoutingHelper_affe6938b3ce8f3590a382c6ba8d8dd74}{Ipv6RoutingHelper::PrintEvery}, printInterval, node, stream, unit);
92     \}
93 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6




Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}!Print\+Ndisc\+Cache@{Print\+Ndisc\+Cache}}
\index{Print\+Ndisc\+Cache@{Print\+Ndisc\+Cache}!ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Print\+Ndisc\+Cache(\+Ptr$<$ Node $>$ node, Ptr$<$ Output\+Stream\+Wrapper $>$ stream)}{PrintNdiscCache(Ptr< Node > node, Ptr< OutputStreamWrapper > stream)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Routing\+Helper\+::\+Print\+Ndisc\+Cache (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node, }
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6RoutingHelper_a582eac0a7c42f77cdc5b8319f1c25897}{}\label{classns3_1_1Ipv6RoutingHelper_a582eac0a7c42f77cdc5b8319f1c25897}


prints the neighbor cache of a node. 


\begin{DoxyParams}{Parameters}
{\em node} & The node ptr for which we need the neighbor cache to be printed \\
\hline
{\em stream} & The output stream object to use\\
\hline
\end{DoxyParams}
This method calls the \hyperlink{classns3_1_1Ipv6RoutingHelper_a582eac0a7c42f77cdc5b8319f1c25897}{Print\+Ndisc\+Cache()} method of the \hyperlink{classns3_1_1NdiscCache}{Ndisc\+Cache} associated with each \hyperlink{classns3_1_1Ipv6Interface}{Ipv6\+Interface} stored in the \hyperlink{classns3_1_1Ipv6}{Ipv6} object, for all nodes at the specified time. The output format is similar to\+: \begin{DoxyVerb}2001:db8::f00d:beef:cafe dev 1 lladdr 00-06-00:00:00:00:00:02 REACHABLE
\end{DoxyVerb}
 Note that the M\+AC address is printed as \char`\"{}type\char`\"{}-\/\char`\"{}size\char`\"{}-\/\char`\"{}actual address\char`\"{} 
\begin{DoxyCode}
129 \{
130   Ptr<Ipv6L3Protocol> ipv6 = node->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv6L3Protocol> ();
131   \textcolor{keywordflow}{if} (ipv6)
132     \{
133       std::ostream* os = stream->\hyperlink{classns3_1_1OutputStreamWrapper_a0cf30a4188ab6fdae2b2ab74db11acc2}{GetStream} ();
134 
135       *os << \textcolor{stringliteral}{"NDISC Cache of node "};
136       std::string found = \hyperlink{classns3_1_1Names_ab9664faf23569aaae64a2d1f65265045}{Names::FindName} (node);
137       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Names_ab9664faf23569aaae64a2d1f65265045}{Names::FindName} (node) != \textcolor{stringliteral}{""})
138         \{
139           *os << found;
140         \}
141       \textcolor{keywordflow}{else}
142         \{
143           *os << static\_cast<int> (node->\hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} ());
144         \}
145       *os << \textcolor{stringliteral}{" at time "} << \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().\hyperlink{classns3_1_1Time_a8f20d5c3b0902d7b4320982f340b57c8}{GetSeconds} () << \textcolor{stringliteral}{"\(\backslash\)n"};
146 
147       \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}=0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}<ipv6->GetNInterfaces(); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
148         \{
149           Ptr<NdiscCache> ndiscCache = ipv6->GetInterface (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})->GetNdiscCache ();
150           \textcolor{keywordflow}{if} (ndiscCache)
151             \{
152               ndiscCache->PrintNdiscCache (stream);
153             \}
154         \}
155     \}
156 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8




Here is the caller graph for this function\+:
% FIG 9


\index{ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}!Print\+Ndisc\+Cache\+Every@{Print\+Ndisc\+Cache\+Every}}
\index{Print\+Ndisc\+Cache\+Every@{Print\+Ndisc\+Cache\+Every}!ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Print\+Ndisc\+Cache\+Every(\+Time print\+Interval, Ptr$<$ Node $>$ node, Ptr$<$ Output\+Stream\+Wrapper $>$ stream)}{PrintNdiscCacheEvery(Time printInterval, Ptr< Node > node, Ptr< OutputStreamWrapper > stream)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Routing\+Helper\+::\+Print\+Ndisc\+Cache\+Every (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{print\+Interval, }
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node, }
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6RoutingHelper_a6b83234c9aa93f14576ba9f12c87a64b}{}\label{classns3_1_1Ipv6RoutingHelper_a6b83234c9aa93f14576ba9f12c87a64b}


prints the neighbor cache of a node at regular intervals specified by user. 


\begin{DoxyParams}{Parameters}
{\em print\+Interval} & the time interval for which the neighbor cache is supposed to be printed. \\
\hline
{\em node} & The node ptr for which we need the neighbor cache to be printed \\
\hline
{\em stream} & The output stream object to use\\
\hline
\end{DoxyParams}
This method calls the \hyperlink{classns3_1_1Ipv6RoutingHelper_a582eac0a7c42f77cdc5b8319f1c25897}{Print\+Ndisc\+Cache()} method of the \hyperlink{classns3_1_1NdiscCache}{Ndisc\+Cache} associated with each \hyperlink{classns3_1_1Ipv6Interface}{Ipv6\+Interface} stored in the \hyperlink{classns3_1_1Ipv6}{Ipv6} object, for all nodes at the specified time. The output format is similar to\+: \begin{DoxyVerb}2001:db8::f00d:beef:cafe dev 1 lladdr 00-06-00:00:00:00:00:02 REACHABLE
\end{DoxyVerb}
 Note that the M\+AC address is printed as \char`\"{}type\char`\"{}-\/\char`\"{}size\char`\"{}-\/\char`\"{}actual address\char`\"{} 
\begin{DoxyCode}
160 \{
161   Ptr<Ipv6L3Protocol> ipv6 = node->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv6L3Protocol> ();
162   \textcolor{keywordflow}{if} (ipv6)
163     \{
164       std::ostream* os = stream->\hyperlink{classns3_1_1OutputStreamWrapper_a0cf30a4188ab6fdae2b2ab74db11acc2}{GetStream} ();
165 
166       *os << \textcolor{stringliteral}{"NDISC Cache of node "};
167       std::string found = \hyperlink{classns3_1_1Names_ab9664faf23569aaae64a2d1f65265045}{Names::FindName} (node);
168       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Names_ab9664faf23569aaae64a2d1f65265045}{Names::FindName} (node) != \textcolor{stringliteral}{""})
169         \{
170           *os << found;
171         \}
172       \textcolor{keywordflow}{else}
173         \{
174           *os << static\_cast<int> (node->\hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} ());
175         \}
176       *os << \textcolor{stringliteral}{" at time "} << \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().\hyperlink{classns3_1_1Time_a8f20d5c3b0902d7b4320982f340b57c8}{GetSeconds} () << \textcolor{stringliteral}{"\(\backslash\)n"};
177 
178       \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}=0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}<ipv6->GetNInterfaces(); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
179         \{
180           Ptr<NdiscCache> ndiscCache = ipv6->GetInterface (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})->GetNdiscCache ();
181           \textcolor{keywordflow}{if} (ndiscCache)
182             \{
183               ndiscCache->PrintNdiscCache (stream);
184             \}
185         \}
186       \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (printInterval, &
      \hyperlink{classns3_1_1Ipv6RoutingHelper_a6b83234c9aa93f14576ba9f12c87a64b}{Ipv6RoutingHelper::PrintNdiscCacheEvery}, printInterval, node, stream
      );
187     \}
188 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10




Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}!Print\+Neighbor\+Cache\+All\+At@{Print\+Neighbor\+Cache\+All\+At}}
\index{Print\+Neighbor\+Cache\+All\+At@{Print\+Neighbor\+Cache\+All\+At}!ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Print\+Neighbor\+Cache\+All\+At(\+Time print\+Time, Ptr$<$ Output\+Stream\+Wrapper $>$ stream)}{PrintNeighborCacheAllAt(Time printTime, Ptr< OutputStreamWrapper > stream)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Routing\+Helper\+::\+Print\+Neighbor\+Cache\+All\+At (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{print\+Time, }
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv6RoutingHelper_a3fb619b1828a73f8c4a77ba1a64c6417}{}\label{classns3_1_1Ipv6RoutingHelper_a3fb619b1828a73f8c4a77ba1a64c6417}


prints the neighbor cache of all nodes at a particular time. 


\begin{DoxyParams}{Parameters}
{\em print\+Time} & the time at which the neighbor cache is supposed to be printed. \\
\hline
{\em stream} & The output stream object to use\\
\hline
\end{DoxyParams}
This method calls the \hyperlink{classns3_1_1Ipv6RoutingHelper_a582eac0a7c42f77cdc5b8319f1c25897}{Print\+Ndisc\+Cache()} method of the \hyperlink{classns3_1_1NdiscCache}{Ndisc\+Cache} associated with each \hyperlink{classns3_1_1Ipv6Interface}{Ipv6\+Interface} stored in the \hyperlink{classns3_1_1Ipv6}{Ipv6} object, for all nodes at the specified time. The output format is similar to\+: \begin{DoxyVerb}2001:db8::f00d:beef:cafe dev 1 lladdr 00-06-00:00:00:00:00:02 REACHABLE
\end{DoxyVerb}
 Note that the M\+AC address is printed as \char`\"{}type\char`\"{}-\/\char`\"{}size\char`\"{}-\/\char`\"{}actual address\char`\"{} 
\begin{DoxyCode}
97 \{
98   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1NodeList_a1d110b1670005895dd5812baab13682a}{NodeList::GetNNodes} (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
99     \{
100       Ptr<Node> node = \hyperlink{classns3_1_1NodeList_a80ac09977d48d29db5c704ac8483cf6c}{NodeList::GetNode} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
101       \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (printTime, &
      \hyperlink{classns3_1_1Ipv6RoutingHelper_a582eac0a7c42f77cdc5b8319f1c25897}{Ipv6RoutingHelper::PrintNdiscCache}, node, stream);
102     \}
103 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12


\index{ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}!Print\+Neighbor\+Cache\+All\+Every@{Print\+Neighbor\+Cache\+All\+Every}}
\index{Print\+Neighbor\+Cache\+All\+Every@{Print\+Neighbor\+Cache\+All\+Every}!ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Print\+Neighbor\+Cache\+All\+Every(\+Time print\+Interval, Ptr$<$ Output\+Stream\+Wrapper $>$ stream)}{PrintNeighborCacheAllEvery(Time printInterval, Ptr< OutputStreamWrapper > stream)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Routing\+Helper\+::\+Print\+Neighbor\+Cache\+All\+Every (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{print\+Interval, }
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv6RoutingHelper_a623d584ad005d7b9f5c6d43b34007243}{}\label{classns3_1_1Ipv6RoutingHelper_a623d584ad005d7b9f5c6d43b34007243}


prints the neighbor cache of all nodes at regular intervals specified by user. 


\begin{DoxyParams}{Parameters}
{\em print\+Interval} & the time interval for which the neighbor cache is supposed to be printed. \\
\hline
{\em stream} & The output stream object to use\\
\hline
\end{DoxyParams}
This method calls the \hyperlink{classns3_1_1Ipv6RoutingHelper_a582eac0a7c42f77cdc5b8319f1c25897}{Print\+Ndisc\+Cache()} method of the \hyperlink{classns3_1_1NdiscCache}{Ndisc\+Cache} associated with each \hyperlink{classns3_1_1Ipv6Interface}{Ipv6\+Interface} stored in the \hyperlink{classns3_1_1Ipv6}{Ipv6} object, for all nodes at the specified time. The output format is similar to\+: \begin{DoxyVerb}2001:db8::f00d:beef:cafe dev 1 lladdr 00-06-00:00:00:00:00:02 REACHABLE
\end{DoxyVerb}
 Note that the M\+AC address is printed as \char`\"{}type\char`\"{}-\/\char`\"{}size\char`\"{}-\/\char`\"{}actual address\char`\"{} 
\begin{DoxyCode}
107 \{
108   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1NodeList_a1d110b1670005895dd5812baab13682a}{NodeList::GetNNodes} (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
109     \{
110       Ptr<Node> node = \hyperlink{classns3_1_1NodeList_a80ac09977d48d29db5c704ac8483cf6c}{NodeList::GetNode} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
111       \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (printInterval, &
      \hyperlink{classns3_1_1Ipv6RoutingHelper_a6b83234c9aa93f14576ba9f12c87a64b}{Ipv6RoutingHelper::PrintNdiscCacheEvery}, printInterval, node, stream
      );
112     \}
113 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13


\index{ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}!Print\+Neighbor\+Cache\+At@{Print\+Neighbor\+Cache\+At}}
\index{Print\+Neighbor\+Cache\+At@{Print\+Neighbor\+Cache\+At}!ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Print\+Neighbor\+Cache\+At(\+Time print\+Time, Ptr$<$ Node $>$ node, Ptr$<$ Output\+Stream\+Wrapper $>$ stream)}{PrintNeighborCacheAt(Time printTime, Ptr< Node > node, Ptr< OutputStreamWrapper > stream)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Routing\+Helper\+::\+Print\+Neighbor\+Cache\+At (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{print\+Time, }
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node, }
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv6RoutingHelper_a8906443d390d97c41fdb09df227051aa}{}\label{classns3_1_1Ipv6RoutingHelper_a8906443d390d97c41fdb09df227051aa}


prints the neighbor cache of a node at a particular time. 


\begin{DoxyParams}{Parameters}
{\em print\+Time} & the time at which the neighbor cache is supposed to be printed. \\
\hline
{\em node} & The node ptr for which we need the neighbor cache to be printed \\
\hline
{\em stream} & The output stream object to use\\
\hline
\end{DoxyParams}
This method calls the \hyperlink{classns3_1_1Ipv6RoutingHelper_a582eac0a7c42f77cdc5b8319f1c25897}{Print\+Ndisc\+Cache()} method of the \hyperlink{classns3_1_1NdiscCache}{Ndisc\+Cache} associated with each \hyperlink{classns3_1_1Ipv6Interface}{Ipv6\+Interface} stored in the \hyperlink{classns3_1_1Ipv6}{Ipv6} object, for all nodes at the specified time. The output format is similar to\+: \begin{DoxyVerb}2001:db8::f00d:beef:cafe dev 1 lladdr 00-06-00:00:00:00:00:02 REACHABLE
\end{DoxyVerb}
 Note that the M\+AC address is printed as \char`\"{}type\char`\"{}-\/\char`\"{}size\char`\"{}-\/\char`\"{}actual address\char`\"{} 
\begin{DoxyCode}
117 \{
118   \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (printTime, &
      \hyperlink{classns3_1_1Ipv6RoutingHelper_a582eac0a7c42f77cdc5b8319f1c25897}{Ipv6RoutingHelper::PrintNdiscCache}, node, stream);
119 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 14


\index{ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}!Print\+Neighbor\+Cache\+Every@{Print\+Neighbor\+Cache\+Every}}
\index{Print\+Neighbor\+Cache\+Every@{Print\+Neighbor\+Cache\+Every}!ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Print\+Neighbor\+Cache\+Every(\+Time print\+Interval, Ptr$<$ Node $>$ node, Ptr$<$ Output\+Stream\+Wrapper $>$ stream)}{PrintNeighborCacheEvery(Time printInterval, Ptr< Node > node, Ptr< OutputStreamWrapper > stream)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Routing\+Helper\+::\+Print\+Neighbor\+Cache\+Every (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{print\+Interval, }
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node, }
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv6RoutingHelper_ac904dfdcd8d047f61fd20cec6ee73cda}{}\label{classns3_1_1Ipv6RoutingHelper_ac904dfdcd8d047f61fd20cec6ee73cda}


prints the neighbor cache of a node at regular intervals specified by user. 


\begin{DoxyParams}{Parameters}
{\em print\+Interval} & the time interval for which the neighbor cache is supposed to be printed. \\
\hline
{\em node} & The node ptr for which we need the neighbor cache to be printed \\
\hline
{\em stream} & The output stream object to use\\
\hline
\end{DoxyParams}
This method calls the \hyperlink{classns3_1_1Ipv6RoutingHelper_a582eac0a7c42f77cdc5b8319f1c25897}{Print\+Ndisc\+Cache()} method of the \hyperlink{classns3_1_1NdiscCache}{Ndisc\+Cache} associated with each \hyperlink{classns3_1_1Ipv6Interface}{Ipv6\+Interface} stored in the \hyperlink{classns3_1_1Ipv6}{Ipv6} object, for all nodes at the specified time. The output format is similar to\+: \begin{DoxyVerb}2001:db8::f00d:beef:cafe dev 1 lladdr 00-06-00:00:00:00:00:02 REACHABLE
\end{DoxyVerb}
 Note that the M\+AC address is printed as \char`\"{}type\char`\"{}-\/\char`\"{}size\char`\"{}-\/\char`\"{}actual address\char`\"{} 
\begin{DoxyCode}
123 \{
124   \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (printInterval, &
      \hyperlink{classns3_1_1Ipv6RoutingHelper_a6b83234c9aa93f14576ba9f12c87a64b}{Ipv6RoutingHelper::PrintNdiscCacheEvery}, printInterval, node, stream
      );
125 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 15


\index{ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}!Print\+Routing\+Table\+All\+At@{Print\+Routing\+Table\+All\+At}}
\index{Print\+Routing\+Table\+All\+At@{Print\+Routing\+Table\+All\+At}!ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Print\+Routing\+Table\+All\+At(\+Time print\+Time, Ptr$<$ Output\+Stream\+Wrapper $>$ stream, Time\+::\+Unit unit=\+Time\+::\+S)}{PrintRoutingTableAllAt(Time printTime, Ptr< OutputStreamWrapper > stream, Time::Unit unit=Time::S)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Routing\+Helper\+::\+Print\+Routing\+Table\+All\+At (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{print\+Time, }
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream, }
\item[{{\bf Time\+::\+Unit}}]{unit = {\ttfamily {\bf Time\+::S}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv6RoutingHelper_a02468528d712df0b6358c6d7bc56b23b}{}\label{classns3_1_1Ipv6RoutingHelper_a02468528d712df0b6358c6d7bc56b23b}


prints the routing tables of all nodes at a particular time. 


\begin{DoxyParams}{Parameters}
{\em print\+Time} & the time at which the routing table is supposed to be printed. \\
\hline
{\em stream} & The output stream object to use \\
\hline
{\em unit} & The time unit to be used in the report\\
\hline
\end{DoxyParams}
This method calls the Print\+Routing\+Table() method of the \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} stored in the \hyperlink{classns3_1_1Ipv6}{Ipv6} object, for all nodes at the specified time; the output format is routing protocol-\/specific. 
\begin{DoxyCode}
40 \{
41   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1NodeList_a1d110b1670005895dd5812baab13682a}{NodeList::GetNNodes} (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
42     \{
43       Ptr<Node> node = \hyperlink{classns3_1_1NodeList_a80ac09977d48d29db5c704ac8483cf6c}{NodeList::GetNode} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
44       \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (printTime, &
      \hyperlink{classns3_1_1Ipv6RoutingHelper_ac01611050813aedf80458c31d303d3b1}{Ipv6RoutingHelper::Print}, node, stream, unit);
45     \}
46 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 16


\index{ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}!Print\+Routing\+Table\+All\+Every@{Print\+Routing\+Table\+All\+Every}}
\index{Print\+Routing\+Table\+All\+Every@{Print\+Routing\+Table\+All\+Every}!ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Print\+Routing\+Table\+All\+Every(\+Time print\+Interval, Ptr$<$ Output\+Stream\+Wrapper $>$ stream, Time\+::\+Unit unit=\+Time\+::\+S)}{PrintRoutingTableAllEvery(Time printInterval, Ptr< OutputStreamWrapper > stream, Time::Unit unit=Time::S)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Routing\+Helper\+::\+Print\+Routing\+Table\+All\+Every (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{print\+Interval, }
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream, }
\item[{{\bf Time\+::\+Unit}}]{unit = {\ttfamily {\bf Time\+::S}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv6RoutingHelper_a716a9e0881c5c0d1f8f3c728556a4473}{}\label{classns3_1_1Ipv6RoutingHelper_a716a9e0881c5c0d1f8f3c728556a4473}


prints the routing tables of all nodes at regular intervals specified by user. 


\begin{DoxyParams}{Parameters}
{\em print\+Interval} & the time interval for which the routing table is supposed to be printed. \\
\hline
{\em stream} & The output stream object to use \\
\hline
{\em unit} & The time unit to be used in the report\\
\hline
\end{DoxyParams}
This method calls the Print\+Routing\+Table() method of the \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} stored in the \hyperlink{classns3_1_1Ipv6}{Ipv6} object, for all nodes at the specified time interval; the output format is routing protocol-\/specific. 
\begin{DoxyCode}
50 \{
51   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1NodeList_a1d110b1670005895dd5812baab13682a}{NodeList::GetNNodes} (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
52     \{
53       Ptr<Node> node = \hyperlink{classns3_1_1NodeList_a80ac09977d48d29db5c704ac8483cf6c}{NodeList::GetNode} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
54       \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (printInterval, &
      \hyperlink{classns3_1_1Ipv6RoutingHelper_affe6938b3ce8f3590a382c6ba8d8dd74}{Ipv6RoutingHelper::PrintEvery}, printInterval, node, stream, unit);
55     \}
56 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 17


\index{ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}!Print\+Routing\+Table\+At@{Print\+Routing\+Table\+At}}
\index{Print\+Routing\+Table\+At@{Print\+Routing\+Table\+At}!ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Print\+Routing\+Table\+At(\+Time print\+Time, Ptr$<$ Node $>$ node, Ptr$<$ Output\+Stream\+Wrapper $>$ stream, Time\+::\+Unit unit=\+Time\+::\+S)}{PrintRoutingTableAt(Time printTime, Ptr< Node > node, Ptr< OutputStreamWrapper > stream, Time::Unit unit=Time::S)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Routing\+Helper\+::\+Print\+Routing\+Table\+At (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{print\+Time, }
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node, }
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream, }
\item[{{\bf Time\+::\+Unit}}]{unit = {\ttfamily {\bf Time\+::S}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv6RoutingHelper_a4f7287245996b0bb7bdfe9d27adac329}{}\label{classns3_1_1Ipv6RoutingHelper_a4f7287245996b0bb7bdfe9d27adac329}


prints the routing tables of a node at a particular time. 


\begin{DoxyParams}{Parameters}
{\em print\+Time} & the time at which the routing table is supposed to be printed. \\
\hline
{\em node} & The node ptr for which we need the routing table to be printed \\
\hline
{\em stream} & The output stream object to use \\
\hline
{\em unit} & The time unit to be used in the report\\
\hline
\end{DoxyParams}
This method calls the Print\+Routing\+Table() method of the \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} stored in the \hyperlink{classns3_1_1Ipv6}{Ipv6} object, for the selected node at the specified time; the output format is routing protocol-\/specific. 
\begin{DoxyCode}
60 \{
61   \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (printTime, &\hyperlink{classns3_1_1Ipv6RoutingHelper_ac01611050813aedf80458c31d303d3b1}{Ipv6RoutingHelper::Print}, 
      node, stream, unit);
62 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 18


\index{ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}!Print\+Routing\+Table\+Every@{Print\+Routing\+Table\+Every}}
\index{Print\+Routing\+Table\+Every@{Print\+Routing\+Table\+Every}!ns3\+::\+Ipv6\+Routing\+Helper@{ns3\+::\+Ipv6\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Print\+Routing\+Table\+Every(\+Time print\+Interval, Ptr$<$ Node $>$ node, Ptr$<$ Output\+Stream\+Wrapper $>$ stream, Time\+::\+Unit unit=\+Time\+::\+S)}{PrintRoutingTableEvery(Time printInterval, Ptr< Node > node, Ptr< OutputStreamWrapper > stream, Time::Unit unit=Time::S)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Routing\+Helper\+::\+Print\+Routing\+Table\+Every (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{print\+Interval, }
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node, }
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream, }
\item[{{\bf Time\+::\+Unit}}]{unit = {\ttfamily {\bf Time\+::S}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv6RoutingHelper_a802767089cd111e52aea8fef65dfd32e}{}\label{classns3_1_1Ipv6RoutingHelper_a802767089cd111e52aea8fef65dfd32e}


prints the routing tables of a node at regular intervals specified by user. 


\begin{DoxyParams}{Parameters}
{\em print\+Interval} & the time interval for which the routing table is supposed to be printed. \\
\hline
{\em node} & The node ptr for which we need the routing table to be printed \\
\hline
{\em stream} & The output stream object to use \\
\hline
{\em unit} & The time unit to be used in the report\\
\hline
\end{DoxyParams}
This method calls the Print\+Routing\+Table() method of the \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} stored in the \hyperlink{classns3_1_1Ipv6}{Ipv6} object, for the selected node at the specified interval; the output format is routing protocol-\/specific. 
\begin{DoxyCode}
66 \{
67   \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (printInterval, &
      \hyperlink{classns3_1_1Ipv6RoutingHelper_affe6938b3ce8f3590a382c6ba8d8dd74}{Ipv6RoutingHelper::PrintEvery}, printInterval, node, stream, unit);
68 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 19




The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/helper/\hyperlink{ipv6-routing-helper_8h}{ipv6-\/routing-\/helper.\+h}\item 
internet/helper/\hyperlink{ipv6-routing-helper_8cc}{ipv6-\/routing-\/helper.\+cc}\end{DoxyCompactItemize}
