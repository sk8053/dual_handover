\hypertarget{classns3_1_1TrafficControlLayer}{}\section{ns3\+:\+:Traffic\+Control\+Layer Class Reference}
\label{classns3_1_1TrafficControlLayer}\index{ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}}


{\ttfamily \#include $<$traffic-\/control-\/layer.\+h$>$}



Inheritance diagram for ns3\+:\+:Traffic\+Control\+Layer\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Traffic\+Control\+Layer\+:
% FIG 1
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classns3_1_1TrafficControlLayer_1_1NetDeviceInfo}{Net\+Device\+Info}
\begin{DoxyCompactList}\small\item\em Information to store for each device. \end{DoxyCompactList}\item 
struct \hyperlink{structns3_1_1TrafficControlLayer_1_1ProtocolHandlerEntry}{Protocol\+Handler\+Entry}
\begin{DoxyCompactList}\small\item\em Protocol handler entry. This structure is used to demultiplex all the protocols. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef std\+::vector$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1QueueDisc}{Queue\+Disc} $>$ $>$ \hyperlink{classns3_1_1TrafficControlLayer_a9c468db4727d64733d7dba66d2791edf}{Queue\+Disc\+Vector}
\begin{DoxyCompactList}\small\item\em Typedef for queue disc vector. \end{DoxyCompactList}\item 
typedef \hyperlink{classns3_1_1Callback}{Callback}$<$ uint8\+\_\+t, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1QueueItem}{Queue\+Item} $>$ $>$ \hyperlink{classns3_1_1TrafficControlLayer_aac192f903f140af92ca59a2d91a4c0cb}{Select\+Queue\+Callback}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Callback}{Callback} invoked to determine the tx queue selected for a given packet. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1TrafficControlLayer_abe3b878f566ff58d4dcadc2e193f40f5}{Get\+Instance\+Type\+Id} (void) const 
\begin{DoxyCompactList}\small\item\em Get the type ID for the instance. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TrafficControlLayer_a5e01ca7f1b266b684104985fc835c5f2}{Traffic\+Control\+Layer} ()
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1TrafficControlLayer_aa08e8ce5078fce7ff3128a41d3b29366}{$\sim$\+Traffic\+Control\+Layer} ()
\item 
void \hyperlink{classns3_1_1TrafficControlLayer_af1aa1791591898efe876969ab78f4a9b}{Register\+Protocol\+Handler} (\hyperlink{classns3_1_1Node_a4ce20b9442f89703d242ce3a3fa3dbf2}{Node\+::\+Protocol\+Handler} handler, uint16\+\_\+t protocol\+Type, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device)
\begin{DoxyCompactList}\small\item\em Register an IN handler. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1TrafficControlLayer_ac60c5208106f39f7ad25082083ed48a0}{Setup\+Device} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device)
\begin{DoxyCompactList}\small\item\em Perform the operations that the traffic control layer needs to do when an I\+Pv4/v6 interface is added to a device. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1TrafficControlLayer_ae44f2ceeba57ab2628cdda8c0c9e12fc}{Set\+Root\+Queue\+Disc\+On\+Device} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1QueueDisc}{Queue\+Disc} $>$ q\+Disc)
\begin{DoxyCompactList}\small\item\em This method can be used to set the root queue disc installed on a device. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1QueueDisc}{Queue\+Disc} $>$ \hyperlink{classns3_1_1TrafficControlLayer_ac623c250089d239f91931d3cd021552c}{Get\+Root\+Queue\+Disc\+On\+Device} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device) const 
\begin{DoxyCompactList}\small\item\em This method can be used to get the root queue disc installed on a device. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1TrafficControlLayer_a7b162c6b30b1a5e628a68f8fd9f59c1e}{Delete\+Root\+Queue\+Disc\+On\+Device} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device)
\begin{DoxyCompactList}\small\item\em This method can be used to remove the root queue disc (and associated filters, classes and queues) installed on a device. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1TrafficControlLayer_ab2ceb8b90b3418c201f9ecd0ed0c5467}{Set\+Node} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node)
\begin{DoxyCompactList}\small\item\em Set node associated with this stack. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1TrafficControlLayer_ac8d6ccbab480b6b288aa155b8485e178}{Receive} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, uint16\+\_\+t protocol, const \hyperlink{classns3_1_1Address}{Address} \&\hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from}, const \hyperlink{classns3_1_1Address}{Address} \&to, \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2}{Net\+Device\+::\+Packet\+Type} packet\+Type)
\begin{DoxyCompactList}\small\item\em Called by Net\+Devices, incoming packet. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1TrafficControlLayer_aae45cb92c1adb038bac63d347632e627}{Send} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1QueueDiscItem}{Queue\+Disc\+Item} $>$ item)
\begin{DoxyCompactList}\small\item\em Called from upper layer to queue a packet for the transmission. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1TrafficControlLayer_a6710fc399667be74683173183dbb9975}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1TrafficControlLayer_abdb713598fd4dac736848e5cb61b79cc}{Do\+Dispose} (void)
\item 
virtual void \hyperlink{classns3_1_1TrafficControlLayer_ad9ba2e27ced5aa957e45effcbe71aba9}{Do\+Initialize} (void)
\item 
virtual void \hyperlink{classns3_1_1TrafficControlLayer_ad5d645b8add4a444261f6f263c4e4b11}{Notify\+New\+Aggregate} (void)
\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
typedef std\+::vector$<$ struct \hyperlink{structns3_1_1TrafficControlLayer_1_1ProtocolHandlerEntry}{Protocol\+Handler\+Entry} $>$ \hyperlink{classns3_1_1TrafficControlLayer_a4cb25dc01a0f3b99c59c42bf77404247}{Protocol\+Handler\+List}
\begin{DoxyCompactList}\small\item\em Typedef for protocol handlers container. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1TrafficControlLayer_ae017567979012a6b833b98d315d939a9}{Traffic\+Control\+Layer} (\hyperlink{classns3_1_1TrafficControlLayer}{Traffic\+Control\+Layer} const \&)
\begin{DoxyCompactList}\small\item\em Copy constructor Disable default implementation to avoid misuse. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TrafficControlLayer}{Traffic\+Control\+Layer} \& \hyperlink{classns3_1_1TrafficControlLayer_a5825d763cf9b982cff9940c150d4eac8}{operator=} (\hyperlink{classns3_1_1TrafficControlLayer}{Traffic\+Control\+Layer} const \&)
\begin{DoxyCompactList}\small\item\em Assignment operator. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1TrafficControlLayer_ab5d6a1d820a9ce62afcb2eb95a9110cd}{Get\+N\+Devices} (void) const 
\begin{DoxyCompactList}\small\item\em Required by the object map accessor. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1QueueDisc}{Queue\+Disc} $>$ \hyperlink{classns3_1_1TrafficControlLayer_a6712e320745fa4279b4acb22d1e88848}{Get\+Root\+Queue\+Disc\+On\+Device\+By\+Index} (uint32\+\_\+t index) const 
\begin{DoxyCompactList}\small\item\em Required by the object map accessor. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1TrafficControlLayer_a6892507af633ef1fb7e1e0a50b54f0f2}{m\+\_\+node}
\begin{DoxyCompactList}\small\item\em The node this \hyperlink{classns3_1_1TrafficControlLayer}{Traffic\+Control\+Layer} object is aggregated to. \end{DoxyCompactList}\item 
std\+::map$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$, \hyperlink{classns3_1_1TrafficControlLayer_1_1NetDeviceInfo}{Net\+Device\+Info} $>$ \hyperlink{classns3_1_1TrafficControlLayer_a78320d2a2610f730984ca796ed51a495}{m\+\_\+net\+Devices}
\begin{DoxyCompactList}\small\item\em Map storing the required information for each device with a queue disc installed. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TrafficControlLayer_a4cb25dc01a0f3b99c59c42bf77404247}{Protocol\+Handler\+List} \hyperlink{classns3_1_1TrafficControlLayer_a598f6f4d4efa5e776abfe6c0c3af65fa}{m\+\_\+handlers}
\begin{DoxyCompactList}\small\item\em List of upper-\/layer handlers. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Member Typedef Documentation}
\index{ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}!Protocol\+Handler\+List@{Protocol\+Handler\+List}}
\index{Protocol\+Handler\+List@{Protocol\+Handler\+List}!ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}}
\subsubsection[{\texorpdfstring{Protocol\+Handler\+List}{ProtocolHandlerList}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::vector$<$struct {\bf Protocol\+Handler\+Entry}$>$ {\bf ns3\+::\+Traffic\+Control\+Layer\+::\+Protocol\+Handler\+List}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TrafficControlLayer_a4cb25dc01a0f3b99c59c42bf77404247}{}\label{classns3_1_1TrafficControlLayer_a4cb25dc01a0f3b99c59c42bf77404247}


Typedef for protocol handlers container. 

\index{ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}!Queue\+Disc\+Vector@{Queue\+Disc\+Vector}}
\index{Queue\+Disc\+Vector@{Queue\+Disc\+Vector}!ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}}
\subsubsection[{\texorpdfstring{Queue\+Disc\+Vector}{QueueDiscVector}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::vector$<${\bf Ptr}$<${\bf Queue\+Disc}$>$ $>$ {\bf ns3\+::\+Traffic\+Control\+Layer\+::\+Queue\+Disc\+Vector}}\hypertarget{classns3_1_1TrafficControlLayer_a9c468db4727d64733d7dba66d2791edf}{}\label{classns3_1_1TrafficControlLayer_a9c468db4727d64733d7dba66d2791edf}


Typedef for queue disc vector. 

\index{ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}!Select\+Queue\+Callback@{Select\+Queue\+Callback}}
\index{Select\+Queue\+Callback@{Select\+Queue\+Callback}!ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}}
\subsubsection[{\texorpdfstring{Select\+Queue\+Callback}{SelectQueueCallback}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Callback}$<$ uint8\+\_\+t, {\bf Ptr}$<${\bf Queue\+Item}$>$ $>$ {\bf ns3\+::\+Traffic\+Control\+Layer\+::\+Select\+Queue\+Callback}}\hypertarget{classns3_1_1TrafficControlLayer_aac192f903f140af92ca59a2d91a4c0cb}{}\label{classns3_1_1TrafficControlLayer_aac192f903f140af92ca59a2d91a4c0cb}


\hyperlink{classns3_1_1Callback}{Callback} invoked to determine the tx queue selected for a given packet. 



\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}!Traffic\+Control\+Layer@{Traffic\+Control\+Layer}}
\index{Traffic\+Control\+Layer@{Traffic\+Control\+Layer}!ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}}
\subsubsection[{\texorpdfstring{Traffic\+Control\+Layer()}{TrafficControlLayer()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Traffic\+Control\+Layer\+::\+Traffic\+Control\+Layer (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TrafficControlLayer_a5e01ca7f1b266b684104985fc835c5f2}{}\label{classns3_1_1TrafficControlLayer_a5e01ca7f1b266b684104985fc835c5f2}


Constructor. 


\begin{DoxyCode}
58   : \hyperlink{classns3_1_1Object_a40860402e64d8008fb42329df7097cdb}{Object} ()
59 \{
60   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
61 \}
\end{DoxyCode}
\index{ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}!````~Traffic\+Control\+Layer@{$\sim$\+Traffic\+Control\+Layer}}
\index{````~Traffic\+Control\+Layer@{$\sim$\+Traffic\+Control\+Layer}!ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}}
\subsubsection[{\texorpdfstring{$\sim$\+Traffic\+Control\+Layer()}{~TrafficControlLayer()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Traffic\+Control\+Layer\+::$\sim$\+Traffic\+Control\+Layer (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TrafficControlLayer_aa08e8ce5078fce7ff3128a41d3b29366}{}\label{classns3_1_1TrafficControlLayer_aa08e8ce5078fce7ff3128a41d3b29366}

\begin{DoxyCode}
64 \{
65   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
66 \}
\end{DoxyCode}
\index{ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}!Traffic\+Control\+Layer@{Traffic\+Control\+Layer}}
\index{Traffic\+Control\+Layer@{Traffic\+Control\+Layer}!ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}}
\subsubsection[{\texorpdfstring{Traffic\+Control\+Layer(\+Traffic\+Control\+Layer const \&)}{TrafficControlLayer(TrafficControlLayer const &)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Traffic\+Control\+Layer\+::\+Traffic\+Control\+Layer (
\begin{DoxyParamCaption}
\item[{{\bf Traffic\+Control\+Layer} const \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TrafficControlLayer_ae017567979012a6b833b98d315d939a9}{}\label{classns3_1_1TrafficControlLayer_ae017567979012a6b833b98d315d939a9}


Copy constructor Disable default implementation to avoid misuse. 



\subsection{Member Function Documentation}
\index{ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}!Delete\+Root\+Queue\+Disc\+On\+Device@{Delete\+Root\+Queue\+Disc\+On\+Device}}
\index{Delete\+Root\+Queue\+Disc\+On\+Device@{Delete\+Root\+Queue\+Disc\+On\+Device}!ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}}
\subsubsection[{\texorpdfstring{Delete\+Root\+Queue\+Disc\+On\+Device(\+Ptr$<$ Net\+Device $>$ device)}{DeleteRootQueueDiscOnDevice(Ptr< NetDevice > device)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Traffic\+Control\+Layer\+::\+Delete\+Root\+Queue\+Disc\+On\+Device (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{device}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TrafficControlLayer_a7b162c6b30b1a5e628a68f8fd9f59c1e}{}\label{classns3_1_1TrafficControlLayer_a7b162c6b30b1a5e628a68f8fd9f59c1e}


This method can be used to remove the root queue disc (and associated filters, classes and queues) installed on a device. 


\begin{DoxyParams}{Parameters}
{\em device} & the device on which the installed queue disc will be deleted \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
237 \{
238   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << device);
239 
240   std::map<Ptr<NetDevice>, NetDeviceInfo>::iterator ndi = \hyperlink{classns3_1_1TrafficControlLayer_a78320d2a2610f730984ca796ed51a495}{m\_netDevices}.find (device);
241 
242   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (ndi != \hyperlink{classns3_1_1TrafficControlLayer_a78320d2a2610f730984ca796ed51a495}{m\_netDevices}.end () && ndi->second.m\_rootQueueDisc != 0, \textcolor{stringliteral}{"
      No root queue disc"}
243                  << \textcolor{stringliteral}{" installed on device "} << device);
244 
245   \textcolor{comment}{// remove the root queue disc}
246   ndi->second.m\_rootQueueDisc = 0;
247   ndi->second.m\_queueDiscsToWake.clear ();
248 \}
\end{DoxyCode}
\index{ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}}
\subsubsection[{\texorpdfstring{Do\+Dispose(void)}{DoDispose(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Traffic\+Control\+Layer\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1TrafficControlLayer_abdb713598fd4dac736848e5cb61b79cc}{}\label{classns3_1_1TrafficControlLayer_abdb713598fd4dac736848e5cb61b79cc}
Destructor implementation.

This method is called by \hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose()} or by the \hyperlink{classns3_1_1Object}{Object}\textquotesingle{}s destructor, whichever comes first.

Subclasses are expected to implement their real destruction code in an overriden version of this method and chain up to their parent\textquotesingle{}s implementation once they are done. {\itshape i.\+e}, for simplicity, the destructor of every subclass should be empty and its content should be moved to the associated \hyperlink{classns3_1_1TrafficControlLayer_abdb713598fd4dac736848e5cb61b79cc}{Do\+Dispose()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.


\begin{DoxyCode}
70 \{
71   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
72   \hyperlink{classns3_1_1TrafficControlLayer_a6892507af633ef1fb7e1e0a50b54f0f2}{m\_node} = 0;
73   \hyperlink{classns3_1_1TrafficControlLayer_a598f6f4d4efa5e776abfe6c0c3af65fa}{m\_handlers}.clear ();
74   \hyperlink{classns3_1_1TrafficControlLayer_a78320d2a2610f730984ca796ed51a495}{m\_netDevices}.clear ();
75   \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{Object::DoDispose} ();
76 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}!Do\+Initialize@{Do\+Initialize}}
\index{Do\+Initialize@{Do\+Initialize}!ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}}
\subsubsection[{\texorpdfstring{Do\+Initialize(void)}{DoInitialize(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Traffic\+Control\+Layer\+::\+Do\+Initialize (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1TrafficControlLayer_ad9ba2e27ced5aa957e45effcbe71aba9}{}\label{classns3_1_1TrafficControlLayer_ad9ba2e27ced5aa957e45effcbe71aba9}
\hyperlink{classns3_1_1Object_af4411cb29971772fcd09203474a95078}{Initialize()} implementation.

This method is called only once by \hyperlink{classns3_1_1Object_af4411cb29971772fcd09203474a95078}{Initialize()}. If the user calls \hyperlink{classns3_1_1Object_af4411cb29971772fcd09203474a95078}{Initialize()} multiple times, \hyperlink{classns3_1_1TrafficControlLayer_ad9ba2e27ced5aa957e45effcbe71aba9}{Do\+Initialize()} is called only the first time.

Subclasses are expected to override this method and chain up to their parent\textquotesingle{}s implementation once they are done. It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} and \hyperlink{classns3_1_1Object_a79dd435d300f3deca814553f561a2922}{Aggregate\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_af8482a521433409fb5c7f749398c9dbe}{ns3\+::\+Object}.


\begin{DoxyCode}
96 \{
97   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
98   std::map<Ptr<NetDevice>, NetDeviceInfo>::iterator ndi;
99   \textcolor{keywordflow}{for} (ndi = \hyperlink{classns3_1_1TrafficControlLayer_a78320d2a2610f730984ca796ed51a495}{m\_netDevices}.begin (); ndi != \hyperlink{classns3_1_1TrafficControlLayer_a78320d2a2610f730984ca796ed51a495}{m\_netDevices}.end (); ndi++)
100     \{
101       Ptr<NetDeviceQueueInterface> devQueueIface = ndi->second.m\_ndqi;
102       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (devQueueIface);
103 
104       \textcolor{keywordflow}{if} (ndi->second.m\_rootQueueDisc)
105         \{
106           \textcolor{comment}{// set the wake callbacks on netdevice queues}
107            \textcolor{keywordflow}{if} (ndi->second.m\_rootQueueDisc->GetWakeMode () == 
      \hyperlink{classns3_1_1QueueDisc_a0b9b32e71d5becf66e6ac4b3d3de7c8ba56fb0e52526a39cefb47d24550bf47c6}{QueueDisc::WAKE\_ROOT})
108             \{
109               \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < devQueueIface->GetNTxQueues (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
110                 \{
111                   devQueueIface->GetTxQueue (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})->SetWakeCallback (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1QueueDisc_a424eceba41cb013436f353c622c082ff}{QueueDisc::Run}, ndi->second.m\_rootQueueDisc));
112                   ndi->second.m\_queueDiscsToWake.push\_back (ndi->second.m\_rootQueueDisc);
113                 \}
114             \}
115           \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ndi->second.m\_rootQueueDisc->GetWakeMode () == 
      \hyperlink{classns3_1_1QueueDisc_a0b9b32e71d5becf66e6ac4b3d3de7c8bad2dbf3b0b56e3e0d4d0f8f944c4d0fcd}{QueueDisc::WAKE\_CHILD})
116             \{
117               \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (ndi->second.m\_rootQueueDisc->GetNQueueDiscClasses () == 
      devQueueIface->GetNTxQueues (),
118                              \textcolor{stringliteral}{"The number of child queue discs does not match the number of netdevice queues
      "});
119               \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < devQueueIface->GetNTxQueues (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
120                 \{
121                   devQueueIface->GetTxQueue (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})->SetWakeCallback (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1QueueDisc_a424eceba41cb013436f353c622c082ff}{QueueDisc::Run},
122                                                                   ndi->second.m\_rootQueueDisc->
      GetQueueDiscClass (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})->GetQueueDisc ()));
123                   ndi->second.m\_queueDiscsToWake.push\_back (ndi->second.m\_rootQueueDisc->GetQueueDiscClass 
      (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})->GetQueueDisc ());
124                 \}
125             \}
126 
127           \textcolor{comment}{// initialize the queue disc}
128           ndi->second.m\_rootQueueDisc->Initialize ();
129         \}
130     \}
131   \hyperlink{classns3_1_1Object_af8482a521433409fb5c7f749398c9dbe}{Object::DoInitialize} ();
132 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}!Get\+Instance\+Type\+Id@{Get\+Instance\+Type\+Id}}
\index{Get\+Instance\+Type\+Id@{Get\+Instance\+Type\+Id}!ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}}
\subsubsection[{\texorpdfstring{Get\+Instance\+Type\+Id(void) const }{GetInstanceTypeId(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Traffic\+Control\+Layer\+::\+Get\+Instance\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TrafficControlLayer_abe3b878f566ff58d4dcadc2e193f40f5}{}\label{classns3_1_1TrafficControlLayer_abe3b878f566ff58d4dcadc2e193f40f5}


Get the type ID for the instance. 

\begin{DoxyReturn}{Returns}
the instance \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}


Reimplemented from \hyperlink{classns3_1_1Object_a51e5994fa4b6eae32d719ad69f8fcbf5}{ns3\+::\+Object}.


\begin{DoxyCode}
53 \{
54   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TrafficControlLayer_a6710fc399667be74683173183dbb9975}{GetTypeId} ();
55 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4


\index{ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}!Get\+N\+Devices@{Get\+N\+Devices}}
\index{Get\+N\+Devices@{Get\+N\+Devices}!ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}}
\subsubsection[{\texorpdfstring{Get\+N\+Devices(void) const }{GetNDevices(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Traffic\+Control\+Layer\+::\+Get\+N\+Devices (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TrafficControlLayer_ab5d6a1d820a9ce62afcb2eb95a9110cd}{}\label{classns3_1_1TrafficControlLayer_ab5d6a1d820a9ce62afcb2eb95a9110cd}


Required by the object map accessor. 

\begin{DoxyReturn}{Returns}
the number of devices in the m\+\_\+net\+Devices map 
\end{DoxyReturn}

\begin{DoxyCode}
276 \{
277   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TrafficControlLayer_a6892507af633ef1fb7e1e0a50b54f0f2}{m\_node}->\hyperlink{classns3_1_1Node_a531554d2241ba4fa1cd74e3360be6bce}{GetNDevices} ();
278 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5




Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}!Get\+Root\+Queue\+Disc\+On\+Device@{Get\+Root\+Queue\+Disc\+On\+Device}}
\index{Get\+Root\+Queue\+Disc\+On\+Device@{Get\+Root\+Queue\+Disc\+On\+Device}!ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}}
\subsubsection[{\texorpdfstring{Get\+Root\+Queue\+Disc\+On\+Device(\+Ptr$<$ Net\+Device $>$ device) const }{GetRootQueueDiscOnDevice(Ptr< NetDevice > device) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Queue\+Disc} $>$ ns3\+::\+Traffic\+Control\+Layer\+::\+Get\+Root\+Queue\+Disc\+On\+Device (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{device}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TrafficControlLayer_ac623c250089d239f91931d3cd021552c}{}\label{classns3_1_1TrafficControlLayer_ac623c250089d239f91931d3cd021552c}


This method can be used to get the root queue disc installed on a device. 


\begin{DoxyParams}{Parameters}
{\em device} & the device on which the requested root queue disc is installed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the root queue disc installed on the given device 
\end{DoxyReturn}

\begin{DoxyCode}
216 \{
217   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << device);
218 
219   std::map<Ptr<NetDevice>, NetDeviceInfo>::const\_iterator ndi = \hyperlink{classns3_1_1TrafficControlLayer_a78320d2a2610f730984ca796ed51a495}{m\_netDevices}.find (device);
220 
221   \textcolor{keywordflow}{if} (ndi == \hyperlink{classns3_1_1TrafficControlLayer_a78320d2a2610f730984ca796ed51a495}{m\_netDevices}.end ())
222     \{
223       \textcolor{keywordflow}{return} 0;
224     \}
225   \textcolor{keywordflow}{return} ndi->second.m\_rootQueueDisc;
226 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}!Get\+Root\+Queue\+Disc\+On\+Device\+By\+Index@{Get\+Root\+Queue\+Disc\+On\+Device\+By\+Index}}
\index{Get\+Root\+Queue\+Disc\+On\+Device\+By\+Index@{Get\+Root\+Queue\+Disc\+On\+Device\+By\+Index}!ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}}
\subsubsection[{\texorpdfstring{Get\+Root\+Queue\+Disc\+On\+Device\+By\+Index(uint32\+\_\+t index) const }{GetRootQueueDiscOnDeviceByIndex(uint32_t index) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Queue\+Disc} $>$ ns3\+::\+Traffic\+Control\+Layer\+::\+Get\+Root\+Queue\+Disc\+On\+Device\+By\+Index (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{index}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TrafficControlLayer_a6712e320745fa4279b4acb22d1e88848}{}\label{classns3_1_1TrafficControlLayer_a6712e320745fa4279b4acb22d1e88848}


Required by the object map accessor. 


\begin{DoxyParams}{Parameters}
{\em index} & the index of the device in the node\textquotesingle{}s device list \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the root queue disc installed on the specified device 
\end{DoxyReturn}

\begin{DoxyCode}
230 \{
231   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << index);
232   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1TrafficControlLayer_ac623c250089d239f91931d3cd021552c}{GetRootQueueDiscOnDevice} (\hyperlink{classns3_1_1TrafficControlLayer_a6892507af633ef1fb7e1e0a50b54f0f2}{m\_node}->
      \hyperlink{classns3_1_1Node_a5918dfd24ef632efc9a83a5f6561c76e}{GetDevice} (index));
233 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8




Here is the caller graph for this function\+:
% FIG 9


\index{ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Traffic\+Control\+Layer\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1TrafficControlLayer_a6710fc399667be74683173183dbb9975}{}\label{classns3_1_1TrafficControlLayer_a6710fc399667be74683173183dbb9975}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
37 \{
38   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::TrafficControlLayer"})
39     .SetParent<\hyperlink{classns3_1_1Object_a40860402e64d8008fb42329df7097cdb}{Object}> ()
40     .SetGroupName (\textcolor{stringliteral}{"TrafficControl"})
41     .AddConstructor<\hyperlink{classns3_1_1TrafficControlLayer_a5e01ca7f1b266b684104985fc835c5f2}{TrafficControlLayer}> ()
42     .AddAttribute (\textcolor{stringliteral}{"RootQueueDiscList"}, \textcolor{stringliteral}{"The list of root queue discs associated to this Traffic Control
       layer."},
43                    \hyperlink{namespacens3_a5cac680c954929d49b48f4c40c1a2e08}{ObjectMapValue} (),
44                    \hyperlink{namespacens3_acfdf708e388c66beea68eb5ecdcb7456}{MakeObjectMapAccessor} (&
      \hyperlink{classns3_1_1TrafficControlLayer_ab5d6a1d820a9ce62afcb2eb95a9110cd}{TrafficControlLayer::GetNDevices},
45                                           &
      \hyperlink{classns3_1_1TrafficControlLayer_a6712e320745fa4279b4acb22d1e88848}{TrafficControlLayer::GetRootQueueDiscOnDeviceByIndex}),
46                    MakeObjectMapChecker<QueueDisc> ())
47   ;
48   \textcolor{keywordflow}{return} tid;
49 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10




Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}!Notify\+New\+Aggregate@{Notify\+New\+Aggregate}}
\index{Notify\+New\+Aggregate@{Notify\+New\+Aggregate}!ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}}
\subsubsection[{\texorpdfstring{Notify\+New\+Aggregate(void)}{NotifyNewAggregate(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Traffic\+Control\+Layer\+::\+Notify\+New\+Aggregate (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1TrafficControlLayer_ad5d645b8add4a444261f6f263c4e4b11}{}\label{classns3_1_1TrafficControlLayer_ad5d645b8add4a444261f6f263c4e4b11}
Notify all Objects aggregated to this one of a new \hyperlink{classns3_1_1Object}{Object} being aggregated.

This method is invoked whenever two sets of Objects are aggregated together. It is invoked exactly once for each \hyperlink{classns3_1_1Object}{Object} in both sets. This method can be overriden by subclasses who wish to be notified of aggregation events. These subclasses must chain up to their base class \hyperlink{classns3_1_1TrafficControlLayer_ad5d645b8add4a444261f6f263c4e4b11}{Notify\+New\+Aggregate()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} and \hyperlink{classns3_1_1Object_a79dd435d300f3deca814553f561a2922}{Aggregate\+Object()} from within this method.

This function must be implemented in the stack that needs to notify other stacks connected to the node of their presence in the node. 

Reimplemented from \hyperlink{classns3_1_1Object_a1bd7211125185a6cd511c35fea4e500f}{ns3\+::\+Object}.


\begin{DoxyCode}
259 \{
260   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
261   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1TrafficControlLayer_a6892507af633ef1fb7e1e0a50b54f0f2}{m\_node} == 0)
262     \{
263       Ptr<Node> node = this->GetObject<Node> ();
264       \textcolor{comment}{//verify that it's a valid node and that}
265       \textcolor{comment}{//the node was not set before}
266       \textcolor{keywordflow}{if} (node != 0)
267         \{
268           this->\hyperlink{classns3_1_1TrafficControlLayer_ab2ceb8b90b3418c201f9ecd0ed0c5467}{SetNode} (node);
269         \}
270     \}
271   \hyperlink{classns3_1_1Object_a1bd7211125185a6cd511c35fea4e500f}{Object::NotifyNewAggregate} ();
272 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12


\index{ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}!operator=@{operator=}}
\index{operator=@{operator=}!ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}}
\subsubsection[{\texorpdfstring{operator=(\+Traffic\+Control\+Layer const \&)}{operator=(TrafficControlLayer const &)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traffic\+Control\+Layer}\& ns3\+::\+Traffic\+Control\+Layer\+::operator= (
\begin{DoxyParamCaption}
\item[{{\bf Traffic\+Control\+Layer} const \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TrafficControlLayer_a5825d763cf9b982cff9940c150d4eac8}{}\label{classns3_1_1TrafficControlLayer_a5825d763cf9b982cff9940c150d4eac8}


Assignment operator. 

\begin{DoxyReturn}{Returns}
this object Disable default implementation to avoid misuse 
\end{DoxyReturn}
\index{ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}!Receive@{Receive}}
\index{Receive@{Receive}!ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}}
\subsubsection[{\texorpdfstring{Receive(\+Ptr$<$ Net\+Device $>$ device, Ptr$<$ const Packet $>$ p, uint16\+\_\+t protocol, const Address \&from, const Address \&to, Net\+Device\+::\+Packet\+Type packet\+Type)}{Receive(Ptr< NetDevice > device, Ptr< const Packet > p, uint16_t protocol, const Address &from, const Address &to, NetDevice::PacketType packetType)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Traffic\+Control\+Layer\+::\+Receive (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{device, }
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p, }
\item[{uint16\+\_\+t}]{protocol, }
\item[{const {\bf Address} \&}]{from, }
\item[{const {\bf Address} \&}]{to, }
\item[{{\bf Net\+Device\+::\+Packet\+Type}}]{packet\+Type}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TrafficControlLayer_ac8d6ccbab480b6b288aa155b8485e178}{}\label{classns3_1_1TrafficControlLayer_ac8d6ccbab480b6b288aa155b8485e178}


Called by Net\+Devices, incoming packet. 

After analyses and scheduling, this method will call the right handler to pass the packet up in the stack.


\begin{DoxyParams}{Parameters}
{\em device} & network device \\
\hline
{\em p} & the packet \\
\hline
{\em protocol} & next header value \\
\hline
{\em from} & address of the correspondant \\
\hline
{\em to} & address of the destination \\
\hline
{\em packet\+Type} & type of the packet \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
285 \{
286   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << device << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} << protocol << \hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from} << to << packetType);
287 
288   \textcolor{keywordtype}{bool} found = \textcolor{keyword}{false};
289 
290   \textcolor{keywordflow}{for} (ProtocolHandlerList::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1TrafficControlLayer_a598f6f4d4efa5e776abfe6c0c3af65fa}{m\_handlers}.begin ();
291        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1TrafficControlLayer_a598f6f4d4efa5e776abfe6c0c3af65fa}{m\_handlers}.end (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
292     \{
293       \textcolor{keywordflow}{if} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->device == 0
294           || (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->device != 0 && \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->device == device))
295         \{
296           \textcolor{keywordflow}{if} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->protocol == 0
297               || \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->protocol == protocol)
298             \{
299               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Found handler for packet "} << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} << \textcolor{stringliteral}{", protocol "} <<
300                             protocol << \textcolor{stringliteral}{" and NetDevice "} << device <<
301                             \textcolor{stringliteral}{". Send packet up"});
302               \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->handler (device, \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, protocol, \hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from}, to, packetType);
303               found = \textcolor{keyword}{true};
304             \}
305         \}
306     \}
307 
308   \textcolor{keywordflow}{if} (! found)
309     \{
310       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Handler for protocol "} << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} << \textcolor{stringliteral}{" and device "} << device <<
311                       \textcolor{stringliteral}{" not found. It isn't forwarded up; it dies here."});
312     \}
313 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 13


\index{ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}!Register\+Protocol\+Handler@{Register\+Protocol\+Handler}}
\index{Register\+Protocol\+Handler@{Register\+Protocol\+Handler}!ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}}
\subsubsection[{\texorpdfstring{Register\+Protocol\+Handler(\+Node\+::\+Protocol\+Handler handler, uint16\+\_\+t protocol\+Type, Ptr$<$ Net\+Device $>$ device)}{RegisterProtocolHandler(Node::ProtocolHandler handler, uint16_t protocolType, Ptr< NetDevice > device)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Traffic\+Control\+Layer\+::\+Register\+Protocol\+Handler (
\begin{DoxyParamCaption}
\item[{{\bf Node\+::\+Protocol\+Handler}}]{handler, }
\item[{uint16\+\_\+t}]{protocol\+Type, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{device}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TrafficControlLayer_af1aa1791591898efe876969ab78f4a9b}{}\label{classns3_1_1TrafficControlLayer_af1aa1791591898efe876969ab78f4a9b}


Register an IN handler. 

The handler will be invoked when a packet is received to pass it to upper layers.


\begin{DoxyParams}{Parameters}
{\em handler} & the handler to register \\
\hline
{\em protocol\+Type} & the type of protocol this handler is interested in. This protocol type is a so-\/called Ether\+Type, as registered here\+: \href{http://standards.ieee.org/regauth/ethertype/eth.txt}{\tt http\+://standards.\+ieee.\+org/regauth/ethertype/eth.\+txt} the value zero is interpreted as matching all protocols. \\
\hline
{\em device} & the device attached to this handler. If the value is zero, the handler is attached to all devices. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
176 \{
177   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << protocolType << device);
178 
179   \textcolor{keyword}{struct }ProtocolHandlerEntry entry;
180   entry.handler = handler;
181   entry.protocol = protocolType;
182   entry.device = device;
183   entry.promiscuous = \textcolor{keyword}{false};
184 
185   \hyperlink{classns3_1_1TrafficControlLayer_a598f6f4d4efa5e776abfe6c0c3af65fa}{m\_handlers}.push\_back (entry);
186 
187   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Handler for NetDevice: "} << device << \textcolor{stringliteral}{" registered for protocol "} <<
188                 protocolType << \textcolor{stringliteral}{"."});
189 \}
\end{DoxyCode}
\index{ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}!Send@{Send}}
\index{Send@{Send}!ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}}
\subsubsection[{\texorpdfstring{Send(\+Ptr$<$ Net\+Device $>$ device, Ptr$<$ Queue\+Disc\+Item $>$ item)}{Send(Ptr< NetDevice > device, Ptr< QueueDiscItem > item)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Traffic\+Control\+Layer\+::\+Send (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{device, }
\item[{{\bf Ptr}$<$ {\bf Queue\+Disc\+Item} $>$}]{item}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TrafficControlLayer_aae45cb92c1adb038bac63d347632e627}{}\label{classns3_1_1TrafficControlLayer_aae45cb92c1adb038bac63d347632e627}


Called from upper layer to queue a packet for the transmission. 


\begin{DoxyParams}{Parameters}
{\em device} & the device the packet must be sent to \\
\hline
{\em item} & a queue item including a packet and additional information \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
317 \{
318   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << device << item);
319 
320   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Send packet to device "} << device << \textcolor{stringliteral}{" protocol number "} <<
321                 item->GetProtocol ());
322 
323   std::map<Ptr<NetDevice>, NetDeviceInfo>::iterator ndi = \hyperlink{classns3_1_1TrafficControlLayer_a78320d2a2610f730984ca796ed51a495}{m\_netDevices}.find (device);
324   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (ndi != \hyperlink{classns3_1_1TrafficControlLayer_a78320d2a2610f730984ca796ed51a495}{m\_netDevices}.end ());
325   Ptr<NetDeviceQueueInterface> devQueueIface = ndi->second.m\_ndqi;
326   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (devQueueIface);
327 
328   \textcolor{comment}{// determine the transmission queue of the device where the packet will be enqueued}
329   uint8\_t txq = 0;
330   \textcolor{keywordflow}{if} (devQueueIface->GetNTxQueues () > 1)
331     \{
332       \textcolor{keywordflow}{if} (!ndi->second.m\_selectQueueCallback.IsNull ())
333         \{
334           txq = ndi->second.m\_selectQueueCallback (item);
335         \}
336       \textcolor{comment}{// otherwise, Linux determines the queue index by using a hash function}
337       \textcolor{comment}{// and associates such index to the socket which the packet belongs to,}
338       \textcolor{comment}{// so that subsequent packets of the same socket will be mapped to the}
339       \textcolor{comment}{// same tx queue (\_\_netdev\_pick\_tx function in net/core/dev.c). It is}
340       \textcolor{comment}{// pointless to implement this in ns-3 because currently the multi-queue}
341       \textcolor{comment}{// devices provide a select queue callback}
342     \}
343 
344   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (txq < devQueueIface->GetNTxQueues ());
345 
346   \textcolor{keywordflow}{if} (ndi->second.m\_rootQueueDisc == 0)
347     \{
348       \textcolor{comment}{// The device has no attached queue disc, thus add the header to the packet and}
349       \textcolor{comment}{// send it directly to the device if the selected queue is not stopped}
350       \textcolor{keywordflow}{if} (!devQueueIface->GetTxQueue (txq)->IsStopped ())
351         \{
352           item->AddHeader ();
353           \textcolor{comment}{// a single queue device makes no use of the priority tag}
354           \textcolor{keywordflow}{if} (devQueueIface->GetNTxQueues () == 1)
355             \{
356               SocketPriorityTag priorityTag;
357               item->GetPacket ()->RemovePacketTag (priorityTag);
358             \}
359           device->Send (item->GetPacket (), item->GetAddress (), item->GetProtocol ());
360         \}
361     \}
362   \textcolor{keywordflow}{else}
363     \{
364       \textcolor{comment}{// Enqueue the packet in the queue disc associated with the netdevice queue}
365       \textcolor{comment}{// selected for the packet and try to dequeue packets from such queue disc}
366       item->SetTxQueueIndex (txq);
367 
368       Ptr<QueueDisc> qDisc = ndi->second.m\_queueDiscsToWake[txq];
369       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (qDisc);
370       qDisc->Enqueue (item);
371       qDisc->Run ();
372     \}
373 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 14


\index{ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}!Set\+Node@{Set\+Node}}
\index{Set\+Node@{Set\+Node}!ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}}
\subsubsection[{\texorpdfstring{Set\+Node(\+Ptr$<$ Node $>$ node)}{SetNode(Ptr< Node > node)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Traffic\+Control\+Layer\+::\+Set\+Node (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1TrafficControlLayer_ab2ceb8b90b3418c201f9ecd0ed0c5467}{}\label{classns3_1_1TrafficControlLayer_ab2ceb8b90b3418c201f9ecd0ed0c5467}


Set node associated with this stack. 


\begin{DoxyParams}{Parameters}
{\em node} & node to set \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
252 \{
253   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << node);
254   \hyperlink{classns3_1_1TrafficControlLayer_a6892507af633ef1fb7e1e0a50b54f0f2}{m\_node} = node;
255 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 15


\index{ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}!Set\+Root\+Queue\+Disc\+On\+Device@{Set\+Root\+Queue\+Disc\+On\+Device}}
\index{Set\+Root\+Queue\+Disc\+On\+Device@{Set\+Root\+Queue\+Disc\+On\+Device}!ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}}
\subsubsection[{\texorpdfstring{Set\+Root\+Queue\+Disc\+On\+Device(\+Ptr$<$ Net\+Device $>$ device, Ptr$<$ Queue\+Disc $>$ q\+Disc)}{SetRootQueueDiscOnDevice(Ptr< NetDevice > device, Ptr< QueueDisc > qDisc)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Traffic\+Control\+Layer\+::\+Set\+Root\+Queue\+Disc\+On\+Device (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{device, }
\item[{{\bf Ptr}$<$ {\bf Queue\+Disc} $>$}]{q\+Disc}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TrafficControlLayer_ae44f2ceeba57ab2628cdda8c0c9e12fc}{}\label{classns3_1_1TrafficControlLayer_ae44f2ceeba57ab2628cdda8c0c9e12fc}


This method can be used to set the root queue disc installed on a device. 


\begin{DoxyParams}{Parameters}
{\em device} & the device on which the provided queue disc will be installed \\
\hline
{\em q\+Disc} & the queue disc to be installed as root queue disc on device \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
193 \{
194   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << device << qDisc);
195 
196   std::map<Ptr<NetDevice>, NetDeviceInfo>::iterator ndi = \hyperlink{classns3_1_1TrafficControlLayer_a78320d2a2610f730984ca796ed51a495}{m\_netDevices}.find (device);
197 
198   \textcolor{keywordflow}{if} (ndi == \hyperlink{classns3_1_1TrafficControlLayer_a78320d2a2610f730984ca796ed51a495}{m\_netDevices}.end ())
199     \{
200       \textcolor{comment}{// SetupDevice has not been called yet. This may happen when the tc helper is}
201       \textcolor{comment}{// invoked (to install a queue disc) before the creation of the Ipv\{4,6\}Interface.}
202       \textcolor{comment}{// Since queue discs require that a netdevice queue interface is aggregated}
203       \textcolor{comment}{// to the device, call SetupDevice}
204       \hyperlink{classns3_1_1TrafficControlLayer_ac60c5208106f39f7ad25082083ed48a0}{SetupDevice} (device);
205       ndi = \hyperlink{classns3_1_1TrafficControlLayer_a78320d2a2610f730984ca796ed51a495}{m\_netDevices}.find (device);
206       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (ndi != \hyperlink{classns3_1_1TrafficControlLayer_a78320d2a2610f730984ca796ed51a495}{m\_netDevices}.end ());
207     \}
208 
209   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (ndi->second.m\_rootQueueDisc == 0, \textcolor{stringliteral}{"Cannot install a root queue disc on a "}
210                   << \textcolor{stringliteral}{"device already having one. Delete the existing queue disc first."});
211   ndi->second.m\_rootQueueDisc = qDisc;
212 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 16


\index{ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}!Setup\+Device@{Setup\+Device}}
\index{Setup\+Device@{Setup\+Device}!ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}}
\subsubsection[{\texorpdfstring{Setup\+Device(\+Ptr$<$ Net\+Device $>$ device)}{SetupDevice(Ptr< NetDevice > device)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Traffic\+Control\+Layer\+::\+Setup\+Device (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{device}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1TrafficControlLayer_ac60c5208106f39f7ad25082083ed48a0}{}\label{classns3_1_1TrafficControlLayer_ac60c5208106f39f7ad25082083ed48a0}


Perform the operations that the traffic control layer needs to do when an I\+Pv4/v6 interface is added to a device. 


\begin{DoxyParams}{Parameters}
{\em device} & the device which the I\+Pv4/v6 interface has been added to\\
\hline
\end{DoxyParams}
This method creates a \hyperlink{classns3_1_1NetDeviceQueueInterface}{Net\+Device\+Queue\+Interface} for the device 
\begin{DoxyCode}
136 \{
137   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << device);
138 
139   \textcolor{comment}{// ensure this setup is done just once. SetupDevice is called by Ipv4L3Protocol}
140   \textcolor{comment}{// and Ipv6L3Protocol when they add an interface, thus it might be called twice}
141   \textcolor{comment}{// in case of dual stack nodes. Also, SetupDevice might be called twice if the}
142   \textcolor{comment}{// tc helper is invoked (to install a queue disc) before the creation of the}
143   \textcolor{comment}{// Ipv\{4,6\}Interface, since SetRootQueueDiscOnDevice calls SetupDevice}
144   \textcolor{keywordflow}{if} (device->GetObject<NetDeviceQueueInterface> ())
145     \{
146       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The setup for this device has been already done."});
147       \textcolor{keywordflow}{return};
148     \}
149 
150   \textcolor{comment}{// create a NetDeviceQueueInterface object and aggregate it to the device}
151   Ptr<NetDeviceQueueInterface> devQueueIface = CreateObject<NetDeviceQueueInterface> ();
152   device->AggregateObject (devQueueIface);
153 
154   \textcolor{comment}{// Create the TX queues if the device has not done so and has not set the}
155   \textcolor{comment}{// late TX queues creation flag in the NotifyNewAggregate method}
156   \textcolor{keywordflow}{if} (devQueueIface->GetNTxQueues () == 0 && !devQueueIface->GetLateTxQueuesCreation ())
157     \{
158       devQueueIface->CreateTxQueues ();
159     \}
160 
161   \textcolor{comment}{// devices can set a select queue callback in their NotifyNewAggregate method}
162   \hyperlink{classns3_1_1TrafficControlLayer_aac192f903f140af92ca59a2d91a4c0cb}{SelectQueueCallback} cb = devQueueIface->GetSelectQueueCallback ();
163 
164   \textcolor{comment}{// create an entry in the m\_netDevices map for this device}
165   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\hyperlink{classns3_1_1TrafficControlLayer_a78320d2a2610f730984ca796ed51a495}{m\_netDevices}.find (device) == 
      \hyperlink{classns3_1_1TrafficControlLayer_a78320d2a2610f730984ca796ed51a495}{m\_netDevices}.end (), \textcolor{stringliteral}{"This is a bug,"}
166                  << \textcolor{stringliteral}{"  SetupDevice only can insert an entry in the m\_netDevices map"});
167 
168   \hyperlink{classns3_1_1TrafficControlLayer_a78320d2a2610f730984ca796ed51a495}{m\_netDevices}.emplace (std::piecewise\_construct,
169                         std::forward\_as\_tuple (device),
170                         std::forward\_as\_tuple ((Ptr<QueueDisc>) 0, devQueueIface, 
      \hyperlink{classns3_1_1TrafficControlLayer_a9c468db4727d64733d7dba66d2791edf}{QueueDiscVector} (), cb));
171 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 17




\subsection{Member Data Documentation}
\index{ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}!m\+\_\+handlers@{m\+\_\+handlers}}
\index{m\+\_\+handlers@{m\+\_\+handlers}!ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}}
\subsubsection[{\texorpdfstring{m\+\_\+handlers}{m_handlers}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Protocol\+Handler\+List} ns3\+::\+Traffic\+Control\+Layer\+::m\+\_\+handlers\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TrafficControlLayer_a598f6f4d4efa5e776abfe6c0c3af65fa}{}\label{classns3_1_1TrafficControlLayer_a598f6f4d4efa5e776abfe6c0c3af65fa}


List of upper-\/layer handlers. 

\index{ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}!m\+\_\+net\+Devices@{m\+\_\+net\+Devices}}
\index{m\+\_\+net\+Devices@{m\+\_\+net\+Devices}!ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}}
\subsubsection[{\texorpdfstring{m\+\_\+net\+Devices}{m_netDevices}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<${\bf Ptr}$<${\bf Net\+Device}$>$, {\bf Net\+Device\+Info}$>$ ns3\+::\+Traffic\+Control\+Layer\+::m\+\_\+net\+Devices\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TrafficControlLayer_a78320d2a2610f730984ca796ed51a495}{}\label{classns3_1_1TrafficControlLayer_a78320d2a2610f730984ca796ed51a495}


Map storing the required information for each device with a queue disc installed. 

\index{ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}!m\+\_\+node@{m\+\_\+node}}
\index{m\+\_\+node@{m\+\_\+node}!ns3\+::\+Traffic\+Control\+Layer@{ns3\+::\+Traffic\+Control\+Layer}}
\subsubsection[{\texorpdfstring{m\+\_\+node}{m_node}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Node}$>$ ns3\+::\+Traffic\+Control\+Layer\+::m\+\_\+node\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1TrafficControlLayer_a6892507af633ef1fb7e1e0a50b54f0f2}{}\label{classns3_1_1TrafficControlLayer_a6892507af633ef1fb7e1e0a50b54f0f2}


The node this \hyperlink{classns3_1_1TrafficControlLayer}{Traffic\+Control\+Layer} object is aggregated to. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
traffic-\/control/model/\hyperlink{traffic-control-layer_8h}{traffic-\/control-\/layer.\+h}\item 
traffic-\/control/model/\hyperlink{traffic-control-layer_8cc}{traffic-\/control-\/layer.\+cc}\end{DoxyCompactItemize}
