\hypertarget{classns3_1_1PppHeader}{}\section{ns3\+:\+:Ppp\+Header Class Reference}
\label{classns3_1_1PppHeader}\index{ns3\+::\+Ppp\+Header@{ns3\+::\+Ppp\+Header}}


\hyperlink{classns3_1_1Packet}{Packet} header for P\+PP.  




{\ttfamily \#include $<$ppp-\/header.\+h$>$}



Inheritance diagram for ns3\+:\+:Ppp\+Header\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Ppp\+Header\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1PppHeader_ae75ebcd92f5f19e6211489fffa2834be}{Ppp\+Header} ()
\begin{DoxyCompactList}\small\item\em Construct a P\+PP header. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1PppHeader_ab1a0401bc3ccda1669b8709a854d8e73}{$\sim$\+Ppp\+Header} ()
\begin{DoxyCompactList}\small\item\em Destroy a P\+PP header. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1PppHeader_aeb3082cf924a1ec4d0e6e21d39469a18}{Get\+Instance\+Type\+Id} (void) const 
\begin{DoxyCompactList}\small\item\em Get the \hyperlink{classns3_1_1TypeId}{Type\+Id} of the instance. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1PppHeader_a294af9ecf627de349d1fd14d758f7efa}{Print} (std\+::ostream \&os) const 
\item 
virtual void \hyperlink{classns3_1_1PppHeader_afb1858c81a6644b5a99f0153e10155fc}{Serialize} (\hyperlink{classns3_1_1Buffer_1_1Iterator}{Buffer\+::\+Iterator} start) const 
\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1PppHeader_af092f637bd2ffb1f1b0481f6f2b8f793}{Deserialize} (\hyperlink{classns3_1_1Buffer_1_1Iterator}{Buffer\+::\+Iterator} start)
\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1PppHeader_a87c59c8e4926f5dfa6e3f8baa23f0218}{Get\+Serialized\+Size} (void) const 
\item 
void \hyperlink{classns3_1_1PppHeader_a3490d0fa6baca9b89f9e61cd8d0ed115}{Set\+Protocol} (uint16\+\_\+t protocol)
\begin{DoxyCompactList}\small\item\em Set the protocol type carried by this P\+PP packet. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1PppHeader_aa5cfc64ff43c2b6b4a5cc671e9340059}{Get\+Protocol} (void)
\begin{DoxyCompactList}\small\item\em Get the protocol type carried by this P\+PP packet. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1PppHeader_aae5f8fd63778b282eef4dac266d12ea2}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the \hyperlink{classns3_1_1TypeId}{Type\+Id}. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
uint16\+\_\+t \hyperlink{classns3_1_1PppHeader_a0d24ff8e3b289a1af3f0311a2f7f4deb}{m\+\_\+protocol}
\begin{DoxyCompactList}\small\item\em The P\+PP protocol type of the payload packet. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
\hyperlink{classns3_1_1Packet}{Packet} header for P\+PP. 

This class can be used to add a header to P\+PP packet. Currently we do not implement any of the state machine in \{1661\}, we just encapsulate the inbound packet send it on. The goal here is not really to implement the point-\/to-\/point protocol, but to encapsulate our packets in a known protocol so packet sniffers can parse them.

if P\+PP is transmitted over a serial link, it will typically be framed in some way derivative of I\+BM S\+D\+LC (H\+D\+LC) with all that that entails. Thankfully, we don\textquotesingle{}t have to deal with all of that -- we can use our own protocol for getting bits across the serial link which we call an \hyperlink{namespacens3}{ns3} \hyperlink{classns3_1_1Packet}{Packet}. What we do have to worry about is being able to capture P\+PP frames which are understandable by Wireshark. All this means is that we need to teach the Pcap\+Writer about the appropriate data link type (D\+L\+T\+\_\+\+P\+PP = 9), and we need to add a P\+PP header to each packet. Since we are not using framed P\+PP, this just means prepending the sixteen bit P\+PP protocol number to the packet. The ns-\/3 way to do this is via a class that inherits from class \hyperlink{classns3_1_1Header}{Header}. 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Ppp\+Header@{ns3\+::\+Ppp\+Header}!Ppp\+Header@{Ppp\+Header}}
\index{Ppp\+Header@{Ppp\+Header}!ns3\+::\+Ppp\+Header@{ns3\+::\+Ppp\+Header}}
\subsubsection[{\texorpdfstring{Ppp\+Header()}{PppHeader()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ppp\+Header\+::\+Ppp\+Header (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PppHeader_ae75ebcd92f5f19e6211489fffa2834be}{}\label{classns3_1_1PppHeader_ae75ebcd92f5f19e6211489fffa2834be}


Construct a P\+PP header. 


\begin{DoxyCode}
33 \{
34 \}
\end{DoxyCode}
\index{ns3\+::\+Ppp\+Header@{ns3\+::\+Ppp\+Header}!````~Ppp\+Header@{$\sim$\+Ppp\+Header}}
\index{````~Ppp\+Header@{$\sim$\+Ppp\+Header}!ns3\+::\+Ppp\+Header@{ns3\+::\+Ppp\+Header}}
\subsubsection[{\texorpdfstring{$\sim$\+Ppp\+Header()}{~PppHeader()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ppp\+Header\+::$\sim$\+Ppp\+Header (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1PppHeader_ab1a0401bc3ccda1669b8709a854d8e73}{}\label{classns3_1_1PppHeader_ab1a0401bc3ccda1669b8709a854d8e73}


Destroy a P\+PP header. 


\begin{DoxyCode}
37 \{
38 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Ppp\+Header@{ns3\+::\+Ppp\+Header}!Deserialize@{Deserialize}}
\index{Deserialize@{Deserialize}!ns3\+::\+Ppp\+Header@{ns3\+::\+Ppp\+Header}}
\subsubsection[{\texorpdfstring{Deserialize(\+Buffer\+::\+Iterator start)}{Deserialize(Buffer::Iterator start)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Ppp\+Header\+::\+Deserialize (
\begin{DoxyParamCaption}
\item[{{\bf Buffer\+::\+Iterator}}]{start}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1PppHeader_af092f637bd2ffb1f1b0481f6f2b8f793}{}\label{classns3_1_1PppHeader_af092f637bd2ffb1f1b0481f6f2b8f793}

\begin{DoxyParams}{Parameters}
{\em start} & an iterator which points to where the header should read from. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of bytes read.
\end{DoxyReturn}
This method is used by \hyperlink{classns3_1_1Packet_a0961eccf975d75f902d40956c93ba63e}{Packet\+::\+Remove\+Header} to re-\/create a header from the byte buffer of a packet. The data read is expected to match bit-\/for-\/bit the representation of this header in real networks.

Note that data is not actually removed from the buffer to which the iterator points. Both \hyperlink{classns3_1_1Packet_a0961eccf975d75f902d40956c93ba63e}{Packet\+::\+Remove\+Header()} and \hyperlink{classns3_1_1Packet_aadc63487bea70945c418f4c3e9b81964}{Packet\+::\+Peek\+Header()} call \hyperlink{classns3_1_1PppHeader_af092f637bd2ffb1f1b0481f6f2b8f793}{Deserialize()}, but only the Remove\+Header() has additional statements to remove the header bytes from the underlying buffer and associated metadata. 

Implements \hyperlink{classns3_1_1Header_a78be9400bb66b2a8543606f395ef5396}{ns3\+::\+Header}.


\begin{DoxyCode}
90 \{
91   \hyperlink{classns3_1_1PppHeader_a0d24ff8e3b289a1af3f0311a2f7f4deb}{m\_protocol} = \hyperlink{namespacevisualizer_1_1core_a2a35e5d8a34af358b508dac8635754e0}{start}.ReadNtohU16 ();
92   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1PppHeader_a87c59c8e4926f5dfa6e3f8baa23f0218}{GetSerializedSize} ();
93 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Ppp\+Header@{ns3\+::\+Ppp\+Header}!Get\+Instance\+Type\+Id@{Get\+Instance\+Type\+Id}}
\index{Get\+Instance\+Type\+Id@{Get\+Instance\+Type\+Id}!ns3\+::\+Ppp\+Header@{ns3\+::\+Ppp\+Header}}
\subsubsection[{\texorpdfstring{Get\+Instance\+Type\+Id(void) const }{GetInstanceTypeId(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Ppp\+Header\+::\+Get\+Instance\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1PppHeader_aeb3082cf924a1ec4d0e6e21d39469a18}{}\label{classns3_1_1PppHeader_aeb3082cf924a1ec4d0e6e21d39469a18}


Get the \hyperlink{classns3_1_1TypeId}{Type\+Id} of the instance. 

\begin{DoxyReturn}{Returns}
The \hyperlink{classns3_1_1TypeId}{Type\+Id} for this instance 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1ObjectBase_abe5b43a6f5b99a92a4c3122db31f06fb}{ns3\+::\+Object\+Base}.


\begin{DoxyCode}
53 \{
54   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1PppHeader_aae5f8fd63778b282eef4dac266d12ea2}{GetTypeId} ();
55 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::\+Ppp\+Header@{ns3\+::\+Ppp\+Header}!Get\+Protocol@{Get\+Protocol}}
\index{Get\+Protocol@{Get\+Protocol}!ns3\+::\+Ppp\+Header@{ns3\+::\+Ppp\+Header}}
\subsubsection[{\texorpdfstring{Get\+Protocol(void)}{GetProtocol(void)}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Ppp\+Header\+::\+Get\+Protocol (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PppHeader_aa5cfc64ff43c2b6b4a5cc671e9340059}{}\label{classns3_1_1PppHeader_aa5cfc64ff43c2b6b4a5cc671e9340059}


Get the protocol type carried by this P\+PP packet. 

The type numbers to be used are defined in \{3818\}

\begin{DoxyReturn}{Returns}
the protocol type being carried 
\end{DoxyReturn}

\begin{DoxyCode}
103 \{
104   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1PppHeader_a0d24ff8e3b289a1af3f0311a2f7f4deb}{m\_protocol};
105 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::\+Ppp\+Header@{ns3\+::\+Ppp\+Header}!Get\+Serialized\+Size@{Get\+Serialized\+Size}}
\index{Get\+Serialized\+Size@{Get\+Serialized\+Size}!ns3\+::\+Ppp\+Header@{ns3\+::\+Ppp\+Header}}
\subsubsection[{\texorpdfstring{Get\+Serialized\+Size(void) const }{GetSerializedSize(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Ppp\+Header\+::\+Get\+Serialized\+Size (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1PppHeader_a87c59c8e4926f5dfa6e3f8baa23f0218}{}\label{classns3_1_1PppHeader_a87c59c8e4926f5dfa6e3f8baa23f0218}
\begin{DoxyReturn}{Returns}
the expected size of the header.
\end{DoxyReturn}
This method is used by \hyperlink{classns3_1_1Packet_a465108c595a0bc592095cbcab1832ed8}{Packet\+::\+Add\+Header} to store a header into the byte buffer of a packet. This method should return the number of bytes which are needed to store the full header data by Serialize. 

Implements \hyperlink{classns3_1_1Header_a6ef0497eabc1b1fb0ad42738eb73f934}{ns3\+::\+Header}.


\begin{DoxyCode}
78 \{
79   \textcolor{keywordflow}{return} 2;
80 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Ppp\+Header@{ns3\+::\+Ppp\+Header}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Ppp\+Header@{ns3\+::\+Ppp\+Header}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Ppp\+Header\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1PppHeader_aae5f8fd63778b282eef4dac266d12ea2}{}\label{classns3_1_1PppHeader_aae5f8fd63778b282eef4dac266d12ea2}


Get the \hyperlink{classns3_1_1TypeId}{Type\+Id}. 

\begin{DoxyReturn}{Returns}
The \hyperlink{classns3_1_1TypeId}{Type\+Id} for this class 
\end{DoxyReturn}

\begin{DoxyCode}
42 \{
43   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::PppHeader"})
44     .SetParent<Header> ()
45     .SetGroupName (\textcolor{stringliteral}{"PointToPoint"})
46     .AddConstructor<\hyperlink{classns3_1_1PppHeader_ae75ebcd92f5f19e6211489fffa2834be}{PppHeader}> ()
47   ;
48   \textcolor{keywordflow}{return} tid;
49 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6




Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Ppp\+Header@{ns3\+::\+Ppp\+Header}!Print@{Print}}
\index{Print@{Print}!ns3\+::\+Ppp\+Header@{ns3\+::\+Ppp\+Header}}
\subsubsection[{\texorpdfstring{Print(std\+::ostream \&os) const }{Print(std::ostream &os) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ppp\+Header\+::\+Print (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1PppHeader_a294af9ecf627de349d1fd14d758f7efa}{}\label{classns3_1_1PppHeader_a294af9ecf627de349d1fd14d758f7efa}

\begin{DoxyParams}{Parameters}
{\em os} & output stream This method is used by \hyperlink{classns3_1_1Packet_aa34058a5cdbf94673531f8c4001ab227}{Packet\+::\+Print} to print the content of a header as ascii data to a c++ output stream. Although the header is free to format its output as it wishes, it is recommended to follow a few rules to integrate with the packet pretty printer\+: start with flags, small field values located between a pair of parens. Values should be separated by whitespace. Follow the parens with the important fields, separated by whitespace. i.\+e.\+: (field1 val1 field2 val2 field3 val3) field4 val4 field5 val5 \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Header_a2ce1df7579b2ade7bc7302357feac77a}{ns3\+::\+Header}.


\begin{DoxyCode}
59 \{
60   std::string proto;
61 
62   \textcolor{keywordflow}{switch}(\hyperlink{classns3_1_1PppHeader_a0d24ff8e3b289a1af3f0311a2f7f4deb}{m\_protocol})
63     \{
64     \textcolor{keywordflow}{case} 0x0021: \textcolor{comment}{/* IPv4 */}
65       proto = \textcolor{stringliteral}{"IP (0x0021)"};
66       \textcolor{keywordflow}{break};
67     \textcolor{keywordflow}{case} 0x0057: \textcolor{comment}{/* IPv6 */}
68       proto = \textcolor{stringliteral}{"IPv6 (0x0057)"};
69       \textcolor{keywordflow}{break};
70     \textcolor{keywordflow}{default}:
71       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\textcolor{keyword}{false}, \textcolor{stringliteral}{"PPP Protocol number not defined!"});
72     \}
73   os << \textcolor{stringliteral}{"Point-to-Point Protocol: "} << proto; 
74 \}
\end{DoxyCode}
\index{ns3\+::\+Ppp\+Header@{ns3\+::\+Ppp\+Header}!Serialize@{Serialize}}
\index{Serialize@{Serialize}!ns3\+::\+Ppp\+Header@{ns3\+::\+Ppp\+Header}}
\subsubsection[{\texorpdfstring{Serialize(\+Buffer\+::\+Iterator start) const }{Serialize(Buffer::Iterator start) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ppp\+Header\+::\+Serialize (
\begin{DoxyParamCaption}
\item[{{\bf Buffer\+::\+Iterator}}]{start}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1PppHeader_afb1858c81a6644b5a99f0153e10155fc}{}\label{classns3_1_1PppHeader_afb1858c81a6644b5a99f0153e10155fc}

\begin{DoxyParams}{Parameters}
{\em start} & an iterator which points to where the header should be written.\\
\hline
\end{DoxyParams}
This method is used by \hyperlink{classns3_1_1Packet_a465108c595a0bc592095cbcab1832ed8}{Packet\+::\+Add\+Header} to store a header into the byte buffer of a packet. The data written is expected to match bit-\/for-\/bit the representation of this header in a real network. 

Implements \hyperlink{classns3_1_1Header_afb61f1aac69ff8349a6bfe521fab5404}{ns3\+::\+Header}.


\begin{DoxyCode}
84 \{
85   \hyperlink{namespacevisualizer_1_1core_a2a35e5d8a34af358b508dac8635754e0}{start}.WriteHtonU16 (\hyperlink{classns3_1_1PppHeader_a0d24ff8e3b289a1af3f0311a2f7f4deb}{m\_protocol});
86 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8


\index{ns3\+::\+Ppp\+Header@{ns3\+::\+Ppp\+Header}!Set\+Protocol@{Set\+Protocol}}
\index{Set\+Protocol@{Set\+Protocol}!ns3\+::\+Ppp\+Header@{ns3\+::\+Ppp\+Header}}
\subsubsection[{\texorpdfstring{Set\+Protocol(uint16\+\_\+t protocol)}{SetProtocol(uint16_t protocol)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ppp\+Header\+::\+Set\+Protocol (
\begin{DoxyParamCaption}
\item[{uint16\+\_\+t}]{protocol}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PppHeader_a3490d0fa6baca9b89f9e61cd8d0ed115}{}\label{classns3_1_1PppHeader_a3490d0fa6baca9b89f9e61cd8d0ed115}


Set the protocol type carried by this P\+PP packet. 

The type numbers to be used are defined in \{3818\}


\begin{DoxyParams}{Parameters}
{\em protocol} & the protocol type being carried \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
97 \{
98   \hyperlink{classns3_1_1PppHeader_a0d24ff8e3b289a1af3f0311a2f7f4deb}{m\_protocol}=protocol;
99 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 9




\subsection{Member Data Documentation}
\index{ns3\+::\+Ppp\+Header@{ns3\+::\+Ppp\+Header}!m\+\_\+protocol@{m\+\_\+protocol}}
\index{m\+\_\+protocol@{m\+\_\+protocol}!ns3\+::\+Ppp\+Header@{ns3\+::\+Ppp\+Header}}
\subsubsection[{\texorpdfstring{m\+\_\+protocol}{m_protocol}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Ppp\+Header\+::m\+\_\+protocol\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PppHeader_a0d24ff8e3b289a1af3f0311a2f7f4deb}{}\label{classns3_1_1PppHeader_a0d24ff8e3b289a1af3f0311a2f7f4deb}


The P\+PP protocol type of the payload packet. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
point-\/to-\/point/model/\hyperlink{ppp-header_8h}{ppp-\/header.\+h}\item 
point-\/to-\/point/model/\hyperlink{ppp-header_8cc}{ppp-\/header.\+cc}\end{DoxyCompactItemize}
