\hypertarget{classns3_1_1LoopbackNetDevice}{}\section{ns3\+:\+:Loopback\+Net\+Device Class Reference}
\label{classns3_1_1LoopbackNetDevice}\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}


Virtual network interface that loops back any data sent to it to be immediately received on the same interface.  




{\ttfamily \#include $<$loopback-\/net-\/device.\+h$>$}



Inheritance diagram for ns3\+:\+:Loopback\+Net\+Device\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Loopback\+Net\+Device\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1LoopbackNetDevice_aa0ff9e728fe8a9acafc8f56ffaf9cbea}{Loopback\+Net\+Device} ()
\item 
virtual void \hyperlink{classns3_1_1LoopbackNetDevice_a35aa739d7e48b0d0f574a0846aa2c8fa}{Set\+If\+Index} (const uint32\+\_\+t index)
\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1LoopbackNetDevice_a0e85f4b59c8ced3a2b69609f91fcd64d}{Get\+If\+Index} (void) const 
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Channel}{Channel} $>$ \hyperlink{classns3_1_1LoopbackNetDevice_a1e9d74faf50c64a390693bec6c916a57}{Get\+Channel} (void) const 
\item 
virtual void \hyperlink{classns3_1_1LoopbackNetDevice_ae194813879ce85bec09ba22501decb7e}{Set\+Address} (\hyperlink{classns3_1_1Address}{Address} address)
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1LoopbackNetDevice_a74de91df2349ac83f227760aee230083}{Get\+Address} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1LoopbackNetDevice_a0c401b78801c1e41d7fb15e708787438}{Set\+Mtu} (const uint16\+\_\+t mtu)
\item 
virtual uint16\+\_\+t \hyperlink{classns3_1_1LoopbackNetDevice_a557a8a3d4f69e50678842028480ada36}{Get\+Mtu} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1LoopbackNetDevice_a109ee470b78b34b42734ada81e28aea7}{Is\+Link\+Up} (void) const 
\item 
virtual void \hyperlink{classns3_1_1LoopbackNetDevice_a9252996d4ca666705fb334c9a664e5fd}{Add\+Link\+Change\+Callback} (\hyperlink{classns3_1_1Callback}{Callback}$<$ void $>$ callback)
\item 
virtual bool \hyperlink{classns3_1_1LoopbackNetDevice_a63c4ce91fb02fc9a9dcd451d183e3bba}{Is\+Broadcast} (void) const 
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1LoopbackNetDevice_a5016750dde40db94bddb53640313a239}{Get\+Broadcast} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1LoopbackNetDevice_a889c040c2e85a29fdebb00ebba1854ed}{Is\+Multicast} (void) const 
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1LoopbackNetDevice_acdc5982949f02ac8e98c6859b3fed58a}{Get\+Multicast} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} multicast\+Group) const 
\begin{DoxyCompactList}\small\item\em Make and return a M\+AC multicast address using the provided multicast group. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1LoopbackNetDevice_ae8649da600c4a937db48e259965e448d}{Is\+Point\+To\+Point} (void) const 
\begin{DoxyCompactList}\small\item\em Return true if the net device is on a point-\/to-\/point link. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1LoopbackNetDevice_acd2007b4b31b0bb284ecca76df83dfe4}{Is\+Bridge} (void) const 
\begin{DoxyCompactList}\small\item\em Return true if the net device is acting as a bridge. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1LoopbackNetDevice_add41fe2884d42456ea019337bfa88c37}{Send} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, const \hyperlink{classns3_1_1Address}{Address} \&dest, uint16\+\_\+t protocol\+Number)
\item 
virtual bool \hyperlink{classns3_1_1LoopbackNetDevice_a95f0043ce01d85a65cf08cb6495886e0}{Send\+From} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, const \hyperlink{classns3_1_1Address}{Address} \&source, const \hyperlink{classns3_1_1Address}{Address} \&dest, uint16\+\_\+t protocol\+Number)
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1LoopbackNetDevice_a95df57dcc2755a4b29af1925ed0f9c5b}{Get\+Node} (void) const 
\item 
virtual void \hyperlink{classns3_1_1LoopbackNetDevice_aee8ac2bb101b3489a1f3dd1682bdf3c2}{Set\+Node} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node)
\item 
virtual bool \hyperlink{classns3_1_1LoopbackNetDevice_af7c8b1f612bb78aed183080ab1e65cae}{Needs\+Arp} (void) const 
\item 
virtual void \hyperlink{classns3_1_1LoopbackNetDevice_ab628a992340b0530c0777d048b84ee0f}{Set\+Receive\+Callback} (\hyperlink{classns3_1_1NetDevice_ad5e5e1ca187472bc2ba99575d8def568}{Net\+Device\+::\+Receive\+Callback} cb)
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1LoopbackNetDevice_a5533dda5ad3085b3597aca7d9b05ab38}{Get\+Multicast} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} addr) const 
\begin{DoxyCompactList}\small\item\em Get the M\+AC multicast address corresponding to the I\+Pv6 address provided. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1LoopbackNetDevice_a789063a46797d9c03d7abeb24f0891b1}{Set\+Promisc\+Receive\+Callback} (\hyperlink{classns3_1_1NetDevice_a427225795919f26c414bee2ea3f31ed2}{Promisc\+Receive\+Callback} cb)
\item 
virtual bool \hyperlink{classns3_1_1LoopbackNetDevice_a7dc18fb68db1cf88cbad276cb674083d}{Supports\+Send\+From} (void) const 
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1LoopbackNetDevice_a93128f30064bc62b6b8806c8584de160}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1LoopbackNetDevice_ac2f5d5fbbf5c0f88550ea181b9107f34}{Do\+Dispose} (void)
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classns3_1_1LoopbackNetDevice_a2b5c5f64267ba906d149ab89d2831d34}{Receive} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, uint16\+\_\+t protocol, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} to, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} \hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from})
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1NetDevice_ad5e5e1ca187472bc2ba99575d8def568}{Net\+Device\+::\+Receive\+Callback} \hyperlink{classns3_1_1LoopbackNetDevice_a844fcc47c3dc1be07aed83c8ba70a7b0}{m\+\_\+rx\+Callback}
\item 
\hyperlink{classns3_1_1NetDevice_a427225795919f26c414bee2ea3f31ed2}{Net\+Device\+::\+Promisc\+Receive\+Callback} \hyperlink{classns3_1_1LoopbackNetDevice_ac18a33947e9703ed786c83448348414c}{m\+\_\+promisc\+Callback}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1LoopbackNetDevice_a5f1f7506494670806071ca51f717f297}{m\+\_\+node}
\begin{DoxyCompactList}\small\item\em the node this \hyperlink{classns3_1_1NetDevice}{Net\+Device} is associated with \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1LoopbackNetDevice_ac2cecc3794c627c237c1ab9d2eca91db}{m\+\_\+mtu}
\begin{DoxyCompactList}\small\item\em device M\+TU \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1LoopbackNetDevice_a223d24d108f8a9dfba19aeb64bd8cfbc}{m\+\_\+if\+Index}
\begin{DoxyCompactList}\small\item\em interface index \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} \hyperlink{classns3_1_1LoopbackNetDevice_a7d692338d3d7b73fd73f8b182af36d6b}{m\+\_\+address}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1NetDevice}{Net\+Device} M\+AC address. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Virtual network interface that loops back any data sent to it to be immediately received on the same interface. 

This \hyperlink{classns3_1_1NetDevice}{Net\+Device} is automatically added to any node as soon as the Internet stack is initialized. 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!Loopback\+Net\+Device@{Loopback\+Net\+Device}}
\index{Loopback\+Net\+Device@{Loopback\+Net\+Device}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{Loopback\+Net\+Device()}{LoopbackNetDevice()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Loopback\+Net\+Device\+::\+Loopback\+Net\+Device (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1LoopbackNetDevice_aa0ff9e728fe8a9acafc8f56ffaf9cbea}{}\label{classns3_1_1LoopbackNetDevice_aa0ff9e728fe8a9acafc8f56ffaf9cbea}

\begin{DoxyCode}
45   : \hyperlink{classns3_1_1LoopbackNetDevice_a5f1f7506494670806071ca51f717f297}{m\_node} (0),
46     \hyperlink{classns3_1_1LoopbackNetDevice_ac2cecc3794c627c237c1ab9d2eca91db}{m\_mtu} (0xffff),
47     \hyperlink{classns3_1_1LoopbackNetDevice_a223d24d108f8a9dfba19aeb64bd8cfbc}{m\_ifIndex} (0),
48     \hyperlink{classns3_1_1LoopbackNetDevice_a7d692338d3d7b73fd73f8b182af36d6b}{m\_address} (Mac48Address (\textcolor{stringliteral}{"00:00:00:00:00:00"}))
49 \{
50   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
51 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!Add\+Link\+Change\+Callback@{Add\+Link\+Change\+Callback}}
\index{Add\+Link\+Change\+Callback@{Add\+Link\+Change\+Callback}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{Add\+Link\+Change\+Callback(\+Callback$<$ void $>$ callback)}{AddLinkChangeCallback(Callback< void > callback)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Loopback\+Net\+Device\+::\+Add\+Link\+Change\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Callback}$<$ void $>$}]{callback}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1LoopbackNetDevice_a9252996d4ca666705fb334c9a664e5fd}{}\label{classns3_1_1LoopbackNetDevice_a9252996d4ca666705fb334c9a664e5fd}

\begin{DoxyParams}{Parameters}
{\em callback} & the callback to invoke\\
\hline
\end{DoxyParams}
Add a callback invoked whenever the link status changes to UP. This callback is typically used by the I\+P/\+A\+RP layer to flush the A\+RP cache and by I\+Pv6 stack to flush N\+D\+I\+SC cache whenever the link goes up. 

Implements \hyperlink{classns3_1_1NetDevice_aafb1bf869d38ef7a7112d11fab0163a3}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
133 \{\}
\end{DoxyCode}
\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{Do\+Dispose(void)}{DoDispose(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Loopback\+Net\+Device\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1LoopbackNetDevice_ac2f5d5fbbf5c0f88550ea181b9107f34}{}\label{classns3_1_1LoopbackNetDevice_ac2f5d5fbbf5c0f88550ea181b9107f34}
Destructor implementation.

This method is called by \hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose()} or by the \hyperlink{classns3_1_1Object}{Object}\textquotesingle{}s destructor, whichever comes first.

Subclasses are expected to implement their real destruction code in an overriden version of this method and chain up to their parent\textquotesingle{}s implementation once they are done. {\itshape i.\+e}, for simplicity, the destructor of every subclass should be empty and its content should be moved to the associated \hyperlink{classns3_1_1LoopbackNetDevice_ac2f5d5fbbf5c0f88550ea181b9107f34}{Do\+Dispose()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.


\begin{DoxyCode}
226 \{
227   \hyperlink{classns3_1_1LoopbackNetDevice_a5f1f7506494670806071ca51f717f297}{m\_node} = 0;
228   \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{NetDevice::DoDispose} ();
229 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!Get\+Address@{Get\+Address}}
\index{Get\+Address@{Get\+Address}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Address(void) const }{GetAddress(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Loopback\+Net\+Device\+::\+Get\+Address (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1LoopbackNetDevice_a74de91df2349ac83f227760aee230083}{}\label{classns3_1_1LoopbackNetDevice_a74de91df2349ac83f227760aee230083}
\begin{DoxyReturn}{Returns}
the current \hyperlink{classns3_1_1Address}{Address} of this interface. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a671f99de496d6f09ae343bb715301fb2}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
108 \{
109   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1LoopbackNetDevice_a7d692338d3d7b73fd73f8b182af36d6b}{m\_address};
110 \}
\end{DoxyCode}
\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!Get\+Broadcast@{Get\+Broadcast}}
\index{Get\+Broadcast@{Get\+Broadcast}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Broadcast(void) const }{GetBroadcast(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Loopback\+Net\+Device\+::\+Get\+Broadcast (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1LoopbackNetDevice_a5016750dde40db94bddb53640313a239}{}\label{classns3_1_1LoopbackNetDevice_a5016750dde40db94bddb53640313a239}
\begin{DoxyReturn}{Returns}
the broadcast address supported by this netdevice.
\end{DoxyReturn}
Calling this method is invalid if Is\+Broadcast returns not true. 

Implements \hyperlink{classns3_1_1NetDevice_a4724e03bc548dd8e967cc4a7356197bd}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
143 \{
144   \textcolor{comment}{// This is typically set to all zeros rather than all ones in real systems}
145   \textcolor{keywordflow}{return} Mac48Address (\textcolor{stringliteral}{"00:00:00:00:00:00"});
146 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 3


\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!Get\+Channel@{Get\+Channel}}
\index{Get\+Channel@{Get\+Channel}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Channel(void) const }{GetChannel(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Channel} $>$ ns3\+::\+Loopback\+Net\+Device\+::\+Get\+Channel (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1LoopbackNetDevice_a1e9d74faf50c64a390693bec6c916a57}{}\label{classns3_1_1LoopbackNetDevice_a1e9d74faf50c64a390693bec6c916a57}
\begin{DoxyReturn}{Returns}
the channel this \hyperlink{classns3_1_1NetDevice}{Net\+Device} is connected to. The value returned can be zero if the \hyperlink{classns3_1_1NetDevice}{Net\+Device} is not yet connected to any channel or if the underlying \hyperlink{classns3_1_1NetDevice}{Net\+Device} has no concept of a channel. i.\+e., callers {\itshape must} check for zero and be ready to handle it. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a3d810bd2738634e2e851661271828565}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
96 \{
97   \textcolor{keywordflow}{return} 0;
98 \}
\end{DoxyCode}
\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!Get\+If\+Index@{Get\+If\+Index}}
\index{Get\+If\+Index@{Get\+If\+Index}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+If\+Index(void) const }{GetIfIndex(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Loopback\+Net\+Device\+::\+Get\+If\+Index (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1LoopbackNetDevice_a0e85f4b59c8ced3a2b69609f91fcd64d}{}\label{classns3_1_1LoopbackNetDevice_a0e85f4b59c8ced3a2b69609f91fcd64d}
\begin{DoxyReturn}{Returns}
index if\+Index of the device 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a8c1ae2ec8eadc4524dfc1e425bfa0850}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
90 \{
91   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1LoopbackNetDevice_a223d24d108f8a9dfba19aeb64bd8cfbc}{m\_ifIndex};
92 \}
\end{DoxyCode}
\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!Get\+Mtu@{Get\+Mtu}}
\index{Get\+Mtu@{Get\+Mtu}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Mtu(void) const }{GetMtu(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Loopback\+Net\+Device\+::\+Get\+Mtu (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1LoopbackNetDevice_a557a8a3d4f69e50678842028480ada36}{}\label{classns3_1_1LoopbackNetDevice_a557a8a3d4f69e50678842028480ada36}
\begin{DoxyReturn}{Returns}
the link-\/level M\+TU in bytes for this interface.
\end{DoxyReturn}
This value is typically used by the IP layer to perform IP fragmentation when needed. 

Implements \hyperlink{classns3_1_1NetDevice_a91f4f5d01bc2d567c1e0a69b63a4cf14}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
121 \{
122   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1LoopbackNetDevice_ac2cecc3794c627c237c1ab9d2eca91db}{m\_mtu};
123 \}
\end{DoxyCode}
\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!Get\+Multicast@{Get\+Multicast}}
\index{Get\+Multicast@{Get\+Multicast}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Multicast(\+Ipv4\+Address multicast\+Group) const }{GetMulticast(Ipv4Address multicastGroup) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Loopback\+Net\+Device\+::\+Get\+Multicast (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{multicast\+Group}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1LoopbackNetDevice_acdc5982949f02ac8e98c6859b3fed58a}{}\label{classns3_1_1LoopbackNetDevice_acdc5982949f02ac8e98c6859b3fed58a}


Make and return a M\+AC multicast address using the provided multicast group. 

\{1112\} says that an \hyperlink{classns3_1_1Ipv4}{Ipv4} host group address is mapped to an Ethernet multicast address by placing the low-\/order 23-\/bits of the IP address into the low-\/order 23 bits of the Ethernet multicast address 01-\/00-\/5\+E-\/00-\/00-\/00 (hex). Similar R\+F\+Cs exist for \hyperlink{classns3_1_1Ipv6}{Ipv6} and Eui64 mappings. This method performs the multicast address creation function appropriate to the underlying M\+AC address of the device. This M\+AC address is encapsulated in an abstract \hyperlink{classns3_1_1Address}{Address} to avoid dependencies on the exact M\+AC address format.

In the case of net devices that do not support multicast, clients are expected to test \hyperlink{classns3_1_1NetDevice_a1afb4848a9226540f1ff51f9b31ae95e}{Net\+Device\+::\+Is\+Multicast} and avoid attempting to map multicast packets. Subclasses of \hyperlink{classns3_1_1NetDevice}{Net\+Device} that do support multicasting are expected to override this method and provide an implementation appropriate to the particular device.


\begin{DoxyParams}{Parameters}
{\em multicast\+Group} & The IP address for the multicast group destination of the packet. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The M\+AC multicast \hyperlink{classns3_1_1Address}{Address} used to send packets to the provided multicast group.
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Calling this method is invalid if Is\+Multicast returns not true. 
\end{DoxyWarning}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1LoopbackNetDevice_a889c040c2e85a29fdebb00ebba1854ed}{Is\+Multicast()} 
\end{DoxySeeAlso}


Implements \hyperlink{classns3_1_1NetDevice_a98aa4852df367b6a393c8cc1d88af0d9}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
158 \{
159   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Mac48Address_a23d170f8c7a7d90a8110425620285819}{Mac48Address::GetMulticast} (multicastGroup);
160 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4


\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!Get\+Multicast@{Get\+Multicast}}
\index{Get\+Multicast@{Get\+Multicast}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Multicast(\+Ipv6\+Address addr) const }{GetMulticast(Ipv6Address addr) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Loopback\+Net\+Device\+::\+Get\+Multicast (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{addr}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1LoopbackNetDevice_a5533dda5ad3085b3597aca7d9b05ab38}{}\label{classns3_1_1LoopbackNetDevice_a5533dda5ad3085b3597aca7d9b05ab38}


Get the M\+AC multicast address corresponding to the I\+Pv6 address provided. 


\begin{DoxyParams}{Parameters}
{\em addr} & I\+Pv6 address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the M\+AC multicast address 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Calling this method is invalid if Is\+Multicast returns not true. 
\end{DoxyWarning}


Implements \hyperlink{classns3_1_1NetDevice_a46479a2c0101c6f9da9251ed4d7575bd}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
163 \{
164   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Mac48Address_a23d170f8c7a7d90a8110425620285819}{Mac48Address::GetMulticast} (addr);
165 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5


\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!Get\+Node@{Get\+Node}}
\index{Get\+Node@{Get\+Node}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Node(void) const }{GetNode(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Node} $>$ ns3\+::\+Loopback\+Net\+Device\+::\+Get\+Node (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1LoopbackNetDevice_a95df57dcc2755a4b29af1925ed0f9c5b}{}\label{classns3_1_1LoopbackNetDevice_a95df57dcc2755a4b29af1925ed0f9c5b}
\begin{DoxyReturn}{Returns}
the node base class which contains this network interface.
\end{DoxyReturn}
When a subclass needs to get access to the underlying node base class to print the nodeid for example, it can invoke this method. 

Implements \hyperlink{classns3_1_1NetDevice_a098b6cc4339ac00c62e75cfa48c8aeac}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
202 \{
203   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1LoopbackNetDevice_a5f1f7506494670806071ca51f717f297}{m\_node};
204 \}
\end{DoxyCode}
\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Loopback\+Net\+Device\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1LoopbackNetDevice_a93128f30064bc62b6b8806c8584de160}{}\label{classns3_1_1LoopbackNetDevice_a93128f30064bc62b6b8806c8584de160}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
35 \{
36   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::LoopbackNetDevice"})
37     .SetParent<NetDevice> ()
38     .SetGroupName (\textcolor{stringliteral}{"Internet"})
39     .AddConstructor<\hyperlink{classns3_1_1LoopbackNetDevice_aa0ff9e728fe8a9acafc8f56ffaf9cbea}{LoopbackNetDevice}> ()
40   ;
41   \textcolor{keywordflow}{return} tid;
42 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6


\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!Is\+Bridge@{Is\+Bridge}}
\index{Is\+Bridge@{Is\+Bridge}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Bridge(void) const }{IsBridge(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Loopback\+Net\+Device\+::\+Is\+Bridge (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1LoopbackNetDevice_acd2007b4b31b0bb284ecca76df83dfe4}{}\label{classns3_1_1LoopbackNetDevice_acd2007b4b31b0bb284ecca76df83dfe4}


Return true if the net device is acting as a bridge. 

\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Bridge flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a9d34556a1c83a69dacb08698ca4a1d94}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
175 \{
176   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
177 \}
\end{DoxyCode}
\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!Is\+Broadcast@{Is\+Broadcast}}
\index{Is\+Broadcast@{Is\+Broadcast}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Broadcast(void) const }{IsBroadcast(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Loopback\+Net\+Device\+::\+Is\+Broadcast (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1LoopbackNetDevice_a63c4ce91fb02fc9a9dcd451d183e3bba}{}\label{classns3_1_1LoopbackNetDevice_a63c4ce91fb02fc9a9dcd451d183e3bba}
\begin{DoxyReturn}{Returns}
true if this interface supports a broadcast address, false otherwise. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a67f992b20858cd7b397d8fba2feff141}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
137 \{
138   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
139 \}
\end{DoxyCode}
\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!Is\+Link\+Up@{Is\+Link\+Up}}
\index{Is\+Link\+Up@{Is\+Link\+Up}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Link\+Up(void) const }{IsLinkUp(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Loopback\+Net\+Device\+::\+Is\+Link\+Up (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1LoopbackNetDevice_a109ee470b78b34b42734ada81e28aea7}{}\label{classns3_1_1LoopbackNetDevice_a109ee470b78b34b42734ada81e28aea7}
\begin{DoxyReturn}{Returns}
true if link is up; false otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_afe1822b79e19a05ab95f693c8fb64fc7}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
127 \{
128   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
129 \}
\end{DoxyCode}
\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!Is\+Multicast@{Is\+Multicast}}
\index{Is\+Multicast@{Is\+Multicast}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Multicast(void) const }{IsMulticast(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Loopback\+Net\+Device\+::\+Is\+Multicast (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1LoopbackNetDevice_a889c040c2e85a29fdebb00ebba1854ed}{}\label{classns3_1_1LoopbackNetDevice_a889c040c2e85a29fdebb00ebba1854ed}
\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Multicast flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a1afb4848a9226540f1ff51f9b31ae95e}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
150 \{
151   \textcolor{comment}{// Multicast loopback will need to be supported for outgoing }
152   \textcolor{comment}{// datagrams but this will probably be handled in multicast sockets}
153   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
154 \}
\end{DoxyCode}
\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!Is\+Point\+To\+Point@{Is\+Point\+To\+Point}}
\index{Is\+Point\+To\+Point@{Is\+Point\+To\+Point}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Point\+To\+Point(void) const }{IsPointToPoint(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Loopback\+Net\+Device\+::\+Is\+Point\+To\+Point (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1LoopbackNetDevice_ae8649da600c4a937db48e259965e448d}{}\label{classns3_1_1LoopbackNetDevice_ae8649da600c4a937db48e259965e448d}


Return true if the net device is on a point-\/to-\/point link. 

\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Point\+To\+Point flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a718177f25efeaf2dbf8a18fcab87224d}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
169 \{
170   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
171 \}
\end{DoxyCode}
\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!Needs\+Arp@{Needs\+Arp}}
\index{Needs\+Arp@{Needs\+Arp}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{Needs\+Arp(void) const }{NeedsArp(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Loopback\+Net\+Device\+::\+Needs\+Arp (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1LoopbackNetDevice_af7c8b1f612bb78aed183080ab1e65cae}{}\label{classns3_1_1LoopbackNetDevice_af7c8b1f612bb78aed183080ab1e65cae}
\begin{DoxyReturn}{Returns}
true if A\+RP is needed, false otherwise.
\end{DoxyReturn}
Called by higher-\/layers to check if this \hyperlink{classns3_1_1NetDevice}{Net\+Device} requires A\+RP to be used. 

Implements \hyperlink{classns3_1_1NetDevice_ab1a133696310cad3dc2c3d1a4993f310}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
214 \{
215   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
216 \}
\end{DoxyCode}
\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!Receive@{Receive}}
\index{Receive@{Receive}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{Receive(\+Ptr$<$ Packet $>$ packet, uint16\+\_\+t protocol, Mac48\+Address to, Mac48\+Address from)}{Receive(Ptr< Packet > packet, uint16_t protocol, Mac48Address to, Mac48Address from)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Loopback\+Net\+Device\+::\+Receive (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{uint16\+\_\+t}]{protocol, }
\item[{{\bf Mac48\+Address}}]{to, }
\item[{{\bf Mac48\+Address}}]{from}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1LoopbackNetDevice_a2b5c5f64267ba906d149ab89d2831d34}{}\label{classns3_1_1LoopbackNetDevice_a2b5c5f64267ba906d149ab89d2831d34}
Receive a packet from tge Loopback \hyperlink{classns3_1_1NetDevice}{Net\+Device}.


\begin{DoxyParams}{Parameters}
{\em packet} & a reference to the received packet \\
\hline
{\em protocol} & the protocol \\
\hline
{\em to} & destination address \\
\hline
{\em from} & source address \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
56 \{
57   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (packet << \textcolor{stringliteral}{" "} << protocol << \textcolor{stringliteral}{" "} << to << \textcolor{stringliteral}{" "} << 
      \hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from});
58   \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2}{NetDevice::PacketType} packetType;
59   \textcolor{keywordflow}{if} (to == \hyperlink{classns3_1_1LoopbackNetDevice_a7d692338d3d7b73fd73f8b182af36d6b}{m\_address})
60     \{
61       packetType = \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2a60835731aced24ac0c712ba61e62462e}{NetDevice::PACKET\_HOST};
62     \}
63   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (to.IsBroadcast ())
64     \{
65       packetType = \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2a60835731aced24ac0c712ba61e62462e}{NetDevice::PACKET\_HOST};
66     \}
67   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (to.IsGroup ())
68     \{
69       packetType = \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2ae3ffb88d364e97f06f662f5d7ba53bbe}{NetDevice::PACKET\_MULTICAST};
70     \}
71   \textcolor{keywordflow}{else} 
72     \{
73       packetType = \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2a60c00fab4286dd2903e2b197a9f8c6c8}{NetDevice::PACKET\_OTHERHOST};
74     \}
75   \hyperlink{classns3_1_1LoopbackNetDevice_a844fcc47c3dc1be07aed83c8ba70a7b0}{m\_rxCallback} (\textcolor{keyword}{this}, packet, protocol, \hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from});
76   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1LoopbackNetDevice_ac18a33947e9703ed786c83448348414c}{m\_promiscCallback}.\hyperlink{classns3_1_1Callback_aa8e27826badbf37f84763f36f70d9b54}{IsNull} ())
77     \{
78       \hyperlink{classns3_1_1LoopbackNetDevice_ac18a33947e9703ed786c83448348414c}{m\_promiscCallback} (\textcolor{keyword}{this}, packet, protocol, \hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from}, to, packetType);
79     \}
80 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7




Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!Send@{Send}}
\index{Send@{Send}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{Send(\+Ptr$<$ Packet $>$ packet, const Address \&dest, uint16\+\_\+t protocol\+Number)}{Send(Ptr< Packet > packet, const Address &dest, uint16_t protocolNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Loopback\+Net\+Device\+::\+Send (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{const {\bf Address} \&}]{dest, }
\item[{uint16\+\_\+t}]{protocol\+Number}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1LoopbackNetDevice_add41fe2884d42456ea019337bfa88c37}{}\label{classns3_1_1LoopbackNetDevice_add41fe2884d42456ea019337bfa88c37}

\begin{DoxyParams}{Parameters}
{\em packet} & packet sent from above down to Network Device \\
\hline
{\em dest} & mac address of the destination (already resolved) \\
\hline
{\em protocol\+Number} & identifies the type of payload contained in this packet. Used to call the right L3\+Protocol when the packet is received.\\
\hline
\end{DoxyParams}
Called from higher layer to send packet into Network Device to the specified destination \hyperlink{classns3_1_1Address}{Address}

\begin{DoxyReturn}{Returns}
whether the Send operation succeeded 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a59f41afb0fe8951bb94d5739cbe6ee7d}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
181 \{
182   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (packet << \textcolor{stringliteral}{" "} << dest << \textcolor{stringliteral}{" "} << protocolNumber);
183   Mac48Address to = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (dest);
184   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (to == \hyperlink{classns3_1_1LoopbackNetDevice_a5016750dde40db94bddb53640313a239}{GetBroadcast} () || to == 
      \hyperlink{classns3_1_1LoopbackNetDevice_a7d692338d3d7b73fd73f8b182af36d6b}{m\_address}, \textcolor{stringliteral}{"Invalid destination address"});
185   \hyperlink{classns3_1_1Simulator_a86dbaef45a15a42365d7d2ae550449f6}{Simulator::ScheduleWithContext} (\hyperlink{classns3_1_1LoopbackNetDevice_a5f1f7506494670806071ca51f717f297}{m\_node}->
      \hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} (), \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (0.0), &\hyperlink{classns3_1_1LoopbackNetDevice_a2b5c5f64267ba906d149ab89d2831d34}{LoopbackNetDevice::Receive}, \textcolor{keyword}{this}, packet, 
      protocolNumber, to, \hyperlink{classns3_1_1LoopbackNetDevice_a7d692338d3d7b73fd73f8b182af36d6b}{m\_address});
186   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
187 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9


\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!Send\+From@{Send\+From}}
\index{Send\+From@{Send\+From}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{Send\+From(\+Ptr$<$ Packet $>$ packet, const Address \&source, const Address \&dest, uint16\+\_\+t protocol\+Number)}{SendFrom(Ptr< Packet > packet, const Address &source, const Address &dest, uint16_t protocolNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Loopback\+Net\+Device\+::\+Send\+From (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{const {\bf Address} \&}]{source, }
\item[{const {\bf Address} \&}]{dest, }
\item[{uint16\+\_\+t}]{protocol\+Number}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1LoopbackNetDevice_a95f0043ce01d85a65cf08cb6495886e0}{}\label{classns3_1_1LoopbackNetDevice_a95f0043ce01d85a65cf08cb6495886e0}

\begin{DoxyParams}{Parameters}
{\em packet} & packet sent from above down to Network Device \\
\hline
{\em source} & source mac address (so called \char`\"{}\+M\+A\+C spoofing\char`\"{}) \\
\hline
{\em dest} & mac address of the destination (already resolved) \\
\hline
{\em protocol\+Number} & identifies the type of payload contained in this packet. Used to call the right L3\+Protocol when the packet is received.\\
\hline
\end{DoxyParams}
Called from higher layer to send packet into Network Device with the specified source and destination Addresses.

\begin{DoxyReturn}{Returns}
whether the Send operation succeeded 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a19d55a4746c1ae584bf7da69959a885b}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
191 \{
192   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (packet << \textcolor{stringliteral}{" "} << source << \textcolor{stringliteral}{" "} << dest << \textcolor{stringliteral}{" "} << protocolNumber);
193   Mac48Address to = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (dest);
194   Mac48Address \hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from} = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (source);
195   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (to.IsBroadcast () || to == \hyperlink{classns3_1_1LoopbackNetDevice_a7d692338d3d7b73fd73f8b182af36d6b}{m\_address}, \textcolor{stringliteral}{"Invalid destination address"})
      ;
196   \hyperlink{classns3_1_1Simulator_a86dbaef45a15a42365d7d2ae550449f6}{Simulator::ScheduleWithContext} (\hyperlink{classns3_1_1LoopbackNetDevice_a5f1f7506494670806071ca51f717f297}{m\_node}->
      \hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} (), \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (0.0), &\hyperlink{classns3_1_1LoopbackNetDevice_a2b5c5f64267ba906d149ab89d2831d34}{LoopbackNetDevice::Receive}, \textcolor{keyword}{this}, packet, 
      protocolNumber, to, \hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from});
197   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
198 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10


\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!Set\+Address@{Set\+Address}}
\index{Set\+Address@{Set\+Address}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Address(\+Address address)}{SetAddress(Address address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Loopback\+Net\+Device\+::\+Set\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1LoopbackNetDevice_ae194813879ce85bec09ba22501decb7e}{}\label{classns3_1_1LoopbackNetDevice_ae194813879ce85bec09ba22501decb7e}
Set the address of this interface 
\begin{DoxyParams}{Parameters}
{\em address} & address to set \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1NetDevice_ab56dc36bc0547471ab3210eda60ee76c}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
102 \{
103   \hyperlink{classns3_1_1LoopbackNetDevice_a7d692338d3d7b73fd73f8b182af36d6b}{m\_address} = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (address);
104 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 11


\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!Set\+If\+Index@{Set\+If\+Index}}
\index{Set\+If\+Index@{Set\+If\+Index}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+If\+Index(const uint32\+\_\+t index)}{SetIfIndex(const uint32_t index)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Loopback\+Net\+Device\+::\+Set\+If\+Index (
\begin{DoxyParamCaption}
\item[{const uint32\+\_\+t}]{index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1LoopbackNetDevice_a35aa739d7e48b0d0f574a0846aa2c8fa}{}\label{classns3_1_1LoopbackNetDevice_a35aa739d7e48b0d0f574a0846aa2c8fa}

\begin{DoxyParams}{Parameters}
{\em index} & if\+Index of the device \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1NetDevice_a2e1ac6c1189cd565420305d85a193fb8}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
84 \{
85   \hyperlink{classns3_1_1LoopbackNetDevice_a223d24d108f8a9dfba19aeb64bd8cfbc}{m\_ifIndex} = index;
86 \}
\end{DoxyCode}
\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!Set\+Mtu@{Set\+Mtu}}
\index{Set\+Mtu@{Set\+Mtu}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Mtu(const uint16\+\_\+t mtu)}{SetMtu(const uint16_t mtu)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Loopback\+Net\+Device\+::\+Set\+Mtu (
\begin{DoxyParamCaption}
\item[{const uint16\+\_\+t}]{mtu}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1LoopbackNetDevice_a0c401b78801c1e41d7fb15e708787438}{}\label{classns3_1_1LoopbackNetDevice_a0c401b78801c1e41d7fb15e708787438}

\begin{DoxyParams}{Parameters}
{\em mtu} & M\+TU value, in bytes, to set for the device \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether the M\+TU value was within legal bounds
\end{DoxyReturn}
Override for default M\+TU defined on a per-\/type basis. 

Implements \hyperlink{classns3_1_1NetDevice_a2ba4956d45cde68eab3cbdd6ede06df0}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
114 \{
115   \hyperlink{classns3_1_1LoopbackNetDevice_ac2cecc3794c627c237c1ab9d2eca91db}{m\_mtu} = mtu;
116   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
117 \}
\end{DoxyCode}
\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!Set\+Node@{Set\+Node}}
\index{Set\+Node@{Set\+Node}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Node(\+Ptr$<$ Node $>$ node)}{SetNode(Ptr< Node > node)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Loopback\+Net\+Device\+::\+Set\+Node (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1LoopbackNetDevice_aee8ac2bb101b3489a1f3dd1682bdf3c2}{}\label{classns3_1_1LoopbackNetDevice_aee8ac2bb101b3489a1f3dd1682bdf3c2}

\begin{DoxyParams}{Parameters}
{\em node} & the node associated to this netdevice.\\
\hline
\end{DoxyParams}
This method is called from \hyperlink{classns3_1_1Node_a42ff83ee1d5d1649c770d3f5b62375de}{ns3\+::\+Node\+::\+Add\+Device}. 

Implements \hyperlink{classns3_1_1NetDevice_a3ae520ae06e93b957f0f56f113319a08}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
208 \{
209   \hyperlink{classns3_1_1LoopbackNetDevice_a5f1f7506494670806071ca51f717f297}{m\_node} = node;
210 \}
\end{DoxyCode}
\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!Set\+Promisc\+Receive\+Callback@{Set\+Promisc\+Receive\+Callback}}
\index{Set\+Promisc\+Receive\+Callback@{Set\+Promisc\+Receive\+Callback}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Promisc\+Receive\+Callback(\+Promisc\+Receive\+Callback cb)}{SetPromiscReceiveCallback(PromiscReceiveCallback cb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Loopback\+Net\+Device\+::\+Set\+Promisc\+Receive\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Promisc\+Receive\+Callback}}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1LoopbackNetDevice_a789063a46797d9c03d7abeb24f0891b1}{}\label{classns3_1_1LoopbackNetDevice_a789063a46797d9c03d7abeb24f0891b1}

\begin{DoxyParams}{Parameters}
{\em cb} & callback to invoke whenever a packet has been received in promiscuous mode and must be forwarded to the higher layers.\\
\hline
\end{DoxyParams}
Enables netdevice promiscuous mode and sets the callback that will handle promiscuous mode packets. Note, promiscuous mode packets means {\itshape all} packets, including those packets that can be sensed by the netdevice but which are intended to be received by other hosts. 

Implements \hyperlink{classns3_1_1NetDevice_a3968946bdbb74d47d7b13612baad7d6d}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
234 \{
235   \hyperlink{classns3_1_1LoopbackNetDevice_ac18a33947e9703ed786c83448348414c}{m\_promiscCallback} = cb;
236 \}
\end{DoxyCode}
\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!Set\+Receive\+Callback@{Set\+Receive\+Callback}}
\index{Set\+Receive\+Callback@{Set\+Receive\+Callback}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Receive\+Callback(\+Net\+Device\+::\+Receive\+Callback cb)}{SetReceiveCallback(NetDevice::ReceiveCallback cb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Loopback\+Net\+Device\+::\+Set\+Receive\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Net\+Device\+::\+Receive\+Callback}}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1LoopbackNetDevice_ab628a992340b0530c0777d048b84ee0f}{}\label{classns3_1_1LoopbackNetDevice_ab628a992340b0530c0777d048b84ee0f}

\begin{DoxyParams}{Parameters}
{\em cb} & callback to invoke whenever a packet has been received and must be forwarded to the higher layers.\\
\hline
\end{DoxyParams}
Set the callback to be used to notify higher layers when a packet has been received. 

Implements \hyperlink{classns3_1_1NetDevice_ac63e4d5668e421fec4b5d37f32e7dd18}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
220 \{
221   \hyperlink{classns3_1_1LoopbackNetDevice_a844fcc47c3dc1be07aed83c8ba70a7b0}{m\_rxCallback} = cb;
222 \}
\end{DoxyCode}
\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!Supports\+Send\+From@{Supports\+Send\+From}}
\index{Supports\+Send\+From@{Supports\+Send\+From}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{Supports\+Send\+From(void) const }{SupportsSendFrom(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Loopback\+Net\+Device\+::\+Supports\+Send\+From (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1LoopbackNetDevice_a7dc18fb68db1cf88cbad276cb674083d}{}\label{classns3_1_1LoopbackNetDevice_a7dc18fb68db1cf88cbad276cb674083d}
\begin{DoxyReturn}{Returns}
true if this interface supports a bridging mode, false otherwise. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a04793d220b54c40e110ebf86dae5b25c}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
240 \{
241   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
242 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!m\+\_\+address@{m\+\_\+address}}
\index{m\+\_\+address@{m\+\_\+address}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+address}{m_address}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Mac48\+Address} ns3\+::\+Loopback\+Net\+Device\+::m\+\_\+address\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1LoopbackNetDevice_a7d692338d3d7b73fd73f8b182af36d6b}{}\label{classns3_1_1LoopbackNetDevice_a7d692338d3d7b73fd73f8b182af36d6b}


\hyperlink{classns3_1_1NetDevice}{Net\+Device} M\+AC address. 

\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!m\+\_\+if\+Index@{m\+\_\+if\+Index}}
\index{m\+\_\+if\+Index@{m\+\_\+if\+Index}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+if\+Index}{m_ifIndex}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Loopback\+Net\+Device\+::m\+\_\+if\+Index\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1LoopbackNetDevice_a223d24d108f8a9dfba19aeb64bd8cfbc}{}\label{classns3_1_1LoopbackNetDevice_a223d24d108f8a9dfba19aeb64bd8cfbc}


interface index 

\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!m\+\_\+mtu@{m\+\_\+mtu}}
\index{m\+\_\+mtu@{m\+\_\+mtu}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+mtu}{m_mtu}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Loopback\+Net\+Device\+::m\+\_\+mtu\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1LoopbackNetDevice_ac2cecc3794c627c237c1ab9d2eca91db}{}\label{classns3_1_1LoopbackNetDevice_ac2cecc3794c627c237c1ab9d2eca91db}


device M\+TU 

\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!m\+\_\+node@{m\+\_\+node}}
\index{m\+\_\+node@{m\+\_\+node}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+node}{m_node}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Node}$>$ ns3\+::\+Loopback\+Net\+Device\+::m\+\_\+node\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1LoopbackNetDevice_a5f1f7506494670806071ca51f717f297}{}\label{classns3_1_1LoopbackNetDevice_a5f1f7506494670806071ca51f717f297}


the node this \hyperlink{classns3_1_1NetDevice}{Net\+Device} is associated with 

\index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!m\+\_\+promisc\+Callback@{m\+\_\+promisc\+Callback}}
\index{m\+\_\+promisc\+Callback@{m\+\_\+promisc\+Callback}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+promisc\+Callback}{m_promiscCallback}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Net\+Device\+::\+Promisc\+Receive\+Callback} ns3\+::\+Loopback\+Net\+Device\+::m\+\_\+promisc\+Callback\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1LoopbackNetDevice_ac18a33947e9703ed786c83448348414c}{}\label{classns3_1_1LoopbackNetDevice_ac18a33947e9703ed786c83448348414c}
The callback used to notify higher layers that a packet has been received in promiscuous mode. \index{ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}!m\+\_\+rx\+Callback@{m\+\_\+rx\+Callback}}
\index{m\+\_\+rx\+Callback@{m\+\_\+rx\+Callback}!ns3\+::\+Loopback\+Net\+Device@{ns3\+::\+Loopback\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+rx\+Callback}{m_rxCallback}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Net\+Device\+::\+Receive\+Callback} ns3\+::\+Loopback\+Net\+Device\+::m\+\_\+rx\+Callback\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1LoopbackNetDevice_a844fcc47c3dc1be07aed83c8ba70a7b0}{}\label{classns3_1_1LoopbackNetDevice_a844fcc47c3dc1be07aed83c8ba70a7b0}
The callback used to notify higher layers that a packet has been received. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/model/\hyperlink{loopback-net-device_8h}{loopback-\/net-\/device.\+h}\item 
internet/model/\hyperlink{loopback-net-device_8cc}{loopback-\/net-\/device.\+cc}\end{DoxyCompactItemize}
