\hypertarget{classns3_1_1Ipv6ListRouting}{}\section{ns3\+:\+:Ipv6\+List\+Routing Class Reference}
\label{classns3_1_1Ipv6ListRouting}\index{ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}}


Hold list of \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} objects.  




{\ttfamily \#include $<$ipv6-\/list-\/routing.\+h$>$}



Inheritance diagram for ns3\+:\+:Ipv6\+List\+Routing\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Ipv6\+List\+Routing\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ipv6ListRouting_aba2640dffd53164b983cf8492ca970c8}{Ipv6\+List\+Routing} ()
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ipv6ListRouting_a045ee0b12dee4e8642ff7f1f6b86a835}{$\sim$\+Ipv6\+List\+Routing} ()
\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6ListRouting_af2f9faf061ec907349d7287475fe73bc}{Add\+Routing\+Protocol} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} $>$ routing\+Protocol, int16\+\_\+t priority)
\begin{DoxyCompactList}\small\item\em Register a new routing protocol to be used in this I\+Pv4 stack. \end{DoxyCompactList}\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1Ipv6ListRouting_a7aa04efd7a6833dddcebe061bcbb0e78}{Get\+N\+Routing\+Protocols} (void) const 
\begin{DoxyCompactList}\small\item\em Get the number of routing protocols. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} $>$ \hyperlink{classns3_1_1Ipv6ListRouting_ac57acbccab04b57ffb62a8bd9d40d506}{Get\+Routing\+Protocol} (uint32\+\_\+t index, int16\+\_\+t \&priority) const 
\begin{DoxyCompactList}\small\item\em Get pointer to routing protocol stored at index,. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Route}{Ipv6\+Route} $>$ \hyperlink{classns3_1_1Ipv6ListRouting_a17dd6df1ef25f2ff410b5ba759b6e5e7}{Route\+Output} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ oif, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket\+::\+Socket\+Errno} \&sockerr)
\begin{DoxyCompactList}\small\item\em Query routing cache for an existing route, for an outbound packet. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1Ipv6ListRouting_a1b4d7867aad1029308cb7907f75e1035}{Route\+Input} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ idev, \hyperlink{classns3_1_1Ipv6RoutingProtocol_a579fd6755ee873009819f7117371fea7}{Unicast\+Forward\+Callback} ucb, \hyperlink{classns3_1_1Ipv6RoutingProtocol_a5f12e04512ce8e5808c3cceff6b8918f}{Multicast\+Forward\+Callback} mcb, \hyperlink{classns3_1_1Ipv6RoutingProtocol_a93f6c06be1e024747e95f4299eba74a6}{Local\+Deliver\+Callback} lcb, \hyperlink{classns3_1_1Ipv6RoutingProtocol_abfdf43594e2ae97e1a4dc340e3a086a5}{Error\+Callback} ecb)
\begin{DoxyCompactList}\small\item\em Route an input packet (to be forwarded or locally delivered) \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6ListRouting_afbeeaf6cd4dd9a81354e70617bf88811}{Notify\+Interface\+Up} (uint32\+\_\+t interface)
\begin{DoxyCompactList}\small\item\em Notify when specified interface goes UP. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6ListRouting_a24b3d4068e036c349699901558f0471c}{Notify\+Interface\+Down} (uint32\+\_\+t interface)
\begin{DoxyCompactList}\small\item\em Notify when specified interface goes D\+O\+WN. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6ListRouting_a67d4f8e48b55a0c99d8e59ac5b74c498}{Notify\+Add\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv6InterfaceAddress}{Ipv6\+Interface\+Address} address)
\begin{DoxyCompactList}\small\item\em Notify when specified interface add an address. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6ListRouting_a46e2cf52e8552cc0b3373c6609be27cc}{Notify\+Remove\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv6InterfaceAddress}{Ipv6\+Interface\+Address} address)
\begin{DoxyCompactList}\small\item\em Notify when specified interface add an address. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6ListRouting_a39dddd9618719875abab8c2ed9eed081}{Notify\+Add\+Route} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dst, \hyperlink{classns3_1_1Ipv6Prefix}{Ipv6\+Prefix} mask, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} next\+Hop, uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} prefix\+To\+Use=\hyperlink{classns3_1_1Ipv6Address_a63a34bdb1505e05fbdd07d316d0bd7e6}{Ipv6\+Address\+::\+Get\+Zero}())
\begin{DoxyCompactList}\small\item\em Notify a new route. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6ListRouting_a10a31c12272e77d51d1fd68b025ad2f5}{Notify\+Remove\+Route} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dst, \hyperlink{classns3_1_1Ipv6Prefix}{Ipv6\+Prefix} mask, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} next\+Hop, uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} prefix\+To\+Use=\hyperlink{classns3_1_1Ipv6Address_a63a34bdb1505e05fbdd07d316d0bd7e6}{Ipv6\+Address\+::\+Get\+Zero}())
\begin{DoxyCompactList}\small\item\em Notify route removing. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6ListRouting_ac660375f36097f4c760a2cc5e6f4aa8a}{Set\+Ipv6} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6}{Ipv6} $>$ ipv6)
\begin{DoxyCompactList}\small\item\em Typically, invoked directly or indirectly from \hyperlink{classns3_1_1Ipv6_aa889d2174527a1df773d65974de83f8f}{ns3\+::\+Ipv6\+::\+Set\+Routing\+Protocol}. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6ListRouting_a0c8272a6217b35e37b6e6ac247494890}{Print\+Routing\+Table} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream, \hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295a}{Time\+::\+Unit} unit=\hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295aade8622b06524a328cd3a59db6ccf76af}{Time\+::S}) const 
\begin{DoxyCompactList}\small\item\em Print the Routing Table entries. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1Ipv6ListRouting_a2a1e3ee20de076b049451e4a675e438b}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID of this class. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1Ipv6ListRouting_a71c24e3a4fc051e12bc1731c238a7bc6}{Do\+Dispose} (void)
\begin{DoxyCompactList}\small\item\em Dispose this object. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
typedef std\+::pair$<$ int16\+\_\+t, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} $>$ $>$ \hyperlink{classns3_1_1Ipv6ListRouting_a319efc7e5387bd5e2ca63ffe82daa15d}{Ipv6\+Routing\+Protocol\+Entry}
\begin{DoxyCompactList}\small\item\em Container identifying an I\+Pv6 Routing Protocol entry in the list. \end{DoxyCompactList}\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ipv6ListRouting_a319efc7e5387bd5e2ca63ffe82daa15d}{Ipv6\+Routing\+Protocol\+Entry} $>$ \hyperlink{classns3_1_1Ipv6ListRouting_ac06678936e0664598621368bbfa8f6de}{Ipv6\+Routing\+Protocol\+List}
\begin{DoxyCompactList}\small\item\em Container of the I\+Pv6 Routing Protocols. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Private Member Functions}
\begin{DoxyCompactItemize}
\item 
static bool \hyperlink{classns3_1_1Ipv6ListRouting_a3a0763f9854cedc4a231ba253ea2e418}{Compare} (const \hyperlink{classns3_1_1Ipv6ListRouting_a319efc7e5387bd5e2ca63ffe82daa15d}{Ipv6\+Routing\+Protocol\+Entry} \&a, const \hyperlink{classns3_1_1Ipv6ListRouting_a319efc7e5387bd5e2ca63ffe82daa15d}{Ipv6\+Routing\+Protocol\+Entry} \&\hyperlink{lte__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b})
\begin{DoxyCompactList}\small\item\em Compare two routing protocols. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ipv6ListRouting_ac06678936e0664598621368bbfa8f6de}{Ipv6\+Routing\+Protocol\+List} \hyperlink{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{m\+\_\+routing\+Protocols}
\begin{DoxyCompactList}\small\item\em List of routing protocols. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6}{Ipv6} $>$ \hyperlink{classns3_1_1Ipv6ListRouting_af82ea298d92eb8cfcb6c7572e32b517d}{m\+\_\+ipv6}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Ipv6}{Ipv6} this protocol is associated with. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Hold list of \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} objects. 

This class is a specialization of \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} that allows other instances of \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} to be inserted in a prioritized list. Routing protocols in the list are consulted one by one, from highest to lowest priority, until a routing protocol is found that will take the packet (this corresponds to a non-\/zero return value to Route\+Output, or a return value of true to Route\+Input). The order by which routing protocols with the same priority value are consulted is undefined. 

\subsection{Member Typedef Documentation}
\index{ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}!Ipv6\+Routing\+Protocol\+Entry@{Ipv6\+Routing\+Protocol\+Entry}}
\index{Ipv6\+Routing\+Protocol\+Entry@{Ipv6\+Routing\+Protocol\+Entry}!ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}}
\subsubsection[{\texorpdfstring{Ipv6\+Routing\+Protocol\+Entry}{Ipv6RoutingProtocolEntry}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::pair$<$int16\+\_\+t, {\bf Ptr}$<${\bf Ipv6\+Routing\+Protocol}$>$ $>$ {\bf ns3\+::\+Ipv6\+List\+Routing\+::\+Ipv6\+Routing\+Protocol\+Entry}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6ListRouting_a319efc7e5387bd5e2ca63ffe82daa15d}{}\label{classns3_1_1Ipv6ListRouting_a319efc7e5387bd5e2ca63ffe82daa15d}


Container identifying an I\+Pv6 Routing Protocol entry in the list. 

\index{ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}!Ipv6\+Routing\+Protocol\+List@{Ipv6\+Routing\+Protocol\+List}}
\index{Ipv6\+Routing\+Protocol\+List@{Ipv6\+Routing\+Protocol\+List}!ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}}
\subsubsection[{\texorpdfstring{Ipv6\+Routing\+Protocol\+List}{Ipv6RoutingProtocolList}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Ipv6\+Routing\+Protocol\+Entry}$>$ {\bf ns3\+::\+Ipv6\+List\+Routing\+::\+Ipv6\+Routing\+Protocol\+List}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6ListRouting_ac06678936e0664598621368bbfa8f6de}{}\label{classns3_1_1Ipv6ListRouting_ac06678936e0664598621368bbfa8f6de}


Container of the I\+Pv6 Routing Protocols. 



\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}!Ipv6\+List\+Routing@{Ipv6\+List\+Routing}}
\index{Ipv6\+List\+Routing@{Ipv6\+List\+Routing}!ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}}
\subsubsection[{\texorpdfstring{Ipv6\+List\+Routing()}{Ipv6ListRouting()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv6\+List\+Routing\+::\+Ipv6\+List\+Routing (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6ListRouting_aba2640dffd53164b983cf8492ca970c8}{}\label{classns3_1_1Ipv6ListRouting_aba2640dffd53164b983cf8492ca970c8}


Constructor. 


\begin{DoxyCode}
47   : \hyperlink{classns3_1_1Ipv6ListRouting_af82ea298d92eb8cfcb6c7572e32b517d}{m\_ipv6} (0)
48 \{
49   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
50 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}!````~Ipv6\+List\+Routing@{$\sim$\+Ipv6\+List\+Routing}}
\index{````~Ipv6\+List\+Routing@{$\sim$\+Ipv6\+List\+Routing}!ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}}
\subsubsection[{\texorpdfstring{$\sim$\+Ipv6\+List\+Routing()}{~Ipv6ListRouting()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv6\+List\+Routing\+::$\sim$\+Ipv6\+List\+Routing (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6ListRouting_a045ee0b12dee4e8642ff7f1f6b86a835}{}\label{classns3_1_1Ipv6ListRouting_a045ee0b12dee4e8642ff7f1f6b86a835}


Destructor. 


\begin{DoxyCode}
53 \{
54   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
55 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}!Add\+Routing\+Protocol@{Add\+Routing\+Protocol}}
\index{Add\+Routing\+Protocol@{Add\+Routing\+Protocol}!ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}}
\subsubsection[{\texorpdfstring{Add\+Routing\+Protocol(\+Ptr$<$ Ipv6\+Routing\+Protocol $>$ routing\+Protocol, int16\+\_\+t priority)}{AddRoutingProtocol(Ptr< Ipv6RoutingProtocol > routingProtocol, int16_t priority)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+List\+Routing\+::\+Add\+Routing\+Protocol (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv6\+Routing\+Protocol} $>$}]{routing\+Protocol, }
\item[{int16\+\_\+t}]{priority}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6ListRouting_af2f9faf061ec907349d7287475fe73bc}{}\label{classns3_1_1Ipv6ListRouting_af2f9faf061ec907349d7287475fe73bc}


Register a new routing protocol to be used in this I\+Pv4 stack. 


\begin{DoxyParams}{Parameters}
{\em routing\+Protocol} & new routing protocol implementation object \\
\hline
{\em priority} & priority to give to this routing protocol. Values may range between -\/32768 and +32767. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
246 \{
247   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << routingProtocol->GetInstanceTypeId () << priority);
248   \hyperlink{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{m\_routingProtocols}.push\_back (std::make\_pair (priority, routingProtocol));
249   \hyperlink{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{m\_routingProtocols}.sort ( \hyperlink{classns3_1_1Ipv6ListRouting_a3a0763f9854cedc4a231ba253ea2e418}{Compare} );
250   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6ListRouting_af82ea298d92eb8cfcb6c7572e32b517d}{m\_ipv6} != 0)
251     \{
252       routingProtocol->SetIpv6 (\hyperlink{classns3_1_1Ipv6ListRouting_af82ea298d92eb8cfcb6c7572e32b517d}{m\_ipv6});
253     \}
254 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2




Here is the caller graph for this function\+:
% FIG 3


\index{ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}!Compare@{Compare}}
\index{Compare@{Compare}!ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}}
\subsubsection[{\texorpdfstring{Compare(const Ipv6\+Routing\+Protocol\+Entry \&a, const Ipv6\+Routing\+Protocol\+Entry \&b)}{Compare(const Ipv6RoutingProtocolEntry &a, const Ipv6RoutingProtocolEntry &b)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv6\+List\+Routing\+::\+Compare (
\begin{DoxyParamCaption}
\item[{const {\bf Ipv6\+Routing\+Protocol\+Entry} \&}]{a, }
\item[{const {\bf Ipv6\+Routing\+Protocol\+Entry} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6ListRouting_a3a0763f9854cedc4a231ba253ea2e418}{}\label{classns3_1_1Ipv6ListRouting_a3a0763f9854cedc4a231ba253ea2e418}


Compare two routing protocols. 


\begin{DoxyParams}{Parameters}
{\em a} & first object to compare \\
\hline
{\em b} & second object to compare \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if they are the same, false otherwise 
\end{DoxyReturn}

\begin{DoxyCode}
286 \{
287   \textcolor{keywordflow}{return} a.first > \hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b}.first;
288 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}}
\subsubsection[{\texorpdfstring{Do\+Dispose(void)}{DoDispose(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+List\+Routing\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6ListRouting_a71c24e3a4fc051e12bc1731c238a7bc6}{}\label{classns3_1_1Ipv6ListRouting_a71c24e3a4fc051e12bc1731c238a7bc6}


Dispose this object. 



Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.


\begin{DoxyCode}
59 \{
60   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
61   \textcolor{keywordflow}{for} (Ipv6RoutingProtocolList::iterator rprotoIter = \hyperlink{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{m\_routingProtocols}.begin ();
62        rprotoIter != \hyperlink{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{m\_routingProtocols}.end (); rprotoIter++)
63     \{
64       \textcolor{comment}{// Note:  Calling dispose on these protocols causes memory leak}
65       \textcolor{comment}{//        The routing protocols should not maintain a pointer to}
66       \textcolor{comment}{//        this object, so Dispose () shouldn't be necessary.}
67       (*rprotoIter).second = 0;
68     \}
69   \hyperlink{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{m\_routingProtocols}.clear ();
70   \hyperlink{classns3_1_1Ipv6ListRouting_af82ea298d92eb8cfcb6c7572e32b517d}{m\_ipv6} = 0;
71 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}!Get\+N\+Routing\+Protocols@{Get\+N\+Routing\+Protocols}}
\index{Get\+N\+Routing\+Protocols@{Get\+N\+Routing\+Protocols}!ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}}
\subsubsection[{\texorpdfstring{Get\+N\+Routing\+Protocols(void) const }{GetNRoutingProtocols(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Ipv6\+List\+Routing\+::\+Get\+N\+Routing\+Protocols (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6ListRouting_a7aa04efd7a6833dddcebe061bcbb0e78}{}\label{classns3_1_1Ipv6ListRouting_a7aa04efd7a6833dddcebe061bcbb0e78}


Get the number of routing protocols. 

\begin{DoxyReturn}{Returns}
number of routing protocols in the list 
\end{DoxyReturn}

\begin{DoxyCode}
258 \{
259   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
260   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{m\_routingProtocols}.size ();
261 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}!Get\+Routing\+Protocol@{Get\+Routing\+Protocol}}
\index{Get\+Routing\+Protocol@{Get\+Routing\+Protocol}!ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Routing\+Protocol(uint32\+\_\+t index, int16\+\_\+t \&priority) const }{GetRoutingProtocol(uint32_t index, int16_t &priority) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv6\+Routing\+Protocol} $>$ ns3\+::\+Ipv6\+List\+Routing\+::\+Get\+Routing\+Protocol (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{index, }
\item[{int16\+\_\+t \&}]{priority}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6ListRouting_ac57acbccab04b57ffb62a8bd9d40d506}{}\label{classns3_1_1Ipv6ListRouting_ac57acbccab04b57ffb62a8bd9d40d506}


Get pointer to routing protocol stored at index,. 

The first protocol (index 0) the highest priority, the next one (index 1) the second highest priority, and so on. The priority parameter is an output parameter and it returns the integer priority of the protocol. 
\begin{DoxyParams}{Parameters}
{\em index} & index of protocol to return \\
\hline
{\em priority} & output parameter, set to the priority of the protocol being returned \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to routing protocol indexed by 
\end{DoxyReturn}

\begin{DoxyCode}
265 \{
266   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (index);
267   \textcolor{keywordflow}{if} (index > \hyperlink{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{m\_routingProtocols}.size ())
268     \{
269       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Ipv6ListRouting::GetRoutingProtocol ():  index "} << index << \textcolor{stringliteral}{" out of
       range"});
270     \}
271   uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0;
272   \textcolor{keywordflow}{for} (Ipv6RoutingProtocolList::const\_iterator rprotoIter = \hyperlink{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{m\_routingProtocols}.begin ();
273        rprotoIter != \hyperlink{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{m\_routingProtocols}.end (); rprotoIter++, i++)
274     \{
275       \textcolor{keywordflow}{if} (i == index)
276         \{
277           priority = (*rprotoIter).first;
278           \textcolor{keywordflow}{return} (*rprotoIter).second;
279         \}
280     \}
281   \textcolor{keywordflow}{return} 0;
282 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Ipv6\+List\+Routing\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv6ListRouting_a2a1e3ee20de076b049451e4a675e438b}{}\label{classns3_1_1Ipv6ListRouting_a2a1e3ee20de076b049451e4a675e438b}


Get the type ID of this class. 

\begin{DoxyReturn}{Returns}
type ID 
\end{DoxyReturn}

\begin{DoxyCode}
36 \{
37   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::Ipv6ListRouting"})
38     .SetParent<Ipv6RoutingProtocol> ()
39     .SetGroupName (\textcolor{stringliteral}{"Internet"})
40     .AddConstructor<\hyperlink{classns3_1_1Ipv6ListRouting_aba2640dffd53164b983cf8492ca970c8}{Ipv6ListRouting}> ()
41   ;
42   \textcolor{keywordflow}{return} tid;
43 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7




Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}!Notify\+Add\+Address@{Notify\+Add\+Address}}
\index{Notify\+Add\+Address@{Notify\+Add\+Address}!ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}}
\subsubsection[{\texorpdfstring{Notify\+Add\+Address(uint32\+\_\+t interface, Ipv6\+Interface\+Address address)}{NotifyAddAddress(uint32_t interface, Ipv6InterfaceAddress address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+List\+Routing\+::\+Notify\+Add\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv6\+Interface\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6ListRouting_a67d4f8e48b55a0c99d8e59ac5b74c498}{}\label{classns3_1_1Ipv6ListRouting_a67d4f8e48b55a0c99d8e59ac5b74c498}


Notify when specified interface add an address. 

Protocols are expected to implement this method to be notified whenever a new address is added to an interface. Typically used to add a \textquotesingle{}network route\textquotesingle{} on an interface. Can be invoked on an up or down interface. 
\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
{\em address} & a new address being added to an interface \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6RoutingProtocol_ae8ef31faadbb3ddd1c9a8888c986cb57}{ns3\+::\+Ipv6\+Routing\+Protocol}.


\begin{DoxyCode}
165 \{
166   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << interface << address);
167   \textcolor{keywordflow}{for} (Ipv6RoutingProtocolList::const\_iterator rprotoIter =
168          \hyperlink{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{m\_routingProtocols}.begin ();
169        rprotoIter != \hyperlink{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{m\_routingProtocols}.end ();
170        rprotoIter++)
171     \{
172       (*rprotoIter).second->NotifyAddAddress (interface, address);
173     \}
174 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}!Notify\+Add\+Route@{Notify\+Add\+Route}}
\index{Notify\+Add\+Route@{Notify\+Add\+Route}!ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}}
\subsubsection[{\texorpdfstring{Notify\+Add\+Route(\+Ipv6\+Address dst, Ipv6\+Prefix mask, Ipv6\+Address next\+Hop, uint32\+\_\+t interface, Ipv6\+Address prefix\+To\+Use=\+Ipv6\+Address\+::\+Get\+Zero())}{NotifyAddRoute(Ipv6Address dst, Ipv6Prefix mask, Ipv6Address nextHop, uint32_t interface, Ipv6Address prefixToUse=Ipv6Address::GetZero())}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+List\+Routing\+::\+Notify\+Add\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{dst, }
\item[{{\bf Ipv6\+Prefix}}]{mask, }
\item[{{\bf Ipv6\+Address}}]{next\+Hop, }
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv6\+Address}}]{prefix\+To\+Use = {\ttfamily {\bf Ipv6\+Address\+::\+Get\+Zero}()}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6ListRouting_a39dddd9618719875abab8c2ed9eed081}{}\label{classns3_1_1Ipv6ListRouting_a39dddd9618719875abab8c2ed9eed081}


Notify a new route. 

Typically this is used to add another route from I\+Pv6 stack (i.\+e. I\+C\+M\+Pv6 redirect case, ...). 
\begin{DoxyParams}{Parameters}
{\em dst} & destination address \\
\hline
{\em mask} & destination mask \\
\hline
{\em next\+Hop} & next\+Hop for this destination \\
\hline
{\em interface} & output interface \\
\hline
{\em prefix\+To\+Use} & prefix to use as source with this route \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6RoutingProtocol_ad5fee223bfdac0b1dde05de7702a87cf}{ns3\+::\+Ipv6\+Routing\+Protocol}.


\begin{DoxyCode}
189 \{
190   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << dst << mask << nextHop << interface);
191   \textcolor{keywordflow}{for} (Ipv6RoutingProtocolList::const\_iterator rprotoIter =
192          \hyperlink{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{m\_routingProtocols}.begin ();
193        rprotoIter != \hyperlink{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{m\_routingProtocols}.end ();
194        rprotoIter++)
195     \{
196       (*rprotoIter).second->NotifyAddRoute (dst, mask, nextHop, interface, prefixToUse);
197     \}
198 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}!Notify\+Interface\+Down@{Notify\+Interface\+Down}}
\index{Notify\+Interface\+Down@{Notify\+Interface\+Down}!ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}}
\subsubsection[{\texorpdfstring{Notify\+Interface\+Down(uint32\+\_\+t interface)}{NotifyInterfaceDown(uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+List\+Routing\+::\+Notify\+Interface\+Down (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6ListRouting_a24b3d4068e036c349699901558f0471c}{}\label{classns3_1_1Ipv6ListRouting_a24b3d4068e036c349699901558f0471c}


Notify when specified interface goes D\+O\+WN. 

Protocols are expected to implement this method to be notified of the state change of an interface in a node. 
\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6RoutingProtocol_aa9b4c21a3878a1b808c9ac9d26c914bf}{ns3\+::\+Ipv6\+Routing\+Protocol}.


\begin{DoxyCode}
153 \{
154   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << interface);
155   \textcolor{keywordflow}{for} (Ipv6RoutingProtocolList::const\_iterator rprotoIter =
156          \hyperlink{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{m\_routingProtocols}.begin ();
157        rprotoIter != \hyperlink{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{m\_routingProtocols}.end ();
158        rprotoIter++)
159     \{
160       (*rprotoIter).second->NotifyInterfaceDown (interface);
161     \}
162 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}!Notify\+Interface\+Up@{Notify\+Interface\+Up}}
\index{Notify\+Interface\+Up@{Notify\+Interface\+Up}!ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}}
\subsubsection[{\texorpdfstring{Notify\+Interface\+Up(uint32\+\_\+t interface)}{NotifyInterfaceUp(uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+List\+Routing\+::\+Notify\+Interface\+Up (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6ListRouting_afbeeaf6cd4dd9a81354e70617bf88811}{}\label{classns3_1_1Ipv6ListRouting_afbeeaf6cd4dd9a81354e70617bf88811}


Notify when specified interface goes UP. 

Protocols are expected to implement this method to be notified of the state change of an interface in a node. 
\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6RoutingProtocol_a024dd60e2deb864565ba5993efc38300}{ns3\+::\+Ipv6\+Routing\+Protocol}.


\begin{DoxyCode}
141 \{
142   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << interface);
143   \textcolor{keywordflow}{for} (Ipv6RoutingProtocolList::const\_iterator rprotoIter =
144          \hyperlink{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{m\_routingProtocols}.begin ();
145        rprotoIter != \hyperlink{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{m\_routingProtocols}.end ();
146        rprotoIter++)
147     \{
148       (*rprotoIter).second->NotifyInterfaceUp (interface);
149     \}
150 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}!Notify\+Remove\+Address@{Notify\+Remove\+Address}}
\index{Notify\+Remove\+Address@{Notify\+Remove\+Address}!ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}}
\subsubsection[{\texorpdfstring{Notify\+Remove\+Address(uint32\+\_\+t interface, Ipv6\+Interface\+Address address)}{NotifyRemoveAddress(uint32_t interface, Ipv6InterfaceAddress address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+List\+Routing\+::\+Notify\+Remove\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv6\+Interface\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6ListRouting_a46e2cf52e8552cc0b3373c6609be27cc}{}\label{classns3_1_1Ipv6ListRouting_a46e2cf52e8552cc0b3373c6609be27cc}


Notify when specified interface add an address. 

Protocols are expected to implement this method to be notified whenever a new address is removed from an interface. Typically used to remove the \textquotesingle{}network route\textquotesingle{} of an interface. Can be invoked on an up or down interface. 
\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
{\em address} & a new address being added to an interface \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6RoutingProtocol_a878ace2f28ea3b07417fe5751d9ec5fc}{ns3\+::\+Ipv6\+Routing\+Protocol}.


\begin{DoxyCode}
177 \{
178   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << interface << address);
179   \textcolor{keywordflow}{for} (Ipv6RoutingProtocolList::const\_iterator rprotoIter =
180          \hyperlink{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{m\_routingProtocols}.begin ();
181        rprotoIter != \hyperlink{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{m\_routingProtocols}.end ();
182        rprotoIter++)
183     \{
184       (*rprotoIter).second->NotifyRemoveAddress (interface, address);
185     \}
186 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}!Notify\+Remove\+Route@{Notify\+Remove\+Route}}
\index{Notify\+Remove\+Route@{Notify\+Remove\+Route}!ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}}
\subsubsection[{\texorpdfstring{Notify\+Remove\+Route(\+Ipv6\+Address dst, Ipv6\+Prefix mask, Ipv6\+Address next\+Hop, uint32\+\_\+t interface, Ipv6\+Address prefix\+To\+Use=\+Ipv6\+Address\+::\+Get\+Zero())}{NotifyRemoveRoute(Ipv6Address dst, Ipv6Prefix mask, Ipv6Address nextHop, uint32_t interface, Ipv6Address prefixToUse=Ipv6Address::GetZero())}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+List\+Routing\+::\+Notify\+Remove\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{dst, }
\item[{{\bf Ipv6\+Prefix}}]{mask, }
\item[{{\bf Ipv6\+Address}}]{next\+Hop, }
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv6\+Address}}]{prefix\+To\+Use = {\ttfamily {\bf Ipv6\+Address\+::\+Get\+Zero}()}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6ListRouting_a10a31c12272e77d51d1fd68b025ad2f5}{}\label{classns3_1_1Ipv6ListRouting_a10a31c12272e77d51d1fd68b025ad2f5}


Notify route removing. 


\begin{DoxyParams}{Parameters}
{\em dst} & destination address \\
\hline
{\em mask} & destination mask \\
\hline
{\em next\+Hop} & next\+Hop for this destination \\
\hline
{\em interface} & output interface \\
\hline
{\em prefix\+To\+Use} & prefix to use as source with this route \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6RoutingProtocol_afcd129c7be3b0fb78012fa68025bf553}{ns3\+::\+Ipv6\+Routing\+Protocol}.


\begin{DoxyCode}
201 \{
202   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << dst << mask << nextHop << interface);
203   \textcolor{keywordflow}{for} (Ipv6RoutingProtocolList::const\_iterator rprotoIter =
204          \hyperlink{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{m\_routingProtocols}.begin ();
205        rprotoIter != \hyperlink{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{m\_routingProtocols}.end ();
206        rprotoIter++)
207     \{
208       (*rprotoIter).second->NotifyRemoveRoute (dst, mask, nextHop, interface, prefixToUse);
209     \}
210 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}!Print\+Routing\+Table@{Print\+Routing\+Table}}
\index{Print\+Routing\+Table@{Print\+Routing\+Table}!ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}}
\subsubsection[{\texorpdfstring{Print\+Routing\+Table(\+Ptr$<$ Output\+Stream\+Wrapper $>$ stream, Time\+::\+Unit unit=\+Time\+::\+S) const }{PrintRoutingTable(Ptr< OutputStreamWrapper > stream, Time::Unit unit=Time::S) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+List\+Routing\+::\+Print\+Routing\+Table (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream, }
\item[{{\bf Time\+::\+Unit}}]{unit = {\ttfamily {\bf Time\+::S}}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6ListRouting_a0c8272a6217b35e37b6e6ac247494890}{}\label{classns3_1_1Ipv6ListRouting_a0c8272a6217b35e37b6e6ac247494890}


Print the Routing Table entries. 


\begin{DoxyParams}{Parameters}
{\em stream} & The ostream the Routing table is printed to \\
\hline
{\em unit} & The time unit to be used in the report \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6RoutingProtocol_a2d5f8412f903a1365a1e84c06ad3da43}{ns3\+::\+Ipv6\+Routing\+Protocol}.


\begin{DoxyCode}
214 \{
215   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
216 
217   *stream->\hyperlink{classns3_1_1OutputStreamWrapper_a0cf30a4188ab6fdae2b2ab74db11acc2}{GetStream} () << \textcolor{stringliteral}{"Node: "} << \hyperlink{classns3_1_1Ipv6ListRouting_af82ea298d92eb8cfcb6c7572e32b517d}{m\_ipv6}->GetObject<Node> ()->GetId ()
218                         << \textcolor{stringliteral}{", Time: "} << \hyperlink{group__simulator_gac3635e2e87f7ce316c89290ee1b01d0d}{Now}().\hyperlink{classns3_1_1Time_a0bb1110638ce9938248bd07865a328ab}{As} (unit)
219                         << \textcolor{stringliteral}{", Local time: "} << GetObject<Node> ()->GetLocalTime ().As (unit)
220                         << \textcolor{stringliteral}{", Ipv6ListRouting table"} << std::endl;
221   \textcolor{keywordflow}{for} (Ipv6RoutingProtocolList::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{m\_routingProtocols}.begin ();
222        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{m\_routingProtocols}.end (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
223     \{
224       *stream->\hyperlink{classns3_1_1OutputStreamWrapper_a0cf30a4188ab6fdae2b2ab74db11acc2}{GetStream} () << \textcolor{stringliteral}{"  Priority: "} << (*i).first << \textcolor{stringliteral}{" Protocol: "} << (*i).second->
      GetInstanceTypeId () << std::endl;
225       (*i).second->PrintRoutingTable (stream, unit);
226     \}
227 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9


\index{ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}!Route\+Input@{Route\+Input}}
\index{Route\+Input@{Route\+Input}!ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}}
\subsubsection[{\texorpdfstring{Route\+Input(\+Ptr$<$ const Packet $>$ p, const Ipv6\+Header \&header, Ptr$<$ const Net\+Device $>$ idev, Unicast\+Forward\+Callback ucb, Multicast\+Forward\+Callback mcb, Local\+Deliver\+Callback lcb, Error\+Callback ecb)}{RouteInput(Ptr< const Packet > p, const Ipv6Header &header, Ptr< const NetDevice > idev, UnicastForwardCallback ucb, MulticastForwardCallback mcb, LocalDeliverCallback lcb, ErrorCallback ecb)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv6\+List\+Routing\+::\+Route\+Input (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv6\+Header} \&}]{header, }
\item[{{\bf Ptr}$<$ const {\bf Net\+Device} $>$}]{idev, }
\item[{{\bf Unicast\+Forward\+Callback}}]{ucb, }
\item[{{\bf Multicast\+Forward\+Callback}}]{mcb, }
\item[{{\bf Local\+Deliver\+Callback}}]{lcb, }
\item[{{\bf Error\+Callback}}]{ecb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6ListRouting_a1b4d7867aad1029308cb7907f75e1035}{}\label{classns3_1_1Ipv6ListRouting_a1b4d7867aad1029308cb7907f75e1035}


Route an input packet (to be forwarded or locally delivered) 

This lookup is used in the forwarding process. The packet is handed over to the \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol}, and will get forwarded onward by one of the callbacks. The Linux equivalent is ip\+\_\+route\+\_\+input (). There are four valid outcomes, and a matching callbacks to handle each.


\begin{DoxyParams}{Parameters}
{\em p} & received packet \\
\hline
{\em header} & input parameter used to form a search key for a route \\
\hline
{\em idev} & Pointer to ingress network device \\
\hline
{\em ucb} & \hyperlink{classns3_1_1Callback}{Callback} for the case in which the packet is to be forwarded as unicast \\
\hline
{\em mcb} & \hyperlink{classns3_1_1Callback}{Callback} for the case in which the packet is to be forwarded as multicast \\
\hline
{\em lcb} & \hyperlink{classns3_1_1Callback}{Callback} for the case in which the packet is to be locally delivered \\
\hline
{\em ecb} & \hyperlink{classns3_1_1Callback}{Callback} to call if there is an error in forwarding \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} takes responsibility for forwarding or delivering the packet, false otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv6RoutingProtocol_a73c66cddf196bf84090305f8d64df33b}{ns3\+::\+Ipv6\+Routing\+Protocol}.


\begin{DoxyCode}
103 \{
104   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} << header << idev);
105   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"RouteInput logic for node: "} << \hyperlink{classns3_1_1Ipv6ListRouting_af82ea298d92eb8cfcb6c7572e32b517d}{m\_ipv6}->GetObject<Node> ()->GetId ());
106 
107   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1Ipv6ListRouting_af82ea298d92eb8cfcb6c7572e32b517d}{m\_ipv6} != 0);
108   \textcolor{comment}{// Check if input device supports IP}
109   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1Ipv6ListRouting_af82ea298d92eb8cfcb6c7572e32b517d}{m\_ipv6}->GetInterfaceForDevice (idev) >= 0);
110   Ipv6Address dst = header.GetDestinationAddress ();
111 
112   \textcolor{comment}{// Check if input device supports IP forwarding}
113   uint32\_t iif = \hyperlink{classns3_1_1Ipv6ListRouting_af82ea298d92eb8cfcb6c7572e32b517d}{m\_ipv6}->GetInterfaceForDevice (idev);
114   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6ListRouting_af82ea298d92eb8cfcb6c7572e32b517d}{m\_ipv6}->IsForwarding (iif) == \textcolor{keyword}{false})
115     \{
116       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Forwarding disabled for this interface"});
117       ecb (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{Socket::ERROR\_NOROUTETOHOST});
118       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
119     \}
120 
121   \textcolor{comment}{// We disable error callback for the called protocols.}
122   \hyperlink{classns3_1_1Ipv6RoutingProtocol_abfdf43594e2ae97e1a4dc340e3a086a5}{ErrorCallback} nullEcb = MakeNullCallback<void, Ptr<const Packet>, \textcolor{keyword}{const} Ipv6Header &, 
      \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket::SocketErrno} > ();
123 
124   \textcolor{keywordflow}{for} (Ipv6RoutingProtocolList::const\_iterator rprotoIter = \hyperlink{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{m\_routingProtocols}.begin ();
125        rprotoIter != \hyperlink{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{m\_routingProtocols}.end ();
126        rprotoIter++)
127     \{
128       \textcolor{keywordflow}{if} ((*rprotoIter).second->RouteInput (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header, idev, ucb, mcb, lcb, nullEcb))
129         \{
130           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
131         \}
132     \}
133 
134   \textcolor{comment}{// No routing protocol has found a route.}
135   ecb (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{Socket::ERROR\_NOROUTETOHOST});
136   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
137 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10


\index{ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}!Route\+Output@{Route\+Output}}
\index{Route\+Output@{Route\+Output}!ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}}
\subsubsection[{\texorpdfstring{Route\+Output(\+Ptr$<$ Packet $>$ p, const Ipv6\+Header \&header, Ptr$<$ Net\+Device $>$ oif, Socket\+::\+Socket\+Errno \&sockerr)}{RouteOutput(Ptr< Packet > p, const Ipv6Header &header, Ptr< NetDevice > oif, Socket::SocketErrno &sockerr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv6\+Route} $>$ ns3\+::\+Ipv6\+List\+Routing\+::\+Route\+Output (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv6\+Header} \&}]{header, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{oif, }
\item[{{\bf Socket\+::\+Socket\+Errno} \&}]{sockerr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6ListRouting_a17dd6df1ef25f2ff410b5ba759b6e5e7}{}\label{classns3_1_1Ipv6ListRouting_a17dd6df1ef25f2ff410b5ba759b6e5e7}


Query routing cache for an existing route, for an outbound packet. 

This lookup is used by transport protocols. It does not cause any packet to be forwarded, and is synchronous. Can be used for multicast or unicast. The Linux equivalent is ip\+\_\+route\+\_\+output ()


\begin{DoxyParams}{Parameters}
{\em p} & packet to be routed. Note that this method may modify the packet. Callers may also pass in a null pointer. \\
\hline
{\em header} & input parameter (used to form key to search for the route) \\
\hline
{\em oif} & Output interface device. May be zero, or may be bound via socket options to a particular output interface. \\
\hline
{\em sockerr} & Output parameter; socket errno\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a code that indicates what happened in the lookup 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv6RoutingProtocol_a92e79a0364ad272392ee635ffe50644d}{ns3\+::\+Ipv6\+Routing\+Protocol}.


\begin{DoxyCode}
75 \{
76   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << header.GetDestinationAddress () << header.GetSourceAddress () << 
      oif);
77   Ptr<Ipv6Route> route;
78 
79   \textcolor{keywordflow}{for} (Ipv6RoutingProtocolList::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{m\_routingProtocols}.begin ();
80        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{m\_routingProtocols}.end (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
81     \{
82       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Checking protocol "} << (*i).second->GetInstanceTypeId () << \textcolor{stringliteral}{" with
       priority "} << (*i).first);
83       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Requesting source address for destination "} << header.
      GetDestinationAddress ());
84       route = (*i).second->RouteOutput (p, header, oif, sockerr);
85       \textcolor{keywordflow}{if} (route)
86         \{
87           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Found route "} << route);
88           sockerr = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaaa7eb006d73c5ad0117c5591fcb3469f7}{Socket::ERROR\_NOTERROR};
89           \textcolor{keywordflow}{return} route;
90         \}
91     \}
92   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Done checking "} << \hyperlink{classns3_1_1Ipv6ListRouting_a2a1e3ee20de076b049451e4a675e438b}{GetTypeId} ());
93   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{""});
94   sockerr = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{Socket::ERROR\_NOROUTETOHOST};
95   \textcolor{keywordflow}{return} 0;
96 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 11


\index{ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}!Set\+Ipv6@{Set\+Ipv6}}
\index{Set\+Ipv6@{Set\+Ipv6}!ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}}
\subsubsection[{\texorpdfstring{Set\+Ipv6(\+Ptr$<$ Ipv6 $>$ ipv6)}{SetIpv6(Ptr< Ipv6 > ipv6)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+List\+Routing\+::\+Set\+Ipv6 (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv6} $>$}]{ipv6}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6ListRouting_ac660375f36097f4c760a2cc5e6f4aa8a}{}\label{classns3_1_1Ipv6ListRouting_ac660375f36097f4c760a2cc5e6f4aa8a}


Typically, invoked directly or indirectly from \hyperlink{classns3_1_1Ipv6_aa889d2174527a1df773d65974de83f8f}{ns3\+::\+Ipv6\+::\+Set\+Routing\+Protocol}. 


\begin{DoxyParams}{Parameters}
{\em ipv6} & the ipv6 object this routing protocol is being associated with \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6RoutingProtocol_ab97e8194b12a2db1d1374fc881974903}{ns3\+::\+Ipv6\+Routing\+Protocol}.


\begin{DoxyCode}
231 \{
232   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << ipv6);
233   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1Ipv6ListRouting_af82ea298d92eb8cfcb6c7572e32b517d}{m\_ipv6} == 0);
234   \textcolor{keywordflow}{for} (Ipv6RoutingProtocolList::const\_iterator rprotoIter =
235          \hyperlink{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{m\_routingProtocols}.begin ();
236        rprotoIter != \hyperlink{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{m\_routingProtocols}.end ();
237        rprotoIter++)
238     \{
239       (*rprotoIter).second->SetIpv6 (ipv6);
240     \}
241   \hyperlink{classns3_1_1Ipv6ListRouting_af82ea298d92eb8cfcb6c7572e32b517d}{m\_ipv6} = ipv6;
242 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}!m\+\_\+ipv6@{m\+\_\+ipv6}}
\index{m\+\_\+ipv6@{m\+\_\+ipv6}!ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+ipv6}{m_ipv6}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Ipv6}$>$ ns3\+::\+Ipv6\+List\+Routing\+::m\+\_\+ipv6\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6ListRouting_af82ea298d92eb8cfcb6c7572e32b517d}{}\label{classns3_1_1Ipv6ListRouting_af82ea298d92eb8cfcb6c7572e32b517d}


\hyperlink{classns3_1_1Ipv6}{Ipv6} this protocol is associated with. 

\index{ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}!m\+\_\+routing\+Protocols@{m\+\_\+routing\+Protocols}}
\index{m\+\_\+routing\+Protocols@{m\+\_\+routing\+Protocols}!ns3\+::\+Ipv6\+List\+Routing@{ns3\+::\+Ipv6\+List\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+routing\+Protocols}{m_routingProtocols}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+Routing\+Protocol\+List} ns3\+::\+Ipv6\+List\+Routing\+::m\+\_\+routing\+Protocols\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}{}\label{classns3_1_1Ipv6ListRouting_aec46de403a1c73088ce952d7cbd804e8}


List of routing protocols. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/model/\hyperlink{ipv6-list-routing_8h}{ipv6-\/list-\/routing.\+h}\item 
internet/model/\hyperlink{ipv6-list-routing_8cc}{ipv6-\/list-\/routing.\+cc}\end{DoxyCompactItemize}
