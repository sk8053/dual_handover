\hypertarget{classns3_1_1Ipv6StaticRoutingHelper}{}\section{ns3\+:\+:Ipv6\+Static\+Routing\+Helper Class Reference}
\label{classns3_1_1Ipv6StaticRoutingHelper}\index{ns3\+::\+Ipv6\+Static\+Routing\+Helper@{ns3\+::\+Ipv6\+Static\+Routing\+Helper}}


Helper class that adds \hyperlink{classns3_1_1Ipv6StaticRouting}{ns3\+::\+Ipv6\+Static\+Routing} objects.  




{\ttfamily \#include $<$ipv6-\/static-\/routing-\/helper.\+h$>$}



Inheritance diagram for ns3\+:\+:Ipv6\+Static\+Routing\+Helper\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Ipv6\+Static\+Routing\+Helper\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ipv6StaticRoutingHelper_ae72254093470eae64213505e1a17c567}{Ipv6\+Static\+Routing\+Helper} ()
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6StaticRoutingHelper_ad6606fcb427f3261f2d2d9d2c5ab5c8b}{Ipv6\+Static\+Routing\+Helper} (const \hyperlink{classns3_1_1Ipv6StaticRoutingHelper}{Ipv6\+Static\+Routing\+Helper} \&)
\begin{DoxyCompactList}\small\item\em Construct an \hyperlink{classns3_1_1Ipv6ListRoutingHelper}{Ipv6\+List\+Routing\+Helper} from another previously initialized instance (Copy Constructor). \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6StaticRoutingHelper}{Ipv6\+Static\+Routing\+Helper} $\ast$ \hyperlink{classns3_1_1Ipv6StaticRoutingHelper_a984170f1188bad7e980a21c81990a304}{Copy} (void) const 
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} $>$ \hyperlink{classns3_1_1Ipv6StaticRoutingHelper_aeed733513c2f46bbe03fcd2c0370f493}{Create} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node) const 
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6StaticRouting}{Ipv6\+Static\+Routing} $>$ \hyperlink{classns3_1_1Ipv6StaticRoutingHelper_a50e42745077d7bcfd371df331879fae9}{Get\+Static\+Routing} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6}{Ipv6} $>$ ipv6) const 
\begin{DoxyCompactList}\small\item\em Get \hyperlink{classns3_1_1Ipv6StaticRouting}{Ipv6\+Static\+Routing} pointer from I\+Pv6 stack. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6StaticRoutingHelper_a65007098b4ba329479010f5bbba3eb90}{Add\+Multicast\+Route} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_abdb05bc5a064cf642a06c83b3392f148}{n}, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} source, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} group, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ input, \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} output)
\begin{DoxyCompactList}\small\item\em Add a multicast route to a node and net device using explicit \hyperlink{classns3_1_1Ptr}{Ptr$<$\+Node$>$} and Ptr$<$\+Net\+Device$>$ \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6StaticRoutingHelper_a5818d6d0d82274eb444b8c0d74d37516}{Add\+Multicast\+Route} (std\+::string \hyperlink{lte__link__budget__x2__handover__measures_8m_abdb05bc5a064cf642a06c83b3392f148}{n}, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} source, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} group, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ input, \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} output)
\begin{DoxyCompactList}\small\item\em Add a multicast route to a node and device using a name string previously associated to the node using the \hyperlink{classns3_1_1Object}{Object} Name Service and a Ptr$<$\+Net\+Device$>$ \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6StaticRoutingHelper_a0712124ec79872a665e3532d43c1e640}{Add\+Multicast\+Route} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_abdb05bc5a064cf642a06c83b3392f148}{n}, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} source, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} group, std\+::string input\+Name, \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} output)
\begin{DoxyCompactList}\small\item\em Add a multicast route to a node and device using a \hyperlink{classns3_1_1Ptr}{Ptr$<$\+Node$>$} and a name string previously associated to the device using the \hyperlink{classns3_1_1Object}{Object} Name Service. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6StaticRoutingHelper_a7d5f7ed76864b25e72dbb79a3faee717}{Add\+Multicast\+Route} (std\+::string n\+Name, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} source, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} group, std\+::string input\+Name, \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} output)
\begin{DoxyCompactList}\small\item\em Add a multicast route to a node and device using name strings previously associated to both the node and device using the \hyperlink{classns3_1_1Object}{Object} Name Service. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ipv6StaticRoutingHelper}{Ipv6\+Static\+Routing\+Helper} \& \hyperlink{classns3_1_1Ipv6StaticRoutingHelper_ad535a8baed5924433c8dc73202707661}{operator=} (const \hyperlink{classns3_1_1Ipv6StaticRoutingHelper}{Ipv6\+Static\+Routing\+Helper} \&o)
\begin{DoxyCompactList}\small\item\em Assignment operator declared private and not implemented to disallow assignment and prevent the compiler from happily inserting its own. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Helper class that adds \hyperlink{classns3_1_1Ipv6StaticRouting}{ns3\+::\+Ipv6\+Static\+Routing} objects. 

This class is expected to be used in conjunction with \hyperlink{classns3_1_1InternetStackHelper_a3e382c02df022dec79952a7eca8cd5ba}{ns3\+::\+Internet\+Stack\+Helper\+::\+Set\+Routing\+Helper} 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Ipv6\+Static\+Routing\+Helper@{ns3\+::\+Ipv6\+Static\+Routing\+Helper}!Ipv6\+Static\+Routing\+Helper@{Ipv6\+Static\+Routing\+Helper}}
\index{Ipv6\+Static\+Routing\+Helper@{Ipv6\+Static\+Routing\+Helper}!ns3\+::\+Ipv6\+Static\+Routing\+Helper@{ns3\+::\+Ipv6\+Static\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Ipv6\+Static\+Routing\+Helper()}{Ipv6StaticRoutingHelper()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv6\+Static\+Routing\+Helper\+::\+Ipv6\+Static\+Routing\+Helper (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6StaticRoutingHelper_ae72254093470eae64213505e1a17c567}{}\label{classns3_1_1Ipv6StaticRoutingHelper_ae72254093470eae64213505e1a17c567}


Constructor. 


\begin{DoxyCode}
39 \{
40 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 2


\index{ns3\+::\+Ipv6\+Static\+Routing\+Helper@{ns3\+::\+Ipv6\+Static\+Routing\+Helper}!Ipv6\+Static\+Routing\+Helper@{Ipv6\+Static\+Routing\+Helper}}
\index{Ipv6\+Static\+Routing\+Helper@{Ipv6\+Static\+Routing\+Helper}!ns3\+::\+Ipv6\+Static\+Routing\+Helper@{ns3\+::\+Ipv6\+Static\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Ipv6\+Static\+Routing\+Helper(const Ipv6\+Static\+Routing\+Helper \&)}{Ipv6StaticRoutingHelper(const Ipv6StaticRoutingHelper &)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv6\+Static\+Routing\+Helper\+::\+Ipv6\+Static\+Routing\+Helper (
\begin{DoxyParamCaption}
\item[{const {\bf Ipv6\+Static\+Routing\+Helper} \&}]{o}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6StaticRoutingHelper_ad6606fcb427f3261f2d2d9d2c5ab5c8b}{}\label{classns3_1_1Ipv6StaticRoutingHelper_ad6606fcb427f3261f2d2d9d2c5ab5c8b}


Construct an \hyperlink{classns3_1_1Ipv6ListRoutingHelper}{Ipv6\+List\+Routing\+Helper} from another previously initialized instance (Copy Constructor). 


\begin{DoxyCode}
43 \{
44 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Ipv6\+Static\+Routing\+Helper@{ns3\+::\+Ipv6\+Static\+Routing\+Helper}!Add\+Multicast\+Route@{Add\+Multicast\+Route}}
\index{Add\+Multicast\+Route@{Add\+Multicast\+Route}!ns3\+::\+Ipv6\+Static\+Routing\+Helper@{ns3\+::\+Ipv6\+Static\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Add\+Multicast\+Route(\+Ptr$<$ Node $>$ n, Ipv6\+Address source, Ipv6\+Address group, Ptr$<$ Net\+Device $>$ input, Net\+Device\+Container output)}{AddMulticastRoute(Ptr< Node > n, Ipv6Address source, Ipv6Address group, Ptr< NetDevice > input, NetDeviceContainer output)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Static\+Routing\+Helper\+::\+Add\+Multicast\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{n, }
\item[{{\bf Ipv6\+Address}}]{source, }
\item[{{\bf Ipv6\+Address}}]{group, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{input, }
\item[{{\bf Net\+Device\+Container}}]{output}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6StaticRoutingHelper_a65007098b4ba329479010f5bbba3eb90}{}\label{classns3_1_1Ipv6StaticRoutingHelper_a65007098b4ba329479010f5bbba3eb90}


Add a multicast route to a node and net device using explicit \hyperlink{classns3_1_1Ptr}{Ptr$<$\+Node$>$} and Ptr$<$\+Net\+Device$>$ 


\begin{DoxyParams}{Parameters}
{\em n} & The node. \\
\hline
{\em source} & Source address. \\
\hline
{\em group} & Multicast group. \\
\hline
{\em input} & Input \hyperlink{classns3_1_1NetDevice}{Net\+Device}. \\
\hline
{\em output} & Output Net\+Devices. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
95 \{
96   Ptr<Ipv6> ipv6 = n->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv6> ();
97 
98   \textcolor{comment}{// We need to convert the NetDeviceContainer to an array of interface }
99   \textcolor{comment}{// numbers}
100   std::vector<uint32\_t> outputInterfaces;
101   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1NetDeviceContainer_a45709bb572f975569ed985fa89b132f8}{NetDeviceContainer::Iterator} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = output.Begin (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != output.End (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
102     \{
103       Ptr<NetDevice> nd = *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
104       int32\_t \textcolor{keyword}{interface }= ipv6->GetInterfaceForDevice (nd);
105       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (interface >= 0, 
106                      \textcolor{stringliteral}{"Ipv6StaticRoutingHelper::AddMulticastRoute (): "}
107                      \textcolor{stringliteral}{"Expected an interface associated with the device nd"});
108       outputInterfaces.push\_back (interface);
109     \}
110 
111   int32\_t inputInterface = ipv6->GetInterfaceForDevice (input);
112   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (inputInterface >= 0, 
113                  \textcolor{stringliteral}{"Ipv6StaticRoutingHelper::AddMulticastRoute (): "}
114                  \textcolor{stringliteral}{"Expected an interface associated with the device input"});
115   \hyperlink{classns3_1_1Ipv6StaticRoutingHelper_ae72254093470eae64213505e1a17c567}{Ipv6StaticRoutingHelper} helper;
116   Ptr<Ipv6StaticRouting> ipv6StaticRouting = helper.GetStaticRouting (ipv6);
117   \textcolor{keywordflow}{if} (!ipv6StaticRouting)
118     \{
119       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (ipv6StaticRouting,
120                      \textcolor{stringliteral}{"Ipv6StaticRoutingHelper::SetDefaultMulticastRoute (): "}
121                      \textcolor{stringliteral}{"Expected an Ipv6StaticRouting associated with this node"});
122     \}
123   ipv6StaticRouting->AddMulticastRoute (source, \hyperlink{namespacevisualizer_1_1higcontainer_aa6ad2b76790275bfce7783429beaa23f}{group}, inputInterface, outputInterfaces);
124 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3




Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::\+Ipv6\+Static\+Routing\+Helper@{ns3\+::\+Ipv6\+Static\+Routing\+Helper}!Add\+Multicast\+Route@{Add\+Multicast\+Route}}
\index{Add\+Multicast\+Route@{Add\+Multicast\+Route}!ns3\+::\+Ipv6\+Static\+Routing\+Helper@{ns3\+::\+Ipv6\+Static\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Add\+Multicast\+Route(std\+::string n, Ipv6\+Address source, Ipv6\+Address group, Ptr$<$ Net\+Device $>$ input, Net\+Device\+Container output)}{AddMulticastRoute(std::string n, Ipv6Address source, Ipv6Address group, Ptr< NetDevice > input, NetDeviceContainer output)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Static\+Routing\+Helper\+::\+Add\+Multicast\+Route (
\begin{DoxyParamCaption}
\item[{std\+::string}]{n, }
\item[{{\bf Ipv6\+Address}}]{source, }
\item[{{\bf Ipv6\+Address}}]{group, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{input, }
\item[{{\bf Net\+Device\+Container}}]{output}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6StaticRoutingHelper_a5818d6d0d82274eb444b8c0d74d37516}{}\label{classns3_1_1Ipv6StaticRoutingHelper_a5818d6d0d82274eb444b8c0d74d37516}


Add a multicast route to a node and device using a name string previously associated to the node using the \hyperlink{classns3_1_1Object}{Object} Name Service and a Ptr$<$\+Net\+Device$>$ 


\begin{DoxyParams}{Parameters}
{\em n} & The node. \\
\hline
{\em source} & Source address. \\
\hline
{\em group} & Multicast group. \\
\hline
{\em input} & Input \hyperlink{classns3_1_1NetDevice}{Net\+Device}. \\
\hline
{\em output} & Output Net\+Devices. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
145 \{
146   Ptr<Node> \hyperlink{namespacesample-rng-plot_aeb5ee5c431e338ef39b7ac5431242e1d}{n} = Names::Find<Node> (nName);
147   \hyperlink{classns3_1_1Ipv6StaticRoutingHelper_a65007098b4ba329479010f5bbba3eb90}{AddMulticastRoute} (n, source, \hyperlink{namespacevisualizer_1_1higcontainer_aa6ad2b76790275bfce7783429beaa23f}{group}, input, output);
148 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5


\index{ns3\+::\+Ipv6\+Static\+Routing\+Helper@{ns3\+::\+Ipv6\+Static\+Routing\+Helper}!Add\+Multicast\+Route@{Add\+Multicast\+Route}}
\index{Add\+Multicast\+Route@{Add\+Multicast\+Route}!ns3\+::\+Ipv6\+Static\+Routing\+Helper@{ns3\+::\+Ipv6\+Static\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Add\+Multicast\+Route(\+Ptr$<$ Node $>$ n, Ipv6\+Address source, Ipv6\+Address group, std\+::string input\+Name, Net\+Device\+Container output)}{AddMulticastRoute(Ptr< Node > n, Ipv6Address source, Ipv6Address group, std::string inputName, NetDeviceContainer output)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Static\+Routing\+Helper\+::\+Add\+Multicast\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{n, }
\item[{{\bf Ipv6\+Address}}]{source, }
\item[{{\bf Ipv6\+Address}}]{group, }
\item[{std\+::string}]{input\+Name, }
\item[{{\bf Net\+Device\+Container}}]{output}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6StaticRoutingHelper_a0712124ec79872a665e3532d43c1e640}{}\label{classns3_1_1Ipv6StaticRoutingHelper_a0712124ec79872a665e3532d43c1e640}


Add a multicast route to a node and device using a \hyperlink{classns3_1_1Ptr}{Ptr$<$\+Node$>$} and a name string previously associated to the device using the \hyperlink{classns3_1_1Object}{Object} Name Service. 


\begin{DoxyParams}{Parameters}
{\em n} & The node. \\
\hline
{\em source} & Source address. \\
\hline
{\em group} & Multicast group. \\
\hline
{\em input\+Name} & Input \hyperlink{classns3_1_1NetDevice}{Net\+Device}. \\
\hline
{\em output} & Output Net\+Devices. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
133 \{
134   Ptr<NetDevice> input = Names::Find<NetDevice> (inputName);
135   \hyperlink{classns3_1_1Ipv6StaticRoutingHelper_a65007098b4ba329479010f5bbba3eb90}{AddMulticastRoute} (n, source, \hyperlink{namespacevisualizer_1_1higcontainer_aa6ad2b76790275bfce7783429beaa23f}{group}, input, output);
136 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6


\index{ns3\+::\+Ipv6\+Static\+Routing\+Helper@{ns3\+::\+Ipv6\+Static\+Routing\+Helper}!Add\+Multicast\+Route@{Add\+Multicast\+Route}}
\index{Add\+Multicast\+Route@{Add\+Multicast\+Route}!ns3\+::\+Ipv6\+Static\+Routing\+Helper@{ns3\+::\+Ipv6\+Static\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Add\+Multicast\+Route(std\+::string n\+Name, Ipv6\+Address source, Ipv6\+Address group, std\+::string input\+Name, Net\+Device\+Container output)}{AddMulticastRoute(std::string nName, Ipv6Address source, Ipv6Address group, std::string inputName, NetDeviceContainer output)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Static\+Routing\+Helper\+::\+Add\+Multicast\+Route (
\begin{DoxyParamCaption}
\item[{std\+::string}]{n\+Name, }
\item[{{\bf Ipv6\+Address}}]{source, }
\item[{{\bf Ipv6\+Address}}]{group, }
\item[{std\+::string}]{input\+Name, }
\item[{{\bf Net\+Device\+Container}}]{output}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6StaticRoutingHelper_a7d5f7ed76864b25e72dbb79a3faee717}{}\label{classns3_1_1Ipv6StaticRoutingHelper_a7d5f7ed76864b25e72dbb79a3faee717}


Add a multicast route to a node and device using name strings previously associated to both the node and device using the \hyperlink{classns3_1_1Object}{Object} Name Service. 


\begin{DoxyParams}{Parameters}
{\em n\+Name} & The node. \\
\hline
{\em source} & Source address. \\
\hline
{\em group} & Multicast group. \\
\hline
{\em input\+Name} & Input \hyperlink{classns3_1_1NetDevice}{Net\+Device}. \\
\hline
{\em output} & Output Net\+Devices. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
157 \{
158   Ptr<NetDevice> input = Names::Find<NetDevice> (inputName);
159   Ptr<Node> \hyperlink{namespacesample-rng-plot_aeb5ee5c431e338ef39b7ac5431242e1d}{n} = Names::Find<Node> (nName);
160   \hyperlink{classns3_1_1Ipv6StaticRoutingHelper_a65007098b4ba329479010f5bbba3eb90}{AddMulticastRoute} (n, source, \hyperlink{namespacevisualizer_1_1higcontainer_aa6ad2b76790275bfce7783429beaa23f}{group}, input, output);
161 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7


\index{ns3\+::\+Ipv6\+Static\+Routing\+Helper@{ns3\+::\+Ipv6\+Static\+Routing\+Helper}!Copy@{Copy}}
\index{Copy@{Copy}!ns3\+::\+Ipv6\+Static\+Routing\+Helper@{ns3\+::\+Ipv6\+Static\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Copy(void) const }{Copy(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+Static\+Routing\+Helper} $\ast$ ns3\+::\+Ipv6\+Static\+Routing\+Helper\+::\+Copy (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6StaticRoutingHelper_a984170f1188bad7e980a21c81990a304}{}\label{classns3_1_1Ipv6StaticRoutingHelper_a984170f1188bad7e980a21c81990a304}
\begin{DoxyReturn}{Returns}
pointer to clone of this \hyperlink{classns3_1_1Ipv6StaticRoutingHelper}{Ipv6\+Static\+Routing\+Helper}
\end{DoxyReturn}
This method is mainly for internal use by the other helpers; clients are expected to free the dynamic memory allocated by this method 

Implements \hyperlink{classns3_1_1Ipv6RoutingHelper_a324f924df9565843a0964e844e35927c}{ns3\+::\+Ipv6\+Routing\+Helper}.


\begin{DoxyCode}
48 \{
49   \textcolor{keywordflow}{return} \textcolor{keyword}{new} \hyperlink{classns3_1_1Ipv6StaticRoutingHelper_ae72254093470eae64213505e1a17c567}{Ipv6StaticRoutingHelper} (*\textcolor{keyword}{this});
50 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8


\index{ns3\+::\+Ipv6\+Static\+Routing\+Helper@{ns3\+::\+Ipv6\+Static\+Routing\+Helper}!Create@{Create}}
\index{Create@{Create}!ns3\+::\+Ipv6\+Static\+Routing\+Helper@{ns3\+::\+Ipv6\+Static\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Create(\+Ptr$<$ Node $>$ node) const }{Create(Ptr< Node > node) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv6\+Routing\+Protocol} $>$ ns3\+::\+Ipv6\+Static\+Routing\+Helper\+::\+Create (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6StaticRoutingHelper_aeed733513c2f46bbe03fcd2c0370f493}{}\label{classns3_1_1Ipv6StaticRoutingHelper_aeed733513c2f46bbe03fcd2c0370f493}

\begin{DoxyParams}{Parameters}
{\em node} & the node on which the routing protocol will run \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a newly-\/created routing protocol
\end{DoxyReturn}
This method will be called by \hyperlink{classns3_1_1InternetStackHelper_a6645b412f31283d2d9bc3d8a95cebbc0}{ns3\+::\+Internet\+Stack\+Helper\+::\+Install} 

Implements \hyperlink{classns3_1_1Ipv6RoutingHelper_aee8501a0e661843ccf9da08e3e56614b}{ns3\+::\+Ipv6\+Routing\+Helper}.


\begin{DoxyCode}
54 \{
55   \textcolor{keywordflow}{return} CreateObject<Ipv6StaticRouting> ();
56 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+Static\+Routing\+Helper@{ns3\+::\+Ipv6\+Static\+Routing\+Helper}!Get\+Static\+Routing@{Get\+Static\+Routing}}
\index{Get\+Static\+Routing@{Get\+Static\+Routing}!ns3\+::\+Ipv6\+Static\+Routing\+Helper@{ns3\+::\+Ipv6\+Static\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Get\+Static\+Routing(\+Ptr$<$ Ipv6 $>$ ipv6) const }{GetStaticRouting(Ptr< Ipv6 > ipv6) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv6\+Static\+Routing} $>$ ns3\+::\+Ipv6\+Static\+Routing\+Helper\+::\+Get\+Static\+Routing (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv6} $>$}]{ipv6}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv6StaticRoutingHelper_a50e42745077d7bcfd371df331879fae9}{}\label{classns3_1_1Ipv6StaticRoutingHelper_a50e42745077d7bcfd371df331879fae9}


Get \hyperlink{classns3_1_1Ipv6StaticRouting}{Ipv6\+Static\+Routing} pointer from I\+Pv6 stack. 


\begin{DoxyParams}{Parameters}
{\em ipv6} & \hyperlink{classns3_1_1Ipv6}{Ipv6} pointer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{classns3_1_1Ipv6StaticRouting}{Ipv6\+Static\+Routing} pointer or 0 if not found 
\end{DoxyReturn}

\begin{DoxyCode}
60 \{
61   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
62   Ptr<Ipv6RoutingProtocol> ipv6rp = ipv6->GetRoutingProtocol ();
63   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (ipv6rp, \textcolor{stringliteral}{"No routing protocol associated with Ipv6"});
64   \textcolor{keywordflow}{if} (DynamicCast<Ipv6StaticRouting> (ipv6rp))
65     \{
66       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Static routing found as the main IPv4 routing protocol."});
67       \textcolor{keywordflow}{return} DynamicCast<Ipv6StaticRouting> (ipv6rp); 
68     \} 
69   \textcolor{keywordflow}{if} (DynamicCast<Ipv6ListRouting> (ipv6rp))
70     \{
71       Ptr<Ipv6ListRouting> lrp = DynamicCast<Ipv6ListRouting> (ipv6rp);
72       int16\_t priority;
73       \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < lrp->GetNRoutingProtocols ();  \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
74         \{
75           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Searching for static routing in list"});
76           Ptr<Ipv6RoutingProtocol> temp = lrp->GetRoutingProtocol (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, priority);
77           \textcolor{keywordflow}{if} (DynamicCast<Ipv6StaticRouting> (temp))
78             \{
79               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Found static routing in list"});
80               \textcolor{keywordflow}{return} DynamicCast<Ipv6StaticRouting> (temp);
81             \}
82         \}
83     \}
84   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Static routing not found"});
85   \textcolor{keywordflow}{return} 0;
86 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 9


\index{ns3\+::\+Ipv6\+Static\+Routing\+Helper@{ns3\+::\+Ipv6\+Static\+Routing\+Helper}!operator=@{operator=}}
\index{operator=@{operator=}!ns3\+::\+Ipv6\+Static\+Routing\+Helper@{ns3\+::\+Ipv6\+Static\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{operator=(const Ipv6\+Static\+Routing\+Helper \&o)}{operator=(const Ipv6StaticRoutingHelper &o)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+Static\+Routing\+Helper}\& ns3\+::\+Ipv6\+Static\+Routing\+Helper\+::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf Ipv6\+Static\+Routing\+Helper} \&}]{o}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6StaticRoutingHelper_ad535a8baed5924433c8dc73202707661}{}\label{classns3_1_1Ipv6StaticRoutingHelper_ad535a8baed5924433c8dc73202707661}


Assignment operator declared private and not implemented to disallow assignment and prevent the compiler from happily inserting its own. 


\begin{DoxyParams}{Parameters}
{\em o} & object to copy from \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a reference to the new object 
\end{DoxyReturn}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/helper/\hyperlink{ipv6-static-routing-helper_8h}{ipv6-\/static-\/routing-\/helper.\+h}\item 
internet/helper/\hyperlink{ipv6-static-routing-helper_8cc}{ipv6-\/static-\/routing-\/helper.\+cc}\end{DoxyCompactItemize}
