\hypertarget{classns3_1_1FdNetDeviceHelper}{}\section{ns3\+:\+:Fd\+Net\+Device\+Helper Class Reference}
\label{classns3_1_1FdNetDeviceHelper}\index{ns3\+::\+Fd\+Net\+Device\+Helper@{ns3\+::\+Fd\+Net\+Device\+Helper}}


build a set of \hyperlink{classns3_1_1FdNetDevice}{Fd\+Net\+Device} objects Normally we eschew multiple inheritance, however, the classes Pcap\+User\+Helper\+For\+Device and Ascii\+Trace\+User\+Helper\+For\+Device are treated as \char`\"{}mixins\char`\"{}. A mixin is a self-\/contained class that encapsulates a general attribute or a set of functionality that may be of interest to many other classes.  




{\ttfamily \#include $<$fd-\/net-\/device-\/helper.\+h$>$}



Inheritance diagram for ns3\+:\+:Fd\+Net\+Device\+Helper\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Fd\+Net\+Device\+Helper\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1FdNetDeviceHelper_a9aaeaa49939e9212ce16f11345e2e4eb}{Fd\+Net\+Device\+Helper} ()
\item 
virtual \hyperlink{classns3_1_1FdNetDeviceHelper_a8018d2553649901a9f37ccc9ef3385e2}{$\sim$\+Fd\+Net\+Device\+Helper} ()
\item 
void \hyperlink{classns3_1_1FdNetDeviceHelper_a0274f52a7b4288ca58f04fc2ac31d398}{Set\+Attribute} (std\+::string n1, const \hyperlink{classns3_1_1AttributeValue}{Attribute\+Value} \&v1)
\item 
virtual \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} \hyperlink{classns3_1_1FdNetDeviceHelper_af70d55cbb4f6411c33cacb84eb651ad5}{Install} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node) const 
\item 
virtual \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} \hyperlink{classns3_1_1FdNetDeviceHelper_ab7e70ab5e273b32a5cf3519674f1cc4e}{Install} (std\+::string \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name}) const 
\item 
virtual \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} \hyperlink{classns3_1_1FdNetDeviceHelper_a9f9355b6beaa030c7fab05b3eb3b4952}{Install} (const \hyperlink{classns3_1_1NodeContainer}{Node\+Container} \&\hyperlink{mmwave_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c}) const 
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ \hyperlink{classns3_1_1FdNetDeviceHelper_adf0e4f64b03f7203f7080b50f412a970}{Install\+Priv} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node) const 
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1FdNetDeviceHelper_ad2438701b5de250057f690ad9c88a693}{Enable\+Pcap\+Internal} (std\+::string prefix, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ nd, bool promiscuous, bool explicit\+Filename)
\begin{DoxyCompactList}\small\item\em Enable pcap output on the indicated net device. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1FdNetDeviceHelper_ae302a206158bfda94ddea64b711854d2}{Enable\+Ascii\+Internal} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream, std\+::string prefix, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ nd, bool explicit\+Filename)
\begin{DoxyCompactList}\small\item\em Enable ascii trace output on the indicated net device. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1ObjectFactory}{Object\+Factory} \hyperlink{classns3_1_1FdNetDeviceHelper_a68ff62237281b17bbd72fde746ce6826}{m\+\_\+device\+Factory}
\begin{DoxyCompactList}\small\item\em factory for the Net\+Devices \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
build a set of \hyperlink{classns3_1_1FdNetDevice}{Fd\+Net\+Device} objects Normally we eschew multiple inheritance, however, the classes Pcap\+User\+Helper\+For\+Device and Ascii\+Trace\+User\+Helper\+For\+Device are treated as \char`\"{}mixins\char`\"{}. A mixin is a self-\/contained class that encapsulates a general attribute or a set of functionality that may be of interest to many other classes. 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Fd\+Net\+Device\+Helper@{ns3\+::\+Fd\+Net\+Device\+Helper}!Fd\+Net\+Device\+Helper@{Fd\+Net\+Device\+Helper}}
\index{Fd\+Net\+Device\+Helper@{Fd\+Net\+Device\+Helper}!ns3\+::\+Fd\+Net\+Device\+Helper@{ns3\+::\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{Fd\+Net\+Device\+Helper()}{FdNetDeviceHelper()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Fd\+Net\+Device\+Helper\+::\+Fd\+Net\+Device\+Helper (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1FdNetDeviceHelper_a9aaeaa49939e9212ce16f11345e2e4eb}{}\label{classns3_1_1FdNetDeviceHelper_a9aaeaa49939e9212ce16f11345e2e4eb}
Construct a \hyperlink{classns3_1_1FdNetDeviceHelper}{Fd\+Net\+Device\+Helper}. 
\begin{DoxyCode}
41 \{
42   \hyperlink{classns3_1_1FdNetDeviceHelper_a68ff62237281b17bbd72fde746ce6826}{m\_deviceFactory}.\hyperlink{classns3_1_1ObjectFactory_a77dcd099064038a1eb7a6b8251229ec3}{SetTypeId} (\textcolor{stringliteral}{"ns3::FdNetDevice"});
43 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Fd\+Net\+Device\+Helper@{ns3\+::\+Fd\+Net\+Device\+Helper}!````~Fd\+Net\+Device\+Helper@{$\sim$\+Fd\+Net\+Device\+Helper}}
\index{````~Fd\+Net\+Device\+Helper@{$\sim$\+Fd\+Net\+Device\+Helper}!ns3\+::\+Fd\+Net\+Device\+Helper@{ns3\+::\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{$\sim$\+Fd\+Net\+Device\+Helper()}{~FdNetDeviceHelper()}}]{\setlength{\rightskip}{0pt plus 5cm}virtual ns3\+::\+Fd\+Net\+Device\+Helper\+::$\sim$\+Fd\+Net\+Device\+Helper (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDeviceHelper_a8018d2553649901a9f37ccc9ef3385e2}{}\label{classns3_1_1FdNetDeviceHelper_a8018d2553649901a9f37ccc9ef3385e2}

\begin{DoxyCode}
54   \{
55   \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3




\subsection{Member Function Documentation}
\index{ns3\+::\+Fd\+Net\+Device\+Helper@{ns3\+::\+Fd\+Net\+Device\+Helper}!Enable\+Ascii\+Internal@{Enable\+Ascii\+Internal}}
\index{Enable\+Ascii\+Internal@{Enable\+Ascii\+Internal}!ns3\+::\+Fd\+Net\+Device\+Helper@{ns3\+::\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{Enable\+Ascii\+Internal(\+Ptr$<$ Output\+Stream\+Wrapper $>$ stream, std\+::string prefix, Ptr$<$ Net\+Device $>$ nd, bool explicit\+Filename)}{EnableAsciiInternal(Ptr< OutputStreamWrapper > stream, std::string prefix, Ptr< NetDevice > nd, bool explicitFilename)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Fd\+Net\+Device\+Helper\+::\+Enable\+Ascii\+Internal (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream, }
\item[{std\+::string}]{prefix, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{nd, }
\item[{bool}]{explicit\+Filename}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDeviceHelper_ae302a206158bfda94ddea64b711854d2}{}\label{classns3_1_1FdNetDeviceHelper_ae302a206158bfda94ddea64b711854d2}


Enable ascii trace output on the indicated net device. 

Net\+Device-\/specific implementation mechanism for hooking the trace and writing to the trace file.


\begin{DoxyParams}{Parameters}
{\em stream} & The output stream object to use when logging ascii traces. \\
\hline
{\em prefix} & Filename prefix to use for ascii trace files. \\
\hline
{\em nd} & Net device for which you want to enable tracing. \\
\hline
{\em explicit\+Filename} & Treat the prefix as an explicit filename if true \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1AsciiTraceHelperForDevice_ab0eb42de1633994e75f4a4fd44bc79de}{ns3\+::\+Ascii\+Trace\+Helper\+For\+Device}.


\begin{DoxyCode}
96 \{
97   \textcolor{comment}{//}
98   \textcolor{comment}{// All of the ascii enable functions vector through here including the ones}
99   \textcolor{comment}{// that are wandering through all of devices on perhaps all of the nodes in}
100   \textcolor{comment}{// the system.  We can only deal with devices of type FdNetDevice.}
101   \textcolor{comment}{//}
102   Ptr<FdNetDevice> device = nd->GetObject<FdNetDevice> ();
103   \textcolor{keywordflow}{if} (device == 0)
104     \{
105       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"FdNetDeviceHelper::EnableAsciiInternal(): Device "} << device << \textcolor{stringliteral}{" not of
       type ns3::FdNetDevice"});
106       \textcolor{keywordflow}{return};
107     \}
108 
109   \textcolor{comment}{//}
110   \textcolor{comment}{// Our default trace sinks are going to use packet printing, so we have to}
111   \textcolor{comment}{// make sure that is turned on.}
112   \textcolor{comment}{//}
113   \hyperlink{classns3_1_1Packet_ae17c0cd8e63e83df3c9273801e3d5d7f}{Packet::EnablePrinting} ();
114 
115   \textcolor{comment}{//}
116   \textcolor{comment}{// If we are not provided an OutputStreamWrapper, we are expected to create}
117   \textcolor{comment}{// one using the usual trace filename conventions and do a Hook*WithoutContext}
118   \textcolor{comment}{// since there will be one file per context and therefore the context would}
119   \textcolor{comment}{// be redundant.}
120   \textcolor{comment}{//}
121   \textcolor{keywordflow}{if} (stream == 0)
122     \{
123       \textcolor{comment}{//}
124       \textcolor{comment}{// Set up an output stream object to deal with private ofstream copy}
125       \textcolor{comment}{// constructor and lifetime issues.  Let the helper decide the actual}
126       \textcolor{comment}{// name of the file given the prefix.}
127       \textcolor{comment}{//}
128       AsciiTraceHelper asciiTraceHelper;
129 
130       std::string filename;
131       \textcolor{keywordflow}{if} (explicitFilename)
132         \{
133           filename = prefix;
134         \}
135       \textcolor{keywordflow}{else}
136         \{
137           filename = asciiTraceHelper.GetFilenameFromDevice (prefix, device);
138         \}
139 
140       Ptr<OutputStreamWrapper> theStream = asciiTraceHelper.CreateFileStream (filename);
141 
142       \textcolor{comment}{//}
143       \textcolor{comment}{// The MacRx trace source provides our "r" event.}
144       \textcolor{comment}{//}
145       asciiTraceHelper.HookDefaultReceiveSinkWithoutContext<FdNetDevice> (device, \textcolor{stringliteral}{"MacRx"}, theStream);
146 
147       \textcolor{keywordflow}{return};
148     \}
149 
150   \textcolor{comment}{//}
151   \textcolor{comment}{// If we are provided an OutputStreamWrapper, we are expected to use it, and}
152   \textcolor{comment}{// to providd a context.  We are free to come up with our own context if we}
153   \textcolor{comment}{// want, and use the AsciiTraceHelper Hook*WithContext functions, but for}
154   \textcolor{comment}{// compatibility and simplicity, we just use Config::Connect and let it deal}
155   \textcolor{comment}{// with the context.}
156   \textcolor{comment}{//}
157   \textcolor{comment}{// Note that we are going to use the default trace sinks provided by the}
158   \textcolor{comment}{// ascii trace helper.  There is actually no AsciiTraceHelper in sight here,}
159   \textcolor{comment}{// but the default trace sinks are actually publicly available static}
160   \textcolor{comment}{// functions that are always there waiting for just such a case.}
161   \textcolor{comment}{//}
162   uint32\_t deviceid = nd->GetIfIndex ();
163   std::ostringstream oss;
164 
165   oss << \textcolor{stringliteral}{"/NodeList/"} << nd->GetNode ()->GetId () << \textcolor{stringliteral}{"/DeviceList/"} << deviceid << \textcolor{stringliteral}{"
      /$ns3::FdNetDevice/MacRx"};
166   \hyperlink{group__config_ga4014f151241cd0939b6cb64409605736}{Config::Connect} (oss.str (), \hyperlink{group__makeboundcallback_ga1725d6362e6065faa0709f7c93f8d770}{MakeBoundCallback} (&
      \hyperlink{classns3_1_1AsciiTraceHelper_a344e3964ea89001f9df29659ac2dd4bf}{AsciiTraceHelper::DefaultReceiveSinkWithContext}, stream));
167 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4




Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Fd\+Net\+Device\+Helper@{ns3\+::\+Fd\+Net\+Device\+Helper}!Enable\+Pcap\+Internal@{Enable\+Pcap\+Internal}}
\index{Enable\+Pcap\+Internal@{Enable\+Pcap\+Internal}!ns3\+::\+Fd\+Net\+Device\+Helper@{ns3\+::\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{Enable\+Pcap\+Internal(std\+::string prefix, Ptr$<$ Net\+Device $>$ nd, bool promiscuous, bool explicit\+Filename)}{EnablePcapInternal(std::string prefix, Ptr< NetDevice > nd, bool promiscuous, bool explicitFilename)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Fd\+Net\+Device\+Helper\+::\+Enable\+Pcap\+Internal (
\begin{DoxyParamCaption}
\item[{std\+::string}]{prefix, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{nd, }
\item[{bool}]{promiscuous, }
\item[{bool}]{explicit\+Filename}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDeviceHelper_ad2438701b5de250057f690ad9c88a693}{}\label{classns3_1_1FdNetDeviceHelper_ad2438701b5de250057f690ad9c88a693}


Enable pcap output on the indicated net device. 

Net\+Device-\/specific implementation mechanism for hooking the trace and writing to the trace file.


\begin{DoxyParams}{Parameters}
{\em prefix} & Filename prefix to use for pcap files. \\
\hline
{\em nd} & Net device for which you want to enable tracing. \\
\hline
{\em promiscuous} & If true capture all possible packets available at the device. \\
\hline
{\em explicit\+Filename} & Treat the prefix as an explicit filename if true \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1PcapHelperForDevice_aae5c1fa77e45af342b1e3f70bf604e0f}{ns3\+::\+Pcap\+Helper\+For\+Device}.


\begin{DoxyCode}
54 \{
55   \textcolor{comment}{//}
56   \textcolor{comment}{// All of the Pcap enable functions vector through here including the ones}
57   \textcolor{comment}{// that are wandering through all of devices on perhaps all of the nodes in}
58   \textcolor{comment}{// the system.  We can only deal with devices of type FdNetDevice.}
59   \textcolor{comment}{//}
60   Ptr<FdNetDevice> device = nd->GetObject<FdNetDevice> ();
61   \textcolor{keywordflow}{if} (device == 0)
62     \{
63       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"FdNetDeviceHelper::EnablePcapInternal(): Device "} << device << \textcolor{stringliteral}{" not of type
       ns3::FdNetDevice"});
64       \textcolor{keywordflow}{return};
65     \}
66 
67   PcapHelper pcapHelper;
68 
69   std::string filename;
70   \textcolor{keywordflow}{if} (explicitFilename)
71     \{
72       filename = prefix;
73     \}
74   \textcolor{keywordflow}{else}
75     \{
76       filename = pcapHelper.GetFilenameFromDevice (prefix, device);
77     \}
78 
79   Ptr<PcapFileWrapper> file = pcapHelper.CreateFile (filename, std::ios::out, 
      \hyperlink{classns3_1_1PcapHelper_a2ee4dad28ddd9a1fe636f51835eaa77fafcc9f108717302f66800b8ea731e0ca0}{PcapHelper::DLT\_EN10MB});
80   \textcolor{keywordflow}{if} (promiscuous)
81     \{
82       pcapHelper.HookDefaultSink<FdNetDevice> (device, \textcolor{stringliteral}{"PromiscSniffer"}, file);
83     \}
84   \textcolor{keywordflow}{else}
85     \{
86       pcapHelper.HookDefaultSink<FdNetDevice> (device, \textcolor{stringliteral}{"Sniffer"}, file);
87     \}
88 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6




Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Fd\+Net\+Device\+Helper@{ns3\+::\+Fd\+Net\+Device\+Helper}!Install@{Install}}
\index{Install@{Install}!ns3\+::\+Fd\+Net\+Device\+Helper@{ns3\+::\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{Install(\+Ptr$<$ Node $>$ node) const }{Install(Ptr< Node > node) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Net\+Device\+Container} ns3\+::\+Fd\+Net\+Device\+Helper\+::\+Install (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDeviceHelper_af70d55cbb4f6411c33cacb84eb651ad5}{}\label{classns3_1_1FdNetDeviceHelper_af70d55cbb4f6411c33cacb84eb651ad5}
This method creates a \hyperlink{classns3_1_1FdNetDevice}{Fd\+Net\+Device} and associates it to a node


\begin{DoxyParams}{Parameters}
{\em node} & The node to install the device in \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A container holding the added net device. 
\end{DoxyReturn}

\begin{DoxyCode}
171 \{
172   \textcolor{keywordflow}{return} NetDeviceContainer (\hyperlink{classns3_1_1FdNetDeviceHelper_adf0e4f64b03f7203f7080b50f412a970}{InstallPriv} (node));
173 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8




Here is the caller graph for this function\+:
% FIG 9


\index{ns3\+::\+Fd\+Net\+Device\+Helper@{ns3\+::\+Fd\+Net\+Device\+Helper}!Install@{Install}}
\index{Install@{Install}!ns3\+::\+Fd\+Net\+Device\+Helper@{ns3\+::\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{Install(std\+::string name) const }{Install(std::string name) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Net\+Device\+Container} ns3\+::\+Fd\+Net\+Device\+Helper\+::\+Install (
\begin{DoxyParamCaption}
\item[{std\+::string}]{name}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDeviceHelper_ab7e70ab5e273b32a5cf3519674f1cc4e}{}\label{classns3_1_1FdNetDeviceHelper_ab7e70ab5e273b32a5cf3519674f1cc4e}
This method creates a \hyperlink{classns3_1_1FdNetDevice}{Fd\+Net\+Device} and associates it to a node


\begin{DoxyParams}{Parameters}
{\em name} & The name of the node to install the device in \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A container holding the added net device. 
\end{DoxyReturn}

\begin{DoxyCode}
177 \{
178   Ptr<Node> node = Names::Find<Node> (nodeName);
179   \textcolor{keywordflow}{return} NetDeviceContainer (\hyperlink{classns3_1_1FdNetDeviceHelper_adf0e4f64b03f7203f7080b50f412a970}{InstallPriv} (node));
180 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10


\index{ns3\+::\+Fd\+Net\+Device\+Helper@{ns3\+::\+Fd\+Net\+Device\+Helper}!Install@{Install}}
\index{Install@{Install}!ns3\+::\+Fd\+Net\+Device\+Helper@{ns3\+::\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{Install(const Node\+Container \&c) const }{Install(const NodeContainer &c) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Net\+Device\+Container} ns3\+::\+Fd\+Net\+Device\+Helper\+::\+Install (
\begin{DoxyParamCaption}
\item[{const {\bf Node\+Container} \&}]{c}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDeviceHelper_a9f9355b6beaa030c7fab05b3eb3b4952}{}\label{classns3_1_1FdNetDeviceHelper_a9f9355b6beaa030c7fab05b3eb3b4952}
This method creates a \hyperlink{classns3_1_1FdNetDevice}{Fd\+Net\+Device} and associates it to a node. For each Ptr$<$node$>$ in the provided container\+: it creates an \hyperlink{classns3_1_1FdNetDevice}{ns3\+::\+Fd\+Net\+Device} (with the attributes configured by Fd\+Net\+Device\+Helper\+::\+Set\+Device\+Attribute); adds the device to the node; and attaches the channel to the device.


\begin{DoxyParams}{Parameters}
{\em c} & The \hyperlink{classns3_1_1NodeContainer}{Node\+Container} holding the nodes to be changed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A container holding the added net devices. 
\end{DoxyReturn}

\begin{DoxyCode}
184 \{
185   NetDeviceContainer devs;
186 
187   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1NodeContainer_aa1a9f2d2b09bfef7d066d3974bca2cc4}{NodeContainer::Iterator} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c}.Begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c}.End (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
188     \{
189       devs.Add (\hyperlink{classns3_1_1FdNetDeviceHelper_adf0e4f64b03f7203f7080b50f412a970}{InstallPriv} (*\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}));
190     \}
191 
192   \textcolor{keywordflow}{return} devs;
193 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 11


\index{ns3\+::\+Fd\+Net\+Device\+Helper@{ns3\+::\+Fd\+Net\+Device\+Helper}!Install\+Priv@{Install\+Priv}}
\index{Install\+Priv@{Install\+Priv}!ns3\+::\+Fd\+Net\+Device\+Helper@{ns3\+::\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{Install\+Priv(\+Ptr$<$ Node $>$ node) const }{InstallPriv(Ptr< Node > node) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Net\+Device} $>$ ns3\+::\+Fd\+Net\+Device\+Helper\+::\+Install\+Priv (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDeviceHelper_adf0e4f64b03f7203f7080b50f412a970}{}\label{classns3_1_1FdNetDeviceHelper_adf0e4f64b03f7203f7080b50f412a970}
This method creates an \hyperlink{classns3_1_1FdNetDevice}{ns3\+::\+Fd\+Net\+Device} and associates it to a node


\begin{DoxyParams}{Parameters}
{\em node} & The node to install the device in \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A container holding the added net device. 
\end{DoxyReturn}


Reimplemented in \hyperlink{classns3_1_1TapFdNetDeviceHelper_a5b95f44885b6b5a5285604be0c6fa413}{ns3\+::\+Tap\+Fd\+Net\+Device\+Helper}, \hyperlink{classns3_1_1PlanetLabFdNetDeviceHelper_a740ff8b94a42f4175af712baf00c83ab}{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper}, and \hyperlink{classns3_1_1EmuFdNetDeviceHelper_a80562da33cef1c20d4b03b351fbbc21a}{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper}.


\begin{DoxyCode}
197 \{
198   Ptr<FdNetDevice> device = \hyperlink{classns3_1_1FdNetDeviceHelper_a68ff62237281b17bbd72fde746ce6826}{m\_deviceFactory}.\hyperlink{classns3_1_1ObjectFactory_a18152e93f0a6fe184ed7300cb31e9896}{Create}<FdNetDevice> ();
199   device->SetAddress (\hyperlink{classns3_1_1Mac48Address_a203b53c035649c0d4881fa1115aa2cdb}{Mac48Address::Allocate} ());
200   node->\hyperlink{classns3_1_1Node_a42ff83ee1d5d1649c770d3f5b62375de}{AddDevice} (device);
201   \textcolor{keywordflow}{return} device;
202 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12




Here is the caller graph for this function\+:
% FIG 13


\index{ns3\+::\+Fd\+Net\+Device\+Helper@{ns3\+::\+Fd\+Net\+Device\+Helper}!Set\+Attribute@{Set\+Attribute}}
\index{Set\+Attribute@{Set\+Attribute}!ns3\+::\+Fd\+Net\+Device\+Helper@{ns3\+::\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{Set\+Attribute(std\+::string n1, const Attribute\+Value \&v1)}{SetAttribute(std::string n1, const AttributeValue &v1)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Fd\+Net\+Device\+Helper\+::\+Set\+Attribute (
\begin{DoxyParamCaption}
\item[{std\+::string}]{n1, }
\item[{const {\bf Attribute\+Value} \&}]{v1}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1FdNetDeviceHelper_a0274f52a7b4288ca58f04fc2ac31d398}{}\label{classns3_1_1FdNetDeviceHelper_a0274f52a7b4288ca58f04fc2ac31d398}

\begin{DoxyParams}{Parameters}
{\em n1} & the name of the attribute to set \\
\hline
{\em v1} & the value of the attribute to set\\
\hline
\end{DoxyParams}
Set these attributes on each \hyperlink{classns3_1_1FdNetDevice}{ns3\+::\+Fd\+Net\+Device} created by \hyperlink{classns3_1_1FdNetDeviceHelper_af70d55cbb4f6411c33cacb84eb651ad5}{Fd\+Net\+Device\+Helper\+::\+Install} 
\begin{DoxyCode}
47 \{
48   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
49   \hyperlink{classns3_1_1FdNetDeviceHelper_a68ff62237281b17bbd72fde746ce6826}{m\_deviceFactory}.\hyperlink{classns3_1_1ObjectFactory_aef5c0d5019c96bdf01cefd1ff83f4a68}{Set} (n1, v1);
50 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 14




Here is the caller graph for this function\+:
% FIG 15




\subsection{Member Data Documentation}
\index{ns3\+::\+Fd\+Net\+Device\+Helper@{ns3\+::\+Fd\+Net\+Device\+Helper}!m\+\_\+device\+Factory@{m\+\_\+device\+Factory}}
\index{m\+\_\+device\+Factory@{m\+\_\+device\+Factory}!ns3\+::\+Fd\+Net\+Device\+Helper@{ns3\+::\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+device\+Factory}{m_deviceFactory}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Object\+Factory} ns3\+::\+Fd\+Net\+Device\+Helper\+::m\+\_\+device\+Factory\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDeviceHelper_a68ff62237281b17bbd72fde746ce6826}{}\label{classns3_1_1FdNetDeviceHelper_a68ff62237281b17bbd72fde746ce6826}


factory for the Net\+Devices 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
fd-\/net-\/device/helper/\hyperlink{fd-net-device-helper_8h}{fd-\/net-\/device-\/helper.\+h}\item 
fd-\/net-\/device/helper/\hyperlink{fd-net-device-helper_8cc}{fd-\/net-\/device-\/helper.\+cc}\end{DoxyCompactItemize}
