\hypertarget{classns3_1_1FdNetDevice}{}\section{ns3\+:\+:Fd\+Net\+Device Class Reference}
\label{classns3_1_1FdNetDevice}\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}


a \hyperlink{classns3_1_1NetDevice}{Net\+Device} to read/write network traffic from/into a file descriptor.  




{\ttfamily \#include $<$fd-\/net-\/device.\+h$>$}



Inheritance diagram for ns3\+:\+:Fd\+Net\+Device\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Fd\+Net\+Device\+:
% FIG 1
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classns3_1_1FdNetDevice_abdacbf10c181f50998a98e7688016618}{Encapsulation\+Mode} \{ \hyperlink{classns3_1_1FdNetDevice_abdacbf10c181f50998a98e7688016618a47e79129b21891ac4452ab35e05bd17d}{D\+IX}, 
\hyperlink{classns3_1_1FdNetDevice_abdacbf10c181f50998a98e7688016618ac6f7f5fa39999c05c1b1c2c5e5dd8889}{L\+LC}, 
\hyperlink{classns3_1_1FdNetDevice_abdacbf10c181f50998a98e7688016618abbad9c0d0fe0604652f21e33cf4d8798}{D\+I\+X\+PI}
 \}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1FdNetDevice_a81fa1519bf5abcb59cf902d74e264b53}{Fd\+Net\+Device} ()
\item 
virtual \hyperlink{classns3_1_1FdNetDevice_a31f4418c13aa2c2cf259e14155cd7455}{$\sim$\+Fd\+Net\+Device} ()
\item 
void \hyperlink{classns3_1_1FdNetDevice_a93861c71ec179c621b192ec0f864cff4}{Set\+Encapsulation\+Mode} (\hyperlink{classns3_1_1FdNetDevice_abdacbf10c181f50998a98e7688016618}{Fd\+Net\+Device\+::\+Encapsulation\+Mode} mode)
\item 
\hyperlink{classns3_1_1FdNetDevice_abdacbf10c181f50998a98e7688016618}{Fd\+Net\+Device\+::\+Encapsulation\+Mode} \hyperlink{classns3_1_1FdNetDevice_a4e67f8fec1545413979550017ed77cd9}{Get\+Encapsulation\+Mode} (void) const 
\item 
void \hyperlink{classns3_1_1FdNetDevice_ac72fff1b3d44824245645a9bcb37c709}{Set\+File\+Descriptor} (int \hyperlink{mmwave_2model_2fading-traces_2fading__trace__generator_8m_a44f21d5190b5a6df8089f54799628d7e}{fd})
\item 
void \hyperlink{classns3_1_1FdNetDevice_a32bda505142d81a4092048bf200ee6fc}{Start} (\hyperlink{classns3_1_1Time}{Time} t\+Start)
\item 
void \hyperlink{classns3_1_1FdNetDevice_a6849d18a8f1ed78077207057dce6c7ca}{Stop} (\hyperlink{classns3_1_1Time}{Time} t\+Stop)
\item 
virtual void \hyperlink{classns3_1_1FdNetDevice_a7e94668589f3e9778d536da9788fa119}{Set\+If\+Index} (const uint32\+\_\+t index)
\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1FdNetDevice_a13b410431720411883b779ca542211b7}{Get\+If\+Index} (void) const 
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Channel}{Channel} $>$ \hyperlink{classns3_1_1FdNetDevice_ada5131b8b2434b720867a0ab28433dd0}{Get\+Channel} (void) const 
\item 
virtual void \hyperlink{classns3_1_1FdNetDevice_a7fd0f69ac39428a18e354ffe21d15d6c}{Set\+Address} (\hyperlink{classns3_1_1Address}{Address} address)
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1FdNetDevice_a390033e5a444a1a13b8c5d860a3fd85a}{Get\+Address} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1FdNetDevice_a7f1ac465e2a943f0369c99bd3525bb00}{Set\+Mtu} (const uint16\+\_\+t mtu)
\item 
virtual uint16\+\_\+t \hyperlink{classns3_1_1FdNetDevice_ac1d86a7d43dc3c27bccb8e06b6779f6c}{Get\+Mtu} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1FdNetDevice_afe7a9225c43079850621ff0af3dc50c9}{Is\+Link\+Up} (void) const 
\item 
virtual void \hyperlink{classns3_1_1FdNetDevice_a997b2f4def41dafb904ccdb11b19b51d}{Add\+Link\+Change\+Callback} (\hyperlink{classns3_1_1Callback}{Callback}$<$ void $>$ callback)
\item 
virtual bool \hyperlink{classns3_1_1FdNetDevice_a0d582586009e076369fc8dc60f125452}{Is\+Broadcast} (void) const 
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1FdNetDevice_ada7d26e95bb6f320bacb1677c75f7484}{Get\+Broadcast} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1FdNetDevice_aa0ab9a8b2aa654ac8462721081548e83}{Is\+Multicast} (void) const 
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1FdNetDevice_ac717e2565f3ca7ea35ff4ac0d05e9e78}{Get\+Multicast} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} multicast\+Group) const 
\begin{DoxyCompactList}\small\item\em Make and return a M\+AC multicast address using the provided multicast group. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1FdNetDevice_adc2e71a7a047107567676d5fd604016f}{Is\+Point\+To\+Point} (void) const 
\begin{DoxyCompactList}\small\item\em Return true if the net device is on a point-\/to-\/point link. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1FdNetDevice_a23c9c76044490449abd1ec8f1d500072}{Is\+Bridge} (void) const 
\begin{DoxyCompactList}\small\item\em Return true if the net device is acting as a bridge. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1FdNetDevice_aa6a59de8f1c4586446d8d59213f60619}{Send} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, const \hyperlink{classns3_1_1Address}{Address} \&dest, uint16\+\_\+t protocol\+Number)
\item 
virtual bool \hyperlink{classns3_1_1FdNetDevice_acf6a3cd28d254cd41c1776cbb55095cb}{Send\+From} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, const \hyperlink{classns3_1_1Address}{Address} \&source, const \hyperlink{classns3_1_1Address}{Address} \&dest, uint16\+\_\+t protocol\+Number)
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1FdNetDevice_a301f937cb45179136ad4b2fe4750a56f}{Get\+Node} (void) const 
\item 
virtual void \hyperlink{classns3_1_1FdNetDevice_a2f695f5c375f5e69df201956347881aa}{Set\+Node} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node)
\item 
virtual bool \hyperlink{classns3_1_1FdNetDevice_a2cd99374da02cce70f3c2f06b8c41d3d}{Needs\+Arp} (void) const 
\item 
virtual void \hyperlink{classns3_1_1FdNetDevice_a4a2ba76da683b88593eb4456169cbf21}{Set\+Receive\+Callback} (\hyperlink{classns3_1_1NetDevice_ad5e5e1ca187472bc2ba99575d8def568}{Net\+Device\+::\+Receive\+Callback} cb)
\item 
virtual void \hyperlink{classns3_1_1FdNetDevice_abdca762c17ee6f58513daefb92b18471}{Set\+Promisc\+Receive\+Callback} (\hyperlink{classns3_1_1NetDevice_a427225795919f26c414bee2ea3f31ed2}{Net\+Device\+::\+Promisc\+Receive\+Callback} cb)
\item 
virtual bool \hyperlink{classns3_1_1FdNetDevice_a658792f0ed912154af2a2ffd90ce9905}{Supports\+Send\+From} () const 
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1FdNetDevice_a174a683ff194065093e8a9f1b496207a}{Get\+Multicast} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} addr) const 
\begin{DoxyCompactList}\small\item\em Get the M\+AC multicast address corresponding to the I\+Pv6 address provided. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1FdNetDevice_a2a3c8e37a145215384b62a2a7d7618b9}{Set\+Is\+Broadcast} (bool broadcast)
\item 
virtual void \hyperlink{classns3_1_1FdNetDevice_ad94f95495b987f43330cfa3ee4088ce5}{Set\+Is\+Multicast} (bool multicast)
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1FdNetDevice_a8b80cb55852cbf8874d160bf2f4a3dc8}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1FdNetDevice_a2ae015e4bc1b4ef3a9f279b3c7dcf5b4}{Do\+Dispose} (void)
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1FdNetDevice_a9ca7a80b428788720e22f6bc0f342aab}{Fd\+Net\+Device} (\hyperlink{classns3_1_1FdNetDevice}{Fd\+Net\+Device} const \&)
\begin{DoxyCompactList}\small\item\em Copy constructor. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1FdNetDevice_afec16ee9ae009f427348474f9e9c3c50}{Start\+Device} (void)
\item 
void \hyperlink{classns3_1_1FdNetDevice_ae5603448cbdc59550ce805f8c4c786e5}{Stop\+Device} (void)
\item 
void \hyperlink{classns3_1_1FdNetDevice_a65d669a9883c299c5527bbe0b9f33aef}{Receive\+Callback} (uint8\+\_\+t $\ast$buf, ssize\+\_\+t len)
\item 
void \hyperlink{classns3_1_1FdNetDevice_a7fd80498ff2e6f9fd91f0f5db3c5dbd5}{Forward\+Up} (void)
\item 
bool \hyperlink{classns3_1_1FdNetDevice_aaeea471746751f9e33fe79caead4a329}{Transmit\+Start} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p})
\item 
void \hyperlink{classns3_1_1FdNetDevice_a5e53758ee0fae578ad7e759b29193ea8}{Notify\+Link\+Up} (void)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1FdNetDevice_a344e2f5a2628c1a0305d5b4bbf72f8c6}{m\+\_\+node}
\item 
uint32\+\_\+t \hyperlink{classns3_1_1FdNetDevice_aed43dab9b55bd308388c3a9f1510a709}{m\+\_\+node\+Id}
\item 
uint32\+\_\+t \hyperlink{classns3_1_1FdNetDevice_a1b65e4f3e463c7ae49267e26213a6392}{m\+\_\+if\+Index}
\item 
uint16\+\_\+t \hyperlink{classns3_1_1FdNetDevice_a26eb80ddedbacaf1f5a1c19940e7225d}{m\+\_\+mtu}
\item 
int \hyperlink{classns3_1_1FdNetDevice_a2351bba8f2719557d98ff85e88b451a5}{m\+\_\+fd}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1FdNetDeviceFdReader}{Fd\+Net\+Device\+Fd\+Reader} $>$ \hyperlink{classns3_1_1FdNetDevice_ac678c4f411e1982c5d2416f7c05ebd3b}{m\+\_\+fd\+Reader}
\item 
\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} \hyperlink{classns3_1_1FdNetDevice_ad6ce5cc7c15f7a9c79a0c822aea60036}{m\+\_\+address}
\item 
\hyperlink{classns3_1_1FdNetDevice_abdacbf10c181f50998a98e7688016618}{Encapsulation\+Mode} \hyperlink{classns3_1_1FdNetDevice_aa5d97abfd57576f6b80423ac764e5cc8}{m\+\_\+encap\+Mode}
\item 
bool \hyperlink{classns3_1_1FdNetDevice_abf646fbe52523693488607b6ee9a7578}{m\+\_\+link\+Up}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback} \hyperlink{classns3_1_1FdNetDevice_a3e8d275156225016c9e518ae5429ade7}{m\+\_\+link\+Change\+Callbacks}
\item 
bool \hyperlink{classns3_1_1FdNetDevice_a0c9a5b7d7802458647ac8f2af3e80176}{m\+\_\+is\+Broadcast}
\item 
bool \hyperlink{classns3_1_1FdNetDevice_a781a28aa762e85bca94a29f3686ee15b}{m\+\_\+is\+Multicast}
\item 
std\+::queue$<$ std\+::pair$<$ uint8\+\_\+t $\ast$, ssize\+\_\+t $>$ $>$ \hyperlink{classns3_1_1FdNetDevice_a58492550a84c8c2c959b4d4904342d70}{m\+\_\+pending\+Queue}
\item 
uint32\+\_\+t \hyperlink{classns3_1_1FdNetDevice_a4be8b630492f263f0cb5f9c5fd223eac}{m\+\_\+max\+Pending\+Reads}
\item 
\hyperlink{classns3_1_1SystemMutex}{System\+Mutex} \hyperlink{classns3_1_1FdNetDevice_a957f57e977ee857a0233a484c276d427}{m\+\_\+pending\+Read\+Mutex}
\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1FdNetDevice_a6349cf5842c54a0420f9e41422895efa}{m\+\_\+t\+Start}
\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1FdNetDevice_ac97346af9ad4364aa3d1d7db0516fca5}{m\+\_\+t\+Stop}
\item 
\hyperlink{classns3_1_1EventId}{Event\+Id} \hyperlink{classns3_1_1FdNetDevice_a759e74ace56841b2ae47c69ff0276b2f}{m\+\_\+start\+Event}
\item 
\hyperlink{classns3_1_1EventId}{Event\+Id} \hyperlink{classns3_1_1FdNetDevice_a010c8ac9ac2fffeb6ce1ffaf94b5a890}{m\+\_\+stop\+Event}
\item 
\hyperlink{classns3_1_1NetDevice_ad5e5e1ca187472bc2ba99575d8def568}{Net\+Device\+::\+Receive\+Callback} \hyperlink{classns3_1_1FdNetDevice_a5c3e9d04b053c707a4188f823a6bc2ab}{m\+\_\+rx\+Callback}
\item 
\hyperlink{classns3_1_1NetDevice_a427225795919f26c414bee2ea3f31ed2}{Net\+Device\+::\+Promisc\+Receive\+Callback} \hyperlink{classns3_1_1FdNetDevice_aa95f558a530aca66f7fe582559902160}{m\+\_\+promisc\+Rx\+Callback}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1FdNetDevice_a7a067bc7ab39f2ebfcc925a58da4f519}{m\+\_\+mac\+Tx\+Trace}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1FdNetDevice_ad204b6948cb00479cc229465c6c07ebb}{m\+\_\+mac\+Tx\+Drop\+Trace}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1FdNetDevice_ac0fbee33fa2dc3d5349f33f794364fdb}{m\+\_\+mac\+Promisc\+Rx\+Trace}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1FdNetDevice_a5d526995e92ac4957170d9b8a680bad1}{m\+\_\+mac\+Rx\+Trace}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1FdNetDevice_a1aa224dd6e458d104dda994ea7448f7d}{m\+\_\+mac\+Rx\+Drop\+Trace}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1FdNetDevice_acd0f33f8fede665976f2485300c20810}{m\+\_\+phy\+Tx\+Drop\+Trace}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1FdNetDevice_ab0049e3c36f1916a8b15de5446ce192c}{m\+\_\+phy\+Rx\+Drop\+Trace}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1FdNetDevice_a821080a2cc1253e22918e8fcedcfbe58}{m\+\_\+sniffer\+Trace}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1FdNetDevice_a7f43138ecf824b335eb80eeebdb91eb6}{m\+\_\+promisc\+Sniffer\+Trace}
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
a \hyperlink{classns3_1_1NetDevice}{Net\+Device} to read/write network traffic from/into a file descriptor. 

A \hyperlink{classns3_1_1FdNetDevice}{Fd\+Net\+Device} object will read and write frames/packets from/to a file descriptor. This file descriptor might be associated to a Linux T\+A\+P/\+T\+UN device, to a socket or to a user space process, allowing the simulation to exchange traffic with the \char`\"{}outside-\/world\char`\"{} 

\subsection{Member Enumeration Documentation}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Encapsulation\+Mode@{Encapsulation\+Mode}}
\index{Encapsulation\+Mode@{Encapsulation\+Mode}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Encapsulation\+Mode}{EncapsulationMode}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf ns3\+::\+Fd\+Net\+Device\+::\+Encapsulation\+Mode}}\hypertarget{classns3_1_1FdNetDevice_abdacbf10c181f50998a98e7688016618}{}\label{classns3_1_1FdNetDevice_abdacbf10c181f50998a98e7688016618}
Enumeration of the types of frames supported in the class. \begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{D\+IX@{D\+IX}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!D\+IX@{D\+IX}}\item[{\em 
D\+IX\hypertarget{classns3_1_1FdNetDevice_abdacbf10c181f50998a98e7688016618a47e79129b21891ac4452ab35e05bd17d}{}\label{classns3_1_1FdNetDevice_abdacbf10c181f50998a98e7688016618a47e79129b21891ac4452ab35e05bd17d}
}]D\+IX II / Ethernet II packet \index{L\+LC@{L\+LC}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!L\+LC@{L\+LC}}\item[{\em 
L\+LC\hypertarget{classns3_1_1FdNetDevice_abdacbf10c181f50998a98e7688016618ac6f7f5fa39999c05c1b1c2c5e5dd8889}{}\label{classns3_1_1FdNetDevice_abdacbf10c181f50998a98e7688016618ac6f7f5fa39999c05c1b1c2c5e5dd8889}
}]802.\+2 L\+L\+C/\+S\+N\+AP \hyperlink{classns3_1_1Packet}{Packet} \index{D\+I\+X\+PI@{D\+I\+X\+PI}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!D\+I\+X\+PI@{D\+I\+X\+PI}}\item[{\em 
D\+I\+X\+PI\hypertarget{classns3_1_1FdNetDevice_abdacbf10c181f50998a98e7688016618abbad9c0d0fe0604652f21e33cf4d8798}{}\label{classns3_1_1FdNetDevice_abdacbf10c181f50998a98e7688016618abbad9c0d0fe0604652f21e33cf4d8798}
}]When using T\+AP devices, if flag I\+F\+F\+\_\+\+N\+O\+\_\+\+PI is not set on the device, IP packets will have an extra header\+: Flags \mbox{[}2 bytes\mbox{]} Proto \mbox{[}2 bytes\mbox{]} Raw protocol(\+I\+P, I\+Pv6, etc) frame. \end{description}
\end{Desc}

\begin{DoxyCode}
97   \{
98     \hyperlink{classns3_1_1FdNetDevice_abdacbf10c181f50998a98e7688016618a47e79129b21891ac4452ab35e05bd17d}{DIX},         
99     \hyperlink{classns3_1_1FdNetDevice_abdacbf10c181f50998a98e7688016618ac6f7f5fa39999c05c1b1c2c5e5dd8889}{LLC},         
100     \hyperlink{classns3_1_1FdNetDevice_abdacbf10c181f50998a98e7688016618abbad9c0d0fe0604652f21e33cf4d8798}{DIXPI},       
106   \};
\end{DoxyCode}


\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Fd\+Net\+Device@{Fd\+Net\+Device}}
\index{Fd\+Net\+Device@{Fd\+Net\+Device}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Fd\+Net\+Device()}{FdNetDevice()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Fd\+Net\+Device\+::\+Fd\+Net\+Device (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1FdNetDevice_a81fa1519bf5abcb59cf902d74e264b53}{}\label{classns3_1_1FdNetDevice_a81fa1519bf5abcb59cf902d74e264b53}
Constructor for the \hyperlink{classns3_1_1FdNetDevice}{Fd\+Net\+Device}. 
\begin{DoxyCode}
169   : \hyperlink{classns3_1_1FdNetDevice_a344e2f5a2628c1a0305d5b4bbf72f8c6}{m\_node} (0),
170     \hyperlink{classns3_1_1FdNetDevice_a1b65e4f3e463c7ae49267e26213a6392}{m\_ifIndex} (0),
171     \textcolor{comment}{// Defaults to Ethernet v2 MTU}
172     \hyperlink{classns3_1_1FdNetDevice_a26eb80ddedbacaf1f5a1c19940e7225d}{m\_mtu} (1500),
173     \hyperlink{classns3_1_1FdNetDevice_a2351bba8f2719557d98ff85e88b451a5}{m\_fd} (-1),
174     \hyperlink{classns3_1_1FdNetDevice_ac678c4f411e1982c5d2416f7c05ebd3b}{m\_fdReader} (0),
175     \hyperlink{classns3_1_1FdNetDevice_a0c9a5b7d7802458647ac8f2af3e80176}{m\_isBroadcast} (\textcolor{keyword}{true}),
176     \hyperlink{classns3_1_1FdNetDevice_a781a28aa762e85bca94a29f3686ee15b}{m\_isMulticast} (\textcolor{keyword}{false}),
177     \hyperlink{classns3_1_1FdNetDevice_a759e74ace56841b2ae47c69ff0276b2f}{m\_startEvent} (),
178     \hyperlink{classns3_1_1FdNetDevice_a010c8ac9ac2fffeb6ce1ffaf94b5a890}{m\_stopEvent} ()
179 \{
180   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
181   \hyperlink{classns3_1_1FdNetDevice_a32bda505142d81a4092048bf200ee6fc}{Start} (\hyperlink{classns3_1_1FdNetDevice_a6349cf5842c54a0420f9e41422895efa}{m\_tStart});
182 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!````~Fd\+Net\+Device@{$\sim$\+Fd\+Net\+Device}}
\index{````~Fd\+Net\+Device@{$\sim$\+Fd\+Net\+Device}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{$\sim$\+Fd\+Net\+Device()}{~FdNetDevice()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Fd\+Net\+Device\+::$\sim$\+Fd\+Net\+Device (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDevice_a31f4418c13aa2c2cf259e14155cd7455}{}\label{classns3_1_1FdNetDevice_a31f4418c13aa2c2cf259e14155cd7455}
Destructor for the \hyperlink{classns3_1_1FdNetDevice}{Fd\+Net\+Device}. 
\begin{DoxyCode}
189 \{
190   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
191 
192   \{
193     CriticalSection cs (\hyperlink{classns3_1_1FdNetDevice_a957f57e977ee857a0233a484c276d427}{m\_pendingReadMutex});
194 
195     \textcolor{keywordflow}{while} (!\hyperlink{classns3_1_1FdNetDevice_a58492550a84c8c2c959b4d4904342d70}{m\_pendingQueue}.empty ())
196       \{
197         std::pair<uint8\_t *, ssize\_t> next = \hyperlink{classns3_1_1FdNetDevice_a58492550a84c8c2c959b4d4904342d70}{m\_pendingQueue}.front ();
198         \hyperlink{classns3_1_1FdNetDevice_a58492550a84c8c2c959b4d4904342d70}{m\_pendingQueue}.pop ();
199 
200         free (next.first);
201       \}
202   \}
203 \}
\end{DoxyCode}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Fd\+Net\+Device@{Fd\+Net\+Device}}
\index{Fd\+Net\+Device@{Fd\+Net\+Device}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Fd\+Net\+Device(\+Fd\+Net\+Device const \&)}{FdNetDevice(FdNetDevice const &)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Fd\+Net\+Device\+::\+Fd\+Net\+Device (
\begin{DoxyParamCaption}
\item[{{\bf Fd\+Net\+Device} const \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_a9ca7a80b428788720e22f6bc0f342aab}{}\label{classns3_1_1FdNetDevice_a9ca7a80b428788720e22f6bc0f342aab}


Copy constructor. 

Defined and unimplemented to avoid misuse as suggested in \href{http://www.nsnam.org/wiki/NS-3_Python_Bindings#.22invalid_use_of_incomplete_type.22}{\tt http\+://www.\+nsnam.\+org/wiki/\+N\+S-\/3\+\_\+\+Python\+\_\+\+Bindings\#.\+22invalid\+\_\+use\+\_\+of\+\_\+incomplete\+\_\+type.\+22} 
\begin{DoxyCode}
185 \{
186 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Add\+Link\+Change\+Callback@{Add\+Link\+Change\+Callback}}
\index{Add\+Link\+Change\+Callback@{Add\+Link\+Change\+Callback}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Add\+Link\+Change\+Callback(\+Callback$<$ void $>$ callback)}{AddLinkChangeCallback(Callback< void > callback)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Fd\+Net\+Device\+::\+Add\+Link\+Change\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Callback}$<$ void $>$}]{callback}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDevice_a997b2f4def41dafb904ccdb11b19b51d}{}\label{classns3_1_1FdNetDevice_a997b2f4def41dafb904ccdb11b19b51d}

\begin{DoxyParams}{Parameters}
{\em callback} & the callback to invoke\\
\hline
\end{DoxyParams}
Add a callback invoked whenever the link status changes to UP. This callback is typically used by the I\+P/\+A\+RP layer to flush the A\+RP cache and by I\+Pv6 stack to flush N\+D\+I\+SC cache whenever the link goes up. 

Implements \hyperlink{classns3_1_1NetDevice_aafb1bf869d38ef7a7112d11fab0163a3}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
675 \{
676   \hyperlink{classns3_1_1FdNetDevice_a3e8d275156225016c9e518ae5429ade7}{m\_linkChangeCallbacks}.\hyperlink{classns3_1_1TracedCallback_aacc251bf4e302e7d034e9f0e25a15980}{ConnectWithoutContext} (callback);
677 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Do\+Dispose(void)}{DoDispose(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Fd\+Net\+Device\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDevice_a2ae015e4bc1b4ef3a9f279b3c7dcf5b4}{}\label{classns3_1_1FdNetDevice_a2ae015e4bc1b4ef3a9f279b3c7dcf5b4}
Destructor implementation.

This method is called by \hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose()} or by the \hyperlink{classns3_1_1Object}{Object}\textquotesingle{}s destructor, whichever comes first.

Subclasses are expected to implement their real destruction code in an overriden version of this method and chain up to their parent\textquotesingle{}s implementation once they are done. {\itshape i.\+e}, for simplicity, the destructor of every subclass should be empty and its content should be moved to the associated \hyperlink{classns3_1_1FdNetDevice_a2ae015e4bc1b4ef3a9f279b3c7dcf5b4}{Do\+Dispose()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.


\begin{DoxyCode}
207 \{
208   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
209   \hyperlink{classns3_1_1FdNetDevice_ae5603448cbdc59550ce805f8c4c786e5}{StopDevice} ();
210   \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{NetDevice::DoDispose} ();
211 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4


\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Forward\+Up@{Forward\+Up}}
\index{Forward\+Up@{Forward\+Up}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Forward\+Up(void)}{ForwardUp(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Fd\+Net\+Device\+::\+Forward\+Up (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_a7fd80498ff2e6f9fd91f0f5db3c5dbd5}{}\label{classns3_1_1FdNetDevice_a7fd80498ff2e6f9fd91f0f5db3c5dbd5}
Forward the frame to the appropriate callback for processing 
\begin{DoxyCode}
386 \{
387 
388   uint8\_t *buf = 0; 
389   ssize\_t len = 0;
390 
391   \{
392     CriticalSection cs (\hyperlink{classns3_1_1FdNetDevice_a957f57e977ee857a0233a484c276d427}{m\_pendingReadMutex});
393     std::pair<uint8\_t *, ssize\_t> next = \hyperlink{classns3_1_1FdNetDevice_a58492550a84c8c2c959b4d4904342d70}{m\_pendingQueue}.front ();
394     \hyperlink{classns3_1_1FdNetDevice_a58492550a84c8c2c959b4d4904342d70}{m\_pendingQueue}.pop ();
395 
396     buf = next.first;
397     len = next.second;
398   \}
399 
400   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << buf << len);
401 
402   \textcolor{comment}{// We need to remove the PI header and ignore it}
403   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1FdNetDevice_aa5d97abfd57576f6b80423ac764e5cc8}{m\_encapMode} == \hyperlink{classns3_1_1FdNetDevice_abdacbf10c181f50998a98e7688016618abbad9c0d0fe0604652f21e33cf4d8798}{DIXPI})
404     \{
405       \hyperlink{group__fd-net-device_ga297e68cd3a421ef11540f26b073ea881}{RemovePIHeader} (buf, len);
406     \}
407 
408   \textcolor{comment}{//}
409   \textcolor{comment}{// Create a packet out of the buffer we received and free that buffer.}
410   \textcolor{comment}{//}
411   Ptr<Packet> packet = Create<Packet> (\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }uint8\_t *\textcolor{keyword}{>} (buf), len);
412   free (buf);
413   buf = 0;
414 
415   \textcolor{comment}{//}
416   \textcolor{comment}{// Trace sinks will expect complete packets, not packets without some of the}
417   \textcolor{comment}{// headers}
418   \textcolor{comment}{//}
419   Ptr<Packet> originalPacket = packet->Copy ();
420 
421   Mac48Address destination;
422   Mac48Address source;
423   uint16\_t protocol;
424   \textcolor{keywordtype}{bool} isBroadcast = \textcolor{keyword}{false};
425   \textcolor{keywordtype}{bool} isMulticast = \textcolor{keyword}{false};
426 
427   EthernetHeader header (\textcolor{keyword}{false});
428 
429   \textcolor{comment}{//}
430   \textcolor{comment}{// This device could be running in an environment where completely unexpected}
431   \textcolor{comment}{// kinds of packets are flying around, so we need to harden things a bit and}
432   \textcolor{comment}{// filter out packets we think are completely bogus, so we always check to see}
433   \textcolor{comment}{// that the packet is long enough to contain the header we want to remove.}
434   \textcolor{comment}{//}
435   \textcolor{keywordflow}{if} (packet->GetSize () < header.GetSerializedSize ())
436     \{
437       \hyperlink{classns3_1_1FdNetDevice_ab0049e3c36f1916a8b15de5446ce192c}{m\_phyRxDropTrace} (originalPacket);
438       \textcolor{keywordflow}{return};
439     \}
440 
441   packet->RemoveHeader (header);
442   destination = header.GetDestination ();
443   source = header.GetSource ();
444   isBroadcast = header.GetDestination ().IsBroadcast ();
445   isMulticast = header.GetDestination ().IsGroup ();
446   protocol = header.GetLengthType ();
447 
448   \textcolor{comment}{//}
449   \textcolor{comment}{// If the length/type is less than 1500, it corresponds to a length}
450   \textcolor{comment}{// interpretation packet.  In this case, it is an 802.3 packet and}
451   \textcolor{comment}{// will also have an 802.2 LLC header.  If greater than 1500, we}
452   \textcolor{comment}{// find the protocol number (Ethernet type) directly.}
453   \textcolor{comment}{//}
454   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1FdNetDevice_aa5d97abfd57576f6b80423ac764e5cc8}{m\_encapMode} == \hyperlink{classns3_1_1FdNetDevice_abdacbf10c181f50998a98e7688016618ac6f7f5fa39999c05c1b1c2c5e5dd8889}{LLC} and header.GetLengthType () <= 1500)
455     \{
456       LlcSnapHeader llc;
457       \textcolor{comment}{//}
458       \textcolor{comment}{// Check to see that the packet is long enough to possibly contain the}
459       \textcolor{comment}{// header we want to remove before just naively calling.}
460       \textcolor{comment}{//}
461       \textcolor{keywordflow}{if} (packet->GetSize () < llc.GetSerializedSize ())
462         \{
463           \hyperlink{classns3_1_1FdNetDevice_ab0049e3c36f1916a8b15de5446ce192c}{m\_phyRxDropTrace} (originalPacket);
464           \textcolor{keywordflow}{return};
465         \}
466 
467       packet->RemoveHeader (llc);
468       protocol = llc.GetType ();
469     \}
470 
471   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Pkt source is "} << source);
472   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Pkt destination is "} << destination);
473 
474   \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2}{PacketType} packetType;
475 
476   \textcolor{keywordflow}{if} (isBroadcast)
477     \{
478       packetType = \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2a851cdec39029ae1f3de8955e9b33eb9c}{NS3\_PACKET\_BROADCAST};
479     \}
480   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isMulticast)
481     \{
482       packetType = \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2a46d4c29c98b4c198f24310ce69f43dc3}{NS3\_PACKET\_MULTICAST};
483     \}
484   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (destination == \hyperlink{classns3_1_1FdNetDevice_ad6ce5cc7c15f7a9c79a0c822aea60036}{m\_address})
485     \{
486       packetType = \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2a4f3acc25ea8b98021b5c610b899ae7d8}{NS3\_PACKET\_HOST};
487     \}
488   \textcolor{keywordflow}{else}
489     \{
490       packetType = \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2a16d8e18aea18b500b8f18de6d52c884d}{NS3\_PACKET\_OTHERHOST};
491     \}
492 
493   \textcolor{comment}{//}
494   \textcolor{comment}{// For all kinds of packetType we receive, we hit the promiscuous sniffer}
495   \textcolor{comment}{// hook and pass a copy up to the promiscuous callback.  Pass a copy to}
496   \textcolor{comment}{// make sure that nobody messes with our packet.}
497   \textcolor{comment}{//}
498   \hyperlink{classns3_1_1FdNetDevice_a7f43138ecf824b335eb80eeebdb91eb6}{m\_promiscSnifferTrace} (originalPacket);
499 
500   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1FdNetDevice_aa95f558a530aca66f7fe582559902160}{m\_promiscRxCallback}.\hyperlink{classns3_1_1Callback_aa8e27826badbf37f84763f36f70d9b54}{IsNull} ())
501     \{
502       \hyperlink{classns3_1_1FdNetDevice_ac0fbee33fa2dc3d5349f33f794364fdb}{m\_macPromiscRxTrace} (originalPacket);
503       \hyperlink{classns3_1_1FdNetDevice_aa95f558a530aca66f7fe582559902160}{m\_promiscRxCallback} (\textcolor{keyword}{this}, packet, protocol, source, destination,
504                            packetType);
505     \}
506 
507   \textcolor{comment}{//}
508   \textcolor{comment}{// If this packet is not destined for some other host, it must be for us}
509   \textcolor{comment}{// as either a broadcast, multicast or unicast.  We need to hit the mac}
510   \textcolor{comment}{// packet received trace hook and forward the packet up the stack.}
511   \textcolor{comment}{//}
512   \textcolor{keywordflow}{if} (packetType != \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2a16d8e18aea18b500b8f18de6d52c884d}{NS3\_PACKET\_OTHERHOST})
513     \{
514       \hyperlink{classns3_1_1FdNetDevice_a821080a2cc1253e22918e8fcedcfbe58}{m\_snifferTrace} (originalPacket);
515       \hyperlink{classns3_1_1FdNetDevice_a5d526995e92ac4957170d9b8a680bad1}{m\_macRxTrace} (originalPacket);
516       \hyperlink{classns3_1_1FdNetDevice_a5c3e9d04b053c707a4188f823a6bc2ab}{m\_rxCallback} (\textcolor{keyword}{this}, packet, protocol, source);
517     \}
518 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5




Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Get\+Address@{Get\+Address}}
\index{Get\+Address@{Get\+Address}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Address(void) const }{GetAddress(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Fd\+Net\+Device\+::\+Get\+Address (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDevice_a390033e5a444a1a13b8c5d860a3fd85a}{}\label{classns3_1_1FdNetDevice_a390033e5a444a1a13b8c5d860a3fd85a}
\begin{DoxyReturn}{Returns}
the current \hyperlink{classns3_1_1Address}{Address} of this interface. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a671f99de496d6f09ae343bb715301fb2}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
619 \{
620   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1FdNetDevice_ad6ce5cc7c15f7a9c79a0c822aea60036}{m\_address};
621 \}
\end{DoxyCode}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Get\+Broadcast@{Get\+Broadcast}}
\index{Get\+Broadcast@{Get\+Broadcast}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Broadcast(void) const }{GetBroadcast(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Fd\+Net\+Device\+::\+Get\+Broadcast (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDevice_ada7d26e95bb6f320bacb1677c75f7484}{}\label{classns3_1_1FdNetDevice_ada7d26e95bb6f320bacb1677c75f7484}
\begin{DoxyReturn}{Returns}
the broadcast address supported by this netdevice.
\end{DoxyReturn}
Calling this method is invalid if Is\+Broadcast returns not true. 

Implements \hyperlink{classns3_1_1NetDevice_a4724e03bc548dd8e967cc4a7356197bd}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
693 \{
694   \textcolor{keywordflow}{return} Mac48Address (\textcolor{stringliteral}{"ff:ff:ff:ff:ff:ff"});
695 \}
\end{DoxyCode}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Get\+Channel@{Get\+Channel}}
\index{Get\+Channel@{Get\+Channel}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Channel(void) const }{GetChannel(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Channel} $>$ ns3\+::\+Fd\+Net\+Device\+::\+Get\+Channel (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDevice_ada5131b8b2434b720867a0ab28433dd0}{}\label{classns3_1_1FdNetDevice_ada5131b8b2434b720867a0ab28433dd0}
\begin{DoxyReturn}{Returns}
the channel this \hyperlink{classns3_1_1NetDevice}{Net\+Device} is connected to. The value returned can be zero if the \hyperlink{classns3_1_1NetDevice}{Net\+Device} is not yet connected to any channel or if the underlying \hyperlink{classns3_1_1NetDevice}{Net\+Device} has no concept of a channel. i.\+e., callers {\itshape must} check for zero and be ready to handle it. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a3d810bd2738634e2e851661271828565}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
644 \{
645   \textcolor{keywordflow}{return} NULL;
646 \}
\end{DoxyCode}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Get\+Encapsulation\+Mode@{Get\+Encapsulation\+Mode}}
\index{Get\+Encapsulation\+Mode@{Get\+Encapsulation\+Mode}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Encapsulation\+Mode(void) const }{GetEncapsulationMode(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fd\+Net\+Device\+::\+Encapsulation\+Mode} ns3\+::\+Fd\+Net\+Device\+::\+Get\+Encapsulation\+Mode (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1FdNetDevice_a4e67f8fec1545413979550017ed77cd9}{}\label{classns3_1_1FdNetDevice_a4e67f8fec1545413979550017ed77cd9}
Get the link layer encapsulation mode of this device.

\begin{DoxyReturn}{Returns}
The link layer encapsulation mode of this device. 
\end{DoxyReturn}

\begin{DoxyCode}
223 \{
224   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
225   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1FdNetDevice_aa5d97abfd57576f6b80423ac764e5cc8}{m\_encapMode};
226 \}
\end{DoxyCode}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Get\+If\+Index@{Get\+If\+Index}}
\index{Get\+If\+Index@{Get\+If\+Index}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+If\+Index(void) const }{GetIfIndex(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Fd\+Net\+Device\+::\+Get\+If\+Index (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDevice_a13b410431720411883b779ca542211b7}{}\label{classns3_1_1FdNetDevice_a13b410431720411883b779ca542211b7}
\begin{DoxyReturn}{Returns}
index if\+Index of the device 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a8c1ae2ec8eadc4524dfc1e425bfa0850}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
638 \{
639   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1FdNetDevice_a1b65e4f3e463c7ae49267e26213a6392}{m\_ifIndex};
640 \}
\end{DoxyCode}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Get\+Mtu@{Get\+Mtu}}
\index{Get\+Mtu@{Get\+Mtu}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Mtu(void) const }{GetMtu(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Fd\+Net\+Device\+::\+Get\+Mtu (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDevice_ac1d86a7d43dc3c27bccb8e06b6779f6c}{}\label{classns3_1_1FdNetDevice_ac1d86a7d43dc3c27bccb8e06b6779f6c}
\begin{DoxyReturn}{Returns}
the link-\/level M\+TU in bytes for this interface.
\end{DoxyReturn}
This value is typically used by the IP layer to perform IP fragmentation when needed. 

Implements \hyperlink{classns3_1_1NetDevice_a91f4f5d01bc2d567c1e0a69b63a4cf14}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
663 \{
664   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1FdNetDevice_a26eb80ddedbacaf1f5a1c19940e7225d}{m\_mtu};
665 \}
\end{DoxyCode}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Get\+Multicast@{Get\+Multicast}}
\index{Get\+Multicast@{Get\+Multicast}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Multicast(\+Ipv4\+Address multicast\+Group) const }{GetMulticast(Ipv4Address multicastGroup) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Fd\+Net\+Device\+::\+Get\+Multicast (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{multicast\+Group}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDevice_ac717e2565f3ca7ea35ff4ac0d05e9e78}{}\label{classns3_1_1FdNetDevice_ac717e2565f3ca7ea35ff4ac0d05e9e78}


Make and return a M\+AC multicast address using the provided multicast group. 

\{1112\} says that an \hyperlink{classns3_1_1Ipv4}{Ipv4} host group address is mapped to an Ethernet multicast address by placing the low-\/order 23-\/bits of the IP address into the low-\/order 23 bits of the Ethernet multicast address 01-\/00-\/5\+E-\/00-\/00-\/00 (hex). Similar R\+F\+Cs exist for \hyperlink{classns3_1_1Ipv6}{Ipv6} and Eui64 mappings. This method performs the multicast address creation function appropriate to the underlying M\+AC address of the device. This M\+AC address is encapsulated in an abstract \hyperlink{classns3_1_1Address}{Address} to avoid dependencies on the exact M\+AC address format.

In the case of net devices that do not support multicast, clients are expected to test \hyperlink{classns3_1_1NetDevice_a1afb4848a9226540f1ff51f9b31ae95e}{Net\+Device\+::\+Is\+Multicast} and avoid attempting to map multicast packets. Subclasses of \hyperlink{classns3_1_1NetDevice}{Net\+Device} that do support multicasting are expected to override this method and provide an implementation appropriate to the particular device.


\begin{DoxyParams}{Parameters}
{\em multicast\+Group} & The IP address for the multicast group destination of the packet. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The M\+AC multicast \hyperlink{classns3_1_1Address}{Address} used to send packets to the provided multicast group.
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Calling this method is invalid if Is\+Multicast returns not true. 
\end{DoxyWarning}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1FdNetDevice_aa0ab9a8b2aa654ac8462721081548e83}{Is\+Multicast()} 
\end{DoxySeeAlso}


Implements \hyperlink{classns3_1_1NetDevice_a98aa4852df367b6a393c8cc1d88af0d9}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
711 \{
712   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Mac48Address_a23d170f8c7a7d90a8110425620285819}{Mac48Address::GetMulticast} (multicastGroup);
713 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7


\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Get\+Multicast@{Get\+Multicast}}
\index{Get\+Multicast@{Get\+Multicast}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Multicast(\+Ipv6\+Address addr) const }{GetMulticast(Ipv6Address addr) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Fd\+Net\+Device\+::\+Get\+Multicast (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{addr}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDevice_a174a683ff194065093e8a9f1b496207a}{}\label{classns3_1_1FdNetDevice_a174a683ff194065093e8a9f1b496207a}


Get the M\+AC multicast address corresponding to the I\+Pv6 address provided. 


\begin{DoxyParams}{Parameters}
{\em addr} & I\+Pv6 address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the M\+AC multicast address 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Calling this method is invalid if Is\+Multicast returns not true. 
\end{DoxyWarning}


Implements \hyperlink{classns3_1_1NetDevice_a46479a2c0101c6f9da9251ed4d7575bd}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
717 \{
718   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Mac48Address_a23d170f8c7a7d90a8110425620285819}{Mac48Address::GetMulticast} (addr);
719 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8


\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Get\+Node@{Get\+Node}}
\index{Get\+Node@{Get\+Node}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Node(void) const }{GetNode(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Node} $>$ ns3\+::\+Fd\+Net\+Device\+::\+Get\+Node (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDevice_a301f937cb45179136ad4b2fe4750a56f}{}\label{classns3_1_1FdNetDevice_a301f937cb45179136ad4b2fe4750a56f}
\begin{DoxyReturn}{Returns}
the node base class which contains this network interface.
\end{DoxyReturn}
When a subclass needs to get access to the underlying node base class to print the nodeid for example, it can invoke this method. 

Implements \hyperlink{classns3_1_1NetDevice_a098b6cc4339ac00c62e75cfa48c8aeac}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
735 \{
736   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1FdNetDevice_a344e2f5a2628c1a0305d5b4bbf72f8c6}{m\_node};
737 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 9


\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Fd\+Net\+Device\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1FdNetDevice_a8b80cb55852cbf8874d160bf2f4a3dc8}{}\label{classns3_1_1FdNetDevice_a8b80cb55852cbf8874d160bf2f4a3dc8}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
82 \{
83   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::FdNetDevice"})
84     .SetParent<NetDevice> ()
85     .SetGroupName (\textcolor{stringliteral}{"FdNetDevice"})
86     .AddConstructor<\hyperlink{classns3_1_1FdNetDevice_a81fa1519bf5abcb59cf902d74e264b53}{FdNetDevice}> ()
87     .AddAttribute (\textcolor{stringliteral}{"Address"},
88                    \textcolor{stringliteral}{"The MAC address of this device."},
89                    Mac48AddressValue (Mac48Address (\textcolor{stringliteral}{"ff:ff:ff:ff:ff:ff"})),
90                    MakeMac48AddressAccessor (&\hyperlink{classns3_1_1FdNetDevice_ad6ce5cc7c15f7a9c79a0c822aea60036}{FdNetDevice::m\_address}),
91                    MakeMac48AddressChecker ())
92     .AddAttribute (\textcolor{stringliteral}{"Start"},
93                    \textcolor{stringliteral}{"The simulation time at which to spin up "}
94                    \textcolor{stringliteral}{"the device thread."},
95                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (0.)),
96                    MakeTimeAccessor (&\hyperlink{classns3_1_1FdNetDevice_a6349cf5842c54a0420f9e41422895efa}{FdNetDevice::m\_tStart}),
97                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
98     .AddAttribute (\textcolor{stringliteral}{"Stop"},
99                    \textcolor{stringliteral}{"The simulation time at which to tear down "}
100                    \textcolor{stringliteral}{"the device thread."},
101                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (0.)),
102                    MakeTimeAccessor (&\hyperlink{classns3_1_1FdNetDevice_ac97346af9ad4364aa3d1d7db0516fca5}{FdNetDevice::m\_tStop}),
103                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
104     .AddAttribute (\textcolor{stringliteral}{"EncapsulationMode"},
105                    \textcolor{stringliteral}{"The link-layer encapsulation type to use."},
106                    EnumValue (\hyperlink{classns3_1_1FdNetDevice_abdacbf10c181f50998a98e7688016618a47e79129b21891ac4452ab35e05bd17d}{DIX}),
107                    \hyperlink{namespacens3_af5050739867ce63896dec011e332c8ec}{MakeEnumAccessor} (&\hyperlink{classns3_1_1FdNetDevice_aa5d97abfd57576f6b80423ac764e5cc8}{FdNetDevice::m\_encapMode}),
108                    \hyperlink{namespacens3_a48832781a2b521d3d0091e05ece30615}{MakeEnumChecker} (\hyperlink{classns3_1_1FdNetDevice_abdacbf10c181f50998a98e7688016618a47e79129b21891ac4452ab35e05bd17d}{DIX}, \textcolor{stringliteral}{"Dix"},
109                                     \hyperlink{classns3_1_1FdNetDevice_abdacbf10c181f50998a98e7688016618ac6f7f5fa39999c05c1b1c2c5e5dd8889}{LLC}, \textcolor{stringliteral}{"Llc"},
110                                     \hyperlink{classns3_1_1FdNetDevice_abdacbf10c181f50998a98e7688016618abbad9c0d0fe0604652f21e33cf4d8798}{DIXPI}, \textcolor{stringliteral}{"DixPi"}))
111     .AddAttribute (\textcolor{stringliteral}{"RxQueueSize"}, \textcolor{stringliteral}{"Maximum size of the read queue.  "}
112                    \textcolor{stringliteral}{"This value limits number of packets that have been read "}
113                    \textcolor{stringliteral}{"from the network into a memory buffer but have not yet "}
114                    \textcolor{stringliteral}{"been processed by the simulator."},
115                    UintegerValue (1000),
116                    MakeUintegerAccessor (&\hyperlink{classns3_1_1FdNetDevice_a4be8b630492f263f0cb5f9c5fd223eac}{FdNetDevice::m\_maxPendingReads}),
117                    MakeUintegerChecker<uint32\_t> ())
118     \textcolor{comment}{//}
119     \textcolor{comment}{// Trace sources at the "top" of the net device, where packets transition}
120     \textcolor{comment}{// to/from higher layers.  These points do not really correspond to the}
121     \textcolor{comment}{// MAC layer of the underlying operating system, but exist to provide}
122     \textcolor{comment}{// a consitent tracing environment.  These trace hooks should really be}
123     \textcolor{comment}{// interpreted as the points at which a packet leaves the ns-3 environment}
124     \textcolor{comment}{// destined for the underlying operating system or vice-versa.}
125     \textcolor{comment}{//}
126     .AddTraceSource (\textcolor{stringliteral}{"MacTx"},
127                      \textcolor{stringliteral}{"Trace source indicating a packet has "}
128                      \textcolor{stringliteral}{"arrived for transmission by this device"},
129                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1FdNetDevice_a7a067bc7ab39f2ebfcc925a58da4f519}{FdNetDevice::m\_macTxTrace}),
130                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
131     .AddTraceSource (\textcolor{stringliteral}{"MacTxDrop"},
132                      \textcolor{stringliteral}{"Trace source indicating a packet has "}
133                      \textcolor{stringliteral}{"been dropped by the device before transmission"},
134                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1FdNetDevice_ad204b6948cb00479cc229465c6c07ebb}{FdNetDevice::m\_macTxDropTrace}),
135                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
136     .AddTraceSource (\textcolor{stringliteral}{"MacPromiscRx"},
137                      \textcolor{stringliteral}{"A packet has been received by this device, "}
138                      \textcolor{stringliteral}{"has been passed up from the physical layer "}
139                      \textcolor{stringliteral}{"and is being forwarded up the local protocol stack.  "}
140                      \textcolor{stringliteral}{"This is a promiscuous trace,"},
141                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1FdNetDevice_ac0fbee33fa2dc3d5349f33f794364fdb}{FdNetDevice::m\_macPromiscRxTrace}),
142                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
143     .AddTraceSource (\textcolor{stringliteral}{"MacRx"},
144                      \textcolor{stringliteral}{"A packet has been received by this device, "}
145                      \textcolor{stringliteral}{"has been passed up from the physical layer "}
146                      \textcolor{stringliteral}{"and is being forwarded up the local protocol stack.  "}
147                      \textcolor{stringliteral}{"This is a non-promiscuous trace,"},
148                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1FdNetDevice_a5d526995e92ac4957170d9b8a680bad1}{FdNetDevice::m\_macRxTrace}),
149                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
150 
151     \textcolor{comment}{//}
152     \textcolor{comment}{// Trace sources designed to simulate a packet sniffer facility (tcpdump).}
153     \textcolor{comment}{//}
154     .AddTraceSource (\textcolor{stringliteral}{"Sniffer"},
155                      \textcolor{stringliteral}{"Trace source simulating a non-promiscuous "}
156                      \textcolor{stringliteral}{"packet sniffer attached to the device"},
157                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1FdNetDevice_a821080a2cc1253e22918e8fcedcfbe58}{FdNetDevice::m\_snifferTrace}),
158                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
159     .AddTraceSource (\textcolor{stringliteral}{"PromiscSniffer"},
160                      \textcolor{stringliteral}{"Trace source simulating a promiscuous "}
161                      \textcolor{stringliteral}{"packet sniffer attached to the device"},
162                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1FdNetDevice_a7f43138ecf824b335eb80eeebdb91eb6}{FdNetDevice::m\_promiscSnifferTrace}),
163                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
164   ;
165   \textcolor{keywordflow}{return} tid;
166 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10


\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Is\+Bridge@{Is\+Bridge}}
\index{Is\+Bridge@{Is\+Bridge}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Bridge(void) const }{IsBridge(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Fd\+Net\+Device\+::\+Is\+Bridge (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDevice_a23c9c76044490449abd1ec8f1d500072}{}\label{classns3_1_1FdNetDevice_a23c9c76044490449abd1ec8f1d500072}


Return true if the net device is acting as a bridge. 

\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Bridge flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a9d34556a1c83a69dacb08698ca4a1d94}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
723 \{
724   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
725 \}
\end{DoxyCode}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Is\+Broadcast@{Is\+Broadcast}}
\index{Is\+Broadcast@{Is\+Broadcast}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Broadcast(void) const }{IsBroadcast(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Fd\+Net\+Device\+::\+Is\+Broadcast (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDevice_a0d582586009e076369fc8dc60f125452}{}\label{classns3_1_1FdNetDevice_a0d582586009e076369fc8dc60f125452}
\begin{DoxyReturn}{Returns}
true if this interface supports a broadcast address, false otherwise. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a67f992b20858cd7b397d8fba2feff141}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
681 \{
682   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1FdNetDevice_a0c9a5b7d7802458647ac8f2af3e80176}{m\_isBroadcast};
683 \}
\end{DoxyCode}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Is\+Link\+Up@{Is\+Link\+Up}}
\index{Is\+Link\+Up@{Is\+Link\+Up}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Link\+Up(void) const }{IsLinkUp(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Fd\+Net\+Device\+::\+Is\+Link\+Up (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDevice_afe7a9225c43079850621ff0af3dc50c9}{}\label{classns3_1_1FdNetDevice_afe7a9225c43079850621ff0af3dc50c9}
\begin{DoxyReturn}{Returns}
true if link is up; false otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_afe1822b79e19a05ab95f693c8fb64fc7}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
669 \{
670   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1FdNetDevice_abf646fbe52523693488607b6ee9a7578}{m\_linkUp};
671 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Is\+Multicast@{Is\+Multicast}}
\index{Is\+Multicast@{Is\+Multicast}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Multicast(void) const }{IsMulticast(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Fd\+Net\+Device\+::\+Is\+Multicast (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDevice_aa0ab9a8b2aa654ac8462721081548e83}{}\label{classns3_1_1FdNetDevice_aa0ab9a8b2aa654ac8462721081548e83}
\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Multicast flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a1afb4848a9226540f1ff51f9b31ae95e}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
699 \{
700   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1FdNetDevice_a781a28aa762e85bca94a29f3686ee15b}{m\_isMulticast};
701 \}
\end{DoxyCode}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Is\+Point\+To\+Point@{Is\+Point\+To\+Point}}
\index{Is\+Point\+To\+Point@{Is\+Point\+To\+Point}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Point\+To\+Point(void) const }{IsPointToPoint(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Fd\+Net\+Device\+::\+Is\+Point\+To\+Point (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDevice_adc2e71a7a047107567676d5fd604016f}{}\label{classns3_1_1FdNetDevice_adc2e71a7a047107567676d5fd604016f}


Return true if the net device is on a point-\/to-\/point link. 

\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Point\+To\+Point flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a718177f25efeaf2dbf8a18fcab87224d}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
729 \{
730   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
731 \}
\end{DoxyCode}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Needs\+Arp@{Needs\+Arp}}
\index{Needs\+Arp@{Needs\+Arp}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Needs\+Arp(void) const }{NeedsArp(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Fd\+Net\+Device\+::\+Needs\+Arp (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDevice_a2cd99374da02cce70f3c2f06b8c41d3d}{}\label{classns3_1_1FdNetDevice_a2cd99374da02cce70f3c2f06b8c41d3d}
\begin{DoxyReturn}{Returns}
true if A\+RP is needed, false otherwise.
\end{DoxyReturn}
Called by higher-\/layers to check if this \hyperlink{classns3_1_1NetDevice}{Net\+Device} requires A\+RP to be used. 

Implements \hyperlink{classns3_1_1NetDevice_ab1a133696310cad3dc2c3d1a4993f310}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
747 \{
748   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
749 \}
\end{DoxyCode}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Notify\+Link\+Up@{Notify\+Link\+Up}}
\index{Notify\+Link\+Up@{Notify\+Link\+Up}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Notify\+Link\+Up(void)}{NotifyLinkUp(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Fd\+Net\+Device\+::\+Notify\+Link\+Up (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_a5e53758ee0fae578ad7e759b29193ea8}{}\label{classns3_1_1FdNetDevice_a5e53758ee0fae578ad7e759b29193ea8}
Notify that the link is up and ready 
\begin{DoxyCode}
625 \{
626   \hyperlink{classns3_1_1FdNetDevice_abf646fbe52523693488607b6ee9a7578}{m\_linkUp} = \textcolor{keyword}{true};
627   \hyperlink{classns3_1_1FdNetDevice_a3e8d275156225016c9e518ae5429ade7}{m\_linkChangeCallbacks} ();
628 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 12


\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Receive\+Callback@{Receive\+Callback}}
\index{Receive\+Callback@{Receive\+Callback}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Receive\+Callback(uint8\+\_\+t $\ast$buf, ssize\+\_\+t len)}{ReceiveCallback(uint8_t *buf, ssize_t len)}}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf ns3\+::\+Fd\+Net\+Device\+::\+Receive\+Callback} (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$}]{buf, }
\item[{ssize\+\_\+t}]{len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_a65d669a9883c299c5527bbe0b9f33aef}{}\label{classns3_1_1FdNetDevice_a65d669a9883c299c5527bbe0b9f33aef}
\hyperlink{classns3_1_1Callback}{Callback} to invoke when a new frame is received 
\begin{DoxyCode}
290 \{
291   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << buf << len);
292   \textcolor{keywordtype}{bool} skip = \textcolor{keyword}{false};
293 
294   \{
295     CriticalSection cs (\hyperlink{classns3_1_1FdNetDevice_a957f57e977ee857a0233a484c276d427}{m\_pendingReadMutex});
296     \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1FdNetDevice_a58492550a84c8c2c959b4d4904342d70}{m\_pendingQueue}.size () >= \hyperlink{classns3_1_1FdNetDevice_a4be8b630492f263f0cb5f9c5fd223eac}{m\_maxPendingReads})
297       \{
298         \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Packet dropped"});
299         skip = \textcolor{keyword}{true};
300       \}
301     \textcolor{keywordflow}{else}
302       \{
303         \hyperlink{classns3_1_1FdNetDevice_a58492550a84c8c2c959b4d4904342d70}{m\_pendingQueue}.push (std::make\_pair (buf, len));
304       \}
305   \}
306 
307   \textcolor{keywordflow}{if} (skip)
308     \{
309       \textcolor{keyword}{struct }timespec time = \{
310         0, 100000000\hyperlink{loss__ITU1411__NLOS__over__rooftop_8m_a0f93e2c2e7c447b4dfc5bcac7e346da1}{L}
311       \};                                        \textcolor{comment}{// 100 ms}
312       nanosleep (&time, NULL);
313     \}
314   \textcolor{keywordflow}{else}
315     \{
316       \hyperlink{classns3_1_1Simulator_a86dbaef45a15a42365d7d2ae550449f6}{Simulator::ScheduleWithContext} (\hyperlink{classns3_1_1FdNetDevice_aed43dab9b55bd308388c3a9f1510a709}{m\_nodeId}, 
      \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (0), \hyperlink{group__makeeventfnptr_ga289a28a2497c18a9bd299e5e2014094b}{MakeEvent} (&\hyperlink{classns3_1_1FdNetDevice_a7fd80498ff2e6f9fd91f0f5db3c5dbd5}{FdNetDevice::ForwardUp}, \textcolor{keyword}{this}));
317     \}
318 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13


\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Send@{Send}}
\index{Send@{Send}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Send(\+Ptr$<$ Packet $>$ packet, const Address \&dest, uint16\+\_\+t protocol\+Number)}{Send(Ptr< Packet > packet, const Address &dest, uint16_t protocolNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Fd\+Net\+Device\+::\+Send (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{const {\bf Address} \&}]{dest, }
\item[{uint16\+\_\+t}]{protocol\+Number}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDevice_aa6a59de8f1c4586446d8d59213f60619}{}\label{classns3_1_1FdNetDevice_aa6a59de8f1c4586446d8d59213f60619}

\begin{DoxyParams}{Parameters}
{\em packet} & packet sent from above down to Network Device \\
\hline
{\em dest} & mac address of the destination (already resolved) \\
\hline
{\em protocol\+Number} & identifies the type of payload contained in this packet. Used to call the right L3\+Protocol when the packet is received.\\
\hline
\end{DoxyParams}
Called from higher layer to send packet into Network Device to the specified destination \hyperlink{classns3_1_1Address}{Address}

\begin{DoxyReturn}{Returns}
whether the Send operation succeeded 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a59f41afb0fe8951bb94d5739cbe6ee7d}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
522 \{
523   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << destination << protocolNumber);
524   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1FdNetDevice_acf6a3cd28d254cd41c1776cbb55095cb}{SendFrom} (packet, \hyperlink{classns3_1_1FdNetDevice_ad6ce5cc7c15f7a9c79a0c822aea60036}{m\_address}, destination, protocolNumber);
525 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 14


\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Send\+From@{Send\+From}}
\index{Send\+From@{Send\+From}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Send\+From(\+Ptr$<$ Packet $>$ packet, const Address \&source, const Address \&dest, uint16\+\_\+t protocol\+Number)}{SendFrom(Ptr< Packet > packet, const Address &source, const Address &dest, uint16_t protocolNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Fd\+Net\+Device\+::\+Send\+From (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{const {\bf Address} \&}]{source, }
\item[{const {\bf Address} \&}]{dest, }
\item[{uint16\+\_\+t}]{protocol\+Number}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDevice_acf6a3cd28d254cd41c1776cbb55095cb}{}\label{classns3_1_1FdNetDevice_acf6a3cd28d254cd41c1776cbb55095cb}

\begin{DoxyParams}{Parameters}
{\em packet} & packet sent from above down to Network Device \\
\hline
{\em source} & source mac address (so called \char`\"{}\+M\+A\+C spoofing\char`\"{}) \\
\hline
{\em dest} & mac address of the destination (already resolved) \\
\hline
{\em protocol\+Number} & identifies the type of payload contained in this packet. Used to call the right L3\+Protocol when the packet is received.\\
\hline
\end{DoxyParams}
Called from higher layer to send packet into Network Device with the specified source and destination Addresses.

\begin{DoxyReturn}{Returns}
whether the Send operation succeeded 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a19d55a4746c1ae584bf7da69959a885b}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
529 \{
530   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << src << dest << protocolNumber);
531   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"packet: "} << packet << \textcolor{stringliteral}{" UID: "} << packet->\hyperlink{classns3_1_1Packet_a1f212c825b50e54d94f5b9ae99592e6a}{GetUid} ());
532 
533   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1FdNetDevice_afe7a9225c43079850621ff0af3dc50c9}{IsLinkUp} () == \textcolor{keyword}{false})
534     \{
535       \hyperlink{classns3_1_1FdNetDevice_ad204b6948cb00479cc229465c6c07ebb}{m\_macTxDropTrace} (packet);
536       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
537     \}
538 
539   Mac48Address destination = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (dest);
540   Mac48Address source = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (src);
541 
542   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Transmit packet with UID "} << packet->\hyperlink{classns3_1_1Packet_a1f212c825b50e54d94f5b9ae99592e6a}{GetUid} ());
543   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Transmit packet from "} << source);
544   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Transmit packet to "} << destination);
545 
546   EthernetHeader header (\textcolor{keyword}{false});
547   header.SetSource (source);
548   header.SetDestination (destination);
549 
550   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (packet->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} () <= \hyperlink{classns3_1_1FdNetDevice_a26eb80ddedbacaf1f5a1c19940e7225d}{m\_mtu}, \textcolor{stringliteral}{"FdNetDevice::SendFrom(): Packet too
       big "} << packet->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ());
551 
552   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1FdNetDevice_aa5d97abfd57576f6b80423ac764e5cc8}{m\_encapMode} == \hyperlink{classns3_1_1FdNetDevice_abdacbf10c181f50998a98e7688016618ac6f7f5fa39999c05c1b1c2c5e5dd8889}{LLC})
553     \{
554       LlcSnapHeader llc;
555       llc.SetType (protocolNumber);
556       packet->\hyperlink{classns3_1_1Packet_a465108c595a0bc592095cbcab1832ed8}{AddHeader} (llc);
557 
558       header.SetLengthType (packet->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ());
559     \}
560   \textcolor{keywordflow}{else}
561     \{
562       header.SetLengthType (protocolNumber);
563     \}
564 
565   packet->\hyperlink{classns3_1_1Packet_a465108c595a0bc592095cbcab1832ed8}{AddHeader} (header);
566 
567   \textcolor{comment}{//}
568   \textcolor{comment}{// there's not much meaning associated with the different layers in this}
569   \textcolor{comment}{// device, so don't be surprised when they're all stacked together in}
570   \textcolor{comment}{// essentially one place.  We do this for trace consistency across devices.}
571   \textcolor{comment}{//}
572   \hyperlink{classns3_1_1FdNetDevice_a7a067bc7ab39f2ebfcc925a58da4f519}{m\_macTxTrace} (packet);
573 
574   \hyperlink{classns3_1_1FdNetDevice_a7f43138ecf824b335eb80eeebdb91eb6}{m\_promiscSnifferTrace} (packet);
575   \hyperlink{classns3_1_1FdNetDevice_a821080a2cc1253e22918e8fcedcfbe58}{m\_snifferTrace} (packet);
576 
577   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"calling write"});
578 
579 
580   \textcolor{keywordtype}{size\_t} len =  (size\_t) packet->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ();
581   uint8\_t *buffer = (uint8\_t*)malloc (len);
582   packet->\hyperlink{classns3_1_1Packet_a5a6d304b9e0d90733919ffe224b98f0d}{CopyData} (buffer, len);
583 
584   \textcolor{comment}{// We need to add the PI header}
585   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1FdNetDevice_aa5d97abfd57576f6b80423ac764e5cc8}{m\_encapMode} == \hyperlink{classns3_1_1FdNetDevice_abdacbf10c181f50998a98e7688016618abbad9c0d0fe0604652f21e33cf4d8798}{DIXPI})
586     \{
587       \hyperlink{group__fd-net-device_gad3e41a1d562aec7c106c65c5964071b6}{AddPIHeader} (buffer, len);
588     \}
589 
590   ssize\_t written = write (\hyperlink{classns3_1_1FdNetDevice_a2351bba8f2719557d98ff85e88b451a5}{m\_fd}, buffer, len);
591   free (buffer);
592 
593   \textcolor{keywordflow}{if} (written == -1 || (\textcolor{keywordtype}{size\_t}) written != len)
594     \{
595       \hyperlink{classns3_1_1FdNetDevice_ad204b6948cb00479cc229465c6c07ebb}{m\_macTxDropTrace} (packet);
596       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
597     \}
598 
599   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
600 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 15




Here is the caller graph for this function\+:
% FIG 16


\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Set\+Address@{Set\+Address}}
\index{Set\+Address@{Set\+Address}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Address(\+Address address)}{SetAddress(Address address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Fd\+Net\+Device\+::\+Set\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDevice_a7fd0f69ac39428a18e354ffe21d15d6c}{}\label{classns3_1_1FdNetDevice_a7fd0f69ac39428a18e354ffe21d15d6c}
Set the address of this interface 
\begin{DoxyParams}{Parameters}
{\em address} & address to set \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1NetDevice_ab56dc36bc0547471ab3210eda60ee76c}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
613 \{
614   \hyperlink{classns3_1_1FdNetDevice_ad6ce5cc7c15f7a9c79a0c822aea60036}{m\_address} = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (address);
615 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 17




Here is the caller graph for this function\+:
% FIG 18


\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Set\+Encapsulation\+Mode@{Set\+Encapsulation\+Mode}}
\index{Set\+Encapsulation\+Mode@{Set\+Encapsulation\+Mode}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Encapsulation\+Mode(\+Fd\+Net\+Device\+::\+Encapsulation\+Mode mode)}{SetEncapsulationMode(FdNetDevice::EncapsulationMode mode)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Fd\+Net\+Device\+::\+Set\+Encapsulation\+Mode (
\begin{DoxyParamCaption}
\item[{{\bf Fd\+Net\+Device\+::\+Encapsulation\+Mode}}]{mode}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1FdNetDevice_a93861c71ec179c621b192ec0f864cff4}{}\label{classns3_1_1FdNetDevice_a93861c71ec179c621b192ec0f864cff4}
Set the link layer encapsulation mode of this device.


\begin{DoxyParams}{Parameters}
{\em mode} & The link layer encapsulation mode of this device. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
215 \{
216   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (mode);
217   \hyperlink{classns3_1_1FdNetDevice_aa5d97abfd57576f6b80423ac764e5cc8}{m\_encapMode} = mode;
218   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"m\_encapMode = "} << \hyperlink{classns3_1_1FdNetDevice_aa5d97abfd57576f6b80423ac764e5cc8}{m\_encapMode});
219 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 19


\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Set\+File\+Descriptor@{Set\+File\+Descriptor}}
\index{Set\+File\+Descriptor@{Set\+File\+Descriptor}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+File\+Descriptor(int fd)}{SetFileDescriptor(int fd)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Fd\+Net\+Device\+::\+Set\+File\+Descriptor (
\begin{DoxyParamCaption}
\item[{int}]{fd}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1FdNetDevice_ac72fff1b3d44824245645a9bcb37c709}{}\label{classns3_1_1FdNetDevice_ac72fff1b3d44824245645a9bcb37c709}
Set the associated file descriptor. 
\begin{DoxyCode}
604 \{
605   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1FdNetDevice_a2351bba8f2719557d98ff85e88b451a5}{m\_fd} == -1 and \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_a44f21d5190b5a6df8089f54799628d7e}{fd} > 0)
606     \{
607       \hyperlink{classns3_1_1FdNetDevice_a2351bba8f2719557d98ff85e88b451a5}{m\_fd} = \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_a44f21d5190b5a6df8089f54799628d7e}{fd};
608     \}
609 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 20


\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Set\+If\+Index@{Set\+If\+Index}}
\index{Set\+If\+Index@{Set\+If\+Index}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+If\+Index(const uint32\+\_\+t index)}{SetIfIndex(const uint32_t index)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Fd\+Net\+Device\+::\+Set\+If\+Index (
\begin{DoxyParamCaption}
\item[{const uint32\+\_\+t}]{index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDevice_a7e94668589f3e9778d536da9788fa119}{}\label{classns3_1_1FdNetDevice_a7e94668589f3e9778d536da9788fa119}

\begin{DoxyParams}{Parameters}
{\em index} & if\+Index of the device \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1NetDevice_a2e1ac6c1189cd565420305d85a193fb8}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
632 \{
633   \hyperlink{classns3_1_1FdNetDevice_a1b65e4f3e463c7ae49267e26213a6392}{m\_ifIndex} = index;
634 \}
\end{DoxyCode}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Set\+Is\+Broadcast@{Set\+Is\+Broadcast}}
\index{Set\+Is\+Broadcast@{Set\+Is\+Broadcast}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Is\+Broadcast(bool broadcast)}{SetIsBroadcast(bool broadcast)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Fd\+Net\+Device\+::\+Set\+Is\+Broadcast (
\begin{DoxyParamCaption}
\item[{bool}]{broadcast}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDevice_a2a3c8e37a145215384b62a2a7d7618b9}{}\label{classns3_1_1FdNetDevice_a2a3c8e37a145215384b62a2a7d7618b9}
Set if the \hyperlink{classns3_1_1NetDevice}{Net\+Device} is able to send Broadcast messages 
\begin{DoxyParams}{Parameters}
{\em broadcast} & true if the \hyperlink{classns3_1_1NetDevice}{Net\+Device} can send Broadcast \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
687 \{
688   \hyperlink{classns3_1_1FdNetDevice_a0c9a5b7d7802458647ac8f2af3e80176}{m\_isBroadcast} = broadcast;
689 \}
\end{DoxyCode}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Set\+Is\+Multicast@{Set\+Is\+Multicast}}
\index{Set\+Is\+Multicast@{Set\+Is\+Multicast}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Is\+Multicast(bool multicast)}{SetIsMulticast(bool multicast)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Fd\+Net\+Device\+::\+Set\+Is\+Multicast (
\begin{DoxyParamCaption}
\item[{bool}]{multicast}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDevice_ad94f95495b987f43330cfa3ee4088ce5}{}\label{classns3_1_1FdNetDevice_ad94f95495b987f43330cfa3ee4088ce5}
Set if the \hyperlink{classns3_1_1NetDevice}{Net\+Device} is able to send Multicast messages 
\begin{DoxyParams}{Parameters}
{\em multicast} & true if the \hyperlink{classns3_1_1NetDevice}{Net\+Device} can send Multicast \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
705 \{
706   \hyperlink{classns3_1_1FdNetDevice_a781a28aa762e85bca94a29f3686ee15b}{m\_isMulticast} = multicast;
707 \}
\end{DoxyCode}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Set\+Mtu@{Set\+Mtu}}
\index{Set\+Mtu@{Set\+Mtu}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Mtu(const uint16\+\_\+t mtu)}{SetMtu(const uint16_t mtu)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Fd\+Net\+Device\+::\+Set\+Mtu (
\begin{DoxyParamCaption}
\item[{const uint16\+\_\+t}]{mtu}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDevice_a7f1ac465e2a943f0369c99bd3525bb00}{}\label{classns3_1_1FdNetDevice_a7f1ac465e2a943f0369c99bd3525bb00}

\begin{DoxyParams}{Parameters}
{\em mtu} & M\+TU value, in bytes, to set for the device \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether the M\+TU value was within legal bounds
\end{DoxyReturn}
Override for default M\+TU defined on a per-\/type basis. 

Implements \hyperlink{classns3_1_1NetDevice_a2ba4956d45cde68eab3cbdd6ede06df0}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
650 \{
651   \textcolor{comment}{// The MTU depends on the technology associated to }
652   \textcolor{comment}{// the file descriptor. The user is responsible of}
653   \textcolor{comment}{// setting the correct value of the MTU.}
654   \textcolor{comment}{// If the file descriptor is created using a helper,}
655   \textcolor{comment}{// then is the responsibility of the helper to set }
656   \textcolor{comment}{// the correct MTU value.}
657   \hyperlink{classns3_1_1FdNetDevice_a26eb80ddedbacaf1f5a1c19940e7225d}{m\_mtu} = mtu;
658   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
659 \}
\end{DoxyCode}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Set\+Node@{Set\+Node}}
\index{Set\+Node@{Set\+Node}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Node(\+Ptr$<$ Node $>$ node)}{SetNode(Ptr< Node > node)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Fd\+Net\+Device\+::\+Set\+Node (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDevice_a2f695f5c375f5e69df201956347881aa}{}\label{classns3_1_1FdNetDevice_a2f695f5c375f5e69df201956347881aa}

\begin{DoxyParams}{Parameters}
{\em node} & the node associated to this netdevice.\\
\hline
\end{DoxyParams}
This method is called from \hyperlink{classns3_1_1Node_a42ff83ee1d5d1649c770d3f5b62375de}{ns3\+::\+Node\+::\+Add\+Device}. 

Implements \hyperlink{classns3_1_1NetDevice_a3ae520ae06e93b957f0f56f113319a08}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
741 \{
742   \hyperlink{classns3_1_1FdNetDevice_a344e2f5a2628c1a0305d5b4bbf72f8c6}{m\_node} = node;
743 \}
\end{DoxyCode}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Set\+Promisc\+Receive\+Callback@{Set\+Promisc\+Receive\+Callback}}
\index{Set\+Promisc\+Receive\+Callback@{Set\+Promisc\+Receive\+Callback}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Promisc\+Receive\+Callback(\+Net\+Device\+::\+Promisc\+Receive\+Callback cb)}{SetPromiscReceiveCallback(NetDevice::PromiscReceiveCallback cb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Fd\+Net\+Device\+::\+Set\+Promisc\+Receive\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Net\+Device\+::\+Promisc\+Receive\+Callback}}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDevice_abdca762c17ee6f58513daefb92b18471}{}\label{classns3_1_1FdNetDevice_abdca762c17ee6f58513daefb92b18471}

\begin{DoxyParams}{Parameters}
{\em cb} & callback to invoke whenever a packet has been received in promiscuous mode and must be forwarded to the higher layers.\\
\hline
\end{DoxyParams}
Enables netdevice promiscuous mode and sets the callback that will handle promiscuous mode packets. Note, promiscuous mode packets means {\itshape all} packets, including those packets that can be sensed by the netdevice but which are intended to be received by other hosts. 

Implements \hyperlink{classns3_1_1NetDevice_a3968946bdbb74d47d7b13612baad7d6d}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
759 \{
760   \hyperlink{classns3_1_1FdNetDevice_aa95f558a530aca66f7fe582559902160}{m\_promiscRxCallback} = cb;
761 \}
\end{DoxyCode}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Set\+Receive\+Callback@{Set\+Receive\+Callback}}
\index{Set\+Receive\+Callback@{Set\+Receive\+Callback}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Receive\+Callback(\+Net\+Device\+::\+Receive\+Callback cb)}{SetReceiveCallback(NetDevice::ReceiveCallback cb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Fd\+Net\+Device\+::\+Set\+Receive\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Net\+Device\+::\+Receive\+Callback}}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDevice_a4a2ba76da683b88593eb4456169cbf21}{}\label{classns3_1_1FdNetDevice_a4a2ba76da683b88593eb4456169cbf21}

\begin{DoxyParams}{Parameters}
{\em cb} & callback to invoke whenever a packet has been received and must be forwarded to the higher layers.\\
\hline
\end{DoxyParams}
Set the callback to be used to notify higher layers when a packet has been received. 

Implements \hyperlink{classns3_1_1NetDevice_ac63e4d5668e421fec4b5d37f32e7dd18}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
753 \{
754   \hyperlink{classns3_1_1FdNetDevice_a5c3e9d04b053c707a4188f823a6bc2ab}{m\_rxCallback} = cb;
755 \}
\end{DoxyCode}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Start@{Start}}
\index{Start@{Start}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Start(\+Time t\+Start)}{Start(Time tStart)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Fd\+Net\+Device\+::\+Start (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{t\+Start}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1FdNetDevice_a32bda505142d81a4092048bf200ee6fc}{}\label{classns3_1_1FdNetDevice_a32bda505142d81a4092048bf200ee6fc}
Set a start time for the device.


\begin{DoxyParams}{Parameters}
{\em t\+Start} & the start time \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
230 \{
231   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (tStart);
232   \hyperlink{classns3_1_1Simulator_a1b903a62d6117ef28f7ba3c6500689bf}{Simulator::Cancel} (\hyperlink{classns3_1_1FdNetDevice_a759e74ace56841b2ae47c69ff0276b2f}{m\_startEvent});
233   \hyperlink{classns3_1_1FdNetDevice_a759e74ace56841b2ae47c69ff0276b2f}{m\_startEvent} = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (tStart, &
      \hyperlink{classns3_1_1FdNetDevice_afec16ee9ae009f427348474f9e9c3c50}{FdNetDevice::StartDevice}, \textcolor{keyword}{this});
234 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 21




Here is the caller graph for this function\+:
% FIG 22


\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Start\+Device@{Start\+Device}}
\index{Start\+Device@{Start\+Device}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Start\+Device(void)}{StartDevice(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Fd\+Net\+Device\+::\+Start\+Device (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_afec16ee9ae009f427348474f9e9c3c50}{}\label{classns3_1_1FdNetDevice_afec16ee9ae009f427348474f9e9c3c50}
Spin up the device 
\begin{DoxyCode}
246 \{
247   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
248 
249   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1FdNetDevice_a2351bba8f2719557d98ff85e88b451a5}{m\_fd} == -1)
250     \{
251       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"FdNetDevice::Start(): Failure, invalid file descriptor."});
252       \textcolor{keywordflow}{return};
253     \}
254   \textcolor{comment}{//}
255   \textcolor{comment}{// A similar story exists for the node ID.  We can't just naively do a}
256   \textcolor{comment}{// GetNode ()->GetId () since GetNode is going to give us a Ptr<Node> which}
257   \textcolor{comment}{// is reference counted.  We need to stash away the node ID for use in the}
258   \textcolor{comment}{// read thread.}
259   \textcolor{comment}{//}
260   \hyperlink{classns3_1_1FdNetDevice_aed43dab9b55bd308388c3a9f1510a709}{m\_nodeId} = \hyperlink{classns3_1_1FdNetDevice_a301f937cb45179136ad4b2fe4750a56f}{GetNode} ()->\hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} ();
261 
262   \hyperlink{classns3_1_1FdNetDevice_ac678c4f411e1982c5d2416f7c05ebd3b}{m\_fdReader} = Create<FdNetDeviceFdReader> ();
263   \textcolor{comment}{// 22 bytes covers 14 bytes Ethernet header with possible 8 bytes LLC/SNAP}
264   \hyperlink{classns3_1_1FdNetDevice_ac678c4f411e1982c5d2416f7c05ebd3b}{m\_fdReader}->SetBufferSize (\hyperlink{classns3_1_1FdNetDevice_a26eb80ddedbacaf1f5a1c19940e7225d}{m\_mtu} + 22);
265   \hyperlink{classns3_1_1FdNetDevice_ac678c4f411e1982c5d2416f7c05ebd3b}{m\_fdReader}->Start (\hyperlink{classns3_1_1FdNetDevice_a2351bba8f2719557d98ff85e88b451a5}{m\_fd}, \hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1FdNetDevice_a65d669a9883c299c5527bbe0b9f33aef}{FdNetDevice::ReceiveCallback}, \textcolor{keyword}{this}));
266 
267   \hyperlink{classns3_1_1FdNetDevice_a5e53758ee0fae578ad7e759b29193ea8}{NotifyLinkUp} ();
268 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 23




Here is the caller graph for this function\+:
% FIG 24


\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Stop@{Stop}}
\index{Stop@{Stop}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Stop(\+Time t\+Stop)}{Stop(Time tStop)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Fd\+Net\+Device\+::\+Stop (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{t\+Stop}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1FdNetDevice_a6849d18a8f1ed78077207057dce6c7ca}{}\label{classns3_1_1FdNetDevice_a6849d18a8f1ed78077207057dce6c7ca}
Set a stop time for the device.


\begin{DoxyParams}{Parameters}
{\em t\+Stop} & the stop time \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
238 \{
239   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (tStop);
240   \hyperlink{classns3_1_1Simulator_a1b903a62d6117ef28f7ba3c6500689bf}{Simulator::Cancel} (\hyperlink{classns3_1_1FdNetDevice_a010c8ac9ac2fffeb6ce1ffaf94b5a890}{m\_stopEvent});
241   \hyperlink{classns3_1_1FdNetDevice_a759e74ace56841b2ae47c69ff0276b2f}{m\_startEvent} = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (tStop, &
      \hyperlink{classns3_1_1FdNetDevice_ae5603448cbdc59550ce805f8c4c786e5}{FdNetDevice::StopDevice}, \textcolor{keyword}{this});
242 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 25


\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Stop\+Device@{Stop\+Device}}
\index{Stop\+Device@{Stop\+Device}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Stop\+Device(void)}{StopDevice(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Fd\+Net\+Device\+::\+Stop\+Device (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_ae5603448cbdc59550ce805f8c4c786e5}{}\label{classns3_1_1FdNetDevice_ae5603448cbdc59550ce805f8c4c786e5}
Tear down the device 
\begin{DoxyCode}
272 \{
273   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
274 
275   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1FdNetDevice_ac678c4f411e1982c5d2416f7c05ebd3b}{m\_fdReader} != 0)
276     \{
277       \hyperlink{classns3_1_1FdNetDevice_ac678c4f411e1982c5d2416f7c05ebd3b}{m\_fdReader}->Stop ();
278       \hyperlink{classns3_1_1FdNetDevice_ac678c4f411e1982c5d2416f7c05ebd3b}{m\_fdReader} = 0;
279     \}
280 
281   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1FdNetDevice_a2351bba8f2719557d98ff85e88b451a5}{m\_fd} != -1)
282     \{
283       close (\hyperlink{classns3_1_1FdNetDevice_a2351bba8f2719557d98ff85e88b451a5}{m\_fd});
284       \hyperlink{classns3_1_1FdNetDevice_a2351bba8f2719557d98ff85e88b451a5}{m\_fd} = -1;
285     \}
286 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 26


\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Supports\+Send\+From@{Supports\+Send\+From}}
\index{Supports\+Send\+From@{Supports\+Send\+From}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Supports\+Send\+From() const }{SupportsSendFrom() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Fd\+Net\+Device\+::\+Supports\+Send\+From (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1FdNetDevice_a658792f0ed912154af2a2ffd90ce9905}{}\label{classns3_1_1FdNetDevice_a658792f0ed912154af2a2ffd90ce9905}
\begin{DoxyReturn}{Returns}
true if this interface supports a bridging mode, false otherwise. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a04793d220b54c40e110ebf86dae5b25c}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
765 \{
766   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
767 \}
\end{DoxyCode}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!Transmit\+Start@{Transmit\+Start}}
\index{Transmit\+Start@{Transmit\+Start}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{Transmit\+Start(\+Ptr$<$ Packet $>$ p)}{TransmitStart(Ptr< Packet > p)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Fd\+Net\+Device\+::\+Transmit\+Start (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_aaeea471746751f9e33fe79caead4a329}{}\label{classns3_1_1FdNetDevice_aaeea471746751f9e33fe79caead4a329}
Start Sending a \hyperlink{classns3_1_1Packet}{Packet} Down the Wire. 
\begin{DoxyParams}{Parameters}
{\em p} & packet to send \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if success, false on failure 
\end{DoxyReturn}


\subsection{Member Data Documentation}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!m\+\_\+address@{m\+\_\+address}}
\index{m\+\_\+address@{m\+\_\+address}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+address}{m_address}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Mac48\+Address} ns3\+::\+Fd\+Net\+Device\+::m\+\_\+address\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_ad6ce5cc7c15f7a9c79a0c822aea60036}{}\label{classns3_1_1FdNetDevice_ad6ce5cc7c15f7a9c79a0c822aea60036}
The net device mac address. \index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!m\+\_\+encap\+Mode@{m\+\_\+encap\+Mode}}
\index{m\+\_\+encap\+Mode@{m\+\_\+encap\+Mode}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+encap\+Mode}{m_encapMode}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Encapsulation\+Mode} ns3\+::\+Fd\+Net\+Device\+::m\+\_\+encap\+Mode\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_aa5d97abfd57576f6b80423ac764e5cc8}{}\label{classns3_1_1FdNetDevice_aa5d97abfd57576f6b80423ac764e5cc8}
The typ of encapsulation of the received/transmited frames. \index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!m\+\_\+fd@{m\+\_\+fd}}
\index{m\+\_\+fd@{m\+\_\+fd}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+fd}{m_fd}}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Fd\+Net\+Device\+::m\+\_\+fd\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_a2351bba8f2719557d98ff85e88b451a5}{}\label{classns3_1_1FdNetDevice_a2351bba8f2719557d98ff85e88b451a5}
The file descriptor used for receive/send network traffic. \index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!m\+\_\+fd\+Reader@{m\+\_\+fd\+Reader}}
\index{m\+\_\+fd\+Reader@{m\+\_\+fd\+Reader}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+fd\+Reader}{m_fdReader}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Fd\+Net\+Device\+Fd\+Reader}$>$ ns3\+::\+Fd\+Net\+Device\+::m\+\_\+fd\+Reader\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_ac678c4f411e1982c5d2416f7c05ebd3b}{}\label{classns3_1_1FdNetDevice_ac678c4f411e1982c5d2416f7c05ebd3b}
Reader for the file descriptor. \index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!m\+\_\+if\+Index@{m\+\_\+if\+Index}}
\index{m\+\_\+if\+Index@{m\+\_\+if\+Index}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+if\+Index}{m_ifIndex}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Fd\+Net\+Device\+::m\+\_\+if\+Index\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_a1b65e4f3e463c7ae49267e26213a6392}{}\label{classns3_1_1FdNetDevice_a1b65e4f3e463c7ae49267e26213a6392}
The ns-\/3 interface index (in the sense of net device index) that has been assigned to this network device. \index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!m\+\_\+is\+Broadcast@{m\+\_\+is\+Broadcast}}
\index{m\+\_\+is\+Broadcast@{m\+\_\+is\+Broadcast}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+is\+Broadcast}{m_isBroadcast}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Fd\+Net\+Device\+::m\+\_\+is\+Broadcast\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_a0c9a5b7d7802458647ac8f2af3e80176}{}\label{classns3_1_1FdNetDevice_a0c9a5b7d7802458647ac8f2af3e80176}
Flag indicating whether or not the underlying net device supports broadcast. \index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!m\+\_\+is\+Multicast@{m\+\_\+is\+Multicast}}
\index{m\+\_\+is\+Multicast@{m\+\_\+is\+Multicast}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+is\+Multicast}{m_isMulticast}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Fd\+Net\+Device\+::m\+\_\+is\+Multicast\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_a781a28aa762e85bca94a29f3686ee15b}{}\label{classns3_1_1FdNetDevice_a781a28aa762e85bca94a29f3686ee15b}
Flag indicating whether or not the underlying net device supports multicast. \index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!m\+\_\+link\+Change\+Callbacks@{m\+\_\+link\+Change\+Callbacks}}
\index{m\+\_\+link\+Change\+Callbacks@{m\+\_\+link\+Change\+Callbacks}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+link\+Change\+Callbacks}{m_linkChangeCallbacks}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback} ns3\+::\+Fd\+Net\+Device\+::m\+\_\+link\+Change\+Callbacks\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_a3e8d275156225016c9e518ae5429ade7}{}\label{classns3_1_1FdNetDevice_a3e8d275156225016c9e518ae5429ade7}
Callbacks to fire if the link changes state (up or down). \index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!m\+\_\+link\+Up@{m\+\_\+link\+Up}}
\index{m\+\_\+link\+Up@{m\+\_\+link\+Up}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+link\+Up}{m_linkUp}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Fd\+Net\+Device\+::m\+\_\+link\+Up\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_abf646fbe52523693488607b6ee9a7578}{}\label{classns3_1_1FdNetDevice_abf646fbe52523693488607b6ee9a7578}
Flag indicating whether or not the link is up. In this case, whether or not the device is connected to a channel. \index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!m\+\_\+mac\+Promisc\+Rx\+Trace@{m\+\_\+mac\+Promisc\+Rx\+Trace}}
\index{m\+\_\+mac\+Promisc\+Rx\+Trace@{m\+\_\+mac\+Promisc\+Rx\+Trace}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+mac\+Promisc\+Rx\+Trace}{m_macPromiscRxTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Fd\+Net\+Device\+::m\+\_\+mac\+Promisc\+Rx\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_ac0fbee33fa2dc3d5349f33f794364fdb}{}\label{classns3_1_1FdNetDevice_ac0fbee33fa2dc3d5349f33f794364fdb}
The trace source fired for packets successfully received by the device immediately before being forwarded up to higher layers (at the L2/\+L3 transition). This is a promiscuous trace.

\begin{DoxySeeAlso}{See also}
class Call\+Back\+Trace\+Source 
\end{DoxySeeAlso}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!m\+\_\+mac\+Rx\+Drop\+Trace@{m\+\_\+mac\+Rx\+Drop\+Trace}}
\index{m\+\_\+mac\+Rx\+Drop\+Trace@{m\+\_\+mac\+Rx\+Drop\+Trace}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+mac\+Rx\+Drop\+Trace}{m_macRxDropTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Fd\+Net\+Device\+::m\+\_\+mac\+Rx\+Drop\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_a1aa224dd6e458d104dda994ea7448f7d}{}\label{classns3_1_1FdNetDevice_a1aa224dd6e458d104dda994ea7448f7d}
The trace source fired for packets successfully received by the device but which are dropped before being forwarded up to higher layers (at the L2/\+L3 transition).

\begin{DoxySeeAlso}{See also}
class Call\+Back\+Trace\+Source 
\end{DoxySeeAlso}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!m\+\_\+mac\+Rx\+Trace@{m\+\_\+mac\+Rx\+Trace}}
\index{m\+\_\+mac\+Rx\+Trace@{m\+\_\+mac\+Rx\+Trace}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+mac\+Rx\+Trace}{m_macRxTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Fd\+Net\+Device\+::m\+\_\+mac\+Rx\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_a5d526995e92ac4957170d9b8a680bad1}{}\label{classns3_1_1FdNetDevice_a5d526995e92ac4957170d9b8a680bad1}
The trace source fired for packets successfully received by the device immediately before being forwarded up to higher layers (at the L2/\+L3 transition). This is a non-\/promiscuous trace.

\begin{DoxySeeAlso}{See also}
class Call\+Back\+Trace\+Source 
\end{DoxySeeAlso}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!m\+\_\+mac\+Tx\+Drop\+Trace@{m\+\_\+mac\+Tx\+Drop\+Trace}}
\index{m\+\_\+mac\+Tx\+Drop\+Trace@{m\+\_\+mac\+Tx\+Drop\+Trace}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+mac\+Tx\+Drop\+Trace}{m_macTxDropTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Fd\+Net\+Device\+::m\+\_\+mac\+Tx\+Drop\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_ad204b6948cb00479cc229465c6c07ebb}{}\label{classns3_1_1FdNetDevice_ad204b6948cb00479cc229465c6c07ebb}
The trace source fired when packets coming into the \char`\"{}top\char`\"{} of the device at the L3/\+L2 transition are dropped before being queued for transmission.

\begin{DoxySeeAlso}{See also}
class Call\+Back\+Trace\+Source 
\end{DoxySeeAlso}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!m\+\_\+mac\+Tx\+Trace@{m\+\_\+mac\+Tx\+Trace}}
\index{m\+\_\+mac\+Tx\+Trace@{m\+\_\+mac\+Tx\+Trace}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+mac\+Tx\+Trace}{m_macTxTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Fd\+Net\+Device\+::m\+\_\+mac\+Tx\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_a7a067bc7ab39f2ebfcc925a58da4f519}{}\label{classns3_1_1FdNetDevice_a7a067bc7ab39f2ebfcc925a58da4f519}
The trace source fired when packets come into the \char`\"{}top\char`\"{} of the device at the L3/\+L2 transition, before being queued for transmission.

\begin{DoxySeeAlso}{See also}
class Call\+Back\+Trace\+Source 
\end{DoxySeeAlso}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!m\+\_\+max\+Pending\+Reads@{m\+\_\+max\+Pending\+Reads}}
\index{m\+\_\+max\+Pending\+Reads@{m\+\_\+max\+Pending\+Reads}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Pending\+Reads}{m_maxPendingReads}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Fd\+Net\+Device\+::m\+\_\+max\+Pending\+Reads\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_a4be8b630492f263f0cb5f9c5fd223eac}{}\label{classns3_1_1FdNetDevice_a4be8b630492f263f0cb5f9c5fd223eac}
Maximum number of packets that can be received and scheduled for read but not yeat read. \index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!m\+\_\+mtu@{m\+\_\+mtu}}
\index{m\+\_\+mtu@{m\+\_\+mtu}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+mtu}{m_mtu}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Fd\+Net\+Device\+::m\+\_\+mtu\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_a26eb80ddedbacaf1f5a1c19940e7225d}{}\label{classns3_1_1FdNetDevice_a26eb80ddedbacaf1f5a1c19940e7225d}
The M\+TU associated to the file descriptor technology \index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!m\+\_\+node@{m\+\_\+node}}
\index{m\+\_\+node@{m\+\_\+node}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+node}{m_node}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Node}$>$ ns3\+::\+Fd\+Net\+Device\+::m\+\_\+node\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_a344e2f5a2628c1a0305d5b4bbf72f8c6}{}\label{classns3_1_1FdNetDevice_a344e2f5a2628c1a0305d5b4bbf72f8c6}
The ns-\/3 node associated to the net device. \index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!m\+\_\+node\+Id@{m\+\_\+node\+Id}}
\index{m\+\_\+node\+Id@{m\+\_\+node\+Id}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+node\+Id}{m_nodeId}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Fd\+Net\+Device\+::m\+\_\+node\+Id\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_aed43dab9b55bd308388c3a9f1510a709}{}\label{classns3_1_1FdNetDevice_aed43dab9b55bd308388c3a9f1510a709}
a copy of the node id so the read thread doesn\textquotesingle{}t have to \hyperlink{classns3_1_1FdNetDevice_a301f937cb45179136ad4b2fe4750a56f}{Get\+Node()} in in order to find the node ID. Thread unsafe reference counting in multithreaded apps is not a good thing. \index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!m\+\_\+pending\+Queue@{m\+\_\+pending\+Queue}}
\index{m\+\_\+pending\+Queue@{m\+\_\+pending\+Queue}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+pending\+Queue}{m_pendingQueue}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::queue$<$ std\+::pair$<$uint8\+\_\+t $\ast$, ssize\+\_\+t$>$ $>$ ns3\+::\+Fd\+Net\+Device\+::m\+\_\+pending\+Queue\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_a58492550a84c8c2c959b4d4904342d70}{}\label{classns3_1_1FdNetDevice_a58492550a84c8c2c959b4d4904342d70}
Number of packets that were received and scheduled for read but not yeat read. \index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!m\+\_\+pending\+Read\+Mutex@{m\+\_\+pending\+Read\+Mutex}}
\index{m\+\_\+pending\+Read\+Mutex@{m\+\_\+pending\+Read\+Mutex}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+pending\+Read\+Mutex}{m_pendingReadMutex}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf System\+Mutex} ns3\+::\+Fd\+Net\+Device\+::m\+\_\+pending\+Read\+Mutex\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_a957f57e977ee857a0233a484c276d427}{}\label{classns3_1_1FdNetDevice_a957f57e977ee857a0233a484c276d427}
Mutex to increase pending read counter. \index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!m\+\_\+phy\+Rx\+Drop\+Trace@{m\+\_\+phy\+Rx\+Drop\+Trace}}
\index{m\+\_\+phy\+Rx\+Drop\+Trace@{m\+\_\+phy\+Rx\+Drop\+Trace}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+phy\+Rx\+Drop\+Trace}{m_phyRxDropTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Fd\+Net\+Device\+::m\+\_\+phy\+Rx\+Drop\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_ab0049e3c36f1916a8b15de5446ce192c}{}\label{classns3_1_1FdNetDevice_ab0049e3c36f1916a8b15de5446ce192c}
The trace source fired when the phy layer drops a packet it has received.

\begin{DoxySeeAlso}{See also}
class Call\+Back\+Trace\+Source 
\end{DoxySeeAlso}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!m\+\_\+phy\+Tx\+Drop\+Trace@{m\+\_\+phy\+Tx\+Drop\+Trace}}
\index{m\+\_\+phy\+Tx\+Drop\+Trace@{m\+\_\+phy\+Tx\+Drop\+Trace}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+phy\+Tx\+Drop\+Trace}{m_phyTxDropTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Fd\+Net\+Device\+::m\+\_\+phy\+Tx\+Drop\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_acd0f33f8fede665976f2485300c20810}{}\label{classns3_1_1FdNetDevice_acd0f33f8fede665976f2485300c20810}
The trace source fired when the phy layer drops a packet as it tries to transmit it.

\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000032}{Todo}]Remove\+: this \hyperlink{classns3_1_1TracedCallback}{Traced\+Callback} is never invoked.\end{DoxyRefDesc}


\begin{DoxySeeAlso}{See also}
class Call\+Back\+Trace\+Source 
\end{DoxySeeAlso}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!m\+\_\+promisc\+Rx\+Callback@{m\+\_\+promisc\+Rx\+Callback}}
\index{m\+\_\+promisc\+Rx\+Callback@{m\+\_\+promisc\+Rx\+Callback}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+promisc\+Rx\+Callback}{m_promiscRxCallback}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Net\+Device\+::\+Promisc\+Receive\+Callback} ns3\+::\+Fd\+Net\+Device\+::m\+\_\+promisc\+Rx\+Callback\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_aa95f558a530aca66f7fe582559902160}{}\label{classns3_1_1FdNetDevice_aa95f558a530aca66f7fe582559902160}
The callback used to notify higher layers that a packet has been received in promiscuous mode. \index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!m\+\_\+promisc\+Sniffer\+Trace@{m\+\_\+promisc\+Sniffer\+Trace}}
\index{m\+\_\+promisc\+Sniffer\+Trace@{m\+\_\+promisc\+Sniffer\+Trace}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+promisc\+Sniffer\+Trace}{m_promiscSnifferTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Fd\+Net\+Device\+::m\+\_\+promisc\+Sniffer\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_a7f43138ecf824b335eb80eeebdb91eb6}{}\label{classns3_1_1FdNetDevice_a7f43138ecf824b335eb80eeebdb91eb6}
A trace source that emulates a promiscuous mode protocol sniffer connected to the device. This trace source fire on packets destined for any host just like your average everyday packet sniffer.

On the transmit size, this trace hook will fire after a packet is dequeued from the device queue for transmission. In Linux, for example, this would correspond to the point just before a device hard\+\_\+start\+\_\+xmit where dev\+\_\+queue\+\_\+xmit\+\_\+nit is called to dispatch the packet to the P\+F\+\_\+\+P\+A\+C\+K\+ET E\+T\+H\+\_\+\+P\+\_\+\+A\+LL handlers.

On the receive side, this trace hook will fire when a packet is received, just before the receive callback is executed. In Linux, for example, this would correspond to the point at which the packet is dispatched to packet sniffers in netif\+\_\+receive\+\_\+skb.

\begin{DoxySeeAlso}{See also}
class Call\+Back\+Trace\+Source 
\end{DoxySeeAlso}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!m\+\_\+rx\+Callback@{m\+\_\+rx\+Callback}}
\index{m\+\_\+rx\+Callback@{m\+\_\+rx\+Callback}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+rx\+Callback}{m_rxCallback}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Net\+Device\+::\+Receive\+Callback} ns3\+::\+Fd\+Net\+Device\+::m\+\_\+rx\+Callback\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_a5c3e9d04b053c707a4188f823a6bc2ab}{}\label{classns3_1_1FdNetDevice_a5c3e9d04b053c707a4188f823a6bc2ab}
The callback used to notify higher layers that a packet has been received. \index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!m\+\_\+sniffer\+Trace@{m\+\_\+sniffer\+Trace}}
\index{m\+\_\+sniffer\+Trace@{m\+\_\+sniffer\+Trace}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+sniffer\+Trace}{m_snifferTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Fd\+Net\+Device\+::m\+\_\+sniffer\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_a821080a2cc1253e22918e8fcedcfbe58}{}\label{classns3_1_1FdNetDevice_a821080a2cc1253e22918e8fcedcfbe58}
A trace source that emulates a non-\/promiscuous protocol sniffer connected to the device. Unlike your average everyday sniffer, this trace source will not fire on P\+A\+C\+K\+E\+T\+\_\+\+O\+T\+H\+E\+R\+H\+O\+ST events.

On the transmit size, this trace hook will fire after a packet is dequeued from the device queue for transmission. In Linux, for example, this would correspond to the point just before a device hard\+\_\+start\+\_\+xmit where dev\+\_\+queue\+\_\+xmit\+\_\+nit is called to dispatch the packet to the P\+F\+\_\+\+P\+A\+C\+K\+ET E\+T\+H\+\_\+\+P\+\_\+\+A\+LL handlers.

On the receive side, this trace hook will fire when a packet is received, just before the receive callback is executed. In Linux, for example, this would correspond to the point at which the packet is dispatched to packet sniffers in netif\+\_\+receive\+\_\+skb.

\begin{DoxySeeAlso}{See also}
class Call\+Back\+Trace\+Source 
\end{DoxySeeAlso}
\index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!m\+\_\+start\+Event@{m\+\_\+start\+Event}}
\index{m\+\_\+start\+Event@{m\+\_\+start\+Event}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+start\+Event}{m_startEvent}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Event\+Id} ns3\+::\+Fd\+Net\+Device\+::m\+\_\+start\+Event\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_a759e74ace56841b2ae47c69ff0276b2f}{}\label{classns3_1_1FdNetDevice_a759e74ace56841b2ae47c69ff0276b2f}
\hyperlink{classns3_1_1NetDevice}{Net\+Device} start event \index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!m\+\_\+stop\+Event@{m\+\_\+stop\+Event}}
\index{m\+\_\+stop\+Event@{m\+\_\+stop\+Event}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+stop\+Event}{m_stopEvent}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Event\+Id} ns3\+::\+Fd\+Net\+Device\+::m\+\_\+stop\+Event\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_a010c8ac9ac2fffeb6ce1ffaf94b5a890}{}\label{classns3_1_1FdNetDevice_a010c8ac9ac2fffeb6ce1ffaf94b5a890}
\hyperlink{classns3_1_1NetDevice}{Net\+Device} stop event \index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!m\+\_\+t\+Start@{m\+\_\+t\+Start}}
\index{m\+\_\+t\+Start@{m\+\_\+t\+Start}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+t\+Start}{m_tStart}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Fd\+Net\+Device\+::m\+\_\+t\+Start\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_a6349cf5842c54a0420f9e41422895efa}{}\label{classns3_1_1FdNetDevice_a6349cf5842c54a0420f9e41422895efa}
\hyperlink{classns3_1_1Time}{Time} to start spinning up the device \index{ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}!m\+\_\+t\+Stop@{m\+\_\+t\+Stop}}
\index{m\+\_\+t\+Stop@{m\+\_\+t\+Stop}!ns3\+::\+Fd\+Net\+Device@{ns3\+::\+Fd\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+t\+Stop}{m_tStop}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Fd\+Net\+Device\+::m\+\_\+t\+Stop\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1FdNetDevice_ac97346af9ad4364aa3d1d7db0516fca5}{}\label{classns3_1_1FdNetDevice_ac97346af9ad4364aa3d1d7db0516fca5}
\hyperlink{classns3_1_1Time}{Time} to start tearing down the device 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
fd-\/net-\/device/model/\hyperlink{fd-net-device_8h}{fd-\/net-\/device.\+h}\item 
fd-\/net-\/device/model/\hyperlink{fd-net-device_8cc}{fd-\/net-\/device.\+cc}\end{DoxyCompactItemize}
