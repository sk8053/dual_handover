\hypertarget{classns3_1_1Ipv4}{}\section{ns3\+:\+:Ipv4 Class Reference}
\label{classns3_1_1Ipv4}\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}


Access to the I\+Pv4 forwarding table, interfaces, and configuration.  




{\ttfamily \#include $<$ipv4.\+h$>$}



Inheritance diagram for ns3\+:\+:Ipv4\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Ipv4\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ipv4_a1c15284fe630c76e0c9c75a97f1ff234}{Ipv4} ()
\item 
virtual \hyperlink{classns3_1_1Ipv4_ac0b234d06dde3dfb8ac77c7109b10bee}{$\sim$\+Ipv4} ()
\item 
virtual void \hyperlink{classns3_1_1Ipv4_a2d165c3bafd4ca580f02a03536db80d3}{Set\+Routing\+Protocol} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} $>$ routing\+Protocol)=0
\begin{DoxyCompactList}\small\item\em Register a new routing protocol to be used by this \hyperlink{classns3_1_1Ipv4}{Ipv4} stack. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} $>$ \hyperlink{classns3_1_1Ipv4_a62b179607cbea43b510447c422186da1}{Get\+Routing\+Protocol} (void) const =0
\begin{DoxyCompactList}\small\item\em Get the routing protocol to be used by this \hyperlink{classns3_1_1Ipv4}{Ipv4} stack. \end{DoxyCompactList}\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1Ipv4_a637354128b71bc587ea5a6eeaef42469}{Add\+Interface} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device)=0
\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1Ipv4_ae761207b8bb5414a47e9d5954ca1f1ed}{Get\+N\+Interfaces} (void) const =0
\item 
virtual int32\+\_\+t \hyperlink{classns3_1_1Ipv4_a001797776dd13d907b9cf0c3c474fa57}{Get\+Interface\+For\+Address} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} address) const =0
\begin{DoxyCompactList}\small\item\em Return the interface number of the interface that has been assigned the specified IP address. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv4_a81f6cbb774cdc255e3e49490e0960539}{Send} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} source, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} destination, uint8\+\_\+t protocol, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ route)=0
\item 
virtual void \hyperlink{classns3_1_1Ipv4_a6d6b3f031557d3fccc195df342f8598a}{Send\+With\+Header} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} ip\+Header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ route)=0
\item 
virtual void \hyperlink{classns3_1_1Ipv4_a4a3a2344ac44ff2126feb034f172671d}{Insert} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} $>$ protocol)=0
\item 
virtual void \hyperlink{classns3_1_1Ipv4_a8bfa5664c5dfd59f7e12e4cd59f28f00}{Insert} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} $>$ protocol, uint32\+\_\+t interface\+Index)=0
\begin{DoxyCompactList}\small\item\em Add a L4 protocol to a specific interface. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv4_a53bdb693f9688a3cf51ef8c9d290fdd1}{Remove} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} $>$ protocol)=0
\item 
virtual void \hyperlink{classns3_1_1Ipv4_ae9b1e38c3c9461ab1344eb1dc8444f63}{Remove} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} $>$ protocol, uint32\+\_\+t interface\+Index)=0
\begin{DoxyCompactList}\small\item\em Remove a L4 protocol from a specific interface. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1Ipv4_a82691b73bb7f96ca9932f5545b3d4d9c}{Is\+Destination\+Address} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} address, uint32\+\_\+t iif) const =0
\begin{DoxyCompactList}\small\item\em Determine whether address and interface corresponding to received packet can be accepted for local delivery. \end{DoxyCompactList}\item 
virtual int32\+\_\+t \hyperlink{classns3_1_1Ipv4_ac0ac95059f33e44ba2e848749489682b}{Get\+Interface\+For\+Prefix} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} address, \hyperlink{classns3_1_1Ipv4Mask}{Ipv4\+Mask} mask) const =0
\begin{DoxyCompactList}\small\item\em Return the interface number of first interface found that has an \hyperlink{classns3_1_1Ipv4}{Ipv4} address within the prefix specified by the input address and mask parameters. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ \hyperlink{classns3_1_1Ipv4_a3dc128ddb3012e2b27c005d88bc9f695}{Get\+Net\+Device} (uint32\+\_\+t interface)=0
\item 
virtual int32\+\_\+t \hyperlink{classns3_1_1Ipv4_ab3ff69819c27af58b02ee4791c94abf7}{Get\+Interface\+For\+Device} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device) const =0
\item 
virtual bool \hyperlink{classns3_1_1Ipv4_ad203526cae6a4b86f1bb89e44d2b62f7}{Add\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} address)=0
\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1Ipv4_a4de4613f0d5e34eeddd84e81c25768ca}{Get\+N\+Addresses} (uint32\+\_\+t interface) const =0
\item 
virtual \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} \hyperlink{classns3_1_1Ipv4_a5aa7213c1365083840b2311a3cb5b24b}{Get\+Address} (uint32\+\_\+t interface, uint32\+\_\+t address\+Index) const =0
\item 
virtual bool \hyperlink{classns3_1_1Ipv4_acc40c575c9eda827a041c5f99fe63401}{Remove\+Address} (uint32\+\_\+t interface, uint32\+\_\+t address\+Index)=0
\item 
virtual bool \hyperlink{classns3_1_1Ipv4_a5570da6ab4231f74efcb8c101c2346a0}{Remove\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} address)=0
\begin{DoxyCompactList}\small\item\em Remove the given address on named \hyperlink{classns3_1_1Ipv4}{Ipv4} interface. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \hyperlink{classns3_1_1Ipv4_a78f954ad686942a98d456a3dd5d418e5}{Select\+Source\+Address} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} dst, \hyperlink{classns3_1_1Ipv4InterfaceAddress_a329cea433e74f717c26c9e51c4fcd3d8}{Ipv4\+Interface\+Address\+::\+Interface\+Address\+Scope\+\_\+e} scope)=0
\begin{DoxyCompactList}\small\item\em Return the first primary source address with scope less than or equal to the requested scope, to use in sending a packet to destination dst out of the specified device. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv4_a2b5632573b67957fabe2dfea248a57a3}{Set\+Metric} (uint32\+\_\+t interface, uint16\+\_\+t metric)=0
\item 
virtual uint16\+\_\+t \hyperlink{classns3_1_1Ipv4_ace48f3304b9da2e15cda01fc8c11efd9}{Get\+Metric} (uint32\+\_\+t interface) const =0
\item 
virtual uint16\+\_\+t \hyperlink{classns3_1_1Ipv4_a58545a760ba30f653d2be2adaed0651c}{Get\+Mtu} (uint32\+\_\+t interface) const =0
\item 
virtual bool \hyperlink{classns3_1_1Ipv4_af5cc0afb0373b1c3c2014c974aa269ba}{Is\+Up} (uint32\+\_\+t interface) const =0
\item 
virtual void \hyperlink{classns3_1_1Ipv4_a71b2f8acca4923aef907b50b3196bf23}{Set\+Up} (uint32\+\_\+t interface)=0
\item 
virtual void \hyperlink{classns3_1_1Ipv4_ac148839884b1ce11f9237ddc523f5cd2}{Set\+Down} (uint32\+\_\+t interface)=0
\item 
virtual bool \hyperlink{classns3_1_1Ipv4_a241bb02749cefd690671a4cbc52a8dae}{Is\+Forwarding} (uint32\+\_\+t interface) const =0
\item 
virtual void \hyperlink{classns3_1_1Ipv4_aee95b3b96994698f5629f8b9e617b587}{Set\+Forwarding} (uint32\+\_\+t interface, bool val)=0
\item 
virtual \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \hyperlink{classns3_1_1Ipv4_ac7a49d14371de95cd1cc8f6563266edd}{Source\+Address\+Selection} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} dest)=0
\begin{DoxyCompactList}\small\item\em Choose the source address to use with destination address. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} $>$ \hyperlink{classns3_1_1Ipv4_acc65667e029c46ec184685674933d956}{Get\+Protocol} (int protocol\+Number) const =0
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} $>$ \hyperlink{classns3_1_1Ipv4_a15733f7419f27fb3bee959b1ee256d30}{Get\+Protocol} (int protocol\+Number, int32\+\_\+t interface\+Index) const =0
\begin{DoxyCompactList}\small\item\em Get L4 protocol by protocol number for the specified interface. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$ \hyperlink{classns3_1_1Ipv4_a1356d5645420ef3270bf27e839605f76}{Create\+Raw\+Socket} (void)=0
\begin{DoxyCompactList}\small\item\em Creates a raw socket. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv4_a1fb3d05138c4767db2c8c1c524ca3db3}{Delete\+Raw\+Socket} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$ socket)=0
\begin{DoxyCompactList}\small\item\em Deletes a particular raw socket. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1Ipv4_a339a61fc36efb3366dd2065e5f5f4aa8}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const uint32\+\_\+t \hyperlink{classns3_1_1Ipv4_a9b05b2610976f8d53da45d95891a0657}{I\+F\+\_\+\+A\+NY} = 0xffffffff
\begin{DoxyCompactList}\small\item\em interface wildcard, meaning any interface \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1Ipv4_a12decc8332283f56ba59b0aacb3498ca}{Set\+Ip\+Forward} (bool forward)=0
\begin{DoxyCompactList}\small\item\em Set or unset the IP forwarding state. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1Ipv4_ac6803a68ed412d4aae3108afc2afd890}{Get\+Ip\+Forward} (void) const =0
\begin{DoxyCompactList}\small\item\em Get the IP forwarding state. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv4_a3bdaf12fbfaca276c1a60a3a7cd9b68c}{Set\+Weak\+Es\+Model} (bool model)=0
\begin{DoxyCompactList}\small\item\em Set or unset the Weak Es Model. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1Ipv4_a3d9882e80ef4e0e2375d89037f3ab5e1}{Get\+Weak\+Es\+Model} (void) const =0
\begin{DoxyCompactList}\small\item\em Get the Weak Es Model status. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Access to the I\+Pv4 forwarding table, interfaces, and configuration. 

This class defines the A\+PI to manipulate the following aspects of the I\+Pv4 implementation\+:
\begin{DoxyEnumerate}
\item set/get an \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol}
\item register a \hyperlink{classns3_1_1NetDevice}{Net\+Device} for use by the \hyperlink{classns3_1_1Ipv4}{Ipv4} layer (basically, to create Ipv4-\/related state such as addressing and neighbor cache that is associated with a \hyperlink{classns3_1_1NetDevice}{Net\+Device})
\item manipulate the status of the \hyperlink{classns3_1_1NetDevice}{Net\+Device} from the \hyperlink{classns3_1_1Ipv4}{Ipv4} perspective, such as marking it as Up or Down,
\item adding, deleting, and getting addresses associated to the \hyperlink{classns3_1_1Ipv4}{Ipv4} interfaces.
\item exporting \hyperlink{classns3_1_1Ipv4}{Ipv4} configuration attributes
\end{DoxyEnumerate}

Each \hyperlink{classns3_1_1NetDevice}{Net\+Device} has conceptually a single \hyperlink{classns3_1_1Ipv4}{Ipv4} interface associated with it (the corresponding structure in the Linux \hyperlink{classns3_1_1Ipv4}{Ipv4} implementation is struct in\+\_\+device). Each interface may have one or more \hyperlink{classns3_1_1Ipv4}{Ipv4} addresses associated with it. Each \hyperlink{classns3_1_1Ipv4}{Ipv4} address may have different subnet mask, scope, etc., so all of this per-\/address information is stored in an \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} class (the corresponding structure in Linux is struct in\+\_\+ifaddr)

\hyperlink{classns3_1_1Ipv4}{Ipv4} attributes such as whether IP forwarding is enabled and disabled are also stored in this class

TO DO\+: Add A\+PI to allow access to the \hyperlink{classns3_1_1Ipv4}{Ipv4} neighbor table

\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} 

\hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} 
\end{DoxySeeAlso}


\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Ipv4@{Ipv4}}
\index{Ipv4@{Ipv4}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Ipv4()}{Ipv4()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv4\+::\+Ipv4 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4_a1c15284fe630c76e0c9c75a97f1ff234}{}\label{classns3_1_1Ipv4_a1c15284fe630c76e0c9c75a97f1ff234}

\begin{DoxyCode}
62 \{
63   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
64 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!````~Ipv4@{$\sim$\+Ipv4}}
\index{````~Ipv4@{$\sim$\+Ipv4}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{$\sim$\+Ipv4()}{~Ipv4()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv4\+::$\sim$\+Ipv4 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4_ac0b234d06dde3dfb8ac77c7109b10bee}{}\label{classns3_1_1Ipv4_ac0b234d06dde3dfb8ac77c7109b10bee}

\begin{DoxyCode}
67 \{
68   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
69 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Add\+Address@{Add\+Address}}
\index{Add\+Address@{Add\+Address}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Add\+Address(uint32\+\_\+t interface, Ipv4\+Interface\+Address address)=0}{AddAddress(uint32_t interface, Ipv4InterfaceAddress address)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool ns3\+::\+Ipv4\+::\+Add\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv4\+Interface\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_ad203526cae6a4b86f1bb89e44d2b62f7}{}\label{classns3_1_1Ipv4_ad203526cae6a4b86f1bb89e44d2b62f7}

\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of an \hyperlink{classns3_1_1Ipv4}{Ipv4} interface \\
\hline
{\em address} & \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} address to associate with the underlying \hyperlink{classns3_1_1Ipv4}{Ipv4} interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the operation succeeded 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_a6392fb16c03883eb3e21c9ac4216967d}{ns3\+::\+Ipv4\+L3\+Protocol}.



Here is the caller graph for this function\+:
% FIG 2


\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Add\+Interface@{Add\+Interface}}
\index{Add\+Interface@{Add\+Interface}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Add\+Interface(\+Ptr$<$ Net\+Device $>$ device)=0}{AddInterface(Ptr< NetDevice > device)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual uint32\+\_\+t ns3\+::\+Ipv4\+::\+Add\+Interface (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{device}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_a637354128b71bc587ea5a6eeaef42469}{}\label{classns3_1_1Ipv4_a637354128b71bc587ea5a6eeaef42469}

\begin{DoxyParams}{Parameters}
{\em device} & device to add to the list of \hyperlink{classns3_1_1Ipv4}{Ipv4} interfaces which can be used as output interfaces during packet forwarding. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the index of the \hyperlink{classns3_1_1Ipv4}{Ipv4} interface added.
\end{DoxyReturn}
Once a device has been added, it can never be removed\+: if you want to disable it, you can invoke \hyperlink{classns3_1_1Ipv4_ac148839884b1ce11f9237ddc523f5cd2}{Ipv4\+::\+Set\+Down} which will make sure that it is never used during packet forwarding. 

Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_ac6855eb39254f74fa30e7f23a7b100db}{ns3\+::\+Ipv4\+L3\+Protocol}.



Here is the caller graph for this function\+:
% FIG 3


\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Create\+Raw\+Socket@{Create\+Raw\+Socket}}
\index{Create\+Raw\+Socket@{Create\+Raw\+Socket}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Create\+Raw\+Socket(void)=0}{CreateRawSocket(void)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Ptr}$<${\bf Socket}$>$ ns3\+::\+Ipv4\+::\+Create\+Raw\+Socket (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_a1356d5645420ef3270bf27e839605f76}{}\label{classns3_1_1Ipv4_a1356d5645420ef3270bf27e839605f76}


Creates a raw socket. 

\begin{DoxyReturn}{Returns}
a smart pointer to the instantiated raw socket 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_abc060605c64f9dc7c56f5d8124fbaec2}{ns3\+::\+Ipv4\+L3\+Protocol}.

\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Delete\+Raw\+Socket@{Delete\+Raw\+Socket}}
\index{Delete\+Raw\+Socket@{Delete\+Raw\+Socket}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Delete\+Raw\+Socket(\+Ptr$<$ Socket $>$ socket)=0}{DeleteRawSocket(Ptr< Socket > socket)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv4\+::\+Delete\+Raw\+Socket (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Socket} $>$}]{socket}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_a1fb3d05138c4767db2c8c1c524ca3db3}{}\label{classns3_1_1Ipv4_a1fb3d05138c4767db2c8c1c524ca3db3}


Deletes a particular raw socket. 


\begin{DoxyParams}{Parameters}
{\em socket} & Smart pointer to the raw socket to be deleted \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_a170d2d386421ff92c45c2e7dd3f79a5e}{ns3\+::\+Ipv4\+L3\+Protocol}.

\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Get\+Address@{Get\+Address}}
\index{Get\+Address@{Get\+Address}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Get\+Address(uint32\+\_\+t interface, uint32\+\_\+t address\+Index) const =0}{GetAddress(uint32_t interface, uint32_t addressIndex) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Ipv4\+Interface\+Address} ns3\+::\+Ipv4\+::\+Get\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{uint32\+\_\+t}]{address\+Index}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_a5aa7213c1365083840b2311a3cb5b24b}{}\label{classns3_1_1Ipv4_a5aa7213c1365083840b2311a3cb5b24b}
Because addresses can be removed, the address\+Index is not guaranteed to be static across calls to this method.


\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of an \hyperlink{classns3_1_1Ipv4}{Ipv4} interface \\
\hline
{\em address\+Index} & index of \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} associated to the interface and address\+Index 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_a85fa4287313a773dee29aa73fa74a7e0}{ns3\+::\+Ipv4\+L3\+Protocol}.



Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Get\+Interface\+For\+Address@{Get\+Interface\+For\+Address}}
\index{Get\+Interface\+For\+Address@{Get\+Interface\+For\+Address}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Get\+Interface\+For\+Address(\+Ipv4\+Address address) const =0}{GetInterfaceForAddress(Ipv4Address address) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual int32\+\_\+t ns3\+::\+Ipv4\+::\+Get\+Interface\+For\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{address}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_a001797776dd13d907b9cf0c3c474fa57}{}\label{classns3_1_1Ipv4_a001797776dd13d907b9cf0c3c474fa57}


Return the interface number of the interface that has been assigned the specified IP address. 


\begin{DoxyParams}{Parameters}
{\em address} & The IP address being searched for \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The interface number of the \hyperlink{classns3_1_1Ipv4}{Ipv4} interface with the given address or -\/1 if not found.
\end{DoxyReturn}
Each IP interface has one or more IP addresses associated with it. This method searches the list of interfaces for one that holds a particular address. This call takes an IP address as a parameter and returns the interface number of the first interface that has been assigned that address, or -\/1 if not found. There must be an exact match; this method will not match broadcast or multicast addresses. 

Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_a8aac475db90ce304c53b23c2d470f6eb}{ns3\+::\+Ipv4\+L3\+Protocol}.

\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Get\+Interface\+For\+Device@{Get\+Interface\+For\+Device}}
\index{Get\+Interface\+For\+Device@{Get\+Interface\+For\+Device}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Get\+Interface\+For\+Device(\+Ptr$<$ const Net\+Device $>$ device) const =0}{GetInterfaceForDevice(Ptr< const NetDevice > device) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual int32\+\_\+t ns3\+::\+Ipv4\+::\+Get\+Interface\+For\+Device (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Net\+Device} $>$}]{device}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_ab3ff69819c27af58b02ee4791c94abf7}{}\label{classns3_1_1Ipv4_ab3ff69819c27af58b02ee4791c94abf7}

\begin{DoxyParams}{Parameters}
{\em device} & The \hyperlink{classns3_1_1NetDevice}{Net\+Device} for an \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The interface number of an \hyperlink{classns3_1_1Ipv4}{Ipv4} interface or -\/1 if not found. 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_a4640baab6b3879020a4146f17e293321}{ns3\+::\+Ipv4\+L3\+Protocol}.



Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Get\+Interface\+For\+Prefix@{Get\+Interface\+For\+Prefix}}
\index{Get\+Interface\+For\+Prefix@{Get\+Interface\+For\+Prefix}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Get\+Interface\+For\+Prefix(\+Ipv4\+Address address, Ipv4\+Mask mask) const =0}{GetInterfaceForPrefix(Ipv4Address address, Ipv4Mask mask) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual int32\+\_\+t ns3\+::\+Ipv4\+::\+Get\+Interface\+For\+Prefix (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{address, }
\item[{{\bf Ipv4\+Mask}}]{mask}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_ac0ac95059f33e44ba2e848749489682b}{}\label{classns3_1_1Ipv4_ac0ac95059f33e44ba2e848749489682b}


Return the interface number of first interface found that has an \hyperlink{classns3_1_1Ipv4}{Ipv4} address within the prefix specified by the input address and mask parameters. 


\begin{DoxyParams}{Parameters}
{\em address} & The IP address assigned to the interface of interest. \\
\hline
{\em mask} & The IP prefix to use in the mask \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The interface number of the \hyperlink{classns3_1_1Ipv4}{Ipv4} interface with the given address or -\/1 if not found.
\end{DoxyReturn}
Each IP interface has one or more IP addresses associated with it. This method searches the list of interfaces for the first one found that holds an address that is included within the prefix formed by the input address and mask parameters. The value -\/1 is returned if no match is found. 

Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_aedf0ed801978ecf18b1e8ae0d0039a42}{ns3\+::\+Ipv4\+L3\+Protocol}.

\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Get\+Ip\+Forward@{Get\+Ip\+Forward}}
\index{Get\+Ip\+Forward@{Get\+Ip\+Forward}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Get\+Ip\+Forward(void) const =0}{GetIpForward(void) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool ns3\+::\+Ipv4\+::\+Get\+Ip\+Forward (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_ac6803a68ed412d4aae3108afc2afd890}{}\label{classns3_1_1Ipv4_ac6803a68ed412d4aae3108afc2afd890}


Get the IP forwarding state. 

\begin{DoxyReturn}{Returns}
true if IP is in forwarding state 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_acbc9196c4f23691e6dde9890f24c5285}{ns3\+::\+Ipv4\+L3\+Protocol}.



Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Get\+Metric@{Get\+Metric}}
\index{Get\+Metric@{Get\+Metric}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Get\+Metric(uint32\+\_\+t interface) const =0}{GetMetric(uint32_t interface) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual uint16\+\_\+t ns3\+::\+Ipv4\+::\+Get\+Metric (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_ace48f3304b9da2e15cda01fc8c11efd9}{}\label{classns3_1_1Ipv4_ace48f3304b9da2e15cda01fc8c11efd9}

\begin{DoxyParams}{Parameters}
{\em interface} & The interface number of an \hyperlink{classns3_1_1Ipv4}{Ipv4} interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
routing metric (cost) associated to the underlying \hyperlink{classns3_1_1Ipv4}{Ipv4} interface 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_af8445efaa4cb715717f0152d37b4ed34}{ns3\+::\+Ipv4\+L3\+Protocol}.

\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Get\+Mtu@{Get\+Mtu}}
\index{Get\+Mtu@{Get\+Mtu}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Get\+Mtu(uint32\+\_\+t interface) const =0}{GetMtu(uint32_t interface) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual uint16\+\_\+t ns3\+::\+Ipv4\+::\+Get\+Mtu (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_a58545a760ba30f653d2be2adaed0651c}{}\label{classns3_1_1Ipv4_a58545a760ba30f653d2be2adaed0651c}

\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of \hyperlink{classns3_1_1Ipv4}{Ipv4} interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the Maximum Transmission Unit (in bytes) associated to the underlying \hyperlink{classns3_1_1Ipv4}{Ipv4} interface 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_ad5ec856c17f917cc47a10552ccdd9767}{ns3\+::\+Ipv4\+L3\+Protocol}.

\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Get\+N\+Addresses@{Get\+N\+Addresses}}
\index{Get\+N\+Addresses@{Get\+N\+Addresses}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Get\+N\+Addresses(uint32\+\_\+t interface) const =0}{GetNAddresses(uint32_t interface) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual uint32\+\_\+t ns3\+::\+Ipv4\+::\+Get\+N\+Addresses (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_a4de4613f0d5e34eeddd84e81c25768ca}{}\label{classns3_1_1Ipv4_a4de4613f0d5e34eeddd84e81c25768ca}

\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of an \hyperlink{classns3_1_1Ipv4}{Ipv4} interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} entries for the interface. 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_ab816ec1b5f680117bc1363b3d9649b22}{ns3\+::\+Ipv4\+L3\+Protocol}.

\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Get\+Net\+Device@{Get\+Net\+Device}}
\index{Get\+Net\+Device@{Get\+Net\+Device}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Get\+Net\+Device(uint32\+\_\+t interface)=0}{GetNetDevice(uint32_t interface)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Ptr}$<${\bf Net\+Device}$>$ ns3\+::\+Ipv4\+::\+Get\+Net\+Device (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_a3dc128ddb3012e2b27c005d88bc9f695}{}\label{classns3_1_1Ipv4_a3dc128ddb3012e2b27c005d88bc9f695}

\begin{DoxyParams}{Parameters}
{\em interface} & The interface number of an \hyperlink{classns3_1_1Ipv4}{Ipv4} interface. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The \hyperlink{classns3_1_1NetDevice}{Net\+Device} associated with the \hyperlink{classns3_1_1Ipv4}{Ipv4} interface number. 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_a783709154b6f41b3a800b3e67369d501}{ns3\+::\+Ipv4\+L3\+Protocol}.

\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Get\+N\+Interfaces@{Get\+N\+Interfaces}}
\index{Get\+N\+Interfaces@{Get\+N\+Interfaces}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Get\+N\+Interfaces(void) const =0}{GetNInterfaces(void) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual uint32\+\_\+t ns3\+::\+Ipv4\+::\+Get\+N\+Interfaces (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_ae761207b8bb5414a47e9d5954ca1f1ed}{}\label{classns3_1_1Ipv4_ae761207b8bb5414a47e9d5954ca1f1ed}
\begin{DoxyReturn}{Returns}
the number of interfaces added by the user. 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_a6ab2be11c0df97f2d1170bbc737c9628}{ns3\+::\+Ipv4\+L3\+Protocol}.



Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Get\+Protocol@{Get\+Protocol}}
\index{Get\+Protocol@{Get\+Protocol}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Get\+Protocol(int protocol\+Number) const =0}{GetProtocol(int protocolNumber) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Ptr}$<${\bf Ip\+L4\+Protocol}$>$ ns3\+::\+Ipv4\+::\+Get\+Protocol (
\begin{DoxyParamCaption}
\item[{int}]{protocol\+Number}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_acc65667e029c46ec184685674933d956}{}\label{classns3_1_1Ipv4_acc65667e029c46ec184685674933d956}

\begin{DoxyParams}{Parameters}
{\em protocol\+Number} & number of protocol to lookup in this L4 Demux \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a matching L4 Protocol
\end{DoxyReturn}
This method is typically called by lower layers to forward packets up the stack to the right protocol. 

Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_acbe71267a0b2bca4569cf574148d3361}{ns3\+::\+Ipv4\+L3\+Protocol}.

\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Get\+Protocol@{Get\+Protocol}}
\index{Get\+Protocol@{Get\+Protocol}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Get\+Protocol(int protocol\+Number, int32\+\_\+t interface\+Index) const =0}{GetProtocol(int protocolNumber, int32_t interfaceIndex) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Ptr}$<${\bf Ip\+L4\+Protocol}$>$ ns3\+::\+Ipv4\+::\+Get\+Protocol (
\begin{DoxyParamCaption}
\item[{int}]{protocol\+Number, }
\item[{int32\+\_\+t}]{interface\+Index}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_a15733f7419f27fb3bee959b1ee256d30}{}\label{classns3_1_1Ipv4_a15733f7419f27fb3bee959b1ee256d30}


Get L4 protocol by protocol number for the specified interface. 


\begin{DoxyParams}{Parameters}
{\em protocol\+Number} & protocol number \\
\hline
{\em interface\+Index} & interface index, -\/1 means \char`\"{}any\char`\"{} interface. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
corresponding \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} or 0 if not found 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_a4c12ae9366588d171aac8cebb74931dc}{ns3\+::\+Ipv4\+L3\+Protocol}.

\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Get\+Routing\+Protocol@{Get\+Routing\+Protocol}}
\index{Get\+Routing\+Protocol@{Get\+Routing\+Protocol}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Get\+Routing\+Protocol(void) const =0}{GetRoutingProtocol(void) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Ptr}$<${\bf Ipv4\+Routing\+Protocol}$>$ ns3\+::\+Ipv4\+::\+Get\+Routing\+Protocol (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_a62b179607cbea43b510447c422186da1}{}\label{classns3_1_1Ipv4_a62b179607cbea43b510447c422186da1}


Get the routing protocol to be used by this \hyperlink{classns3_1_1Ipv4}{Ipv4} stack. 

\begin{DoxyReturn}{Returns}
smart pointer to \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} object, or null pointer if none 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_aa1e4efbf4978299e47406895c3f4b41d}{ns3\+::\+Ipv4\+L3\+Protocol}.



Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Ipv4\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv4_a339a61fc36efb3366dd2065e5f5f4aa8}{}\label{classns3_1_1Ipv4_a339a61fc36efb3366dd2065e5f5f4aa8}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
35 \{
36   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::Ipv4"})
37     .SetParent<\hyperlink{classns3_1_1Object_a40860402e64d8008fb42329df7097cdb}{Object}> ()
38     .SetGroupName (\textcolor{stringliteral}{"Internet"})
39     .AddAttribute (\textcolor{stringliteral}{"IpForward"}, \textcolor{stringliteral}{"Globally enable or disable IP forwarding for all current and future Ipv4
       devices."},
40                    BooleanValue (\textcolor{keyword}{true}),
41                    MakeBooleanAccessor (&\hyperlink{classns3_1_1Ipv4_a12decc8332283f56ba59b0aacb3498ca}{Ipv4::SetIpForward},
42                                         &\hyperlink{classns3_1_1Ipv4_ac6803a68ed412d4aae3108afc2afd890}{Ipv4::GetIpForward}),
43                    MakeBooleanChecker ())
44     .AddAttribute (\textcolor{stringliteral}{"WeakEsModel"}, 
45                    \textcolor{stringliteral}{"RFC1122 term for whether host accepts datagram with a dest. address on another
       interface"},
46                    BooleanValue (\textcolor{keyword}{true}),
47                    MakeBooleanAccessor (&\hyperlink{classns3_1_1Ipv4_a3bdaf12fbfaca276c1a60a3a7cd9b68c}{Ipv4::SetWeakEsModel},
48                                         &\hyperlink{classns3_1_1Ipv4_a3d9882e80ef4e0e2375d89037f3ab5e1}{Ipv4::GetWeakEsModel}),
49                    MakeBooleanChecker ())
50 \textcolor{preprocessor}{#if 0}
51     .AddAttribute (\textcolor{stringliteral}{"MtuDiscover"}, \textcolor{stringliteral}{"If enabled, every outgoing ip packet will have the DF flag set."},
52                    BooleanValue (\textcolor{keyword}{false}),
53                    MakeBooleanAccessor (&\hyperlink{classns3_1_1UdpSocket_ae3f06fb2459a7c09f91068905a063a6a}{UdpSocket::SetMtuDiscover},
54                                         &\hyperlink{classns3_1_1UdpSocket_abd9c668464d5f89f17780fcd932777c2}{UdpSocket::GetMtuDiscover}),
55                    MakeBooleanChecker ())
56 \textcolor{preprocessor}{#endif}
57   ;
58   \textcolor{keywordflow}{return} tid;
59 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9


\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Get\+Weak\+Es\+Model@{Get\+Weak\+Es\+Model}}
\index{Get\+Weak\+Es\+Model@{Get\+Weak\+Es\+Model}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Get\+Weak\+Es\+Model(void) const =0}{GetWeakEsModel(void) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool ns3\+::\+Ipv4\+::\+Get\+Weak\+Es\+Model (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_a3d9882e80ef4e0e2375d89037f3ab5e1}{}\label{classns3_1_1Ipv4_a3d9882e80ef4e0e2375d89037f3ab5e1}


Get the Weak Es Model status. 

R\+F\+C1122 term for whether host accepts datagram with a dest. address on another interface \begin{DoxyReturn}{Returns}
true for Weak Es Model activated 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_ad6249ba16ffc906ac0041ce89bdc2cac}{ns3\+::\+Ipv4\+L3\+Protocol}.



Here is the caller graph for this function\+:
% FIG 10


\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Insert@{Insert}}
\index{Insert@{Insert}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Insert(\+Ptr$<$ Ip\+L4\+Protocol $>$ protocol)=0}{Insert(Ptr< IpL4Protocol > protocol)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv4\+::\+Insert (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ip\+L4\+Protocol} $>$}]{protocol}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_a4a3a2344ac44ff2126feb034f172671d}{}\label{classns3_1_1Ipv4_a4a3a2344ac44ff2126feb034f172671d}

\begin{DoxyParams}{Parameters}
{\em protocol} & a template for the protocol to add to this L4 Demux. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the L4\+Protocol effectively added.
\end{DoxyReturn}
Invoke Copy on the input template to get a copy of the input protocol which can be used on the \hyperlink{classns3_1_1Node}{Node} on which this L4 Demux is running. The new L4\+Protocol is registered internally as a working L4 Protocol and returned from this method. The caller does not get ownership of the returned pointer. 

Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_adcca82f024e576d06b4687ec3519ed8b}{ns3\+::\+Ipv4\+L3\+Protocol}.

\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Insert@{Insert}}
\index{Insert@{Insert}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Insert(\+Ptr$<$ Ip\+L4\+Protocol $>$ protocol, uint32\+\_\+t interface\+Index)=0}{Insert(Ptr< IpL4Protocol > protocol, uint32_t interfaceIndex)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv4\+::\+Insert (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ip\+L4\+Protocol} $>$}]{protocol, }
\item[{uint32\+\_\+t}]{interface\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_a8bfa5664c5dfd59f7e12e4cd59f28f00}{}\label{classns3_1_1Ipv4_a8bfa5664c5dfd59f7e12e4cd59f28f00}


Add a L4 protocol to a specific interface. 

This may be called multiple times for multiple interfaces for the same protocol. To insert for all interfaces, use the separate Insert (Ptr$<$\+Ip\+L4\+Protocol$>$ protocol) method.

Setting a protocol on a specific interface will overwrite the previously bound protocol.


\begin{DoxyParams}{Parameters}
{\em protocol} & L4 protocol. \\
\hline
{\em interface\+Index} & interface index. \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_a2c8c7ce0f9c6e8ca5825d9abc5554f1c}{ns3\+::\+Ipv4\+L3\+Protocol}.

\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Is\+Destination\+Address@{Is\+Destination\+Address}}
\index{Is\+Destination\+Address@{Is\+Destination\+Address}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Is\+Destination\+Address(\+Ipv4\+Address address, uint32\+\_\+t iif) const =0}{IsDestinationAddress(Ipv4Address address, uint32_t iif) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool ns3\+::\+Ipv4\+::\+Is\+Destination\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{address, }
\item[{uint32\+\_\+t}]{iif}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_a82691b73bb7f96ca9932f5545b3d4d9c}{}\label{classns3_1_1Ipv4_a82691b73bb7f96ca9932f5545b3d4d9c}


Determine whether address and interface corresponding to received packet can be accepted for local delivery. 


\begin{DoxyParams}{Parameters}
{\em address} & The IP address being considered \\
\hline
{\em iif} & The incoming \hyperlink{classns3_1_1Ipv4}{Ipv4} interface index \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the address is associated with the interface index
\end{DoxyReturn}
This method can be used to determine whether a received packet has an acceptable address for local delivery on the host. The address may be a unicast, multicast, or broadcast address. This method will return true if address is an exact match of a unicast address on one of the host\textquotesingle{}s interfaces (see below), if address corresponds to a multicast group that the host has joined (and the incoming device is acceptable), or if address corresponds to a broadcast address.

If the \hyperlink{classns3_1_1Ipv4}{Ipv4} attribute Weak\+Es\+Model is true, the unicast address may match any of the \hyperlink{classns3_1_1Ipv4}{Ipv4} addresses on any interface. If the attribute is false, the address must match one assigned to the incoming device. 

Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_a2d76dcdc0c915346d9177afda3b4e388}{ns3\+::\+Ipv4\+L3\+Protocol}.

\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Is\+Forwarding@{Is\+Forwarding}}
\index{Is\+Forwarding@{Is\+Forwarding}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Is\+Forwarding(uint32\+\_\+t interface) const =0}{IsForwarding(uint32_t interface) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool ns3\+::\+Ipv4\+::\+Is\+Forwarding (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_a241bb02749cefd690671a4cbc52a8dae}{}\label{classns3_1_1Ipv4_a241bb02749cefd690671a4cbc52a8dae}

\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of \hyperlink{classns3_1_1Ipv4}{Ipv4} interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if IP forwarding enabled for input datagrams on this device 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_a7edb82af155c25e7325d1c91df7d83de}{ns3\+::\+Ipv4\+L3\+Protocol}.

\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Is\+Up@{Is\+Up}}
\index{Is\+Up@{Is\+Up}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Is\+Up(uint32\+\_\+t interface) const =0}{IsUp(uint32_t interface) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool ns3\+::\+Ipv4\+::\+Is\+Up (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_af5cc0afb0373b1c3c2014c974aa269ba}{}\label{classns3_1_1Ipv4_af5cc0afb0373b1c3c2014c974aa269ba}

\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of \hyperlink{classns3_1_1Ipv4}{Ipv4} interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the underlying interface is in the \char`\"{}up\char`\"{} state, false otherwise. 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_a8f30b837b325a3e332e25d0da91cfbf4}{ns3\+::\+Ipv4\+L3\+Protocol}.

\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Remove@{Remove}}
\index{Remove@{Remove}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Remove(\+Ptr$<$ Ip\+L4\+Protocol $>$ protocol)=0}{Remove(Ptr< IpL4Protocol > protocol)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv4\+::\+Remove (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ip\+L4\+Protocol} $>$}]{protocol}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_a53bdb693f9688a3cf51ef8c9d290fdd1}{}\label{classns3_1_1Ipv4_a53bdb693f9688a3cf51ef8c9d290fdd1}

\begin{DoxyParams}{Parameters}
{\em protocol} & protocol to remove from this demux.\\
\hline
\end{DoxyParams}
The input value to this method should be the value returned from the Ipv4\+L4\+Protocol\+::\+Insert method. 

Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_a718acab47b00b50f77c9acb05efbf220}{ns3\+::\+Ipv4\+L3\+Protocol}.

\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Remove@{Remove}}
\index{Remove@{Remove}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Remove(\+Ptr$<$ Ip\+L4\+Protocol $>$ protocol, uint32\+\_\+t interface\+Index)=0}{Remove(Ptr< IpL4Protocol > protocol, uint32_t interfaceIndex)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv4\+::\+Remove (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ip\+L4\+Protocol} $>$}]{protocol, }
\item[{uint32\+\_\+t}]{interface\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_ae9b1e38c3c9461ab1344eb1dc8444f63}{}\label{classns3_1_1Ipv4_ae9b1e38c3c9461ab1344eb1dc8444f63}


Remove a L4 protocol from a specific interface. 


\begin{DoxyParams}{Parameters}
{\em protocol} & L4 protocol to remove. \\
\hline
{\em interface\+Index} & interface index. \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_abb4d0e17bda74dd318b3ff2cb3db58ee}{ns3\+::\+Ipv4\+L3\+Protocol}.

\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Remove\+Address@{Remove\+Address}}
\index{Remove\+Address@{Remove\+Address}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Remove\+Address(uint32\+\_\+t interface, uint32\+\_\+t address\+Index)=0}{RemoveAddress(uint32_t interface, uint32_t addressIndex)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool ns3\+::\+Ipv4\+::\+Remove\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{uint32\+\_\+t}]{address\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_acc40c575c9eda827a041c5f99fe63401}{}\label{classns3_1_1Ipv4_acc40c575c9eda827a041c5f99fe63401}
Remove the address at address\+Index on named interface. The address\+Index for all higher indices will decrement by one after this method is called; so, for example, to remove 5 addresses from an interface i, one could call Remove\+Address (i, 0); 5 times.


\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of an \hyperlink{classns3_1_1Ipv4}{Ipv4} interface \\
\hline
{\em address\+Index} & index of \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} to remove \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the operation succeeded 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_a143bb06864cd386728afe563b9f554dc}{ns3\+::\+Ipv4\+L3\+Protocol}.

\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Remove\+Address@{Remove\+Address}}
\index{Remove\+Address@{Remove\+Address}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Remove\+Address(uint32\+\_\+t interface, Ipv4\+Address address)=0}{RemoveAddress(uint32_t interface, Ipv4Address address)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool ns3\+::\+Ipv4\+::\+Remove\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv4\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_a5570da6ab4231f74efcb8c101c2346a0}{}\label{classns3_1_1Ipv4_a5570da6ab4231f74efcb8c101c2346a0}


Remove the given address on named \hyperlink{classns3_1_1Ipv4}{Ipv4} interface. 


\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of an \hyperlink{classns3_1_1Ipv4}{Ipv4} interface \\
\hline
{\em address} & The address to remove \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the operation succeeded 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_a30338b1132156b86a8bbf5e6d17c6266}{ns3\+::\+Ipv4\+L3\+Protocol}.

\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Select\+Source\+Address@{Select\+Source\+Address}}
\index{Select\+Source\+Address@{Select\+Source\+Address}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Select\+Source\+Address(\+Ptr$<$ const Net\+Device $>$ device, Ipv4\+Address dst, Ipv4\+Interface\+Address\+::\+Interface\+Address\+Scope\+\_\+e scope)=0}{SelectSourceAddress(Ptr< const NetDevice > device, Ipv4Address dst, Ipv4InterfaceAddress::InterfaceAddressScope_e scope)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Ipv4\+Address} ns3\+::\+Ipv4\+::\+Select\+Source\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Net\+Device} $>$}]{device, }
\item[{{\bf Ipv4\+Address}}]{dst, }
\item[{{\bf Ipv4\+Interface\+Address\+::\+Interface\+Address\+Scope\+\_\+e}}]{scope}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_a78f954ad686942a98d456a3dd5d418e5}{}\label{classns3_1_1Ipv4_a78f954ad686942a98d456a3dd5d418e5}


Return the first primary source address with scope less than or equal to the requested scope, to use in sending a packet to destination dst out of the specified device. 

This method mirrors the behavior of Linux inet\+\_\+select\+\_\+addr() and is provided because interfaces may have multiple IP addresses configured on them with different scopes, and with a primary and secondary status. Secondary addresses are never returned. \begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address}
\end{DoxySeeAlso}
If a non-\/zero device pointer is provided, the method first tries to return a primary address that is configured on that device, and whose subnet matches that of dst and whose scope is less than or equal to the requested scope. If a primary address does not match the subnet of dst but otherwise matches the scope, it is returned. If no such address on the device is found, the other devices are searched in order of their interface index, but not considering dst as a factor in the search. Because a loopback interface is typically the first one configured on a node, it will be the first alternate device to be tried. Addresses scoped at L\+I\+NK scope are not returned in this phase.

If no device pointer is provided, the same logic as above applies, only that there is no preferred device that is consulted first. This means that if the device pointer is null, input parameter dst will be ignored.

If there are no possible addresses to return, a warning log message is issued and the all-\/zeroes address is returned.


\begin{DoxyParams}{Parameters}
{\em device} & output \hyperlink{classns3_1_1NetDevice}{Net\+Device} (optionally provided, only to constrain the search) \\
\hline
{\em dst} & Destination address to match, if device is provided \\
\hline
{\em scope} & Scope of returned address must be less than or equal to this \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the first primary \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} that meets the search criteria 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_aa7a0d27e88ef21b5e83b36c0e602b6c2}{ns3\+::\+Ipv4\+L3\+Protocol}.

\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Send@{Send}}
\index{Send@{Send}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Send(\+Ptr$<$ Packet $>$ packet, Ipv4\+Address source, Ipv4\+Address destination, uint8\+\_\+t protocol, Ptr$<$ Ipv4\+Route $>$ route)=0}{Send(Ptr< Packet > packet, Ipv4Address source, Ipv4Address destination, uint8_t protocol, Ptr< Ipv4Route > route)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv4\+::\+Send (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Ipv4\+Address}}]{source, }
\item[{{\bf Ipv4\+Address}}]{destination, }
\item[{uint8\+\_\+t}]{protocol, }
\item[{{\bf Ptr}$<$ {\bf Ipv4\+Route} $>$}]{route}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_a81f6cbb774cdc255e3e49490e0960539}{}\label{classns3_1_1Ipv4_a81f6cbb774cdc255e3e49490e0960539}

\begin{DoxyParams}{Parameters}
{\em packet} & packet to send \\
\hline
{\em source} & source address of packet \\
\hline
{\em destination} & address of packet \\
\hline
{\em protocol} & number of packet \\
\hline
{\em route} & route entry\\
\hline
\end{DoxyParams}
Higher-\/level layers call this method to send a packet down the stack to the M\+AC and P\+HY layers. 

Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_abe8cf785815f3fbb32b0e21d629be641}{ns3\+::\+Ipv4\+L3\+Protocol}.



Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Send\+With\+Header@{Send\+With\+Header}}
\index{Send\+With\+Header@{Send\+With\+Header}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Send\+With\+Header(\+Ptr$<$ Packet $>$ packet, Ipv4\+Header ip\+Header, Ptr$<$ Ipv4\+Route $>$ route)=0}{SendWithHeader(Ptr< Packet > packet, Ipv4Header ipHeader, Ptr< Ipv4Route > route)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv4\+::\+Send\+With\+Header (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Ipv4\+Header}}]{ip\+Header, }
\item[{{\bf Ptr}$<$ {\bf Ipv4\+Route} $>$}]{route}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_a6d6b3f031557d3fccc195df342f8598a}{}\label{classns3_1_1Ipv4_a6d6b3f031557d3fccc195df342f8598a}

\begin{DoxyParams}{Parameters}
{\em packet} & packet to send \\
\hline
{\em ip\+Header} & IP \hyperlink{classns3_1_1Header}{Header} \\
\hline
{\em route} & route entry\\
\hline
\end{DoxyParams}
Higher-\/level layers call this method to send a packet with I\+Pv4 \hyperlink{classns3_1_1Header}{Header} (Intend to be used with Ip\+Header\+Include attribute.) 

Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_a9305010252cee1e4e97766227ca58ba4}{ns3\+::\+Ipv4\+L3\+Protocol}.

\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Set\+Down@{Set\+Down}}
\index{Set\+Down@{Set\+Down}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Set\+Down(uint32\+\_\+t interface)=0}{SetDown(uint32_t interface)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv4\+::\+Set\+Down (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_ac148839884b1ce11f9237ddc523f5cd2}{}\label{classns3_1_1Ipv4_ac148839884b1ce11f9237ddc523f5cd2}

\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of \hyperlink{classns3_1_1Ipv4}{Ipv4} interface\\
\hline
\end{DoxyParams}
Set the interface into the \char`\"{}down\char`\"{} state. In this state, it is ignored during \hyperlink{classns3_1_1Ipv4}{Ipv4} forwarding. 

Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_aad57377d10edd4f3de417533d7f07917}{ns3\+::\+Ipv4\+L3\+Protocol}.

\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Set\+Forwarding@{Set\+Forwarding}}
\index{Set\+Forwarding@{Set\+Forwarding}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Set\+Forwarding(uint32\+\_\+t interface, bool val)=0}{SetForwarding(uint32_t interface, bool val)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv4\+::\+Set\+Forwarding (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{bool}]{val}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_aee95b3b96994698f5629f8b9e617b587}{}\label{classns3_1_1Ipv4_aee95b3b96994698f5629f8b9e617b587}

\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of \hyperlink{classns3_1_1Ipv4}{Ipv4} interface \\
\hline
{\em val} & Value to set the forwarding flag\\
\hline
\end{DoxyParams}
If set to true, IP forwarding is enabled for input datagrams on this device 

Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_a4150655165d81cc01cb4ac4883de5c08}{ns3\+::\+Ipv4\+L3\+Protocol}.

\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Set\+Ip\+Forward@{Set\+Ip\+Forward}}
\index{Set\+Ip\+Forward@{Set\+Ip\+Forward}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Set\+Ip\+Forward(bool forward)=0}{SetIpForward(bool forward)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv4\+::\+Set\+Ip\+Forward (
\begin{DoxyParamCaption}
\item[{bool}]{forward}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_a12decc8332283f56ba59b0aacb3498ca}{}\label{classns3_1_1Ipv4_a12decc8332283f56ba59b0aacb3498ca}


Set or unset the IP forwarding state. 


\begin{DoxyParams}{Parameters}
{\em forward} & the forwarding state \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_a455a909e3bdcb5651e0ffd3eadf850d8}{ns3\+::\+Ipv4\+L3\+Protocol}.



Here is the caller graph for this function\+:
% FIG 12


\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Set\+Metric@{Set\+Metric}}
\index{Set\+Metric@{Set\+Metric}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Set\+Metric(uint32\+\_\+t interface, uint16\+\_\+t metric)=0}{SetMetric(uint32_t interface, uint16_t metric)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv4\+::\+Set\+Metric (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{uint16\+\_\+t}]{metric}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_a2b5632573b67957fabe2dfea248a57a3}{}\label{classns3_1_1Ipv4_a2b5632573b67957fabe2dfea248a57a3}

\begin{DoxyParams}{Parameters}
{\em interface} & The interface number of an \hyperlink{classns3_1_1Ipv4}{Ipv4} interface \\
\hline
{\em metric} & routing metric (cost) associated to the underlying \hyperlink{classns3_1_1Ipv4}{Ipv4} interface \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_acdb26739ce815d86b85767edca3f0068}{ns3\+::\+Ipv4\+L3\+Protocol}.



Here is the caller graph for this function\+:
% FIG 13


\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Set\+Routing\+Protocol@{Set\+Routing\+Protocol}}
\index{Set\+Routing\+Protocol@{Set\+Routing\+Protocol}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Set\+Routing\+Protocol(\+Ptr$<$ Ipv4\+Routing\+Protocol $>$ routing\+Protocol)=0}{SetRoutingProtocol(Ptr< Ipv4RoutingProtocol > routingProtocol)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv4\+::\+Set\+Routing\+Protocol (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv4\+Routing\+Protocol} $>$}]{routing\+Protocol}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_a2d165c3bafd4ca580f02a03536db80d3}{}\label{classns3_1_1Ipv4_a2d165c3bafd4ca580f02a03536db80d3}


Register a new routing protocol to be used by this \hyperlink{classns3_1_1Ipv4}{Ipv4} stack. 

This call will replace any routing protocol that has been previously registered. If you want to add multiple routing protocols, you must add them to a Ipv4\+List\+Routing\+Protocol directly.


\begin{DoxyParams}{Parameters}
{\em routing\+Protocol} & smart pointer to \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} object \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_a7e7d286dc2c782ea931d12a95203fc29}{ns3\+::\+Ipv4\+L3\+Protocol}.

\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Set\+Up@{Set\+Up}}
\index{Set\+Up@{Set\+Up}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Set\+Up(uint32\+\_\+t interface)=0}{SetUp(uint32_t interface)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv4\+::\+Set\+Up (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_a71b2f8acca4923aef907b50b3196bf23}{}\label{classns3_1_1Ipv4_a71b2f8acca4923aef907b50b3196bf23}

\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of \hyperlink{classns3_1_1Ipv4}{Ipv4} interface\\
\hline
\end{DoxyParams}
Set the interface into the \char`\"{}up\char`\"{} state. In this state, it is considered valid during \hyperlink{classns3_1_1Ipv4}{Ipv4} forwarding. 

Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_a9c4d254d735b420b7fb6e0a56a90f221}{ns3\+::\+Ipv4\+L3\+Protocol}.



Here is the caller graph for this function\+:
% FIG 14


\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Set\+Weak\+Es\+Model@{Set\+Weak\+Es\+Model}}
\index{Set\+Weak\+Es\+Model@{Set\+Weak\+Es\+Model}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Set\+Weak\+Es\+Model(bool model)=0}{SetWeakEsModel(bool model)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv4\+::\+Set\+Weak\+Es\+Model (
\begin{DoxyParamCaption}
\item[{bool}]{model}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_a3bdaf12fbfaca276c1a60a3a7cd9b68c}{}\label{classns3_1_1Ipv4_a3bdaf12fbfaca276c1a60a3a7cd9b68c}


Set or unset the Weak Es Model. 

R\+F\+C1122 term for whether host accepts datagram with a dest. address on another interface 
\begin{DoxyParams}{Parameters}
{\em model} & true for Weak Es Model \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_a45e538d92668de5fa759de6141751702}{ns3\+::\+Ipv4\+L3\+Protocol}.



Here is the caller graph for this function\+:
% FIG 15


\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!Source\+Address\+Selection@{Source\+Address\+Selection}}
\index{Source\+Address\+Selection@{Source\+Address\+Selection}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{Source\+Address\+Selection(uint32\+\_\+t interface, Ipv4\+Address dest)=0}{SourceAddressSelection(uint32_t interface, Ipv4Address dest)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Ipv4\+Address} ns3\+::\+Ipv4\+::\+Source\+Address\+Selection (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv4\+Address}}]{dest}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv4_ac7a49d14371de95cd1cc8f6563266edd}{}\label{classns3_1_1Ipv4_ac7a49d14371de95cd1cc8f6563266edd}


Choose the source address to use with destination address. 


\begin{DoxyParams}{Parameters}
{\em interface} & interface index \\
\hline
{\em dest} & I\+Pv4 destination address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
I\+Pv4 source address to use 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv4L3Protocol_a60f11e28019741497dd8730f53294b4f}{ns3\+::\+Ipv4\+L3\+Protocol}.



\subsection{Member Data Documentation}
\index{ns3\+::\+Ipv4@{ns3\+::\+Ipv4}!I\+F\+\_\+\+A\+NY@{I\+F\+\_\+\+A\+NY}}
\index{I\+F\+\_\+\+A\+NY@{I\+F\+\_\+\+A\+NY}!ns3\+::\+Ipv4@{ns3\+::\+Ipv4}}
\subsubsection[{\texorpdfstring{I\+F\+\_\+\+A\+NY}{IF_ANY}}]{\setlength{\rightskip}{0pt plus 5cm}const uint32\+\_\+t ns3\+::\+Ipv4\+::\+I\+F\+\_\+\+A\+NY = 0xffffffff\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv4_a9b05b2610976f8d53da45d95891a0657}{}\label{classns3_1_1Ipv4_a9b05b2610976f8d53da45d95891a0657}


interface wildcard, meaning any interface 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/model/\hyperlink{ipv4_8h}{ipv4.\+h}\item 
internet/model/\hyperlink{ipv4_8cc}{ipv4.\+cc}\end{DoxyCompactItemize}
