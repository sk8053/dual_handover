\hypertarget{classns3_1_1WifiQueue}{}\section{ns3\+:\+:Wifi\+Queue$<$ Item $>$ Class Template Reference}
\label{classns3_1_1WifiQueue}\index{ns3\+::\+Wifi\+Queue$<$ Item $>$@{ns3\+::\+Wifi\+Queue$<$ Item $>$}}


{\ttfamily \#include $<$block-\/ack-\/manager.\+h$>$}



Inheritance diagram for ns3\+:\+:Wifi\+Queue$<$ Item $>$\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Wifi\+Queue$<$ Item $>$\+:
% FIG 1
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classns3_1_1WifiQueue_a31cd8cafb8f3f8d162183f2a1754eddc}{Drop\+Policy} \{ \hyperlink{classns3_1_1WifiQueue_a31cd8cafb8f3f8d162183f2a1754eddca3578683d483860a57f65e5e784fc19ec}{D\+R\+O\+P\+\_\+\+N\+E\+W\+E\+ST}, 
\hyperlink{classns3_1_1WifiQueue_a31cd8cafb8f3f8d162183f2a1754eddca74d01c9f08b15019a3df13c5531fcbf0}{D\+R\+O\+P\+\_\+\+O\+L\+D\+E\+ST}
 \}\begin{DoxyCompactList}\small\item\em drop policy \end{DoxyCompactList}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1WifiQueue_a888b5859d593427165427461dd1f93a9}{Wifi\+Queue} ()
\item 
\hyperlink{classns3_1_1WifiQueue_a3d326c61c93a37a613a5a88baa44db3e}{$\sim$\+Wifi\+Queue} ()
\item 
void \hyperlink{classns3_1_1WifiQueue_a6a051869c84005e58b3585f87fbb4f2b}{Set\+Max\+Delay} (\hyperlink{classns3_1_1Time}{Time} \hyperlink{mmwave_2model_2fading-traces_2fading__trace__generator_8m_a7964e6aa8f61a9d28973c8267a606ad8}{delay})
\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1WifiQueue_a95d0d7636ae39fde1dca1f79190a6339}{Get\+Max\+Delay} (void) const 
\item 
bool \hyperlink{classns3_1_1WifiQueue_a509b8de8ba7f9126ed3191cb4a91f87b}{Enqueue} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ Item $>$ item)
\item 
bool \hyperlink{classns3_1_1WifiQueue_a9e15ef91113057214a9972e4a2c9f8e9}{Push\+Front} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ Item $>$ item)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ Item $>$ \hyperlink{classns3_1_1WifiQueue_a32d8b3612cbb83a76f67c2956ce82627}{Dequeue} (void)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ Item $>$ \hyperlink{classns3_1_1WifiQueue_af0fa49618470fe6d53b879861fbd7926}{Dequeue\+By\+Tid\+And\+Address} (uint8\+\_\+t tid, \hyperlink{classns3_1_1WifiMacHeader_a17406db48973a8e8fb6d961dd35154fe}{Wifi\+Mac\+Header\+::\+Address\+Type} \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type}, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} addr)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ Item $>$ \hyperlink{classns3_1_1WifiQueue_ab827ee78be5de8ac043504560b6be3f1}{Dequeue\+First\+Available} (const \hyperlink{classns3_1_1QosBlockedDestinations}{Qos\+Blocked\+Destinations} $\ast$blocked\+Packets)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const Item $>$ \hyperlink{classns3_1_1WifiQueue_a4cbd048691e6feeaaaeb5bd61afba704}{Peek} (void) const 
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const Item $>$ \hyperlink{classns3_1_1WifiQueue_a3d1b48d3bd1fb7593955e5a42ff61aeb}{Peek\+By\+Tid\+And\+Address} (uint8\+\_\+t tid, \hyperlink{classns3_1_1WifiMacHeader_a17406db48973a8e8fb6d961dd35154fe}{Wifi\+Mac\+Header\+::\+Address\+Type} \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type}, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} addr)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const Item $>$ \hyperlink{classns3_1_1WifiQueue_a7fa563e72d974b9200c17fc5d8afd41b}{Peek\+First\+Available} (const \hyperlink{classns3_1_1QosBlockedDestinations}{Qos\+Blocked\+Destinations} $\ast$blocked\+Packets)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ Item $>$ \hyperlink{classns3_1_1WifiQueue_a268b987d47e0e8b611557547c5104723}{Remove} (void)
\item 
bool \hyperlink{classns3_1_1WifiQueue_a430f2c6eb99315791dd316dbead9a9de}{Remove} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet)
\item 
uint32\+\_\+t \hyperlink{classns3_1_1WifiQueue_a1d4fcfe71ed2e341e97a315383aab695}{Get\+N\+Packets\+By\+Tid\+And\+Address} (uint8\+\_\+t tid, \hyperlink{classns3_1_1WifiMacHeader_a17406db48973a8e8fb6d961dd35154fe}{Wifi\+Mac\+Header\+::\+Address\+Type} \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type}, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} addr)
\item 
bool \hyperlink{classns3_1_1WifiQueue_ab4a0e0f26d4b88534d8df601dc3cab97}{Has\+Packets} (void)
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1WifiQueue_a9741d8376010aec96a05bf237db14a82}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classns3_1_1WifiQueue_a6a90562f553a5938725afc0c77a88dc7}{Ttl\+Exceeded} (typename \hyperlink{classns3_1_1Queue}{Queue}$<$ Item $>$\+::\hyperlink{classns3_1_1Queue_af108d00696b556f3b3addd8816413119}{Const\+Iterator} \&it)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1WifiQueue_a03250df9a7461abb71034e610c193093}{m\+\_\+max\+Delay}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Time}{Time} to live for packets in the queue. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1WifiQueue_a31cd8cafb8f3f8d162183f2a1754eddc}{Drop\+Policy} \hyperlink{classns3_1_1WifiQueue_a0dd5aa1773f1bba30d03e07f63e6dc30}{m\+\_\+drop\+Policy}
\begin{DoxyCompactList}\small\item\em Drop behavior of queue. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Item$>$\\*
class ns3\+::\+Wifi\+Queue$<$ Item $>$}

This queue implements the timeout procedure described in (Section 9.\+19.\+2.\+6 \char`\"{}\+Retransmit procedures\char`\"{} paragraph 6; I\+E\+EE 802.\+11-\/2012).

When a packet is received by the M\+AC, to be sent to the P\+HY, it is queued in the internal queue after being tagged by the current time.

When a packet is dequeued, the queue checks its timestamp to verify whether or not it should be dropped. If dot11\+E\+D\+C\+A\+Table\+M\+S\+D\+U\+Lifetime has elapsed, it is dropped. Otherwise, it is returned to the caller.

Wifi\+Mac\+Queue could have been declared as a subclass of Queue$<$\+Wifi\+Mac\+Queue\+Item$>$, but this would have caused python examples using wifi to crash at runtime with the following error message\+: \char`\"{}\+Trying to allocate twice the same uid\+:
ns3\+::\+Queue$<$\+Wifi\+Mac\+Queue\+Item$>$\char`\"{}. Such an error wasn\textquotesingle{}t fully debugged but it may have been due to static initialization order issues.

To avoid such an error, the template class Wifi\+Queue$<$\+Item$>$ is introduced as a subclass of Queue$<$\+Item$>$. Wifi\+Mac\+Queue is then declared as a specialization of Wifi\+Queue$<$\+Item$>$ with Item equal to \hyperlink{classns3_1_1WifiMacQueueItem}{Wifi\+Mac\+Queue\+Item}. The methods of the \hyperlink{classns3_1_1WifiQueue}{Wifi\+Queue} class are left unimplemented for Item other than \hyperlink{classns3_1_1WifiMacQueueItem}{Wifi\+Mac\+Queue\+Item}.

Modules that need to forward declare Wifi\+Mac\+Queue have to include the following\+:


\begin{DoxyCode}
\textcolor{keyword}{class }WifiMacQueueItem;
\textcolor{keyword}{template} <\textcolor{keyword}{typename} Item> \textcolor{keyword}{class }\hyperlink{classns3_1_1WifiQueue_a888b5859d593427165427461dd1f93a9}{WifiQueue};
\textcolor{keyword}{typedef} WifiQueue<WifiMacQueueItem> \hyperlink{namespacens3_a3ca96bcdf02c0e7cacea08ca62ead54c}{WifiMacQueue};
\end{DoxyCode}


in their header file. 

\subsection{Member Enumeration Documentation}
\index{ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}!Drop\+Policy@{Drop\+Policy}}
\index{Drop\+Policy@{Drop\+Policy}!ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}}
\subsubsection[{\texorpdfstring{Drop\+Policy}{DropPolicy}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Item $>$ enum {\bf ns3\+::\+Wifi\+Queue\+::\+Drop\+Policy}}\hypertarget{classns3_1_1WifiQueue_a31cd8cafb8f3f8d162183f2a1754eddc}{}\label{classns3_1_1WifiQueue_a31cd8cafb8f3f8d162183f2a1754eddc}


drop policy 

\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{D\+R\+O\+P\+\_\+\+N\+E\+W\+E\+ST@{D\+R\+O\+P\+\_\+\+N\+E\+W\+E\+ST}!ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}}\index{ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}!D\+R\+O\+P\+\_\+\+N\+E\+W\+E\+ST@{D\+R\+O\+P\+\_\+\+N\+E\+W\+E\+ST}}\item[{\em 
D\+R\+O\+P\+\_\+\+N\+E\+W\+E\+ST\hypertarget{classns3_1_1WifiQueue_a31cd8cafb8f3f8d162183f2a1754eddca3578683d483860a57f65e5e784fc19ec}{}\label{classns3_1_1WifiQueue_a31cd8cafb8f3f8d162183f2a1754eddca3578683d483860a57f65e5e784fc19ec}
}]\index{D\+R\+O\+P\+\_\+\+O\+L\+D\+E\+ST@{D\+R\+O\+P\+\_\+\+O\+L\+D\+E\+ST}!ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}}\index{ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}!D\+R\+O\+P\+\_\+\+O\+L\+D\+E\+ST@{D\+R\+O\+P\+\_\+\+O\+L\+D\+E\+ST}}\item[{\em 
D\+R\+O\+P\+\_\+\+O\+L\+D\+E\+ST\hypertarget{classns3_1_1WifiQueue_a31cd8cafb8f3f8d162183f2a1754eddca74d01c9f08b15019a3df13c5531fcbf0}{}\label{classns3_1_1WifiQueue_a31cd8cafb8f3f8d162183f2a1754eddca74d01c9f08b15019a3df13c5531fcbf0}
}]\end{description}
\end{Desc}

\begin{DoxyCode}
162   \{
163     \hyperlink{classns3_1_1WifiQueue_a31cd8cafb8f3f8d162183f2a1754eddca3578683d483860a57f65e5e784fc19ec}{DROP\_NEWEST},
164     \hyperlink{classns3_1_1WifiQueue_a31cd8cafb8f3f8d162183f2a1754eddca74d01c9f08b15019a3df13c5531fcbf0}{DROP\_OLDEST}
165   \};
\end{DoxyCode}


\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}!Wifi\+Queue@{Wifi\+Queue}}
\index{Wifi\+Queue@{Wifi\+Queue}!ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}}
\subsubsection[{\texorpdfstring{Wifi\+Queue()}{WifiQueue()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Wifi\+Mac\+Queue\+::\+Wifi\+Queue (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WifiQueue_a888b5859d593427165427461dd1f93a9}{}\label{classns3_1_1WifiQueue_a888b5859d593427165427461dd1f93a9}

\begin{DoxyCode}
114 \{
115 \}
\end{DoxyCode}
\index{ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}!````~Wifi\+Queue@{$\sim$\+Wifi\+Queue}}
\index{````~Wifi\+Queue@{$\sim$\+Wifi\+Queue}!ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}}
\subsubsection[{\texorpdfstring{$\sim$\+Wifi\+Queue()}{~WifiQueue()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Wifi\+Mac\+Queue\+::$\sim$\+Wifi\+Queue (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WifiQueue_a3d326c61c93a37a613a5a88baa44db3e}{}\label{classns3_1_1WifiQueue_a3d326c61c93a37a613a5a88baa44db3e}

\begin{DoxyCode}
119 \{
120   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
121 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}!Dequeue@{Dequeue}}
\index{Dequeue@{Dequeue}!ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}}
\subsubsection[{\texorpdfstring{Dequeue(void)}{Dequeue(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Wifi\+Mac\+Queue\+Item} $>$ ns3\+::\+Wifi\+Mac\+Queue\+::\+Dequeue (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WifiQueue_a32d8b3612cbb83a76f67c2956ce82627}{}\label{classns3_1_1WifiQueue_a32d8b3612cbb83a76f67c2956ce82627}
Dequeue the packet in the front of the queue.

\begin{DoxyReturn}{Returns}
the packet 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Queue_a9cf7af155b96b1b59f1a61d77680176a}{ns3\+::\+Queue$<$ Item $>$}.


\begin{DoxyCode}
211 \{
212   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
213 
214   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = \hyperlink{classns3_1_1Queue_a22bfb0852a9de53cf9f44e6166279a4f}{Head} (); it != \hyperlink{classns3_1_1Queue_a34b4a2b16dc1d51f02a18358d66faf46}{Tail} (); )
215     \{
216       \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1WifiQueue_a6a90562f553a5938725afc0c77a88dc7}{TtlExceeded} (it))
217         \{
218           \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Queue_a7d5e900f5ebc08733bcc8ead96997447}{DoDequeue} (it);
219         \}
220     \}
221   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The queue is empty"});
222   \textcolor{keywordflow}{return} 0;
223 \}
\end{DoxyCode}
\index{ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}!Dequeue\+By\+Tid\+And\+Address@{Dequeue\+By\+Tid\+And\+Address}}
\index{Dequeue\+By\+Tid\+And\+Address@{Dequeue\+By\+Tid\+And\+Address}!ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}}
\subsubsection[{\texorpdfstring{Dequeue\+By\+Tid\+And\+Address(uint8\+\_\+t tid, Wifi\+Mac\+Header\+::\+Address\+Type type, Mac48\+Address addr)}{DequeueByTidAndAddress(uint8_t tid, WifiMacHeader::AddressType type, Mac48Address addr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Wifi\+Mac\+Queue\+Item} $>$ ns3\+::\+Wifi\+Mac\+Queue\+::\+Dequeue\+By\+Tid\+And\+Address (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{tid, }
\item[{{\bf Wifi\+Mac\+Header\+::\+Address\+Type}}]{type, }
\item[{{\bf Mac48\+Address}}]{addr}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WifiQueue_af0fa49618470fe6d53b879861fbd7926}{}\label{classns3_1_1WifiQueue_af0fa49618470fe6d53b879861fbd7926}
Search and return, if present in the queue, the first packet having the address indicated by {\itshape type} equal to {\itshape addr}, and tid equal to {\itshape tid}. This method removes the packet from the queue. It is typically used by \hyperlink{classns3_1_1EdcaTxopN}{ns3\+::\+Edca\+TxopN} in order to perform correct M\+S\+DU aggregation (A-\/\+M\+S\+DU).


\begin{DoxyParams}{Parameters}
{\em tid} & the given T\+ID \\
\hline
{\em type} & the given address type \\
\hline
{\em addr} & the given destination\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the packet 
\end{DoxyReturn}

\begin{DoxyCode}
229 \{
230   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << dest);
231 
232   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = \hyperlink{classns3_1_1Queue_a22bfb0852a9de53cf9f44e6166279a4f}{Head} (); it != \hyperlink{classns3_1_1Queue_a34b4a2b16dc1d51f02a18358d66faf46}{Tail} (); )
233     \{
234       \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1WifiQueue_a6a90562f553a5938725afc0c77a88dc7}{TtlExceeded} (it))
235         \{
236           \textcolor{keywordflow}{if} ((*it)->GetHeader ().IsQosData () && (*it)->GetAddress (\hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type}) == dest &&
237               (*it)->GetHeader ().GetQosTid () == tid)
238             \{
239               \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Queue_a7d5e900f5ebc08733bcc8ead96997447}{DoDequeue} (it);
240             \}
241 
242           it++;
243         \}
244     \}
245   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The queue is empty"});
246   \textcolor{keywordflow}{return} 0;
247 \}
\end{DoxyCode}
\index{ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}!Dequeue\+First\+Available@{Dequeue\+First\+Available}}
\index{Dequeue\+First\+Available@{Dequeue\+First\+Available}!ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}}
\subsubsection[{\texorpdfstring{Dequeue\+First\+Available(const Qos\+Blocked\+Destinations $\ast$blocked\+Packets)}{DequeueFirstAvailable(const QosBlockedDestinations *blockedPackets)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Wifi\+Mac\+Queue\+Item} $>$ ns3\+::\+Wifi\+Mac\+Queue\+::\+Dequeue\+First\+Available (
\begin{DoxyParamCaption}
\item[{const {\bf Qos\+Blocked\+Destinations} $\ast$}]{blocked\+Packets}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WifiQueue_ab827ee78be5de8ac043504560b6be3f1}{}\label{classns3_1_1WifiQueue_ab827ee78be5de8ac043504560b6be3f1}
Return first available packet for transmission. A packet could be no available if it is a QoS packet with a tid and an address1 fields equal to {\itshape tid} and {\itshape addr} respectively that index a pending agreement in the \hyperlink{classns3_1_1BlockAckManager}{Block\+Ack\+Manager} object. So that packet must not be transmitted until reception of an A\+D\+D\+BA response frame from station addressed by {\itshape addr}. This method removes the packet from queue.


\begin{DoxyParams}{Parameters}
{\em blocked\+Packets} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
packet 
\end{DoxyReturn}

\begin{DoxyCode}
252 \{
253   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
254 
255   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = \hyperlink{classns3_1_1Queue_a22bfb0852a9de53cf9f44e6166279a4f}{Head} (); it != \hyperlink{classns3_1_1Queue_a34b4a2b16dc1d51f02a18358d66faf46}{Tail} (); )
256     \{
257       \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1WifiQueue_a6a90562f553a5938725afc0c77a88dc7}{TtlExceeded} (it))
258         \{
259           \textcolor{keywordflow}{if} (!(*it)->GetHeader ().IsQosData ()
260               || !blockedPackets->IsBlocked ((*it)->GetHeader ().GetAddr1 (), (*it)->GetHeader ().GetQosTid
       ()))
261             \{
262               \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Queue_a7d5e900f5ebc08733bcc8ead96997447}{DoDequeue} (it);
263             \}
264 
265           it++;
266         \}
267     \}
268   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The queue is empty"});
269   \textcolor{keywordflow}{return} 0;
270 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}!Enqueue@{Enqueue}}
\index{Enqueue@{Enqueue}!ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}}
\subsubsection[{\texorpdfstring{Enqueue(\+Ptr$<$ Item $>$ item)}{Enqueue(Ptr< Item > item)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Item $>$ bool {\bf ns3\+::\+Wifi\+Queue}$<$ Item $>$\+::Enqueue (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ Item $>$}]{item}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WifiQueue_a509b8de8ba7f9126ed3191cb4a91f87b}{}\label{classns3_1_1WifiQueue_a509b8de8ba7f9126ed3191cb4a91f87b}
Enqueue the given Wifi M\+AC queue item at the {\itshape end} of the queue.


\begin{DoxyParams}{Parameters}
{\em item} & the Wifi M\+AC queue item to be enqueued at the end \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if success, false if the packet has been dropped 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Queue_adb0a0fa921500253f8bb60f7ca819c5e}{ns3\+::\+Queue$<$ Item $>$}.



Here is the caller graph for this function\+:
% FIG 3


\index{ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}!Get\+Max\+Delay@{Get\+Max\+Delay}}
\index{Get\+Max\+Delay@{Get\+Max\+Delay}!ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}}
\subsubsection[{\texorpdfstring{Get\+Max\+Delay(void) const }{GetMaxDelay(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Wifi\+Mac\+Queue\+::\+Get\+Max\+Delay (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1WifiQueue_a95d0d7636ae39fde1dca1f79190a6339}{}\label{classns3_1_1WifiQueue_a95d0d7636ae39fde1dca1f79190a6339}
Return the maximum delay before the packet is discarded.

\begin{DoxyReturn}{Returns}
the maximum delay 
\end{DoxyReturn}

\begin{DoxyCode}
135 \{
136   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
137 
138   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1WifiQueue_a03250df9a7461abb71034e610c193093}{m\_maxDelay};
139 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4


\index{ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}!Get\+N\+Packets\+By\+Tid\+And\+Address@{Get\+N\+Packets\+By\+Tid\+And\+Address}}
\index{Get\+N\+Packets\+By\+Tid\+And\+Address@{Get\+N\+Packets\+By\+Tid\+And\+Address}!ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}}
\subsubsection[{\texorpdfstring{Get\+N\+Packets\+By\+Tid\+And\+Address(uint8\+\_\+t tid, Wifi\+Mac\+Header\+::\+Address\+Type type, Mac48\+Address addr)}{GetNPacketsByTidAndAddress(uint8_t tid, WifiMacHeader::AddressType type, Mac48Address addr)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Wifi\+Mac\+Queue\+::\+Get\+N\+Packets\+By\+Tid\+And\+Address (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{tid, }
\item[{{\bf Wifi\+Mac\+Header\+::\+Address\+Type}}]{type, }
\item[{{\bf Mac48\+Address}}]{addr}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WifiQueue_a1d4fcfe71ed2e341e97a315383aab695}{}\label{classns3_1_1WifiQueue_a1d4fcfe71ed2e341e97a315383aab695}
Return the number of QoS packets having tid equal to {\itshape tid} and address specified by {\itshape type} equal to {\itshape addr}.


\begin{DoxyParams}{Parameters}
{\em tid} & the given T\+ID \\
\hline
{\em type} & the given address type \\
\hline
{\em addr} & the given destination\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of QoS packets 
\end{DoxyReturn}

\begin{DoxyCode}
371 \{
372   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << addr);
373 
374   uint32\_t nPackets = 0;
375 
376   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = \hyperlink{classns3_1_1Queue_a22bfb0852a9de53cf9f44e6166279a4f}{Head} (); it != \hyperlink{classns3_1_1Queue_a34b4a2b16dc1d51f02a18358d66faf46}{Tail} (); )
377     \{
378       \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1WifiQueue_a6a90562f553a5938725afc0c77a88dc7}{TtlExceeded} (it))
379         \{
380           \textcolor{keywordflow}{if} ((*it)->GetHeader ().IsQosData () && (*it)->GetAddress (\hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type}) == addr &&
381               (*it)->GetHeader ().GetQosTid () == tid)
382             \{
383               nPackets++;
384             \}
385 
386           it++;
387         \}
388     \}
389   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"returns "} << nPackets);
390   \textcolor{keywordflow}{return} nPackets;
391 \}
\end{DoxyCode}
\index{ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Wifi\+Mac\+Queue\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1WifiQueue_a9741d8376010aec96a05bf237db14a82}{}\label{classns3_1_1WifiQueue_a9741d8376010aec96a05bf237db14a82}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
94 \{
95   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::WifiMacQueue"})
96     .SetParent<Queue<WifiMacQueueItem> > ()
97     .SetGroupName (\textcolor{stringliteral}{"Wifi"})
98     .AddConstructor<\hyperlink{namespacens3_a3ca96bcdf02c0e7cacea08ca62ead54c}{WifiMacQueue}> ()
99     .AddAttribute (\textcolor{stringliteral}{"MaxDelay"}, \textcolor{stringliteral}{"If a packet stays longer than this delay in the queue, it is dropped."},
100                    TimeValue (\hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (500.0)),
101                    MakeTimeAccessor (&\hyperlink{classns3_1_1WifiQueue_a03250df9a7461abb71034e610c193093}{WifiMacQueue::m\_maxDelay}),
102                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
103     .AddAttribute (\textcolor{stringliteral}{"DropPolicy"}, \textcolor{stringliteral}{"Upon enqueue with full queue, drop oldest (DropOldest) or newest
       (DropNewest) packet"},
104                    EnumValue (\hyperlink{classns3_1_1WifiQueue_a31cd8cafb8f3f8d162183f2a1754eddca3578683d483860a57f65e5e784fc19ec}{DROP\_NEWEST}),
105                    \hyperlink{namespacens3_af5050739867ce63896dec011e332c8ec}{MakeEnumAccessor} (&\hyperlink{classns3_1_1WifiQueue_a0dd5aa1773f1bba30d03e07f63e6dc30}{WifiMacQueue::m\_dropPolicy})
      ,
106                    \hyperlink{namespacens3_a48832781a2b521d3d0091e05ece30615}{MakeEnumChecker} (\hyperlink{classns3_1_1WifiQueue_a31cd8cafb8f3f8d162183f2a1754eddca74d01c9f08b15019a3df13c5531fcbf0}{WifiMacQueue::DROP\_OLDEST}, \textcolor{stringliteral}{"
      DropOldest"},
107                                     \hyperlink{classns3_1_1WifiQueue_a31cd8cafb8f3f8d162183f2a1754eddca3578683d483860a57f65e5e784fc19ec}{WifiMacQueue::DROP\_NEWEST}, \textcolor{stringliteral}{"DropNewest"}))
108   ;
109   \textcolor{keywordflow}{return} tid;
110 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5


\index{ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}!Has\+Packets@{Has\+Packets}}
\index{Has\+Packets@{Has\+Packets}!ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}}
\subsubsection[{\texorpdfstring{Has\+Packets(void)}{HasPackets(void)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Wifi\+Mac\+Queue\+::\+Has\+Packets (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WifiQueue_ab4a0e0f26d4b88534d8df601dc3cab97}{}\label{classns3_1_1WifiQueue_ab4a0e0f26d4b88534d8df601dc3cab97}
This method must be used (instead of the Is\+Empty method of the base class) to check whether there are packets with unexpired time to live in the queue

\begin{DoxyReturn}{Returns}
true if there are packets with unexpired time to live 
\end{DoxyReturn}

\begin{DoxyCode}
396 \{
397   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
398 
399   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = \hyperlink{classns3_1_1Queue_a22bfb0852a9de53cf9f44e6166279a4f}{Head} (); it != \hyperlink{classns3_1_1Queue_a34b4a2b16dc1d51f02a18358d66faf46}{Tail} (); )
400     \{
401       \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1WifiQueue_a6a90562f553a5938725afc0c77a88dc7}{TtlExceeded} (it))
402         \{
403           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"returns true"});
404           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
405         \}
406     \}
407   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"returns false"});
408   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
409 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6


\index{ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}!Peek@{Peek}}
\index{Peek@{Peek}!ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}}
\subsubsection[{\texorpdfstring{Peek(void) const }{Peek(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ const {\bf Wifi\+Mac\+Queue\+Item} $>$ ns3\+::\+Wifi\+Mac\+Queue\+::\+Peek (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WifiQueue_a4cbd048691e6feeaaaeb5bd61afba704}{}\label{classns3_1_1WifiQueue_a4cbd048691e6feeaaaeb5bd61afba704}
Peek the packet in the front of the queue. The packet is not removed.

\begin{DoxyReturn}{Returns}
the packet 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Queue_a8cfd906d4e0d7090cf7bc1d3437265fe}{ns3\+::\+Queue$<$ Item $>$}.


\begin{DoxyCode}
275 \{
276   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
277   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Queue_add8f532cc43e5bf05c1913682f5f70be}{DoPeek} (\hyperlink{classns3_1_1Queue_a22bfb0852a9de53cf9f44e6166279a4f}{Head} ());
278 \}
\end{DoxyCode}
\index{ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}!Peek\+By\+Tid\+And\+Address@{Peek\+By\+Tid\+And\+Address}}
\index{Peek\+By\+Tid\+And\+Address@{Peek\+By\+Tid\+And\+Address}!ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}}
\subsubsection[{\texorpdfstring{Peek\+By\+Tid\+And\+Address(uint8\+\_\+t tid, Wifi\+Mac\+Header\+::\+Address\+Type type, Mac48\+Address addr)}{PeekByTidAndAddress(uint8_t tid, WifiMacHeader::AddressType type, Mac48Address addr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ const {\bf Wifi\+Mac\+Queue\+Item} $>$ ns3\+::\+Wifi\+Mac\+Queue\+::\+Peek\+By\+Tid\+And\+Address (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{tid, }
\item[{{\bf Wifi\+Mac\+Header\+::\+Address\+Type}}]{type, }
\item[{{\bf Mac48\+Address}}]{addr}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WifiQueue_a3d1b48d3bd1fb7593955e5a42ff61aeb}{}\label{classns3_1_1WifiQueue_a3d1b48d3bd1fb7593955e5a42ff61aeb}
Search and return, if present in the queue, the first packet having the address indicated by {\itshape type} equal to {\itshape addr}, and tid equal to {\itshape tid}. This method does not remove the packet from the queue. It is typically used by \hyperlink{classns3_1_1EdcaTxopN}{ns3\+::\+Edca\+TxopN} in order to perform correct M\+S\+DU aggregation (A-\/\+M\+S\+DU).


\begin{DoxyParams}{Parameters}
{\em tid} & the given T\+ID \\
\hline
{\em type} & the given address type \\
\hline
{\em addr} & the given destination\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
packet 
\end{DoxyReturn}

\begin{DoxyCode}
284 \{
285   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << dest);
286 
287   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = \hyperlink{classns3_1_1Queue_a22bfb0852a9de53cf9f44e6166279a4f}{Head} (); it != \hyperlink{classns3_1_1Queue_a34b4a2b16dc1d51f02a18358d66faf46}{Tail} (); )
288     \{
289       \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1WifiQueue_a6a90562f553a5938725afc0c77a88dc7}{TtlExceeded} (it))
290         \{
291           \textcolor{keywordflow}{if} ((*it)->GetHeader ().IsQosData () && (*it)->GetAddress (\hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type}) == dest &&
292               (*it)->GetHeader ().GetQosTid () == tid)
293             \{
294               \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Queue_add8f532cc43e5bf05c1913682f5f70be}{DoPeek} (it);
295             \}
296 
297           it++;
298         \}
299     \}
300   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The queue is empty"});
301   \textcolor{keywordflow}{return} 0;
302 \}
\end{DoxyCode}
\index{ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}!Peek\+First\+Available@{Peek\+First\+Available}}
\index{Peek\+First\+Available@{Peek\+First\+Available}!ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}}
\subsubsection[{\texorpdfstring{Peek\+First\+Available(const Qos\+Blocked\+Destinations $\ast$blocked\+Packets)}{PeekFirstAvailable(const QosBlockedDestinations *blockedPackets)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ const {\bf Wifi\+Mac\+Queue\+Item} $>$ ns3\+::\+Wifi\+Mac\+Queue\+::\+Peek\+First\+Available (
\begin{DoxyParamCaption}
\item[{const {\bf Qos\+Blocked\+Destinations} $\ast$}]{blocked\+Packets}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WifiQueue_a7fa563e72d974b9200c17fc5d8afd41b}{}\label{classns3_1_1WifiQueue_a7fa563e72d974b9200c17fc5d8afd41b}
Return first available packet for transmission. The packet is not removed from queue.


\begin{DoxyParams}{Parameters}
{\em hdr} & the header of the dequeued packet \\
\hline
{\em t\+Stamp} & \\
\hline
{\em blocked\+Packets} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
packet 
\end{DoxyReturn}

\begin{DoxyCode}
307 \{
308   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
309 
310   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = \hyperlink{classns3_1_1Queue_a22bfb0852a9de53cf9f44e6166279a4f}{Head} (); it != \hyperlink{classns3_1_1Queue_a34b4a2b16dc1d51f02a18358d66faf46}{Tail} (); )
311     \{
312       \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1WifiQueue_a6a90562f553a5938725afc0c77a88dc7}{TtlExceeded} (it))
313         \{
314           \textcolor{keywordflow}{if} (!(*it)->GetHeader ().IsQosData ()
315               || !blockedPackets->IsBlocked ((*it)->GetHeader ().GetAddr1 (), (*it)->GetHeader ().GetQosTid
       ()))
316             \{
317               \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Queue_add8f532cc43e5bf05c1913682f5f70be}{DoPeek} (it);
318             \}
319 
320           it++;
321         \}
322     \}
323   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The queue is empty"});
324   \textcolor{keywordflow}{return} 0;
325 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7


\index{ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}!Push\+Front@{Push\+Front}}
\index{Push\+Front@{Push\+Front}!ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}}
\subsubsection[{\texorpdfstring{Push\+Front(\+Ptr$<$ Item $>$ item)}{PushFront(Ptr< Item > item)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Item $>$ bool {\bf ns3\+::\+Wifi\+Queue}$<$ Item $>$\+::Push\+Front (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ Item $>$}]{item}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WifiQueue_a9e15ef91113057214a9972e4a2c9f8e9}{}\label{classns3_1_1WifiQueue_a9e15ef91113057214a9972e4a2c9f8e9}
Enqueue the given Wifi M\+AC queue item at the {\itshape front} of the queue.


\begin{DoxyParams}{Parameters}
{\em item} & the Wifi M\+AC queue item to be enqueued at the front \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if success, false if the packet has been dropped 
\end{DoxyReturn}


Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}!Remove@{Remove}}
\index{Remove@{Remove}!ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}}
\subsubsection[{\texorpdfstring{Remove(void)}{Remove(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Wifi\+Mac\+Queue\+Item} $>$ ns3\+::\+Wifi\+Mac\+Queue\+::\+Remove (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WifiQueue_a268b987d47e0e8b611557547c5104723}{}\label{classns3_1_1WifiQueue_a268b987d47e0e8b611557547c5104723}
Remove the packet in the front of the queue.

\begin{DoxyReturn}{Returns}
the packet 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Queue_a4c9b65890dff0ff3d3dcae12a8dfccec}{ns3\+::\+Queue$<$ Item $>$}.


\begin{DoxyCode}
330 \{
331   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
332 
333   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = \hyperlink{classns3_1_1Queue_a22bfb0852a9de53cf9f44e6166279a4f}{Head} (); it != \hyperlink{classns3_1_1Queue_a34b4a2b16dc1d51f02a18358d66faf46}{Tail} (); )
334     \{
335       \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1WifiQueue_a6a90562f553a5938725afc0c77a88dc7}{TtlExceeded} (it))
336         \{
337           \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Queue_aeafca6fdd31674467fb5251b14ba5899}{DoRemove} (it);
338         \}
339     \}
340   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The queue is empty"});
341   \textcolor{keywordflow}{return} 0;
342 \}
\end{DoxyCode}
\index{ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}!Remove@{Remove}}
\index{Remove@{Remove}!ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}}
\subsubsection[{\texorpdfstring{Remove(\+Ptr$<$ const Packet $>$ packet)}{Remove(Ptr< const Packet > packet)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Wifi\+Mac\+Queue\+::\+Remove (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{packet}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WifiQueue_a430f2c6eb99315791dd316dbead9a9de}{}\label{classns3_1_1WifiQueue_a430f2c6eb99315791dd316dbead9a9de}
If exists, removes {\itshape packet} from queue and returns true. Otherwise it takes no effects and return false. Deletion of the packet is performed in linear time (O(n)).


\begin{DoxyParams}{Parameters}
{\em packet} & the packet to be removed\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the packet was removed, false otherwise 
\end{DoxyReturn}

\begin{DoxyCode}
347 \{
348   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet);
349 
350   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = \hyperlink{classns3_1_1Queue_a22bfb0852a9de53cf9f44e6166279a4f}{Head} (); it != \hyperlink{classns3_1_1Queue_a34b4a2b16dc1d51f02a18358d66faf46}{Tail} (); )
351     \{
352       \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1WifiQueue_a6a90562f553a5938725afc0c77a88dc7}{TtlExceeded} (it))
353         \{
354           \textcolor{keywordflow}{if} ((*it)->GetPacket () == packet)
355             \{
356               \hyperlink{classns3_1_1Queue_aeafca6fdd31674467fb5251b14ba5899}{DoRemove} (it);
357               \textcolor{keywordflow}{return} \textcolor{keyword}{true};
358             \}
359 
360           it++;
361         \}
362     \}
363   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Packet "} << packet << \textcolor{stringliteral}{" not found in the queue"});
364   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
365 \}
\end{DoxyCode}
\index{ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}!Set\+Max\+Delay@{Set\+Max\+Delay}}
\index{Set\+Max\+Delay@{Set\+Max\+Delay}!ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}}
\subsubsection[{\texorpdfstring{Set\+Max\+Delay(\+Time delay)}{SetMaxDelay(Time delay)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Wifi\+Mac\+Queue\+::\+Set\+Max\+Delay (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{delay}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WifiQueue_a6a051869c84005e58b3585f87fbb4f2b}{}\label{classns3_1_1WifiQueue_a6a051869c84005e58b3585f87fbb4f2b}
Set the maximum delay before the packet is discarded.


\begin{DoxyParams}{Parameters}
{\em delay} & the maximum delay \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
126 \{
127   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_a7964e6aa8f61a9d28973c8267a606ad8}{delay});
128 
129   \hyperlink{classns3_1_1WifiQueue_a03250df9a7461abb71034e610c193093}{m\_maxDelay} = \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_a7964e6aa8f61a9d28973c8267a606ad8}{delay};
130 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9


\index{ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}!Ttl\+Exceeded@{Ttl\+Exceeded}}
\index{Ttl\+Exceeded@{Ttl\+Exceeded}!ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}}
\subsubsection[{\texorpdfstring{Ttl\+Exceeded(typename Queue$<$ Item $>$\+::\+Const\+Iterator \&it)}{TtlExceeded(typename Queue< Item >::ConstIterator &it)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Item $>$ bool {\bf ns3\+::\+Wifi\+Queue}$<$ Item $>$\+::Ttl\+Exceeded (
\begin{DoxyParamCaption}
\item[{typename {\bf Queue}$<$ Item $>$\+::{\bf Const\+Iterator} \&}]{it}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WifiQueue_a6a90562f553a5938725afc0c77a88dc7}{}\label{classns3_1_1WifiQueue_a6a90562f553a5938725afc0c77a88dc7}
Remove the item pointed to by the iterator {\itshape it} if it has been in the queue for too long. If the item is removed, the iterator is updated to point to the item that followed the erased one.


\begin{DoxyParams}{Parameters}
{\em it} & an iterator pointing to the item \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the item is removed, false otherwise 
\end{DoxyReturn}


Here is the caller graph for this function\+:
% FIG 10




\subsection{Member Data Documentation}
\index{ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}!m\+\_\+drop\+Policy@{m\+\_\+drop\+Policy}}
\index{m\+\_\+drop\+Policy@{m\+\_\+drop\+Policy}!ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}}
\subsubsection[{\texorpdfstring{m\+\_\+drop\+Policy}{m_dropPolicy}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Item $>$ {\bf Drop\+Policy} {\bf ns3\+::\+Wifi\+Queue}$<$ Item $>$\+::m\+\_\+drop\+Policy\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WifiQueue_a0dd5aa1773f1bba30d03e07f63e6dc30}{}\label{classns3_1_1WifiQueue_a0dd5aa1773f1bba30d03e07f63e6dc30}


Drop behavior of queue. 

\index{ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}!m\+\_\+max\+Delay@{m\+\_\+max\+Delay}}
\index{m\+\_\+max\+Delay@{m\+\_\+max\+Delay}!ns3\+::\+Wifi\+Queue@{ns3\+::\+Wifi\+Queue}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Delay}{m_maxDelay}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Item $>$ {\bf Time} {\bf ns3\+::\+Wifi\+Queue}$<$ Item $>$\+::m\+\_\+max\+Delay\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WifiQueue_a03250df9a7461abb71034e610c193093}{}\label{classns3_1_1WifiQueue_a03250df9a7461abb71034e610c193093}


\hyperlink{classns3_1_1Time}{Time} to live for packets in the queue. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
wifi/model/\hyperlink{block-ack-manager_8h}{block-\/ack-\/manager.\+h}\item 
wifi/model/\hyperlink{wifi-mac-queue_8h}{wifi-\/mac-\/queue.\+h}\item 
wifi/model/\hyperlink{wifi-mac-queue_8cc}{wifi-\/mac-\/queue.\+cc}\end{DoxyCompactItemize}
