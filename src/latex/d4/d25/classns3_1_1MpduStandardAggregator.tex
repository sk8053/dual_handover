\hypertarget{classns3_1_1MpduStandardAggregator}{}\section{ns3\+:\+:Mpdu\+Standard\+Aggregator Class Reference}
\label{classns3_1_1MpduStandardAggregator}\index{ns3\+::\+Mpdu\+Standard\+Aggregator@{ns3\+::\+Mpdu\+Standard\+Aggregator}}


{\ttfamily \#include $<$mpdu-\/standard-\/aggregator.\+h$>$}



Inheritance diagram for ns3\+:\+:Mpdu\+Standard\+Aggregator\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Mpdu\+Standard\+Aggregator\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1MpduStandardAggregator_a01d1669f60722abe9a34cbfd24aff973}{Mpdu\+Standard\+Aggregator} ()
\item 
\hyperlink{classns3_1_1MpduStandardAggregator_ae5bd109aef4b4c3d2e903a9cef9fd4d0}{$\sim$\+Mpdu\+Standard\+Aggregator} ()
\item 
void \hyperlink{classns3_1_1MpduStandardAggregator_aa180c7dbeca04fa473f79e6ca107584d}{Set\+Max\+Ampdu\+Size} (uint32\+\_\+t max\+Size)
\item 
uint32\+\_\+t \hyperlink{classns3_1_1MpduStandardAggregator_adea8b7a94c26a41f893297f59978e4b7}{Get\+Max\+Ampdu\+Size} (void) const 
\item 
bool \hyperlink{classns3_1_1MpduStandardAggregator_ae8df5366479ace23f603e772a32721dc}{Aggregate} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ aggregated\+Packet) const 
\item 
void \hyperlink{classns3_1_1MpduStandardAggregator_a8ae46f2c643b8b39b31c28875db10372}{Aggregate\+Single\+Mpdu} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ aggregated\+Packet) const 
\item 
void \hyperlink{classns3_1_1MpduStandardAggregator_a20f9b233d444b85d4ed22b622dbc3bcd}{Add\+Header\+And\+Pad} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, bool last, bool is\+Single\+Mpdu) const 
\item 
bool \hyperlink{classns3_1_1MpduStandardAggregator_afe782faf74fce1ae60b4e59182eea462}{Can\+Be\+Aggregated} (uint32\+\_\+t packet\+Size, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ aggregated\+Packet, uint8\+\_\+t block\+Ack\+Size) const 
\item 
uint32\+\_\+t \hyperlink{classns3_1_1MpduStandardAggregator_af00b3fee23a51d256dc0c2df6f488a93}{Calculate\+Padding} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet) const 
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1MpduStandardAggregator_aa9dbd223cfe9d70540d867727c59c645}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
uint32\+\_\+t \hyperlink{classns3_1_1MpduStandardAggregator_afe4089ec8e77ce0a35c92803131ffc5f}{m\+\_\+max\+Ampdu\+Length}
\begin{DoxyCompactList}\small\item\em Maximum length in bytes of A-\/\+M\+P\+D\+Us. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Standard M\+P\+DU aggregator 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Mpdu\+Standard\+Aggregator@{ns3\+::\+Mpdu\+Standard\+Aggregator}!Mpdu\+Standard\+Aggregator@{Mpdu\+Standard\+Aggregator}}
\index{Mpdu\+Standard\+Aggregator@{Mpdu\+Standard\+Aggregator}!ns3\+::\+Mpdu\+Standard\+Aggregator@{ns3\+::\+Mpdu\+Standard\+Aggregator}}
\subsubsection[{\texorpdfstring{Mpdu\+Standard\+Aggregator()}{MpduStandardAggregator()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Mpdu\+Standard\+Aggregator\+::\+Mpdu\+Standard\+Aggregator (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1MpduStandardAggregator_a01d1669f60722abe9a34cbfd24aff973}{}\label{classns3_1_1MpduStandardAggregator_a01d1669f60722abe9a34cbfd24aff973}

\begin{DoxyCode}
47 \{
48 \}
\end{DoxyCode}
\index{ns3\+::\+Mpdu\+Standard\+Aggregator@{ns3\+::\+Mpdu\+Standard\+Aggregator}!````~Mpdu\+Standard\+Aggregator@{$\sim$\+Mpdu\+Standard\+Aggregator}}
\index{````~Mpdu\+Standard\+Aggregator@{$\sim$\+Mpdu\+Standard\+Aggregator}!ns3\+::\+Mpdu\+Standard\+Aggregator@{ns3\+::\+Mpdu\+Standard\+Aggregator}}
\subsubsection[{\texorpdfstring{$\sim$\+Mpdu\+Standard\+Aggregator()}{~MpduStandardAggregator()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Mpdu\+Standard\+Aggregator\+::$\sim$\+Mpdu\+Standard\+Aggregator (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1MpduStandardAggregator_ae5bd109aef4b4c3d2e903a9cef9fd4d0}{}\label{classns3_1_1MpduStandardAggregator_ae5bd109aef4b4c3d2e903a9cef9fd4d0}

\begin{DoxyCode}
51 \{
52 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Mpdu\+Standard\+Aggregator@{ns3\+::\+Mpdu\+Standard\+Aggregator}!Add\+Header\+And\+Pad@{Add\+Header\+And\+Pad}}
\index{Add\+Header\+And\+Pad@{Add\+Header\+And\+Pad}!ns3\+::\+Mpdu\+Standard\+Aggregator@{ns3\+::\+Mpdu\+Standard\+Aggregator}}
\subsubsection[{\texorpdfstring{Add\+Header\+And\+Pad(\+Ptr$<$ Packet $>$ packet, bool last, bool is\+Single\+Mpdu) const }{AddHeaderAndPad(Ptr< Packet > packet, bool last, bool isSingleMpdu) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mpdu\+Standard\+Aggregator\+::\+Add\+Header\+And\+Pad (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{bool}]{last, }
\item[{bool}]{is\+Single\+Mpdu}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MpduStandardAggregator_a20f9b233d444b85d4ed22b622dbc3bcd}{}\label{classns3_1_1MpduStandardAggregator_a20f9b233d444b85d4ed22b622dbc3bcd}
Adds A-\/\+M\+P\+DU subframe header and padding to each M\+P\+DU that is part of an A-\/\+M\+P\+DU before it is sent. 

Implements \hyperlink{classns3_1_1MpduAggregator_afdac5a63ad17349e7454d5947938f923}{ns3\+::\+Mpdu\+Aggregator}.


\begin{DoxyCode}
121 \{
122   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
123   AmpduSubframeHeader currentHdr;
124 
125   \textcolor{comment}{//This is called to prepare packets from the aggregate queue to be sent so no need to check total size
       since it has already been}
126   \textcolor{comment}{//done before when deciding how many packets to add to the queue}
127   currentHdr.SetCrc (1);
128   currentHdr.SetSig ();
129   currentHdr.SetLength (packet->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ());
130   \textcolor{keywordflow}{if} (isSingleMpdu)
131     \{
132       currentHdr.SetEof (1);
133     \}
134 
135   packet->\hyperlink{classns3_1_1Packet_a465108c595a0bc592095cbcab1832ed8}{AddHeader} (currentHdr);
136   uint32\_t padding = \hyperlink{classns3_1_1MpduStandardAggregator_af00b3fee23a51d256dc0c2df6f488a93}{CalculatePadding} (packet);
137 
138   \textcolor{keywordflow}{if} (padding && !last)
139     \{
140       Ptr<Packet> pad = Create<Packet> (padding);
141       packet->\hyperlink{classns3_1_1Packet_a14ec3d4250b425468764de58f5837b6b}{AddAtEnd} (pad);
142     \}
143 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Mpdu\+Standard\+Aggregator@{ns3\+::\+Mpdu\+Standard\+Aggregator}!Aggregate@{Aggregate}}
\index{Aggregate@{Aggregate}!ns3\+::\+Mpdu\+Standard\+Aggregator@{ns3\+::\+Mpdu\+Standard\+Aggregator}}
\subsubsection[{\texorpdfstring{Aggregate(\+Ptr$<$ const Packet $>$ packet, Ptr$<$ Packet $>$ aggregated\+Packet) const }{Aggregate(Ptr< const Packet > packet, Ptr< Packet > aggregatedPacket) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Mpdu\+Standard\+Aggregator\+::\+Aggregate (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{packet, }
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{aggregated\+Packet}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MpduStandardAggregator_ae8df5366479ace23f603e772a32721dc}{}\label{classns3_1_1MpduStandardAggregator_ae8df5366479ace23f603e772a32721dc}

\begin{DoxyParams}{Parameters}
{\em packet} & packet we have to insert into {\itshape aggregated\+Packet}. \\
\hline
{\em aggregated\+Packet} & packet that will contain {\itshape packet}, if aggregation is possible.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if {\itshape packet} can be aggregated to {\itshape aggregated\+Packet}, false otherwise.
\end{DoxyReturn}
This method performs an M\+P\+DU aggregation. Returns true if {\itshape packet} can be aggregated to {\itshape aggregated\+Packet}, false otherwise. 

Implements \hyperlink{classns3_1_1MpduAggregator_a8452ad0dca5d5a0fef52991c4f4cf610}{ns3\+::\+Mpdu\+Aggregator}.


\begin{DoxyCode}
68 \{
69   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
70   Ptr<Packet> currentPacket;
71   AmpduSubframeHeader currentHdr;
72 
73   uint32\_t padding = \hyperlink{classns3_1_1MpduStandardAggregator_af00b3fee23a51d256dc0c2df6f488a93}{CalculatePadding} (aggregatedPacket);
74   uint32\_t actualSize = aggregatedPacket->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ();
75 
76   \textcolor{keywordflow}{if} ((4 + packet->GetSize () + actualSize + padding) <= \hyperlink{classns3_1_1MpduStandardAggregator_afe4089ec8e77ce0a35c92803131ffc5f}{m\_maxAmpduLength})
77     \{
78       \textcolor{keywordflow}{if} (padding)
79         \{
80           Ptr<Packet> pad = Create<Packet> (padding);
81           aggregatedPacket->\hyperlink{classns3_1_1Packet_a14ec3d4250b425468764de58f5837b6b}{AddAtEnd} (pad);
82         \}
83       currentHdr.SetCrc (1);
84       currentHdr.SetSig ();
85       currentHdr.SetLength (packet->GetSize ());
86       currentPacket = packet->Copy ();
87 
88       currentPacket->AddHeader (currentHdr);
89       aggregatedPacket->\hyperlink{classns3_1_1Packet_a14ec3d4250b425468764de58f5837b6b}{AddAtEnd} (currentPacket);
90       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
91     \}
92   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
93 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::\+Mpdu\+Standard\+Aggregator@{ns3\+::\+Mpdu\+Standard\+Aggregator}!Aggregate\+Single\+Mpdu@{Aggregate\+Single\+Mpdu}}
\index{Aggregate\+Single\+Mpdu@{Aggregate\+Single\+Mpdu}!ns3\+::\+Mpdu\+Standard\+Aggregator@{ns3\+::\+Mpdu\+Standard\+Aggregator}}
\subsubsection[{\texorpdfstring{Aggregate\+Single\+Mpdu(\+Ptr$<$ const Packet $>$ packet, Ptr$<$ Packet $>$ aggregated\+Packet) const }{AggregateSingleMpdu(Ptr< const Packet > packet, Ptr< Packet > aggregatedPacket) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mpdu\+Standard\+Aggregator\+::\+Aggregate\+Single\+Mpdu (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{packet, }
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{aggregated\+Packet}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MpduStandardAggregator_a8ae46f2c643b8b39b31c28875db10372}{}\label{classns3_1_1MpduStandardAggregator_a8ae46f2c643b8b39b31c28875db10372}
This method performs a V\+H\+T/\+HE single M\+P\+DU aggregation. 

Implements \hyperlink{classns3_1_1MpduAggregator_a41a0e95112386fd7b7e33c1c12dc6bb0}{ns3\+::\+Mpdu\+Aggregator}.


\begin{DoxyCode}
97 \{
98   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
99   Ptr<Packet> currentPacket;
100   AmpduSubframeHeader currentHdr;
101 
102   uint32\_t padding = \hyperlink{classns3_1_1MpduStandardAggregator_af00b3fee23a51d256dc0c2df6f488a93}{CalculatePadding} (aggregatedPacket);
103   \textcolor{keywordflow}{if} (padding)
104     \{
105       Ptr<Packet> pad = Create<Packet> (padding);
106       aggregatedPacket->\hyperlink{classns3_1_1Packet_a14ec3d4250b425468764de58f5837b6b}{AddAtEnd} (pad);
107     \}
108 
109   currentHdr.SetEof (1);
110   currentHdr.SetCrc (1);
111   currentHdr.SetSig ();
112   currentHdr.SetLength (packet->GetSize ());
113   currentPacket = packet->Copy ();
114 
115   currentPacket->AddHeader (currentHdr);
116   aggregatedPacket->\hyperlink{classns3_1_1Packet_a14ec3d4250b425468764de58f5837b6b}{AddAtEnd} (currentPacket);
117 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4


\index{ns3\+::\+Mpdu\+Standard\+Aggregator@{ns3\+::\+Mpdu\+Standard\+Aggregator}!Calculate\+Padding@{Calculate\+Padding}}
\index{Calculate\+Padding@{Calculate\+Padding}!ns3\+::\+Mpdu\+Standard\+Aggregator@{ns3\+::\+Mpdu\+Standard\+Aggregator}}
\subsubsection[{\texorpdfstring{Calculate\+Padding(\+Ptr$<$ const Packet $>$ packet) const }{CalculatePadding(Ptr< const Packet > packet) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Mpdu\+Standard\+Aggregator\+::\+Calculate\+Padding (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{packet}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MpduStandardAggregator_af00b3fee23a51d256dc0c2df6f488a93}{}\label{classns3_1_1MpduStandardAggregator_af00b3fee23a51d256dc0c2df6f488a93}

\begin{DoxyParams}{Parameters}
{\em packet} & the packet \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the padding that must be added to the end of an aggregated packet
\end{DoxyReturn}
Calculates how much padding must be added to the end of an aggregated packet, after that a new packet is added. Each A-\/\+M\+P\+DU subframe is padded so that its length is multiple of 4 octets. 

Implements \hyperlink{classns3_1_1MpduAggregator_aef376d087d3039318f6ae8fa01181879}{ns3\+::\+Mpdu\+Aggregator}.


\begin{DoxyCode}
166 \{
167   \textcolor{keywordflow}{return} (4 - (packet->GetSize () % 4 )) % 4;
168 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Mpdu\+Standard\+Aggregator@{ns3\+::\+Mpdu\+Standard\+Aggregator}!Can\+Be\+Aggregated@{Can\+Be\+Aggregated}}
\index{Can\+Be\+Aggregated@{Can\+Be\+Aggregated}!ns3\+::\+Mpdu\+Standard\+Aggregator@{ns3\+::\+Mpdu\+Standard\+Aggregator}}
\subsubsection[{\texorpdfstring{Can\+Be\+Aggregated(uint32\+\_\+t packet\+Size, Ptr$<$ Packet $>$ aggregated\+Packet, uint8\+\_\+t block\+Ack\+Size) const }{CanBeAggregated(uint32_t packetSize, Ptr< Packet > aggregatedPacket, uint8_t blockAckSize) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Mpdu\+Standard\+Aggregator\+::\+Can\+Be\+Aggregated (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{packet\+Size, }
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{aggregated\+Packet, }
\item[{uint8\+\_\+t}]{block\+Ack\+Size}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MpduStandardAggregator_afe782faf74fce1ae60b4e59182eea462}{}\label{classns3_1_1MpduStandardAggregator_afe782faf74fce1ae60b4e59182eea462}

\begin{DoxyParams}{Parameters}
{\em packet\+Size} & size of the packet we want to insert into {\itshape aggregated\+Packet}. \\
\hline
{\em aggregated\+Packet} & packet that will contain the packet of size {\itshape packet\+Size}, if aggregation is possible. \\
\hline
{\em block\+Ack\+Size} & size of the piggybacked block ack request\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the packet of size {\itshape packet\+Size} can be aggregated to {\itshape aggregated\+Packet}, false otherwise.
\end{DoxyReturn}
This method is used to determine if a packet could be aggregated to an A-\/\+M\+P\+DU without exceeding the maximum packet size. 

Implements \hyperlink{classns3_1_1MpduAggregator_a3b9a3eb957da16bb9e01e619b23df10a}{ns3\+::\+Mpdu\+Aggregator}.


\begin{DoxyCode}
147 \{
148   uint32\_t padding = \hyperlink{classns3_1_1MpduStandardAggregator_af00b3fee23a51d256dc0c2df6f488a93}{CalculatePadding} (aggregatedPacket);
149   uint32\_t actualSize = aggregatedPacket->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ();
150   \textcolor{keywordflow}{if} (blockAckSize > 0)
151     \{
152       blockAckSize = blockAckSize + 4 + padding;
153     \}
154   \textcolor{keywordflow}{if} ((4 + packetSize + actualSize + padding + blockAckSize) <= \hyperlink{classns3_1_1MpduStandardAggregator_afe4089ec8e77ce0a35c92803131ffc5f}{m\_maxAmpduLength})
155     \{
156       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
157     \}
158   \textcolor{keywordflow}{else}
159     \{
160       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
161     \}
162 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6


\index{ns3\+::\+Mpdu\+Standard\+Aggregator@{ns3\+::\+Mpdu\+Standard\+Aggregator}!Get\+Max\+Ampdu\+Size@{Get\+Max\+Ampdu\+Size}}
\index{Get\+Max\+Ampdu\+Size@{Get\+Max\+Ampdu\+Size}!ns3\+::\+Mpdu\+Standard\+Aggregator@{ns3\+::\+Mpdu\+Standard\+Aggregator}}
\subsubsection[{\texorpdfstring{Get\+Max\+Ampdu\+Size(void) const }{GetMaxAmpduSize(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Mpdu\+Standard\+Aggregator\+::\+Get\+Max\+Ampdu\+Size (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MpduStandardAggregator_adea8b7a94c26a41f893297f59978e4b7}{}\label{classns3_1_1MpduStandardAggregator_adea8b7a94c26a41f893297f59978e4b7}
Returns the maximum A-\/\+M\+P\+DU size in bytes. Value 0 means that M\+P\+DU aggregation is disabled.

\begin{DoxyReturn}{Returns}
the maximum A-\/\+M\+P\+DU size in bytes. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1MpduAggregator_a781ed153a388bbc8a5ac231cfd9218c8}{ns3\+::\+Mpdu\+Aggregator}.


\begin{DoxyCode}
62 \{
63   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1MpduStandardAggregator_afe4089ec8e77ce0a35c92803131ffc5f}{m\_maxAmpduLength};
64 \}
\end{DoxyCode}
\index{ns3\+::\+Mpdu\+Standard\+Aggregator@{ns3\+::\+Mpdu\+Standard\+Aggregator}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Mpdu\+Standard\+Aggregator@{ns3\+::\+Mpdu\+Standard\+Aggregator}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Mpdu\+Standard\+Aggregator\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1MpduStandardAggregator_aa9dbd223cfe9d70540d867727c59c645}{}\label{classns3_1_1MpduStandardAggregator_aa9dbd223cfe9d70540d867727c59c645}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
33 \{
34   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::MpduStandardAggregator"})
35     .SetParent<MpduAggregator> ()
36     .SetGroupName (\textcolor{stringliteral}{"Wifi"})
37     .AddConstructor<\hyperlink{classns3_1_1MpduStandardAggregator_a01d1669f60722abe9a34cbfd24aff973}{MpduStandardAggregator}> ()
38     .AddAttribute (\textcolor{stringliteral}{"MaxAmpduSize"}, \textcolor{stringliteral}{"Max length in bytes of an A-MPDU (Deprecated!)"},
39                    UintegerValue (65535),
40                    MakeUintegerAccessor (&
      \hyperlink{classns3_1_1MpduStandardAggregator_afe4089ec8e77ce0a35c92803131ffc5f}{MpduStandardAggregator::m\_maxAmpduLength}),
41                    MakeUintegerChecker<uint32\_t> ())
42   ;
43   \textcolor{keywordflow}{return} tid;
44 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7


\index{ns3\+::\+Mpdu\+Standard\+Aggregator@{ns3\+::\+Mpdu\+Standard\+Aggregator}!Set\+Max\+Ampdu\+Size@{Set\+Max\+Ampdu\+Size}}
\index{Set\+Max\+Ampdu\+Size@{Set\+Max\+Ampdu\+Size}!ns3\+::\+Mpdu\+Standard\+Aggregator@{ns3\+::\+Mpdu\+Standard\+Aggregator}}
\subsubsection[{\texorpdfstring{Set\+Max\+Ampdu\+Size(uint32\+\_\+t max\+Size)}{SetMaxAmpduSize(uint32_t maxSize)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mpdu\+Standard\+Aggregator\+::\+Set\+Max\+Ampdu\+Size (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{max\+Size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MpduStandardAggregator_aa180c7dbeca04fa473f79e6ca107584d}{}\label{classns3_1_1MpduStandardAggregator_aa180c7dbeca04fa473f79e6ca107584d}
Sets the maximum A-\/\+M\+P\+DU size in bytes. Value 0 means that M\+P\+DU aggregation is disabled.


\begin{DoxyParams}{Parameters}
{\em max\+Size} & the maximum A-\/\+M\+P\+DU size in bytes. \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1MpduAggregator_a00344d9ef60b8ad4368769b31761f55d}{ns3\+::\+Mpdu\+Aggregator}.


\begin{DoxyCode}
56 \{
57   \hyperlink{classns3_1_1MpduStandardAggregator_afe4089ec8e77ce0a35c92803131ffc5f}{m\_maxAmpduLength} = maxSize;
58 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{ns3\+::\+Mpdu\+Standard\+Aggregator@{ns3\+::\+Mpdu\+Standard\+Aggregator}!m\+\_\+max\+Ampdu\+Length@{m\+\_\+max\+Ampdu\+Length}}
\index{m\+\_\+max\+Ampdu\+Length@{m\+\_\+max\+Ampdu\+Length}!ns3\+::\+Mpdu\+Standard\+Aggregator@{ns3\+::\+Mpdu\+Standard\+Aggregator}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Ampdu\+Length}{m_maxAmpduLength}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Mpdu\+Standard\+Aggregator\+::m\+\_\+max\+Ampdu\+Length\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MpduStandardAggregator_afe4089ec8e77ce0a35c92803131ffc5f}{}\label{classns3_1_1MpduStandardAggregator_afe4089ec8e77ce0a35c92803131ffc5f}


Maximum length in bytes of A-\/\+M\+P\+D\+Us. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
wifi/model/\hyperlink{mpdu-standard-aggregator_8h}{mpdu-\/standard-\/aggregator.\+h}\item 
wifi/model/\hyperlink{mpdu-standard-aggregator_8cc}{mpdu-\/standard-\/aggregator.\+cc}\end{DoxyCompactItemize}
