\hypertarget{classns3_1_1WaveNetDevice}{}\section{ns3\+:\+:Wave\+Net\+Device Class Reference}
\label{classns3_1_1WaveNetDevice}\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}


{\ttfamily \#include $<$wave-\/net-\/device.\+h$>$}



Inheritance diagram for ns3\+:\+:Wave\+Net\+Device\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Wave\+Net\+Device\+:
% FIG 1
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classns3_1_1Callback}{Callback}$<$ bool, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$, const \hyperlink{classns3_1_1Address}{Address} \&, uint32\+\_\+t, uint32\+\_\+t $>$ \hyperlink{classns3_1_1WaveNetDevice_aa5c0bdf5b0cb42fbd142d42a755321df}{Wave\+Vsa\+Callback}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1WaveNetDevice_afd2c31b5c9c07a08ca8252d32ea506d7}{Wave\+Net\+Device} (void)
\item 
virtual \hyperlink{classns3_1_1WaveNetDevice_a3d882ba56a20256a43908b20137c7811}{$\sim$\+Wave\+Net\+Device} (void)
\item 
void \hyperlink{classns3_1_1WaveNetDevice_a1c2c9c7feb2a647396934f2b538afd1b}{Add\+Mac} (uint32\+\_\+t channel\+Number, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OcbWifiMac}{Ocb\+Wifi\+Mac} $>$ mac)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OcbWifiMac}{Ocb\+Wifi\+Mac} $>$ \hyperlink{classns3_1_1WaveNetDevice_a899f670dd8eb023f0e40f19b536724eb}{Get\+Mac} (uint32\+\_\+t channel\+Number) const 
\item 
std\+::map$<$ uint32\+\_\+t, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OcbWifiMac}{Ocb\+Wifi\+Mac} $>$ $>$ \hyperlink{classns3_1_1WaveNetDevice_a48869fef4b065ccb39d2210a22bbe437}{Get\+Macs} (void) const 
\item 
void \hyperlink{classns3_1_1WaveNetDevice_a067a76c0ee75baca3d269038645780da}{Add\+Phy} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1WifiPhy}{Wifi\+Phy} $>$ phy)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1WifiPhy}{Wifi\+Phy} $>$ \hyperlink{classns3_1_1WaveNetDevice_a28447ac2a7aae3a41f075d6a5741be0c}{Get\+Phy} (uint32\+\_\+t index) const 
\item 
std\+::vector$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1WifiPhy}{Wifi\+Phy} $>$ $>$ \hyperlink{classns3_1_1WaveNetDevice_a8c09cc860910de37d56a759bcea6dffa}{Get\+Phys} (void) const 
\item 
void \hyperlink{classns3_1_1WaveNetDevice_a3aa4f3edcb781fca5306e817315cd31b}{Set\+Channel\+Scheduler} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1ChannelScheduler}{Channel\+Scheduler} $>$ channel\+Scheduler)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1ChannelScheduler}{Channel\+Scheduler} $>$ \hyperlink{classns3_1_1WaveNetDevice_abae0924be9be442fa0b234c82047e368}{Get\+Channel\+Scheduler} (void) const 
\item 
void \hyperlink{classns3_1_1WaveNetDevice_acc72aa6c137e1c78c6e5bc3c19973ef4}{Set\+Channel\+Manager} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1ChannelManager}{Channel\+Manager} $>$ channel\+Manager)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1ChannelManager}{Channel\+Manager} $>$ \hyperlink{classns3_1_1WaveNetDevice_a4c0b3d018ff1ade5c8c9375d9e43f5ad}{Get\+Channel\+Manager} (void) const 
\item 
void \hyperlink{classns3_1_1WaveNetDevice_a0bd0431f70e5ea68ae818650b6ff06d8}{Set\+Channel\+Coordinator} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1ChannelCoordinator}{Channel\+Coordinator} $>$ channel\+Coordinator)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1ChannelCoordinator}{Channel\+Coordinator} $>$ \hyperlink{classns3_1_1WaveNetDevice_af2995fc465c490ae033e98c5beabd7f1}{Get\+Channel\+Coordinator} (void) const 
\item 
void \hyperlink{classns3_1_1WaveNetDevice_a67b70adf83f3029059e45b8f99901b9d}{Set\+Vsa\+Manager} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1VsaManager}{Vsa\+Manager} $>$ vsa\+Manager)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1VsaManager}{Vsa\+Manager} $>$ \hyperlink{classns3_1_1WaveNetDevice_a41e53ba04e34f65d93bbc34f088093db}{Get\+Vsa\+Manager} (void) const 
\item 
bool \hyperlink{classns3_1_1WaveNetDevice_a0d443497d2438fa48ef7ec72be6728fd}{Start\+Sch} (const \hyperlink{structns3_1_1SchInfo}{Sch\+Info} \&sch\+Info)
\item 
bool \hyperlink{classns3_1_1WaveNetDevice_aeaaa53f5a961de1acfd755c69bbab3fb}{Stop\+Sch} (uint32\+\_\+t channel\+Number)
\item 
bool \hyperlink{classns3_1_1WaveNetDevice_adb48d281cd174f232e8c4fc0b642573b}{Start\+Vsa} (const \hyperlink{structns3_1_1VsaInfo}{Vsa\+Info} \&vsa\+Info)
\item 
bool \hyperlink{classns3_1_1WaveNetDevice_a83693f1bee542812b303a76d065ed1b5}{Stop\+Vsa} (uint32\+\_\+t channel\+Number)
\item 
void \hyperlink{classns3_1_1WaveNetDevice_ab728ae9b274726d36112367b59a3906d}{Set\+Wave\+Vsa\+Callback} (\hyperlink{classns3_1_1WaveNetDevice_aa5c0bdf5b0cb42fbd142d42a755321df}{Wave\+Vsa\+Callback} vsa\+Callback)
\item 
bool \hyperlink{classns3_1_1WaveNetDevice_a9c79e073964d5d94bd6bf6facc7aad9b}{Register\+Tx\+Profile} (const \hyperlink{structns3_1_1TxProfile}{Tx\+Profile} \&txprofile)
\item 
bool \hyperlink{classns3_1_1WaveNetDevice_a1bedf1420a065a47bea96590b4004be5}{Delete\+Tx\+Profile} (uint32\+\_\+t channel\+Number)
\item 
bool \hyperlink{classns3_1_1WaveNetDevice_a99ec2b781006c6011a9667e064843b38}{SendX} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, const \hyperlink{classns3_1_1Address}{Address} \&dest, uint32\+\_\+t protocol, const \hyperlink{structns3_1_1TxInfo}{Tx\+Info} \&tx\+Info)
\item 
void \hyperlink{classns3_1_1WaveNetDevice_a15ea0879945399632f422f41cf9e18cc}{Change\+Address} (\hyperlink{classns3_1_1Address}{Address} new\+Address)
\item 
void \hyperlink{classns3_1_1WaveNetDevice_acba936255c24bbfb833b904a80cf5595}{Cancel\+Tx} (uint32\+\_\+t channel\+Number, enum \hyperlink{group__wifi_gab422b4562ba272b39a9b6bca3513f3ac}{Ac\+Index} ac)
\item 
virtual bool \hyperlink{classns3_1_1WaveNetDevice_a21f1928cbc917375a79cb6ed48f4db3e}{Send} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, const \hyperlink{classns3_1_1Address}{Address} \&dest, uint16\+\_\+t protocol\+Number)
\item 
virtual void \hyperlink{classns3_1_1WaveNetDevice_ac6d2149989047dde63c914c1425fb26b}{Set\+If\+Index} (const uint32\+\_\+t index)
\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1WaveNetDevice_a049bbb84ab271ea4663c0f7515132cc0}{Get\+If\+Index} (void) const 
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Channel}{Channel} $>$ \hyperlink{classns3_1_1WaveNetDevice_a887be3c7138671e2fc3e2caff96ce3dc}{Get\+Channel} (void) const 
\item 
virtual void \hyperlink{classns3_1_1WaveNetDevice_af398bddb4768c86bdd1cb37ca1963eca}{Set\+Address} (\hyperlink{classns3_1_1Address}{Address} address)
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1WaveNetDevice_a26fc24872a196373d69b21615514a758}{Get\+Address} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1WaveNetDevice_a382714bf5a869123c1a38f5c4a0c7a06}{Set\+Mtu} (const uint16\+\_\+t mtu)
\item 
virtual uint16\+\_\+t \hyperlink{classns3_1_1WaveNetDevice_a827dd0721ba254bf2112c8f2642f9a23}{Get\+Mtu} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1WaveNetDevice_aad4371d5d6d230831987abb70761d884}{Is\+Link\+Up} (void) const 
\item 
virtual void \hyperlink{classns3_1_1WaveNetDevice_af696e94be87ffb340a674ebc7d2f94ef}{Add\+Link\+Change\+Callback} (\hyperlink{classns3_1_1Callback}{Callback}$<$ void $>$ callback)
\item 
virtual bool \hyperlink{classns3_1_1WaveNetDevice_a55e7c9d97a0180848f54e00183a8c525}{Is\+Broadcast} (void) const 
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1WaveNetDevice_a3c5e95f7277d8171bbf35c874f65bc72}{Get\+Broadcast} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1WaveNetDevice_ace71bad15150f78178e331411b1bc1c3}{Is\+Multicast} (void) const 
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1WaveNetDevice_a8a27d37eafa4779d268682099205f473}{Get\+Multicast} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} multicast\+Group) const 
\begin{DoxyCompactList}\small\item\em Make and return a M\+AC multicast address using the provided multicast group. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1WaveNetDevice_a6eafd8ea02f3cfeb991696a0da0d342b}{Is\+Point\+To\+Point} (void) const 
\begin{DoxyCompactList}\small\item\em Return true if the net device is on a point-\/to-\/point link. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1WaveNetDevice_a2a90f57199efb01997d57a944691f8f1}{Is\+Bridge} (void) const 
\begin{DoxyCompactList}\small\item\em Return true if the net device is acting as a bridge. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1WaveNetDevice_ad3bcbda618cb6c6b9a9ceb7d7cae0924}{Get\+Node} (void) const 
\item 
virtual void \hyperlink{classns3_1_1WaveNetDevice_a064907223dfd3ccead8b187d21b36699}{Set\+Node} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node)
\item 
virtual bool \hyperlink{classns3_1_1WaveNetDevice_afe298fb0f9f6977b5bb0406f915236fa}{Needs\+Arp} (void) const 
\item 
virtual void \hyperlink{classns3_1_1WaveNetDevice_a98a6505182abba177a0ab348356301d8}{Set\+Receive\+Callback} (\hyperlink{classns3_1_1NetDevice_ad5e5e1ca187472bc2ba99575d8def568}{Net\+Device\+::\+Receive\+Callback} cb)
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1WaveNetDevice_a26c4774de7786f9ca29d7e07270770f1}{Get\+Multicast} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} addr) const 
\begin{DoxyCompactList}\small\item\em Get the M\+AC multicast address corresponding to the I\+Pv6 address provided. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1WaveNetDevice_a3d5db01ed8dc819c146734c756227a3c}{Send\+From} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, const \hyperlink{classns3_1_1Address}{Address} \&source, const \hyperlink{classns3_1_1Address}{Address} \&dest, uint16\+\_\+t protocol\+Number)
\item 
virtual void \hyperlink{classns3_1_1WaveNetDevice_a7ebc8fb3b0f840c9f1f62b5de8987cf4}{Set\+Promisc\+Receive\+Callback} (\hyperlink{classns3_1_1NetDevice_a427225795919f26c414bee2ea3f31ed2}{Promisc\+Receive\+Callback} cb)
\item 
virtual bool \hyperlink{classns3_1_1WaveNetDevice_afbb333ee66fb43ea4814e55621cf669f}{Supports\+Send\+From} (void) const 
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1WaveNetDevice_a89ef5e155729b91ccf8c5e057bdb31af}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
typedef std\+::map$<$ uint32\+\_\+t, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OcbWifiMac}{Ocb\+Wifi\+Mac} $>$ $>$ \hyperlink{classns3_1_1WaveNetDevice_aa9993b2c252f7ffb8bf802c8f708359d}{Mac\+Entities}
\begin{DoxyCompactList}\small\item\em Mac\+Entities typedef. \end{DoxyCompactList}\item 
typedef std\+::map$<$ uint32\+\_\+t, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OcbWifiMac}{Ocb\+Wifi\+Mac} $>$ $>$\+::const\+\_\+iterator \hyperlink{classns3_1_1WaveNetDevice_a6511363042ad221a19c4cda0d328e0fc}{Mac\+EntitiesI}
\begin{DoxyCompactList}\small\item\em Mac\+Entities iterator typedef. \end{DoxyCompactList}\item 
typedef std\+::vector$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1WifiPhy}{Wifi\+Phy} $>$ $>$ \hyperlink{classns3_1_1WaveNetDevice_a3f2285fdbb8db9d733db91e55ebd8b43}{Phy\+Entities}
\begin{DoxyCompactList}\small\item\em Phy\+Entities typedef. \end{DoxyCompactList}\item 
typedef std\+::vector$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1WifiPhy}{Wifi\+Phy} $>$ $>$\+::const\+\_\+iterator \hyperlink{classns3_1_1WaveNetDevice_ab7544e360cf30da8b42e84caf14c8e8a}{Phy\+EntitiesI}
\begin{DoxyCompactList}\small\item\em Phy\+Entities iterator typedef. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1WaveNetDevice_aa1d99811f4322194aea16bab5b96d2e6}{Do\+Dispose} (void)
\item 
virtual void \hyperlink{classns3_1_1WaveNetDevice_af81a8cce97f26cfc0bfdad5e13fe4777}{Do\+Initialize} (void)
\item 
bool \hyperlink{classns3_1_1WaveNetDevice_a56b63f50ec806a4a50397aa8ac4d6231}{Is\+Available\+Channel} (uint32\+\_\+t channel\+Number) const 
\item 
void \hyperlink{classns3_1_1WaveNetDevice_aa6dacd06c56a1796db12966008605edb}{Forward\+Up} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} \hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from}, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} to)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1WaveNetDevice_aa9993b2c252f7ffb8bf802c8f708359d}{Mac\+Entities} \hyperlink{classns3_1_1WaveNetDevice_a6db79f07bf41465f7b91dd38ae81f1e8}{m\+\_\+mac\+Entities}
\item 
\hyperlink{classns3_1_1WaveNetDevice_a3f2285fdbb8db9d733db91e55ebd8b43}{Phy\+Entities} \hyperlink{classns3_1_1WaveNetDevice_a60401868abeed63f3218b78c076534a8}{m\+\_\+phy\+Entities}
\begin{DoxyCompactList}\small\item\em Phy entities. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1ChannelManager}{Channel\+Manager} $>$ \hyperlink{classns3_1_1WaveNetDevice_ae9970c62630b78bc09d4d4a16cb55ff8}{m\+\_\+channel\+Manager}
\begin{DoxyCompactList}\small\item\em the channel manager \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1ChannelScheduler}{Channel\+Scheduler} $>$ \hyperlink{classns3_1_1WaveNetDevice_a64edd74de0dc4af431f2d08aad19a9d1}{m\+\_\+channel\+Scheduler}
\begin{DoxyCompactList}\small\item\em the channel scheduler \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1ChannelCoordinator}{Channel\+Coordinator} $>$ \hyperlink{classns3_1_1WaveNetDevice_ab05beb5d2cd120f6b81ab100628c1912}{m\+\_\+channel\+Coordinator}
\begin{DoxyCompactList}\small\item\em the channel coordinator \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1VsaManager}{Vsa\+Manager} $>$ \hyperlink{classns3_1_1WaveNetDevice_a3bec7791c4e2ffc4609e7bf1b75b07b7}{m\+\_\+vsa\+Manager}
\begin{DoxyCompactList}\small\item\em the V\+SA manager \end{DoxyCompactList}\item 
\hyperlink{structns3_1_1TxProfile}{Tx\+Profile} $\ast$ \hyperlink{classns3_1_1WaveNetDevice_ac541d171fef0d8f5c070e305a3e02bca}{m\+\_\+tx\+Profile}
\begin{DoxyCompactList}\small\item\em transmit profile \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Address}{Address}, \hyperlink{classns3_1_1Address}{Address} $>$ \hyperlink{classns3_1_1WaveNetDevice_a9f5269cddc734b4dddff1e96f577a28f}{m\+\_\+address\+Change}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1WaveNetDevice_ac48a992182b2920c3889706e76e78f79}{m\+\_\+node}
\begin{DoxyCompactList}\small\item\em the node \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1NetDevice_ad5e5e1ca187472bc2ba99575d8def568}{Net\+Device\+::\+Receive\+Callback} \hyperlink{classns3_1_1WaveNetDevice_a323fd8350ab01fa9fa0b4a2ec6b32442}{m\+\_\+forward\+Up}
\begin{DoxyCompactList}\small\item\em forward up receive callback \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1NetDevice_a427225795919f26c414bee2ea3f31ed2}{Net\+Device\+::\+Promisc\+Receive\+Callback} \hyperlink{classns3_1_1WaveNetDevice_aa240cecb622b251bbab6177554e9d439}{m\+\_\+promisc\+Rx}
\begin{DoxyCompactList}\small\item\em promiscious receive callback \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1WaveNetDevice_a6b8a6a87173e27fc9bdcbb45e1e395bd}{m\+\_\+if\+Index}
\begin{DoxyCompactList}\small\item\em IF index. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1WaveNetDevice_a203a4cd4350be439a2cb5dd45f02c383}{m\+\_\+mtu}
\begin{DoxyCompactList}\small\item\em M\+TU. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Private Attributes}
\begin{DoxyCompactItemize}
\item 
static const uint16\+\_\+t \hyperlink{classns3_1_1WaveNetDevice_a657b84535129c4bf94fb6720d5052508}{M\+A\+X\+\_\+\+M\+S\+D\+U\+\_\+\+S\+I\+ZE} = 2304
\begin{DoxyCompactList}\small\item\em This value conforms to the 802.\+11 specification. \end{DoxyCompactList}\item 
static const uint16\+\_\+t \hyperlink{classns3_1_1WaveNetDevice_aea82cd6718f17f1d2e585c23e4d76100}{I\+Pv4\+\_\+\+P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER} = 0x0800
\begin{DoxyCompactList}\small\item\em IP v4 Protocol number. \end{DoxyCompactList}\item 
static const uint16\+\_\+t \hyperlink{classns3_1_1WaveNetDevice_a8b18e42ab92375ead7121c02c79e802f}{I\+Pv6\+\_\+\+P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER} = 0x86\+DD
\begin{DoxyCompactList}\small\item\em IP v6 Protocol number. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
This class holds together multiple, \hyperlink{classns3_1_1WifiPhy}{ns3\+::\+Wifi\+Phy}, and \hyperlink{classns3_1_1OcbWifiMac}{ns3\+::\+Ocb\+Wifi\+Mac} (including \hyperlink{classns3_1_1WifiRemoteStationManager}{ns3\+::\+Wifi\+Remote\+Station\+Manager}). Besides that, to support multiple channel operation this class also holds \hyperlink{classns3_1_1ChannelScheduler}{ns3\+::\+Channel\+Scheduler}, \hyperlink{classns3_1_1ChannelManager}{ns3\+::\+Channel\+Manager}, \hyperlink{classns3_1_1ChannelCoordinator}{ns3\+::\+Channel\+Coordinator} and \hyperlink{classns3_1_1VsaManager}{ns3\+::\+Vsa\+Manager}.

these primitives specified in the standard will not be implemented because of limited use in simulation\+: void Start\+Timing\+Advertisement (); void Stop\+Timing\+Advertisement (); Utc\+Time Get\+Utc\+Time (); void Set\+Utc\+Time (); 

\subsection{Member Typedef Documentation}
\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Mac\+Entities@{Mac\+Entities}}
\index{Mac\+Entities@{Mac\+Entities}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Mac\+Entities}{MacEntities}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::map$<$uint32\+\_\+t, {\bf Ptr}$<${\bf Ocb\+Wifi\+Mac}$>$ $>$ {\bf ns3\+::\+Wave\+Net\+Device\+::\+Mac\+Entities}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WaveNetDevice_aa9993b2c252f7ffb8bf802c8f708359d}{}\label{classns3_1_1WaveNetDevice_aa9993b2c252f7ffb8bf802c8f708359d}


Mac\+Entities typedef. 

\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Mac\+EntitiesI@{Mac\+EntitiesI}}
\index{Mac\+EntitiesI@{Mac\+EntitiesI}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Mac\+EntitiesI}{MacEntitiesI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::map$<$uint32\+\_\+t, {\bf Ptr}$<${\bf Ocb\+Wifi\+Mac}$>$ $>$\+::const\+\_\+iterator {\bf ns3\+::\+Wave\+Net\+Device\+::\+Mac\+EntitiesI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WaveNetDevice_a6511363042ad221a19c4cda0d328e0fc}{}\label{classns3_1_1WaveNetDevice_a6511363042ad221a19c4cda0d328e0fc}


Mac\+Entities iterator typedef. 

\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Phy\+Entities@{Phy\+Entities}}
\index{Phy\+Entities@{Phy\+Entities}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Phy\+Entities}{PhyEntities}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::vector$<${\bf Ptr}$<${\bf Wifi\+Phy}$>$ $>$ {\bf ns3\+::\+Wave\+Net\+Device\+::\+Phy\+Entities}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WaveNetDevice_a3f2285fdbb8db9d733db91e55ebd8b43}{}\label{classns3_1_1WaveNetDevice_a3f2285fdbb8db9d733db91e55ebd8b43}


Phy\+Entities typedef. 

\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Phy\+EntitiesI@{Phy\+EntitiesI}}
\index{Phy\+EntitiesI@{Phy\+EntitiesI}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Phy\+EntitiesI}{PhyEntitiesI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::vector$<${\bf Ptr}$<${\bf Wifi\+Phy}$>$ $>$\+::const\+\_\+iterator {\bf ns3\+::\+Wave\+Net\+Device\+::\+Phy\+EntitiesI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WaveNetDevice_ab7544e360cf30da8b42e84caf14c8e8a}{}\label{classns3_1_1WaveNetDevice_ab7544e360cf30da8b42e84caf14c8e8a}


Phy\+Entities iterator typedef. 

\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Wave\+Vsa\+Callback@{Wave\+Vsa\+Callback}}
\index{Wave\+Vsa\+Callback@{Wave\+Vsa\+Callback}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Wave\+Vsa\+Callback}{WaveVsaCallback}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Callback}$<$bool, {\bf Ptr}$<$const {\bf Packet}$>$,const {\bf Address} \&, uint32\+\_\+t, uint32\+\_\+t$>$ {\bf ns3\+::\+Wave\+Net\+Device\+::\+Wave\+Vsa\+Callback}}\hypertarget{classns3_1_1WaveNetDevice_aa5c0bdf5b0cb42fbd142d42a755321df}{}\label{classns3_1_1WaveNetDevice_aa5c0bdf5b0cb42fbd142d42a755321df}

\begin{DoxyParams}{Parameters}
{\em packet} & the packet is Vendor Specific Action frame. \\
\hline
{\em address} & the address of the M\+AC from which the management frame was received. \\
\hline
{\em management\+ID} & identify the originator of the data. Values are specified in I\+E\+EE P1609.\+0 with range 0-\/15. \\
\hline
{\em channel\+Number} & the channel on which the frame was received. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the callback could handle the packet successfully, false otherwise. 
\end{DoxyReturn}


\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Wave\+Net\+Device@{Wave\+Net\+Device}}
\index{Wave\+Net\+Device@{Wave\+Net\+Device}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Wave\+Net\+Device(void)}{WaveNetDevice(void)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Wave\+Net\+Device\+::\+Wave\+Net\+Device (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WaveNetDevice_afd2c31b5c9c07a08ca8252d32ea506d7}{}\label{classns3_1_1WaveNetDevice_afd2c31b5c9c07a08ca8252d32ea506d7}

\begin{DoxyCode}
85   : \hyperlink{classns3_1_1WaveNetDevice_ac541d171fef0d8f5c070e305a3e02bca}{m\_txProfile} (0)
86 \{
87   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
88 \}
\end{DoxyCode}
\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!````~Wave\+Net\+Device@{$\sim$\+Wave\+Net\+Device}}
\index{````~Wave\+Net\+Device@{$\sim$\+Wave\+Net\+Device}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{$\sim$\+Wave\+Net\+Device(void)}{~WaveNetDevice(void)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Wave\+Net\+Device\+::$\sim$\+Wave\+Net\+Device (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WaveNetDevice_a3d882ba56a20256a43908b20137c7811}{}\label{classns3_1_1WaveNetDevice_a3d882ba56a20256a43908b20137c7811}

\begin{DoxyCode}
91 \{
92   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
93 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Add\+Link\+Change\+Callback@{Add\+Link\+Change\+Callback}}
\index{Add\+Link\+Change\+Callback@{Add\+Link\+Change\+Callback}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Add\+Link\+Change\+Callback(\+Callback$<$ void $>$ callback)}{AddLinkChangeCallback(Callback< void > callback)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Wave\+Net\+Device\+::\+Add\+Link\+Change\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Callback}$<$ void $>$}]{callback}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WaveNetDevice_af696e94be87ffb340a674ebc7d2f94ef}{}\label{classns3_1_1WaveNetDevice_af696e94be87ffb340a674ebc7d2f94ef}

\begin{DoxyParams}{Parameters}
{\em callback} & the callback to invoke\\
\hline
\end{DoxyParams}
Add a callback invoked whenever the link status changes to UP. This callback is typically used by the I\+P/\+A\+RP layer to flush the A\+RP cache and by I\+Pv6 stack to flush N\+D\+I\+SC cache whenever the link goes up. 

Implements \hyperlink{classns3_1_1NetDevice_aafb1bf869d38ef7a7112d11fab0163a3}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
557 \{
558   \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"WaveNetDevice is linkup forever, so this callback will be never called"});
559 \}
\end{DoxyCode}
\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Add\+Mac@{Add\+Mac}}
\index{Add\+Mac@{Add\+Mac}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Add\+Mac(uint32\+\_\+t channel\+Number, Ptr$<$ Ocb\+Wifi\+Mac $>$ mac)}{AddMac(uint32_t channelNumber, Ptr< OcbWifiMac > mac)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Wave\+Net\+Device\+::\+Add\+Mac (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{channel\+Number, }
\item[{{\bf Ptr}$<$ {\bf Ocb\+Wifi\+Mac} $>$}]{mac}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WaveNetDevice_a1c2c9c7feb2a647396934f2b538afd1b}{}\label{classns3_1_1WaveNetDevice_a1c2c9c7feb2a647396934f2b538afd1b}

\begin{DoxyParams}{Parameters}
{\em channel\+Number} & the specific channel \\
\hline
{\em mac} & add a new available M\+AC entity for specific channel \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
175 \{
176   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << channelNumber << mac);
177   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1ChannelManager_ae06978b638275c7a37ba6505e2104f92}{ChannelManager::IsWaveChannel} (channelNumber))
178     \{
179       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"The channel "} << channelNumber << \textcolor{stringliteral}{" is not a valid WAVE channel number
      "});
180     \}
181   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1WaveNetDevice_a6db79f07bf41465f7b91dd38ae81f1e8}{m\_macEntities}.find (channelNumber) != \hyperlink{classns3_1_1WaveNetDevice_a6db79f07bf41465f7b91dd38ae81f1e8}{m\_macEntities}.end ())
182     \{
183       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"The MAC entity for channel "} << channelNumber << \textcolor{stringliteral}{" already exists."});
184     \}
185   \hyperlink{classns3_1_1WaveNetDevice_a6db79f07bf41465f7b91dd38ae81f1e8}{m\_macEntities}.insert (std::make\_pair (channelNumber, mac));
186 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2




Here is the caller graph for this function\+:
% FIG 3


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Add\+Phy@{Add\+Phy}}
\index{Add\+Phy@{Add\+Phy}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Add\+Phy(\+Ptr$<$ Wifi\+Phy $>$ phy)}{AddPhy(Ptr< WifiPhy > phy)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Wave\+Net\+Device\+::\+Add\+Phy (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Wifi\+Phy} $>$}]{phy}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WaveNetDevice_a067a76c0ee75baca3d269038645780da}{}\label{classns3_1_1WaveNetDevice_a067a76c0ee75baca3d269038645780da}

\begin{DoxyParams}{Parameters}
{\em phy} & add a new available P\+HY entity \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
208 \{
209   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << phy);
210   \textcolor{keywordflow}{if} (std::find (\hyperlink{classns3_1_1WaveNetDevice_a60401868abeed63f3218b78c076534a8}{m\_phyEntities}.begin (), \hyperlink{classns3_1_1WaveNetDevice_a60401868abeed63f3218b78c076534a8}{m\_phyEntities}.end (), phy) != 
      \hyperlink{classns3_1_1WaveNetDevice_a60401868abeed63f3218b78c076534a8}{m\_phyEntities}.end ())
211     \{
212       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"This PHY entity is already inserted"});
213     \}
214   \hyperlink{classns3_1_1WaveNetDevice_a60401868abeed63f3218b78c076534a8}{m\_phyEntities}.push\_back (phy);
215 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Cancel\+Tx@{Cancel\+Tx}}
\index{Cancel\+Tx@{Cancel\+Tx}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Cancel\+Tx(uint32\+\_\+t channel\+Number, enum Ac\+Index ac)}{CancelTx(uint32_t channelNumber, enum AcIndex ac)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Wave\+Net\+Device\+::\+Cancel\+Tx (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{channel\+Number, }
\item[{enum {\bf Ac\+Index}}]{ac}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WaveNetDevice_acba936255c24bbfb833b904a80cf5595}{}\label{classns3_1_1WaveNetDevice_acba936255c24bbfb833b904a80cf5595}

\begin{DoxyParams}{Parameters}
{\em channel\+Number} & the specific channel number \\
\hline
{\em ac} & the specific access category\\
\hline
\end{DoxyParams}
Cancel all transmissions with the particular category and channel number. 
\begin{DoxyCode}
453 \{
454   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1WaveNetDevice_a56b63f50ec806a4a50397aa8ac4d6231}{IsAvailableChannel} (channelNumber))
455     \{
456       \textcolor{keywordflow}{return};
457     \}
458   Ptr<OcbWifiMac> mac = \hyperlink{classns3_1_1WaveNetDevice_a899f670dd8eb023f0e40f19b536724eb}{GetMac} (channelNumber);
459   mac->CancleTx (ac);
460 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Change\+Address@{Change\+Address}}
\index{Change\+Address@{Change\+Address}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Change\+Address(\+Address new\+Address)}{ChangeAddress(Address newAddress)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Wave\+Net\+Device\+::\+Change\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Address}}]{new\+Address}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WaveNetDevice_a15ea0879945399632f422f41cf9e18cc}{}\label{classns3_1_1WaveNetDevice_a15ea0879945399632f422f41cf9e18cc}

\begin{DoxyParams}{Parameters}
{\em new\+Address} & an immediate M\+A\+C-\/layer address change is required\\
\hline
\end{DoxyParams}
This method is similar with Set\+Address method, but Set\+Address is suggested for initializing a device, while this method is preferred for changing address and a address\+Change \hyperlink{classns3_1_1TracedCallback}{Traced\+Callback} will be called. 
\begin{DoxyCode}
434 \{
435   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << newAddress);
436   Address oldAddress = \hyperlink{classns3_1_1WaveNetDevice_a26fc24872a196373d69b21615514a758}{GetAddress} ();
437   \textcolor{keywordflow}{if} (newAddress == oldAddress)
438     \{
439       \textcolor{keywordflow}{return};
440     \}
441   \hyperlink{classns3_1_1WaveNetDevice_af398bddb4768c86bdd1cb37ca1963eca}{SetAddress} (newAddress);
442   \textcolor{comment}{// Since MAC address is changed, the MAC layer including multiple MAC entities should be reset}
443   \textcolor{comment}{// and internal MAC queues will be flushed.}
444   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1WaveNetDevice_a6511363042ad221a19c4cda0d328e0fc}{MacEntitiesI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1WaveNetDevice_a6db79f07bf41465f7b91dd38ae81f1e8}{m\_macEntities}.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != 
      \hyperlink{classns3_1_1WaveNetDevice_a6db79f07bf41465f7b91dd38ae81f1e8}{m\_macEntities}.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
445     \{
446       \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second->Reset ();
447     \}
448   \hyperlink{classns3_1_1WaveNetDevice_a9f5269cddc734b4dddff1e96f577a28f}{m\_addressChange} (oldAddress, newAddress);
449 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Delete\+Tx\+Profile@{Delete\+Tx\+Profile}}
\index{Delete\+Tx\+Profile@{Delete\+Tx\+Profile}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Delete\+Tx\+Profile(uint32\+\_\+t channel\+Number)}{DeleteTxProfile(uint32_t channelNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Wave\+Net\+Device\+::\+Delete\+Tx\+Profile (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{channel\+Number}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WaveNetDevice_a1bedf1420a065a47bea96590b4004be5}{}\label{classns3_1_1WaveNetDevice_a1bedf1420a065a47bea96590b4004be5}

\begin{DoxyParams}{Parameters}
{\em channel\+Number} & the specific channel number delete a registered transmitter profile in the M\+L\+ME after the associated I\+P-\/based data transfer is complete \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether the tx profile is unregistered successfully 
\end{DoxyReturn}

\begin{DoxyCode}
348 \{
349   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << channelNumber);
350   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1WaveNetDevice_a56b63f50ec806a4a50397aa8ac4d6231}{IsAvailableChannel} (channelNumber))
351     \{
352       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
353     \}
354   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1WaveNetDevice_ac541d171fef0d8f5c070e305a3e02bca}{m\_txProfile} == 0)
355     \{
356       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
357     \}
358   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1WaveNetDevice_ac541d171fef0d8f5c070e305a3e02bca}{m\_txProfile}->\hyperlink{structns3_1_1TxProfile_a6ee2354a51951ca34dfbec1677f6bfa3}{channelNumber} != channelNumber)
359     \{
360       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
361     \}
362 
363   \textcolor{keyword}{delete} \hyperlink{classns3_1_1WaveNetDevice_ac541d171fef0d8f5c070e305a3e02bca}{m\_txProfile};
364   \hyperlink{classns3_1_1WaveNetDevice_ac541d171fef0d8f5c070e305a3e02bca}{m\_txProfile} = 0;
365   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
366 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7




Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Do\+Dispose(void)}{DoDispose(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Wave\+Net\+Device\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1WaveNetDevice_aa1d99811f4322194aea16bab5b96d2e6}{}\label{classns3_1_1WaveNetDevice_aa1d99811f4322194aea16bab5b96d2e6}
Destructor implementation.

This method is called by \hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose()} or by the \hyperlink{classns3_1_1Object}{Object}\textquotesingle{}s destructor, whichever comes first.

Subclasses are expected to implement their real destruction code in an overriden version of this method and chain up to their parent\textquotesingle{}s implementation once they are done. {\itshape i.\+e}, for simplicity, the destructor of every subclass should be empty and its content should be moved to the associated \hyperlink{classns3_1_1WaveNetDevice_aa1d99811f4322194aea16bab5b96d2e6}{Do\+Dispose()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.


\begin{DoxyCode}
97 \{
98   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
99   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1WaveNetDevice_ac541d171fef0d8f5c070e305a3e02bca}{m\_txProfile} != 0)
100     \{
101       \textcolor{keyword}{delete} \hyperlink{classns3_1_1WaveNetDevice_ac541d171fef0d8f5c070e305a3e02bca}{m\_txProfile};
102       \hyperlink{classns3_1_1WaveNetDevice_ac541d171fef0d8f5c070e305a3e02bca}{m\_txProfile} = 0;
103     \}
104   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1WaveNetDevice_ab7544e360cf30da8b42e84caf14c8e8a}{PhyEntitiesI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1WaveNetDevice_a60401868abeed63f3218b78c076534a8}{m\_phyEntities}.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != 
      \hyperlink{classns3_1_1WaveNetDevice_a60401868abeed63f3218b78c076534a8}{m\_phyEntities}.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
105     \{
106       Ptr<WifiPhy> phy = (*i);
107       phy->Dispose ();
108     \}
109   \hyperlink{classns3_1_1WaveNetDevice_a60401868abeed63f3218b78c076534a8}{m\_phyEntities}.clear ();
110   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1WaveNetDevice_a6511363042ad221a19c4cda0d328e0fc}{MacEntitiesI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1WaveNetDevice_a6db79f07bf41465f7b91dd38ae81f1e8}{m\_macEntities}.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != 
      \hyperlink{classns3_1_1WaveNetDevice_a6db79f07bf41465f7b91dd38ae81f1e8}{m\_macEntities}.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
111     \{
112       Ptr<OcbWifiMac> mac = \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second;
113       Ptr<WifiRemoteStationManager> stationManager = mac->GetWifiRemoteStationManager ();
114       stationManager->Dispose ();
115       mac->Dispose ();
116     \}
117   \hyperlink{classns3_1_1WaveNetDevice_a6db79f07bf41465f7b91dd38ae81f1e8}{m\_macEntities}.clear ();
118   \hyperlink{classns3_1_1WaveNetDevice_ab05beb5d2cd120f6b81ab100628c1912}{m\_channelCoordinator}->\hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose} ();
119   \hyperlink{classns3_1_1WaveNetDevice_ae9970c62630b78bc09d4d4a16cb55ff8}{m\_channelManager}->Dispose ();
120   \hyperlink{classns3_1_1WaveNetDevice_a64edd74de0dc4af431f2d08aad19a9d1}{m\_channelScheduler}->Dispose ();
121   \hyperlink{classns3_1_1WaveNetDevice_a3bec7791c4e2ffc4609e7bf1b75b07b7}{m\_vsaManager}->Dispose ();
122   \hyperlink{classns3_1_1WaveNetDevice_ab05beb5d2cd120f6b81ab100628c1912}{m\_channelCoordinator} = 0;
123   \hyperlink{classns3_1_1WaveNetDevice_ae9970c62630b78bc09d4d4a16cb55ff8}{m\_channelManager} = 0;
124   \hyperlink{classns3_1_1WaveNetDevice_a64edd74de0dc4af431f2d08aad19a9d1}{m\_channelScheduler} = 0;
125   \hyperlink{classns3_1_1WaveNetDevice_a3bec7791c4e2ffc4609e7bf1b75b07b7}{m\_vsaManager} = 0;
126   \textcolor{comment}{// chain up.}
127   \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{NetDevice::DoDispose} ();
128 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Do\+Initialize@{Do\+Initialize}}
\index{Do\+Initialize@{Do\+Initialize}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Do\+Initialize(void)}{DoInitialize(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Wave\+Net\+Device\+::\+Do\+Initialize (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1WaveNetDevice_af81a8cce97f26cfc0bfdad5e13fe4777}{}\label{classns3_1_1WaveNetDevice_af81a8cce97f26cfc0bfdad5e13fe4777}
\hyperlink{classns3_1_1Object_af4411cb29971772fcd09203474a95078}{Initialize()} implementation.

This method is called only once by \hyperlink{classns3_1_1Object_af4411cb29971772fcd09203474a95078}{Initialize()}. If the user calls \hyperlink{classns3_1_1Object_af4411cb29971772fcd09203474a95078}{Initialize()} multiple times, \hyperlink{classns3_1_1WaveNetDevice_af81a8cce97f26cfc0bfdad5e13fe4777}{Do\+Initialize()} is called only the first time.

Subclasses are expected to override this method and chain up to their parent\textquotesingle{}s implementation once they are done. It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} and \hyperlink{classns3_1_1Object_a79dd435d300f3deca814553f561a2922}{Aggregate\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_af8482a521433409fb5c7f749398c9dbe}{ns3\+::\+Object}.


\begin{DoxyCode}
132 \{
133   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
134   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1WaveNetDevice_a60401868abeed63f3218b78c076534a8}{m\_phyEntities}.size () == 0)
135     \{
136       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"there is no PHY entity in this WAVE device"});
137     \}
138   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1WaveNetDevice_ab7544e360cf30da8b42e84caf14c8e8a}{PhyEntitiesI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1WaveNetDevice_a60401868abeed63f3218b78c076534a8}{m\_phyEntities}.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != 
      \hyperlink{classns3_1_1WaveNetDevice_a60401868abeed63f3218b78c076534a8}{m\_phyEntities}.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
139     \{
140       Ptr<WifiPhy> phy = (*i);
141       phy->Initialize ();
142     \}
143   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1WaveNetDevice_a6db79f07bf41465f7b91dd38ae81f1e8}{m\_macEntities}.size () == 0)
144     \{
145       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"there is no MAC entity in this WAVE device"});
146     \}
147   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1WaveNetDevice_a6511363042ad221a19c4cda0d328e0fc}{MacEntitiesI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1WaveNetDevice_a6db79f07bf41465f7b91dd38ae81f1e8}{m\_macEntities}.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != 
      \hyperlink{classns3_1_1WaveNetDevice_a6db79f07bf41465f7b91dd38ae81f1e8}{m\_macEntities}.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
148     \{
149       Ptr<OcbWifiMac> mac = \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second;
150       mac->SetForwardUpCallback (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1WaveNetDevice_aa6dacd06c56a1796db12966008605edb}{WaveNetDevice::ForwardUp}, \textcolor{keyword}{this}));
151       \textcolor{comment}{// Make each MAC entity in sleep mode.}
152       mac->Suspend ();
153       mac->Initialize ();
154 
155       Ptr<WifiRemoteStationManager> stationManager = mac->GetWifiRemoteStationManager ();
156       \textcolor{comment}{// Currently PHY is not attached to MAC and will be dynamically attached and unattached to MAC
       latter,}
157       \textcolor{comment}{// however WifiRemoteStationManager in the MAC shall know something  in the PHY such as supported
       data rates.}
158       \textcolor{comment}{// Since these information can be treated as same when same PHY devices are added, here we force}
159       \textcolor{comment}{// all of WifiRemoteStationManagers in multiple MAC entities only associate with single PHY device
       even there may}
160       \textcolor{comment}{// be multiple PHY entities. This approach may be strange but can work fine.}
161       stationManager->SetupPhy (\hyperlink{classns3_1_1WaveNetDevice_a60401868abeed63f3218b78c076534a8}{m\_phyEntities}[0]);
162       stationManager->Initialize ();
163     \}
164   \hyperlink{classns3_1_1WaveNetDevice_a64edd74de0dc4af431f2d08aad19a9d1}{m\_channelScheduler}->SetWaveNetDevice (\textcolor{keyword}{this});
165   \hyperlink{classns3_1_1WaveNetDevice_a3bec7791c4e2ffc4609e7bf1b75b07b7}{m\_vsaManager}->SetWaveNetDevice (\textcolor{keyword}{this});
166   \hyperlink{classns3_1_1WaveNetDevice_a64edd74de0dc4af431f2d08aad19a9d1}{m\_channelScheduler}->Initialize ();
167   \hyperlink{classns3_1_1WaveNetDevice_ab05beb5d2cd120f6b81ab100628c1912}{m\_channelCoordinator}->\hyperlink{classns3_1_1Object_af4411cb29971772fcd09203474a95078}{Initialize} ();
168   \hyperlink{classns3_1_1WaveNetDevice_ae9970c62630b78bc09d4d4a16cb55ff8}{m\_channelManager}->Initialize ();
169   \hyperlink{classns3_1_1WaveNetDevice_a3bec7791c4e2ffc4609e7bf1b75b07b7}{m\_vsaManager}->Initialize ();
170   \hyperlink{classns3_1_1Object_af8482a521433409fb5c7f749398c9dbe}{NetDevice::DoInitialize} ();
171 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Forward\+Up@{Forward\+Up}}
\index{Forward\+Up@{Forward\+Up}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Forward\+Up(\+Ptr$<$ Packet $>$ packet, Mac48\+Address from, Mac48\+Address to)}{ForwardUp(Ptr< Packet > packet, Mac48Address from, Mac48Address to)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Wave\+Net\+Device\+::\+Forward\+Up (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Mac48\+Address}}]{from, }
\item[{{\bf Mac48\+Address}}]{to}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WaveNetDevice_aa6dacd06c56a1796db12966008605edb}{}\label{classns3_1_1WaveNetDevice_aa6dacd06c56a1796db12966008605edb}
Receive a packet from the lower layer and pass the packet up the stack.


\begin{DoxyParams}{Parameters}
{\em packet} & \\
\hline
{\em from} & \\
\hline
{\em to} & \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
678 \{
679   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << \hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from} << to);
680   LlcSnapHeader llc;
681   packet->\hyperlink{classns3_1_1Packet_a0961eccf975d75f902d40956c93ba63e}{RemoveHeader} (llc);
682   \textcolor{keyword}{enum} \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2}{NetDevice::PacketType} \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type};
683   \textcolor{keywordflow}{if} (to.IsBroadcast ())
684     \{
685       type = \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2adfeb6a2929cee183836a32fe293ce205}{NetDevice::PACKET\_BROADCAST};
686     \}
687   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (to.IsGroup ())
688     \{
689       type = \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2ae3ffb88d364e97f06f662f5d7ba53bbe}{NetDevice::PACKET\_MULTICAST};
690     \}
691   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (to == \hyperlink{classns3_1_1WaveNetDevice_a26fc24872a196373d69b21615514a758}{GetAddress} ())
692     \{
693       type = \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2a60835731aced24ac0c712ba61e62462e}{NetDevice::PACKET\_HOST};
694     \}
695   \textcolor{keywordflow}{else}
696     \{
697       type = \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2a60c00fab4286dd2903e2b197a9f8c6c8}{NetDevice::PACKET\_OTHERHOST};
698     \}
699 
700   \textcolor{keywordflow}{if} (type != \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2a60c00fab4286dd2903e2b197a9f8c6c8}{NetDevice::PACKET\_OTHERHOST})
701     \{
702       \textcolor{comment}{// currently we cannot know from which MAC entity the packet is received,}
703       \textcolor{comment}{// so we use the MAC entity for CCH as it receives this packet.}
704       Ptr<OcbWifiMac> mac = \hyperlink{classns3_1_1WaveNetDevice_a899f670dd8eb023f0e40f19b536724eb}{GetMac} (\hyperlink{channel-manager_8h_a52d2f169cde2f6abe66ecc83f0d7ad80}{CCH});
705       mac->NotifyRx (packet);
706       \hyperlink{classns3_1_1WaveNetDevice_a323fd8350ab01fa9fa0b4a2ec6b32442}{m\_forwardUp} (\textcolor{keyword}{this}, packet, llc.GetType (), \hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from});
707     \}
708 
709   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1WaveNetDevice_aa240cecb622b251bbab6177554e9d439}{m\_promiscRx}.\hyperlink{classns3_1_1Callback_aa8e27826badbf37f84763f36f70d9b54}{IsNull} ())
710     \{
711       \textcolor{comment}{// currently we cannot know from which MAC entity the packet is received,}
712       \textcolor{comment}{// so we use the MAC entity for CCH as it receives this packet.}
713       Ptr<OcbWifiMac> mac = \hyperlink{classns3_1_1WaveNetDevice_a899f670dd8eb023f0e40f19b536724eb}{GetMac} (\hyperlink{channel-manager_8h_a52d2f169cde2f6abe66ecc83f0d7ad80}{CCH});
714       mac->NotifyPromiscRx (packet);
715       \hyperlink{classns3_1_1WaveNetDevice_aa240cecb622b251bbab6177554e9d439}{m\_promiscRx} (\textcolor{keyword}{this}, packet, llc.GetType (), \hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from}, to, \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type});
716     \}
717 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 11




Here is the caller graph for this function\+:
% FIG 12


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Get\+Address@{Get\+Address}}
\index{Get\+Address@{Get\+Address}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Address(void) const }{GetAddress(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Wave\+Net\+Device\+::\+Get\+Address (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WaveNetDevice_a26fc24872a196373d69b21615514a758}{}\label{classns3_1_1WaveNetDevice_a26fc24872a196373d69b21615514a758}
\begin{DoxyReturn}{Returns}
the current \hyperlink{classns3_1_1Address}{Address} of this interface. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a671f99de496d6f09ae343bb715301fb2}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
529 \{
530   \textcolor{keywordflow}{return} (\hyperlink{classns3_1_1WaveNetDevice_a899f670dd8eb023f0e40f19b536724eb}{GetMac} (\hyperlink{channel-manager_8h_a52d2f169cde2f6abe66ecc83f0d7ad80}{CCH}))->GetAddress ();
531 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13




Here is the caller graph for this function\+:
% FIG 14


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Get\+Broadcast@{Get\+Broadcast}}
\index{Get\+Broadcast@{Get\+Broadcast}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Broadcast(void) const }{GetBroadcast(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Wave\+Net\+Device\+::\+Get\+Broadcast (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WaveNetDevice_a3c5e95f7277d8171bbf35c874f65bc72}{}\label{classns3_1_1WaveNetDevice_a3c5e95f7277d8171bbf35c874f65bc72}
\begin{DoxyReturn}{Returns}
the broadcast address supported by this netdevice.
\end{DoxyReturn}
Calling this method is invalid if Is\+Broadcast returns not true. 

Implements \hyperlink{classns3_1_1NetDevice_a4724e03bc548dd8e967cc4a7356197bd}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
567 \{
568   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Mac48Address_a55156e302c6bf950c0b558365adbde84}{Mac48Address::GetBroadcast} ();
569 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 15


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Get\+Channel@{Get\+Channel}}
\index{Get\+Channel@{Get\+Channel}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Channel(void) const }{GetChannel(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Channel} $>$ ns3\+::\+Wave\+Net\+Device\+::\+Get\+Channel (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WaveNetDevice_a887be3c7138671e2fc3e2caff96ce3dc}{}\label{classns3_1_1WaveNetDevice_a887be3c7138671e2fc3e2caff96ce3dc}
\begin{DoxyReturn}{Returns}
the channel this \hyperlink{classns3_1_1NetDevice}{Net\+Device} is connected to. The value returned can be zero if the \hyperlink{classns3_1_1NetDevice}{Net\+Device} is not yet connected to any channel or if the underlying \hyperlink{classns3_1_1NetDevice}{Net\+Device} has no concept of a channel. i.\+e., callers {\itshape must} check for zero and be ready to handle it. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a3d810bd2738634e2e851661271828565}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
515 \{
516   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (!\hyperlink{classns3_1_1WaveNetDevice_a60401868abeed63f3218b78c076534a8}{m\_phyEntities}.empty ());
517   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1WaveNetDevice_a28447ac2a7aae3a41f075d6a5741be0c}{GetPhy} (0)->\hyperlink{classns3_1_1WifiPhy_afa06077425565033505674c1b122c2e8}{GetChannel} ();
518 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 16




Here is the caller graph for this function\+:
% FIG 17


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Get\+Channel\+Coordinator@{Get\+Channel\+Coordinator}}
\index{Get\+Channel\+Coordinator@{Get\+Channel\+Coordinator}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Channel\+Coordinator(void) const }{GetChannelCoordinator(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Channel\+Coordinator} $>$ ns3\+::\+Wave\+Net\+Device\+::\+Get\+Channel\+Coordinator (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1WaveNetDevice_af2995fc465c490ae033e98c5beabd7f1}{}\label{classns3_1_1WaveNetDevice_af2995fc465c490ae033e98c5beabd7f1}
\begin{DoxyReturn}{Returns}
current channel coordinator for multiple channel operation 
\end{DoxyReturn}

\begin{DoxyCode}
489 \{
490   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1WaveNetDevice_ab05beb5d2cd120f6b81ab100628c1912}{m\_channelCoordinator};
491 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 18


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Get\+Channel\+Manager@{Get\+Channel\+Manager}}
\index{Get\+Channel\+Manager@{Get\+Channel\+Manager}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Channel\+Manager(void) const }{GetChannelManager(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Channel\+Manager} $>$ ns3\+::\+Wave\+Net\+Device\+::\+Get\+Channel\+Manager (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1WaveNetDevice_a4c0b3d018ff1ade5c8c9375d9e43f5ad}{}\label{classns3_1_1WaveNetDevice_a4c0b3d018ff1ade5c8c9375d9e43f5ad}
\begin{DoxyReturn}{Returns}
currentc channel manager for multiple channel operation 
\end{DoxyReturn}

\begin{DoxyCode}
469 \{
470   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1WaveNetDevice_ae9970c62630b78bc09d4d4a16cb55ff8}{m\_channelManager};
471 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 19


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Get\+Channel\+Scheduler@{Get\+Channel\+Scheduler}}
\index{Get\+Channel\+Scheduler@{Get\+Channel\+Scheduler}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Channel\+Scheduler(void) const }{GetChannelScheduler(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Channel\+Scheduler} $>$ ns3\+::\+Wave\+Net\+Device\+::\+Get\+Channel\+Scheduler (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1WaveNetDevice_abae0924be9be442fa0b234c82047e368}{}\label{classns3_1_1WaveNetDevice_abae0924be9be442fa0b234c82047e368}
\begin{DoxyReturn}{Returns}
current channel scheduler for multiple channel operation 
\end{DoxyReturn}

\begin{DoxyCode}
479 \{
480   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1WaveNetDevice_a64edd74de0dc4af431f2d08aad19a9d1}{m\_channelScheduler};
481 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 20


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Get\+If\+Index@{Get\+If\+Index}}
\index{Get\+If\+Index@{Get\+If\+Index}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+If\+Index(void) const }{GetIfIndex(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Wave\+Net\+Device\+::\+Get\+If\+Index (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WaveNetDevice_a049bbb84ab271ea4663c0f7515132cc0}{}\label{classns3_1_1WaveNetDevice_a049bbb84ab271ea4663c0f7515132cc0}
\begin{DoxyReturn}{Returns}
index if\+Index of the device 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a8c1ae2ec8eadc4524dfc1e425bfa0850}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
510 \{
511   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1WaveNetDevice_a6b8a6a87173e27fc9bdcbb45e1e395bd}{m\_ifIndex};
512 \}
\end{DoxyCode}
\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Get\+Mac@{Get\+Mac}}
\index{Get\+Mac@{Get\+Mac}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Mac(uint32\+\_\+t channel\+Number) const }{GetMac(uint32_t channelNumber) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ocb\+Wifi\+Mac} $>$ ns3\+::\+Wave\+Net\+Device\+::\+Get\+Mac (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{channel\+Number}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1WaveNetDevice_a899f670dd8eb023f0e40f19b536724eb}{}\label{classns3_1_1WaveNetDevice_a899f670dd8eb023f0e40f19b536724eb}

\begin{DoxyParams}{Parameters}
{\em channel\+Number} & the specific channel number \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
corresponding M\+AC entity 
\end{DoxyReturn}

\begin{DoxyCode}
189 \{
190   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << channelNumber);
191   \hyperlink{classns3_1_1WaveNetDevice_a6511363042ad221a19c4cda0d328e0fc}{MacEntitiesI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1WaveNetDevice_a6db79f07bf41465f7b91dd38ae81f1e8}{m\_macEntities}.find (channelNumber);
192   \textcolor{keywordflow}{if} (i == \hyperlink{classns3_1_1WaveNetDevice_a6db79f07bf41465f7b91dd38ae81f1e8}{m\_macEntities}.end ())
193     \{
194       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"there is no available MAC entity for channel "} << channelNumber);
195     \}
196   \textcolor{keywordflow}{return} i->second;
197 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 21


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Get\+Macs@{Get\+Macs}}
\index{Get\+Macs@{Get\+Macs}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Macs(void) const }{GetMacs(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<$ uint32\+\_\+t, {\bf Ptr}$<$ {\bf Ocb\+Wifi\+Mac} $>$ $>$ ns3\+::\+Wave\+Net\+Device\+::\+Get\+Macs (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1WaveNetDevice_a48869fef4b065ccb39d2210a22bbe437}{}\label{classns3_1_1WaveNetDevice_a48869fef4b065ccb39d2210a22bbe437}
\begin{DoxyReturn}{Returns}
all inserted M\+AC entities. 
\end{DoxyReturn}

\begin{DoxyCode}
201 \{
202   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
203   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1WaveNetDevice_a6db79f07bf41465f7b91dd38ae81f1e8}{m\_macEntities};
204 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 22


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Get\+Mtu@{Get\+Mtu}}
\index{Get\+Mtu@{Get\+Mtu}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Mtu(void) const }{GetMtu(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Wave\+Net\+Device\+::\+Get\+Mtu (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WaveNetDevice_a827dd0721ba254bf2112c8f2642f9a23}{}\label{classns3_1_1WaveNetDevice_a827dd0721ba254bf2112c8f2642f9a23}
\begin{DoxyReturn}{Returns}
the link-\/level M\+TU in bytes for this interface.
\end{DoxyReturn}
This value is typically used by the IP layer to perform IP fragmentation when needed. 

Implements \hyperlink{classns3_1_1NetDevice_a91f4f5d01bc2d567c1e0a69b63a4cf14}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
544 \{
545   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1WaveNetDevice_a203a4cd4350be439a2cb5dd45f02c383}{m\_mtu};
546 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 23


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Get\+Multicast@{Get\+Multicast}}
\index{Get\+Multicast@{Get\+Multicast}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Multicast(\+Ipv4\+Address multicast\+Group) const }{GetMulticast(Ipv4Address multicastGroup) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Wave\+Net\+Device\+::\+Get\+Multicast (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{multicast\+Group}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WaveNetDevice_a8a27d37eafa4779d268682099205f473}{}\label{classns3_1_1WaveNetDevice_a8a27d37eafa4779d268682099205f473}


Make and return a M\+AC multicast address using the provided multicast group. 

\{1112\} says that an \hyperlink{classns3_1_1Ipv4}{Ipv4} host group address is mapped to an Ethernet multicast address by placing the low-\/order 23-\/bits of the IP address into the low-\/order 23 bits of the Ethernet multicast address 01-\/00-\/5\+E-\/00-\/00-\/00 (hex). Similar R\+F\+Cs exist for \hyperlink{classns3_1_1Ipv6}{Ipv6} and Eui64 mappings. This method performs the multicast address creation function appropriate to the underlying M\+AC address of the device. This M\+AC address is encapsulated in an abstract \hyperlink{classns3_1_1Address}{Address} to avoid dependencies on the exact M\+AC address format.

In the case of net devices that do not support multicast, clients are expected to test \hyperlink{classns3_1_1NetDevice_a1afb4848a9226540f1ff51f9b31ae95e}{Net\+Device\+::\+Is\+Multicast} and avoid attempting to map multicast packets. Subclasses of \hyperlink{classns3_1_1NetDevice}{Net\+Device} that do support multicasting are expected to override this method and provide an implementation appropriate to the particular device.


\begin{DoxyParams}{Parameters}
{\em multicast\+Group} & The IP address for the multicast group destination of the packet. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The M\+AC multicast \hyperlink{classns3_1_1Address}{Address} used to send packets to the provided multicast group.
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Calling this method is invalid if Is\+Multicast returns not true. 
\end{DoxyWarning}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1WaveNetDevice_ace71bad15150f78178e331411b1bc1c3}{Is\+Multicast()} 
\end{DoxySeeAlso}


Implements \hyperlink{classns3_1_1NetDevice_a98aa4852df367b6a393c8cc1d88af0d9}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
577 \{
578   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Mac48Address_a23d170f8c7a7d90a8110425620285819}{Mac48Address::GetMulticast} (multicastGroup);
579 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 24


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Get\+Multicast@{Get\+Multicast}}
\index{Get\+Multicast@{Get\+Multicast}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Multicast(\+Ipv6\+Address addr) const }{GetMulticast(Ipv6Address addr) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Wave\+Net\+Device\+::\+Get\+Multicast (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{addr}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WaveNetDevice_a26c4774de7786f9ca29d7e07270770f1}{}\label{classns3_1_1WaveNetDevice_a26c4774de7786f9ca29d7e07270770f1}


Get the M\+AC multicast address corresponding to the I\+Pv6 address provided. 


\begin{DoxyParams}{Parameters}
{\em addr} & I\+Pv6 address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the M\+AC multicast address 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Calling this method is invalid if Is\+Multicast returns not true. 
\end{DoxyWarning}


Implements \hyperlink{classns3_1_1NetDevice_a46479a2c0101c6f9da9251ed4d7575bd}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
581 \{
582   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Mac48Address_a23d170f8c7a7d90a8110425620285819}{Mac48Address::GetMulticast} (addr);
583 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 25


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Get\+Node@{Get\+Node}}
\index{Get\+Node@{Get\+Node}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Node(void) const }{GetNode(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Node} $>$ ns3\+::\+Wave\+Net\+Device\+::\+Get\+Node (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WaveNetDevice_ad3bcbda618cb6c6b9a9ceb7d7cae0924}{}\label{classns3_1_1WaveNetDevice_ad3bcbda618cb6c6b9a9ceb7d7cae0924}
\begin{DoxyReturn}{Returns}
the node base class which contains this network interface.
\end{DoxyReturn}
When a subclass needs to get access to the underlying node base class to print the nodeid for example, it can invoke this method. 

Implements \hyperlink{classns3_1_1NetDevice_a098b6cc4339ac00c62e75cfa48c8aeac}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
638 \{
639   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1WaveNetDevice_ac48a992182b2920c3889706e76e78f79}{m\_node};
640 \}
\end{DoxyCode}
\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Get\+Phy@{Get\+Phy}}
\index{Get\+Phy@{Get\+Phy}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Phy(uint32\+\_\+t index) const }{GetPhy(uint32_t index) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Wifi\+Phy} $>$ ns3\+::\+Wave\+Net\+Device\+::\+Get\+Phy (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{index}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1WaveNetDevice_a28447ac2a7aae3a41f075d6a5741be0c}{}\label{classns3_1_1WaveNetDevice_a28447ac2a7aae3a41f075d6a5741be0c}

\begin{DoxyParams}{Parameters}
{\em index} & the index of P\+HY entity \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
corresponding P\+HY entity 
\end{DoxyReturn}

\begin{DoxyCode}
218 \{
219   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << index);
220   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1WaveNetDevice_a60401868abeed63f3218b78c076534a8}{m\_phyEntities}.at (index);
221 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 26


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Get\+Phys@{Get\+Phys}}
\index{Get\+Phys@{Get\+Phys}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Phys(void) const }{GetPhys(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<$ {\bf Ptr}$<$ {\bf Wifi\+Phy} $>$ $>$ ns3\+::\+Wave\+Net\+Device\+::\+Get\+Phys (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1WaveNetDevice_a8c09cc860910de37d56a759bcea6dffa}{}\label{classns3_1_1WaveNetDevice_a8c09cc860910de37d56a759bcea6dffa}
\begin{DoxyReturn}{Returns}
all inserted P\+HY entities. 
\end{DoxyReturn}

\begin{DoxyCode}
225 \{
226   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
227   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1WaveNetDevice_a60401868abeed63f3218b78c076534a8}{m\_phyEntities};
228 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 27


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Wave\+Net\+Device\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1WaveNetDevice_a89ef5e155729b91ccf8c5e057bdb31af}{}\label{classns3_1_1WaveNetDevice_a89ef5e155729b91ccf8c5e057bdb31af}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
38 \{
39   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::WaveNetDevice"})
40     .SetParent<NetDevice> ()
41     .SetGroupName (\textcolor{stringliteral}{"Wave"})
42     .AddConstructor<\hyperlink{classns3_1_1WaveNetDevice_afd2c31b5c9c07a08ca8252d32ea506d7}{WaveNetDevice}> ()
43     .AddAttribute (\textcolor{stringliteral}{"Mtu"}, \textcolor{stringliteral}{"The MAC-level Maximum Transmission Unit"},
44                    UintegerValue (\hyperlink{classns3_1_1WaveNetDevice_a657b84535129c4bf94fb6720d5052508}{MAX\_MSDU\_SIZE} - 
      \hyperlink{namespacens3_af8522e22bcdefd901bcf12e260491ec8}{LLC\_SNAP\_HEADER\_LENGTH}),
45                    MakeUintegerAccessor (&\hyperlink{classns3_1_1WaveNetDevice_a382714bf5a869123c1a38f5c4a0c7a06}{WaveNetDevice::SetMtu},
46                                          &\hyperlink{classns3_1_1WaveNetDevice_a827dd0721ba254bf2112c8f2642f9a23}{WaveNetDevice::GetMtu}),
47                    MakeUintegerChecker<uint16\_t> (1,\hyperlink{classns3_1_1WaveNetDevice_a657b84535129c4bf94fb6720d5052508}{MAX\_MSDU\_SIZE} - 
      \hyperlink{namespacens3_af8522e22bcdefd901bcf12e260491ec8}{LLC\_SNAP\_HEADER\_LENGTH}))
48     .AddAttribute (\textcolor{stringliteral}{"Channel"}, \textcolor{stringliteral}{"The channel attached to this device"},
49                    PointerValue (),
50                    MakePointerAccessor (&\hyperlink{classns3_1_1WaveNetDevice_a887be3c7138671e2fc3e2caff96ce3dc}{WaveNetDevice::GetChannel}),
51                    MakePointerChecker<Channel> ())
52     .AddAttribute (\textcolor{stringliteral}{"PhyEntities"}, \textcolor{stringliteral}{"The PHY entities attached to this device."},
53                    \hyperlink{namespacens3_a5de726d8bcea7a51fd68ce5167a66713}{ObjectVectorValue} (),
54                    \hyperlink{namespacens3_a6ad5b3621a5dc72b7030cbb07c73adf6}{MakeObjectVectorAccessor} (&
      \hyperlink{classns3_1_1WaveNetDevice_a60401868abeed63f3218b78c076534a8}{WaveNetDevice::m\_phyEntities}),
55                    MakeObjectVectorChecker<WifiPhy> ())
56     .AddAttribute (\textcolor{stringliteral}{"MacEntities"}, \textcolor{stringliteral}{"The MAC layer attached to this device."},
57                    \hyperlink{namespacens3_a5cac680c954929d49b48f4c40c1a2e08}{ObjectMapValue} (),
58                    \hyperlink{namespacens3_acfdf708e388c66beea68eb5ecdcb7456}{MakeObjectMapAccessor} (&
      \hyperlink{classns3_1_1WaveNetDevice_a6db79f07bf41465f7b91dd38ae81f1e8}{WaveNetDevice::m\_macEntities}),
59                    MakeObjectMapChecker<OcbWifiMac> ())
60     .AddAttribute (\textcolor{stringliteral}{"ChannelScheduler"}, \textcolor{stringliteral}{"The channel scheduler attached to this device."},
61                    PointerValue (),
62                    MakePointerAccessor (&\hyperlink{classns3_1_1WaveNetDevice_a3aa4f3edcb781fca5306e817315cd31b}{WaveNetDevice::SetChannelScheduler}
      ,
63                                         &\hyperlink{classns3_1_1WaveNetDevice_abae0924be9be442fa0b234c82047e368}{WaveNetDevice::GetChannelScheduler}
      ),
64                    MakePointerChecker<ChannelScheduler> ())
65     .AddAttribute (\textcolor{stringliteral}{"ChannelManager"}, \textcolor{stringliteral}{"The channel manager attached to this device."},
66                    PointerValue (),
67                    MakePointerAccessor (&\hyperlink{classns3_1_1WaveNetDevice_acc72aa6c137e1c78c6e5bc3c19973ef4}{WaveNetDevice::SetChannelManager},
68                                         &\hyperlink{classns3_1_1WaveNetDevice_a4c0b3d018ff1ade5c8c9375d9e43f5ad}{WaveNetDevice::GetChannelManager}),
69                    MakePointerChecker<ChannelManager> ())
70     .AddAttribute (\textcolor{stringliteral}{"ChannelCoordinator"}, \textcolor{stringliteral}{"The channel coordinator attached to this device."},
71                    PointerValue (),
72                    MakePointerAccessor (&\hyperlink{classns3_1_1WaveNetDevice_a0bd0431f70e5ea68ae818650b6ff06d8}{WaveNetDevice::SetChannelCoordinator}
      ,
73                                         &\hyperlink{classns3_1_1WaveNetDevice_af2995fc465c490ae033e98c5beabd7f1}{WaveNetDevice::GetChannelCoordinator}
      ),
74                    MakePointerChecker<ChannelCoordinator> ())
75     .AddAttribute (\textcolor{stringliteral}{"VsaManager"}, \textcolor{stringliteral}{"The VSA manager attached to this device."},
76                    PointerValue (),
77                    MakePointerAccessor (&\hyperlink{classns3_1_1WaveNetDevice_a67b70adf83f3029059e45b8f99901b9d}{WaveNetDevice::SetVsaManager},
78                                         &\hyperlink{classns3_1_1WaveNetDevice_a41e53ba04e34f65d93bbc34f088093db}{WaveNetDevice::GetVsaManager}),
79                    MakePointerChecker<VsaManager> ())
80   ;
81   \textcolor{keywordflow}{return} tid;
82 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 28


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Get\+Vsa\+Manager@{Get\+Vsa\+Manager}}
\index{Get\+Vsa\+Manager@{Get\+Vsa\+Manager}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Vsa\+Manager(void) const }{GetVsaManager(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Vsa\+Manager} $>$ ns3\+::\+Wave\+Net\+Device\+::\+Get\+Vsa\+Manager (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1WaveNetDevice_a41e53ba04e34f65d93bbc34f088093db}{}\label{classns3_1_1WaveNetDevice_a41e53ba04e34f65d93bbc34f088093db}
\begin{DoxyReturn}{Returns}
current V\+SA manager for multiple channel operation 
\end{DoxyReturn}

\begin{DoxyCode}
499 \{
500   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1WaveNetDevice_a3bec7791c4e2ffc4609e7bf1b75b07b7}{m\_vsaManager};
501 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 29


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Is\+Available\+Channel@{Is\+Available\+Channel}}
\index{Is\+Available\+Channel@{Is\+Available\+Channel}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Available\+Channel(uint32\+\_\+t channel\+Number) const }{IsAvailableChannel(uint32_t channelNumber) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Wave\+Net\+Device\+::\+Is\+Available\+Channel (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{channel\+Number}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WaveNetDevice_a56b63f50ec806a4a50397aa8ac4d6231}{}\label{classns3_1_1WaveNetDevice_a56b63f50ec806a4a50397aa8ac4d6231}

\begin{DoxyParams}{Parameters}
{\em channel\+Number} & the specific channel \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether this channel is valid and available for use 
\end{DoxyReturn}

\begin{DoxyCode}
662 \{
663   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1ChannelManager_ae06978b638275c7a37ba6505e2104f92}{ChannelManager::IsWaveChannel} (channelNumber))
664     \{
665       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"this is no a valid WAVE channel for channel "} << channelNumber);
666       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
667     \}
668   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1WaveNetDevice_a6db79f07bf41465f7b91dd38ae81f1e8}{m\_macEntities}.find (channelNumber) == \hyperlink{classns3_1_1WaveNetDevice_a6db79f07bf41465f7b91dd38ae81f1e8}{m\_macEntities}.end ())
669     \{
670       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"this is no available WAVE entity  for channel "} << channelNumber);
671       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
672     \}
673   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
674 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 30




Here is the caller graph for this function\+:
% FIG 31


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Is\+Bridge@{Is\+Bridge}}
\index{Is\+Bridge@{Is\+Bridge}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Bridge(void) const }{IsBridge(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Wave\+Net\+Device\+::\+Is\+Bridge (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WaveNetDevice_a2a90f57199efb01997d57a944691f8f1}{}\label{classns3_1_1WaveNetDevice_a2a90f57199efb01997d57a944691f8f1}


Return true if the net device is acting as a bridge. 

\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Bridge flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a9d34556a1c83a69dacb08698ca4a1d94}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
591 \{
592   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
593 \}
\end{DoxyCode}
\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Is\+Broadcast@{Is\+Broadcast}}
\index{Is\+Broadcast@{Is\+Broadcast}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Broadcast(void) const }{IsBroadcast(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Wave\+Net\+Device\+::\+Is\+Broadcast (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WaveNetDevice_a55e7c9d97a0180848f54e00183a8c525}{}\label{classns3_1_1WaveNetDevice_a55e7c9d97a0180848f54e00183a8c525}
\begin{DoxyReturn}{Returns}
true if this interface supports a broadcast address, false otherwise. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a67f992b20858cd7b397d8fba2feff141}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
562 \{
563   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
564 \}
\end{DoxyCode}
\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Is\+Link\+Up@{Is\+Link\+Up}}
\index{Is\+Link\+Up@{Is\+Link\+Up}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Link\+Up(void) const }{IsLinkUp(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Wave\+Net\+Device\+::\+Is\+Link\+Up (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WaveNetDevice_aad4371d5d6d230831987abb70761d884}{}\label{classns3_1_1WaveNetDevice_aad4371d5d6d230831987abb70761d884}
\begin{DoxyReturn}{Returns}
true if link is up; false otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_afe1822b79e19a05ab95f693c8fb64fc7}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
549 \{
550   \textcolor{comment}{// Different from WifiNetDevice::IsLinkUp, a WaveNetDevice device}
551   \textcolor{comment}{// is always link up so the m\_linkup variable is true forever.}
552   \textcolor{comment}{// Even the device is in channel switch state, packets can still be queued.}
553   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
554 \}
\end{DoxyCode}
\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Is\+Multicast@{Is\+Multicast}}
\index{Is\+Multicast@{Is\+Multicast}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Multicast(void) const }{IsMulticast(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Wave\+Net\+Device\+::\+Is\+Multicast (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WaveNetDevice_ace71bad15150f78178e331411b1bc1c3}{}\label{classns3_1_1WaveNetDevice_ace71bad15150f78178e331411b1bc1c3}
\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Multicast flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a1afb4848a9226540f1ff51f9b31ae95e}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
572 \{
573   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
574 \}
\end{DoxyCode}
\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Is\+Point\+To\+Point@{Is\+Point\+To\+Point}}
\index{Is\+Point\+To\+Point@{Is\+Point\+To\+Point}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Point\+To\+Point(void) const }{IsPointToPoint(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Wave\+Net\+Device\+::\+Is\+Point\+To\+Point (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WaveNetDevice_a6eafd8ea02f3cfeb991696a0da0d342b}{}\label{classns3_1_1WaveNetDevice_a6eafd8ea02f3cfeb991696a0da0d342b}


Return true if the net device is on a point-\/to-\/point link. 

\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Point\+To\+Point flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a718177f25efeaf2dbf8a18fcab87224d}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
586 \{
587   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
588 \}
\end{DoxyCode}
\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Needs\+Arp@{Needs\+Arp}}
\index{Needs\+Arp@{Needs\+Arp}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Needs\+Arp(void) const }{NeedsArp(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Wave\+Net\+Device\+::\+Needs\+Arp (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WaveNetDevice_afe298fb0f9f6977b5bb0406f915236fa}{}\label{classns3_1_1WaveNetDevice_afe298fb0f9f6977b5bb0406f915236fa}
\begin{DoxyReturn}{Returns}
true if A\+RP is needed, false otherwise.
\end{DoxyReturn}
Called by higher-\/layers to check if this \hyperlink{classns3_1_1NetDevice}{Net\+Device} requires A\+RP to be used. 

Implements \hyperlink{classns3_1_1NetDevice_ab1a133696310cad3dc2c3d1a4993f310}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
648 \{
649   \textcolor{comment}{// Whether NeedsArp or not?}
650   \textcolor{comment}{// For IP-based packets , yes; For WSMP packets, no;}
651   \textcolor{comment}{// so return true always.}
652   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
653 \}
\end{DoxyCode}
\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Register\+Tx\+Profile@{Register\+Tx\+Profile}}
\index{Register\+Tx\+Profile@{Register\+Tx\+Profile}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Register\+Tx\+Profile(const Tx\+Profile \&txprofile)}{RegisterTxProfile(const TxProfile &txprofile)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Wave\+Net\+Device\+::\+Register\+Tx\+Profile (
\begin{DoxyParamCaption}
\item[{const {\bf Tx\+Profile} \&}]{txprofile}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WaveNetDevice_a9c79e073964d5d94bd6bf6facc7aad9b}{}\label{classns3_1_1WaveNetDevice_a9c79e073964d5d94bd6bf6facc7aad9b}

\begin{DoxyParams}{Parameters}
{\em txprofile} & transmit profile for I\+P-\/based data register a transmitter profile in the M\+L\+ME before the associated I\+P-\/based data transfer starts. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether the tx profile is registered successfully
\end{DoxyReturn}
note\+: This method should be called before \hyperlink{classns3_1_1WaveNetDevice_a21f1928cbc917375a79cb6ed48f4db3e}{Wave\+Net\+Device\+::\+Send} method 
\begin{DoxyCode}
303 \{
304   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << &txprofile);
305   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1WaveNetDevice_ac541d171fef0d8f5c070e305a3e02bca}{m\_txProfile} != 0)
306     \{
307       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
308     \}
309   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1WaveNetDevice_a56b63f50ec806a4a50397aa8ac4d6231}{IsAvailableChannel} (txprofile.channelNumber))
310     \{
311       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
312     \}
313   \textcolor{keywordflow}{if} (txprofile.txPowerLevel > 8)
314     \{
315       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
316     \}
317   \textcolor{comment}{// IP-based packets is not allowed to send in the CCH.}
318   \textcolor{keywordflow}{if} (txprofile.channelNumber == \hyperlink{channel-manager_8h_a52d2f169cde2f6abe66ecc83f0d7ad80}{CCH})
319     \{
320       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"IP-based packets shall not be transmitted on the CCH"});
321       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
322     \}
323   \textcolor{keywordflow}{if}  (txprofile.dataRate == WifiMode () || txprofile.txPowerLevel == 8)
324     \{
325       \textcolor{comment}{// let MAC layer itself determine tx parameters.}
326       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"High layer does not want to control tx parameters."});
327     \}
328   \textcolor{keywordflow}{else}
329     \{
330       \textcolor{comment}{// if current PHY devices do not support data rate of the tx profile}
331       \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1WaveNetDevice_ab7544e360cf30da8b42e84caf14c8e8a}{PhyEntitiesI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1WaveNetDevice_a60401868abeed63f3218b78c076534a8}{m\_phyEntities}.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != 
      \hyperlink{classns3_1_1WaveNetDevice_a60401868abeed63f3218b78c076534a8}{m\_phyEntities}.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
332         \{
333           \textcolor{keywordflow}{if} (!((*i)->IsModeSupported (txprofile.dataRate)))
334             \{
335               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"This data rate "} << txprofile.dataRate.GetUniqueName () << \textcolor{stringliteral}{" is
       not supported by current PHY device"});
336               \textcolor{keywordflow}{return} \textcolor{keyword}{false};
337             \}
338         \}
339     \}
340 
341   \hyperlink{classns3_1_1WaveNetDevice_ac541d171fef0d8f5c070e305a3e02bca}{m\_txProfile} = \textcolor{keyword}{new} TxProfile ();
342   *\hyperlink{classns3_1_1WaveNetDevice_ac541d171fef0d8f5c070e305a3e02bca}{m\_txProfile} = txprofile;
343   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
344 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 32




Here is the caller graph for this function\+:
% FIG 33


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Send@{Send}}
\index{Send@{Send}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Send(\+Ptr$<$ Packet $>$ packet, const Address \&dest, uint16\+\_\+t protocol\+Number)}{Send(Ptr< Packet > packet, const Address &dest, uint16_t protocolNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Wave\+Net\+Device\+::\+Send (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{const {\bf Address} \&}]{dest, }
\item[{uint16\+\_\+t}]{protocol\+Number}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WaveNetDevice_a21f1928cbc917375a79cb6ed48f4db3e}{}\label{classns3_1_1WaveNetDevice_a21f1928cbc917375a79cb6ed48f4db3e}

\begin{DoxyParams}{Parameters}
{\em packet} & packet sent from above down to Network Device \\
\hline
{\em dest} & mac address of the destination (already resolved) \\
\hline
{\em protocol\+Number} & identifies the type of payload contained in this packet. Used to call the right L3\+Protocol when the packet is received. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether the Send operation succeeded
\end{DoxyReturn}
Normally this method is called by 1609.\+3 standard to send I\+P-\/based packets, however high layers can also send packets in other types except I\+P-\/based packets in C\+CH. 

Implements \hyperlink{classns3_1_1NetDevice_a59f41afb0fe8951bb94d5739cbe6ee7d}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
597 \{
598   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << dest << protocol);
599   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1WaveNetDevice_ac541d171fef0d8f5c070e305a3e02bca}{m\_txProfile} == 0)
600     \{
601       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"there is no tx profile registered for transmission"});
602       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
603     \}
604   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1WaveNetDevice_a64edd74de0dc4af431f2d08aad19a9d1}{m\_channelScheduler}->IsChannelAccessAssigned (
      \hyperlink{classns3_1_1WaveNetDevice_ac541d171fef0d8f5c070e305a3e02bca}{m\_txProfile}->\hyperlink{structns3_1_1TxProfile_a6ee2354a51951ca34dfbec1677f6bfa3}{channelNumber}))
605     \{
606       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"there is no channel access assigned for channel "} << 
      \hyperlink{classns3_1_1WaveNetDevice_ac541d171fef0d8f5c070e305a3e02bca}{m\_txProfile}->\hyperlink{structns3_1_1TxProfile_a6ee2354a51951ca34dfbec1677f6bfa3}{channelNumber});
607       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
608     \}
609   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1WaveNetDevice_ac541d171fef0d8f5c070e305a3e02bca}{m\_txProfile}->\hyperlink{structns3_1_1TxProfile_a28ed5bf9dd2e23cd6b04be7deb7e320a}{dataRate} == WifiMode () || \hyperlink{classns3_1_1WaveNetDevice_ac541d171fef0d8f5c070e305a3e02bca}{m\_txProfile}->
      \hyperlink{structns3_1_1TxProfile_a194d9d200726947b1878974701b88ee6}{txPowerLevel} == 8)
610     \{
611       \textcolor{comment}{// let MAC layer itself determine tx parameters.}
612       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"High layer does not want to control tx parameters."});
613     \}
614   \textcolor{keywordflow}{else}
615     \{
616       WifiTxVector txVector;
617       txVector.SetTxPowerLevel (\hyperlink{classns3_1_1WaveNetDevice_ac541d171fef0d8f5c070e305a3e02bca}{m\_txProfile}->\hyperlink{structns3_1_1TxProfile_a194d9d200726947b1878974701b88ee6}{txPowerLevel});
618       txVector.SetMode (\hyperlink{classns3_1_1WaveNetDevice_ac541d171fef0d8f5c070e305a3e02bca}{m\_txProfile}->\hyperlink{structns3_1_1TxProfile_a28ed5bf9dd2e23cd6b04be7deb7e320a}{dataRate});
619       txVector.SetPreambleType (\hyperlink{classns3_1_1WaveNetDevice_ac541d171fef0d8f5c070e305a3e02bca}{m\_txProfile}->\hyperlink{structns3_1_1TxProfile_a2a3b9303ef59326971fe7d158656adb6}{preamble});
620       HigherLayerTxVectorTag tag = HigherLayerTxVectorTag (txVector, \hyperlink{classns3_1_1WaveNetDevice_ac541d171fef0d8f5c070e305a3e02bca}{m\_txProfile}->
      \hyperlink{structns3_1_1TxProfile_a5ab1a6b737ba020a12498afabefa68f8}{adaptable});
621       packet->\hyperlink{classns3_1_1Packet_a7400b8655852f5271c5957250d0141af}{AddPacketTag} (tag);
622     \}
623 
624   LlcSnapHeader llc;
625   llc.SetType (protocol);
626   packet->\hyperlink{classns3_1_1Packet_a465108c595a0bc592095cbcab1832ed8}{AddHeader} (llc);
627 
628   \textcolor{comment}{// qos tag is already inserted into the packet by high layer  or with default value 7 if high layer
       forget it.}
629   Ptr<WifiMac> mac = \hyperlink{classns3_1_1WaveNetDevice_a899f670dd8eb023f0e40f19b536724eb}{GetMac} (\hyperlink{classns3_1_1WaveNetDevice_ac541d171fef0d8f5c070e305a3e02bca}{m\_txProfile}->\hyperlink{structns3_1_1TxProfile_a6ee2354a51951ca34dfbec1677f6bfa3}{channelNumber});
630   Mac48Address realTo = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (dest);
631   mac->NotifyTx (packet);
632   mac->Enqueue (packet, realTo);
633   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
634 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 34




Here is the caller graph for this function\+:
% FIG 35


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Send\+From@{Send\+From}}
\index{Send\+From@{Send\+From}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Send\+From(\+Ptr$<$ Packet $>$ packet, const Address \&source, const Address \&dest, uint16\+\_\+t protocol\+Number)}{SendFrom(Ptr< Packet > packet, const Address &source, const Address &dest, uint16_t protocolNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Wave\+Net\+Device\+::\+Send\+From (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{const {\bf Address} \&}]{source, }
\item[{const {\bf Address} \&}]{dest, }
\item[{uint16\+\_\+t}]{protocol\+Number}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WaveNetDevice_a3d5db01ed8dc819c146734c756227a3c}{}\label{classns3_1_1WaveNetDevice_a3d5db01ed8dc819c146734c756227a3c}

\begin{DoxyParams}{Parameters}
{\em packet} & packet sent from above down to Network Device \\
\hline
{\em source} & source mac address (so called \char`\"{}\+M\+A\+C spoofing\char`\"{}) \\
\hline
{\em dest} & mac address of the destination (already resolved) \\
\hline
{\em protocol\+Number} & identifies the type of payload contained in this packet. Used to call the right L3\+Protocol when the packet is received.\\
\hline
\end{DoxyParams}
Called from higher layer to send packet into Network Device with the specified source and destination Addresses.

\begin{DoxyReturn}{Returns}
whether the Send operation succeeded 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a19d55a4746c1ae584bf7da69959a885b}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
721 \{
722   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << source << dest << protocol);
723   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
724 \}
\end{DoxyCode}
\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!SendX@{SendX}}
\index{SendX@{SendX}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Send\+X(\+Ptr$<$ Packet $>$ packet, const Address \&dest, uint32\+\_\+t protocol, const Tx\+Info \&tx\+Info)}{SendX(Ptr< Packet > packet, const Address &dest, uint32_t protocol, const TxInfo &txInfo)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Wave\+Net\+Device\+::\+SendX (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{const {\bf Address} \&}]{dest, }
\item[{uint32\+\_\+t}]{protocol, }
\item[{const {\bf Tx\+Info} \&}]{tx\+Info}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WaveNetDevice_a99ec2b781006c6011a9667e064843b38}{}\label{classns3_1_1WaveNetDevice_a99ec2b781006c6011a9667e064843b38}

\begin{DoxyParams}{Parameters}
{\em packet} & packet sent from above down to Network Device \\
\hline
{\em dest} & mac address of the destination (already resolved) \\
\hline
{\em protocol} & identifies the type of payload contained in the packet. Used to call the right L3\+Protocol when the packet is received. \\
\hline
{\em tx\+Info} & W\+S\+MP or other packets parameters for sending \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether the SendX operation succeeded
\end{DoxyReturn}
Normally this method is called by 1609.\+3 standard to send W\+S\+MP packets, however high layers can also send packets in other types except I\+P-\/based packets in C\+CH. 
\begin{DoxyCode}
370 \{
371   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << dest << protocol << &txInfo);
372   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1WaveNetDevice_a56b63f50ec806a4a50397aa8ac4d6231}{IsAvailableChannel} (txInfo.channelNumber))
373     \{
374       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
375     \}
376   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1WaveNetDevice_a64edd74de0dc4af431f2d08aad19a9d1}{m\_channelScheduler}->IsChannelAccessAssigned (txInfo.channelNumber))
377     \{
378       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"there is no channel access assigned for channel "} << txInfo.channelNumber)
      ;
379       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
380     \}
381   \textcolor{keywordflow}{if} ((txInfo.channelNumber == \hyperlink{channel-manager_8h_a52d2f169cde2f6abe66ecc83f0d7ad80}{CCH}) && (protocol == \hyperlink{classns3_1_1WaveNetDevice_aea82cd6718f17f1d2e585c23e4d76100}{IPv4\_PROT\_NUMBER} || protocol == 
      \hyperlink{classns3_1_1WaveNetDevice_a8b18e42ab92375ead7121c02c79e802f}{IPv6\_PROT\_NUMBER}))
382     \{
383       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"IP-based packets shall not be transmitted on the CCH"});
384       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
385     \}
386   \textcolor{keywordflow}{if} ((txInfo.priority > 7) || txInfo.txPowerLevel > 8)
387     \{
388       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"invalid transmit parameters."});
389       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
390     \}
391 
392   \textcolor{keywordflow}{if} ((txInfo.dataRate == WifiMode ()) ||  (txInfo.txPowerLevel == 8))
393     \{
394       \textcolor{comment}{// let MAC layer itself determine tx parameters.}
395       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"High layer does not want to control tx parameters."});
396     \}
397   \textcolor{keywordflow}{else}
398     \{
399       \textcolor{comment}{// if current PHY devices do not support data rate of the  tx profile}
400       \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1WaveNetDevice_ab7544e360cf30da8b42e84caf14c8e8a}{PhyEntitiesI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1WaveNetDevice_a60401868abeed63f3218b78c076534a8}{m\_phyEntities}.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != 
      \hyperlink{classns3_1_1WaveNetDevice_a60401868abeed63f3218b78c076534a8}{m\_phyEntities}.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
401         \{
402           \textcolor{keywordflow}{if} ( !((*i)->IsModeSupported (txInfo.dataRate)))
403             \{
404               \textcolor{keywordflow}{return} \textcolor{keyword}{false};
405             \}
406         \}
407       WifiTxVector txVector;
408       txVector.SetChannelWidth (10);
409       txVector.SetTxPowerLevel (txInfo.txPowerLevel);
410       txVector.SetMode (txInfo.dataRate);
411       txVector.SetPreambleType (txInfo.preamble);
412       HigherLayerTxVectorTag tag = HigherLayerTxVectorTag (txVector, \textcolor{keyword}{false});
413       packet->\hyperlink{classns3_1_1Packet_a7400b8655852f5271c5957250d0141af}{AddPacketTag} (tag);
414     \}
415 
416   LlcSnapHeader llc;
417   llc.SetType (protocol);
418   packet->\hyperlink{classns3_1_1Packet_a465108c595a0bc592095cbcab1832ed8}{AddHeader} (llc);
419 
420   \textcolor{comment}{// according to channel number and priority,}
421   \textcolor{comment}{// route the packet to a proper queue.}
422   SocketPriorityTag prio;
423   prio.SetPriority (txInfo.priority);
424   packet->\hyperlink{classns3_1_1Packet_afb014ae9f4adddbfc51c64b085bfd405}{ReplacePacketTag} (prio);
425   Ptr<WifiMac> mac = \hyperlink{classns3_1_1WaveNetDevice_a899f670dd8eb023f0e40f19b536724eb}{GetMac} (txInfo.channelNumber);
426   Mac48Address realTo = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (dest);
427   mac->NotifyTx (packet);
428   mac->Enqueue (packet, realTo);
429   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
430 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 36




Here is the caller graph for this function\+:
% FIG 37


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Set\+Address@{Set\+Address}}
\index{Set\+Address@{Set\+Address}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Address(\+Address address)}{SetAddress(Address address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Wave\+Net\+Device\+::\+Set\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WaveNetDevice_af398bddb4768c86bdd1cb37ca1963eca}{}\label{classns3_1_1WaveNetDevice_af398bddb4768c86bdd1cb37ca1963eca}
Set the address of this interface 
\begin{DoxyParams}{Parameters}
{\em address} & address to set \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1NetDevice_ab56dc36bc0547471ab3210eda60ee76c}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
521 \{
522   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1WaveNetDevice_a6511363042ad221a19c4cda0d328e0fc}{MacEntitiesI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1WaveNetDevice_a6db79f07bf41465f7b91dd38ae81f1e8}{m\_macEntities}.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != 
      \hyperlink{classns3_1_1WaveNetDevice_a6db79f07bf41465f7b91dd38ae81f1e8}{m\_macEntities}.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
523     \{
524       \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second->SetAddress (\hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (address));
525     \}
526 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 38




Here is the caller graph for this function\+:
% FIG 39


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Set\+Channel\+Coordinator@{Set\+Channel\+Coordinator}}
\index{Set\+Channel\+Coordinator@{Set\+Channel\+Coordinator}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Channel\+Coordinator(\+Ptr$<$ Channel\+Coordinator $>$ channel\+Coordinator)}{SetChannelCoordinator(Ptr< ChannelCoordinator > channelCoordinator)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Wave\+Net\+Device\+::\+Set\+Channel\+Coordinator (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Channel\+Coordinator} $>$}]{channel\+Coordinator}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WaveNetDevice_a0bd0431f70e5ea68ae818650b6ff06d8}{}\label{classns3_1_1WaveNetDevice_a0bd0431f70e5ea68ae818650b6ff06d8}

\begin{DoxyParams}{Parameters}
{\em channel\+Coordinator} & the channel coordinator for multiple channel operation \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
484 \{
485   \hyperlink{classns3_1_1WaveNetDevice_ab05beb5d2cd120f6b81ab100628c1912}{m\_channelCoordinator} = channelCoordinator;
486 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 40


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Set\+Channel\+Manager@{Set\+Channel\+Manager}}
\index{Set\+Channel\+Manager@{Set\+Channel\+Manager}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Channel\+Manager(\+Ptr$<$ Channel\+Manager $>$ channel\+Manager)}{SetChannelManager(Ptr< ChannelManager > channelManager)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Wave\+Net\+Device\+::\+Set\+Channel\+Manager (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Channel\+Manager} $>$}]{channel\+Manager}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WaveNetDevice_acc72aa6c137e1c78c6e5bc3c19973ef4}{}\label{classns3_1_1WaveNetDevice_acc72aa6c137e1c78c6e5bc3c19973ef4}

\begin{DoxyParams}{Parameters}
{\em channel\+Manager} & the channel manager for multiple channel operation \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
464 \{
465   \hyperlink{classns3_1_1WaveNetDevice_ae9970c62630b78bc09d4d4a16cb55ff8}{m\_channelManager} = channelManager;
466 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 41


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Set\+Channel\+Scheduler@{Set\+Channel\+Scheduler}}
\index{Set\+Channel\+Scheduler@{Set\+Channel\+Scheduler}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Channel\+Scheduler(\+Ptr$<$ Channel\+Scheduler $>$ channel\+Scheduler)}{SetChannelScheduler(Ptr< ChannelScheduler > channelScheduler)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Wave\+Net\+Device\+::\+Set\+Channel\+Scheduler (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Channel\+Scheduler} $>$}]{channel\+Scheduler}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WaveNetDevice_a3aa4f3edcb781fca5306e817315cd31b}{}\label{classns3_1_1WaveNetDevice_a3aa4f3edcb781fca5306e817315cd31b}

\begin{DoxyParams}{Parameters}
{\em channel\+Scheduler} & the channel scheduler for multiple channel operation \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
474 \{
475   \hyperlink{classns3_1_1WaveNetDevice_a64edd74de0dc4af431f2d08aad19a9d1}{m\_channelScheduler} = channelScheduler;
476 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 42


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Set\+If\+Index@{Set\+If\+Index}}
\index{Set\+If\+Index@{Set\+If\+Index}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+If\+Index(const uint32\+\_\+t index)}{SetIfIndex(const uint32_t index)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Wave\+Net\+Device\+::\+Set\+If\+Index (
\begin{DoxyParamCaption}
\item[{const uint32\+\_\+t}]{index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WaveNetDevice_ac6d2149989047dde63c914c1425fb26b}{}\label{classns3_1_1WaveNetDevice_ac6d2149989047dde63c914c1425fb26b}

\begin{DoxyParams}{Parameters}
{\em index} & if\+Index of the device \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1NetDevice_a2e1ac6c1189cd565420305d85a193fb8}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
505 \{
506   \hyperlink{classns3_1_1WaveNetDevice_a6b8a6a87173e27fc9bdcbb45e1e395bd}{m\_ifIndex} = index;
507 \}
\end{DoxyCode}
\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Set\+Mtu@{Set\+Mtu}}
\index{Set\+Mtu@{Set\+Mtu}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Mtu(const uint16\+\_\+t mtu)}{SetMtu(const uint16_t mtu)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Wave\+Net\+Device\+::\+Set\+Mtu (
\begin{DoxyParamCaption}
\item[{const uint16\+\_\+t}]{mtu}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WaveNetDevice_a382714bf5a869123c1a38f5c4a0c7a06}{}\label{classns3_1_1WaveNetDevice_a382714bf5a869123c1a38f5c4a0c7a06}

\begin{DoxyParams}{Parameters}
{\em mtu} & M\+TU value, in bytes, to set for the device \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether the M\+TU value was within legal bounds
\end{DoxyReturn}
Override for default M\+TU defined on a per-\/type basis. 

Implements \hyperlink{classns3_1_1NetDevice_a2ba4956d45cde68eab3cbdd6ede06df0}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
534 \{
535   \textcolor{keywordflow}{if} (mtu > \hyperlink{classns3_1_1WaveNetDevice_a657b84535129c4bf94fb6720d5052508}{MAX\_MSDU\_SIZE} - \hyperlink{namespacens3_af8522e22bcdefd901bcf12e260491ec8}{LLC\_SNAP\_HEADER\_LENGTH})
536     \{
537       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
538     \}
539   \hyperlink{classns3_1_1WaveNetDevice_a203a4cd4350be439a2cb5dd45f02c383}{m\_mtu} = mtu;
540   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
541 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 43


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Set\+Node@{Set\+Node}}
\index{Set\+Node@{Set\+Node}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Node(\+Ptr$<$ Node $>$ node)}{SetNode(Ptr< Node > node)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Wave\+Net\+Device\+::\+Set\+Node (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WaveNetDevice_a064907223dfd3ccead8b187d21b36699}{}\label{classns3_1_1WaveNetDevice_a064907223dfd3ccead8b187d21b36699}

\begin{DoxyParams}{Parameters}
{\em node} & the node associated to this netdevice.\\
\hline
\end{DoxyParams}
This method is called from \hyperlink{classns3_1_1Node_a42ff83ee1d5d1649c770d3f5b62375de}{ns3\+::\+Node\+::\+Add\+Device}. 

Implements \hyperlink{classns3_1_1NetDevice_a3ae520ae06e93b957f0f56f113319a08}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
643 \{
644   \hyperlink{classns3_1_1WaveNetDevice_ac48a992182b2920c3889706e76e78f79}{m\_node} = node;
645 \}
\end{DoxyCode}
\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Set\+Promisc\+Receive\+Callback@{Set\+Promisc\+Receive\+Callback}}
\index{Set\+Promisc\+Receive\+Callback@{Set\+Promisc\+Receive\+Callback}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Promisc\+Receive\+Callback(\+Promisc\+Receive\+Callback cb)}{SetPromiscReceiveCallback(PromiscReceiveCallback cb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Wave\+Net\+Device\+::\+Set\+Promisc\+Receive\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Promisc\+Receive\+Callback}}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WaveNetDevice_a7ebc8fb3b0f840c9f1f62b5de8987cf4}{}\label{classns3_1_1WaveNetDevice_a7ebc8fb3b0f840c9f1f62b5de8987cf4}

\begin{DoxyParams}{Parameters}
{\em cb} & callback to invoke whenever a packet has been received in promiscuous mode and must be forwarded to the higher layers.\\
\hline
\end{DoxyParams}
Enables netdevice promiscuous mode and sets the callback that will handle promiscuous mode packets. Note, promiscuous mode packets means {\itshape all} packets, including those packets that can be sensed by the netdevice but which are intended to be received by other hosts. 

Implements \hyperlink{classns3_1_1NetDevice_a3968946bdbb74d47d7b13612baad7d6d}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
728 \{
729   \hyperlink{classns3_1_1WaveNetDevice_aa240cecb622b251bbab6177554e9d439}{m\_promiscRx} = cb;
730   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1WaveNetDevice_a6511363042ad221a19c4cda0d328e0fc}{MacEntitiesI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1WaveNetDevice_a6db79f07bf41465f7b91dd38ae81f1e8}{m\_macEntities}.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != 
      \hyperlink{classns3_1_1WaveNetDevice_a6db79f07bf41465f7b91dd38ae81f1e8}{m\_macEntities}.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
731     \{
732       \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second->SetPromisc ();
733     \}
734 \}
\end{DoxyCode}
\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Set\+Receive\+Callback@{Set\+Receive\+Callback}}
\index{Set\+Receive\+Callback@{Set\+Receive\+Callback}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Receive\+Callback(\+Net\+Device\+::\+Receive\+Callback cb)}{SetReceiveCallback(NetDevice::ReceiveCallback cb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Wave\+Net\+Device\+::\+Set\+Receive\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Net\+Device\+::\+Receive\+Callback}}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WaveNetDevice_a98a6505182abba177a0ab348356301d8}{}\label{classns3_1_1WaveNetDevice_a98a6505182abba177a0ab348356301d8}

\begin{DoxyParams}{Parameters}
{\em cb} & callback to invoke whenever a packet has been received and must be forwarded to the higher layers.\\
\hline
\end{DoxyParams}
Set the callback to be used to notify higher layers when a packet has been received. 

Implements \hyperlink{classns3_1_1NetDevice_ac63e4d5668e421fec4b5d37f32e7dd18}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
656 \{
657   \hyperlink{classns3_1_1WaveNetDevice_a323fd8350ab01fa9fa0b4a2ec6b32442}{m\_forwardUp} = cb;
658 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 44


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Set\+Vsa\+Manager@{Set\+Vsa\+Manager}}
\index{Set\+Vsa\+Manager@{Set\+Vsa\+Manager}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Vsa\+Manager(\+Ptr$<$ Vsa\+Manager $>$ vsa\+Manager)}{SetVsaManager(Ptr< VsaManager > vsaManager)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Wave\+Net\+Device\+::\+Set\+Vsa\+Manager (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Vsa\+Manager} $>$}]{vsa\+Manager}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WaveNetDevice_a67b70adf83f3029059e45b8f99901b9d}{}\label{classns3_1_1WaveNetDevice_a67b70adf83f3029059e45b8f99901b9d}

\begin{DoxyParams}{Parameters}
{\em vsa\+Manager} & the V\+SA manager for multiple channel operation \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
494 \{
495   \hyperlink{classns3_1_1WaveNetDevice_a3bec7791c4e2ffc4609e7bf1b75b07b7}{m\_vsaManager} = vsaManager;
496 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 45


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Set\+Wave\+Vsa\+Callback@{Set\+Wave\+Vsa\+Callback}}
\index{Set\+Wave\+Vsa\+Callback@{Set\+Wave\+Vsa\+Callback}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Wave\+Vsa\+Callback(\+Wave\+Vsa\+Callback vsa\+Callback)}{SetWaveVsaCallback(WaveVsaCallback vsaCallback)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Wave\+Net\+Device\+::\+Set\+Wave\+Vsa\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Wave\+Vsa\+Callback}}]{vsa\+Callback}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WaveNetDevice_ab728ae9b274726d36112367b59a3906d}{}\label{classns3_1_1WaveNetDevice_ab728ae9b274726d36112367b59a3906d}

\begin{DoxyParams}{Parameters}
{\em vsa\+Callback} & the V\+SA receive callback for 1609 management information \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
274 \{
275   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
276   \hyperlink{classns3_1_1WaveNetDevice_a3bec7791c4e2ffc4609e7bf1b75b07b7}{m\_vsaManager}->SetWaveVsaCallback (vsaCallback);
277 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 46


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Start\+Sch@{Start\+Sch}}
\index{Start\+Sch@{Start\+Sch}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Start\+Sch(const Sch\+Info \&sch\+Info)}{StartSch(const SchInfo &schInfo)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Wave\+Net\+Device\+::\+Start\+Sch (
\begin{DoxyParamCaption}
\item[{const {\bf Sch\+Info} \&}]{sch\+Info}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WaveNetDevice_a0d443497d2438fa48ef7ec72be6728fd}{}\label{classns3_1_1WaveNetDevice_a0d443497d2438fa48ef7ec72be6728fd}

\begin{DoxyParams}{Parameters}
{\em sch\+Info} & the parameters about how to start S\+CH service \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether channel access is assigned successfully 
\end{DoxyReturn}

\begin{DoxyCode}
281 \{
282   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << &schInfo);
283   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1WaveNetDevice_a56b63f50ec806a4a50397aa8ac4d6231}{IsAvailableChannel} (schInfo.channelNumber))
284     \{
285       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
286     \}
287   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1WaveNetDevice_a64edd74de0dc4af431f2d08aad19a9d1}{m\_channelScheduler}->StartSch (schInfo);
288 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 47




Here is the caller graph for this function\+:
% FIG 48


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Start\+Vsa@{Start\+Vsa}}
\index{Start\+Vsa@{Start\+Vsa}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Start\+Vsa(const Vsa\+Info \&vsa\+Info)}{StartVsa(const VsaInfo &vsaInfo)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Wave\+Net\+Device\+::\+Start\+Vsa (
\begin{DoxyParamCaption}
\item[{const {\bf Vsa\+Info} \&}]{vsa\+Info}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WaveNetDevice_adb48d281cd174f232e8c4fc0b642573b}{}\label{classns3_1_1WaveNetDevice_adb48d281cd174f232e8c4fc0b642573b}

\begin{DoxyParams}{Parameters}
{\em vsa\+Info} & the parameters about how to send V\+SA frame \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether the request for V\+SA transmission is completed 
\end{DoxyReturn}

\begin{DoxyCode}
232 \{
233   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << &vsaInfo);
234   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1WaveNetDevice_a56b63f50ec806a4a50397aa8ac4d6231}{IsAvailableChannel} ( vsaInfo.channelNumber))
235     \{
236       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
237     \}
238   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1WaveNetDevice_a64edd74de0dc4af431f2d08aad19a9d1}{m\_channelScheduler}->IsChannelAccessAssigned (vsaInfo.channelNumber))
239     \{
240       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"there is no channel access assigned for channel "} << vsaInfo.channelNumber
      );
241       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
242     \}
243   \textcolor{keywordflow}{if} (vsaInfo.vsc == 0)
244     \{
245       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"vendor specific information shall not be null"});
246       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
247     \}
248   \textcolor{keywordflow}{if} (vsaInfo.oi.IsNull () && vsaInfo.managementId >= 16)
249     \{
250       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"when organization identifier is not set, management ID "}
251                     \textcolor{stringliteral}{"shall be in range from 0 to 15"});
252       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
253     \}
254 
255   \hyperlink{classns3_1_1WaveNetDevice_a3bec7791c4e2ffc4609e7bf1b75b07b7}{m\_vsaManager}->SendVsa (vsaInfo);
256   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
257 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 49




Here is the caller graph for this function\+:
% FIG 50


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Stop\+Sch@{Stop\+Sch}}
\index{Stop\+Sch@{Stop\+Sch}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Stop\+Sch(uint32\+\_\+t channel\+Number)}{StopSch(uint32_t channelNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Wave\+Net\+Device\+::\+Stop\+Sch (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{channel\+Number}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WaveNetDevice_aeaaa53f5a961de1acfd755c69bbab3fb}{}\label{classns3_1_1WaveNetDevice_aeaaa53f5a961de1acfd755c69bbab3fb}

\begin{DoxyParams}{Parameters}
{\em channel\+Number} & the channel which access resource will be released. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether channel access is released successfully 
\end{DoxyReturn}

\begin{DoxyCode}
292 \{
293   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << channelNumber);
294   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1WaveNetDevice_a56b63f50ec806a4a50397aa8ac4d6231}{IsAvailableChannel} (channelNumber))
295     \{
296       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
297     \}
298   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1WaveNetDevice_a64edd74de0dc4af431f2d08aad19a9d1}{m\_channelScheduler}->StopSch (channelNumber);
299 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 51




Here is the caller graph for this function\+:
% FIG 52


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Stop\+Vsa@{Stop\+Vsa}}
\index{Stop\+Vsa@{Stop\+Vsa}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Stop\+Vsa(uint32\+\_\+t channel\+Number)}{StopVsa(uint32_t channelNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Wave\+Net\+Device\+::\+Stop\+Vsa (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{channel\+Number}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WaveNetDevice_a83693f1bee542812b303a76d065ed1b5}{}\label{classns3_1_1WaveNetDevice_a83693f1bee542812b303a76d065ed1b5}

\begin{DoxyParams}{Parameters}
{\em channel\+Number} & the channel on which V\+SA transmit event will be canceled. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether the request for stopping V\+SA transmission is completed 
\end{DoxyReturn}

\begin{DoxyCode}
262 \{
263   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << channelNumber);
264   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1WaveNetDevice_a56b63f50ec806a4a50397aa8ac4d6231}{IsAvailableChannel} (channelNumber))
265     \{
266       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
267     \}
268   \hyperlink{classns3_1_1WaveNetDevice_a3bec7791c4e2ffc4609e7bf1b75b07b7}{m\_vsaManager}->RemoveByChannel (channelNumber);
269   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
270 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 53




Here is the caller graph for this function\+:
% FIG 54


\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!Supports\+Send\+From@{Supports\+Send\+From}}
\index{Supports\+Send\+From@{Supports\+Send\+From}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{Supports\+Send\+From(void) const }{SupportsSendFrom(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Wave\+Net\+Device\+::\+Supports\+Send\+From (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1WaveNetDevice_afbb333ee66fb43ea4814e55621cf669f}{}\label{classns3_1_1WaveNetDevice_afbb333ee66fb43ea4814e55621cf669f}
\begin{DoxyReturn}{Returns}
true if this interface supports a bridging mode, false otherwise. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a04793d220b54c40e110ebf86dae5b25c}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
738 \{
739   \textcolor{keywordflow}{return} (\hyperlink{classns3_1_1WaveNetDevice_a899f670dd8eb023f0e40f19b536724eb}{GetMac} (\hyperlink{channel-manager_8h_a52d2f169cde2f6abe66ecc83f0d7ad80}{CCH}))->SupportsSendFrom ();
740 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 55




\subsection{Member Data Documentation}
\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!I\+Pv4\+\_\+\+P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER@{I\+Pv4\+\_\+\+P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER}}
\index{I\+Pv4\+\_\+\+P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER@{I\+Pv4\+\_\+\+P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{I\+Pv4\+\_\+\+P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER}{IPv4_PROT_NUMBER}}]{\setlength{\rightskip}{0pt plus 5cm}const uint16\+\_\+t ns3\+::\+Wave\+Net\+Device\+::\+I\+Pv4\+\_\+\+P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER = 0x0800\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\hypertarget{classns3_1_1WaveNetDevice_aea82cd6718f17f1d2e585c23e4d76100}{}\label{classns3_1_1WaveNetDevice_aea82cd6718f17f1d2e585c23e4d76100}


IP v4 Protocol number. 

\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!I\+Pv6\+\_\+\+P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER@{I\+Pv6\+\_\+\+P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER}}
\index{I\+Pv6\+\_\+\+P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER@{I\+Pv6\+\_\+\+P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{I\+Pv6\+\_\+\+P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER}{IPv6_PROT_NUMBER}}]{\setlength{\rightskip}{0pt plus 5cm}const uint16\+\_\+t ns3\+::\+Wave\+Net\+Device\+::\+I\+Pv6\+\_\+\+P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER = 0x86\+DD\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\hypertarget{classns3_1_1WaveNetDevice_a8b18e42ab92375ead7121c02c79e802f}{}\label{classns3_1_1WaveNetDevice_a8b18e42ab92375ead7121c02c79e802f}


IP v6 Protocol number. 

\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!m\+\_\+address\+Change@{m\+\_\+address\+Change}}
\index{m\+\_\+address\+Change@{m\+\_\+address\+Change}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+address\+Change}{m_addressChange}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Address}, {\bf Address}$>$ ns3\+::\+Wave\+Net\+Device\+::m\+\_\+address\+Change\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WaveNetDevice_a9f5269cddc734b4dddff1e96f577a28f}{}\label{classns3_1_1WaveNetDevice_a9f5269cddc734b4dddff1e96f577a28f}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000165}{Todo}]The \hyperlink{classns3_1_1Address}{Address} arguments should be passed by const reference, since they are large. \end{DoxyRefDesc}
\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!m\+\_\+channel\+Coordinator@{m\+\_\+channel\+Coordinator}}
\index{m\+\_\+channel\+Coordinator@{m\+\_\+channel\+Coordinator}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+channel\+Coordinator}{m_channelCoordinator}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Channel\+Coordinator}$>$ ns3\+::\+Wave\+Net\+Device\+::m\+\_\+channel\+Coordinator\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WaveNetDevice_ab05beb5d2cd120f6b81ab100628c1912}{}\label{classns3_1_1WaveNetDevice_ab05beb5d2cd120f6b81ab100628c1912}


the channel coordinator 

\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!m\+\_\+channel\+Manager@{m\+\_\+channel\+Manager}}
\index{m\+\_\+channel\+Manager@{m\+\_\+channel\+Manager}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+channel\+Manager}{m_channelManager}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Channel\+Manager}$>$ ns3\+::\+Wave\+Net\+Device\+::m\+\_\+channel\+Manager\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WaveNetDevice_ae9970c62630b78bc09d4d4a16cb55ff8}{}\label{classns3_1_1WaveNetDevice_ae9970c62630b78bc09d4d4a16cb55ff8}


the channel manager 

\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!m\+\_\+channel\+Scheduler@{m\+\_\+channel\+Scheduler}}
\index{m\+\_\+channel\+Scheduler@{m\+\_\+channel\+Scheduler}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+channel\+Scheduler}{m_channelScheduler}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Channel\+Scheduler}$>$ ns3\+::\+Wave\+Net\+Device\+::m\+\_\+channel\+Scheduler\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WaveNetDevice_a64edd74de0dc4af431f2d08aad19a9d1}{}\label{classns3_1_1WaveNetDevice_a64edd74de0dc4af431f2d08aad19a9d1}


the channel scheduler 

\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!m\+\_\+forward\+Up@{m\+\_\+forward\+Up}}
\index{m\+\_\+forward\+Up@{m\+\_\+forward\+Up}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+forward\+Up}{m_forwardUp}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Net\+Device\+::\+Receive\+Callback} ns3\+::\+Wave\+Net\+Device\+::m\+\_\+forward\+Up\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WaveNetDevice_a323fd8350ab01fa9fa0b4a2ec6b32442}{}\label{classns3_1_1WaveNetDevice_a323fd8350ab01fa9fa0b4a2ec6b32442}


forward up receive callback 

\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!m\+\_\+if\+Index@{m\+\_\+if\+Index}}
\index{m\+\_\+if\+Index@{m\+\_\+if\+Index}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+if\+Index}{m_ifIndex}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Wave\+Net\+Device\+::m\+\_\+if\+Index\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WaveNetDevice_a6b8a6a87173e27fc9bdcbb45e1e395bd}{}\label{classns3_1_1WaveNetDevice_a6b8a6a87173e27fc9bdcbb45e1e395bd}


IF index. 

\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!m\+\_\+mac\+Entities@{m\+\_\+mac\+Entities}}
\index{m\+\_\+mac\+Entities@{m\+\_\+mac\+Entities}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+mac\+Entities}{m_macEntities}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Mac\+Entities} ns3\+::\+Wave\+Net\+Device\+::m\+\_\+mac\+Entities\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WaveNetDevice_a6db79f07bf41465f7b91dd38ae81f1e8}{}\label{classns3_1_1WaveNetDevice_a6db79f07bf41465f7b91dd38ae81f1e8}
M\+AC entities \index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!m\+\_\+mtu@{m\+\_\+mtu}}
\index{m\+\_\+mtu@{m\+\_\+mtu}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+mtu}{m_mtu}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Wave\+Net\+Device\+::m\+\_\+mtu\hspace{0.3cm}{\ttfamily [mutable]}, {\ttfamily [private]}}\hypertarget{classns3_1_1WaveNetDevice_a203a4cd4350be439a2cb5dd45f02c383}{}\label{classns3_1_1WaveNetDevice_a203a4cd4350be439a2cb5dd45f02c383}


M\+TU. 

\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!m\+\_\+node@{m\+\_\+node}}
\index{m\+\_\+node@{m\+\_\+node}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+node}{m_node}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Node}$>$ ns3\+::\+Wave\+Net\+Device\+::m\+\_\+node\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WaveNetDevice_ac48a992182b2920c3889706e76e78f79}{}\label{classns3_1_1WaveNetDevice_ac48a992182b2920c3889706e76e78f79}


the node 

\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!m\+\_\+phy\+Entities@{m\+\_\+phy\+Entities}}
\index{m\+\_\+phy\+Entities@{m\+\_\+phy\+Entities}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+phy\+Entities}{m_phyEntities}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Phy\+Entities} ns3\+::\+Wave\+Net\+Device\+::m\+\_\+phy\+Entities\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WaveNetDevice_a60401868abeed63f3218b78c076534a8}{}\label{classns3_1_1WaveNetDevice_a60401868abeed63f3218b78c076534a8}


Phy entities. 

\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!m\+\_\+promisc\+Rx@{m\+\_\+promisc\+Rx}}
\index{m\+\_\+promisc\+Rx@{m\+\_\+promisc\+Rx}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+promisc\+Rx}{m_promiscRx}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Net\+Device\+::\+Promisc\+Receive\+Callback} ns3\+::\+Wave\+Net\+Device\+::m\+\_\+promisc\+Rx\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WaveNetDevice_aa240cecb622b251bbab6177554e9d439}{}\label{classns3_1_1WaveNetDevice_aa240cecb622b251bbab6177554e9d439}


promiscious receive callback 

\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!m\+\_\+tx\+Profile@{m\+\_\+tx\+Profile}}
\index{m\+\_\+tx\+Profile@{m\+\_\+tx\+Profile}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+tx\+Profile}{m_txProfile}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tx\+Profile}$\ast$ ns3\+::\+Wave\+Net\+Device\+::m\+\_\+tx\+Profile\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WaveNetDevice_ac541d171fef0d8f5c070e305a3e02bca}{}\label{classns3_1_1WaveNetDevice_ac541d171fef0d8f5c070e305a3e02bca}


transmit profile 

\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!m\+\_\+vsa\+Manager@{m\+\_\+vsa\+Manager}}
\index{m\+\_\+vsa\+Manager@{m\+\_\+vsa\+Manager}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+vsa\+Manager}{m_vsaManager}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Vsa\+Manager}$>$ ns3\+::\+Wave\+Net\+Device\+::m\+\_\+vsa\+Manager\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WaveNetDevice_a3bec7791c4e2ffc4609e7bf1b75b07b7}{}\label{classns3_1_1WaveNetDevice_a3bec7791c4e2ffc4609e7bf1b75b07b7}


the V\+SA manager 

\index{ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}!M\+A\+X\+\_\+\+M\+S\+D\+U\+\_\+\+S\+I\+ZE@{M\+A\+X\+\_\+\+M\+S\+D\+U\+\_\+\+S\+I\+ZE}}
\index{M\+A\+X\+\_\+\+M\+S\+D\+U\+\_\+\+S\+I\+ZE@{M\+A\+X\+\_\+\+M\+S\+D\+U\+\_\+\+S\+I\+ZE}!ns3\+::\+Wave\+Net\+Device@{ns3\+::\+Wave\+Net\+Device}}
\subsubsection[{\texorpdfstring{M\+A\+X\+\_\+\+M\+S\+D\+U\+\_\+\+S\+I\+ZE}{MAX_MSDU_SIZE}}]{\setlength{\rightskip}{0pt plus 5cm}const uint16\+\_\+t ns3\+::\+Wave\+Net\+Device\+::\+M\+A\+X\+\_\+\+M\+S\+D\+U\+\_\+\+S\+I\+ZE = 2304\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\hypertarget{classns3_1_1WaveNetDevice_a657b84535129c4bf94fb6720d5052508}{}\label{classns3_1_1WaveNetDevice_a657b84535129c4bf94fb6720d5052508}


This value conforms to the 802.\+11 specification. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
wave/model/\hyperlink{wave-net-device_8h}{wave-\/net-\/device.\+h}\item 
wave/model/\hyperlink{wave-net-device_8cc}{wave-\/net-\/device.\+cc}\end{DoxyCompactItemize}
