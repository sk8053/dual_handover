\hypertarget{classns3_1_1CsmaNetDevice}{}\section{ns3\+:\+:Csma\+Net\+Device Class Reference}
\label{classns3_1_1CsmaNetDevice}\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}


A Device for a Csma Network Link.  




{\ttfamily \#include $<$csma-\/net-\/device.\+h$>$}



Inheritance diagram for ns3\+:\+:Csma\+Net\+Device\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Csma\+Net\+Device\+:
% FIG 1
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classns3_1_1CsmaNetDevice_a176431468055d41f8e879e33a5362cad}{Encapsulation\+Mode} \{ \hyperlink{classns3_1_1CsmaNetDevice_a176431468055d41f8e879e33a5362cada1f230eaef80ea65f838f089c07981bad}{I\+L\+L\+E\+G\+AL}, 
\hyperlink{classns3_1_1CsmaNetDevice_a176431468055d41f8e879e33a5362cada8cc8287029197a9496df00c6d3f8b9ff}{D\+IX}, 
\hyperlink{classns3_1_1CsmaNetDevice_a176431468055d41f8e879e33a5362cadab3a0dd08ede5405aff1fd939e556dc5b}{L\+LC}
 \}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1CsmaNetDevice_a5005a5403e112dad6ecd2922a9065916}{Csma\+Net\+Device} ()
\item 
virtual \hyperlink{classns3_1_1CsmaNetDevice_af1c8ebf5c098c264e248d025ead3c6a4}{$\sim$\+Csma\+Net\+Device} ()
\item 
void \hyperlink{classns3_1_1CsmaNetDevice_a03c6e2194fff14f295c234aa9e4c1cdd}{Set\+Interframe\+Gap} (\hyperlink{classns3_1_1Time}{Time} t)
\item 
void \hyperlink{classns3_1_1CsmaNetDevice_a8295d286454a3044ac4100d72af25bd9}{Set\+Backoff\+Params} (\hyperlink{classns3_1_1Time}{Time} slot\+Time, uint32\+\_\+t min\+Slots, uint32\+\_\+t max\+Slots, uint32\+\_\+t max\+Retries, uint32\+\_\+t ceiling)
\item 
bool \hyperlink{classns3_1_1CsmaNetDevice_a5e24813945deeace8e8abe4ede602278}{Attach} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1CsmaChannel}{Csma\+Channel} $>$ ch)
\item 
void \hyperlink{classns3_1_1CsmaNetDevice_ae5cc491c6cafc21896c88c8d313c3bfe}{Set\+Queue} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Queue}{Queue}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ queue)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Queue}{Queue}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1CsmaNetDevice_a40e2c34436dde9efd9d1f1c86594b4d0}{Get\+Queue} (void) const 
\item 
void \hyperlink{classns3_1_1CsmaNetDevice_aa129e661ab34da9e2145f69847dd5447}{Set\+Receive\+Error\+Model} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1ErrorModel}{Error\+Model} $>$ em)
\item 
void \hyperlink{classns3_1_1CsmaNetDevice_a640e48cd26f676994e0d76b5f34a5367}{Receive} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1CsmaNetDevice}{Csma\+Net\+Device} $>$ sender)
\item 
bool \hyperlink{classns3_1_1CsmaNetDevice_a40e5946f8807cb9c65857789c3c2b269}{Is\+Send\+Enabled} (void)
\item 
void \hyperlink{classns3_1_1CsmaNetDevice_aa3a93694ca83a26f513008a7d8f36dbe}{Set\+Send\+Enable} (bool enable)
\item 
bool \hyperlink{classns3_1_1CsmaNetDevice_a6a4e8e37d1a78fa176184a1787b47c3a}{Is\+Receive\+Enabled} (void)
\item 
void \hyperlink{classns3_1_1CsmaNetDevice_a2bb51b44d9ef6aa86350c83f059d3f8f}{Set\+Receive\+Enable} (bool enable)
\item 
void \hyperlink{classns3_1_1CsmaNetDevice_abb8187ce567fde1aa17250f38751468b}{Set\+Encapsulation\+Mode} (\hyperlink{classns3_1_1CsmaNetDevice_a176431468055d41f8e879e33a5362cad}{Csma\+Net\+Device\+::\+Encapsulation\+Mode} mode)
\item 
\hyperlink{classns3_1_1CsmaNetDevice_a176431468055d41f8e879e33a5362cad}{Csma\+Net\+Device\+::\+Encapsulation\+Mode} \hyperlink{classns3_1_1CsmaNetDevice_a51819cee730b7c8f68d1ec277a986a8a}{Get\+Encapsulation\+Mode} (void)
\item 
virtual void \hyperlink{classns3_1_1CsmaNetDevice_a469d807eeb90a07795ef29824698b23f}{Set\+If\+Index} (const uint32\+\_\+t index)
\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1CsmaNetDevice_a0a2ec345a46446edcd4c829980abc837}{Get\+If\+Index} (void) const 
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Channel}{Channel} $>$ \hyperlink{classns3_1_1CsmaNetDevice_ab4eaccd57e3fc31b49197632bd53933f}{Get\+Channel} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1CsmaNetDevice_a6fe6c073498c02fa0b01c64746f6166b}{Set\+Mtu} (const uint16\+\_\+t mtu)
\item 
virtual uint16\+\_\+t \hyperlink{classns3_1_1CsmaNetDevice_a4c27c177803c2efbea66c14b66babd84}{Get\+Mtu} (void) const 
\item 
virtual void \hyperlink{classns3_1_1CsmaNetDevice_a3e67420f44df00ba880ecc3f361cce2a}{Set\+Address} (\hyperlink{classns3_1_1Address}{Address} address)
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1CsmaNetDevice_ae3352827049c29ccee336f2c7fb98182}{Get\+Address} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1CsmaNetDevice_a961676d6d97ebdb8605196c96e0d2ef1}{Is\+Link\+Up} (void) const 
\item 
virtual void \hyperlink{classns3_1_1CsmaNetDevice_a9d03e26036a3f29d584baa12bd7e14a5}{Add\+Link\+Change\+Callback} (\hyperlink{classns3_1_1Callback}{Callback}$<$ void $>$ callback)
\item 
virtual bool \hyperlink{classns3_1_1CsmaNetDevice_a36fbc65aebd3b5bd7d0747c3e5bf3b4b}{Is\+Broadcast} (void) const 
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1CsmaNetDevice_aebadc0653f18569208a61013cfe36947}{Get\+Broadcast} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1CsmaNetDevice_a44bd5fb211a01d2b1df02db27d062200}{Is\+Multicast} (void) const 
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1CsmaNetDevice_ac7091be8b22f218e39572028c5fe45d2}{Get\+Multicast} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} multicast\+Group) const 
\begin{DoxyCompactList}\small\item\em Make and return a M\+AC multicast address using the provided multicast group. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1CsmaNetDevice_a38a3517032b7973fbafca15103c07d52}{Is\+Point\+To\+Point} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1CsmaNetDevice_a16114731c9a1ea434be6872fc5ec4196}{Is\+Bridge} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1CsmaNetDevice_a6d3d0c60f8a2d60fbe006248bb6b119d}{Send} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, const \hyperlink{classns3_1_1Address}{Address} \&dest, uint16\+\_\+t protocol\+Number)
\item 
virtual bool \hyperlink{classns3_1_1CsmaNetDevice_ad7cb5da0e3fb59bd1670c8fa0af4b775}{Send\+From} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, const \hyperlink{classns3_1_1Address}{Address} \&source, const \hyperlink{classns3_1_1Address}{Address} \&dest, uint16\+\_\+t protocol\+Number)
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1CsmaNetDevice_a4a6057b8a66a50306506b3560494f708}{Get\+Node} (void) const 
\item 
virtual void \hyperlink{classns3_1_1CsmaNetDevice_a81187adfa932888b01c57f146eb49991}{Set\+Node} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node)
\item 
virtual bool \hyperlink{classns3_1_1CsmaNetDevice_aaabe1b5821f22b8f3ee474a2ffa32516}{Needs\+Arp} (void) const 
\item 
virtual void \hyperlink{classns3_1_1CsmaNetDevice_a7aece222e096a5526a28e7bf71e609f8}{Set\+Receive\+Callback} (\hyperlink{classns3_1_1NetDevice_ad5e5e1ca187472bc2ba99575d8def568}{Net\+Device\+::\+Receive\+Callback} cb)
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1CsmaNetDevice_ac3944d8c8399743a25b9919512912f62}{Get\+Multicast} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} addr) const 
\begin{DoxyCompactList}\small\item\em Get the M\+AC multicast address corresponding to the I\+Pv6 address provided. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1CsmaNetDevice_a826a66d3c380a4b2190d1a6b1fb5a6e2}{Set\+Promisc\+Receive\+Callback} (\hyperlink{classns3_1_1NetDevice_a427225795919f26c414bee2ea3f31ed2}{Promisc\+Receive\+Callback} cb)
\item 
virtual bool \hyperlink{classns3_1_1CsmaNetDevice_ad660af503a5fb898d8f07507159c82d3}{Supports\+Send\+From} (void) const 
\item 
int64\+\_\+t \hyperlink{classns3_1_1CsmaNetDevice_a7eecd9876d8d0642fc403867e5fa1cb4}{Assign\+Streams} (int64\+\_\+t stream)
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1CsmaNetDevice_aee49acd8c695a21662f2111c7771e92b}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1CsmaNetDevice_a9d516f357637bc0994c3babadd5f14e7}{Do\+Dispose} (void)
\item 
void \hyperlink{classns3_1_1CsmaNetDevice_a736bf6ce5851ace677f8fc693a92855c}{Add\+Header} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} source, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} dest, uint16\+\_\+t protocol\+Number)
\item 
virtual void \hyperlink{classns3_1_1CsmaNetDevice_a2632c23827564f42d14b5c512db9314e}{Do\+Initialize} (void)
\item 
virtual void \hyperlink{classns3_1_1CsmaNetDevice_a45857b94ade04508597e30ab15b9963c}{Notify\+New\+Aggregate} (void)
\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4}{Tx\+Machine\+State} \{ \hyperlink{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4a50a4f4ac7775f95f3ec1d4624213bee2}{R\+E\+A\+DY}, 
\hyperlink{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4a84e62edebfa7e85ec23402f94bb1361a}{B\+U\+SY}, 
\hyperlink{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4ab6c58ad6a7f71f004ea78a8ccb9362c6}{G\+AP}, 
\hyperlink{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4a415034117cf23985cd8d3481944cd731}{B\+A\+C\+K\+O\+FF}
 \}
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1CsmaNetDevice}{Csma\+Net\+Device} \& \hyperlink{classns3_1_1CsmaNetDevice_a388accd5aee7b7aca18d458e4135198f}{operator=} (const \hyperlink{classns3_1_1CsmaNetDevice}{Csma\+Net\+Device} \&o)
\item 
\hyperlink{classns3_1_1CsmaNetDevice_a7fab551359f930d9b3884efb43a261c5}{Csma\+Net\+Device} (const \hyperlink{classns3_1_1CsmaNetDevice}{Csma\+Net\+Device} \&o)
\item 
void \hyperlink{classns3_1_1CsmaNetDevice_a566f2c2362d412be7c3c20e2f115842a}{Init} (bool send\+Enable, bool receive\+Enable)
\item 
void \hyperlink{classns3_1_1CsmaNetDevice_a4120db41aa1f41a5e1d59220b306f1e8}{Transmit\+Start} ()
\item 
void \hyperlink{classns3_1_1CsmaNetDevice_a3f908850087739df8d27e1a7207261aa}{Transmit\+Complete\+Event} (void)
\item 
void \hyperlink{classns3_1_1CsmaNetDevice_a2cb06577684f06daca6c24b4ef4e8910}{Transmit\+Ready\+Event} (void)
\item 
void \hyperlink{classns3_1_1CsmaNetDevice_ac6b19bd1a3d2f257a56c3bf8e026ad88}{Transmit\+Abort} (void)
\item 
void \hyperlink{classns3_1_1CsmaNetDevice_a4d01c6da5e8a31af9c3c8ff7bbe0e022}{Notify\+Link\+Up} (void)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
uint32\+\_\+t \hyperlink{classns3_1_1CsmaNetDevice_a8cfc188ed680554dfa0b70cc6fc5e5ba}{m\+\_\+device\+Id}
\item 
bool \hyperlink{classns3_1_1CsmaNetDevice_ac5bde9af7f582a6d707a68061c114fdf}{m\+\_\+send\+Enable}
\item 
bool \hyperlink{classns3_1_1CsmaNetDevice_a8d844dcce78846a16c9a52c752f9736f}{m\+\_\+receive\+Enable}
\item 
\hyperlink{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4}{Tx\+Machine\+State} \hyperlink{classns3_1_1CsmaNetDevice_af07031cad3f8bd8c4b33ba77fa706e99}{m\+\_\+tx\+Machine\+State}
\item 
\hyperlink{classns3_1_1CsmaNetDevice_a176431468055d41f8e879e33a5362cad}{Encapsulation\+Mode} \hyperlink{classns3_1_1CsmaNetDevice_a3f4b374840119abfa65dbe2075533f39}{m\+\_\+encap\+Mode}
\item 
\hyperlink{classns3_1_1DataRate}{Data\+Rate} \hyperlink{classns3_1_1CsmaNetDevice_a3051c17d676b00f0b2e95291d16c3769}{m\+\_\+bps}
\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1CsmaNetDevice_ae581d7910d91ab9aaf760288ccf75c55}{m\+\_\+t\+Interframe\+Gap}
\item 
\hyperlink{classns3_1_1Backoff}{Backoff} \hyperlink{classns3_1_1CsmaNetDevice_a2cb5f9baf0a19a7ea6527002b0299403}{m\+\_\+backoff}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\+\_\+current\+Pkt}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1CsmaChannel}{Csma\+Channel} $>$ \hyperlink{classns3_1_1CsmaNetDevice_a5c3ecdf9a63006b106dff1c110e736ff}{m\+\_\+channel}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Queue}{Queue}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1CsmaNetDevice_a499be4029c01107f7f16f5371843ffde}{m\+\_\+queue}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1ErrorModel}{Error\+Model} $>$ \hyperlink{classns3_1_1CsmaNetDevice_aeef9196f9c7c46c99a7f703dc46c0207}{m\+\_\+receive\+Error\+Model}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1CsmaNetDevice_acd8f03ea3f02befd6caa2b07065ac80a}{m\+\_\+mac\+Tx\+Trace}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1CsmaNetDevice_ac6e2a81eedea1fa443600bbac37842b2}{m\+\_\+mac\+Tx\+Drop\+Trace}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1CsmaNetDevice_a4b22f431d8511abaf9ef4e92cc41ce24}{m\+\_\+mac\+Promisc\+Rx\+Trace}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1CsmaNetDevice_a40f2a9fcb15d1e44fc918d1639bff18a}{m\+\_\+mac\+Rx\+Trace}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1CsmaNetDevice_a0ba6e9b6d9403e55044c695ece47e311}{m\+\_\+mac\+Rx\+Drop\+Trace}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1CsmaNetDevice_a1f035d24ccf03e5731243e0b22665cb0}{m\+\_\+mac\+Tx\+Backoff\+Trace}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1CsmaNetDevice_a6c5deac5e6a05a2013175402d4e22985}{m\+\_\+phy\+Tx\+Begin\+Trace}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1CsmaNetDevice_a8cac1ff27eec4db589ed00545f942a21}{m\+\_\+phy\+Tx\+End\+Trace}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1CsmaNetDevice_ad2a07cf80f83d9ce17d9280775e9a1f8}{m\+\_\+phy\+Tx\+Drop\+Trace}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1CsmaNetDevice_abdbb5dd4d62426a5ad0f6cb8cb030b3b}{m\+\_\+phy\+Rx\+Begin\+Trace}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1CsmaNetDevice_afe2bac4b10c5d73f78e11668a3e6a679}{m\+\_\+phy\+Rx\+End\+Trace}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1CsmaNetDevice_a9413b693a3028dcccb20f653bad58bc0}{m\+\_\+phy\+Rx\+Drop\+Trace}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1CsmaNetDevice_a88e5994b762e01f74606742a7f15b797}{m\+\_\+sniffer\+Trace}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1CsmaNetDevice_aae7fbd28077e7ac8efee738c4194ed16}{m\+\_\+promisc\+Sniffer\+Trace}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1CsmaNetDevice_a9dbd678469e1b1efe74a45b868ead509}{m\+\_\+node}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDeviceQueueInterface}{Net\+Device\+Queue\+Interface} $>$ \hyperlink{classns3_1_1CsmaNetDevice_a93a7be08d44dbabfdf111e90feb7c72a}{m\+\_\+queue\+Interface}
\item 
\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} \hyperlink{classns3_1_1CsmaNetDevice_ae26602a3eb4e97c0aa39ae61b4d028f8}{m\+\_\+address}
\item 
\hyperlink{classns3_1_1NetDevice_ad5e5e1ca187472bc2ba99575d8def568}{Net\+Device\+::\+Receive\+Callback} \hyperlink{classns3_1_1CsmaNetDevice_a18646390c167ad8f0f8b8795a9052031}{m\+\_\+rx\+Callback}
\item 
\hyperlink{classns3_1_1NetDevice_a427225795919f26c414bee2ea3f31ed2}{Net\+Device\+::\+Promisc\+Receive\+Callback} \hyperlink{classns3_1_1CsmaNetDevice_a4c9c0533341d76fe278fbef18525b228}{m\+\_\+promisc\+Rx\+Callback}
\item 
uint32\+\_\+t \hyperlink{classns3_1_1CsmaNetDevice_af2bb0a9e64ae4ee179256f480e4eed4e}{m\+\_\+if\+Index}
\item 
bool \hyperlink{classns3_1_1CsmaNetDevice_afc0b0c430b9ee8e8ddde196c340b5764}{m\+\_\+link\+Up}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback} \hyperlink{classns3_1_1CsmaNetDevice_a67dd7e65384a1b9f89dfacc1ede41d69}{m\+\_\+link\+Change\+Callbacks}
\item 
uint32\+\_\+t \hyperlink{classns3_1_1CsmaNetDevice_a4b2e70ee2ee42f63f3756728ec592bc1}{m\+\_\+mtu}
\end{DoxyCompactItemize}
\subsection*{Static Private Attributes}
\begin{DoxyCompactItemize}
\item 
static const uint16\+\_\+t \hyperlink{classns3_1_1CsmaNetDevice_aba1a157c1695a4c02b4dcba3490217e4}{D\+E\+F\+A\+U\+L\+T\+\_\+\+M\+TU} = 1500
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
A Device for a Csma Network Link. 

The Csma net device class is analogous to layer 1 and 2 of the T\+CP stack. The \hyperlink{classns3_1_1NetDevice}{Net\+Device} takes a raw packet of bytes and creates a protocol specific packet from them. 

\subsection{Member Enumeration Documentation}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Encapsulation\+Mode@{Encapsulation\+Mode}}
\index{Encapsulation\+Mode@{Encapsulation\+Mode}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Encapsulation\+Mode}{EncapsulationMode}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf ns3\+::\+Csma\+Net\+Device\+::\+Encapsulation\+Mode}}\hypertarget{classns3_1_1CsmaNetDevice_a176431468055d41f8e879e33a5362cad}{}\label{classns3_1_1CsmaNetDevice_a176431468055d41f8e879e33a5362cad}
Enumeration of the types of packets supported in the class. \begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{I\+L\+L\+E\+G\+AL@{I\+L\+L\+E\+G\+AL}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!I\+L\+L\+E\+G\+AL@{I\+L\+L\+E\+G\+AL}}\item[{\em 
I\+L\+L\+E\+G\+AL\hypertarget{classns3_1_1CsmaNetDevice_a176431468055d41f8e879e33a5362cada1f230eaef80ea65f838f089c07981bad}{}\label{classns3_1_1CsmaNetDevice_a176431468055d41f8e879e33a5362cada1f230eaef80ea65f838f089c07981bad}
}]Encapsulation mode not set \index{D\+IX@{D\+IX}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!D\+IX@{D\+IX}}\item[{\em 
D\+IX\hypertarget{classns3_1_1CsmaNetDevice_a176431468055d41f8e879e33a5362cada8cc8287029197a9496df00c6d3f8b9ff}{}\label{classns3_1_1CsmaNetDevice_a176431468055d41f8e879e33a5362cada8cc8287029197a9496df00c6d3f8b9ff}
}]D\+IX II / Ethernet II packet \index{L\+LC@{L\+LC}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!L\+LC@{L\+LC}}\item[{\em 
L\+LC\hypertarget{classns3_1_1CsmaNetDevice_a176431468055d41f8e879e33a5362cadab3a0dd08ede5405aff1fd939e556dc5b}{}\label{classns3_1_1CsmaNetDevice_a176431468055d41f8e879e33a5362cadab3a0dd08ede5405aff1fd939e556dc5b}
}]802.\+2 L\+L\+C/\+S\+N\+AP \hyperlink{classns3_1_1Packet}{Packet} \end{description}
\end{Desc}

\begin{DoxyCode}
72                          \{
73     \hyperlink{classns3_1_1CsmaNetDevice_a176431468055d41f8e879e33a5362cada1f230eaef80ea65f838f089c07981bad}{ILLEGAL},     
74     \hyperlink{classns3_1_1CsmaNetDevice_a176431468055d41f8e879e33a5362cada8cc8287029197a9496df00c6d3f8b9ff}{DIX},         
75     \hyperlink{classns3_1_1CsmaNetDevice_a176431468055d41f8e879e33a5362cadab3a0dd08ede5405aff1fd939e556dc5b}{LLC},         
76   \};
\end{DoxyCode}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Tx\+Machine\+State@{Tx\+Machine\+State}}
\index{Tx\+Machine\+State@{Tx\+Machine\+State}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Tx\+Machine\+State}{TxMachineState}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf ns3\+::\+Csma\+Net\+Device\+::\+Tx\+Machine\+State}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4}{}\label{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4}
Enumeration of the states of the transmit machine of the net device. \begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{R\+E\+A\+DY@{R\+E\+A\+DY}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!R\+E\+A\+DY@{R\+E\+A\+DY}}\item[{\em 
R\+E\+A\+DY\hypertarget{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4a50a4f4ac7775f95f3ec1d4624213bee2}{}\label{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4a50a4f4ac7775f95f3ec1d4624213bee2}
}]The transmitter is ready to begin transmission of a packet \index{B\+U\+SY@{B\+U\+SY}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!B\+U\+SY@{B\+U\+SY}}\item[{\em 
B\+U\+SY\hypertarget{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4a84e62edebfa7e85ec23402f94bb1361a}{}\label{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4a84e62edebfa7e85ec23402f94bb1361a}
}]The transmitter is busy transmitting a packet \index{G\+AP@{G\+AP}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!G\+AP@{G\+AP}}\item[{\em 
G\+AP\hypertarget{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4ab6c58ad6a7f71f004ea78a8ccb9362c6}{}\label{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4ab6c58ad6a7f71f004ea78a8ccb9362c6}
}]The transmitter is in the interframe gap time \index{B\+A\+C\+K\+O\+FF@{B\+A\+C\+K\+O\+FF}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!B\+A\+C\+K\+O\+FF@{B\+A\+C\+K\+O\+FF}}\item[{\em 
B\+A\+C\+K\+O\+FF\hypertarget{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4a415034117cf23985cd8d3481944cd731}{}\label{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4a415034117cf23985cd8d3481944cd731}
}]The transmitter is waiting for the channel to be free \end{description}
\end{Desc}

\begin{DoxyCode}
475   \{
476     \hyperlink{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4a50a4f4ac7775f95f3ec1d4624213bee2}{READY},   
477     \hyperlink{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4a84e62edebfa7e85ec23402f94bb1361a}{BUSY},    
478     \hyperlink{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4ab6c58ad6a7f71f004ea78a8ccb9362c6}{GAP},      
479     \hyperlink{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4a415034117cf23985cd8d3481944cd731}{BACKOFF}      
480   \};
\end{DoxyCode}


\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Csma\+Net\+Device@{Csma\+Net\+Device}}
\index{Csma\+Net\+Device@{Csma\+Net\+Device}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Csma\+Net\+Device()}{CsmaNetDevice()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Csma\+Net\+Device\+::\+Csma\+Net\+Device (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1CsmaNetDevice_a5005a5403e112dad6ecd2922a9065916}{}\label{classns3_1_1CsmaNetDevice_a5005a5403e112dad6ecd2922a9065916}
Construct a \hyperlink{classns3_1_1CsmaNetDevice}{Csma\+Net\+Device}

This is the default constructor for a \hyperlink{classns3_1_1CsmaNetDevice}{Csma\+Net\+Device}. 
\begin{DoxyCode}
188   : \hyperlink{classns3_1_1CsmaNetDevice_afc0b0c430b9ee8e8ddde196c340b5764}{m\_linkUp} (\textcolor{keyword}{false})
189 \{
190   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
191   \hyperlink{classns3_1_1CsmaNetDevice_af07031cad3f8bd8c4b33ba77fa706e99}{m\_txMachineState} = \hyperlink{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4a50a4f4ac7775f95f3ec1d4624213bee2}{READY};
192   \hyperlink{classns3_1_1CsmaNetDevice_ae581d7910d91ab9aaf760288ccf75c55}{m\_tInterframeGap} = \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (0);
193   \hyperlink{classns3_1_1CsmaNetDevice_a5c3ecdf9a63006b106dff1c110e736ff}{m\_channel} = 0;
194 
195   \textcolor{comment}{// }
196   \textcolor{comment}{// We would like to let the attribute system take care of initializing the }
197   \textcolor{comment}{// packet encapsulation stuff, but we also don't want to get caught up in}
198   \textcolor{comment}{// initialization order changes.  So we'll get the three problem variables}
199   \textcolor{comment}{// into a consistent state here before the attribute calls, and then depend}
200   \textcolor{comment}{// on the semantics of the setters to preserve a consistent state.  This }
201   \textcolor{comment}{// really doesn't have to be the same set of values as the initial values }
202   \textcolor{comment}{// set by the attributes, but it does have to be a consistent set.  That is,}
203   \textcolor{comment}{// you can just change the default encapsulation mode above without having }
204   \textcolor{comment}{// to change it here.}
205   \textcolor{comment}{//}
206   \hyperlink{classns3_1_1CsmaNetDevice_a3f4b374840119abfa65dbe2075533f39}{m\_encapMode} = \hyperlink{classns3_1_1CsmaNetDevice_a176431468055d41f8e879e33a5362cada8cc8287029197a9496df00c6d3f8b9ff}{DIX};
207 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!````~Csma\+Net\+Device@{$\sim$\+Csma\+Net\+Device}}
\index{````~Csma\+Net\+Device@{$\sim$\+Csma\+Net\+Device}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{$\sim$\+Csma\+Net\+Device()}{~CsmaNetDevice()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Csma\+Net\+Device\+::$\sim$\+Csma\+Net\+Device (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1CsmaNetDevice_af1c8ebf5c098c264e248d025ead3c6a4}{}\label{classns3_1_1CsmaNetDevice_af1c8ebf5c098c264e248d025ead3c6a4}
Destroy a \hyperlink{classns3_1_1CsmaNetDevice}{Csma\+Net\+Device}

This is the destructor for a \hyperlink{classns3_1_1CsmaNetDevice}{Csma\+Net\+Device}. 
\begin{DoxyCode}
210 \{
211   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
212   \hyperlink{classns3_1_1CsmaNetDevice_a499be4029c01107f7f16f5371843ffde}{m\_queue} = 0;
213 \}
\end{DoxyCode}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Csma\+Net\+Device@{Csma\+Net\+Device}}
\index{Csma\+Net\+Device@{Csma\+Net\+Device}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Csma\+Net\+Device(const Csma\+Net\+Device \&o)}{CsmaNetDevice(const CsmaNetDevice &o)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Csma\+Net\+Device\+::\+Csma\+Net\+Device (
\begin{DoxyParamCaption}
\item[{const {\bf Csma\+Net\+Device} \&}]{o}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_a7fab551359f930d9b3884efb43a261c5}{}\label{classns3_1_1CsmaNetDevice_a7fab551359f930d9b3884efb43a261c5}
Copy constructor is declared but not implemented. This disables the copy constructor for \hyperlink{classns3_1_1CsmaNetDevice}{Csma\+Net\+Device} objects. 
\begin{DoxyParams}{Parameters}
{\em o} & object to copy \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Add\+Header@{Add\+Header}}
\index{Add\+Header@{Add\+Header}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Add\+Header(\+Ptr$<$ Packet $>$ p, Mac48\+Address source, Mac48\+Address dest, uint16\+\_\+t protocol\+Number)}{AddHeader(Ptr< Packet > p, Mac48Address source, Mac48Address dest, uint16_t protocolNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Csma\+Net\+Device\+::\+Add\+Header (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{{\bf Mac48\+Address}}]{source, }
\item[{{\bf Mac48\+Address}}]{dest, }
\item[{uint16\+\_\+t}]{protocol\+Number}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classns3_1_1CsmaNetDevice_a736bf6ce5851ace677f8fc693a92855c}{}\label{classns3_1_1CsmaNetDevice_a736bf6ce5851ace677f8fc693a92855c}
Adds the necessary headers and trailers to a packet of data in order to respect the packet type


\begin{DoxyParams}{Parameters}
{\em p} & \hyperlink{classns3_1_1Packet}{Packet} to which header should be added \\
\hline
{\em source} & M\+AC source address from which packet should be sent \\
\hline
{\em dest} & M\+AC destination address to which packet should be sent \\
\hline
{\em protocol\+Number} & In some protocols, identifies the type of payload contained in this packet. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
346 \{
347   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (p << source << dest << protocolNumber);
348 
349   EthernetHeader header (\textcolor{keyword}{false});
350   header.SetSource (source);
351   header.SetDestination (dest);
352 
353   EthernetTrailer trailer;
354 
355   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"p->GetSize () = "} << p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ());
356   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"m\_encapMode = "} << \hyperlink{classns3_1_1CsmaNetDevice_a3f4b374840119abfa65dbe2075533f39}{m\_encapMode});
357   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"m\_mtu = "} << \hyperlink{classns3_1_1CsmaNetDevice_a4b2e70ee2ee42f63f3756728ec592bc1}{m\_mtu});
358 
359   uint16\_t lengthType = 0;
360   \textcolor{keywordflow}{switch} (\hyperlink{classns3_1_1CsmaNetDevice_a3f4b374840119abfa65dbe2075533f39}{m\_encapMode}) 
361     \{
362     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1CsmaNetDevice_a176431468055d41f8e879e33a5362cada8cc8287029197a9496df00c6d3f8b9ff}{DIX}:
363       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Encapsulating packet as DIX (type interpretation)"});
364       \textcolor{comment}{//}
365       \textcolor{comment}{// This corresponds to the type interpretation of the lengthType field as}
366       \textcolor{comment}{// in the old Ethernet Blue Book.}
367       \textcolor{comment}{//}
368       lengthType = protocolNumber;
369 
370       \textcolor{comment}{//}
371       \textcolor{comment}{// All Ethernet frames must carry a minimum payload of 46 bytes.  We need}
372       \textcolor{comment}{// to pad out if we don't have enough bytes.  These must be real bytes }
373       \textcolor{comment}{// since they will be written to pcap files and compared in regression }
374       \textcolor{comment}{// trace files.}
375       \textcolor{comment}{//}
376       \textcolor{keywordflow}{if} (p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} () < 46)
377         \{
378           uint8\_t buffer[46];
379           memset (buffer, 0, 46);
380           Ptr<Packet> padd = Create<Packet> (buffer, 46 - p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ());
381           p->\hyperlink{classns3_1_1Packet_a14ec3d4250b425468764de58f5837b6b}{AddAtEnd} (padd);
382         \}
383       \textcolor{keywordflow}{break};
384     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1CsmaNetDevice_a176431468055d41f8e879e33a5362cadab3a0dd08ede5405aff1fd939e556dc5b}{LLC}: 
385       \{
386         \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Encapsulating packet as LLC (length interpretation)"});
387 
388         LlcSnapHeader llc;
389         llc.SetType (protocolNumber);
390         p->\hyperlink{classns3_1_1Packet_a465108c595a0bc592095cbcab1832ed8}{AddHeader} (llc);
391 
392         \textcolor{comment}{//}
393         \textcolor{comment}{// This corresponds to the length interpretation of the lengthType }
394         \textcolor{comment}{// field but with an LLC/SNAP header added to the payload as in }
395         \textcolor{comment}{// IEEE 802.2}
396         \textcolor{comment}{//}
397         lengthType = p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ();
398 
399         \textcolor{comment}{//}
400         \textcolor{comment}{// All Ethernet frames must carry a minimum payload of 46 bytes.  The }
401         \textcolor{comment}{// LLC SNAP header counts as part of this payload.  We need to padd out}
402         \textcolor{comment}{// if we don't have enough bytes.  These must be real bytes since they }
403         \textcolor{comment}{// will be written to pcap files and compared in regression trace files.}
404         \textcolor{comment}{//}
405         \textcolor{keywordflow}{if} (p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} () < 46)
406           \{
407             uint8\_t buffer[46];
408             memset (buffer, 0, 46);
409             Ptr<Packet> padd = Create<Packet> (buffer, 46 - p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ());
410             p->\hyperlink{classns3_1_1Packet_a14ec3d4250b425468764de58f5837b6b}{AddAtEnd} (padd);
411           \}
412 
413         \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (p->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} () <= \hyperlink{classns3_1_1CsmaNetDevice_a4c27c177803c2efbea66c14b66babd84}{GetMtu} (),
414                        \textcolor{stringliteral}{"CsmaNetDevice::AddHeader(): 802.3 Length/Type field with LLC/SNAP: "}
415                        \textcolor{stringliteral}{"length interpretation must not exceed device frame size minus overhead"});
416       \}
417       \textcolor{keywordflow}{break};
418     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1CsmaNetDevice_a176431468055d41f8e879e33a5362cada1f230eaef80ea65f838f089c07981bad}{ILLEGAL}:
419     \textcolor{keywordflow}{default}:
420       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"CsmaNetDevice::AddHeader(): Unknown packet encapsulation mode"});
421       \textcolor{keywordflow}{break};
422     \}
423 
424   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"header.SetLengthType ("} << lengthType << \textcolor{stringliteral}{")"});
425   header.SetLengthType (lengthType);
426   p->\hyperlink{classns3_1_1Packet_a465108c595a0bc592095cbcab1832ed8}{AddHeader} (header);
427 
428   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Node_a0515bfe9a3aeb6605d657ba855699815}{Node::ChecksumEnabled} ())
429     \{
430       trailer.EnableFcs (\textcolor{keyword}{true});
431     \}
432   trailer.CalcFcs (p);
433   p->\hyperlink{classns3_1_1Packet_ae26b490c30ae5bc98be5181ec6e06db8}{AddTrailer} (trailer);
434 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3




Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Add\+Link\+Change\+Callback@{Add\+Link\+Change\+Callback}}
\index{Add\+Link\+Change\+Callback@{Add\+Link\+Change\+Callback}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Add\+Link\+Change\+Callback(\+Callback$<$ void $>$ callback)}{AddLinkChangeCallback(Callback< void > callback)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Csma\+Net\+Device\+::\+Add\+Link\+Change\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Callback}$<$ void $>$}]{callback}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1CsmaNetDevice_a9d03e26036a3f29d584baa12bd7e14a5}{}\label{classns3_1_1CsmaNetDevice_a9d03e26036a3f29d584baa12bd7e14a5}

\begin{DoxyParams}{Parameters}
{\em callback} & the callback to invoke\\
\hline
\end{DoxyParams}
Add a callback invoked whenever the link status changes to UP. This callback is typically used by the I\+P/\+A\+RP layer to flush the A\+RP cache and by I\+Pv6 stack to flush N\+D\+I\+SC cache whenever the link goes up. 

Implements \hyperlink{classns3_1_1NetDevice_aafb1bf869d38ef7a7112d11fab0163a3}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
918 \{
919   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (&callback);
920   \hyperlink{classns3_1_1CsmaNetDevice_a67dd7e65384a1b9f89dfacc1ede41d69}{m\_linkChangeCallbacks}.\hyperlink{classns3_1_1TracedCallback_aacc251bf4e302e7d034e9f0e25a15980}{ConnectWithoutContext} (callback);
921 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5


\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Assign\+Streams@{Assign\+Streams}}
\index{Assign\+Streams@{Assign\+Streams}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Assign\+Streams(int64\+\_\+t stream)}{AssignStreams(int64_t stream)}}]{\setlength{\rightskip}{0pt plus 5cm}int64\+\_\+t ns3\+::\+Csma\+Net\+Device\+::\+Assign\+Streams (
\begin{DoxyParamCaption}
\item[{int64\+\_\+t}]{stream}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1CsmaNetDevice_a7eecd9876d8d0642fc403867e5fa1cb4}{}\label{classns3_1_1CsmaNetDevice_a7eecd9876d8d0642fc403867e5fa1cb4}
Assign a fixed random variable stream number to the random variables used by this model. Return the number of streams (possibly zero) that have been assigned.


\begin{DoxyParams}{Parameters}
{\em stream} & first stream index to use \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of stream indices assigned by this model 
\end{DoxyReturn}

\begin{DoxyCode}
1089 \{
1090   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1CsmaNetDevice_a2cb5f9baf0a19a7ea6527002b0299403}{m\_backoff}.\hyperlink{classns3_1_1Backoff_a5227e2034c6a5b54fd3ea59ed2be2c93}{AssignStreams} (stream);
1091 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6


\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Attach@{Attach}}
\index{Attach@{Attach}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Attach(\+Ptr$<$ Csma\+Channel $>$ ch)}{Attach(Ptr< CsmaChannel > ch)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Csma\+Net\+Device\+::\+Attach (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Csma\+Channel} $>$}]{ch}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1CsmaNetDevice_a5e24813945deeace8e8abe4ede602278}{}\label{classns3_1_1CsmaNetDevice_a5e24813945deeace8e8abe4ede602278}
Attach the device to a channel.

The function Attach is used to add a \hyperlink{classns3_1_1CsmaNetDevice}{Csma\+Net\+Device} to a \hyperlink{classns3_1_1CsmaChannel}{Csma\+Channel}.

\begin{DoxySeeAlso}{See also}
Set\+Data\+Rate () 

\hyperlink{classns3_1_1CsmaNetDevice_a03c6e2194fff14f295c234aa9e4c1cdd}{Set\+Interframe\+Gap} () 
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em ch} & a pointer to the channel to which this object is being attached. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if no error 
\end{DoxyReturn}

\begin{DoxyCode}
684 \{
685   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << &ch);
686 
687   \hyperlink{classns3_1_1CsmaNetDevice_a5c3ecdf9a63006b106dff1c110e736ff}{m\_channel} = ch;
688 
689   \hyperlink{classns3_1_1CsmaNetDevice_a8cfc188ed680554dfa0b70cc6fc5e5ba}{m\_deviceId} = \hyperlink{classns3_1_1CsmaNetDevice_a5c3ecdf9a63006b106dff1c110e736ff}{m\_channel}->Attach (\textcolor{keyword}{this});
690 
691   \textcolor{comment}{//}
692   \textcolor{comment}{// The channel provides us with the transmitter data rate.}
693   \textcolor{comment}{//}
694   \hyperlink{classns3_1_1CsmaNetDevice_a3051c17d676b00f0b2e95291d16c3769}{m\_bps} = \hyperlink{classns3_1_1CsmaNetDevice_a5c3ecdf9a63006b106dff1c110e736ff}{m\_channel}->GetDataRate ();
695 
696   \textcolor{comment}{//}
697   \textcolor{comment}{// We use the Ethernet interframe gap of 96 bit times.}
698   \textcolor{comment}{//}
699   \hyperlink{classns3_1_1CsmaNetDevice_ae581d7910d91ab9aaf760288ccf75c55}{m\_tInterframeGap} = \hyperlink{classns3_1_1CsmaNetDevice_a3051c17d676b00f0b2e95291d16c3769}{m\_bps}.\hyperlink{classns3_1_1DataRate_a5daa3d3b37b7df8bb75d94a6540fd17e}{CalculateBytesTxTime} (96/8);
700 
701   \textcolor{comment}{//}
702   \textcolor{comment}{// This device is up whenever a channel is attached to it.}
703   \textcolor{comment}{//}
704   \hyperlink{classns3_1_1CsmaNetDevice_a4d01c6da5e8a31af9c3c8ff7bbe0e022}{NotifyLinkUp} ();
705   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
706 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7


\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Do\+Dispose(void)}{DoDispose(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Csma\+Net\+Device\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1CsmaNetDevice_a9d516f357637bc0994c3babadd5f14e7}{}\label{classns3_1_1CsmaNetDevice_a9d516f357637bc0994c3babadd5f14e7}
Perform any object release functionality required to break reference cycles in reference counted objects held by the device. 

Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.


\begin{DoxyCode}
217 \{
218   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
219   \hyperlink{classns3_1_1CsmaNetDevice_a5c3ecdf9a63006b106dff1c110e736ff}{m\_channel} = 0;
220   \hyperlink{classns3_1_1CsmaNetDevice_a9dbd678469e1b1efe74a45b868ead509}{m\_node} = 0;
221   \hyperlink{classns3_1_1CsmaNetDevice_a499be4029c01107f7f16f5371843ffde}{m\_queue} = 0;
222   \hyperlink{classns3_1_1CsmaNetDevice_a93a7be08d44dbabfdf111e90feb7c72a}{m\_queueInterface} = 0;
223   \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{NetDevice::DoDispose} ();
224 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8


\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Do\+Initialize@{Do\+Initialize}}
\index{Do\+Initialize@{Do\+Initialize}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Do\+Initialize(void)}{DoInitialize(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Csma\+Net\+Device\+::\+Do\+Initialize (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1CsmaNetDevice_a2632c23827564f42d14b5c512db9314e}{}\label{classns3_1_1CsmaNetDevice_a2632c23827564f42d14b5c512db9314e}
\hyperlink{classns3_1_1Object_af4411cb29971772fcd09203474a95078}{Initialize()} implementation.

This method is called only once by \hyperlink{classns3_1_1Object_af4411cb29971772fcd09203474a95078}{Initialize()}. If the user calls \hyperlink{classns3_1_1Object_af4411cb29971772fcd09203474a95078}{Initialize()} multiple times, \hyperlink{classns3_1_1CsmaNetDevice_a2632c23827564f42d14b5c512db9314e}{Do\+Initialize()} is called only the first time.

Subclasses are expected to override this method and chain up to their parent\textquotesingle{}s implementation once they are done. It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} and \hyperlink{classns3_1_1Object_a79dd435d300f3deca814553f561a2922}{Aggregate\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_af8482a521433409fb5c7f749398c9dbe}{ns3\+::\+Object}.


\begin{DoxyCode}
228 \{
229   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1CsmaNetDevice_a93a7be08d44dbabfdf111e90feb7c72a}{m\_queueInterface})
230     \{
231       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\hyperlink{classns3_1_1CsmaNetDevice_a499be4029c01107f7f16f5371843ffde}{m\_queue} != 0, \textcolor{stringliteral}{"A Queue object has not been attached to the device"}
      );
232 
233       \textcolor{comment}{// connect the traced callbacks of m\_queue to the static methods provided by}
234       \textcolor{comment}{// the NetDeviceQueue class to support flow control and dynamic queue limits.}
235       \textcolor{comment}{// This could not be done in NotifyNewAggregate because at that time we are}
236       \textcolor{comment}{// not guaranteed that a queue has been attached to the netdevice}
237       \hyperlink{classns3_1_1CsmaNetDevice_a93a7be08d44dbabfdf111e90feb7c72a}{m\_queueInterface}->ConnectQueueTraces (\hyperlink{classns3_1_1CsmaNetDevice_a499be4029c01107f7f16f5371843ffde}{m\_queue}, 0);
238     \}
239 
240   \hyperlink{classns3_1_1Object_af8482a521433409fb5c7f749398c9dbe}{NetDevice::DoInitialize} ();
241 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9


\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Get\+Address@{Get\+Address}}
\index{Get\+Address@{Get\+Address}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Address(void) const }{GetAddress(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Csma\+Net\+Device\+::\+Get\+Address (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1CsmaNetDevice_ae3352827049c29ccee336f2c7fb98182}{}\label{classns3_1_1CsmaNetDevice_ae3352827049c29ccee336f2c7fb98182}
\begin{DoxyReturn}{Returns}
the current \hyperlink{classns3_1_1Address}{Address} of this interface. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a671f99de496d6f09ae343bb715301fb2}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
904 \{
905   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
906   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1CsmaNetDevice_ae26602a3eb4e97c0aa39ae61b4d028f8}{m\_address};
907 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 10


\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Get\+Broadcast@{Get\+Broadcast}}
\index{Get\+Broadcast@{Get\+Broadcast}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Broadcast(void) const }{GetBroadcast(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Csma\+Net\+Device\+::\+Get\+Broadcast (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1CsmaNetDevice_aebadc0653f18569208a61013cfe36947}{}\label{classns3_1_1CsmaNetDevice_aebadc0653f18569208a61013cfe36947}
\begin{DoxyReturn}{Returns}
the broadcast address supported by this netdevice.
\end{DoxyReturn}
Calling this method is invalid if Is\+Broadcast returns not true. 

Implements \hyperlink{classns3_1_1NetDevice_a4724e03bc548dd8e967cc4a7356197bd}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
932 \{
933   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
934   \textcolor{keywordflow}{return} Mac48Address (\textcolor{stringliteral}{"ff:ff:ff:ff:ff:ff"});
935 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Get\+Channel@{Get\+Channel}}
\index{Get\+Channel@{Get\+Channel}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Channel(void) const }{GetChannel(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Channel} $>$ ns3\+::\+Csma\+Net\+Device\+::\+Get\+Channel (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1CsmaNetDevice_ab4eaccd57e3fc31b49197632bd53933f}{}\label{classns3_1_1CsmaNetDevice_ab4eaccd57e3fc31b49197632bd53933f}
\begin{DoxyReturn}{Returns}
the channel this \hyperlink{classns3_1_1NetDevice}{Net\+Device} is connected to. The value returned can be zero if the \hyperlink{classns3_1_1NetDevice}{Net\+Device} is not yet connected to any channel or if the underlying \hyperlink{classns3_1_1NetDevice}{Net\+Device} has no concept of a channel. i.\+e., callers {\itshape must} check for zero and be ready to handle it. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a3d810bd2738634e2e851661271828565}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
890 \{
891   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
892   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1CsmaNetDevice_a5c3ecdf9a63006b106dff1c110e736ff}{m\_channel};
893 \}
\end{DoxyCode}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Get\+Encapsulation\+Mode@{Get\+Encapsulation\+Mode}}
\index{Get\+Encapsulation\+Mode@{Get\+Encapsulation\+Mode}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Encapsulation\+Mode(void)}{GetEncapsulationMode(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Csma\+Net\+Device\+::\+Encapsulation\+Mode} ns3\+::\+Csma\+Net\+Device\+::\+Get\+Encapsulation\+Mode (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1CsmaNetDevice_a51819cee730b7c8f68d1ec277a986a8a}{}\label{classns3_1_1CsmaNetDevice_a51819cee730b7c8f68d1ec277a986a8a}
Get the encapsulation mode of this device.

\begin{DoxyReturn}{Returns}
The encapsulation mode of this device. 
\end{DoxyReturn}

\begin{DoxyCode}
273 \{
274   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
275   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1CsmaNetDevice_a3f4b374840119abfa65dbe2075533f39}{m\_encapMode};
276 \}
\end{DoxyCode}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Get\+If\+Index@{Get\+If\+Index}}
\index{Get\+If\+Index@{Get\+If\+Index}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+If\+Index(void) const }{GetIfIndex(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Csma\+Net\+Device\+::\+Get\+If\+Index (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1CsmaNetDevice_a0a2ec345a46446edcd4c829980abc837}{}\label{classns3_1_1CsmaNetDevice_a0a2ec345a46446edcd4c829980abc837}
\begin{DoxyReturn}{Returns}
index if\+Index of the device 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a8c1ae2ec8eadc4524dfc1e425bfa0850}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
883 \{
884   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
885   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1CsmaNetDevice_af2bb0a9e64ae4ee179256f480e4eed4e}{m\_ifIndex};
886 \}
\end{DoxyCode}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Get\+Mtu@{Get\+Mtu}}
\index{Get\+Mtu@{Get\+Mtu}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Mtu(void) const }{GetMtu(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Csma\+Net\+Device\+::\+Get\+Mtu (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1CsmaNetDevice_a4c27c177803c2efbea66c14b66babd84}{}\label{classns3_1_1CsmaNetDevice_a4c27c177803c2efbea66c14b66babd84}
\begin{DoxyReturn}{Returns}
the link-\/level M\+TU in bytes for this interface.
\end{DoxyReturn}
This value is typically used by the IP layer to perform IP fragmentation when needed. 

Implements \hyperlink{classns3_1_1NetDevice_a91f4f5d01bc2d567c1e0a69b63a4cf14}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
292 \{
293   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
294   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1CsmaNetDevice_a4b2e70ee2ee42f63f3756728ec592bc1}{m\_mtu};
295 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 12


\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Get\+Multicast@{Get\+Multicast}}
\index{Get\+Multicast@{Get\+Multicast}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Multicast(\+Ipv4\+Address multicast\+Group) const }{GetMulticast(Ipv4Address multicastGroup) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Csma\+Net\+Device\+::\+Get\+Multicast (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{multicast\+Group}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1CsmaNetDevice_ac7091be8b22f218e39572028c5fe45d2}{}\label{classns3_1_1CsmaNetDevice_ac7091be8b22f218e39572028c5fe45d2}


Make and return a M\+AC multicast address using the provided multicast group. 

\{1112\} says that an \hyperlink{classns3_1_1Ipv4}{Ipv4} host group address is mapped to an Ethernet multicast address by placing the low-\/order 23-\/bits of the IP address into the low-\/order 23 bits of the Ethernet multicast address 01-\/00-\/5\+E-\/00-\/00-\/00 (hex).

This method performs the multicast address creation function appropriate to an E\+U\+I-\/48-\/based C\+S\+MA device. This M\+AC address is encapsulated in an abstract \hyperlink{classns3_1_1Address}{Address} to avoid dependencies on the exact address format.


\begin{DoxyParams}{Parameters}
{\em multicast\+Group} & The IP address for the multicast group destination of the packet. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The M\+AC multicast \hyperlink{classns3_1_1Address}{Address} used to send packets to the provided multicast group.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} 

\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} 

\hyperlink{classns3_1_1Address}{Address} 
\end{DoxySeeAlso}


Implements \hyperlink{classns3_1_1NetDevice_a98aa4852df367b6a393c8cc1d88af0d9}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
946 \{
947   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (multicastGroup);
948 
949   Mac48Address ad = \hyperlink{classns3_1_1Mac48Address_a23d170f8c7a7d90a8110425620285819}{Mac48Address::GetMulticast} (multicastGroup);
950 
951   \textcolor{comment}{//}
952   \textcolor{comment}{// Implicit conversion (operator Address ()) is defined for Mac48Address, so}
953   \textcolor{comment}{// use it by just returning the EUI-48 address which is automagically converted}
954   \textcolor{comment}{// to an Address.}
955   \textcolor{comment}{//}
956   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"multicast address is "} << ad);
957 
958   \textcolor{keywordflow}{return} ad;
959 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13


\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Get\+Multicast@{Get\+Multicast}}
\index{Get\+Multicast@{Get\+Multicast}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Multicast(\+Ipv6\+Address addr) const }{GetMulticast(Ipv6Address addr) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Csma\+Net\+Device\+::\+Get\+Multicast (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{addr}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1CsmaNetDevice_ac3944d8c8399743a25b9919512912f62}{}\label{classns3_1_1CsmaNetDevice_ac3944d8c8399743a25b9919512912f62}


Get the M\+AC multicast address corresponding to the I\+Pv6 address provided. 


\begin{DoxyParams}{Parameters}
{\em addr} & I\+Pv6 address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the M\+AC multicast address 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Calling this method is invalid if Is\+Multicast returns not true. 
\end{DoxyWarning}


Implements \hyperlink{classns3_1_1NetDevice_a46479a2c0101c6f9da9251ed4d7575bd}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1066 \{
1067   Mac48Address ad = \hyperlink{classns3_1_1Mac48Address_a23d170f8c7a7d90a8110425620285819}{Mac48Address::GetMulticast} (addr);
1068 
1069   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"MAC IPv6 multicast address is "} << ad);
1070   \textcolor{keywordflow}{return} ad;
1071 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 14


\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Get\+Node@{Get\+Node}}
\index{Get\+Node@{Get\+Node}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Node(void) const }{GetNode(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Node} $>$ ns3\+::\+Csma\+Net\+Device\+::\+Get\+Node (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1CsmaNetDevice_a4a6057b8a66a50306506b3560494f708}{}\label{classns3_1_1CsmaNetDevice_a4a6057b8a66a50306506b3560494f708}
Get the node to which this device is attached.

\begin{DoxyReturn}{Returns}
\hyperlink{classns3_1_1Ptr}{Ptr} to the \hyperlink{classns3_1_1Node}{Node} to which the device is attached. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a098b6cc4339ac00c62e75cfa48c8aeac}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1038 \{
1039   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
1040   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1CsmaNetDevice_a9dbd678469e1b1efe74a45b868ead509}{m\_node};
1041 \}
\end{DoxyCode}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Get\+Queue@{Get\+Queue}}
\index{Get\+Queue@{Get\+Queue}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Queue(void) const }{GetQueue(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Queue}$<$ {\bf Packet} $>$ $>$ ns3\+::\+Csma\+Net\+Device\+::\+Get\+Queue (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1CsmaNetDevice_a40e2c34436dde9efd9d1f1c86594b4d0}{}\label{classns3_1_1CsmaNetDevice_a40e2c34436dde9efd9d1f1c86594b4d0}
Get a copy of the attached \hyperlink{classns3_1_1Queue}{Queue}.

\begin{DoxyReturn}{Returns}
a pointer to the queue. 
\end{DoxyReturn}

\begin{DoxyCode}
861 \{ 
862   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
863   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1CsmaNetDevice_a499be4029c01107f7f16f5371843ffde}{m\_queue};
864 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 15


\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Csma\+Net\+Device\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1CsmaNetDevice_aee49acd8c695a21662f2111c7771e92b}{}\label{classns3_1_1CsmaNetDevice_aee49acd8c695a21662f2111c7771e92b}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
45 \{
46   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::CsmaNetDevice"})
47     .SetParent<NetDevice> ()
48     .SetGroupName (\textcolor{stringliteral}{"Csma"})
49     .AddConstructor<\hyperlink{classns3_1_1CsmaNetDevice_a5005a5403e112dad6ecd2922a9065916}{CsmaNetDevice}> ()
50     .AddAttribute (\textcolor{stringliteral}{"Address"}, 
51                    \textcolor{stringliteral}{"The MAC address of this device."},
52                    Mac48AddressValue (Mac48Address (\textcolor{stringliteral}{"ff:ff:ff:ff:ff:ff"})),
53                    MakeMac48AddressAccessor (&\hyperlink{classns3_1_1CsmaNetDevice_ae26602a3eb4e97c0aa39ae61b4d028f8}{CsmaNetDevice::m\_address}),
54                    MakeMac48AddressChecker ())
55     .AddAttribute (\textcolor{stringliteral}{"Mtu"}, \textcolor{stringliteral}{"The MAC-level Maximum Transmission Unit"},
56                    UintegerValue (\hyperlink{classns3_1_1CsmaNetDevice_aba1a157c1695a4c02b4dcba3490217e4}{DEFAULT\_MTU}),
57                    MakeUintegerAccessor (&\hyperlink{classns3_1_1CsmaNetDevice_a6fe6c073498c02fa0b01c64746f6166b}{CsmaNetDevice::SetMtu},
58                                          &\hyperlink{classns3_1_1CsmaNetDevice_a4c27c177803c2efbea66c14b66babd84}{CsmaNetDevice::GetMtu}),
59                    MakeUintegerChecker<uint16\_t> ())
60     .AddAttribute (\textcolor{stringliteral}{"EncapsulationMode"}, 
61                    \textcolor{stringliteral}{"The link-layer encapsulation type to use."},
62                    EnumValue (\hyperlink{classns3_1_1CsmaNetDevice_a176431468055d41f8e879e33a5362cada8cc8287029197a9496df00c6d3f8b9ff}{DIX}),
63                    \hyperlink{namespacens3_af5050739867ce63896dec011e332c8ec}{MakeEnumAccessor} (&
      \hyperlink{classns3_1_1CsmaNetDevice_abb8187ce567fde1aa17250f38751468b}{CsmaNetDevice::SetEncapsulationMode}),
64                    \hyperlink{namespacens3_a48832781a2b521d3d0091e05ece30615}{MakeEnumChecker} (\hyperlink{classns3_1_1CsmaNetDevice_a176431468055d41f8e879e33a5362cada8cc8287029197a9496df00c6d3f8b9ff}{DIX}, \textcolor{stringliteral}{"Dix"},
65                                     \hyperlink{classns3_1_1CsmaNetDevice_a176431468055d41f8e879e33a5362cadab3a0dd08ede5405aff1fd939e556dc5b}{LLC}, \textcolor{stringliteral}{"Llc"}))
66     .AddAttribute (\textcolor{stringliteral}{"SendEnable"}, 
67                    \textcolor{stringliteral}{"Enable or disable the transmitter section of the device."},
68                    BooleanValue (\textcolor{keyword}{true}),
69                    MakeBooleanAccessor (&\hyperlink{classns3_1_1CsmaNetDevice_ac5bde9af7f582a6d707a68061c114fdf}{CsmaNetDevice::m\_sendEnable}),
70                    MakeBooleanChecker ())
71     .AddAttribute (\textcolor{stringliteral}{"ReceiveEnable"},
72                    \textcolor{stringliteral}{"Enable or disable the receiver section of the device."},
73                    BooleanValue (\textcolor{keyword}{true}),
74                    MakeBooleanAccessor (&\hyperlink{classns3_1_1CsmaNetDevice_a8d844dcce78846a16c9a52c752f9736f}{CsmaNetDevice::m\_receiveEnable}),
75                    MakeBooleanChecker ())
76     .AddAttribute (\textcolor{stringliteral}{"ReceiveErrorModel"}, 
77                    \textcolor{stringliteral}{"The receiver error model used to simulate packet loss"},
78                    PointerValue (),
79                    MakePointerAccessor (&\hyperlink{classns3_1_1CsmaNetDevice_aeef9196f9c7c46c99a7f703dc46c0207}{CsmaNetDevice::m\_receiveErrorModel}
      ),
80                    MakePointerChecker<ErrorModel> ())
81 
82     \textcolor{comment}{//}
83     \textcolor{comment}{// Transmit queueing discipline for the device which includes its own set}
84     \textcolor{comment}{// of trace hooks.}
85     \textcolor{comment}{//}
86     .AddAttribute (\textcolor{stringliteral}{"TxQueue"}, 
87                    \textcolor{stringliteral}{"A queue to use as the transmit queue in the device."},
88                    PointerValue (),
89                    MakePointerAccessor (&\hyperlink{classns3_1_1CsmaNetDevice_a499be4029c01107f7f16f5371843ffde}{CsmaNetDevice::m\_queue}),
90                    \hyperlink{namespacens3_a8cd81c2f226bc23ad44a259717e6da15}{MakePointerChecker}<Queue<Packet> > ())
91 
92     \textcolor{comment}{//}
93     \textcolor{comment}{// Trace sources at the "top" of the net device, where packets transition}
94     \textcolor{comment}{// to/from higher layers.}
95     \textcolor{comment}{//}
96     .AddTraceSource (\textcolor{stringliteral}{"MacTx"}, 
97                      \textcolor{stringliteral}{"Trace source indicating a packet has "}
98                      \textcolor{stringliteral}{"arrived for transmission by this device"},
99                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1CsmaNetDevice_acd8f03ea3f02befd6caa2b07065ac80a}{CsmaNetDevice::m\_macTxTrace}),
100                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
101     .AddTraceSource (\textcolor{stringliteral}{"MacTxDrop"}, 
102                      \textcolor{stringliteral}{"Trace source indicating a packet has been "}
103                      \textcolor{stringliteral}{"dropped by the device before transmission"},
104                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1CsmaNetDevice_ac6e2a81eedea1fa443600bbac37842b2}{CsmaNetDevice::m\_macTxDropTrace}),
105                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
106     .AddTraceSource (\textcolor{stringliteral}{"MacPromiscRx"}, 
107                      \textcolor{stringliteral}{"A packet has been received by this device, "}
108                      \textcolor{stringliteral}{"has been passed up from the physical layer "}
109                      \textcolor{stringliteral}{"and is being forwarded up the local protocol stack.  "}
110                      \textcolor{stringliteral}{"This is a promiscuous trace,"},
111                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1CsmaNetDevice_a4b22f431d8511abaf9ef4e92cc41ce24}{CsmaNetDevice::m\_macPromiscRxTrace}),
112                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
113     .AddTraceSource (\textcolor{stringliteral}{"MacRx"}, 
114                      \textcolor{stringliteral}{"A packet has been received by this device, "}
115                      \textcolor{stringliteral}{"has been passed up from the physical layer "}
116                      \textcolor{stringliteral}{"and is being forwarded up the local protocol stack.  "}
117                      \textcolor{stringliteral}{"This is a non-promiscuous trace,"},
118                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1CsmaNetDevice_a40f2a9fcb15d1e44fc918d1639bff18a}{CsmaNetDevice::m\_macRxTrace}),
119                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
120 \textcolor{preprocessor}{#if 0}
121     \textcolor{comment}{// Not currently implemented in this device}
122     .AddTraceSource (\textcolor{stringliteral}{"MacRxDrop"}, 
123                      \textcolor{stringliteral}{"Trace source indicating a packet was received, "}
124                      \textcolor{stringliteral}{"but dropped before being forwarded up the stack"},
125                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1CsmaNetDevice_a0ba6e9b6d9403e55044c695ece47e311}{CsmaNetDevice::m\_macRxDropTrace}),
126                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
127 \textcolor{preprocessor}{#endif}
128     .AddTraceSource (\textcolor{stringliteral}{"MacTxBackoff"}, 
129                      \textcolor{stringliteral}{"Trace source indicating a packet has been "}
130                      \textcolor{stringliteral}{"delayed by the CSMA backoff process"},
131                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1CsmaNetDevice_a1f035d24ccf03e5731243e0b22665cb0}{CsmaNetDevice::m\_macTxBackoffTrace}),
132                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
133     \textcolor{comment}{//}
134     \textcolor{comment}{// Trace souces at the "bottom" of the net device, where packets transition}
135     \textcolor{comment}{// to/from the channel.}
136     \textcolor{comment}{//}
137     .AddTraceSource (\textcolor{stringliteral}{"PhyTxBegin"}, 
138                      \textcolor{stringliteral}{"Trace source indicating a packet has "}
139                      \textcolor{stringliteral}{"begun transmitting over the channel"},
140                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1CsmaNetDevice_a6c5deac5e6a05a2013175402d4e22985}{CsmaNetDevice::m\_phyTxBeginTrace}),
141                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
142     .AddTraceSource (\textcolor{stringliteral}{"PhyTxEnd"}, 
143                      \textcolor{stringliteral}{"Trace source indicating a packet has been "}
144                      \textcolor{stringliteral}{"completely transmitted over the channel"},
145                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1CsmaNetDevice_a8cac1ff27eec4db589ed00545f942a21}{CsmaNetDevice::m\_phyTxEndTrace}),
146                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
147     .AddTraceSource (\textcolor{stringliteral}{"PhyTxDrop"}, 
148                      \textcolor{stringliteral}{"Trace source indicating a packet has been "}
149                      \textcolor{stringliteral}{"dropped by the device during transmission"},
150                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1CsmaNetDevice_ad2a07cf80f83d9ce17d9280775e9a1f8}{CsmaNetDevice::m\_phyTxDropTrace}),
151                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
152 \textcolor{preprocessor}{#if 0}
153     \textcolor{comment}{// Not currently implemented in this device}
154     .AddTraceSource (\textcolor{stringliteral}{"PhyRxBegin"}, 
155                      \textcolor{stringliteral}{"Trace source indicating a packet has "}
156                      \textcolor{stringliteral}{"begun being received by the device"},
157                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1CsmaNetDevice_abdbb5dd4d62426a5ad0f6cb8cb030b3b}{CsmaNetDevice::m\_phyRxBeginTrace}),
158                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
159 \textcolor{preprocessor}{#endif}
160     .AddTraceSource (\textcolor{stringliteral}{"PhyRxEnd"}, 
161                      \textcolor{stringliteral}{"Trace source indicating a packet has been "}
162                      \textcolor{stringliteral}{"completely received by the device"},
163                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1CsmaNetDevice_afe2bac4b10c5d73f78e11668a3e6a679}{CsmaNetDevice::m\_phyRxEndTrace}),
164                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
165     .AddTraceSource (\textcolor{stringliteral}{"PhyRxDrop"}, 
166                      \textcolor{stringliteral}{"Trace source indicating a packet has been "}
167                      \textcolor{stringliteral}{"dropped by the device during reception"},
168                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1CsmaNetDevice_a9413b693a3028dcccb20f653bad58bc0}{CsmaNetDevice::m\_phyRxDropTrace}),
169                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
170     \textcolor{comment}{//}
171     \textcolor{comment}{// Trace sources designed to simulate a packet sniffer facility (tcpdump). }
172     \textcolor{comment}{//}
173     .AddTraceSource (\textcolor{stringliteral}{"Sniffer"}, 
174                      \textcolor{stringliteral}{"Trace source simulating a non-promiscuous "}
175                      \textcolor{stringliteral}{"packet sniffer attached to the device"},
176                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1CsmaNetDevice_a88e5994b762e01f74606742a7f15b797}{CsmaNetDevice::m\_snifferTrace}),
177                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
178     .AddTraceSource (\textcolor{stringliteral}{"PromiscSniffer"}, 
179                      \textcolor{stringliteral}{"Trace source simulating a promiscuous "}
180                      \textcolor{stringliteral}{"packet sniffer attached to the device"},
181                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1CsmaNetDevice_aae7fbd28077e7ac8efee738c4194ed16}{CsmaNetDevice::m\_promiscSnifferTrace}),
182                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
183   ;
184   \textcolor{keywordflow}{return} tid;
185 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 16


\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Init@{Init}}
\index{Init@{Init}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Init(bool send\+Enable, bool receive\+Enable)}{Init(bool sendEnable, bool receiveEnable)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Csma\+Net\+Device\+::\+Init (
\begin{DoxyParamCaption}
\item[{bool}]{send\+Enable, }
\item[{bool}]{receive\+Enable}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_a566f2c2362d412be7c3c20e2f115842a}{}\label{classns3_1_1CsmaNetDevice_a566f2c2362d412be7c3c20e2f115842a}
Initialization function used during object construction. 
\begin{DoxyParams}{Parameters}
{\em send\+Enable} & if device will be allowed to send \\
\hline
{\em receive\+Enable} & if device will be allowed to receive \\
\hline
\end{DoxyParams}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Is\+Bridge@{Is\+Bridge}}
\index{Is\+Bridge@{Is\+Bridge}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Bridge(void) const }{IsBridge(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Csma\+Net\+Device\+::\+Is\+Bridge (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1CsmaNetDevice_a16114731c9a1ea434be6872fc5ec4196}{}\label{classns3_1_1CsmaNetDevice_a16114731c9a1ea434be6872fc5ec4196}
Is this a bridge? \begin{DoxyReturn}{Returns}
false. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a9d34556a1c83a69dacb08698ca4a1d94}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
970 \{
971   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
972   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
973 \}
\end{DoxyCode}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Is\+Broadcast@{Is\+Broadcast}}
\index{Is\+Broadcast@{Is\+Broadcast}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Broadcast(void) const }{IsBroadcast(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Csma\+Net\+Device\+::\+Is\+Broadcast (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1CsmaNetDevice_a36fbc65aebd3b5bd7d0747c3e5bf3b4b}{}\label{classns3_1_1CsmaNetDevice_a36fbc65aebd3b5bd7d0747c3e5bf3b4b}
\begin{DoxyReturn}{Returns}
true if this interface supports a broadcast address, false otherwise. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a67f992b20858cd7b397d8fba2feff141}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
925 \{
926   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
927   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
928 \}
\end{DoxyCode}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Is\+Link\+Up@{Is\+Link\+Up}}
\index{Is\+Link\+Up@{Is\+Link\+Up}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Link\+Up(void) const }{IsLinkUp(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Csma\+Net\+Device\+::\+Is\+Link\+Up (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1CsmaNetDevice_a961676d6d97ebdb8605196c96e0d2ef1}{}\label{classns3_1_1CsmaNetDevice_a961676d6d97ebdb8605196c96e0d2ef1}
\begin{DoxyReturn}{Returns}
true if link is up; false otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_afe1822b79e19a05ab95f693c8fb64fc7}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
911 \{
912   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
913   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1CsmaNetDevice_afc0b0c430b9ee8e8ddde196c340b5764}{m\_linkUp};
914 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 17


\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Is\+Multicast@{Is\+Multicast}}
\index{Is\+Multicast@{Is\+Multicast}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Multicast(void) const }{IsMulticast(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Csma\+Net\+Device\+::\+Is\+Multicast (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1CsmaNetDevice_a44bd5fb211a01d2b1df02db27d062200}{}\label{classns3_1_1CsmaNetDevice_a44bd5fb211a01d2b1df02db27d062200}
\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Multicast flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a1afb4848a9226540f1ff51f9b31ae95e}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
939 \{
940   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
941   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
942 \}
\end{DoxyCode}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Is\+Point\+To\+Point@{Is\+Point\+To\+Point}}
\index{Is\+Point\+To\+Point@{Is\+Point\+To\+Point}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Point\+To\+Point(void) const }{IsPointToPoint(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Csma\+Net\+Device\+::\+Is\+Point\+To\+Point (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1CsmaNetDevice_a38a3517032b7973fbafca15103c07d52}{}\label{classns3_1_1CsmaNetDevice_a38a3517032b7973fbafca15103c07d52}
Is this a point to point link? \begin{DoxyReturn}{Returns}
false. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a718177f25efeaf2dbf8a18fcab87224d}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
963 \{
964   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
965   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
966 \}
\end{DoxyCode}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Is\+Receive\+Enabled@{Is\+Receive\+Enabled}}
\index{Is\+Receive\+Enabled@{Is\+Receive\+Enabled}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Receive\+Enabled(void)}{IsReceiveEnabled(void)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Csma\+Net\+Device\+::\+Is\+Receive\+Enabled (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1CsmaNetDevice_a6a4e8e37d1a78fa176184a1787b47c3a}{}\label{classns3_1_1CsmaNetDevice_a6a4e8e37d1a78fa176184a1787b47c3a}
Is the receive side of the network device enabled?

\begin{DoxyReturn}{Returns}
True if the receiver side is enabled, otherwise false. 
\end{DoxyReturn}

\begin{DoxyCode}
321 \{
322   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
323   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1CsmaNetDevice_a8d844dcce78846a16c9a52c752f9736f}{m\_receiveEnable};
324 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 18


\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Is\+Send\+Enabled@{Is\+Send\+Enabled}}
\index{Is\+Send\+Enabled@{Is\+Send\+Enabled}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Send\+Enabled(void)}{IsSendEnabled(void)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Csma\+Net\+Device\+::\+Is\+Send\+Enabled (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1CsmaNetDevice_a40e5946f8807cb9c65857789c3c2b269}{}\label{classns3_1_1CsmaNetDevice_a40e5946f8807cb9c65857789c3c2b269}
Is the send side of the network device enabled?

\begin{DoxyReturn}{Returns}
True if the send side is enabled, otherwise false. 
\end{DoxyReturn}

\begin{DoxyCode}
314 \{
315   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
316   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1CsmaNetDevice_ac5bde9af7f582a6d707a68061c114fdf}{m\_sendEnable};
317 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 19


\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Needs\+Arp@{Needs\+Arp}}
\index{Needs\+Arp@{Needs\+Arp}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Needs\+Arp(void) const }{NeedsArp(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Csma\+Net\+Device\+::\+Needs\+Arp (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1CsmaNetDevice_aaabe1b5821f22b8f3ee474a2ffa32516}{}\label{classns3_1_1CsmaNetDevice_aaabe1b5821f22b8f3ee474a2ffa32516}
Does this device need to use the address resolution protocol?

\begin{DoxyReturn}{Returns}
True if the encapsulation mode is set to a value that requires A\+RP (I\+P\+\_\+\+A\+RP or L\+LC). 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_ab1a133696310cad3dc2c3d1a4993f310}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1053 \{
1054   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
1055   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1056 \}
\end{DoxyCode}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Notify\+Link\+Up@{Notify\+Link\+Up}}
\index{Notify\+Link\+Up@{Notify\+Link\+Up}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Notify\+Link\+Up(void)}{NotifyLinkUp(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Csma\+Net\+Device\+::\+Notify\+Link\+Up (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_a4d01c6da5e8a31af9c3c8ff7bbe0e022}{}\label{classns3_1_1CsmaNetDevice_a4d01c6da5e8a31af9c3c8ff7bbe0e022}
Notify any interested parties that the link has come up. 
\begin{DoxyCode}
868 \{
869   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
870   \hyperlink{classns3_1_1CsmaNetDevice_afc0b0c430b9ee8e8ddde196c340b5764}{m\_linkUp} = \textcolor{keyword}{true};
871   \hyperlink{classns3_1_1CsmaNetDevice_a67dd7e65384a1b9f89dfacc1ede41d69}{m\_linkChangeCallbacks} ();
872 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 20


\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Notify\+New\+Aggregate@{Notify\+New\+Aggregate}}
\index{Notify\+New\+Aggregate@{Notify\+New\+Aggregate}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Notify\+New\+Aggregate(void)}{NotifyNewAggregate(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Csma\+Net\+Device\+::\+Notify\+New\+Aggregate (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1CsmaNetDevice_a45857b94ade04508597e30ab15b9963c}{}\label{classns3_1_1CsmaNetDevice_a45857b94ade04508597e30ab15b9963c}
Notify all Objects aggregated to this one of a new \hyperlink{classns3_1_1Object}{Object} being aggregated.

This method is invoked whenever two sets of Objects are aggregated together. It is invoked exactly once for each \hyperlink{classns3_1_1Object}{Object} in both sets. This method can be overriden by subclasses who wish to be notified of aggregation events. These subclasses must chain up to their base class \hyperlink{classns3_1_1CsmaNetDevice_a45857b94ade04508597e30ab15b9963c}{Notify\+New\+Aggregate()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} and \hyperlink{classns3_1_1Object_a79dd435d300f3deca814553f561a2922}{Aggregate\+Object()} from within this method.

This function must be implemented in the stack that needs to notify other stacks connected to the node of their presence in the node. 

Reimplemented from \hyperlink{classns3_1_1Object_a1bd7211125185a6cd511c35fea4e500f}{ns3\+::\+Object}.


\begin{DoxyCode}
245 \{
246   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
247   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1CsmaNetDevice_a93a7be08d44dbabfdf111e90feb7c72a}{m\_queueInterface} == 0)
248     \{
249       Ptr<NetDeviceQueueInterface> ndqi = this->GetObject<NetDeviceQueueInterface> ();
250       \textcolor{comment}{//verify that it's a valid netdevice queue interface and that}
251       \textcolor{comment}{//the netdevice queue interface was not set before}
252       \textcolor{keywordflow}{if} (ndqi != 0)
253         \{
254           \hyperlink{classns3_1_1CsmaNetDevice_a93a7be08d44dbabfdf111e90feb7c72a}{m\_queueInterface} = ndqi;
255         \}
256     \}
257   \hyperlink{classns3_1_1Object_a1bd7211125185a6cd511c35fea4e500f}{NetDevice::NotifyNewAggregate} ();
258 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 21


\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!operator=@{operator=}}
\index{operator=@{operator=}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{operator=(const Csma\+Net\+Device \&o)}{operator=(const CsmaNetDevice &o)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Csma\+Net\+Device}\& ns3\+::\+Csma\+Net\+Device\+::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf Csma\+Net\+Device} \&}]{o}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_a388accd5aee7b7aca18d458e4135198f}{}\label{classns3_1_1CsmaNetDevice_a388accd5aee7b7aca18d458e4135198f}
Operator = is declared but not implemented. This disables the assignment operator for \hyperlink{classns3_1_1CsmaNetDevice}{Csma\+Net\+Device} objects. 
\begin{DoxyParams}{Parameters}
{\em o} & object to copy \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the copied object 
\end{DoxyReturn}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Receive@{Receive}}
\index{Receive@{Receive}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Receive(\+Ptr$<$ Packet $>$ p, Ptr$<$ Csma\+Net\+Device $>$ sender)}{Receive(Ptr< Packet > p, Ptr< CsmaNetDevice > sender)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Csma\+Net\+Device\+::\+Receive (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{{\bf Ptr}$<$ {\bf Csma\+Net\+Device} $>$}]{sender}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1CsmaNetDevice_a640e48cd26f676994e0d76b5f34a5367}{}\label{classns3_1_1CsmaNetDevice_a640e48cd26f676994e0d76b5f34a5367}
Receive a packet from a connected \hyperlink{classns3_1_1CsmaChannel}{Csma\+Channel}.

The \hyperlink{classns3_1_1CsmaNetDevice}{Csma\+Net\+Device} receives packets from its connected channel and forwards them up the protocol stack. This is the public method used by the channel to indicate that the last bit of a packet has arrived at the device.

\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1CsmaChannel}{Csma\+Channel} 
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em p} & a reference to the received packet \\
\hline
{\em sender} & the \hyperlink{classns3_1_1CsmaNetDevice}{Csma\+Net\+Device} that transmitted the packet in the first place \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
724 \{
725   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (packet << senderDevice);
726   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"UID is "} << packet->GetUid ());
727 
728   \textcolor{comment}{//}
729   \textcolor{comment}{// We never forward up packets that we sent.  Real devices don't do this since}
730   \textcolor{comment}{// their receivers are disabled during send, so we don't.}
731   \textcolor{comment}{// }
732   \textcolor{keywordflow}{if} (senderDevice == \textcolor{keyword}{this})
733     \{
734       \textcolor{keywordflow}{return};
735     \}
736 
737   \textcolor{comment}{//}
738   \textcolor{comment}{// Hit the trace hook.  This trace will fire on all packets received from the}
739   \textcolor{comment}{// channel except those originated by this device.}
740   \textcolor{comment}{//}
741   \hyperlink{classns3_1_1CsmaNetDevice_afe2bac4b10c5d73f78e11668a3e6a679}{m\_phyRxEndTrace} (packet);
742 
743   \textcolor{comment}{// }
744   \textcolor{comment}{// Only receive if the send side of net device is enabled}
745   \textcolor{comment}{//}
746   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1CsmaNetDevice_a6a4e8e37d1a78fa176184a1787b47c3a}{IsReceiveEnabled} () == \textcolor{keyword}{false})
747     \{
748       \hyperlink{classns3_1_1CsmaNetDevice_a9413b693a3028dcccb20f653bad58bc0}{m\_phyRxDropTrace} (packet);
749       \textcolor{keywordflow}{return};
750     \}
751 
752   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1CsmaNetDevice_aeef9196f9c7c46c99a7f703dc46c0207}{m\_receiveErrorModel} && \hyperlink{classns3_1_1CsmaNetDevice_aeef9196f9c7c46c99a7f703dc46c0207}{m\_receiveErrorModel}->IsCorrupt (packet) 
      )
753     \{
754       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Dropping pkt due to error model "});
755       \hyperlink{classns3_1_1CsmaNetDevice_a9413b693a3028dcccb20f653bad58bc0}{m\_phyRxDropTrace} (packet);
756       \textcolor{keywordflow}{return};
757     \}
758 
759   \textcolor{comment}{//}
760   \textcolor{comment}{// Trace sinks will expect complete packets, not packets without some of the}
761   \textcolor{comment}{// headers.}
762   \textcolor{comment}{//}
763   Ptr<Packet> originalPacket = packet->Copy ();
764 
765   EthernetTrailer trailer;
766   packet->RemoveTrailer (trailer);
767   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Node_a0515bfe9a3aeb6605d657ba855699815}{Node::ChecksumEnabled} ())
768     \{
769       trailer.EnableFcs (\textcolor{keyword}{true});
770     \}
771 
772   \textcolor{keywordtype}{bool} crcGood = trailer.CheckFcs (packet);
773   \textcolor{keywordflow}{if} (!crcGood)
774     \{
775       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"CRC error on Packet "} << packet);
776       \hyperlink{classns3_1_1CsmaNetDevice_a9413b693a3028dcccb20f653bad58bc0}{m\_phyRxDropTrace} (packet);
777       \textcolor{keywordflow}{return};
778     \}
779 
780   EthernetHeader header (\textcolor{keyword}{false});
781   packet->RemoveHeader (header);
782 
783   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Pkt source is "} << header.GetSource ());
784   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Pkt destination is "} << header.GetDestination ());
785 
786   uint16\_t protocol;
787   \textcolor{comment}{//}
788   \textcolor{comment}{// If the length/type is less than 1500, it corresponds to a length }
789   \textcolor{comment}{// interpretation packet.  In this case, it is an 802.3 packet and }
790   \textcolor{comment}{// will also have an 802.2 LLC header.  If greater than 1500, we}
791   \textcolor{comment}{// find the protocol number (Ethernet type) directly.}
792   \textcolor{comment}{//}
793   \textcolor{keywordflow}{if} (header.GetLengthType () <= 1500)
794     \{
795       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (packet->GetSize () >= header.GetLengthType ());
796       uint32\_t padlen = packet->GetSize () - header.GetLengthType ();
797       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (padlen <= 46);
798       \textcolor{keywordflow}{if} (padlen > 0)
799         \{
800           packet->RemoveAtEnd (padlen);
801         \}
802 
803       LlcSnapHeader llc;
804       packet->RemoveHeader (llc);
805       protocol = llc.GetType ();
806     \}
807   \textcolor{keywordflow}{else}
808     \{
809       protocol = header.GetLengthType ();
810     \}
811 
812   \textcolor{comment}{//}
813   \textcolor{comment}{// Classify the packet based on its destination.}
814   \textcolor{comment}{//}
815   \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2}{PacketType} packetType;
816 
817   \textcolor{keywordflow}{if} (header.GetDestination ().IsBroadcast ())
818     \{
819       packetType = \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2adfeb6a2929cee183836a32fe293ce205}{PACKET\_BROADCAST};
820     \}
821   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (header.GetDestination ().IsGroup ())
822     \{
823       packetType = \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2ae3ffb88d364e97f06f662f5d7ba53bbe}{PACKET\_MULTICAST};
824     \}
825   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (header.GetDestination () == \hyperlink{classns3_1_1CsmaNetDevice_ae26602a3eb4e97c0aa39ae61b4d028f8}{m\_address})
826     \{
827       packetType = \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2a60835731aced24ac0c712ba61e62462e}{PACKET\_HOST};
828     \}
829   \textcolor{keywordflow}{else}
830     \{
831       packetType = \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2a60c00fab4286dd2903e2b197a9f8c6c8}{PACKET\_OTHERHOST};
832     \}
833 
834   \textcolor{comment}{// }
835   \textcolor{comment}{// For all kinds of packetType we receive, we hit the promiscuous sniffer}
836   \textcolor{comment}{// hook and pass a copy up to the promiscuous callback.  Pass a copy to }
837   \textcolor{comment}{// make sure that nobody messes with our packet.}
838   \textcolor{comment}{//}
839   \hyperlink{classns3_1_1CsmaNetDevice_aae7fbd28077e7ac8efee738c4194ed16}{m\_promiscSnifferTrace} (originalPacket);
840   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1CsmaNetDevice_a4c9c0533341d76fe278fbef18525b228}{m\_promiscRxCallback}.\hyperlink{classns3_1_1Callback_aa8e27826badbf37f84763f36f70d9b54}{IsNull} ())
841     \{
842       \hyperlink{classns3_1_1CsmaNetDevice_a4b22f431d8511abaf9ef4e92cc41ce24}{m\_macPromiscRxTrace} (originalPacket);
843       \hyperlink{classns3_1_1CsmaNetDevice_a4c9c0533341d76fe278fbef18525b228}{m\_promiscRxCallback} (\textcolor{keyword}{this}, packet, protocol, header.GetSource (), header.
      GetDestination (), packetType);
844     \}
845 
846   \textcolor{comment}{//}
847   \textcolor{comment}{// If this packet is not destined for some other host, it must be for us}
848   \textcolor{comment}{// as either a broadcast, multicast or unicast.  We need to hit the mac}
849   \textcolor{comment}{// packet received trace hook and forward the packet up the stack.}
850   \textcolor{comment}{//}
851   \textcolor{keywordflow}{if} (packetType != \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2a60c00fab4286dd2903e2b197a9f8c6c8}{PACKET\_OTHERHOST})
852     \{
853       \hyperlink{classns3_1_1CsmaNetDevice_a88e5994b762e01f74606742a7f15b797}{m\_snifferTrace} (originalPacket);
854       \hyperlink{classns3_1_1CsmaNetDevice_a40f2a9fcb15d1e44fc918d1639bff18a}{m\_macRxTrace} (originalPacket);
855       \hyperlink{classns3_1_1CsmaNetDevice_a18646390c167ad8f0f8b8795a9052031}{m\_rxCallback} (\textcolor{keyword}{this}, packet, protocol, header.GetSource ());
856     \}
857 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 22




Here is the caller graph for this function\+:
% FIG 23


\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Send@{Send}}
\index{Send@{Send}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Send(\+Ptr$<$ Packet $>$ packet, const Address \&dest, uint16\+\_\+t protocol\+Number)}{Send(Ptr< Packet > packet, const Address &dest, uint16_t protocolNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Csma\+Net\+Device\+::\+Send (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{const {\bf Address} \&}]{dest, }
\item[{uint16\+\_\+t}]{protocol\+Number}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1CsmaNetDevice_a6d3d0c60f8a2d60fbe006248bb6b119d}{}\label{classns3_1_1CsmaNetDevice_a6d3d0c60f8a2d60fbe006248bb6b119d}
Start sending a packet down the channel. 
\begin{DoxyParams}{Parameters}
{\em packet} & packet to send \\
\hline
{\em dest} & layer 2 destination address \\
\hline
{\em protocol\+Number} & protocol number \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if successfull, false otherwise (drop, ...) 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a59f41afb0fe8951bb94d5739cbe6ee7d}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
977 \{
978   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (packet << dest << protocolNumber);
979   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1CsmaNetDevice_ad7cb5da0e3fb59bd1670c8fa0af4b775}{SendFrom} (packet, \hyperlink{classns3_1_1CsmaNetDevice_ae26602a3eb4e97c0aa39ae61b4d028f8}{m\_address}, dest, protocolNumber);
980 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 24


\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Send\+From@{Send\+From}}
\index{Send\+From@{Send\+From}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Send\+From(\+Ptr$<$ Packet $>$ packet, const Address \&source, const Address \&dest, uint16\+\_\+t protocol\+Number)}{SendFrom(Ptr< Packet > packet, const Address &source, const Address &dest, uint16_t protocolNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Csma\+Net\+Device\+::\+Send\+From (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{const {\bf Address} \&}]{source, }
\item[{const {\bf Address} \&}]{dest, }
\item[{uint16\+\_\+t}]{protocol\+Number}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1CsmaNetDevice_ad7cb5da0e3fb59bd1670c8fa0af4b775}{}\label{classns3_1_1CsmaNetDevice_ad7cb5da0e3fb59bd1670c8fa0af4b775}
Start sending a packet down the channel, with M\+AC spoofing 
\begin{DoxyParams}{Parameters}
{\em packet} & packet to send \\
\hline
{\em source} & layer 2 source address \\
\hline
{\em dest} & layer 2 destination address \\
\hline
{\em protocol\+Number} & protocol number \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if successfull, false otherwise (drop, ...) 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a19d55a4746c1ae584bf7da69959a885b}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
984 \{
985   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (packet << src << dest << protocolNumber);
986   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"packet ="} << packet);
987   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"UID is "} << packet->\hyperlink{classns3_1_1Packet_a1f212c825b50e54d94f5b9ae99592e6a}{GetUid} () << \textcolor{stringliteral}{")"});
988 
989   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1CsmaNetDevice_a961676d6d97ebdb8605196c96e0d2ef1}{IsLinkUp} ());
990 
991   \textcolor{comment}{//}
992   \textcolor{comment}{// Only transmit if send side of net device is enabled}
993   \textcolor{comment}{//}
994   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1CsmaNetDevice_a40e5946f8807cb9c65857789c3c2b269}{IsSendEnabled} () == \textcolor{keyword}{false})
995     \{
996       \hyperlink{classns3_1_1CsmaNetDevice_ac6e2a81eedea1fa443600bbac37842b2}{m\_macTxDropTrace} (packet);
997       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
998     \}
999 
1000   Mac48Address destination = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (dest);
1001   Mac48Address source = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (src);
1002   \hyperlink{classns3_1_1CsmaNetDevice_a736bf6ce5851ace677f8fc693a92855c}{AddHeader} (packet, source, destination, protocolNumber);
1003 
1004   \hyperlink{classns3_1_1CsmaNetDevice_acd8f03ea3f02befd6caa2b07065ac80a}{m\_macTxTrace} (packet);
1005 
1006   \textcolor{comment}{//}
1007   \textcolor{comment}{// Place the packet to be sent on the send queue.  Note that the }
1008   \textcolor{comment}{// queue may fire a drop trace, but we will too.}
1009   \textcolor{comment}{//}
1010   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1CsmaNetDevice_a499be4029c01107f7f16f5371843ffde}{m\_queue}->Enqueue (packet) == \textcolor{keyword}{false})
1011     \{
1012       \hyperlink{classns3_1_1CsmaNetDevice_ac6e2a81eedea1fa443600bbac37842b2}{m\_macTxDropTrace} (packet);
1013       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1014     \}
1015 
1016   \textcolor{comment}{//}
1017   \textcolor{comment}{// If the device is idle, we need to start a transmission. Otherwise,}
1018   \textcolor{comment}{// the transmission will be started when the current packet finished}
1019   \textcolor{comment}{// transmission (see TransmitCompleteEvent)}
1020   \textcolor{comment}{//}
1021   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1CsmaNetDevice_af07031cad3f8bd8c4b33ba77fa706e99}{m\_txMachineState} == \hyperlink{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4a50a4f4ac7775f95f3ec1d4624213bee2}{READY}) 
1022     \{
1023       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1CsmaNetDevice_a499be4029c01107f7f16f5371843ffde}{m\_queue}->IsEmpty () == \textcolor{keyword}{false})
1024         \{
1025           Ptr<Packet> packet = \hyperlink{classns3_1_1CsmaNetDevice_a499be4029c01107f7f16f5371843ffde}{m\_queue}->Dequeue ();
1026           \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (packet != 0, \textcolor{stringliteral}{"CsmaNetDevice::SendFrom(): IsEmpty false but no Packet
       on queue?"});
1027           \hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt} = packet;
1028           \hyperlink{classns3_1_1CsmaNetDevice_aae7fbd28077e7ac8efee738c4194ed16}{m\_promiscSnifferTrace} (\hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt});
1029           \hyperlink{classns3_1_1CsmaNetDevice_a88e5994b762e01f74606742a7f15b797}{m\_snifferTrace} (\hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt});
1030           \hyperlink{classns3_1_1CsmaNetDevice_a4120db41aa1f41a5e1d59220b306f1e8}{TransmitStart} ();
1031         \}
1032     \}
1033   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1034 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 25




Here is the caller graph for this function\+:
% FIG 26


\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Set\+Address@{Set\+Address}}
\index{Set\+Address@{Set\+Address}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Address(\+Address address)}{SetAddress(Address address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Csma\+Net\+Device\+::\+Set\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1CsmaNetDevice_a3e67420f44df00ba880ecc3f361cce2a}{}\label{classns3_1_1CsmaNetDevice_a3e67420f44df00ba880ecc3f361cce2a}
Set the address of this interface 
\begin{DoxyParams}{Parameters}
{\em address} & address to set \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1NetDevice_ab56dc36bc0547471ab3210eda60ee76c}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
897 \{
898   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
899   \hyperlink{classns3_1_1CsmaNetDevice_ae26602a3eb4e97c0aa39ae61b4d028f8}{m\_address} = \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (address);
900 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 27


\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Set\+Backoff\+Params@{Set\+Backoff\+Params}}
\index{Set\+Backoff\+Params@{Set\+Backoff\+Params}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Backoff\+Params(\+Time slot\+Time, uint32\+\_\+t min\+Slots, uint32\+\_\+t max\+Slots, uint32\+\_\+t max\+Retries, uint32\+\_\+t ceiling)}{SetBackoffParams(Time slotTime, uint32_t minSlots, uint32_t maxSlots, uint32_t maxRetries, uint32_t ceiling)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Csma\+Net\+Device\+::\+Set\+Backoff\+Params (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{slot\+Time, }
\item[{uint32\+\_\+t}]{min\+Slots, }
\item[{uint32\+\_\+t}]{max\+Slots, }
\item[{uint32\+\_\+t}]{max\+Retries, }
\item[{uint32\+\_\+t}]{ceiling}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1CsmaNetDevice_a8295d286454a3044ac4100d72af25bd9}{}\label{classns3_1_1CsmaNetDevice_a8295d286454a3044ac4100d72af25bd9}
Set the backoff parameters used to determine the wait to retry transmitting a packet when the channel is busy.

\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1CsmaNetDevice_a5e24813945deeace8e8abe4ede602278}{Attach} () 
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em slot\+Time} & Length of a packet slot (or average packet time) \\
\hline
{\em min\+Slots} & Minimum number of slots to wait \\
\hline
{\em max\+Slots} & Maximum number of slots to wait \\
\hline
{\em max\+Retries} & Maximum number of retries before packet is discard \\
\hline
{\em ceiling} & Cap on the exponential function when calculating max slots \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
335 \{
336   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (slotTime << minSlots << maxSlots << ceiling << maxRetries);
337   \hyperlink{classns3_1_1CsmaNetDevice_a2cb5f9baf0a19a7ea6527002b0299403}{m\_backoff}.\hyperlink{classns3_1_1Backoff_ae6a94d4f007f1cac661b2dc6cf84be0f}{m\_slotTime} = slotTime;
338   \hyperlink{classns3_1_1CsmaNetDevice_a2cb5f9baf0a19a7ea6527002b0299403}{m\_backoff}.\hyperlink{classns3_1_1Backoff_a8870f8d30cfe1766d097314af562fc69}{m\_minSlots} = minSlots;
339   \hyperlink{classns3_1_1CsmaNetDevice_a2cb5f9baf0a19a7ea6527002b0299403}{m\_backoff}.\hyperlink{classns3_1_1Backoff_a53371fae4145bba2abb512cd16156bf6}{m\_maxSlots} = maxSlots;
340   \hyperlink{classns3_1_1CsmaNetDevice_a2cb5f9baf0a19a7ea6527002b0299403}{m\_backoff}.\hyperlink{classns3_1_1Backoff_acf1cad1862af4a90b881d84087e49d5e}{m\_ceiling} = ceiling;
341   \hyperlink{classns3_1_1CsmaNetDevice_a2cb5f9baf0a19a7ea6527002b0299403}{m\_backoff}.\hyperlink{classns3_1_1Backoff_a15d153e005b039f7a0c796f7084bb96a}{m\_maxRetries} = maxRetries;
342 \}
\end{DoxyCode}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Set\+Encapsulation\+Mode@{Set\+Encapsulation\+Mode}}
\index{Set\+Encapsulation\+Mode@{Set\+Encapsulation\+Mode}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Encapsulation\+Mode(\+Csma\+Net\+Device\+::\+Encapsulation\+Mode mode)}{SetEncapsulationMode(CsmaNetDevice::EncapsulationMode mode)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Csma\+Net\+Device\+::\+Set\+Encapsulation\+Mode (
\begin{DoxyParamCaption}
\item[{{\bf Csma\+Net\+Device\+::\+Encapsulation\+Mode}}]{mode}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1CsmaNetDevice_abb8187ce567fde1aa17250f38751468b}{}\label{classns3_1_1CsmaNetDevice_abb8187ce567fde1aa17250f38751468b}
Set the encapsulation mode of this device.


\begin{DoxyParams}{Parameters}
{\em mode} & The encapsulation mode of this device. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
262 \{
263   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (mode);
264 
265   \hyperlink{classns3_1_1CsmaNetDevice_a3f4b374840119abfa65dbe2075533f39}{m\_encapMode} = mode;
266 
267   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"m\_encapMode = "} << \hyperlink{classns3_1_1CsmaNetDevice_a3f4b374840119abfa65dbe2075533f39}{m\_encapMode});
268   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"m\_mtu = "} << \hyperlink{classns3_1_1CsmaNetDevice_a4b2e70ee2ee42f63f3756728ec592bc1}{m\_mtu});
269 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 28


\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Set\+If\+Index@{Set\+If\+Index}}
\index{Set\+If\+Index@{Set\+If\+Index}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+If\+Index(const uint32\+\_\+t index)}{SetIfIndex(const uint32_t index)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Csma\+Net\+Device\+::\+Set\+If\+Index (
\begin{DoxyParamCaption}
\item[{const uint32\+\_\+t}]{index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1CsmaNetDevice_a469d807eeb90a07795ef29824698b23f}{}\label{classns3_1_1CsmaNetDevice_a469d807eeb90a07795ef29824698b23f}

\begin{DoxyParams}{Parameters}
{\em index} & if\+Index of the device \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1NetDevice_a2e1ac6c1189cd565420305d85a193fb8}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
876 \{
877   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (index);
878   \hyperlink{classns3_1_1CsmaNetDevice_af2bb0a9e64ae4ee179256f480e4eed4e}{m\_ifIndex} = index;
879 \}
\end{DoxyCode}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Set\+Interframe\+Gap@{Set\+Interframe\+Gap}}
\index{Set\+Interframe\+Gap@{Set\+Interframe\+Gap}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Interframe\+Gap(\+Time t)}{SetInterframeGap(Time t)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Csma\+Net\+Device\+::\+Set\+Interframe\+Gap (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{t}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1CsmaNetDevice_a03c6e2194fff14f295c234aa9e4c1cdd}{}\label{classns3_1_1CsmaNetDevice_a03c6e2194fff14f295c234aa9e4c1cdd}
Set the interframe gap used to separate packets. The interframe gap defines the minimum space required between packets sent by this device. As in Ethernet, it defaults to 96 bit times.


\begin{DoxyParams}{Parameters}
{\em t} & the interframe gap time \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
328 \{
329   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (t);
330   \hyperlink{classns3_1_1CsmaNetDevice_ae581d7910d91ab9aaf760288ccf75c55}{m\_tInterframeGap} = t;
331 \}
\end{DoxyCode}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Set\+Mtu@{Set\+Mtu}}
\index{Set\+Mtu@{Set\+Mtu}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Mtu(const uint16\+\_\+t mtu)}{SetMtu(const uint16_t mtu)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Csma\+Net\+Device\+::\+Set\+Mtu (
\begin{DoxyParamCaption}
\item[{const uint16\+\_\+t}]{mtu}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1CsmaNetDevice_a6fe6c073498c02fa0b01c64746f6166b}{}\label{classns3_1_1CsmaNetDevice_a6fe6c073498c02fa0b01c64746f6166b}

\begin{DoxyParams}{Parameters}
{\em mtu} & M\+TU value, in bytes, to set for the device \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether the M\+TU value was within legal bounds
\end{DoxyReturn}
Override for default M\+TU defined on a per-\/type basis. 

Implements \hyperlink{classns3_1_1NetDevice_a2ba4956d45cde68eab3cbdd6ede06df0}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
280 \{
281   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << mtu);
282   \hyperlink{classns3_1_1CsmaNetDevice_a4b2e70ee2ee42f63f3756728ec592bc1}{m\_mtu} = mtu;
283 
284   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"m\_encapMode = "} << \hyperlink{classns3_1_1CsmaNetDevice_a3f4b374840119abfa65dbe2075533f39}{m\_encapMode});
285   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"m\_mtu = "} << \hyperlink{classns3_1_1CsmaNetDevice_a4b2e70ee2ee42f63f3756728ec592bc1}{m\_mtu});
286 
287   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
288 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 29


\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Set\+Node@{Set\+Node}}
\index{Set\+Node@{Set\+Node}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Node(\+Ptr$<$ Node $>$ node)}{SetNode(Ptr< Node > node)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Csma\+Net\+Device\+::\+Set\+Node (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1CsmaNetDevice_a81187adfa932888b01c57f146eb49991}{}\label{classns3_1_1CsmaNetDevice_a81187adfa932888b01c57f146eb49991}
Set the node to which this device is being attached.


\begin{DoxyParams}{Parameters}
{\em node} & \hyperlink{classns3_1_1Ptr}{Ptr} to the \hyperlink{classns3_1_1Node}{Node} to which the device is being attached. \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1NetDevice_a3ae520ae06e93b957f0f56f113319a08}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1045 \{
1046   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (node);
1047 
1048   \hyperlink{classns3_1_1CsmaNetDevice_a9dbd678469e1b1efe74a45b868ead509}{m\_node} = node;
1049 \}
\end{DoxyCode}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Set\+Promisc\+Receive\+Callback@{Set\+Promisc\+Receive\+Callback}}
\index{Set\+Promisc\+Receive\+Callback@{Set\+Promisc\+Receive\+Callback}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Promisc\+Receive\+Callback(\+Promisc\+Receive\+Callback cb)}{SetPromiscReceiveCallback(PromiscReceiveCallback cb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Csma\+Net\+Device\+::\+Set\+Promisc\+Receive\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Promisc\+Receive\+Callback}}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1CsmaNetDevice_a826a66d3c380a4b2190d1a6b1fb5a6e2}{}\label{classns3_1_1CsmaNetDevice_a826a66d3c380a4b2190d1a6b1fb5a6e2}

\begin{DoxyParams}{Parameters}
{\em cb} & callback to invoke whenever a packet has been received in promiscuous mode and must be forwarded to the higher layers.\\
\hline
\end{DoxyParams}
Enables netdevice promiscuous mode and sets the callback that will handle promiscuous mode packets. Note, promiscuous mode packets means {\itshape all} packets, including those packets that can be sensed by the netdevice but which are intended to be received by other hosts. 

Implements \hyperlink{classns3_1_1NetDevice_a3968946bdbb74d47d7b13612baad7d6d}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1075 \{
1076   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (&cb);
1077   \hyperlink{classns3_1_1CsmaNetDevice_a4c9c0533341d76fe278fbef18525b228}{m\_promiscRxCallback} = cb;
1078 \}
\end{DoxyCode}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Set\+Queue@{Set\+Queue}}
\index{Set\+Queue@{Set\+Queue}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Queue(\+Ptr$<$ Queue$<$ Packet $>$ $>$ queue)}{SetQueue(Ptr< Queue< Packet > > queue)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Csma\+Net\+Device\+::\+Set\+Queue (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Queue}$<$ {\bf Packet} $>$ $>$}]{queue}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1CsmaNetDevice_ae5cc491c6cafc21896c88c8d313c3bfe}{}\label{classns3_1_1CsmaNetDevice_ae5cc491c6cafc21896c88c8d313c3bfe}
Attach a queue to the \hyperlink{classns3_1_1CsmaNetDevice}{Csma\+Net\+Device}.

The \hyperlink{classns3_1_1CsmaNetDevice}{Csma\+Net\+Device} \char`\"{}owns\char`\"{} a queue. This queue may be set by higher level topology objects to implement a particular queueing method such as Drop\+Tail.

\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Queue}{Queue} 

\hyperlink{classns3_1_1DropTailQueue}{Drop\+Tail\+Queue} 
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em queue} & a \hyperlink{classns3_1_1Ptr}{Ptr} to the queue for being assigned to the device. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
710 \{
711   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (q);
712   \hyperlink{classns3_1_1CsmaNetDevice_a499be4029c01107f7f16f5371843ffde}{m\_queue} = q;
713 \}
\end{DoxyCode}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Set\+Receive\+Callback@{Set\+Receive\+Callback}}
\index{Set\+Receive\+Callback@{Set\+Receive\+Callback}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Receive\+Callback(\+Net\+Device\+::\+Receive\+Callback cb)}{SetReceiveCallback(NetDevice::ReceiveCallback cb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Csma\+Net\+Device\+::\+Set\+Receive\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Net\+Device\+::\+Receive\+Callback}}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1CsmaNetDevice_a7aece222e096a5526a28e7bf71e609f8}{}\label{classns3_1_1CsmaNetDevice_a7aece222e096a5526a28e7bf71e609f8}
Set the callback to be used to notify higher layers when a packet has been received.


\begin{DoxyParams}{Parameters}
{\em cb} & The callback. \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1NetDevice_ac63e4d5668e421fec4b5d37f32e7dd18}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1060 \{
1061   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (&cb);
1062   \hyperlink{classns3_1_1CsmaNetDevice_a18646390c167ad8f0f8b8795a9052031}{m\_rxCallback} = cb;
1063 \}
\end{DoxyCode}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Set\+Receive\+Enable@{Set\+Receive\+Enable}}
\index{Set\+Receive\+Enable@{Set\+Receive\+Enable}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Receive\+Enable(bool enable)}{SetReceiveEnable(bool enable)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Csma\+Net\+Device\+::\+Set\+Receive\+Enable (
\begin{DoxyParamCaption}
\item[{bool}]{enable}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1CsmaNetDevice_a2bb51b44d9ef6aa86350c83f059d3f8f}{}\label{classns3_1_1CsmaNetDevice_a2bb51b44d9ef6aa86350c83f059d3f8f}
Enable or disable the receive side of the network device.


\begin{DoxyParams}{Parameters}
{\em enable} & Enable the receive side if true, otherwise disable. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
307 \{
308   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (receiveEnable);
309   \hyperlink{classns3_1_1CsmaNetDevice_a8d844dcce78846a16c9a52c752f9736f}{m\_receiveEnable} = receiveEnable;
310 \}
\end{DoxyCode}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Set\+Receive\+Error\+Model@{Set\+Receive\+Error\+Model}}
\index{Set\+Receive\+Error\+Model@{Set\+Receive\+Error\+Model}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Receive\+Error\+Model(\+Ptr$<$ Error\+Model $>$ em)}{SetReceiveErrorModel(Ptr< ErrorModel > em)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Csma\+Net\+Device\+::\+Set\+Receive\+Error\+Model (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Error\+Model} $>$}]{em}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1CsmaNetDevice_aa129e661ab34da9e2145f69847dd5447}{}\label{classns3_1_1CsmaNetDevice_aa129e661ab34da9e2145f69847dd5447}
Attach a receive \hyperlink{classns3_1_1ErrorModel}{Error\+Model} to the \hyperlink{classns3_1_1CsmaNetDevice}{Csma\+Net\+Device}.

The \hyperlink{classns3_1_1CsmaNetDevice}{Csma\+Net\+Device} may optionally include an \hyperlink{classns3_1_1ErrorModel}{Error\+Model} in the packet receive chain to simulate data errors in during transmission.

\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1ErrorModel}{Error\+Model} 
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em em} & a pointer to the \hyperlink{classns3_1_1ErrorModel}{Error\+Model} \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
717 \{
718   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (em);
719   \hyperlink{classns3_1_1CsmaNetDevice_aeef9196f9c7c46c99a7f703dc46c0207}{m\_receiveErrorModel} = em; 
720 \}
\end{DoxyCode}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Set\+Send\+Enable@{Set\+Send\+Enable}}
\index{Set\+Send\+Enable@{Set\+Send\+Enable}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Send\+Enable(bool enable)}{SetSendEnable(bool enable)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Csma\+Net\+Device\+::\+Set\+Send\+Enable (
\begin{DoxyParamCaption}
\item[{bool}]{enable}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1CsmaNetDevice_aa3a93694ca83a26f513008a7d8f36dbe}{}\label{classns3_1_1CsmaNetDevice_aa3a93694ca83a26f513008a7d8f36dbe}
Enable or disable the send side of the network device.


\begin{DoxyParams}{Parameters}
{\em enable} & Enable the send side if true, otherwise disable. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
300 \{
301   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (sendEnable);
302   \hyperlink{classns3_1_1CsmaNetDevice_ac5bde9af7f582a6d707a68061c114fdf}{m\_sendEnable} = sendEnable;
303 \}
\end{DoxyCode}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Supports\+Send\+From@{Supports\+Send\+From}}
\index{Supports\+Send\+From@{Supports\+Send\+From}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Supports\+Send\+From(void) const }{SupportsSendFrom(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Csma\+Net\+Device\+::\+Supports\+Send\+From (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1CsmaNetDevice_ad660af503a5fb898d8f07507159c82d3}{}\label{classns3_1_1CsmaNetDevice_ad660af503a5fb898d8f07507159c82d3}
\begin{DoxyReturn}{Returns}
true if this interface supports a bridging mode, false otherwise. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a04793d220b54c40e110ebf86dae5b25c}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
1082 \{
1083   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
1084   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1085 \}
\end{DoxyCode}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Transmit\+Abort@{Transmit\+Abort}}
\index{Transmit\+Abort@{Transmit\+Abort}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Transmit\+Abort(void)}{TransmitAbort(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Csma\+Net\+Device\+::\+Transmit\+Abort (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_ac6b19bd1a3d2f257a56c3bf8e026ad88}{}\label{classns3_1_1CsmaNetDevice_ac6b19bd1a3d2f257a56c3bf8e026ad88}
Aborts the transmission of the current packet

If the net device has tried to transmit a packet for more times than the maximum allowed number of retries (channel always busy) then the packet is dropped. 
\begin{DoxyCode}
570 \{
571   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
572 
573   \textcolor{comment}{//}
574   \textcolor{comment}{// When we started the process of transmitting the current packet, it was }
575   \textcolor{comment}{// placed in m\_currentPkt.  So we had better find one there.}
576   \textcolor{comment}{//}
577   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt} != 0, \textcolor{stringliteral}{"CsmaNetDevice::TransmitAbort(): m\_currentPkt
       zero"});
578   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"m\_currentPkt="} << \hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt});
579   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Pkt UID is "} << \hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt}->\hyperlink{classns3_1_1Packet_a1f212c825b50e54d94f5b9ae99592e6a}{GetUid} () << \textcolor{stringliteral}{")"});
580 
581   \hyperlink{classns3_1_1CsmaNetDevice_ad2a07cf80f83d9ce17d9280775e9a1f8}{m\_phyTxDropTrace} (\hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt});
582   \hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt} = 0;
583 
584   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\hyperlink{classns3_1_1CsmaNetDevice_af07031cad3f8bd8c4b33ba77fa706e99}{m\_txMachineState} == \hyperlink{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4a415034117cf23985cd8d3481944cd731}{BACKOFF}, \textcolor{stringliteral}{"Must be in BACKOFF state
       to abort.  Tx state is: "} << \hyperlink{classns3_1_1CsmaNetDevice_af07031cad3f8bd8c4b33ba77fa706e99}{m\_txMachineState});
585 
586   \textcolor{comment}{// }
587   \textcolor{comment}{// We're done with that one, so reset the backoff algorithm and ready the}
588   \textcolor{comment}{// transmit state machine.}
589   \textcolor{comment}{//}
590   \hyperlink{classns3_1_1CsmaNetDevice_a2cb5f9baf0a19a7ea6527002b0299403}{m\_backoff}.\hyperlink{classns3_1_1Backoff_a103dc910a4f81c7444e873be3d055237}{ResetBackoffTime} ();
591   \hyperlink{classns3_1_1CsmaNetDevice_af07031cad3f8bd8c4b33ba77fa706e99}{m\_txMachineState} = \hyperlink{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4a50a4f4ac7775f95f3ec1d4624213bee2}{READY};
592 
593   \textcolor{comment}{//}
594   \textcolor{comment}{// If there is another packet on the input queue, we need to start trying to }
595   \textcolor{comment}{// get that out.  If the queue is empty we just wait until someone puts one}
596   \textcolor{comment}{// in.}
597   \textcolor{comment}{//}
598   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1CsmaNetDevice_a499be4029c01107f7f16f5371843ffde}{m\_queue}->IsEmpty ())
599     \{
600       \textcolor{keywordflow}{return};
601     \}
602   \textcolor{keywordflow}{else}
603     \{
604       Ptr<Packet> packet = \hyperlink{classns3_1_1CsmaNetDevice_a499be4029c01107f7f16f5371843ffde}{m\_queue}->Dequeue ();
605       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (packet != 0, \textcolor{stringliteral}{"CsmaNetDevice::TransmitAbort(): IsEmpty false but no Packet
       on queue?"});
606       \hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt} = packet;
607       \hyperlink{classns3_1_1CsmaNetDevice_a88e5994b762e01f74606742a7f15b797}{m\_snifferTrace} (\hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt});
608       \hyperlink{classns3_1_1CsmaNetDevice_aae7fbd28077e7ac8efee738c4194ed16}{m\_promiscSnifferTrace} (\hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt});
609       \hyperlink{classns3_1_1CsmaNetDevice_a4120db41aa1f41a5e1d59220b306f1e8}{TransmitStart} ();
610     \}
611 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 30




Here is the caller graph for this function\+:
% FIG 31


\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Transmit\+Complete\+Event@{Transmit\+Complete\+Event}}
\index{Transmit\+Complete\+Event@{Transmit\+Complete\+Event}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Transmit\+Complete\+Event(void)}{TransmitCompleteEvent(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Csma\+Net\+Device\+::\+Transmit\+Complete\+Event (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_a3f908850087739df8d27e1a7207261aa}{}\label{classns3_1_1CsmaNetDevice_a3f908850087739df8d27e1a7207261aa}
Stop Sending a \hyperlink{classns3_1_1Packet}{Packet} Down the Wire and Begin the Interframe Gap.

The Transmit\+Complete\+Event method is used internally to finish the process of sending a packet out on the channel. During execution of this method the Transmit\+End method is called on the channel to let it know that the physical device this class represents has finished sending simulated signals. The channel uses this event to begin its speed of light delay timer after which it notifies the Net Device(s) at the other end of the link that new bits have arrived (it delivers the \hyperlink{classns3_1_1Packet}{Packet}). During this method, the net device also schedules the Transmit\+Ready\+Event at which time the transmitter becomes ready to send the next packet.

\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1CsmaChannel_a720272c5f63d9bdd32d7ca43925ee6d2}{Csma\+Channel\+::\+Transmit\+End} () 

\hyperlink{classns3_1_1CsmaNetDevice_a2cb06577684f06daca6c24b4ef4e8910}{Transmit\+Ready\+Event} () 
\end{DoxySeeAlso}

\begin{DoxyCode}
615 \{
616   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
617 
618   \textcolor{comment}{//}
619   \textcolor{comment}{// This function is called to finish the  process of transmitting a packet.}
620   \textcolor{comment}{// We need to tell the channel that we've stopped wiggling the wire and}
621   \textcolor{comment}{// schedule an event that will be executed when it's time to re-enable}
622   \textcolor{comment}{// the transmitter after the interframe gap.}
623   \textcolor{comment}{//}
624   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\hyperlink{classns3_1_1CsmaNetDevice_af07031cad3f8bd8c4b33ba77fa706e99}{m\_txMachineState} == \hyperlink{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4a84e62edebfa7e85ec23402f94bb1361a}{BUSY}, \textcolor{stringliteral}{"
      CsmaNetDevice::transmitCompleteEvent(): Must be BUSY if transmitting"});
625   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1CsmaNetDevice_a5c3ecdf9a63006b106dff1c110e736ff}{m\_channel}->GetState () == \hyperlink{namespacens3_aff37503a9e9f2dbe82b374050a73e105a5c6ba0512d778b658dc105cc604de3b3}{TRANSMITTING});
626   \hyperlink{classns3_1_1CsmaNetDevice_af07031cad3f8bd8c4b33ba77fa706e99}{m\_txMachineState} = \hyperlink{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4ab6c58ad6a7f71f004ea78a8ccb9362c6}{GAP};
627 
628   \textcolor{comment}{//}
629   \textcolor{comment}{// When we started transmitting the current packet, it was placed in }
630   \textcolor{comment}{// m\_currentPkt.  So we had better find one there.}
631   \textcolor{comment}{//}
632   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt} != 0, \textcolor{stringliteral}{"CsmaNetDevice::TransmitCompleteEvent():
       m\_currentPkt zero"});
633   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"m\_currentPkt="} << \hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt});
634   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Pkt UID is "} << \hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt}->\hyperlink{classns3_1_1Packet_a1f212c825b50e54d94f5b9ae99592e6a}{GetUid} () << \textcolor{stringliteral}{")"});
635 
636   \hyperlink{classns3_1_1CsmaNetDevice_a5c3ecdf9a63006b106dff1c110e736ff}{m\_channel}->TransmitEnd (); 
637   \hyperlink{classns3_1_1CsmaNetDevice_a8cac1ff27eec4db589ed00545f942a21}{m\_phyTxEndTrace} (\hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt});
638   \hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt} = 0;
639 
640   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Schedule TransmitReadyEvent in "} << 
      \hyperlink{classns3_1_1CsmaNetDevice_ae581d7910d91ab9aaf760288ccf75c55}{m\_tInterframeGap}.\hyperlink{classns3_1_1Time_a8f20d5c3b0902d7b4320982f340b57c8}{GetSeconds} () << \textcolor{stringliteral}{"sec"});
641 
642   \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{classns3_1_1CsmaNetDevice_ae581d7910d91ab9aaf760288ccf75c55}{m\_tInterframeGap}, &
      \hyperlink{classns3_1_1CsmaNetDevice_a2cb06577684f06daca6c24b4ef4e8910}{CsmaNetDevice::TransmitReadyEvent}, \textcolor{keyword}{this});
643 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 32




Here is the caller graph for this function\+:
% FIG 33


\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Transmit\+Ready\+Event@{Transmit\+Ready\+Event}}
\index{Transmit\+Ready\+Event@{Transmit\+Ready\+Event}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Transmit\+Ready\+Event(void)}{TransmitReadyEvent(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Csma\+Net\+Device\+::\+Transmit\+Ready\+Event (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_a2cb06577684f06daca6c24b4ef4e8910}{}\label{classns3_1_1CsmaNetDevice_a2cb06577684f06daca6c24b4ef4e8910}
Cause the Transmitter to Become Ready to Send Another \hyperlink{classns3_1_1Packet}{Packet}.

The Transmit\+Ready\+Event method is used internally to re-\/enable the transmit machine of the net device. It is scheduled after a suitable interframe gap after the completion of the previous transmission. The queue is checked at this time, and if there is a packet waiting on the queue, the transmission process is begun.

If a packet is in the queue, it is extracted for the queue as the next packet to be transmitted by the net device.

\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1CsmaNetDevice_a4120db41aa1f41a5e1d59220b306f1e8}{Transmit\+Start} () 
\end{DoxySeeAlso}

\begin{DoxyCode}
647 \{
648   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
649 
650   \textcolor{comment}{//}
651   \textcolor{comment}{// This function is called to enable the transmitter after the interframe}
652   \textcolor{comment}{// gap has passed.  If there are pending transmissions, we use this opportunity}
653   \textcolor{comment}{// to start the next transmit.}
654   \textcolor{comment}{//}
655   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\hyperlink{classns3_1_1CsmaNetDevice_af07031cad3f8bd8c4b33ba77fa706e99}{m\_txMachineState} == \hyperlink{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4ab6c58ad6a7f71f004ea78a8ccb9362c6}{GAP}, \textcolor{stringliteral}{"
      CsmaNetDevice::TransmitReadyEvent(): Must be in interframe gap"});
656   \hyperlink{classns3_1_1CsmaNetDevice_af07031cad3f8bd8c4b33ba77fa706e99}{m\_txMachineState} = \hyperlink{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4a50a4f4ac7775f95f3ec1d4624213bee2}{READY};
657 
658   \textcolor{comment}{//}
659   \textcolor{comment}{// We expect that the packet we had been transmitting was cleared when the }
660   \textcolor{comment}{// TransmitCompleteEvent() was executed.}
661   \textcolor{comment}{//}
662   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt} == 0, \textcolor{stringliteral}{"CsmaNetDevice::TransmitReadyEvent():
       m\_currentPkt nonzero"});
663 
664   \textcolor{comment}{//}
665   \textcolor{comment}{// Get the next packet from the queue for transmitting}
666   \textcolor{comment}{//}
667   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1CsmaNetDevice_a499be4029c01107f7f16f5371843ffde}{m\_queue}->IsEmpty ())
668     \{
669       \textcolor{keywordflow}{return};
670     \}
671   \textcolor{keywordflow}{else}
672     \{
673       Ptr<Packet> packet = \hyperlink{classns3_1_1CsmaNetDevice_a499be4029c01107f7f16f5371843ffde}{m\_queue}->Dequeue ();
674       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (packet != 0, \textcolor{stringliteral}{"CsmaNetDevice::TransmitReadyEvent(): IsEmpty false but no
       Packet on queue?"});
675       \hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt} = packet;
676       \hyperlink{classns3_1_1CsmaNetDevice_a88e5994b762e01f74606742a7f15b797}{m\_snifferTrace} (\hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt});
677       \hyperlink{classns3_1_1CsmaNetDevice_aae7fbd28077e7ac8efee738c4194ed16}{m\_promiscSnifferTrace} (\hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt});
678       \hyperlink{classns3_1_1CsmaNetDevice_a4120db41aa1f41a5e1d59220b306f1e8}{TransmitStart} ();
679     \}
680 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 34




Here is the caller graph for this function\+:
% FIG 35


\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!Transmit\+Start@{Transmit\+Start}}
\index{Transmit\+Start@{Transmit\+Start}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{Transmit\+Start()}{TransmitStart()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Csma\+Net\+Device\+::\+Transmit\+Start (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_a4120db41aa1f41a5e1d59220b306f1e8}{}\label{classns3_1_1CsmaNetDevice_a4120db41aa1f41a5e1d59220b306f1e8}
Start Sending a \hyperlink{classns3_1_1Packet}{Packet} Down the Wire.

The Transmit\+Start method is the method that is used internally in the \hyperlink{classns3_1_1CsmaNetDevice}{Csma\+Net\+Device} to begin the process of sending a packet out on the channel. A corresponding method is called on the channel to let it know that the physical device this class represents has actually started sending signals, this causes the channel to enter the B\+U\+SY state. An event is scheduled for the time at which the bits have been completely transmitted.

If the channel is found to be B\+U\+SY, this method reschedules itself for execution at a later time (within the backoff period).

\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1CsmaChannel_a413b29b1ffbcb8f2c4b3de3ed124dc95}{Csma\+Channel\+::\+Transmit\+Start} () 

\hyperlink{classns3_1_1CsmaNetDevice_a3f908850087739df8d27e1a7207261aa}{Transmit\+Complete\+Event} () 
\end{DoxySeeAlso}

\begin{DoxyCode}
477 \{
478   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
479 
480   \textcolor{comment}{//}
481   \textcolor{comment}{// This function is called to start the process of transmitting a packet.  We }
482   \textcolor{comment}{// expect that the packet to transmit will be found in m\_currentPkt.}
483   \textcolor{comment}{//}
484   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt} != 0, \textcolor{stringliteral}{"CsmaNetDevice::TransmitStart(): m\_currentPkt
       not set"});
485 
486   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"m\_currentPkt = "} << \hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt});
487   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"UID = "} << \hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt}->\hyperlink{classns3_1_1Packet_a1f212c825b50e54d94f5b9ae99592e6a}{GetUid} ());
488 
489   \textcolor{comment}{//}
490   \textcolor{comment}{// Only transmit if the send side of net device is enabled}
491   \textcolor{comment}{//}
492   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1CsmaNetDevice_a40e5946f8807cb9c65857789c3c2b269}{IsSendEnabled} () == \textcolor{keyword}{false})
493     \{
494       \hyperlink{classns3_1_1CsmaNetDevice_ad2a07cf80f83d9ce17d9280775e9a1f8}{m\_phyTxDropTrace} (\hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt});
495       \hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt} = 0;
496       \textcolor{keywordflow}{return};
497     \}
498 
499   \textcolor{comment}{//}
500   \textcolor{comment}{// Somebody has called here telling us to start transmitting a packet.  They }
501   \textcolor{comment}{// can only do this if the state machine is in the READY or BACKOFF state.}
502   \textcolor{comment}{// Specifically, if we are ready to start transmitting, we cannot already}
503   \textcolor{comment}{// be transmitting (i.e., BUSY)}
504   \textcolor{comment}{//}
505   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} ((\hyperlink{classns3_1_1CsmaNetDevice_af07031cad3f8bd8c4b33ba77fa706e99}{m\_txMachineState} == \hyperlink{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4a50a4f4ac7775f95f3ec1d4624213bee2}{READY}) || (
      \hyperlink{classns3_1_1CsmaNetDevice_af07031cad3f8bd8c4b33ba77fa706e99}{m\_txMachineState} == \hyperlink{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4a415034117cf23985cd8d3481944cd731}{BACKOFF}), 
506                  \textcolor{stringliteral}{"Must be READY to transmit. Tx state is: "} << \hyperlink{classns3_1_1CsmaNetDevice_af07031cad3f8bd8c4b33ba77fa706e99}{m\_txMachineState});
507 
508   \textcolor{comment}{//}
509   \textcolor{comment}{// Now we have to sense the state of the medium and either start transmitting}
510   \textcolor{comment}{// if it is idle, or backoff our transmission if someone else is on the wire.}
511   \textcolor{comment}{//}
512   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1CsmaNetDevice_a5c3ecdf9a63006b106dff1c110e736ff}{m\_channel}->GetState () != \hyperlink{namespacens3_aff37503a9e9f2dbe82b374050a73e105acb448301f46bfb634e8e803a6fd21264}{IDLE})
513     \{
514       \textcolor{comment}{//}
515       \textcolor{comment}{// The channel is busy -- backoff and rechedule TransmitStart() unless}
516       \textcolor{comment}{// we have exhausted all of our retries.}
517       \textcolor{comment}{//}
518       \hyperlink{classns3_1_1CsmaNetDevice_af07031cad3f8bd8c4b33ba77fa706e99}{m\_txMachineState} = \hyperlink{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4a415034117cf23985cd8d3481944cd731}{BACKOFF};
519 
520       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1CsmaNetDevice_a2cb5f9baf0a19a7ea6527002b0299403}{m\_backoff}.\hyperlink{classns3_1_1Backoff_a273e3444ab023da993742d4bdd72e982}{MaxRetriesReached} ())
521         \{ 
522           \textcolor{comment}{//}
523           \textcolor{comment}{// Too many retries, abort transmission of packet}
524           \textcolor{comment}{//}
525           \hyperlink{classns3_1_1CsmaNetDevice_ac6b19bd1a3d2f257a56c3bf8e026ad88}{TransmitAbort} ();
526         \} 
527       \textcolor{keywordflow}{else} 
528         \{
529           \hyperlink{classns3_1_1CsmaNetDevice_a1f035d24ccf03e5731243e0b22665cb0}{m\_macTxBackoffTrace} (\hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt});
530 
531           \hyperlink{classns3_1_1CsmaNetDevice_a2cb5f9baf0a19a7ea6527002b0299403}{m\_backoff}.\hyperlink{classns3_1_1Backoff_af0b4605876aeb05e9cf1a90acf6b5f86}{IncrNumRetries} ();
532           \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} backoffTime = \hyperlink{classns3_1_1CsmaNetDevice_a2cb5f9baf0a19a7ea6527002b0299403}{m\_backoff}.\hyperlink{classns3_1_1Backoff_ab805c5622b6c624d8d929be36ac6cc93}{GetBackoffTime} ();
533 
534           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Channel busy, backing off for "} << backoffTime.GetSeconds () << \textcolor{stringliteral}{" sec"}
      );
535 
536           \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (backoffTime, &
      \hyperlink{classns3_1_1CsmaNetDevice_a4120db41aa1f41a5e1d59220b306f1e8}{CsmaNetDevice::TransmitStart}, \textcolor{keyword}{this});
537         \}
538     \} 
539   \textcolor{keywordflow}{else} 
540     \{
541       \textcolor{comment}{//}
542       \textcolor{comment}{// The channel is free, transmit the packet}
543       \textcolor{comment}{//}
544       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1CsmaNetDevice_a5c3ecdf9a63006b106dff1c110e736ff}{m\_channel}->TransmitStart (\hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt}, 
      \hyperlink{classns3_1_1CsmaNetDevice_a8cfc188ed680554dfa0b70cc6fc5e5ba}{m\_deviceId}) == \textcolor{keyword}{false})
545         \{
546           \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Channel TransmitStart returns an error"});
547           \hyperlink{classns3_1_1CsmaNetDevice_ad2a07cf80f83d9ce17d9280775e9a1f8}{m\_phyTxDropTrace} (\hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt});
548           \hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt} = 0;
549           \hyperlink{classns3_1_1CsmaNetDevice_af07031cad3f8bd8c4b33ba77fa706e99}{m\_txMachineState} = \hyperlink{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4a50a4f4ac7775f95f3ec1d4624213bee2}{READY};
550         \} 
551       \textcolor{keywordflow}{else} 
552         \{
553           \textcolor{comment}{//}
554           \textcolor{comment}{// Transmission succeeded, reset the backoff time parameters and}
555           \textcolor{comment}{// schedule a transmit complete event.}
556           \textcolor{comment}{//}
557           \hyperlink{classns3_1_1CsmaNetDevice_a2cb5f9baf0a19a7ea6527002b0299403}{m\_backoff}.\hyperlink{classns3_1_1Backoff_a103dc910a4f81c7444e873be3d055237}{ResetBackoffTime} ();
558           \hyperlink{classns3_1_1CsmaNetDevice_af07031cad3f8bd8c4b33ba77fa706e99}{m\_txMachineState} = \hyperlink{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4a84e62edebfa7e85ec23402f94bb1361a}{BUSY};
559           \hyperlink{classns3_1_1CsmaNetDevice_a6c5deac5e6a05a2013175402d4e22985}{m\_phyTxBeginTrace} (\hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt});
560 
561           \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} tEvent = \hyperlink{classns3_1_1CsmaNetDevice_a3051c17d676b00f0b2e95291d16c3769}{m\_bps}.\hyperlink{classns3_1_1DataRate_a5daa3d3b37b7df8bb75d94a6540fd17e}{CalculateBytesTxTime} (
      \hyperlink{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{m\_currentPkt}->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ());
562           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Schedule TransmitCompleteEvent in "} << tEvent.GetSeconds () << \textcolor{stringliteral}{"sec"});
563           \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (tEvent, &
      \hyperlink{classns3_1_1CsmaNetDevice_a3f908850087739df8d27e1a7207261aa}{CsmaNetDevice::TransmitCompleteEvent}, \textcolor{keyword}{this});
564         \}
565     \}
566 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 36




Here is the caller graph for this function\+:
% FIG 37




\subsection{Member Data Documentation}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!D\+E\+F\+A\+U\+L\+T\+\_\+\+M\+TU@{D\+E\+F\+A\+U\+L\+T\+\_\+\+M\+TU}}
\index{D\+E\+F\+A\+U\+L\+T\+\_\+\+M\+TU@{D\+E\+F\+A\+U\+L\+T\+\_\+\+M\+TU}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{D\+E\+F\+A\+U\+L\+T\+\_\+\+M\+TU}{DEFAULT_MTU}}]{\setlength{\rightskip}{0pt plus 5cm}const uint16\+\_\+t ns3\+::\+Csma\+Net\+Device\+::\+D\+E\+F\+A\+U\+L\+T\+\_\+\+M\+TU = 1500\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_aba1a157c1695a4c02b4dcba3490217e4}{}\label{classns3_1_1CsmaNetDevice_aba1a157c1695a4c02b4dcba3490217e4}
Default Maximum Transmission Unit (M\+TU) for the \hyperlink{classns3_1_1CsmaNetDevice}{Csma\+Net\+Device} \index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+address@{m\+\_\+address}}
\index{m\+\_\+address@{m\+\_\+address}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+address}{m_address}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Mac48\+Address} ns3\+::\+Csma\+Net\+Device\+::m\+\_\+address\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_ae26602a3eb4e97c0aa39ae61b4d028f8}{}\label{classns3_1_1CsmaNetDevice_ae26602a3eb4e97c0aa39ae61b4d028f8}
The M\+AC address which has been assigned to this device. \index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+backoff@{m\+\_\+backoff}}
\index{m\+\_\+backoff@{m\+\_\+backoff}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+backoff}{m_backoff}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Backoff} ns3\+::\+Csma\+Net\+Device\+::m\+\_\+backoff\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_a2cb5f9baf0a19a7ea6527002b0299403}{}\label{classns3_1_1CsmaNetDevice_a2cb5f9baf0a19a7ea6527002b0299403}
Holds the backoff parameters and is used to calculate the next backoff time to use when the channel is busy and the net device is ready to transmit \index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+bps@{m\+\_\+bps}}
\index{m\+\_\+bps@{m\+\_\+bps}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+bps}{m_bps}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Data\+Rate} ns3\+::\+Csma\+Net\+Device\+::m\+\_\+bps\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_a3051c17d676b00f0b2e95291d16c3769}{}\label{classns3_1_1CsmaNetDevice_a3051c17d676b00f0b2e95291d16c3769}
The data rate that the Net Device uses to simulate packet transmission timing. \begin{DoxySeeAlso}{See also}
class \hyperlink{classns3_1_1DataRate}{Data\+Rate} 
\end{DoxySeeAlso}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+channel@{m\+\_\+channel}}
\index{m\+\_\+channel@{m\+\_\+channel}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+channel}{m_channel}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Csma\+Channel}$>$ ns3\+::\+Csma\+Net\+Device\+::m\+\_\+channel\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_a5c3ecdf9a63006b106dff1c110e736ff}{}\label{classns3_1_1CsmaNetDevice_a5c3ecdf9a63006b106dff1c110e736ff}
The \hyperlink{classns3_1_1CsmaChannel}{Csma\+Channel} to which this \hyperlink{classns3_1_1CsmaNetDevice}{Csma\+Net\+Device} has been attached. \begin{DoxySeeAlso}{See also}
class \hyperlink{classns3_1_1CsmaChannel}{Csma\+Channel} 
\end{DoxySeeAlso}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+current\+Pkt@{m\+\_\+current\+Pkt}}
\index{m\+\_\+current\+Pkt@{m\+\_\+current\+Pkt}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+current\+Pkt}{m_currentPkt}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Packet}$>$ ns3\+::\+Csma\+Net\+Device\+::m\+\_\+current\+Pkt\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}{}\label{classns3_1_1CsmaNetDevice_a83f2aa389f676dec6bd1ff056bd61942}
Next packet that will be transmitted (if transmitter is not currently transmitting) or packet that is currently being transmitted. \index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+device\+Id@{m\+\_\+device\+Id}}
\index{m\+\_\+device\+Id@{m\+\_\+device\+Id}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+device\+Id}{m_deviceId}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Csma\+Net\+Device\+::m\+\_\+device\+Id\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_a8cfc188ed680554dfa0b70cc6fc5e5ba}{}\label{classns3_1_1CsmaNetDevice_a8cfc188ed680554dfa0b70cc6fc5e5ba}
Device ID returned by the attached functions. It is used by the mp-\/channel to identify each net device to make sure that only active net devices are writing to the channel \index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+encap\+Mode@{m\+\_\+encap\+Mode}}
\index{m\+\_\+encap\+Mode@{m\+\_\+encap\+Mode}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+encap\+Mode}{m_encapMode}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Encapsulation\+Mode} ns3\+::\+Csma\+Net\+Device\+::m\+\_\+encap\+Mode\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_a3f4b374840119abfa65dbe2075533f39}{}\label{classns3_1_1CsmaNetDevice_a3f4b374840119abfa65dbe2075533f39}
The type of packet that should be created by the Add\+Header function and that should be processed by the Process\+Header function. \index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+if\+Index@{m\+\_\+if\+Index}}
\index{m\+\_\+if\+Index@{m\+\_\+if\+Index}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+if\+Index}{m_ifIndex}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Csma\+Net\+Device\+::m\+\_\+if\+Index\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_af2bb0a9e64ae4ee179256f480e4eed4e}{}\label{classns3_1_1CsmaNetDevice_af2bb0a9e64ae4ee179256f480e4eed4e}
The interface index (really net evice index) that has been assigned to this network device. \index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+link\+Change\+Callbacks@{m\+\_\+link\+Change\+Callbacks}}
\index{m\+\_\+link\+Change\+Callbacks@{m\+\_\+link\+Change\+Callbacks}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+link\+Change\+Callbacks}{m_linkChangeCallbacks}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback} ns3\+::\+Csma\+Net\+Device\+::m\+\_\+link\+Change\+Callbacks\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_a67dd7e65384a1b9f89dfacc1ede41d69}{}\label{classns3_1_1CsmaNetDevice_a67dd7e65384a1b9f89dfacc1ede41d69}
List of callbacks to fire if the link changes state (up or down). \index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+link\+Up@{m\+\_\+link\+Up}}
\index{m\+\_\+link\+Up@{m\+\_\+link\+Up}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+link\+Up}{m_linkUp}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Csma\+Net\+Device\+::m\+\_\+link\+Up\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_afc0b0c430b9ee8e8ddde196c340b5764}{}\label{classns3_1_1CsmaNetDevice_afc0b0c430b9ee8e8ddde196c340b5764}
Flag indicating whether or not the link is up. In this case, whether or not the device is connected to a channel. \index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+mac\+Promisc\+Rx\+Trace@{m\+\_\+mac\+Promisc\+Rx\+Trace}}
\index{m\+\_\+mac\+Promisc\+Rx\+Trace@{m\+\_\+mac\+Promisc\+Rx\+Trace}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+mac\+Promisc\+Rx\+Trace}{m_macPromiscRxTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Csma\+Net\+Device\+::m\+\_\+mac\+Promisc\+Rx\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_a4b22f431d8511abaf9ef4e92cc41ce24}{}\label{classns3_1_1CsmaNetDevice_a4b22f431d8511abaf9ef4e92cc41ce24}
The trace source fired for packets successfully received by the device immediately before being forwarded up to higher layers (at the L2/\+L3 transition). This is a promiscuous trace.

\begin{DoxySeeAlso}{See also}
class Call\+Back\+Trace\+Source 
\end{DoxySeeAlso}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+mac\+Rx\+Drop\+Trace@{m\+\_\+mac\+Rx\+Drop\+Trace}}
\index{m\+\_\+mac\+Rx\+Drop\+Trace@{m\+\_\+mac\+Rx\+Drop\+Trace}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+mac\+Rx\+Drop\+Trace}{m_macRxDropTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Csma\+Net\+Device\+::m\+\_\+mac\+Rx\+Drop\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_a0ba6e9b6d9403e55044c695ece47e311}{}\label{classns3_1_1CsmaNetDevice_a0ba6e9b6d9403e55044c695ece47e311}
The trace source fired for packets successfully received by the device but dropped before being forwarded up to higher layers (at the L2/\+L3 transition).

\begin{DoxySeeAlso}{See also}
class Call\+Back\+Trace\+Source 
\end{DoxySeeAlso}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+mac\+Rx\+Trace@{m\+\_\+mac\+Rx\+Trace}}
\index{m\+\_\+mac\+Rx\+Trace@{m\+\_\+mac\+Rx\+Trace}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+mac\+Rx\+Trace}{m_macRxTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Csma\+Net\+Device\+::m\+\_\+mac\+Rx\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_a40f2a9fcb15d1e44fc918d1639bff18a}{}\label{classns3_1_1CsmaNetDevice_a40f2a9fcb15d1e44fc918d1639bff18a}
The trace source fired for packets successfully received by the device immediately before being forwarded up to higher layers (at the L2/\+L3 transition). This is a non-\/promiscuous trace.

\begin{DoxySeeAlso}{See also}
class Call\+Back\+Trace\+Source 
\end{DoxySeeAlso}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+mac\+Tx\+Backoff\+Trace@{m\+\_\+mac\+Tx\+Backoff\+Trace}}
\index{m\+\_\+mac\+Tx\+Backoff\+Trace@{m\+\_\+mac\+Tx\+Backoff\+Trace}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+mac\+Tx\+Backoff\+Trace}{m_macTxBackoffTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Csma\+Net\+Device\+::m\+\_\+mac\+Tx\+Backoff\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_a1f035d24ccf03e5731243e0b22665cb0}{}\label{classns3_1_1CsmaNetDevice_a1f035d24ccf03e5731243e0b22665cb0}
The trace source fired when the mac layer is forced to begin the backoff process for a packet. This can happen a number of times as the backoff sequence is repeated with increasing delays.

\begin{DoxySeeAlso}{See also}
class Call\+Back\+Trace\+Source 
\end{DoxySeeAlso}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+mac\+Tx\+Drop\+Trace@{m\+\_\+mac\+Tx\+Drop\+Trace}}
\index{m\+\_\+mac\+Tx\+Drop\+Trace@{m\+\_\+mac\+Tx\+Drop\+Trace}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+mac\+Tx\+Drop\+Trace}{m_macTxDropTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Csma\+Net\+Device\+::m\+\_\+mac\+Tx\+Drop\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_ac6e2a81eedea1fa443600bbac37842b2}{}\label{classns3_1_1CsmaNetDevice_ac6e2a81eedea1fa443600bbac37842b2}
The trace source fired when packets coming into the \char`\"{}top\char`\"{} of the device at the L3/\+L2 transition are dropped before being queued for transmission.

\begin{DoxySeeAlso}{See also}
class Call\+Back\+Trace\+Source 
\end{DoxySeeAlso}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+mac\+Tx\+Trace@{m\+\_\+mac\+Tx\+Trace}}
\index{m\+\_\+mac\+Tx\+Trace@{m\+\_\+mac\+Tx\+Trace}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+mac\+Tx\+Trace}{m_macTxTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Csma\+Net\+Device\+::m\+\_\+mac\+Tx\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_acd8f03ea3f02befd6caa2b07065ac80a}{}\label{classns3_1_1CsmaNetDevice_acd8f03ea3f02befd6caa2b07065ac80a}
The trace source fired when packets come into the \char`\"{}top\char`\"{} of the device at the L3/\+L2 transition, before being queued for transmission.

\begin{DoxySeeAlso}{See also}
class Call\+Back\+Trace\+Source 
\end{DoxySeeAlso}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+mtu@{m\+\_\+mtu}}
\index{m\+\_\+mtu@{m\+\_\+mtu}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+mtu}{m_mtu}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Csma\+Net\+Device\+::m\+\_\+mtu\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_a4b2e70ee2ee42f63f3756728ec592bc1}{}\label{classns3_1_1CsmaNetDevice_a4b2e70ee2ee42f63f3756728ec592bc1}
The Maximum Transmission Unit. This corresponds to the maximum number of bytes that can be transmitted as seen from higher layers. This corresponds to the 1500 byte M\+TU size often seen on IP over Ethernet. \index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+node@{m\+\_\+node}}
\index{m\+\_\+node@{m\+\_\+node}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+node}{m_node}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Node}$>$ ns3\+::\+Csma\+Net\+Device\+::m\+\_\+node\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_a9dbd678469e1b1efe74a45b868ead509}{}\label{classns3_1_1CsmaNetDevice_a9dbd678469e1b1efe74a45b868ead509}
The \hyperlink{classns3_1_1Node}{Node} to which this device is attached. \index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+phy\+Rx\+Begin\+Trace@{m\+\_\+phy\+Rx\+Begin\+Trace}}
\index{m\+\_\+phy\+Rx\+Begin\+Trace@{m\+\_\+phy\+Rx\+Begin\+Trace}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+phy\+Rx\+Begin\+Trace}{m_phyRxBeginTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Csma\+Net\+Device\+::m\+\_\+phy\+Rx\+Begin\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_abdbb5dd4d62426a5ad0f6cb8cb030b3b}{}\label{classns3_1_1CsmaNetDevice_abdbb5dd4d62426a5ad0f6cb8cb030b3b}
The trace source fired when a packet begins the reception process from the medium.

\begin{DoxySeeAlso}{See also}
class Call\+Back\+Trace\+Source 
\end{DoxySeeAlso}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+phy\+Rx\+Drop\+Trace@{m\+\_\+phy\+Rx\+Drop\+Trace}}
\index{m\+\_\+phy\+Rx\+Drop\+Trace@{m\+\_\+phy\+Rx\+Drop\+Trace}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+phy\+Rx\+Drop\+Trace}{m_phyRxDropTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Csma\+Net\+Device\+::m\+\_\+phy\+Rx\+Drop\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_a9413b693a3028dcccb20f653bad58bc0}{}\label{classns3_1_1CsmaNetDevice_a9413b693a3028dcccb20f653bad58bc0}
The trace source fired when the phy layer drops a packet it has received.

\begin{DoxySeeAlso}{See also}
class Call\+Back\+Trace\+Source 
\end{DoxySeeAlso}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+phy\+Rx\+End\+Trace@{m\+\_\+phy\+Rx\+End\+Trace}}
\index{m\+\_\+phy\+Rx\+End\+Trace@{m\+\_\+phy\+Rx\+End\+Trace}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+phy\+Rx\+End\+Trace}{m_phyRxEndTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Csma\+Net\+Device\+::m\+\_\+phy\+Rx\+End\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_afe2bac4b10c5d73f78e11668a3e6a679}{}\label{classns3_1_1CsmaNetDevice_afe2bac4b10c5d73f78e11668a3e6a679}
The trace source fired when a packet ends the reception process from the medium.

\begin{DoxySeeAlso}{See also}
class Call\+Back\+Trace\+Source 
\end{DoxySeeAlso}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+phy\+Tx\+Begin\+Trace@{m\+\_\+phy\+Tx\+Begin\+Trace}}
\index{m\+\_\+phy\+Tx\+Begin\+Trace@{m\+\_\+phy\+Tx\+Begin\+Trace}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+phy\+Tx\+Begin\+Trace}{m_phyTxBeginTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Csma\+Net\+Device\+::m\+\_\+phy\+Tx\+Begin\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_a6c5deac5e6a05a2013175402d4e22985}{}\label{classns3_1_1CsmaNetDevice_a6c5deac5e6a05a2013175402d4e22985}
The trace source fired when a packet begins the transmission process on the medium.

\begin{DoxySeeAlso}{See also}
class Call\+Back\+Trace\+Source 
\end{DoxySeeAlso}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+phy\+Tx\+Drop\+Trace@{m\+\_\+phy\+Tx\+Drop\+Trace}}
\index{m\+\_\+phy\+Tx\+Drop\+Trace@{m\+\_\+phy\+Tx\+Drop\+Trace}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+phy\+Tx\+Drop\+Trace}{m_phyTxDropTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Csma\+Net\+Device\+::m\+\_\+phy\+Tx\+Drop\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_ad2a07cf80f83d9ce17d9280775e9a1f8}{}\label{classns3_1_1CsmaNetDevice_ad2a07cf80f83d9ce17d9280775e9a1f8}
The trace source fired when the phy layer drops a packet as it tries to transmit it.

\begin{DoxySeeAlso}{See also}
class Call\+Back\+Trace\+Source 
\end{DoxySeeAlso}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+phy\+Tx\+End\+Trace@{m\+\_\+phy\+Tx\+End\+Trace}}
\index{m\+\_\+phy\+Tx\+End\+Trace@{m\+\_\+phy\+Tx\+End\+Trace}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+phy\+Tx\+End\+Trace}{m_phyTxEndTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Csma\+Net\+Device\+::m\+\_\+phy\+Tx\+End\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_a8cac1ff27eec4db589ed00545f942a21}{}\label{classns3_1_1CsmaNetDevice_a8cac1ff27eec4db589ed00545f942a21}
The trace source fired when a packet ends the transmission process on the medium.

\begin{DoxySeeAlso}{See also}
class Call\+Back\+Trace\+Source 
\end{DoxySeeAlso}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+promisc\+Rx\+Callback@{m\+\_\+promisc\+Rx\+Callback}}
\index{m\+\_\+promisc\+Rx\+Callback@{m\+\_\+promisc\+Rx\+Callback}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+promisc\+Rx\+Callback}{m_promiscRxCallback}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Net\+Device\+::\+Promisc\+Receive\+Callback} ns3\+::\+Csma\+Net\+Device\+::m\+\_\+promisc\+Rx\+Callback\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_a4c9c0533341d76fe278fbef18525b228}{}\label{classns3_1_1CsmaNetDevice_a4c9c0533341d76fe278fbef18525b228}
The callback used to notify higher layers that a packet has been received in promiscuous mode. \index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+promisc\+Sniffer\+Trace@{m\+\_\+promisc\+Sniffer\+Trace}}
\index{m\+\_\+promisc\+Sniffer\+Trace@{m\+\_\+promisc\+Sniffer\+Trace}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+promisc\+Sniffer\+Trace}{m_promiscSnifferTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Csma\+Net\+Device\+::m\+\_\+promisc\+Sniffer\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_aae7fbd28077e7ac8efee738c4194ed16}{}\label{classns3_1_1CsmaNetDevice_aae7fbd28077e7ac8efee738c4194ed16}
A trace source that emulates a promiscuous mode protocol sniffer connected to the device. This trace source fire on packets destined for any host just like your average everyday packet sniffer.

On the transmit size, this trace hook will fire after a packet is dequeued from the device queue for transmission. In Linux, for example, this would correspond to the point just before a device hard\+\_\+start\+\_\+xmit where dev\+\_\+queue\+\_\+xmit\+\_\+nit is called to dispatch the packet to the P\+F\+\_\+\+P\+A\+C\+K\+ET E\+T\+H\+\_\+\+P\+\_\+\+A\+LL handlers.

On the receive side, this trace hook will fire when a packet is received, just before the receive callback is executed. In Linux, for example, this would correspond to the point at which the packet is dispatched to packet sniffers in netif\+\_\+receive\+\_\+skb.

\begin{DoxySeeAlso}{See also}
class Call\+Back\+Trace\+Source 
\end{DoxySeeAlso}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+queue@{m\+\_\+queue}}
\index{m\+\_\+queue@{m\+\_\+queue}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+queue}{m_queue}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Queue}$<${\bf Packet}$>$ $>$ ns3\+::\+Csma\+Net\+Device\+::m\+\_\+queue\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_a499be4029c01107f7f16f5371843ffde}{}\label{classns3_1_1CsmaNetDevice_a499be4029c01107f7f16f5371843ffde}
The \hyperlink{classns3_1_1Queue}{Queue} which this \hyperlink{classns3_1_1CsmaNetDevice}{Csma\+Net\+Device} uses as a packet source. Management of this \hyperlink{classns3_1_1Queue}{Queue} has been delegated to the \hyperlink{classns3_1_1CsmaNetDevice}{Csma\+Net\+Device} and it has the responsibility for deletion. \begin{DoxySeeAlso}{See also}
class \hyperlink{classns3_1_1Queue}{Queue} 

class \hyperlink{classns3_1_1DropTailQueue}{Drop\+Tail\+Queue} 
\end{DoxySeeAlso}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+queue\+Interface@{m\+\_\+queue\+Interface}}
\index{m\+\_\+queue\+Interface@{m\+\_\+queue\+Interface}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+queue\+Interface}{m_queueInterface}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Net\+Device\+Queue\+Interface}$>$ ns3\+::\+Csma\+Net\+Device\+::m\+\_\+queue\+Interface\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_a93a7be08d44dbabfdf111e90feb7c72a}{}\label{classns3_1_1CsmaNetDevice_a93a7be08d44dbabfdf111e90feb7c72a}
\hyperlink{classns3_1_1NetDevice}{Net\+Device} queue interface. \index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+receive\+Enable@{m\+\_\+receive\+Enable}}
\index{m\+\_\+receive\+Enable@{m\+\_\+receive\+Enable}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+receive\+Enable}{m_receiveEnable}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Csma\+Net\+Device\+::m\+\_\+receive\+Enable\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_a8d844dcce78846a16c9a52c752f9736f}{}\label{classns3_1_1CsmaNetDevice_a8d844dcce78846a16c9a52c752f9736f}
Enable net device to receive packets. True by default \index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+receive\+Error\+Model@{m\+\_\+receive\+Error\+Model}}
\index{m\+\_\+receive\+Error\+Model@{m\+\_\+receive\+Error\+Model}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+receive\+Error\+Model}{m_receiveErrorModel}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Error\+Model}$>$ ns3\+::\+Csma\+Net\+Device\+::m\+\_\+receive\+Error\+Model\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_aeef9196f9c7c46c99a7f703dc46c0207}{}\label{classns3_1_1CsmaNetDevice_aeef9196f9c7c46c99a7f703dc46c0207}
Error model for receive packet events. When active this model will be used to model transmission errors by marking some of the packets received as corrupt. \index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+rx\+Callback@{m\+\_\+rx\+Callback}}
\index{m\+\_\+rx\+Callback@{m\+\_\+rx\+Callback}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+rx\+Callback}{m_rxCallback}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Net\+Device\+::\+Receive\+Callback} ns3\+::\+Csma\+Net\+Device\+::m\+\_\+rx\+Callback\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_a18646390c167ad8f0f8b8795a9052031}{}\label{classns3_1_1CsmaNetDevice_a18646390c167ad8f0f8b8795a9052031}
The callback used to notify higher layers that a packet has been received. \index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+send\+Enable@{m\+\_\+send\+Enable}}
\index{m\+\_\+send\+Enable@{m\+\_\+send\+Enable}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+send\+Enable}{m_sendEnable}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Csma\+Net\+Device\+::m\+\_\+send\+Enable\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_ac5bde9af7f582a6d707a68061c114fdf}{}\label{classns3_1_1CsmaNetDevice_ac5bde9af7f582a6d707a68061c114fdf}
Enable net device to send packets. True by default \index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+sniffer\+Trace@{m\+\_\+sniffer\+Trace}}
\index{m\+\_\+sniffer\+Trace@{m\+\_\+sniffer\+Trace}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+sniffer\+Trace}{m_snifferTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Csma\+Net\+Device\+::m\+\_\+sniffer\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_a88e5994b762e01f74606742a7f15b797}{}\label{classns3_1_1CsmaNetDevice_a88e5994b762e01f74606742a7f15b797}
A trace source that emulates a non-\/promiscuous protocol sniffer connected to the device. Unlike your average everyday sniffer, this trace source will not fire on P\+A\+C\+K\+E\+T\+\_\+\+O\+T\+H\+E\+R\+H\+O\+ST events.

On the transmit size, this trace hook will fire after a packet is dequeued from the device queue for transmission. In Linux, for example, this would correspond to the point just before a device hard\+\_\+start\+\_\+xmit where dev\+\_\+queue\+\_\+xmit\+\_\+nit is called to dispatch the packet to the P\+F\+\_\+\+P\+A\+C\+K\+ET E\+T\+H\+\_\+\+P\+\_\+\+A\+LL handlers.

On the receive side, this trace hook will fire when a packet is received, just before the receive callback is executed. In Linux, for example, this would correspond to the point at which the packet is dispatched to packet sniffers in netif\+\_\+receive\+\_\+skb.

\begin{DoxySeeAlso}{See also}
class Call\+Back\+Trace\+Source 
\end{DoxySeeAlso}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+t\+Interframe\+Gap@{m\+\_\+t\+Interframe\+Gap}}
\index{m\+\_\+t\+Interframe\+Gap@{m\+\_\+t\+Interframe\+Gap}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+t\+Interframe\+Gap}{m_tInterframeGap}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Csma\+Net\+Device\+::m\+\_\+t\+Interframe\+Gap\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_ae581d7910d91ab9aaf760288ccf75c55}{}\label{classns3_1_1CsmaNetDevice_ae581d7910d91ab9aaf760288ccf75c55}
The interframe gap that the Net Device uses insert time between packet transmission \begin{DoxySeeAlso}{See also}
class \hyperlink{classns3_1_1Time}{Time} 
\end{DoxySeeAlso}
\index{ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}!m\+\_\+tx\+Machine\+State@{m\+\_\+tx\+Machine\+State}}
\index{m\+\_\+tx\+Machine\+State@{m\+\_\+tx\+Machine\+State}!ns3\+::\+Csma\+Net\+Device@{ns3\+::\+Csma\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+tx\+Machine\+State}{m_txMachineState}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tx\+Machine\+State} ns3\+::\+Csma\+Net\+Device\+::m\+\_\+tx\+Machine\+State\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1CsmaNetDevice_af07031cad3f8bd8c4b33ba77fa706e99}{}\label{classns3_1_1CsmaNetDevice_af07031cad3f8bd8c4b33ba77fa706e99}
The state of the Net Device transmit state machine. \begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1CsmaNetDevice_a46c532357164a954c46a01f05f8d78f4}{Tx\+Machine\+State} 
\end{DoxySeeAlso}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
csma/model/\hyperlink{csma-net-device_8h}{csma-\/net-\/device.\+h}\item 
csma/model/\hyperlink{csma-net-device_8cc}{csma-\/net-\/device.\+cc}\end{DoxyCompactItemize}
