\hypertarget{classns3_1_1ArpCache}{}\section{ns3\+:\+:Arp\+Cache Class Reference}
\label{classns3_1_1ArpCache}\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}


An A\+RP cache.  




{\ttfamily \#include $<$arp-\/cache.\+h$>$}



Inheritance diagram for ns3\+:\+:Arp\+Cache\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Arp\+Cache\+:
% FIG 1
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classns3_1_1ArpCache_1_1Entry}{Entry}
\begin{DoxyCompactList}\small\item\em A record that that holds information about an \hyperlink{classns3_1_1ArpCache}{Arp\+Cache} entry. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef std\+::pair$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$, \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} $>$ \hyperlink{classns3_1_1ArpCache_ad018741a53ccc6cdb8b05fdd4873ef3d}{Ipv4\+Payload\+Header\+Pair}
\begin{DoxyCompactList}\small\item\em Pair of a packet and an \hyperlink{classns3_1_1Ipv4}{Ipv4} header. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1ArpCache_ab8f759ac5cf08b48f1c7f1024c4b482f}{Arp\+Cache} ()
\item 
\hyperlink{classns3_1_1ArpCache_a2b97679e365f8b80cdf620f23d2a5695}{$\sim$\+Arp\+Cache} ()
\item 
void \hyperlink{classns3_1_1ArpCache_a8cd550f89be088d8941f65f5ab3f8241}{Set\+Device} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} $>$ interface)
\begin{DoxyCompactList}\small\item\em Set the \hyperlink{classns3_1_1NetDevice}{Net\+Device} and \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} associated with the \hyperlink{classns3_1_1ArpCache}{Arp\+Cache}. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ \hyperlink{classns3_1_1ArpCache_ad5772bef995ba37ef8b2607fe9a878e1}{Get\+Device} (void) const 
\begin{DoxyCompactList}\small\item\em Returns the \hyperlink{classns3_1_1NetDevice}{Net\+Device} that this A\+RP cache is associated with. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} $>$ \hyperlink{classns3_1_1ArpCache_a0876842c4ecdfcc3d8a591545163a3b8}{Get\+Interface} (void) const 
\begin{DoxyCompactList}\small\item\em Returns the \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} that this A\+RP cache is associated with. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1ArpCache_a69b80e4ba6fa363178e72eb090a903d4}{Set\+Alive\+Timeout} (\hyperlink{classns3_1_1Time}{Time} alive\+Timeout)
\begin{DoxyCompactList}\small\item\em Set the time the entry will be in A\+L\+I\+VE state (unless refreshed) \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1ArpCache_adf7d795ca712fb957b97934c1556168a}{Set\+Dead\+Timeout} (\hyperlink{classns3_1_1Time}{Time} dead\+Timeout)
\begin{DoxyCompactList}\small\item\em Set the time the entry will be in D\+E\+AD state before being removed. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1ArpCache_a1422cb8ec06a7dc516849ee9939ebc25}{Set\+Wait\+Reply\+Timeout} (\hyperlink{classns3_1_1Time}{Time} wait\+Reply\+Timeout)
\begin{DoxyCompactList}\small\item\em Set the time the entry will be in W\+A\+I\+T\+\_\+\+R\+E\+P\+LY state. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1ArpCache_a78dc3f3db9c7fd5f8042efcc1dfff5e8}{Get\+Alive\+Timeout} (void) const 
\begin{DoxyCompactList}\small\item\em Get the time the entry will be in A\+L\+I\+VE state (unless refreshed) \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1ArpCache_ad6b09c9735d13bb83f1a1f635b885cb9}{Get\+Dead\+Timeout} (void) const 
\begin{DoxyCompactList}\small\item\em Get the time the entry will be in D\+E\+AD state before being removed. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1ArpCache_a0e83bb9568d72f3fa2d187a72b0abbc4}{Get\+Wait\+Reply\+Timeout} (void) const 
\begin{DoxyCompactList}\small\item\em Get the time the entry will be in W\+A\+I\+T\+\_\+\+R\+E\+P\+LY state. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1ArpCache_a338c92360d182aa43ed6cb158ecfb959}{Set\+Arp\+Request\+Callback} (\hyperlink{classns3_1_1Callback}{Callback}$<$ void, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1ArpCache}{Arp\+Cache} $>$, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} $>$ arp\+Request\+Callback)
\item 
void \hyperlink{classns3_1_1ArpCache_ada18c1c06844b8e43201d3d7a3a61098}{Start\+Wait\+Reply\+Timer} (void)
\item 
\hyperlink{classns3_1_1ArpCache_1_1Entry}{Arp\+Cache\+::\+Entry} $\ast$ \hyperlink{classns3_1_1ArpCache_a9402dc061ed329656e75c0dd9d591c0b}{Lookup} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} destination)
\begin{DoxyCompactList}\small\item\em Do lookup in the A\+RP cache against an IP address. \end{DoxyCompactList}\item 
\hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1ArpCache_1_1Entry}{Arp\+Cache\+::\+Entry} $\ast$ $>$ \hyperlink{classns3_1_1ArpCache_a906f1f74032fec4ebe54792cb07f34cd}{Lookup\+Inverse} (\hyperlink{classns3_1_1Address}{Address} destination)
\begin{DoxyCompactList}\small\item\em Do lookup in the A\+RP cache against a M\+AC address. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1ArpCache_1_1Entry}{Arp\+Cache\+::\+Entry} $\ast$ \hyperlink{classns3_1_1ArpCache_a7fb6a10eb08b6fb3af0f7848a28a61b4}{Add} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} to)
\begin{DoxyCompactList}\small\item\em Add an \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} to this A\+RP cache. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1ArpCache_a132f62e7c8b6be8674017df5591d872f}{Remove} (\hyperlink{classns3_1_1ArpCache_1_1Entry}{Arp\+Cache\+::\+Entry} $\ast$entry)
\begin{DoxyCompactList}\small\item\em Remove an entry. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1ArpCache_a7feb098de790b3ed4383dd73a11d856c}{Flush} (void)
\begin{DoxyCompactList}\small\item\em Clear the \hyperlink{classns3_1_1ArpCache}{Arp\+Cache} of all entries. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1ArpCache_a521e3f77a195864909066b493f32a3c9}{Print\+Arp\+Cache} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream)
\begin{DoxyCompactList}\small\item\em Print the A\+RP cache entries. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1ArpCache_adc4d8785f0ea5a83b1248d580cfd9487}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
typedef sgi\+::hash\+\_\+map$<$ \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address}, \hyperlink{classns3_1_1ArpCache_1_1Entry}{Arp\+Cache\+::\+Entry} $\ast$, \hyperlink{classns3_1_1Ipv4AddressHash}{Ipv4\+Address\+Hash} $>$ \hyperlink{classns3_1_1ArpCache_a0d745162ea670b114dd1a313c69c4aab}{Cache}
\begin{DoxyCompactList}\small\item\em A\+RP Cache container. \end{DoxyCompactList}\item 
typedef sgi\+::hash\+\_\+map$<$ \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address}, \hyperlink{classns3_1_1ArpCache_1_1Entry}{Arp\+Cache\+::\+Entry} $\ast$, \hyperlink{classns3_1_1Ipv4AddressHash}{Ipv4\+Address\+Hash} $>$\+::iterator \hyperlink{classns3_1_1ArpCache_a22c6fbe2d2b3b00d995ed13ec6a0c9cb}{CacheI}
\begin{DoxyCompactList}\small\item\em A\+RP Cache container iterator. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1ArpCache_a480fe29c24f6e3cd7c0e8599425822e7}{Arp\+Cache} (\hyperlink{classns3_1_1ArpCache}{Arp\+Cache} const \&)
\begin{DoxyCompactList}\small\item\em Copy constructor. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1ArpCache}{Arp\+Cache} \& \hyperlink{classns3_1_1ArpCache_a5adcfb987247b1deeb5461b02d6ee460}{operator=} (\hyperlink{classns3_1_1ArpCache}{Arp\+Cache} const \&)
\begin{DoxyCompactList}\small\item\em Copy constructor. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1ArpCache_a82e8920743f9de62133e2b43071a171b}{Do\+Dispose} (void)
\item 
void \hyperlink{classns3_1_1ArpCache_a8922ac0806811b42957bfc68a3ccf1c6}{Handle\+Wait\+Reply\+Timeout} (void)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ \hyperlink{classns3_1_1ArpCache_abeff23a1b2276b8cca9b3a023bce2850}{m\+\_\+device}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1NetDevice}{Net\+Device} associated with the cache. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} $>$ \hyperlink{classns3_1_1ArpCache_a51ac32b4e89fdfb85f0a30a5104f5857}{m\+\_\+interface}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} associated with the cache. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1ArpCache_a30dc0bd7f1b0fb5847a9df0db1d52add}{m\+\_\+alive\+Timeout}
\begin{DoxyCompactList}\small\item\em cache alive state timeout \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1ArpCache_a399aae557ff88496c35d5f6beb842923}{m\+\_\+dead\+Timeout}
\begin{DoxyCompactList}\small\item\em cache dead state timeout \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1ArpCache_a4369a983ccf79656dbe6066b5fe91814}{m\+\_\+wait\+Reply\+Timeout}
\begin{DoxyCompactList}\small\item\em cache reply state timeout \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1EventId}{Event\+Id} \hyperlink{classns3_1_1ArpCache_a2725853dd931117b4d49b95b036f6d2b}{m\+\_\+wait\+Reply\+Timer}
\begin{DoxyCompactList}\small\item\em cache alive state timer \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Callback}{Callback}$<$ void, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1ArpCache}{Arp\+Cache} $>$, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} $>$ \hyperlink{classns3_1_1ArpCache_a91797ea0de773ea3b9ba84e8cd42a3e0}{m\+\_\+arp\+Request\+Callback}
\begin{DoxyCompactList}\small\item\em reply timeout callback \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1ArpCache_a24f0460babb1745ff532b16710846ab9}{m\+\_\+max\+Retries}
\begin{DoxyCompactList}\small\item\em max retries for a resolution \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1ArpCache_a70391342295055352cc9cfcf34d3cc52}{m\+\_\+pending\+Queue\+Size}
\begin{DoxyCompactList}\small\item\em number of packets waiting for a resolution \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1ArpCache_a0d745162ea670b114dd1a313c69c4aab}{Cache} \hyperlink{classns3_1_1ArpCache_a952de05903ff6b400c332c1bad8e0fc6}{m\+\_\+arp\+Cache}
\begin{DoxyCompactList}\small\item\em the A\+RP cache \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1ArpCache_a7f919ba19c2dbbae6f4d9251ded35fa3}{m\+\_\+drop\+Trace}
\begin{DoxyCompactList}\small\item\em trace for packets dropped by the A\+RP cache queue \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
An A\+RP cache. 

A cached lookup table for translating layer 3 addresses to layer 2. This implementation does lookups from I\+Pv4 to a M\+AC address 

\subsection{Member Typedef Documentation}
\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!Cache@{Cache}}
\index{Cache@{Cache}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{Cache}{Cache}}]{\setlength{\rightskip}{0pt plus 5cm}typedef sgi\+::hash\+\_\+map$<${\bf Ipv4\+Address}, {\bf Arp\+Cache\+::\+Entry} $\ast$, {\bf Ipv4\+Address\+Hash}$>$ {\bf ns3\+::\+Arp\+Cache\+::\+Cache}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1ArpCache_a0d745162ea670b114dd1a313c69c4aab}{}\label{classns3_1_1ArpCache_a0d745162ea670b114dd1a313c69c4aab}


A\+RP Cache container. 

\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!CacheI@{CacheI}}
\index{CacheI@{CacheI}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{CacheI}{CacheI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef sgi\+::hash\+\_\+map$<${\bf Ipv4\+Address}, {\bf Arp\+Cache\+::\+Entry} $\ast$, {\bf Ipv4\+Address\+Hash}$>$\+::iterator {\bf ns3\+::\+Arp\+Cache\+::\+CacheI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1ArpCache_a22c6fbe2d2b3b00d995ed13ec6a0c9cb}{}\label{classns3_1_1ArpCache_a22c6fbe2d2b3b00d995ed13ec6a0c9cb}


A\+RP Cache container iterator. 

\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!Ipv4\+Payload\+Header\+Pair@{Ipv4\+Payload\+Header\+Pair}}
\index{Ipv4\+Payload\+Header\+Pair@{Ipv4\+Payload\+Header\+Pair}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{Ipv4\+Payload\+Header\+Pair}{Ipv4PayloadHeaderPair}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::pair$<${\bf Ptr}$<${\bf Packet}$>$, {\bf Ipv4\+Header}$>$ {\bf ns3\+::\+Arp\+Cache\+::\+Ipv4\+Payload\+Header\+Pair}}\hypertarget{classns3_1_1ArpCache_ad018741a53ccc6cdb8b05fdd4873ef3d}{}\label{classns3_1_1ArpCache_ad018741a53ccc6cdb8b05fdd4873ef3d}


Pair of a packet and an \hyperlink{classns3_1_1Ipv4}{Ipv4} header. 



\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!Arp\+Cache@{Arp\+Cache}}
\index{Arp\+Cache@{Arp\+Cache}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{Arp\+Cache(\+Arp\+Cache const \&)}{ArpCache(ArpCache const &)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Arp\+Cache\+::\+Arp\+Cache (
\begin{DoxyParamCaption}
\item[{{\bf Arp\+Cache} const \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1ArpCache_a480fe29c24f6e3cd7c0e8599425822e7}{}\label{classns3_1_1ArpCache_a480fe29c24f6e3cd7c0e8599425822e7}


Copy constructor. 

Defined and unimplemented to avoid misuse \index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!Arp\+Cache@{Arp\+Cache}}
\index{Arp\+Cache@{Arp\+Cache}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{Arp\+Cache()}{ArpCache()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Arp\+Cache\+::\+Arp\+Cache (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1ArpCache_ab8f759ac5cf08b48f1c7f1024c4b482f}{}\label{classns3_1_1ArpCache_ab8f759ac5cf08b48f1c7f1024c4b482f}

\begin{DoxyCode}
88   : \hyperlink{classns3_1_1ArpCache_abeff23a1b2276b8cca9b3a023bce2850}{m\_device} (0), 
89     \hyperlink{classns3_1_1ArpCache_a51ac32b4e89fdfb85f0a30a5104f5857}{m\_interface} (0)
90 \{
91   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
92 \}
\end{DoxyCode}
\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!````~Arp\+Cache@{$\sim$\+Arp\+Cache}}
\index{````~Arp\+Cache@{$\sim$\+Arp\+Cache}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{$\sim$\+Arp\+Cache()}{~ArpCache()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Arp\+Cache\+::$\sim$\+Arp\+Cache (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1ArpCache_a2b97679e365f8b80cdf620f23d2a5695}{}\label{classns3_1_1ArpCache_a2b97679e365f8b80cdf620f23d2a5695}

\begin{DoxyCode}
95 \{
96   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
97 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!Add@{Add}}
\index{Add@{Add}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{Add(\+Ipv4\+Address to)}{Add(Ipv4Address to)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Arp\+Cache\+::\+Entry} $\ast$ ns3\+::\+Arp\+Cache\+::\+Add (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{to}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1ArpCache_a7fb6a10eb08b6fb3af0f7848a28a61b4}{}\label{classns3_1_1ArpCache_a7fb6a10eb08b6fb3af0f7848a28a61b4}


Add an \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} to this A\+RP cache. 


\begin{DoxyParams}{Parameters}
{\em to} & the destination address of the A\+RP entry. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pointer to a new A\+RP \hyperlink{classns3_1_1ArpCache_1_1Entry}{Entry}. 
\end{DoxyReturn}

\begin{DoxyCode}
331 \{
332   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << to);
333   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1ArpCache_a952de05903ff6b400c332c1bad8e0fc6}{m\_arpCache}.find (to) == \hyperlink{classns3_1_1ArpCache_a952de05903ff6b400c332c1bad8e0fc6}{m\_arpCache}.end ());
334 
335   ArpCache::Entry *entry = \textcolor{keyword}{new} ArpCache::Entry (\textcolor{keyword}{this});
336   \hyperlink{classns3_1_1ArpCache_a952de05903ff6b400c332c1bad8e0fc6}{m\_arpCache}[to] = entry;
337   entry->SetIpv4Address (to);
338   \textcolor{keywordflow}{return} entry;
339 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 2


\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{Do\+Dispose(void)}{DoDispose(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Arp\+Cache\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1ArpCache_a82e8920743f9de62133e2b43071a171b}{}\label{classns3_1_1ArpCache_a82e8920743f9de62133e2b43071a171b}
Destructor implementation.

This method is called by \hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose()} or by the \hyperlink{classns3_1_1Object}{Object}\textquotesingle{}s destructor, whichever comes first.

Subclasses are expected to implement their real destruction code in an overriden version of this method and chain up to their parent\textquotesingle{}s implementation once they are done. {\itshape i.\+e}, for simplicity, the destructor of every subclass should be empty and its content should be moved to the associated \hyperlink{classns3_1_1ArpCache_a82e8920743f9de62133e2b43071a171b}{Do\+Dispose()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.


\begin{DoxyCode}
101 \{
102   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
103   \hyperlink{classns3_1_1ArpCache_a7feb098de790b3ed4383dd73a11d856c}{Flush} ();
104   \hyperlink{classns3_1_1ArpCache_abeff23a1b2276b8cca9b3a023bce2850}{m\_device} = 0;
105   \hyperlink{classns3_1_1ArpCache_a51ac32b4e89fdfb85f0a30a5104f5857}{m\_interface} = 0;
106   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1ArpCache_a2725853dd931117b4d49b95b036f6d2b}{m\_waitReplyTimer}.\hyperlink{classns3_1_1EventId_aabf8476d1a080c199ea0c6aa9ccea372}{IsRunning} ())
107     \{
108       \hyperlink{classns3_1_1Simulator_ae30cacdda6cd0d5d62a8f2097b320506}{Simulator::Remove} (\hyperlink{classns3_1_1ArpCache_a2725853dd931117b4d49b95b036f6d2b}{m\_waitReplyTimer});
109     \}
110   \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{Object::DoDispose} ();
111 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!Flush@{Flush}}
\index{Flush@{Flush}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{Flush(void)}{Flush(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Arp\+Cache\+::\+Flush (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1ArpCache_a7feb098de790b3ed4383dd73a11d856c}{}\label{classns3_1_1ArpCache_a7feb098de790b3ed4383dd73a11d856c}


Clear the \hyperlink{classns3_1_1ArpCache}{Arp\+Cache} of all entries. 


\begin{DoxyCode}
245 \{
246   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
247   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1ArpCache_a22c6fbe2d2b3b00d995ed13ec6a0c9cb}{CacheI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1ArpCache_a952de05903ff6b400c332c1bad8e0fc6}{m\_arpCache}.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1ArpCache_a952de05903ff6b400c332c1bad8e0fc6}{m\_arpCache}.end (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++) 
248     \{
249       \textcolor{keyword}{delete} (*i).second;
250     \}
251   \hyperlink{classns3_1_1ArpCache_a952de05903ff6b400c332c1bad8e0fc6}{m\_arpCache}.erase (\hyperlink{classns3_1_1ArpCache_a952de05903ff6b400c332c1bad8e0fc6}{m\_arpCache}.begin (), \hyperlink{classns3_1_1ArpCache_a952de05903ff6b400c332c1bad8e0fc6}{m\_arpCache}.end ());
252   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1ArpCache_a2725853dd931117b4d49b95b036f6d2b}{m\_waitReplyTimer}.\hyperlink{classns3_1_1EventId_aabf8476d1a080c199ea0c6aa9ccea372}{IsRunning} ())
253     \{
254       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Stopping WaitReplyTimer at "} << \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds
       () << \textcolor{stringliteral}{" due to ArpCache flush"});
255       \hyperlink{classns3_1_1ArpCache_a2725853dd931117b4d49b95b036f6d2b}{m\_waitReplyTimer}.\hyperlink{classns3_1_1EventId_a993ae94e48e014e1afd47edb16db7a11}{Cancel} ();
256     \}
257 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4




Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!Get\+Alive\+Timeout@{Get\+Alive\+Timeout}}
\index{Get\+Alive\+Timeout@{Get\+Alive\+Timeout}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{Get\+Alive\+Timeout(void) const }{GetAliveTimeout(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Arp\+Cache\+::\+Get\+Alive\+Timeout (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1ArpCache_a78dc3f3db9c7fd5f8042efcc1dfff5e8}{}\label{classns3_1_1ArpCache_a78dc3f3db9c7fd5f8042efcc1dfff5e8}


Get the time the entry will be in A\+L\+I\+VE state (unless refreshed) 

\begin{DoxyReturn}{Returns}
the Alive state timeout 
\end{DoxyReturn}

\begin{DoxyCode}
156 \{
157   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
158   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1ArpCache_a30dc0bd7f1b0fb5847a9df0db1d52add}{m\_aliveTimeout};
159 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!Get\+Dead\+Timeout@{Get\+Dead\+Timeout}}
\index{Get\+Dead\+Timeout@{Get\+Dead\+Timeout}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{Get\+Dead\+Timeout(void) const }{GetDeadTimeout(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Arp\+Cache\+::\+Get\+Dead\+Timeout (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1ArpCache_ad6b09c9735d13bb83f1a1f635b885cb9}{}\label{classns3_1_1ArpCache_ad6b09c9735d13bb83f1a1f635b885cb9}


Get the time the entry will be in D\+E\+AD state before being removed. 

\begin{DoxyReturn}{Returns}
the Dead state timeout 
\end{DoxyReturn}

\begin{DoxyCode}
162 \{
163   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
164   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1ArpCache_a399aae557ff88496c35d5f6beb842923}{m\_deadTimeout};
165 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!Get\+Device@{Get\+Device}}
\index{Get\+Device@{Get\+Device}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{Get\+Device(void) const }{GetDevice(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Net\+Device} $>$ ns3\+::\+Arp\+Cache\+::\+Get\+Device (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1ArpCache_ad5772bef995ba37ef8b2607fe9a878e1}{}\label{classns3_1_1ArpCache_ad5772bef995ba37ef8b2607fe9a878e1}


Returns the \hyperlink{classns3_1_1NetDevice}{Net\+Device} that this A\+RP cache is associated with. 

\begin{DoxyReturn}{Returns}
The \hyperlink{classns3_1_1NetDevice}{Net\+Device} that this A\+RP cache is associated with 
\end{DoxyReturn}

\begin{DoxyCode}
123 \{
124   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
125   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1ArpCache_abeff23a1b2276b8cca9b3a023bce2850}{m\_device};
126 \}
\end{DoxyCode}
\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!Get\+Interface@{Get\+Interface}}
\index{Get\+Interface@{Get\+Interface}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{Get\+Interface(void) const }{GetInterface(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv4\+Interface} $>$ ns3\+::\+Arp\+Cache\+::\+Get\+Interface (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1ArpCache_a0876842c4ecdfcc3d8a591545163a3b8}{}\label{classns3_1_1ArpCache_a0876842c4ecdfcc3d8a591545163a3b8}


Returns the \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} that this A\+RP cache is associated with. 

\begin{DoxyReturn}{Returns}
the \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} that this A\+RP cache is associated with 
\end{DoxyReturn}

\begin{DoxyCode}
130 \{
131   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
132   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1ArpCache_a51ac32b4e89fdfb85f0a30a5104f5857}{m\_interface};
133 \}
\end{DoxyCode}
\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Arp\+Cache\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1ArpCache_adc4d8785f0ea5a83b1248d580cfd9487}{}\label{classns3_1_1ArpCache_adc4d8785f0ea5a83b1248d580cfd9487}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
42 \{
43   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::ArpCache"})
44     .SetParent<\hyperlink{classns3_1_1Object_a40860402e64d8008fb42329df7097cdb}{Object}> ()
45     .SetGroupName (\textcolor{stringliteral}{"Internet"})
46     .AddAttribute (\textcolor{stringliteral}{"AliveTimeout"},
47                    \textcolor{stringliteral}{"When this timeout expires, "}
48                    \textcolor{stringliteral}{"the matching cache entry needs refreshing"},
49                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (120)),
50                    MakeTimeAccessor (&\hyperlink{classns3_1_1ArpCache_a30dc0bd7f1b0fb5847a9df0db1d52add}{ArpCache::m\_aliveTimeout}),
51                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
52     .AddAttribute (\textcolor{stringliteral}{"DeadTimeout"},
53                    \textcolor{stringliteral}{"When this timeout expires, "}
54                    \textcolor{stringliteral}{"a new attempt to resolve the matching entry is made"},
55                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (100)),
56                    MakeTimeAccessor (&\hyperlink{classns3_1_1ArpCache_a399aae557ff88496c35d5f6beb842923}{ArpCache::m\_deadTimeout}),
57                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
58     .AddAttribute (\textcolor{stringliteral}{"WaitReplyTimeout"},
59                    \textcolor{stringliteral}{"When this timeout expires, "}
60                    \textcolor{stringliteral}{"the cache entries will be scanned and "}
61                    \textcolor{stringliteral}{"entries in WaitReply state will resend ArpRequest "}
62                    \textcolor{stringliteral}{"unless MaxRetries has been exceeded, "}
63                    \textcolor{stringliteral}{"in which case the entry is marked dead"},
64                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (1)),
65                    MakeTimeAccessor (&\hyperlink{classns3_1_1ArpCache_a4369a983ccf79656dbe6066b5fe91814}{ArpCache::m\_waitReplyTimeout}),
66                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
67     .AddAttribute (\textcolor{stringliteral}{"MaxRetries"},
68                    \textcolor{stringliteral}{"Number of retransmissions of ArpRequest "}
69                    \textcolor{stringliteral}{"before marking dead"},
70                    UintegerValue (3),
71                    MakeUintegerAccessor (&\hyperlink{classns3_1_1ArpCache_a24f0460babb1745ff532b16710846ab9}{ArpCache::m\_maxRetries}),
72                    MakeUintegerChecker<uint32\_t> ())
73     .AddAttribute (\textcolor{stringliteral}{"PendingQueueSize"},
74                    \textcolor{stringliteral}{"The size of the queue for packets pending an arp reply."},
75                    UintegerValue (3),
76                    MakeUintegerAccessor (&\hyperlink{classns3_1_1ArpCache_a70391342295055352cc9cfcf34d3cc52}{ArpCache::m\_pendingQueueSize}),
77                    MakeUintegerChecker<uint32\_t> ())
78     .AddTraceSource (\textcolor{stringliteral}{"Drop"},
79                      \textcolor{stringliteral}{"Packet dropped due to ArpCache entry "}
80                      \textcolor{stringliteral}{"in WaitReply expiring."},
81                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1ArpCache_a7f919ba19c2dbbae6f4d9251ded35fa3}{ArpCache::m\_dropTrace}),
82                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
83   ;
84   \textcolor{keywordflow}{return} tid;
85 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8


\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!Get\+Wait\+Reply\+Timeout@{Get\+Wait\+Reply\+Timeout}}
\index{Get\+Wait\+Reply\+Timeout@{Get\+Wait\+Reply\+Timeout}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{Get\+Wait\+Reply\+Timeout(void) const }{GetWaitReplyTimeout(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Arp\+Cache\+::\+Get\+Wait\+Reply\+Timeout (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1ArpCache_a0e83bb9568d72f3fa2d187a72b0abbc4}{}\label{classns3_1_1ArpCache_a0e83bb9568d72f3fa2d187a72b0abbc4}


Get the time the entry will be in W\+A\+I\+T\+\_\+\+R\+E\+P\+LY state. 

\begin{DoxyReturn}{Returns}
the W\+A\+I\+T\+\_\+\+R\+E\+P\+LY state timeout 
\end{DoxyReturn}

\begin{DoxyCode}
168 \{
169   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
170   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1ArpCache_a4369a983ccf79656dbe6066b5fe91814}{m\_waitReplyTimeout};
171 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 9


\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!Handle\+Wait\+Reply\+Timeout@{Handle\+Wait\+Reply\+Timeout}}
\index{Handle\+Wait\+Reply\+Timeout@{Handle\+Wait\+Reply\+Timeout}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{Handle\+Wait\+Reply\+Timeout(void)}{HandleWaitReplyTimeout(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Arp\+Cache\+::\+Handle\+Wait\+Reply\+Timeout (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1ArpCache_a8922ac0806811b42957bfc68a3ccf1c6}{}\label{classns3_1_1ArpCache_a8922ac0806811b42957bfc68a3ccf1c6}
This function is an event handler for the event that the \hyperlink{classns3_1_1ArpCache}{Arp\+Cache} wants to check whether it must retry any Arp requests. If there are no Arp requests pending, this event is not scheduled. 
\begin{DoxyCode}
196 \{
197   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
198   ArpCache::Entry* entry;
199   \textcolor{keywordtype}{bool} restartWaitReplyTimer = \textcolor{keyword}{false};
200   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1ArpCache_a22c6fbe2d2b3b00d995ed13ec6a0c9cb}{CacheI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1ArpCache_a952de05903ff6b400c332c1bad8e0fc6}{m\_arpCache}.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1ArpCache_a952de05903ff6b400c332c1bad8e0fc6}{m\_arpCache}.end (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++) 
201     \{
202       entry = (*i).second;
203       \textcolor{keywordflow}{if} (entry != 0 && entry->IsWaitReply ())
204         \{
205           \textcolor{keywordflow}{if} (entry->GetRetries () < \hyperlink{classns3_1_1ArpCache_a24f0460babb1745ff532b16710846ab9}{m\_maxRetries})
206             \{
207               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"node="}<< \hyperlink{classns3_1_1ArpCache_abeff23a1b2276b8cca9b3a023bce2850}{m\_device}->GetNode ()->GetId () <<
208                             \textcolor{stringliteral}{", ArpWaitTimeout for "} << entry->GetIpv4Address () <<
209                             \textcolor{stringliteral}{" expired -- retransmitting arp request since retries = "} <<
210                             entry->GetRetries ());
211               \hyperlink{classns3_1_1ArpCache_a91797ea0de773ea3b9ba84e8cd42a3e0}{m\_arpRequestCallback} (\textcolor{keyword}{this}, entry->GetIpv4Address ());
212               restartWaitReplyTimer = \textcolor{keyword}{true};
213               entry->IncrementRetries ();
214             \}
215           \textcolor{keywordflow}{else}
216             \{
217               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"node="}<<\hyperlink{classns3_1_1ArpCache_abeff23a1b2276b8cca9b3a023bce2850}{m\_device}->GetNode ()->GetId () <<
218                             \textcolor{stringliteral}{", wait reply for "} << entry->GetIpv4Address () <<
219                             \textcolor{stringliteral}{" expired -- drop since max retries exceeded: "} <<
220                             entry->GetRetries ());
221               entry->MarkDead ();
222               entry->ClearRetries ();
223               \hyperlink{classns3_1_1ArpCache_ad018741a53ccc6cdb8b05fdd4873ef3d}{Ipv4PayloadHeaderPair} pending = entry->DequeuePending ();
224               \textcolor{keywordflow}{while} (pending.first != 0)
225                 \{
226                   \textcolor{comment}{// add the Ipv4 header for tracing purposes}
227                   pending.first->AddHeader (pending.second);
228                   \hyperlink{classns3_1_1ArpCache_a7f919ba19c2dbbae6f4d9251ded35fa3}{m\_dropTrace} (pending.first);
229                   pending = entry->DequeuePending ();
230                 \}
231             \}
232         \}
233 
234     \}
235   \textcolor{keywordflow}{if} (restartWaitReplyTimer)
236     \{
237       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Restarting WaitReplyTimer at "} << 
      \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().GetSeconds ());
238       \hyperlink{classns3_1_1ArpCache_a2725853dd931117b4d49b95b036f6d2b}{m\_waitReplyTimer} = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (
      \hyperlink{classns3_1_1ArpCache_a4369a983ccf79656dbe6066b5fe91814}{m\_waitReplyTimeout}, 
239                                               &\hyperlink{classns3_1_1ArpCache_a8922ac0806811b42957bfc68a3ccf1c6}{ArpCache::HandleWaitReplyTimeout}
      , \textcolor{keyword}{this});
240     \}
241 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10




Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!Lookup@{Lookup}}
\index{Lookup@{Lookup}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{Lookup(\+Ipv4\+Address destination)}{Lookup(Ipv4Address destination)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Arp\+Cache\+::\+Entry} $\ast$ ns3\+::\+Arp\+Cache\+::\+Lookup (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{destination}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1ArpCache_a9402dc061ed329656e75c0dd9d591c0b}{}\label{classns3_1_1ArpCache_a9402dc061ed329656e75c0dd9d591c0b}


Do lookup in the A\+RP cache against an IP address. 


\begin{DoxyParams}{Parameters}
{\em destination} & The destination I\+Pv4 address to lookup the M\+AC address of \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An \hyperlink{classns3_1_1ArpCache_1_1Entry}{Arp\+Cache\+::\+Entry} with info about layer 2 
\end{DoxyReturn}

\begin{DoxyCode}
319 \{
320   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << to);
321   \hyperlink{classns3_1_1ArpCache_a22c6fbe2d2b3b00d995ed13ec6a0c9cb}{CacheI} it = \hyperlink{classns3_1_1ArpCache_a952de05903ff6b400c332c1bad8e0fc6}{m\_arpCache}.find (to);
322   \textcolor{keywordflow}{if} (it != \hyperlink{classns3_1_1ArpCache_a952de05903ff6b400c332c1bad8e0fc6}{m\_arpCache}.end ())
323     \{
324       \textcolor{keywordflow}{return} it->second;
325     \}
326   \textcolor{keywordflow}{return} 0;
327 \}
\end{DoxyCode}
\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!Lookup\+Inverse@{Lookup\+Inverse}}
\index{Lookup\+Inverse@{Lookup\+Inverse}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{Lookup\+Inverse(\+Address destination)}{LookupInverse(Address destination)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std\+::list}$<$ {\bf Arp\+Cache\+::\+Entry} $\ast$ $>$ ns3\+::\+Arp\+Cache\+::\+Lookup\+Inverse (
\begin{DoxyParamCaption}
\item[{{\bf Address}}]{destination}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1ArpCache_a906f1f74032fec4ebe54792cb07f34cd}{}\label{classns3_1_1ArpCache_a906f1f74032fec4ebe54792cb07f34cd}


Do lookup in the A\+RP cache against a M\+AC address. 


\begin{DoxyParams}{Parameters}
{\em destination} & The destination M\+AC address to lookup of \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A std\+::list of \hyperlink{classns3_1_1ArpCache_1_1Entry}{Arp\+Cache\+::\+Entry} with info about layer 2 
\end{DoxyReturn}

\begin{DoxyCode}
301 \{
302   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << to);
303 
304   std::list<ArpCache::Entry *> entryList;
305   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1ArpCache_a22c6fbe2d2b3b00d995ed13ec6a0c9cb}{CacheI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1ArpCache_a952de05903ff6b400c332c1bad8e0fc6}{m\_arpCache}.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1ArpCache_a952de05903ff6b400c332c1bad8e0fc6}{m\_arpCache}.end (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
306     \{
307       ArpCache::Entry *entry = (*i).second;
308       \textcolor{keywordflow}{if} (entry->GetMacAddress () == to)
309         \{
310           entryList.push\_back (entry);
311         \}
312     \}
313   \textcolor{keywordflow}{return} entryList;
314 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12


\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!operator=@{operator=}}
\index{operator=@{operator=}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{operator=(\+Arp\+Cache const \&)}{operator=(ArpCache const &)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Arp\+Cache}\& ns3\+::\+Arp\+Cache\+::operator= (
\begin{DoxyParamCaption}
\item[{{\bf Arp\+Cache} const \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1ArpCache_a5adcfb987247b1deeb5461b02d6ee460}{}\label{classns3_1_1ArpCache_a5adcfb987247b1deeb5461b02d6ee460}


Copy constructor. 

Defined and unimplemented to avoid misuse \begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!Print\+Arp\+Cache@{Print\+Arp\+Cache}}
\index{Print\+Arp\+Cache@{Print\+Arp\+Cache}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{Print\+Arp\+Cache(\+Ptr$<$ Output\+Stream\+Wrapper $>$ stream)}{PrintArpCache(Ptr< OutputStreamWrapper > stream)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Arp\+Cache\+::\+Print\+Arp\+Cache (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1ArpCache_a521e3f77a195864909066b493f32a3c9}{}\label{classns3_1_1ArpCache_a521e3f77a195864909066b493f32a3c9}


Print the A\+RP cache entries. 


\begin{DoxyParams}{Parameters}
{\em stream} & the ostream the A\+RP cache entries is printed to \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
261 \{
262   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << stream);
263   std::ostream* os = stream->\hyperlink{classns3_1_1OutputStreamWrapper_a0cf30a4188ab6fdae2b2ab74db11acc2}{GetStream} ();
264 
265   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1ArpCache_a22c6fbe2d2b3b00d995ed13ec6a0c9cb}{CacheI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1ArpCache_a952de05903ff6b400c332c1bad8e0fc6}{m\_arpCache}.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1ArpCache_a952de05903ff6b400c332c1bad8e0fc6}{m\_arpCache}.end (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
266     \{
267       *os << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->first << \textcolor{stringliteral}{" dev "};
268       std::string found = \hyperlink{classns3_1_1Names_ab9664faf23569aaae64a2d1f65265045}{Names::FindName} (\hyperlink{classns3_1_1ArpCache_abeff23a1b2276b8cca9b3a023bce2850}{m\_device});
269       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Names_ab9664faf23569aaae64a2d1f65265045}{Names::FindName} (\hyperlink{classns3_1_1ArpCache_abeff23a1b2276b8cca9b3a023bce2850}{m\_device}) != \textcolor{stringliteral}{""})
270         \{
271           *os << found;
272         \}
273       \textcolor{keywordflow}{else}
274         \{
275           *os << static\_cast<int> (\hyperlink{classns3_1_1ArpCache_abeff23a1b2276b8cca9b3a023bce2850}{m\_device}->GetIfIndex ());
276         \}
277 
278       *os << \textcolor{stringliteral}{" lladdr "} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second->GetMacAddress ();
279 
280       \textcolor{keywordflow}{if} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second->IsAlive ())
281         \{
282           *os << \textcolor{stringliteral}{" REACHABLE\(\backslash\)n"};
283         \}
284       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second->IsWaitReply ())
285         \{
286           *os << \textcolor{stringliteral}{" DELAY\(\backslash\)n"};
287         \}
288       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second->IsPermanent ())
289         \{
290           *os << \textcolor{stringliteral}{" PERMANENT\(\backslash\)n"};
291         \}
292       \textcolor{keywordflow}{else}
293         \{
294           *os << \textcolor{stringliteral}{" STALE\(\backslash\)n"};
295         \}
296     \}
297 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13


\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!Remove@{Remove}}
\index{Remove@{Remove}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{Remove(\+Arp\+Cache\+::\+Entry $\ast$entry)}{Remove(ArpCache::Entry *entry)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Arp\+Cache\+::\+Remove (
\begin{DoxyParamCaption}
\item[{{\bf Arp\+Cache\+::\+Entry} $\ast$}]{entry}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1ArpCache_a132f62e7c8b6be8674017df5591d872f}{}\label{classns3_1_1ArpCache_a132f62e7c8b6be8674017df5591d872f}


Remove an entry. 


\begin{DoxyParams}{Parameters}
{\em entry} & pointer to delete it from the list \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
343 \{
344   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << entry);
345   
346   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1ArpCache_a22c6fbe2d2b3b00d995ed13ec6a0c9cb}{CacheI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1ArpCache_a952de05903ff6b400c332c1bad8e0fc6}{m\_arpCache}.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1ArpCache_a952de05903ff6b400c332c1bad8e0fc6}{m\_arpCache}.end (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
347     \{
348       \textcolor{keywordflow}{if} ((*i).second == entry)
349         \{
350           \hyperlink{classns3_1_1ArpCache_a952de05903ff6b400c332c1bad8e0fc6}{m\_arpCache}.erase (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
351           entry->ClearPendingPacket (); \textcolor{comment}{//clear the pending packets for entry's ipaddress}
352           \textcolor{keyword}{delete} entry;
353           \textcolor{keywordflow}{return};
354         \}
355     \}
356   \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Entry not found in this ARP Cache"});
357 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 14


\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!Set\+Alive\+Timeout@{Set\+Alive\+Timeout}}
\index{Set\+Alive\+Timeout@{Set\+Alive\+Timeout}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{Set\+Alive\+Timeout(\+Time alive\+Timeout)}{SetAliveTimeout(Time aliveTimeout)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Arp\+Cache\+::\+Set\+Alive\+Timeout (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{alive\+Timeout}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1ArpCache_a69b80e4ba6fa363178e72eb090a903d4}{}\label{classns3_1_1ArpCache_a69b80e4ba6fa363178e72eb090a903d4}


Set the time the entry will be in A\+L\+I\+VE state (unless refreshed) 


\begin{DoxyParams}{Parameters}
{\em alive\+Timeout} & the Alive state timeout \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
137 \{
138   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << aliveTimeout);
139   \hyperlink{classns3_1_1ArpCache_a30dc0bd7f1b0fb5847a9df0db1d52add}{m\_aliveTimeout} = aliveTimeout;
140 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 15


\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!Set\+Arp\+Request\+Callback@{Set\+Arp\+Request\+Callback}}
\index{Set\+Arp\+Request\+Callback@{Set\+Arp\+Request\+Callback}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{Set\+Arp\+Request\+Callback(\+Callback$<$ void, Ptr$<$ const Arp\+Cache $>$, Ipv4\+Address $>$ arp\+Request\+Callback)}{SetArpRequestCallback(Callback< void, Ptr< const ArpCache >, Ipv4Address > arpRequestCallback)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Arp\+Cache\+::\+Set\+Arp\+Request\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Callback}$<$ void, {\bf Ptr}$<$ const {\bf Arp\+Cache} $>$, {\bf Ipv4\+Address} $>$}]{arp\+Request\+Callback}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1ArpCache_a338c92360d182aa43ed6cb158ecfb959}{}\label{classns3_1_1ArpCache_a338c92360d182aa43ed6cb158ecfb959}
This callback is set when the \hyperlink{classns3_1_1ArpCache}{Arp\+Cache} is set up and allows the cache to generate an Arp request when the Wait\+Reply time expires and a retransmission must be sent


\begin{DoxyParams}{Parameters}
{\em arp\+Request\+Callback} & \hyperlink{classns3_1_1Callback}{Callback} for transmitting an Arp request. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
176 \{
177   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << &arpRequestCallback);
178   \hyperlink{classns3_1_1ArpCache_a91797ea0de773ea3b9ba84e8cd42a3e0}{m\_arpRequestCallback} = arpRequestCallback;
179 \}
\end{DoxyCode}
\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!Set\+Dead\+Timeout@{Set\+Dead\+Timeout}}
\index{Set\+Dead\+Timeout@{Set\+Dead\+Timeout}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{Set\+Dead\+Timeout(\+Time dead\+Timeout)}{SetDeadTimeout(Time deadTimeout)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Arp\+Cache\+::\+Set\+Dead\+Timeout (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{dead\+Timeout}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1ArpCache_adf7d795ca712fb957b97934c1556168a}{}\label{classns3_1_1ArpCache_adf7d795ca712fb957b97934c1556168a}


Set the time the entry will be in D\+E\+AD state before being removed. 


\begin{DoxyParams}{Parameters}
{\em dead\+Timeout} & the Dead state timeout \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
143 \{
144   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << deadTimeout);
145   \hyperlink{classns3_1_1ArpCache_a399aae557ff88496c35d5f6beb842923}{m\_deadTimeout} = deadTimeout;
146 \}
\end{DoxyCode}
\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!Set\+Device@{Set\+Device}}
\index{Set\+Device@{Set\+Device}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{Set\+Device(\+Ptr$<$ Net\+Device $>$ device, Ptr$<$ Ipv4\+Interface $>$ interface)}{SetDevice(Ptr< NetDevice > device, Ptr< Ipv4Interface > interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Arp\+Cache\+::\+Set\+Device (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{device, }
\item[{{\bf Ptr}$<$ {\bf Ipv4\+Interface} $>$}]{interface}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1ArpCache_a8cd550f89be088d8941f65f5ab3f8241}{}\label{classns3_1_1ArpCache_a8cd550f89be088d8941f65f5ab3f8241}


Set the \hyperlink{classns3_1_1NetDevice}{Net\+Device} and \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} associated with the \hyperlink{classns3_1_1ArpCache}{Arp\+Cache}. 


\begin{DoxyParams}{Parameters}
{\em device} & The hardware \hyperlink{classns3_1_1NetDevice}{Net\+Device} associated with this A\+RP cache \\
\hline
{\em interface} & the \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} associated with this A\+RP cache \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
115 \{
116   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << device << interface);
117   \hyperlink{classns3_1_1ArpCache_abeff23a1b2276b8cca9b3a023bce2850}{m\_device} = device;
118   \hyperlink{classns3_1_1ArpCache_a51ac32b4e89fdfb85f0a30a5104f5857}{m\_interface} = interface;
119 \}
\end{DoxyCode}
\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!Set\+Wait\+Reply\+Timeout@{Set\+Wait\+Reply\+Timeout}}
\index{Set\+Wait\+Reply\+Timeout@{Set\+Wait\+Reply\+Timeout}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{Set\+Wait\+Reply\+Timeout(\+Time wait\+Reply\+Timeout)}{SetWaitReplyTimeout(Time waitReplyTimeout)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Arp\+Cache\+::\+Set\+Wait\+Reply\+Timeout (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{wait\+Reply\+Timeout}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1ArpCache_a1422cb8ec06a7dc516849ee9939ebc25}{}\label{classns3_1_1ArpCache_a1422cb8ec06a7dc516849ee9939ebc25}


Set the time the entry will be in W\+A\+I\+T\+\_\+\+R\+E\+P\+LY state. 


\begin{DoxyParams}{Parameters}
{\em wait\+Reply\+Timeout} & the W\+A\+I\+T\+\_\+\+R\+E\+P\+LY state timeout \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
149 \{
150   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << waitReplyTimeout);
151   \hyperlink{classns3_1_1ArpCache_a4369a983ccf79656dbe6066b5fe91814}{m\_waitReplyTimeout} = waitReplyTimeout;
152 \}
\end{DoxyCode}
\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!Start\+Wait\+Reply\+Timer@{Start\+Wait\+Reply\+Timer}}
\index{Start\+Wait\+Reply\+Timer@{Start\+Wait\+Reply\+Timer}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{Start\+Wait\+Reply\+Timer(void)}{StartWaitReplyTimer(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Arp\+Cache\+::\+Start\+Wait\+Reply\+Timer (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1ArpCache_ada18c1c06844b8e43201d3d7a3a61098}{}\label{classns3_1_1ArpCache_ada18c1c06844b8e43201d3d7a3a61098}
This method will schedule a timeout at Wait\+Reply\+Timeout interval in the future, unless a timer is already running for the cache, in which case this method does nothing. 
\begin{DoxyCode}
183 \{
184   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
185   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1ArpCache_a2725853dd931117b4d49b95b036f6d2b}{m\_waitReplyTimer}.\hyperlink{classns3_1_1EventId_aabf8476d1a080c199ea0c6aa9ccea372}{IsRunning} ())
186     \{
187       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Starting WaitReplyTimer at "} << \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} () << \textcolor{stringliteral}{" for "}
       <<
188                     \hyperlink{classns3_1_1ArpCache_a4369a983ccf79656dbe6066b5fe91814}{m\_waitReplyTimeout});
189       \hyperlink{classns3_1_1ArpCache_a2725853dd931117b4d49b95b036f6d2b}{m\_waitReplyTimer} = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (
      \hyperlink{classns3_1_1ArpCache_a4369a983ccf79656dbe6066b5fe91814}{m\_waitReplyTimeout}, 
190                                               &\hyperlink{classns3_1_1ArpCache_a8922ac0806811b42957bfc68a3ccf1c6}{ArpCache::HandleWaitReplyTimeout}
      , \textcolor{keyword}{this});
191     \}
192 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 16




Here is the caller graph for this function\+:
% FIG 17




\subsection{Member Data Documentation}
\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!m\+\_\+alive\+Timeout@{m\+\_\+alive\+Timeout}}
\index{m\+\_\+alive\+Timeout@{m\+\_\+alive\+Timeout}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{m\+\_\+alive\+Timeout}{m_aliveTimeout}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Arp\+Cache\+::m\+\_\+alive\+Timeout\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1ArpCache_a30dc0bd7f1b0fb5847a9df0db1d52add}{}\label{classns3_1_1ArpCache_a30dc0bd7f1b0fb5847a9df0db1d52add}


cache alive state timeout 

\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!m\+\_\+arp\+Cache@{m\+\_\+arp\+Cache}}
\index{m\+\_\+arp\+Cache@{m\+\_\+arp\+Cache}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{m\+\_\+arp\+Cache}{m_arpCache}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cache} ns3\+::\+Arp\+Cache\+::m\+\_\+arp\+Cache\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1ArpCache_a952de05903ff6b400c332c1bad8e0fc6}{}\label{classns3_1_1ArpCache_a952de05903ff6b400c332c1bad8e0fc6}


the A\+RP cache 

\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!m\+\_\+arp\+Request\+Callback@{m\+\_\+arp\+Request\+Callback}}
\index{m\+\_\+arp\+Request\+Callback@{m\+\_\+arp\+Request\+Callback}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{m\+\_\+arp\+Request\+Callback}{m_arpRequestCallback}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Callback}$<$void, {\bf Ptr}$<$const {\bf Arp\+Cache}$>$, {\bf Ipv4\+Address}$>$ ns3\+::\+Arp\+Cache\+::m\+\_\+arp\+Request\+Callback\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1ArpCache_a91797ea0de773ea3b9ba84e8cd42a3e0}{}\label{classns3_1_1ArpCache_a91797ea0de773ea3b9ba84e8cd42a3e0}


reply timeout callback 

\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!m\+\_\+dead\+Timeout@{m\+\_\+dead\+Timeout}}
\index{m\+\_\+dead\+Timeout@{m\+\_\+dead\+Timeout}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{m\+\_\+dead\+Timeout}{m_deadTimeout}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Arp\+Cache\+::m\+\_\+dead\+Timeout\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1ArpCache_a399aae557ff88496c35d5f6beb842923}{}\label{classns3_1_1ArpCache_a399aae557ff88496c35d5f6beb842923}


cache dead state timeout 

\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!m\+\_\+device@{m\+\_\+device}}
\index{m\+\_\+device@{m\+\_\+device}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{m\+\_\+device}{m_device}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Net\+Device}$>$ ns3\+::\+Arp\+Cache\+::m\+\_\+device\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1ArpCache_abeff23a1b2276b8cca9b3a023bce2850}{}\label{classns3_1_1ArpCache_abeff23a1b2276b8cca9b3a023bce2850}


\hyperlink{classns3_1_1NetDevice}{Net\+Device} associated with the cache. 

\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!m\+\_\+drop\+Trace@{m\+\_\+drop\+Trace}}
\index{m\+\_\+drop\+Trace@{m\+\_\+drop\+Trace}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{m\+\_\+drop\+Trace}{m_dropTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Arp\+Cache\+::m\+\_\+drop\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1ArpCache_a7f919ba19c2dbbae6f4d9251ded35fa3}{}\label{classns3_1_1ArpCache_a7f919ba19c2dbbae6f4d9251ded35fa3}


trace for packets dropped by the A\+RP cache queue 

\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!m\+\_\+interface@{m\+\_\+interface}}
\index{m\+\_\+interface@{m\+\_\+interface}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{m\+\_\+interface}{m_interface}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Ipv4\+Interface}$>$ ns3\+::\+Arp\+Cache\+::m\+\_\+interface\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1ArpCache_a51ac32b4e89fdfb85f0a30a5104f5857}{}\label{classns3_1_1ArpCache_a51ac32b4e89fdfb85f0a30a5104f5857}


\hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} associated with the cache. 

\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!m\+\_\+max\+Retries@{m\+\_\+max\+Retries}}
\index{m\+\_\+max\+Retries@{m\+\_\+max\+Retries}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Retries}{m_maxRetries}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Arp\+Cache\+::m\+\_\+max\+Retries\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1ArpCache_a24f0460babb1745ff532b16710846ab9}{}\label{classns3_1_1ArpCache_a24f0460babb1745ff532b16710846ab9}


max retries for a resolution 

\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!m\+\_\+pending\+Queue\+Size@{m\+\_\+pending\+Queue\+Size}}
\index{m\+\_\+pending\+Queue\+Size@{m\+\_\+pending\+Queue\+Size}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{m\+\_\+pending\+Queue\+Size}{m_pendingQueueSize}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Arp\+Cache\+::m\+\_\+pending\+Queue\+Size\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1ArpCache_a70391342295055352cc9cfcf34d3cc52}{}\label{classns3_1_1ArpCache_a70391342295055352cc9cfcf34d3cc52}


number of packets waiting for a resolution 

\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!m\+\_\+wait\+Reply\+Timeout@{m\+\_\+wait\+Reply\+Timeout}}
\index{m\+\_\+wait\+Reply\+Timeout@{m\+\_\+wait\+Reply\+Timeout}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{m\+\_\+wait\+Reply\+Timeout}{m_waitReplyTimeout}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Arp\+Cache\+::m\+\_\+wait\+Reply\+Timeout\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1ArpCache_a4369a983ccf79656dbe6066b5fe91814}{}\label{classns3_1_1ArpCache_a4369a983ccf79656dbe6066b5fe91814}


cache reply state timeout 

\index{ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}!m\+\_\+wait\+Reply\+Timer@{m\+\_\+wait\+Reply\+Timer}}
\index{m\+\_\+wait\+Reply\+Timer@{m\+\_\+wait\+Reply\+Timer}!ns3\+::\+Arp\+Cache@{ns3\+::\+Arp\+Cache}}
\subsubsection[{\texorpdfstring{m\+\_\+wait\+Reply\+Timer}{m_waitReplyTimer}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Event\+Id} ns3\+::\+Arp\+Cache\+::m\+\_\+wait\+Reply\+Timer\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1ArpCache_a2725853dd931117b4d49b95b036f6d2b}{}\label{classns3_1_1ArpCache_a2725853dd931117b4d49b95b036f6d2b}


cache alive state timer 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/model/\hyperlink{arp-cache_8h}{arp-\/cache.\+h}\item 
internet/model/\hyperlink{arp-cache_8cc}{arp-\/cache.\+cc}\end{DoxyCompactItemize}
