\hypertarget{classns3_1_1VirtualNetDevice}{}\section{ns3\+:\+:Virtual\+Net\+Device Class Reference}
\label{classns3_1_1VirtualNetDevice}\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}


A virtual device, similar to Linux T\+U\+N/\+T\+AP interfaces.  




{\ttfamily \#include $<$virtual-\/net-\/device.\+h$>$}



Inheritance diagram for ns3\+:\+:Virtual\+Net\+Device\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Virtual\+Net\+Device\+:
% FIG 1
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classns3_1_1Callback}{Callback}$<$ bool, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$, const \hyperlink{classns3_1_1Address}{Address} \&, const \hyperlink{classns3_1_1Address}{Address} \&, uint16\+\_\+t $>$ \hyperlink{classns3_1_1VirtualNetDevice_aebf725ef61f43759033989504a83dd7f}{Send\+Callback}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1VirtualNetDevice_ab77801a18776a510358ed65a76d81467}{Virtual\+Net\+Device} ()
\item 
virtual \hyperlink{classns3_1_1VirtualNetDevice_a152e936756c7377d127db78197227502}{$\sim$\+Virtual\+Net\+Device} ()
\item 
void \hyperlink{classns3_1_1VirtualNetDevice_ae4e54639e40bf1c5d8d6ed7da9ababed}{Set\+Send\+Callback} (\hyperlink{classns3_1_1VirtualNetDevice_aebf725ef61f43759033989504a83dd7f}{Send\+Callback} transmit\+Cb)
\begin{DoxyCompactList}\small\item\em Set the user callback to be called when a L2 packet is to be transmitted. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1VirtualNetDevice_a601faebbf94efb6a9dcd27f671198a81}{Set\+Needs\+Arp} (bool needs\+Arp)
\begin{DoxyCompactList}\small\item\em Configure whether the virtual device needs A\+RP. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1VirtualNetDevice_aaf6525f4404af8404fe21a7a70d52be9}{Set\+Is\+Point\+To\+Point} (bool is\+Point\+To\+Point)
\begin{DoxyCompactList}\small\item\em Configure whether the virtual device is point-\/to-\/point. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1VirtualNetDevice_a499659f98c264ba457bbff8b44cd49e7}{Set\+Supports\+Send\+From} (bool supports\+Send\+From)
\begin{DoxyCompactList}\small\item\em Configure whether the virtual device supports Send\+From. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1VirtualNetDevice_a3277a3167e1519924a3bcdf795314178}{Set\+Mtu} (const uint16\+\_\+t mtu)
\begin{DoxyCompactList}\small\item\em Configure the reported M\+TU for the virtual device. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1VirtualNetDevice_a4e13d506dae86955be99116c23034e28}{Receive} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, uint16\+\_\+t protocol, const \hyperlink{classns3_1_1Address}{Address} \&source, const \hyperlink{classns3_1_1Address}{Address} \&destination, \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2}{Packet\+Type} packet\+Type)
\item 
virtual void \hyperlink{classns3_1_1VirtualNetDevice_a625c4b50d530dc677b2dbee19f06de56}{Set\+If\+Index} (const uint32\+\_\+t index)
\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1VirtualNetDevice_ac7297332493d46b81cd291e71ba54fca}{Get\+If\+Index} (void) const 
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Channel}{Channel} $>$ \hyperlink{classns3_1_1VirtualNetDevice_ad06bf273cbaf976574d6e540db73bc48}{Get\+Channel} (void) const 
\item 
virtual void \hyperlink{classns3_1_1VirtualNetDevice_a560887abe97f9327f2973d748aa382e9}{Set\+Address} (\hyperlink{classns3_1_1Address}{Address} address)
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1VirtualNetDevice_a8c8219e4244461ea705b3829a599931c}{Get\+Address} (void) const 
\item 
virtual uint16\+\_\+t \hyperlink{classns3_1_1VirtualNetDevice_a9f0f1def1c49995cce47321bd78f1063}{Get\+Mtu} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1VirtualNetDevice_a72627c9d0c272f15338c1d7611a07498}{Is\+Link\+Up} (void) const 
\item 
virtual void \hyperlink{classns3_1_1VirtualNetDevice_ad93701226c958be8c1d7233d8beb0010}{Add\+Link\+Change\+Callback} (\hyperlink{classns3_1_1Callback}{Callback}$<$ void $>$ callback)
\item 
virtual bool \hyperlink{classns3_1_1VirtualNetDevice_a3fd0309cbcf76ef18412b1affaebeddf}{Is\+Broadcast} (void) const 
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1VirtualNetDevice_a178f087d04d32b6b8d893f5a1f60aabe}{Get\+Broadcast} (void) const 
\item 
virtual bool \hyperlink{classns3_1_1VirtualNetDevice_a6a431d51ea635ffbe87e1bb9745cd781}{Is\+Multicast} (void) const 
\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1VirtualNetDevice_abe6b930113d459edbcdaef8e2337260f}{Get\+Multicast} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} multicast\+Group) const 
\begin{DoxyCompactList}\small\item\em Make and return a M\+AC multicast address using the provided multicast group. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1VirtualNetDevice_aa35482ffe0c1a6e0a13adf1ab2f7999e}{Get\+Multicast} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} addr) const 
\begin{DoxyCompactList}\small\item\em Get the M\+AC multicast address corresponding to the I\+Pv6 address provided. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1VirtualNetDevice_a85359c4e68e987d037ba8e28b7ad206b}{Is\+Point\+To\+Point} (void) const 
\begin{DoxyCompactList}\small\item\em Return true if the net device is on a point-\/to-\/point link. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1VirtualNetDevice_acfd15730e0e77206f8c6ebcf1479eaf9}{Send} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, const \hyperlink{classns3_1_1Address}{Address} \&dest, uint16\+\_\+t protocol\+Number)
\item 
virtual bool \hyperlink{classns3_1_1VirtualNetDevice_a7d6da9fb890983644bd02bbc792709d2}{Send\+From} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, const \hyperlink{classns3_1_1Address}{Address} \&source, const \hyperlink{classns3_1_1Address}{Address} \&dest, uint16\+\_\+t protocol\+Number)
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1VirtualNetDevice_a78707c2e2cb0a5b3620f42caa7fe7811}{Get\+Node} (void) const 
\item 
virtual void \hyperlink{classns3_1_1VirtualNetDevice_ae8a84665899b549ae465d715efd2fd43}{Set\+Node} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node)
\item 
virtual bool \hyperlink{classns3_1_1VirtualNetDevice_aee0cd69025468398482b7af188fcc34f}{Needs\+Arp} (void) const 
\item 
virtual void \hyperlink{classns3_1_1VirtualNetDevice_ace48567f181d0f096cd76a45e7ec22c8}{Set\+Receive\+Callback} (\hyperlink{classns3_1_1NetDevice_ad5e5e1ca187472bc2ba99575d8def568}{Net\+Device\+::\+Receive\+Callback} cb)
\item 
virtual void \hyperlink{classns3_1_1VirtualNetDevice_a3b0544bacdb411a716515cda7e62c2f3}{Set\+Promisc\+Receive\+Callback} (\hyperlink{classns3_1_1NetDevice_a427225795919f26c414bee2ea3f31ed2}{Net\+Device\+::\+Promisc\+Receive\+Callback} cb)
\item 
virtual bool \hyperlink{classns3_1_1VirtualNetDevice_aa31fa2c5ff6423606d7b683dd4de467f}{Supports\+Send\+From} () const 
\item 
virtual bool \hyperlink{classns3_1_1VirtualNetDevice_ab7c75263f37d8933e572f228ebc418a3}{Is\+Bridge} (void) const 
\begin{DoxyCompactList}\small\item\em Return true if the net device is acting as a bridge. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1VirtualNetDevice_a7f923e2ff1ecd669740a5221b703dab1}{Get\+Type\+Id} (void)
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1VirtualNetDevice_a7106b7623f5d58e783793de4f97bacfc}{Do\+Dispose} (void)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Address}{Address} \hyperlink{classns3_1_1VirtualNetDevice_ac101b023db43fd70e2498a3b58b456d3}{m\+\_\+my\+Address}
\item 
\hyperlink{classns3_1_1VirtualNetDevice_aebf725ef61f43759033989504a83dd7f}{Send\+Callback} \hyperlink{classns3_1_1VirtualNetDevice_af7be2e7f02d269b54b88a9e396a3fcc4}{m\+\_\+send\+Cb}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1VirtualNetDevice_a434af9b19b144c539ab06deec0ac5125}{m\+\_\+mac\+Rx\+Trace}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1VirtualNetDevice_af893adb92d8bef8af0b47a3a798a2003}{m\+\_\+mac\+Tx\+Trace}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1VirtualNetDevice_a978beda53d5a1309d1fff0cbfb3137b6}{m\+\_\+mac\+Promisc\+Rx\+Trace}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1VirtualNetDevice_a590ab436f1261e3e1e52128678026023}{m\+\_\+sniffer\+Trace}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1VirtualNetDevice_a18f48204e84161b3e3472ee0af08bbfe}{m\+\_\+promisc\+Sniffer\+Trace}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1VirtualNetDevice_a152f05be787bb166a37830a919f2a975}{m\+\_\+node}
\item 
\hyperlink{classns3_1_1NetDevice_ad5e5e1ca187472bc2ba99575d8def568}{Receive\+Callback} \hyperlink{classns3_1_1VirtualNetDevice_adf4e9569cfa5ae6051c76cb4ddda1c14}{m\+\_\+rx\+Callback}
\item 
\hyperlink{classns3_1_1NetDevice_a427225795919f26c414bee2ea3f31ed2}{Promisc\+Receive\+Callback} \hyperlink{classns3_1_1VirtualNetDevice_adaab3f043b0241d58ccdb9ba7ba7587e}{m\+\_\+promisc\+Rx\+Callback}
\item 
std\+::string \hyperlink{classns3_1_1VirtualNetDevice_adb3560f38c365a7fda84caf403c4326c}{m\+\_\+name}
\item 
uint32\+\_\+t \hyperlink{classns3_1_1VirtualNetDevice_a2f1e2e67cf29cc3fd446e2d9c410e9fc}{m\+\_\+index}
\item 
uint16\+\_\+t \hyperlink{classns3_1_1VirtualNetDevice_a3df667e5920ae7bde13ce2f30a4a2bbd}{m\+\_\+mtu}
\item 
bool \hyperlink{classns3_1_1VirtualNetDevice_a6d5b194341bd76b5c99e4c01616fb788}{m\+\_\+needs\+Arp}
\item 
bool \hyperlink{classns3_1_1VirtualNetDevice_aac37389af138f3fae76a3219f9e69869}{m\+\_\+supports\+Send\+From}
\item 
bool \hyperlink{classns3_1_1VirtualNetDevice_af59a3ce1a68aa62f1bded3e131440cbc}{m\+\_\+is\+Point\+To\+Point}
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
A virtual device, similar to Linux T\+U\+N/\+T\+AP interfaces. 

A \hyperlink{classns3_1_1VirtualNetDevice}{Virtual\+Net\+Device} is a \char`\"{}virtual\char`\"{} \hyperlink{classns3_1_1NetDevice}{Net\+Device} implementation which delegates to a user callback (see method \hyperlink{classns3_1_1VirtualNetDevice_ae4e54639e40bf1c5d8d6ed7da9ababed}{Set\+Send\+Callback()}) the task of actually transmitting a packet. It also allows the user code to inject the packet as if it had been received by the \hyperlink{classns3_1_1VirtualNetDevice}{Virtual\+Net\+Device}. Together, these features allow one to build tunnels. For instance, by transmitting packets into a U\+DP socket we end up building an I\+P-\/over-\/\+U\+D\+P-\/over-\/\+IP tunnel, or I\+P-\/over-\/\+IP tunnels.

The same thing could be accomplished by subclassing \hyperlink{classns3_1_1NetDevice}{Net\+Device} directly. However, \hyperlink{classns3_1_1VirtualNetDevice}{Virtual\+Net\+Device} is usually much simpler to program than a \hyperlink{classns3_1_1NetDevice}{Net\+Device} subclass. 

\subsection{Member Typedef Documentation}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Send\+Callback@{Send\+Callback}}
\index{Send\+Callback@{Send\+Callback}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Send\+Callback}{SendCallback}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Callback}$<$bool, {\bf Ptr}$<${\bf Packet}$>$, const {\bf Address}\&, const {\bf Address}\&, uint16\+\_\+t$>$ {\bf ns3\+::\+Virtual\+Net\+Device\+::\+Send\+Callback}}\hypertarget{classns3_1_1VirtualNetDevice_aebf725ef61f43759033989504a83dd7f}{}\label{classns3_1_1VirtualNetDevice_aebf725ef61f43759033989504a83dd7f}
\hyperlink{classns3_1_1Callback}{Callback} the be invoked when the \hyperlink{classns3_1_1VirtualNetDevice}{Virtual\+Net\+Device} is asked to queue/transmit a packet. For more information, consult the documentation of \hyperlink{classns3_1_1NetDevice_a19d55a4746c1ae584bf7da69959a885b}{Net\+Device\+::\+Send\+From()}. 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Virtual\+Net\+Device@{Virtual\+Net\+Device}}
\index{Virtual\+Net\+Device@{Virtual\+Net\+Device}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Virtual\+Net\+Device()}{VirtualNetDevice()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Virtual\+Net\+Device\+::\+Virtual\+Net\+Device (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1VirtualNetDevice_ab77801a18776a510358ed65a76d81467}{}\label{classns3_1_1VirtualNetDevice_ab77801a18776a510358ed65a76d81467}

\begin{DoxyCode}
87 \{
88   \hyperlink{classns3_1_1VirtualNetDevice_a6d5b194341bd76b5c99e4c01616fb788}{m\_needsArp} = \textcolor{keyword}{false};
89   \hyperlink{classns3_1_1VirtualNetDevice_aac37389af138f3fae76a3219f9e69869}{m\_supportsSendFrom} = \textcolor{keyword}{true};
90   \hyperlink{classns3_1_1VirtualNetDevice_af59a3ce1a68aa62f1bded3e131440cbc}{m\_isPointToPoint} = \textcolor{keyword}{true};
91 \}
\end{DoxyCode}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!````~Virtual\+Net\+Device@{$\sim$\+Virtual\+Net\+Device}}
\index{````~Virtual\+Net\+Device@{$\sim$\+Virtual\+Net\+Device}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{$\sim$\+Virtual\+Net\+Device()}{~VirtualNetDevice()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Virtual\+Net\+Device\+::$\sim$\+Virtual\+Net\+Device (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1VirtualNetDevice_a152e936756c7377d127db78197227502}{}\label{classns3_1_1VirtualNetDevice_a152e936756c7377d127db78197227502}

\begin{DoxyCode}
127 \{
128   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
129 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Add\+Link\+Change\+Callback@{Add\+Link\+Change\+Callback}}
\index{Add\+Link\+Change\+Callback@{Add\+Link\+Change\+Callback}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Add\+Link\+Change\+Callback(\+Callback$<$ void $>$ callback)}{AddLinkChangeCallback(Callback< void > callback)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Virtual\+Net\+Device\+::\+Add\+Link\+Change\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Callback}$<$ void $>$}]{callback}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1VirtualNetDevice_ad93701226c958be8c1d7233d8beb0010}{}\label{classns3_1_1VirtualNetDevice_ad93701226c958be8c1d7233d8beb0010}

\begin{DoxyParams}{Parameters}
{\em callback} & the callback to invoke\\
\hline
\end{DoxyParams}
Add a callback invoked whenever the link status changes to UP. This callback is typically used by the I\+P/\+A\+RP layer to flush the A\+RP cache and by I\+Pv6 stack to flush N\+D\+I\+SC cache whenever the link goes up. 

Implements \hyperlink{classns3_1_1NetDevice_aafb1bf869d38ef7a7112d11fab0163a3}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
215 \{
216 \}
\end{DoxyCode}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Do\+Dispose(void)}{DoDispose(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Virtual\+Net\+Device\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1VirtualNetDevice_a7106b7623f5d58e783793de4f97bacfc}{}\label{classns3_1_1VirtualNetDevice_a7106b7623f5d58e783793de4f97bacfc}
Destructor implementation.

This method is called by \hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose()} or by the \hyperlink{classns3_1_1Object}{Object}\textquotesingle{}s destructor, whichever comes first.

Subclasses are expected to implement their real destruction code in an overriden version of this method and chain up to their parent\textquotesingle{}s implementation once they are done. {\itshape i.\+e}, for simplicity, the destructor of every subclass should be empty and its content should be moved to the associated \hyperlink{classns3_1_1VirtualNetDevice_a7106b7623f5d58e783793de4f97bacfc}{Do\+Dispose()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.


\begin{DoxyCode}
133 \{
134   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
135   \hyperlink{classns3_1_1VirtualNetDevice_a152f05be787bb166a37830a919f2a975}{m\_node} = 0;
136   \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{NetDevice::DoDispose} ();
137 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Get\+Address@{Get\+Address}}
\index{Get\+Address@{Get\+Address}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Address(void) const }{GetAddress(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Virtual\+Net\+Device\+::\+Get\+Address (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1VirtualNetDevice_a8c8219e4244461ea705b3829a599931c}{}\label{classns3_1_1VirtualNetDevice_a8c8219e4244461ea705b3829a599931c}
\begin{DoxyReturn}{Returns}
the current \hyperlink{classns3_1_1Address}{Address} of this interface. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a671f99de496d6f09ae343bb715301fb2}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
191 \{
192   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1VirtualNetDevice_ac101b023db43fd70e2498a3b58b456d3}{m\_myAddress};
193 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 3


\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Get\+Broadcast@{Get\+Broadcast}}
\index{Get\+Broadcast@{Get\+Broadcast}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Broadcast(void) const }{GetBroadcast(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Virtual\+Net\+Device\+::\+Get\+Broadcast (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1VirtualNetDevice_a178f087d04d32b6b8d893f5a1f60aabe}{}\label{classns3_1_1VirtualNetDevice_a178f087d04d32b6b8d893f5a1f60aabe}
\begin{DoxyReturn}{Returns}
the broadcast address supported by this netdevice.
\end{DoxyReturn}
Calling this method is invalid if Is\+Broadcast returns not true. 

Implements \hyperlink{classns3_1_1NetDevice_a4724e03bc548dd8e967cc4a7356197bd}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
226 \{
227   \textcolor{keywordflow}{return} Mac48Address (\textcolor{stringliteral}{"ff:ff:ff:ff:ff:ff"});
228 \}
\end{DoxyCode}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Get\+Channel@{Get\+Channel}}
\index{Get\+Channel@{Get\+Channel}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Channel(void) const }{GetChannel(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Channel} $>$ ns3\+::\+Virtual\+Net\+Device\+::\+Get\+Channel (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1VirtualNetDevice_ad06bf273cbaf976574d6e540db73bc48}{}\label{classns3_1_1VirtualNetDevice_ad06bf273cbaf976574d6e540db73bc48}
\begin{DoxyReturn}{Returns}
the channel this \hyperlink{classns3_1_1NetDevice}{Net\+Device} is connected to. The value returned can be zero if the \hyperlink{classns3_1_1NetDevice}{Net\+Device} is not yet connected to any channel or if the underlying \hyperlink{classns3_1_1NetDevice}{Net\+Device} has no concept of a channel. i.\+e., callers {\itshape must} check for zero and be ready to handle it. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a3d810bd2738634e2e851661271828565}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
185 \{
186   \textcolor{keywordflow}{return} Ptr<Channel> ();
187 \}
\end{DoxyCode}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Get\+If\+Index@{Get\+If\+Index}}
\index{Get\+If\+Index@{Get\+If\+Index}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+If\+Index(void) const }{GetIfIndex(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Virtual\+Net\+Device\+::\+Get\+If\+Index (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1VirtualNetDevice_ac7297332493d46b81cd291e71ba54fca}{}\label{classns3_1_1VirtualNetDevice_ac7297332493d46b81cd291e71ba54fca}
\begin{DoxyReturn}{Returns}
index if\+Index of the device 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a8c1ae2ec8eadc4524dfc1e425bfa0850}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
179 \{
180   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1VirtualNetDevice_a2f1e2e67cf29cc3fd446e2d9c410e9fc}{m\_index};
181 \}
\end{DoxyCode}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Get\+Mtu@{Get\+Mtu}}
\index{Get\+Mtu@{Get\+Mtu}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Mtu(void) const }{GetMtu(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Virtual\+Net\+Device\+::\+Get\+Mtu (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1VirtualNetDevice_a9f0f1def1c49995cce47321bd78f1063}{}\label{classns3_1_1VirtualNetDevice_a9f0f1def1c49995cce47321bd78f1063}
\begin{DoxyReturn}{Returns}
the link-\/level M\+TU in bytes for this interface.
\end{DoxyReturn}
This value is typically used by the IP layer to perform IP fragmentation when needed. 

Implements \hyperlink{classns3_1_1NetDevice_a91f4f5d01bc2d567c1e0a69b63a4cf14}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
203 \{
204   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1VirtualNetDevice_a3df667e5920ae7bde13ce2f30a4a2bbd}{m\_mtu};
205 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Get\+Multicast@{Get\+Multicast}}
\index{Get\+Multicast@{Get\+Multicast}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Multicast(\+Ipv4\+Address multicast\+Group) const }{GetMulticast(Ipv4Address multicastGroup) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Virtual\+Net\+Device\+::\+Get\+Multicast (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{multicast\+Group}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1VirtualNetDevice_abe6b930113d459edbcdaef8e2337260f}{}\label{classns3_1_1VirtualNetDevice_abe6b930113d459edbcdaef8e2337260f}


Make and return a M\+AC multicast address using the provided multicast group. 

\{1112\} says that an \hyperlink{classns3_1_1Ipv4}{Ipv4} host group address is mapped to an Ethernet multicast address by placing the low-\/order 23-\/bits of the IP address into the low-\/order 23 bits of the Ethernet multicast address 01-\/00-\/5\+E-\/00-\/00-\/00 (hex). Similar R\+F\+Cs exist for \hyperlink{classns3_1_1Ipv6}{Ipv6} and Eui64 mappings. This method performs the multicast address creation function appropriate to the underlying M\+AC address of the device. This M\+AC address is encapsulated in an abstract \hyperlink{classns3_1_1Address}{Address} to avoid dependencies on the exact M\+AC address format.

In the case of net devices that do not support multicast, clients are expected to test \hyperlink{classns3_1_1NetDevice_a1afb4848a9226540f1ff51f9b31ae95e}{Net\+Device\+::\+Is\+Multicast} and avoid attempting to map multicast packets. Subclasses of \hyperlink{classns3_1_1NetDevice}{Net\+Device} that do support multicasting are expected to override this method and provide an implementation appropriate to the particular device.


\begin{DoxyParams}{Parameters}
{\em multicast\+Group} & The IP address for the multicast group destination of the packet. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The M\+AC multicast \hyperlink{classns3_1_1Address}{Address} used to send packets to the provided multicast group.
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Calling this method is invalid if Is\+Multicast returns not true. 
\end{DoxyWarning}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1VirtualNetDevice_a6a431d51ea635ffbe87e1bb9745cd781}{Is\+Multicast()} 
\end{DoxySeeAlso}


Implements \hyperlink{classns3_1_1NetDevice_a98aa4852df367b6a393c8cc1d88af0d9}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
237 \{
238   \textcolor{keywordflow}{return} Mac48Address (\textcolor{stringliteral}{"ff:ff:ff:ff:ff:ff"});
239 \}
\end{DoxyCode}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Get\+Multicast@{Get\+Multicast}}
\index{Get\+Multicast@{Get\+Multicast}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Multicast(\+Ipv6\+Address addr) const }{GetMulticast(Ipv6Address addr) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Virtual\+Net\+Device\+::\+Get\+Multicast (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{addr}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1VirtualNetDevice_aa35482ffe0c1a6e0a13adf1ab2f7999e}{}\label{classns3_1_1VirtualNetDevice_aa35482ffe0c1a6e0a13adf1ab2f7999e}


Get the M\+AC multicast address corresponding to the I\+Pv6 address provided. 


\begin{DoxyParams}{Parameters}
{\em addr} & I\+Pv6 address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the M\+AC multicast address 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Calling this method is invalid if Is\+Multicast returns not true. 
\end{DoxyWarning}


Implements \hyperlink{classns3_1_1NetDevice_a46479a2c0101c6f9da9251ed4d7575bd}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
242 \{
243   \textcolor{keywordflow}{return} Mac48Address (\textcolor{stringliteral}{"ff:ff:ff:ff:ff:ff"});
244 \}
\end{DoxyCode}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Get\+Node@{Get\+Node}}
\index{Get\+Node@{Get\+Node}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Node(void) const }{GetNode(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Node} $>$ ns3\+::\+Virtual\+Net\+Device\+::\+Get\+Node (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1VirtualNetDevice_a78707c2e2cb0a5b3620f42caa7fe7811}{}\label{classns3_1_1VirtualNetDevice_a78707c2e2cb0a5b3620f42caa7fe7811}
\begin{DoxyReturn}{Returns}
the node base class which contains this network interface.
\end{DoxyReturn}
When a subclass needs to get access to the underlying node base class to print the nodeid for example, it can invoke this method. 

Implements \hyperlink{classns3_1_1NetDevice_a098b6cc4339ac00c62e75cfa48c8aeac}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
278 \{
279   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1VirtualNetDevice_a152f05be787bb166a37830a919f2a975}{m\_node};
280 \}
\end{DoxyCode}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Virtual\+Net\+Device\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1VirtualNetDevice_a7f923e2ff1ecd669740a5221b703dab1}{}\label{classns3_1_1VirtualNetDevice_a7f923e2ff1ecd669740a5221b703dab1}

\begin{DoxyCode}
40 \{
41   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::VirtualNetDevice"})
42     .SetParent<NetDevice> ()
43     .SetGroupName (\textcolor{stringliteral}{"VirtualNetDevice"})
44     .AddConstructor<\hyperlink{classns3_1_1VirtualNetDevice_ab77801a18776a510358ed65a76d81467}{VirtualNetDevice}> ()
45     .AddAttribute (\textcolor{stringliteral}{"Mtu"}, \textcolor{stringliteral}{"The MAC-level Maximum Transmission Unit"},
46                    UintegerValue (1500),
47                    MakeUintegerAccessor (&\hyperlink{classns3_1_1VirtualNetDevice_a3277a3167e1519924a3bcdf795314178}{VirtualNetDevice::SetMtu},
48                                          &\hyperlink{classns3_1_1VirtualNetDevice_a9f0f1def1c49995cce47321bd78f1063}{VirtualNetDevice::GetMtu}),
49                    MakeUintegerChecker<uint16\_t> ())
50     .AddTraceSource (\textcolor{stringliteral}{"MacTx"}, 
51                      \textcolor{stringliteral}{"Trace source indicating a packet has arrived "}
52                      \textcolor{stringliteral}{"for transmission by this device"},
53                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1VirtualNetDevice_af893adb92d8bef8af0b47a3a798a2003}{VirtualNetDevice::m\_macTxTrace}),
54                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
55     .AddTraceSource (\textcolor{stringliteral}{"MacPromiscRx"}, 
56                      \textcolor{stringliteral}{"A packet has been received by this device, "}
57                      \textcolor{stringliteral}{"has been passed up from the physical layer "}
58                      \textcolor{stringliteral}{"and is being forwarded up the local protocol stack.  "}
59                      \textcolor{stringliteral}{"This is a promiscuous trace,"},
60                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1VirtualNetDevice_a978beda53d5a1309d1fff0cbfb3137b6}{VirtualNetDevice::m\_macPromiscRxTrace}),
61                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
62     .AddTraceSource (\textcolor{stringliteral}{"MacRx"}, 
63                      \textcolor{stringliteral}{"A packet has been received by this device, "}
64                      \textcolor{stringliteral}{"has been passed up from the physical layer "}
65                      \textcolor{stringliteral}{"and is being forwarded up the local protocol stack.  "}
66                      \textcolor{stringliteral}{"This is a non-promiscuous trace,"},
67                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1VirtualNetDevice_a434af9b19b144c539ab06deec0ac5125}{VirtualNetDevice::m\_macRxTrace}),
68                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
69     \textcolor{comment}{//}
70     \textcolor{comment}{// Trace sources designed to simulate a packet sniffer facility (tcpdump). }
71     \textcolor{comment}{//}
72     .AddTraceSource (\textcolor{stringliteral}{"Sniffer"}, 
73                      \textcolor{stringliteral}{"Trace source simulating a non-promiscuous "}
74                      \textcolor{stringliteral}{"packet sniffer attached to the device"},
75                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1VirtualNetDevice_a590ab436f1261e3e1e52128678026023}{VirtualNetDevice::m\_snifferTrace}),
76                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
77     .AddTraceSource (\textcolor{stringliteral}{"PromiscSniffer"}, 
78                      \textcolor{stringliteral}{"Trace source simulating a promiscuous "}
79                      \textcolor{stringliteral}{"packet sniffer attached to the device"},
80                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1VirtualNetDevice_a18f48204e84161b3e3472ee0af08bbfe}{VirtualNetDevice::m\_promiscSnifferTrace}),
81                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
82   ;
83   \textcolor{keywordflow}{return} tid;
84 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5


\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Is\+Bridge@{Is\+Bridge}}
\index{Is\+Bridge@{Is\+Bridge}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Bridge(void) const }{IsBridge(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Virtual\+Net\+Device\+::\+Is\+Bridge (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1VirtualNetDevice_ab7c75263f37d8933e572f228ebc418a3}{}\label{classns3_1_1VirtualNetDevice_ab7c75263f37d8933e572f228ebc418a3}


Return true if the net device is acting as a bridge. 

\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Bridge flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a9d34556a1c83a69dacb08698ca4a1d94}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
313 \{
314   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
315 \}
\end{DoxyCode}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Is\+Broadcast@{Is\+Broadcast}}
\index{Is\+Broadcast@{Is\+Broadcast}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Broadcast(void) const }{IsBroadcast(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Virtual\+Net\+Device\+::\+Is\+Broadcast (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1VirtualNetDevice_a3fd0309cbcf76ef18412b1affaebeddf}{}\label{classns3_1_1VirtualNetDevice_a3fd0309cbcf76ef18412b1affaebeddf}
\begin{DoxyReturn}{Returns}
true if this interface supports a broadcast address, false otherwise. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a67f992b20858cd7b397d8fba2feff141}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
220 \{
221   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
222 \}
\end{DoxyCode}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Is\+Link\+Up@{Is\+Link\+Up}}
\index{Is\+Link\+Up@{Is\+Link\+Up}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Link\+Up(void) const }{IsLinkUp(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Virtual\+Net\+Device\+::\+Is\+Link\+Up (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1VirtualNetDevice_a72627c9d0c272f15338c1d7611a07498}{}\label{classns3_1_1VirtualNetDevice_a72627c9d0c272f15338c1d7611a07498}
\begin{DoxyReturn}{Returns}
true if link is up; false otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_afe1822b79e19a05ab95f693c8fb64fc7}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
209 \{
210   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
211 \}
\end{DoxyCode}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Is\+Multicast@{Is\+Multicast}}
\index{Is\+Multicast@{Is\+Multicast}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Multicast(void) const }{IsMulticast(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Virtual\+Net\+Device\+::\+Is\+Multicast (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1VirtualNetDevice_a6a431d51ea635ffbe87e1bb9745cd781}{}\label{classns3_1_1VirtualNetDevice_a6a431d51ea635ffbe87e1bb9745cd781}
\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Multicast flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a1afb4848a9226540f1ff51f9b31ae95e}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
232 \{
233   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
234 \}
\end{DoxyCode}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Is\+Point\+To\+Point@{Is\+Point\+To\+Point}}
\index{Is\+Point\+To\+Point@{Is\+Point\+To\+Point}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Is\+Point\+To\+Point(void) const }{IsPointToPoint(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Virtual\+Net\+Device\+::\+Is\+Point\+To\+Point (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1VirtualNetDevice_a85359c4e68e987d037ba8e28b7ad206b}{}\label{classns3_1_1VirtualNetDevice_a85359c4e68e987d037ba8e28b7ad206b}


Return true if the net device is on a point-\/to-\/point link. 

\begin{DoxyReturn}{Returns}
value of m\+\_\+is\+Point\+To\+Point flag 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a718177f25efeaf2dbf8a18fcab87224d}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
249 \{
250   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1VirtualNetDevice_af59a3ce1a68aa62f1bded3e131440cbc}{m\_isPointToPoint};
251 \}
\end{DoxyCode}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Needs\+Arp@{Needs\+Arp}}
\index{Needs\+Arp@{Needs\+Arp}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Needs\+Arp(void) const }{NeedsArp(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Virtual\+Net\+Device\+::\+Needs\+Arp (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1VirtualNetDevice_aee0cd69025468398482b7af188fcc34f}{}\label{classns3_1_1VirtualNetDevice_aee0cd69025468398482b7af188fcc34f}
\begin{DoxyReturn}{Returns}
true if A\+RP is needed, false otherwise.
\end{DoxyReturn}
Called by higher-\/layers to check if this \hyperlink{classns3_1_1NetDevice}{Net\+Device} requires A\+RP to be used. 

Implements \hyperlink{classns3_1_1NetDevice_ab1a133696310cad3dc2c3d1a4993f310}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
290 \{
291   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1VirtualNetDevice_a6d5b194341bd76b5c99e4c01616fb788}{m\_needsArp};
292 \}
\end{DoxyCode}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Receive@{Receive}}
\index{Receive@{Receive}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Receive(\+Ptr$<$ Packet $>$ packet, uint16\+\_\+t protocol, const Address \&source, const Address \&destination, Packet\+Type packet\+Type)}{Receive(Ptr< Packet > packet, uint16_t protocol, const Address &source, const Address &destination, PacketType packetType)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Virtual\+Net\+Device\+::\+Receive (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{uint16\+\_\+t}]{protocol, }
\item[{const {\bf Address} \&}]{source, }
\item[{const {\bf Address} \&}]{destination, }
\item[{{\bf Packet\+Type}}]{packet\+Type}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1VirtualNetDevice_a4e13d506dae86955be99116c23034e28}{}\label{classns3_1_1VirtualNetDevice_a4e13d506dae86955be99116c23034e28}

\begin{DoxyParams}{Parameters}
{\em packet} & packet sent from below up to Network Device \\
\hline
{\em protocol} & Protocol type \\
\hline
{\em source} & the address of the sender of this packet. \\
\hline
{\em destination} & the address of the receiver of this packet. \\
\hline
{\em packet\+Type} & type of packet received (broadcast/multicast/unicast/otherhost) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the packet was forwarded successfully, false otherwise.
\end{DoxyReturn}
Forward a \char`\"{}virtually received\char`\"{} packet up the node\textquotesingle{}s protocol stack. 
\begin{DoxyCode}
143 \{
144   \textcolor{comment}{// }
145   \textcolor{comment}{// For all kinds of packetType we receive, we hit the promiscuous sniffer}
146   \textcolor{comment}{// hook and pass a copy up to the promiscuous callback.  Pass a copy to }
147   \textcolor{comment}{// make sure that nobody messes with our packet.}
148   \textcolor{comment}{//}
149   \hyperlink{classns3_1_1VirtualNetDevice_a18f48204e84161b3e3472ee0af08bbfe}{m\_promiscSnifferTrace} (packet);
150   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1VirtualNetDevice_adaab3f043b0241d58ccdb9ba7ba7587e}{m\_promiscRxCallback}.\hyperlink{classns3_1_1Callback_aa8e27826badbf37f84763f36f70d9b54}{IsNull} ())
151     \{
152       \hyperlink{classns3_1_1VirtualNetDevice_a978beda53d5a1309d1fff0cbfb3137b6}{m\_macPromiscRxTrace} (packet);
153       \hyperlink{classns3_1_1VirtualNetDevice_adaab3f043b0241d58ccdb9ba7ba7587e}{m\_promiscRxCallback} (\textcolor{keyword}{this}, packet, protocol, source, destination, packetType);
154     \}
155 
156   \textcolor{comment}{//}
157   \textcolor{comment}{// If this packet is not destined for some other host, it must be for us}
158   \textcolor{comment}{// as either a broadcast, multicast or unicast.  We need to hit the mac}
159   \textcolor{comment}{// packet received trace hook and forward the packet up the stack.}
160   \textcolor{comment}{//}
161   \textcolor{keywordflow}{if} (packetType != \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2a60c00fab4286dd2903e2b197a9f8c6c8}{PACKET\_OTHERHOST})
162     \{
163       \hyperlink{classns3_1_1VirtualNetDevice_a590ab436f1261e3e1e52128678026023}{m\_snifferTrace} (packet);
164       \hyperlink{classns3_1_1VirtualNetDevice_a434af9b19b144c539ab06deec0ac5125}{m\_macRxTrace} (packet);
165       \textcolor{keywordflow}{return} \hyperlink{classns3_1_1VirtualNetDevice_adf4e9569cfa5ae6051c76cb4ddda1c14}{m\_rxCallback} (\textcolor{keyword}{this}, packet, protocol, source);
166     \}
167   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
168 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6




Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Send@{Send}}
\index{Send@{Send}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Send(\+Ptr$<$ Packet $>$ packet, const Address \&dest, uint16\+\_\+t protocol\+Number)}{Send(Ptr< Packet > packet, const Address &dest, uint16_t protocolNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Virtual\+Net\+Device\+::\+Send (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{const {\bf Address} \&}]{dest, }
\item[{uint16\+\_\+t}]{protocol\+Number}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1VirtualNetDevice_acfd15730e0e77206f8c6ebcf1479eaf9}{}\label{classns3_1_1VirtualNetDevice_acfd15730e0e77206f8c6ebcf1479eaf9}

\begin{DoxyParams}{Parameters}
{\em packet} & packet sent from above down to Network Device \\
\hline
{\em dest} & mac address of the destination (already resolved) \\
\hline
{\em protocol\+Number} & identifies the type of payload contained in this packet. Used to call the right L3\+Protocol when the packet is received.\\
\hline
\end{DoxyParams}
Called from higher layer to send packet into Network Device to the specified destination \hyperlink{classns3_1_1Address}{Address}

\begin{DoxyReturn}{Returns}
whether the Send operation succeeded 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a59f41afb0fe8951bb94d5739cbe6ee7d}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
255 \{
256   \hyperlink{classns3_1_1VirtualNetDevice_af893adb92d8bef8af0b47a3a798a2003}{m\_macTxTrace} (packet);
257   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1VirtualNetDevice_af7be2e7f02d269b54b88a9e396a3fcc4}{m\_sendCb} (packet, \hyperlink{classns3_1_1VirtualNetDevice_a8c8219e4244461ea705b3829a599931c}{GetAddress} (), dest, protocolNumber))
258     \{
259       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
260     \}
261   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
262 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8


\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Send\+From@{Send\+From}}
\index{Send\+From@{Send\+From}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Send\+From(\+Ptr$<$ Packet $>$ packet, const Address \&source, const Address \&dest, uint16\+\_\+t protocol\+Number)}{SendFrom(Ptr< Packet > packet, const Address &source, const Address &dest, uint16_t protocolNumber)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Virtual\+Net\+Device\+::\+Send\+From (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{const {\bf Address} \&}]{source, }
\item[{const {\bf Address} \&}]{dest, }
\item[{uint16\+\_\+t}]{protocol\+Number}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1VirtualNetDevice_a7d6da9fb890983644bd02bbc792709d2}{}\label{classns3_1_1VirtualNetDevice_a7d6da9fb890983644bd02bbc792709d2}

\begin{DoxyParams}{Parameters}
{\em packet} & packet sent from above down to Network Device \\
\hline
{\em source} & source mac address (so called \char`\"{}\+M\+A\+C spoofing\char`\"{}) \\
\hline
{\em dest} & mac address of the destination (already resolved) \\
\hline
{\em protocol\+Number} & identifies the type of payload contained in this packet. Used to call the right L3\+Protocol when the packet is received.\\
\hline
\end{DoxyParams}
Called from higher layer to send packet into Network Device with the specified source and destination Addresses.

\begin{DoxyReturn}{Returns}
whether the Send operation succeeded 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a19d55a4746c1ae584bf7da69959a885b}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
266 \{
267   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1VirtualNetDevice_aac37389af138f3fae76a3219f9e69869}{m\_supportsSendFrom});
268   \hyperlink{classns3_1_1VirtualNetDevice_af893adb92d8bef8af0b47a3a798a2003}{m\_macTxTrace} (packet);
269   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1VirtualNetDevice_af7be2e7f02d269b54b88a9e396a3fcc4}{m\_sendCb} (packet, source, dest, protocolNumber))
270     \{
271       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
272     \}
273   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
274 \}
\end{DoxyCode}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Set\+Address@{Set\+Address}}
\index{Set\+Address@{Set\+Address}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Address(\+Address address)}{SetAddress(Address address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Virtual\+Net\+Device\+::\+Set\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1VirtualNetDevice_a560887abe97f9327f2973d748aa382e9}{}\label{classns3_1_1VirtualNetDevice_a560887abe97f9327f2973d748aa382e9}
Set the address of this interface 
\begin{DoxyParams}{Parameters}
{\em address} & address to set \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1NetDevice_ab56dc36bc0547471ab3210eda60ee76c}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
197 \{
198   \hyperlink{classns3_1_1VirtualNetDevice_ac101b023db43fd70e2498a3b58b456d3}{m\_myAddress} = addr;
199 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 9


\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Set\+If\+Index@{Set\+If\+Index}}
\index{Set\+If\+Index@{Set\+If\+Index}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+If\+Index(const uint32\+\_\+t index)}{SetIfIndex(const uint32_t index)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Virtual\+Net\+Device\+::\+Set\+If\+Index (
\begin{DoxyParamCaption}
\item[{const uint32\+\_\+t}]{index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1VirtualNetDevice_a625c4b50d530dc677b2dbee19f06de56}{}\label{classns3_1_1VirtualNetDevice_a625c4b50d530dc677b2dbee19f06de56}

\begin{DoxyParams}{Parameters}
{\em index} & if\+Index of the device \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1NetDevice_a2e1ac6c1189cd565420305d85a193fb8}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
173 \{
174   \hyperlink{classns3_1_1VirtualNetDevice_a2f1e2e67cf29cc3fd446e2d9c410e9fc}{m\_index} = index;
175 \}
\end{DoxyCode}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Set\+Is\+Point\+To\+Point@{Set\+Is\+Point\+To\+Point}}
\index{Set\+Is\+Point\+To\+Point@{Set\+Is\+Point\+To\+Point}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Is\+Point\+To\+Point(bool is\+Point\+To\+Point)}{SetIsPointToPoint(bool isPointToPoint)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Virtual\+Net\+Device\+::\+Set\+Is\+Point\+To\+Point (
\begin{DoxyParamCaption}
\item[{bool}]{is\+Point\+To\+Point}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1VirtualNetDevice_aaf6525f4404af8404fe21a7a70d52be9}{}\label{classns3_1_1VirtualNetDevice_aaf6525f4404af8404fe21a7a70d52be9}


Configure whether the virtual device is point-\/to-\/point. 


\begin{DoxyParams}{Parameters}
{\em is\+Point\+To\+Point} & the value that should be returned by the Is\+Point\+To\+Point method for this instance. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
114 \{
115   \hyperlink{classns3_1_1VirtualNetDevice_af59a3ce1a68aa62f1bded3e131440cbc}{m\_isPointToPoint} = isPointToPoint;
116 \}
\end{DoxyCode}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Set\+Mtu@{Set\+Mtu}}
\index{Set\+Mtu@{Set\+Mtu}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Mtu(const uint16\+\_\+t mtu)}{SetMtu(const uint16_t mtu)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Virtual\+Net\+Device\+::\+Set\+Mtu (
\begin{DoxyParamCaption}
\item[{const uint16\+\_\+t}]{mtu}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1VirtualNetDevice_a3277a3167e1519924a3bcdf795314178}{}\label{classns3_1_1VirtualNetDevice_a3277a3167e1519924a3bcdf795314178}


Configure the reported M\+TU for the virtual device. 


\begin{DoxyParams}{Parameters}
{\em mtu} & M\+TU value to set \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether the M\+TU value was within legal bounds 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a2ba4956d45cde68eab3cbdd6ede06df0}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
120 \{
121   \hyperlink{classns3_1_1VirtualNetDevice_a3df667e5920ae7bde13ce2f30a4a2bbd}{m\_mtu} = mtu;
122   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
123 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 10


\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Set\+Needs\+Arp@{Set\+Needs\+Arp}}
\index{Set\+Needs\+Arp@{Set\+Needs\+Arp}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Needs\+Arp(bool needs\+Arp)}{SetNeedsArp(bool needsArp)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Virtual\+Net\+Device\+::\+Set\+Needs\+Arp (
\begin{DoxyParamCaption}
\item[{bool}]{needs\+Arp}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1VirtualNetDevice_a601faebbf94efb6a9dcd27f671198a81}{}\label{classns3_1_1VirtualNetDevice_a601faebbf94efb6a9dcd27f671198a81}


Configure whether the virtual device needs A\+RP. 


\begin{DoxyParams}{Parameters}
{\em needs\+Arp} & the the \textquotesingle{}needs arp\textquotesingle{} value that will be returned by the \hyperlink{classns3_1_1VirtualNetDevice_aee0cd69025468398482b7af188fcc34f}{Needs\+Arp()} method. The method \hyperlink{classns3_1_1VirtualNetDevice_a3fd0309cbcf76ef18412b1affaebeddf}{Is\+Broadcast()} will also return this value. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
102 \{
103   \hyperlink{classns3_1_1VirtualNetDevice_a6d5b194341bd76b5c99e4c01616fb788}{m\_needsArp} = needsArp;
104 \}
\end{DoxyCode}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Set\+Node@{Set\+Node}}
\index{Set\+Node@{Set\+Node}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Node(\+Ptr$<$ Node $>$ node)}{SetNode(Ptr< Node > node)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Virtual\+Net\+Device\+::\+Set\+Node (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1VirtualNetDevice_ae8a84665899b549ae465d715efd2fd43}{}\label{classns3_1_1VirtualNetDevice_ae8a84665899b549ae465d715efd2fd43}

\begin{DoxyParams}{Parameters}
{\em node} & the node associated to this netdevice.\\
\hline
\end{DoxyParams}
This method is called from \hyperlink{classns3_1_1Node_a42ff83ee1d5d1649c770d3f5b62375de}{ns3\+::\+Node\+::\+Add\+Device}. 

Implements \hyperlink{classns3_1_1NetDevice_a3ae520ae06e93b957f0f56f113319a08}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
284 \{
285   \hyperlink{classns3_1_1VirtualNetDevice_a152f05be787bb166a37830a919f2a975}{m\_node} = node;
286 \}
\end{DoxyCode}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Set\+Promisc\+Receive\+Callback@{Set\+Promisc\+Receive\+Callback}}
\index{Set\+Promisc\+Receive\+Callback@{Set\+Promisc\+Receive\+Callback}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Promisc\+Receive\+Callback(\+Net\+Device\+::\+Promisc\+Receive\+Callback cb)}{SetPromiscReceiveCallback(NetDevice::PromiscReceiveCallback cb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Virtual\+Net\+Device\+::\+Set\+Promisc\+Receive\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Net\+Device\+::\+Promisc\+Receive\+Callback}}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1VirtualNetDevice_a3b0544bacdb411a716515cda7e62c2f3}{}\label{classns3_1_1VirtualNetDevice_a3b0544bacdb411a716515cda7e62c2f3}

\begin{DoxyParams}{Parameters}
{\em cb} & callback to invoke whenever a packet has been received in promiscuous mode and must be forwarded to the higher layers.\\
\hline
\end{DoxyParams}
Enables netdevice promiscuous mode and sets the callback that will handle promiscuous mode packets. Note, promiscuous mode packets means {\itshape all} packets, including those packets that can be sensed by the netdevice but which are intended to be received by other hosts. 

Implements \hyperlink{classns3_1_1NetDevice_a3968946bdbb74d47d7b13612baad7d6d}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
302 \{
303   \hyperlink{classns3_1_1VirtualNetDevice_adaab3f043b0241d58ccdb9ba7ba7587e}{m\_promiscRxCallback} = cb;
304 \}
\end{DoxyCode}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Set\+Receive\+Callback@{Set\+Receive\+Callback}}
\index{Set\+Receive\+Callback@{Set\+Receive\+Callback}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Receive\+Callback(\+Net\+Device\+::\+Receive\+Callback cb)}{SetReceiveCallback(NetDevice::ReceiveCallback cb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Virtual\+Net\+Device\+::\+Set\+Receive\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Net\+Device\+::\+Receive\+Callback}}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1VirtualNetDevice_ace48567f181d0f096cd76a45e7ec22c8}{}\label{classns3_1_1VirtualNetDevice_ace48567f181d0f096cd76a45e7ec22c8}

\begin{DoxyParams}{Parameters}
{\em cb} & callback to invoke whenever a packet has been received and must be forwarded to the higher layers.\\
\hline
\end{DoxyParams}
Set the callback to be used to notify higher layers when a packet has been received. 

Implements \hyperlink{classns3_1_1NetDevice_ac63e4d5668e421fec4b5d37f32e7dd18}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
296 \{
297   \hyperlink{classns3_1_1VirtualNetDevice_adf4e9569cfa5ae6051c76cb4ddda1c14}{m\_rxCallback} = cb;
298 \}
\end{DoxyCode}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Set\+Send\+Callback@{Set\+Send\+Callback}}
\index{Set\+Send\+Callback@{Set\+Send\+Callback}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Send\+Callback(\+Send\+Callback transmit\+Cb)}{SetSendCallback(SendCallback transmitCb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Virtual\+Net\+Device\+::\+Set\+Send\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Send\+Callback}}]{transmit\+Cb}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1VirtualNetDevice_ae4e54639e40bf1c5d8d6ed7da9ababed}{}\label{classns3_1_1VirtualNetDevice_ae4e54639e40bf1c5d8d6ed7da9ababed}


Set the user callback to be called when a L2 packet is to be transmitted. 


\begin{DoxyParams}{Parameters}
{\em transmit\+Cb} & the new transmit callback \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
96 \{
97   \hyperlink{classns3_1_1VirtualNetDevice_af7be2e7f02d269b54b88a9e396a3fcc4}{m\_sendCb} = sendCb;
98 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Set\+Supports\+Send\+From@{Set\+Supports\+Send\+From}}
\index{Set\+Supports\+Send\+From@{Set\+Supports\+Send\+From}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Set\+Supports\+Send\+From(bool supports\+Send\+From)}{SetSupportsSendFrom(bool supportsSendFrom)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Virtual\+Net\+Device\+::\+Set\+Supports\+Send\+From (
\begin{DoxyParamCaption}
\item[{bool}]{supports\+Send\+From}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1VirtualNetDevice_a499659f98c264ba457bbff8b44cd49e7}{}\label{classns3_1_1VirtualNetDevice_a499659f98c264ba457bbff8b44cd49e7}


Configure whether the virtual device supports Send\+From. 


\begin{DoxyCode}
108 \{
109   \hyperlink{classns3_1_1VirtualNetDevice_aac37389af138f3fae76a3219f9e69869}{m\_supportsSendFrom} = supportsSendFrom;
110 \}
\end{DoxyCode}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!Supports\+Send\+From@{Supports\+Send\+From}}
\index{Supports\+Send\+From@{Supports\+Send\+From}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{Supports\+Send\+From() const }{SupportsSendFrom() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Virtual\+Net\+Device\+::\+Supports\+Send\+From (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1VirtualNetDevice_aa31fa2c5ff6423606d7b683dd4de467f}{}\label{classns3_1_1VirtualNetDevice_aa31fa2c5ff6423606d7b683dd4de467f}
\begin{DoxyReturn}{Returns}
true if this interface supports a bridging mode, false otherwise. 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1NetDevice_a04793d220b54c40e110ebf86dae5b25c}{ns3\+::\+Net\+Device}.


\begin{DoxyCode}
308 \{
309   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1VirtualNetDevice_aac37389af138f3fae76a3219f9e69869}{m\_supportsSendFrom};
310 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!m\+\_\+index@{m\+\_\+index}}
\index{m\+\_\+index@{m\+\_\+index}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+index}{m_index}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Virtual\+Net\+Device\+::m\+\_\+index\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1VirtualNetDevice_a2f1e2e67cf29cc3fd446e2d9c410e9fc}{}\label{classns3_1_1VirtualNetDevice_a2f1e2e67cf29cc3fd446e2d9c410e9fc}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!m\+\_\+is\+Point\+To\+Point@{m\+\_\+is\+Point\+To\+Point}}
\index{m\+\_\+is\+Point\+To\+Point@{m\+\_\+is\+Point\+To\+Point}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+is\+Point\+To\+Point}{m_isPointToPoint}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Virtual\+Net\+Device\+::m\+\_\+is\+Point\+To\+Point\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1VirtualNetDevice_af59a3ce1a68aa62f1bded3e131440cbc}{}\label{classns3_1_1VirtualNetDevice_af59a3ce1a68aa62f1bded3e131440cbc}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!m\+\_\+mac\+Promisc\+Rx\+Trace@{m\+\_\+mac\+Promisc\+Rx\+Trace}}
\index{m\+\_\+mac\+Promisc\+Rx\+Trace@{m\+\_\+mac\+Promisc\+Rx\+Trace}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+mac\+Promisc\+Rx\+Trace}{m_macPromiscRxTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Virtual\+Net\+Device\+::m\+\_\+mac\+Promisc\+Rx\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1VirtualNetDevice_a978beda53d5a1309d1fff0cbfb3137b6}{}\label{classns3_1_1VirtualNetDevice_a978beda53d5a1309d1fff0cbfb3137b6}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!m\+\_\+mac\+Rx\+Trace@{m\+\_\+mac\+Rx\+Trace}}
\index{m\+\_\+mac\+Rx\+Trace@{m\+\_\+mac\+Rx\+Trace}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+mac\+Rx\+Trace}{m_macRxTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Virtual\+Net\+Device\+::m\+\_\+mac\+Rx\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1VirtualNetDevice_a434af9b19b144c539ab06deec0ac5125}{}\label{classns3_1_1VirtualNetDevice_a434af9b19b144c539ab06deec0ac5125}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!m\+\_\+mac\+Tx\+Trace@{m\+\_\+mac\+Tx\+Trace}}
\index{m\+\_\+mac\+Tx\+Trace@{m\+\_\+mac\+Tx\+Trace}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+mac\+Tx\+Trace}{m_macTxTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Virtual\+Net\+Device\+::m\+\_\+mac\+Tx\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1VirtualNetDevice_af893adb92d8bef8af0b47a3a798a2003}{}\label{classns3_1_1VirtualNetDevice_af893adb92d8bef8af0b47a3a798a2003}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!m\+\_\+mtu@{m\+\_\+mtu}}
\index{m\+\_\+mtu@{m\+\_\+mtu}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+mtu}{m_mtu}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Virtual\+Net\+Device\+::m\+\_\+mtu\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1VirtualNetDevice_a3df667e5920ae7bde13ce2f30a4a2bbd}{}\label{classns3_1_1VirtualNetDevice_a3df667e5920ae7bde13ce2f30a4a2bbd}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!m\+\_\+my\+Address@{m\+\_\+my\+Address}}
\index{m\+\_\+my\+Address@{m\+\_\+my\+Address}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+my\+Address}{m_myAddress}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ns3\+::\+Virtual\+Net\+Device\+::m\+\_\+my\+Address\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1VirtualNetDevice_ac101b023db43fd70e2498a3b58b456d3}{}\label{classns3_1_1VirtualNetDevice_ac101b023db43fd70e2498a3b58b456d3}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!m\+\_\+name@{m\+\_\+name}}
\index{m\+\_\+name@{m\+\_\+name}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+name}{m_name}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string ns3\+::\+Virtual\+Net\+Device\+::m\+\_\+name\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1VirtualNetDevice_adb3560f38c365a7fda84caf403c4326c}{}\label{classns3_1_1VirtualNetDevice_adb3560f38c365a7fda84caf403c4326c}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!m\+\_\+needs\+Arp@{m\+\_\+needs\+Arp}}
\index{m\+\_\+needs\+Arp@{m\+\_\+needs\+Arp}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+needs\+Arp}{m_needsArp}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Virtual\+Net\+Device\+::m\+\_\+needs\+Arp\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1VirtualNetDevice_a6d5b194341bd76b5c99e4c01616fb788}{}\label{classns3_1_1VirtualNetDevice_a6d5b194341bd76b5c99e4c01616fb788}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!m\+\_\+node@{m\+\_\+node}}
\index{m\+\_\+node@{m\+\_\+node}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+node}{m_node}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Node}$>$ ns3\+::\+Virtual\+Net\+Device\+::m\+\_\+node\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1VirtualNetDevice_a152f05be787bb166a37830a919f2a975}{}\label{classns3_1_1VirtualNetDevice_a152f05be787bb166a37830a919f2a975}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!m\+\_\+promisc\+Rx\+Callback@{m\+\_\+promisc\+Rx\+Callback}}
\index{m\+\_\+promisc\+Rx\+Callback@{m\+\_\+promisc\+Rx\+Callback}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+promisc\+Rx\+Callback}{m_promiscRxCallback}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Promisc\+Receive\+Callback} ns3\+::\+Virtual\+Net\+Device\+::m\+\_\+promisc\+Rx\+Callback\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1VirtualNetDevice_adaab3f043b0241d58ccdb9ba7ba7587e}{}\label{classns3_1_1VirtualNetDevice_adaab3f043b0241d58ccdb9ba7ba7587e}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!m\+\_\+promisc\+Sniffer\+Trace@{m\+\_\+promisc\+Sniffer\+Trace}}
\index{m\+\_\+promisc\+Sniffer\+Trace@{m\+\_\+promisc\+Sniffer\+Trace}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+promisc\+Sniffer\+Trace}{m_promiscSnifferTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Virtual\+Net\+Device\+::m\+\_\+promisc\+Sniffer\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1VirtualNetDevice_a18f48204e84161b3e3472ee0af08bbfe}{}\label{classns3_1_1VirtualNetDevice_a18f48204e84161b3e3472ee0af08bbfe}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!m\+\_\+rx\+Callback@{m\+\_\+rx\+Callback}}
\index{m\+\_\+rx\+Callback@{m\+\_\+rx\+Callback}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+rx\+Callback}{m_rxCallback}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Receive\+Callback} ns3\+::\+Virtual\+Net\+Device\+::m\+\_\+rx\+Callback\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1VirtualNetDevice_adf4e9569cfa5ae6051c76cb4ddda1c14}{}\label{classns3_1_1VirtualNetDevice_adf4e9569cfa5ae6051c76cb4ddda1c14}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!m\+\_\+send\+Cb@{m\+\_\+send\+Cb}}
\index{m\+\_\+send\+Cb@{m\+\_\+send\+Cb}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+send\+Cb}{m_sendCb}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Send\+Callback} ns3\+::\+Virtual\+Net\+Device\+::m\+\_\+send\+Cb\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1VirtualNetDevice_af7be2e7f02d269b54b88a9e396a3fcc4}{}\label{classns3_1_1VirtualNetDevice_af7be2e7f02d269b54b88a9e396a3fcc4}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!m\+\_\+sniffer\+Trace@{m\+\_\+sniffer\+Trace}}
\index{m\+\_\+sniffer\+Trace@{m\+\_\+sniffer\+Trace}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+sniffer\+Trace}{m_snifferTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Virtual\+Net\+Device\+::m\+\_\+sniffer\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1VirtualNetDevice_a590ab436f1261e3e1e52128678026023}{}\label{classns3_1_1VirtualNetDevice_a590ab436f1261e3e1e52128678026023}
\index{ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}!m\+\_\+supports\+Send\+From@{m\+\_\+supports\+Send\+From}}
\index{m\+\_\+supports\+Send\+From@{m\+\_\+supports\+Send\+From}!ns3\+::\+Virtual\+Net\+Device@{ns3\+::\+Virtual\+Net\+Device}}
\subsubsection[{\texorpdfstring{m\+\_\+supports\+Send\+From}{m_supportsSendFrom}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Virtual\+Net\+Device\+::m\+\_\+supports\+Send\+From\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1VirtualNetDevice_aac37389af138f3fae76a3219f9e69869}{}\label{classns3_1_1VirtualNetDevice_aac37389af138f3fae76a3219f9e69869}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
virtual-\/net-\/device/model/\hyperlink{virtual-net-device_8h}{virtual-\/net-\/device.\+h}\item 
virtual-\/net-\/device/model/\hyperlink{model_2virtual-net-device_8cc}{virtual-\/net-\/device.\+cc}\end{DoxyCompactItemize}
