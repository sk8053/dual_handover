\hypertarget{classns3_1_1InternetStackHelper}{}\section{ns3\+:\+:Internet\+Stack\+Helper Class Reference}
\label{classns3_1_1InternetStackHelper}\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}


aggregate I\+P/\+T\+C\+P/\+U\+DP functionality to existing Nodes.  




{\ttfamily \#include $<$internet-\/stack-\/helper.\+h$>$}



Inheritance diagram for ns3\+:\+:Internet\+Stack\+Helper\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Internet\+Stack\+Helper\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1InternetStackHelper_aabbcc90f3210ac2a636ba6bb814044a6}{Internet\+Stack\+Helper} (void)
\item 
virtual \hyperlink{classns3_1_1InternetStackHelper_ad61c4845f886b09233ddab021873d303}{$\sim$\+Internet\+Stack\+Helper} (void)
\item 
\hyperlink{classns3_1_1InternetStackHelper_a97777d2bdd2c8616cee38a2808231aab}{Internet\+Stack\+Helper} (const \hyperlink{classns3_1_1InternetStackHelper}{Internet\+Stack\+Helper} \&o)
\begin{DoxyCompactList}\small\item\em Copy constructor. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1InternetStackHelper}{Internet\+Stack\+Helper} \& \hyperlink{classns3_1_1InternetStackHelper_abcbbffe4bb2c8dcfb8ffc495c5ebaba9}{operator=} (const \hyperlink{classns3_1_1InternetStackHelper}{Internet\+Stack\+Helper} \&o)
\begin{DoxyCompactList}\small\item\em Copy constructor. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1InternetStackHelper_a2c9c2074c78e3914eb4760fb1e222d49}{Reset} (void)
\item 
void \hyperlink{classns3_1_1InternetStackHelper_a3e382c02df022dec79952a7eca8cd5ba}{Set\+Routing\+Helper} (const \hyperlink{classns3_1_1Ipv4RoutingHelper}{Ipv4\+Routing\+Helper} \&routing)
\item 
void \hyperlink{classns3_1_1InternetStackHelper_af3b2b9f74fdf4aa20317a8996564921a}{Set\+Routing\+Helper} (const \hyperlink{classns3_1_1Ipv6RoutingHelper}{Ipv6\+Routing\+Helper} \&routing)
\begin{DoxyCompactList}\small\item\em Set I\+Pv6 routing helper. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1InternetStackHelper_a6645b412f31283d2d9bc3d8a95cebbc0}{Install} (std\+::string node\+Name) const 
\item 
void \hyperlink{classns3_1_1InternetStackHelper_a14b0da37b1617255bf1078c11a108dce}{Install} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node) const 
\item 
void \hyperlink{classns3_1_1InternetStackHelper_a3575bfbaafc7b35b107d8ac8abad57b5}{Install} (\hyperlink{classns3_1_1NodeContainer}{Node\+Container} \hyperlink{mmwave_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c}) const 
\item 
void \hyperlink{classns3_1_1InternetStackHelper_a6cfa73782fd4071c4cfbd73ebf1bbb44}{Install\+All} (void) const 
\item 
void \hyperlink{classns3_1_1InternetStackHelper_ac76e9cf493ef559f311c4ef85945129f}{Set\+Tcp} (std\+::string tid)
\begin{DoxyCompactList}\small\item\em set the Tcp stack which will not need any other parameter. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1InternetStackHelper_a665afc046449275066145dcfa2f5790e}{Set\+Tcp} (std\+::string tid, std\+::string attr, const \hyperlink{classns3_1_1AttributeValue}{Attribute\+Value} \&val)
\begin{DoxyCompactList}\small\item\em This function is used to setup the Network Simulation Cradle stack with library value. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1InternetStackHelper_a10e2a35f410d0d1c90d979542c8bfd6e}{Set\+Ipv4\+Stack\+Install} (bool enable)
\begin{DoxyCompactList}\small\item\em Enable/disable I\+Pv4 stack install. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1InternetStackHelper_a5fa8d34e5834305b6aa1b0fe43e1132b}{Set\+Ipv6\+Stack\+Install} (bool enable)
\begin{DoxyCompactList}\small\item\em Enable/disable I\+Pv6 stack install. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1InternetStackHelper_a24eb534b7da530992ed34b9c620bcc8a}{Set\+Ipv4\+Arp\+Jitter} (bool enable)
\begin{DoxyCompactList}\small\item\em Enable/disable I\+Pv4 A\+RP Jitter. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1InternetStackHelper_a82214073afab2b64fe89ca60b8238e6b}{Set\+Ipv6\+Ns\+Rs\+Jitter} (bool enable)
\begin{DoxyCompactList}\small\item\em Enable/disable I\+Pv6 NS and RS Jitter. \end{DoxyCompactList}\item 
int64\+\_\+t \hyperlink{classns3_1_1InternetStackHelper_a63c904e832a2f17e036338db4aa2f1b8}{Assign\+Streams} (\hyperlink{classns3_1_1NodeContainer}{Node\+Container} \hyperlink{mmwave_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c}, int64\+\_\+t stream)
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1InternetStackHelper_aec9bacdd0e3902ad274270d914fdee23}{Enable\+Pcap\+Ipv4\+Internal} (std\+::string prefix, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$ ipv4, uint32\+\_\+t interface, bool explicit\+Filename)
\begin{DoxyCompactList}\small\item\em Enable pcap output the indicated \hyperlink{classns3_1_1Ipv4}{Ipv4} and interface pair. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1InternetStackHelper_ab09a45882051edfc4881fc751ccbdd48}{Enable\+Ascii\+Ipv4\+Internal} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream, std\+::string prefix, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$ ipv4, uint32\+\_\+t interface, bool explicit\+Filename)
\begin{DoxyCompactList}\small\item\em Enable ascii trace output on the indicated \hyperlink{classns3_1_1Ipv4}{Ipv4} and interface pair. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1InternetStackHelper_a2ddebb75d6e8ce2c2b1b6fb55016ec00}{Enable\+Pcap\+Ipv6\+Internal} (std\+::string prefix, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6}{Ipv6} $>$ ipv6, uint32\+\_\+t interface, bool explicit\+Filename)
\begin{DoxyCompactList}\small\item\em Enable pcap output the indicated \hyperlink{classns3_1_1Ipv6}{Ipv6} and interface pair. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1InternetStackHelper_a812b901ab8c2aff1f7feca6a9864b9c2}{Enable\+Ascii\+Ipv6\+Internal} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream, std\+::string prefix, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6}{Ipv6} $>$ ipv6, uint32\+\_\+t interface, bool explicit\+Filename)
\begin{DoxyCompactList}\small\item\em Enable ascii trace output on the indicated \hyperlink{classns3_1_1Ipv6}{Ipv6} and interface pair. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1InternetStackHelper_a51479cdc84af52b048ce586785643856}{Initialize} (void)
\begin{DoxyCompactList}\small\item\em Initialize the helper to its default values. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1InternetStackHelper_a884260b23b3df90bf09eeb403df4d988}{Pcap\+Hooked} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$ ipv4)
\begin{DoxyCompactList}\small\item\em checks if there is an hook to a Pcap wrapper \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1InternetStackHelper_a4b26d61d78933a884a03fbda4ec6eddc}{Ascii\+Hooked} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$ ipv4)
\begin{DoxyCompactList}\small\item\em checks if there is an hook to an ascii output stream \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1InternetStackHelper_a02016af4653dffbda1aa746d4a55b3b5}{Pcap\+Hooked} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6}{Ipv6} $>$ ipv6)
\begin{DoxyCompactList}\small\item\em checks if there is an hook to a Pcap wrapper \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1InternetStackHelper_ad5d996df2601304a011990ffd9c3c2e1}{Ascii\+Hooked} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6}{Ipv6} $>$ ipv6)
\begin{DoxyCompactList}\small\item\em checks if there is an hook to an ascii output stream \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Private Member Functions}
\begin{DoxyCompactItemize}
\item 
static void \hyperlink{classns3_1_1InternetStackHelper_a6605ba9c1bbfdf9ebe09c5dbcfce2451}{Create\+And\+Aggregate\+Object\+From\+Type\+Id} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node, const std\+::string type\+Id)
\begin{DoxyCompactList}\small\item\em create an object from its \hyperlink{classns3_1_1TypeId}{Type\+Id} and aggregates it to the node \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1ObjectFactory}{Object\+Factory} \hyperlink{classns3_1_1InternetStackHelper_a70733544910e58abfe1b238263ea5a68}{m\+\_\+tcp\+Factory}
\begin{DoxyCompactList}\small\item\em T\+CP objects factory. \end{DoxyCompactList}\item 
const \hyperlink{classns3_1_1Ipv4RoutingHelper}{Ipv4\+Routing\+Helper} $\ast$ \hyperlink{classns3_1_1InternetStackHelper_a575127688a08b5a2f3f8e07839ea9807}{m\+\_\+routing}
\begin{DoxyCompactList}\small\item\em I\+Pv4 routing helper. \end{DoxyCompactList}\item 
const \hyperlink{classns3_1_1Ipv6RoutingHelper}{Ipv6\+Routing\+Helper} $\ast$ \hyperlink{classns3_1_1InternetStackHelper_ab00253ad66b420c44ab0226d333c51dd}{m\+\_\+routingv6}
\begin{DoxyCompactList}\small\item\em I\+Pv6 routing helper. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1InternetStackHelper_a52b041bc6e084a821e6885c71d38df31}{m\+\_\+ipv4\+Enabled}
\begin{DoxyCompactList}\small\item\em I\+Pv4 install state (enabled/disabled) ? \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1InternetStackHelper_a2eade9878232a41166cd0638cab7c3bf}{m\+\_\+ipv6\+Enabled}
\begin{DoxyCompactList}\small\item\em I\+Pv6 install state (enabled/disabled) ? \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1InternetStackHelper_a9b4460c9d7b52d6ce2d390ffd1074bfa}{m\+\_\+ipv4\+Arp\+Jitter\+Enabled}
\begin{DoxyCompactList}\small\item\em I\+Pv4 A\+RP Jitter state (enabled/disabled) ? \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1InternetStackHelper_a465f1786b918e4b3b3640d958d6e3212}{m\+\_\+ipv6\+Ns\+Rs\+Jitter\+Enabled}
\begin{DoxyCompactList}\small\item\em I\+Pv6 I\+Pv6 NS and RS Jitter state (enabled/disabled) ? \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
aggregate I\+P/\+T\+C\+P/\+U\+DP functionality to existing Nodes. 

This helper enables pcap and ascii tracing of events in the internet stack associated with a node. This is substantially similar to the tracing that happens in device helpers, but the important difference is that, well, there is no device. This means that the creation of output file names will change, and also the user-\/visible methods will not reference devices and therefore the number of trace enable methods is reduced.

Normally we avoid multiple inheritance in ns-\/3, however, the classes Pcap\+User\+Helper\+For\+Ipv4 and Ascii\+Trace\+User\+Helper\+For\+Ipv4 are treated as \char`\"{}mixins\char`\"{}. A mixin is a self-\/contained class that encapsulates a general attribute or a set of functionality that may be of interest to many other classes.

This class aggregates instances of these objects, by default, to each node\+:
\begin{DoxyItemize}
\item \hyperlink{classns3_1_1ArpL3Protocol}{ns3\+::\+Arp\+L3\+Protocol}
\item \hyperlink{classns3_1_1Ipv4L3Protocol}{ns3\+::\+Ipv4\+L3\+Protocol}
\item \hyperlink{classns3_1_1Icmpv4L4Protocol}{ns3\+::\+Icmpv4\+L4\+Protocol}
\item \hyperlink{classns3_1_1Ipv6L3Protocol}{ns3\+::\+Ipv6\+L3\+Protocol}
\item \hyperlink{classns3_1_1Icmpv6L4Protocol}{ns3\+::\+Icmpv6\+L4\+Protocol}
\item \hyperlink{classns3_1_1UdpL4Protocol}{ns3\+::\+Udp\+L4\+Protocol}
\item \hyperlink{classns3_1_1TrafficControlLayer}{ns3\+::\+Traffic\+Control\+Layer}
\item a T\+CP based on the T\+CP factory provided
\item a \hyperlink{classns3_1_1PacketSocketFactory}{Packet\+Socket\+Factory}
\item \hyperlink{classns3_1_1Ipv4}{Ipv4} routing (a list routing object, a global routing object, and a static routing object)
\item \hyperlink{classns3_1_1Ipv6}{Ipv6} routing (a static routing object) 
\end{DoxyItemize}

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!Internet\+Stack\+Helper@{Internet\+Stack\+Helper}}
\index{Internet\+Stack\+Helper@{Internet\+Stack\+Helper}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{Internet\+Stack\+Helper(void)}{InternetStackHelper(void)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Internet\+Stack\+Helper\+::\+Internet\+Stack\+Helper (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1InternetStackHelper_aabbcc90f3210ac2a636ba6bb814044a6}{}\label{classns3_1_1InternetStackHelper_aabbcc90f3210ac2a636ba6bb814044a6}
Create a new \hyperlink{classns3_1_1InternetStackHelper}{Internet\+Stack\+Helper} which uses a mix of static routing and global routing by default. The static routing protocol (\hyperlink{classns3_1_1Ipv4StaticRouting}{ns3\+::\+Ipv4\+Static\+Routing}) and the global routing protocol are stored in an \hyperlink{classns3_1_1Ipv4ListRouting}{ns3\+::\+Ipv4\+List\+Routing} protocol with priorities 0, and -\/10 by default. If you wish to use different priorites and different routing protocols, you need to use an adhoc \hyperlink{classns3_1_1Ipv4RoutingHelper}{ns3\+::\+Ipv4\+Routing\+Helper}, such as \hyperlink{classns3_1_1OlsrHelper}{ns3\+::\+Olsr\+Helper} 
\begin{DoxyCode}
105   : \hyperlink{classns3_1_1InternetStackHelper_a575127688a08b5a2f3f8e07839ea9807}{m\_routing} (0),
106     \hyperlink{classns3_1_1InternetStackHelper_ab00253ad66b420c44ab0226d333c51dd}{m\_routingv6} (0),
107     \hyperlink{classns3_1_1InternetStackHelper_a52b041bc6e084a821e6885c71d38df31}{m\_ipv4Enabled} (\textcolor{keyword}{true}),
108     \hyperlink{classns3_1_1InternetStackHelper_a2eade9878232a41166cd0638cab7c3bf}{m\_ipv6Enabled} (\textcolor{keyword}{true}),
109     \hyperlink{classns3_1_1InternetStackHelper_a9b4460c9d7b52d6ce2d390ffd1074bfa}{m\_ipv4ArpJitterEnabled} (\textcolor{keyword}{true}),
110     \hyperlink{classns3_1_1InternetStackHelper_a465f1786b918e4b3b3640d958d6e3212}{m\_ipv6NsRsJitterEnabled} (\textcolor{keyword}{true})
111 
112 \{
113   \hyperlink{classns3_1_1InternetStackHelper_a51479cdc84af52b048ce586785643856}{Initialize} ();
114 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!````~Internet\+Stack\+Helper@{$\sim$\+Internet\+Stack\+Helper}}
\index{````~Internet\+Stack\+Helper@{$\sim$\+Internet\+Stack\+Helper}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{$\sim$\+Internet\+Stack\+Helper(void)}{~InternetStackHelper(void)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Internet\+Stack\+Helper\+::$\sim$\+Internet\+Stack\+Helper (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1InternetStackHelper_ad61c4845f886b09233ddab021873d303}{}\label{classns3_1_1InternetStackHelper_ad61c4845f886b09233ddab021873d303}
Destroy the \hyperlink{classns3_1_1InternetStackHelper}{Internet\+Stack\+Helper} 
\begin{DoxyCode}
132 \{
133   \textcolor{keyword}{delete} \hyperlink{classns3_1_1InternetStackHelper_a575127688a08b5a2f3f8e07839ea9807}{m\_routing};
134   \textcolor{keyword}{delete} \hyperlink{classns3_1_1InternetStackHelper_ab00253ad66b420c44ab0226d333c51dd}{m\_routingv6};
135 \}
\end{DoxyCode}
\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!Internet\+Stack\+Helper@{Internet\+Stack\+Helper}}
\index{Internet\+Stack\+Helper@{Internet\+Stack\+Helper}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{Internet\+Stack\+Helper(const Internet\+Stack\+Helper \&o)}{InternetStackHelper(const InternetStackHelper &o)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Internet\+Stack\+Helper\+::\+Internet\+Stack\+Helper (
\begin{DoxyParamCaption}
\item[{const {\bf Internet\+Stack\+Helper} \&}]{o}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1InternetStackHelper_a97777d2bdd2c8616cee38a2808231aab}{}\label{classns3_1_1InternetStackHelper_a97777d2bdd2c8616cee38a2808231aab}


Copy constructor. 


\begin{DoxyParams}{Parameters}
{\em o} & \hyperlink{classns3_1_1Object}{Object} to copy from. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
138 \{
139   \hyperlink{classns3_1_1InternetStackHelper_a575127688a08b5a2f3f8e07839ea9807}{m\_routing} = o.m\_routing->\hyperlink{classns3_1_1Ipv4RoutingHelper_acf569a0ecf95d5b5186456f368eaa465}{Copy} ();
140   \hyperlink{classns3_1_1InternetStackHelper_ab00253ad66b420c44ab0226d333c51dd}{m\_routingv6} = o.m\_routingv6->\hyperlink{classns3_1_1Ipv6RoutingHelper_a324f924df9565843a0964e844e35927c}{Copy} ();
141   \hyperlink{classns3_1_1InternetStackHelper_a52b041bc6e084a821e6885c71d38df31}{m\_ipv4Enabled} = o.m\_ipv4Enabled;
142   \hyperlink{classns3_1_1InternetStackHelper_a2eade9878232a41166cd0638cab7c3bf}{m\_ipv6Enabled} = o.m\_ipv6Enabled;
143   \hyperlink{classns3_1_1InternetStackHelper_a70733544910e58abfe1b238263ea5a68}{m\_tcpFactory} = o.m\_tcpFactory;
144   \hyperlink{classns3_1_1InternetStackHelper_a9b4460c9d7b52d6ce2d390ffd1074bfa}{m\_ipv4ArpJitterEnabled} = o.m\_ipv4ArpJitterEnabled;
145   \hyperlink{classns3_1_1InternetStackHelper_a465f1786b918e4b3b3640d958d6e3212}{m\_ipv6NsRsJitterEnabled} = o.m\_ipv6NsRsJitterEnabled;
146 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3




\subsection{Member Function Documentation}
\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!Ascii\+Hooked@{Ascii\+Hooked}}
\index{Ascii\+Hooked@{Ascii\+Hooked}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{Ascii\+Hooked(\+Ptr$<$ Ipv4 $>$ ipv4)}{AsciiHooked(Ptr< Ipv4 > ipv4)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Internet\+Stack\+Helper\+::\+Ascii\+Hooked (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv4} $>$}]{ipv4}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1InternetStackHelper_a4b26d61d78933a884a03fbda4ec6eddc}{}\label{classns3_1_1InternetStackHelper_a4b26d61d78933a884a03fbda4ec6eddc}


checks if there is an hook to an ascii output stream 


\begin{DoxyParams}{Parameters}
{\em ipv4} & pointer to the I\+Pv4 object \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if a hook is found 
\end{DoxyReturn}

\begin{DoxyCode}
750 \{
751   \textcolor{keywordflow}{for} (  InterfaceStreamMapIpv4::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{namespacens3_ad7720e08dcb21331d85c00128abc175a}{g\_interfaceStreamMapIpv4}.begin
       (); 
752          \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{namespacens3_ad7720e08dcb21331d85c00128abc175a}{g\_interfaceStreamMapIpv4}.end (); 
753          ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
754     \{
755       \textcolor{keywordflow}{if} ((*i).first.first == ipv4)
756         \{
757           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
758         \}
759     \}
760   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
761 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!Ascii\+Hooked@{Ascii\+Hooked}}
\index{Ascii\+Hooked@{Ascii\+Hooked}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{Ascii\+Hooked(\+Ptr$<$ Ipv6 $>$ ipv6)}{AsciiHooked(Ptr< Ipv6 > ipv6)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Internet\+Stack\+Helper\+::\+Ascii\+Hooked (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv6} $>$}]{ipv6}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1InternetStackHelper_ad5d996df2601304a011990ffd9c3c2e1}{}\label{classns3_1_1InternetStackHelper_ad5d996df2601304a011990ffd9c3c2e1}


checks if there is an hook to an ascii output stream 


\begin{DoxyParams}{Parameters}
{\em ipv6} & pointer to the I\+Pv6 object \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if a hook is found 
\end{DoxyReturn}

\begin{DoxyCode}
1088 \{
1089   \textcolor{keywordflow}{for} (  InterfaceStreamMapIpv6::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{namespacens3_a7148863f60ffa7dcfbb51441f0a623fd}{g\_interfaceStreamMapIpv6}.begin
       (); 
1090          \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{namespacens3_a7148863f60ffa7dcfbb51441f0a623fd}{g\_interfaceStreamMapIpv6}.end (); 
1091          ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
1092     \{
1093       \textcolor{keywordflow}{if} ((*i).first.first == ipv6)
1094         \{
1095           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1096         \}
1097     \}
1098   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1099 \}
\end{DoxyCode}
\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!Assign\+Streams@{Assign\+Streams}}
\index{Assign\+Streams@{Assign\+Streams}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{Assign\+Streams(\+Node\+Container c, int64\+\_\+t stream)}{AssignStreams(NodeContainer c, int64_t stream)}}]{\setlength{\rightskip}{0pt plus 5cm}int64\+\_\+t ns3\+::\+Internet\+Stack\+Helper\+::\+Assign\+Streams (
\begin{DoxyParamCaption}
\item[{{\bf Node\+Container}}]{c, }
\item[{int64\+\_\+t}]{stream}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1InternetStackHelper_a63c904e832a2f17e036338db4aa2f1b8}{}\label{classns3_1_1InternetStackHelper_a63c904e832a2f17e036338db4aa2f1b8}
Assign a fixed random variable stream number to the random variables used by this model. Return the number of streams (possibly zero) that have been assigned. The \hyperlink{classns3_1_1InternetStackHelper_a6645b412f31283d2d9bc3d8a95cebbc0}{Install()} method should have previously been called by the user.


\begin{DoxyParams}{Parameters}
{\em stream} & first stream index to use \\
\hline
{\em c} & \hyperlink{classns3_1_1NodeContainer}{Node\+Container} of the set of nodes for which the internet models should be modified to use a fixed stream \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of stream indices assigned by this helper 
\end{DoxyReturn}

\begin{DoxyCode}
211 \{
212   int64\_t currentStream = stream;
213   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1NodeContainer_aa1a9f2d2b09bfef7d066d3974bca2cc4}{NodeContainer::Iterator} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c}.Begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c}.End (); ++
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
214     \{
215       Ptr<Node> node = *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
216       Ptr<GlobalRouter> router = node->GetObject<GlobalRouter> ();
217       \textcolor{keywordflow}{if} (router != 0)
218         \{
219           Ptr<Ipv4GlobalRouting> gr = router->GetRoutingProtocol ();
220           \textcolor{keywordflow}{if} (gr != 0)
221             \{
222               currentStream += gr->AssignStreams (currentStream);
223             \}
224         \}
225       Ptr<Ipv6ExtensionDemux> demux = node->GetObject<Ipv6ExtensionDemux> ();
226       \textcolor{keywordflow}{if} (demux != 0)
227         \{
228           Ptr<Ipv6Extension> fe = demux->GetExtension (
      \hyperlink{classns3_1_1Ipv6ExtensionFragment_ae87f2248d10cdb25e8e082fa74049425}{Ipv6ExtensionFragment::EXT\_NUMBER});
229           \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (fe);  \textcolor{comment}{// should always exist in the demux}
230           currentStream += fe->AssignStreams (currentStream);
231         \}
232       Ptr<Ipv4> ipv4 = node->GetObject<Ipv4> ();
233       \textcolor{keywordflow}{if} (ipv4 != 0)
234         \{
235           Ptr<ArpL3Protocol> arpL3Protocol = ipv4->GetObject<ArpL3Protocol> ();
236           \textcolor{keywordflow}{if} (arpL3Protocol != 0)
237             \{
238               currentStream += arpL3Protocol->AssignStreams (currentStream);
239             \}
240         \}
241       Ptr<Ipv6> ipv6 = node->GetObject<Ipv6> ();
242       \textcolor{keywordflow}{if} (ipv6 != 0)
243         \{
244           Ptr<Icmpv6L4Protocol> icmpv6L4Protocol = ipv6->GetObject<Icmpv6L4Protocol> ();
245           \textcolor{keywordflow}{if} (icmpv6L4Protocol != 0)
246             \{
247               currentStream += icmpv6L4Protocol->AssignStreams (currentStream);
248             \}
249         \}
250     \}
251   \textcolor{keywordflow}{return} (currentStream - stream);
252 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5




Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!Create\+And\+Aggregate\+Object\+From\+Type\+Id@{Create\+And\+Aggregate\+Object\+From\+Type\+Id}}
\index{Create\+And\+Aggregate\+Object\+From\+Type\+Id@{Create\+And\+Aggregate\+Object\+From\+Type\+Id}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{Create\+And\+Aggregate\+Object\+From\+Type\+Id(\+Ptr$<$ Node $>$ node, const std\+::string type\+Id)}{CreateAndAggregateObjectFromTypeId(Ptr< Node > node, const std::string typeId)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Internet\+Stack\+Helper\+::\+Create\+And\+Aggregate\+Object\+From\+Type\+Id (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node, }
\item[{const std\+::string}]{type\+Id}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\hypertarget{classns3_1_1InternetStackHelper_a6605ba9c1bbfdf9ebe09c5dbcfce2451}{}\label{classns3_1_1InternetStackHelper_a6605ba9c1bbfdf9ebe09c5dbcfce2451}


create an object from its \hyperlink{classns3_1_1TypeId}{Type\+Id} and aggregates it to the node 


\begin{DoxyParams}{Parameters}
{\em node} & the node \\
\hline
{\em type\+Id} & the object \hyperlink{classns3_1_1TypeId}{Type\+Id} \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
284 \{
285   ObjectFactory factory;
286   factory.SetTypeId (typeId);
287   Ptr<Object> protocol = factory.Create <Object> ();
288   node->\hyperlink{classns3_1_1Object_a79dd435d300f3deca814553f561a2922}{AggregateObject} (protocol);
289 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7




Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!Enable\+Ascii\+Ipv4\+Internal@{Enable\+Ascii\+Ipv4\+Internal}}
\index{Enable\+Ascii\+Ipv4\+Internal@{Enable\+Ascii\+Ipv4\+Internal}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{Enable\+Ascii\+Ipv4\+Internal(\+Ptr$<$ Output\+Stream\+Wrapper $>$ stream, std\+::string prefix, Ptr$<$ Ipv4 $>$ ipv4, uint32\+\_\+t interface, bool explicit\+Filename)}{EnableAsciiIpv4Internal(Ptr< OutputStreamWrapper > stream, std::string prefix, Ptr< Ipv4 > ipv4, uint32_t interface, bool explicitFilename)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Internet\+Stack\+Helper\+::\+Enable\+Ascii\+Ipv4\+Internal (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream, }
\item[{std\+::string}]{prefix, }
\item[{{\bf Ptr}$<$ {\bf Ipv4} $>$}]{ipv4, }
\item[{uint32\+\_\+t}]{interface, }
\item[{bool}]{explicit\+Filename}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1InternetStackHelper_ab09a45882051edfc4881fc751ccbdd48}{}\label{classns3_1_1InternetStackHelper_ab09a45882051edfc4881fc751ccbdd48}


Enable ascii trace output on the indicated \hyperlink{classns3_1_1Ipv4}{Ipv4} and interface pair. 


\begin{DoxyParams}{Parameters}
{\em stream} & An \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} representing an existing file to use when writing trace data. \\
\hline
{\em prefix} & Filename prefix to use for ascii trace files. \\
\hline
{\em ipv4} & \hyperlink{classns3_1_1Ptr}{Ptr} to the \hyperlink{classns3_1_1Ipv4}{Ipv4} interface on which you want to enable tracing. \\
\hline
{\em interface} & Interface ID on the \hyperlink{classns3_1_1Ipv4}{Ipv4} on which you want to enable tracing. \\
\hline
{\em explicit\+Filename} & Treat the prefix as an explicit filename if true \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1AsciiTraceHelperForIpv4_afe9e8a865d66140f0b2b42b5381b437d}{ns3\+::\+Ascii\+Trace\+Helper\+For\+Ipv4}.


\begin{DoxyCode}
770 \{
771   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1InternetStackHelper_a52b041bc6e084a821e6885c71d38df31}{m\_ipv4Enabled})
772     \{
773       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Call to enable Ipv4 ascii tracing but Ipv4 not enabled"});
774       \textcolor{keywordflow}{return};
775     \}
776 
777   \textcolor{comment}{//}
778   \textcolor{comment}{// Our trace sinks are going to use packet printing, so we have to }
779   \textcolor{comment}{// make sure that is turned on.}
780   \textcolor{comment}{//}
781   \hyperlink{classns3_1_1Packet_ae17c0cd8e63e83df3c9273801e3d5d7f}{Packet::EnablePrinting} ();
782 
783   \textcolor{comment}{//}
784   \textcolor{comment}{// If we are not provided an OutputStreamWrapper, we are expected to create }
785   \textcolor{comment}{// one using the usual trace filename conventions and hook WithoutContext}
786   \textcolor{comment}{// since there will be one file per context and therefore the context would}
787   \textcolor{comment}{// be redundant.}
788   \textcolor{comment}{//}
789   \textcolor{keywordflow}{if} (stream == 0)
790     \{
791       \textcolor{comment}{//}
792       \textcolor{comment}{// Set up an output stream object to deal with private ofstream copy }
793       \textcolor{comment}{// constructor and lifetime issues.  Let the helper decide the actual}
794       \textcolor{comment}{// name of the file given the prefix.}
795       \textcolor{comment}{//}
796       \textcolor{comment}{// We have to create a stream and a mapping from protocol/interface to }
797       \textcolor{comment}{// stream irrespective of how many times we want to trace a particular }
798       \textcolor{comment}{// protocol.}
799       \textcolor{comment}{//}
800       AsciiTraceHelper asciiTraceHelper;
801 
802       std::string filename;
803       \textcolor{keywordflow}{if} (explicitFilename)
804         \{
805           filename = prefix;
806         \}
807       \textcolor{keywordflow}{else}
808         \{
809           filename = asciiTraceHelper.GetFilenameFromInterfacePair (prefix, ipv4, interface);
810         \}
811 
812       Ptr<OutputStreamWrapper> theStream = asciiTraceHelper.CreateFileStream (filename);
813 
814       \textcolor{comment}{//}
815       \textcolor{comment}{// However, we only hook the trace sources once to avoid multiple trace sink}
816       \textcolor{comment}{// calls per event (connect is independent of interface).}
817       \textcolor{comment}{//}
818       \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1InternetStackHelper_a4b26d61d78933a884a03fbda4ec6eddc}{AsciiHooked} (ipv4))
819         \{
820           \textcolor{comment}{//}
821           \textcolor{comment}{// We can use the default drop sink for the ArpL3Protocol since it has}
822           \textcolor{comment}{// the usual signature.  We can get to the Ptr<ArpL3Protocol> through}
823           \textcolor{comment}{// our Ptr<Ipv4> since they must both be aggregated to the same node.}
824           \textcolor{comment}{//}
825           Ptr<ArpL3Protocol> arpL3Protocol = ipv4->GetObject<ArpL3Protocol> ();
826           asciiTraceHelper.HookDefaultDropSinkWithoutContext<ArpL3Protocol> (arpL3Protocol, \textcolor{stringliteral}{"Drop"}, 
      theStream);
827 
828           \textcolor{comment}{//}
829           \textcolor{comment}{// The drop sink for the Ipv4L3Protocol uses a different signature than}
830           \textcolor{comment}{// the default sink, so we have to cook one up for ourselves.  We can get}
831           \textcolor{comment}{// to the Ptr<Ipv4L3Protocol> through our Ptr<Ipv4> since they must both }
832           \textcolor{comment}{// be aggregated to the same node.}
833           \textcolor{comment}{//}
834           Ptr<Ipv4L3Protocol> ipv4L3Protocol = ipv4->GetObject<Ipv4L3Protocol> ();
835           \textcolor{keywordtype}{bool} result = ipv4L3Protocol->TraceConnectWithoutContext (\textcolor{stringliteral}{"Drop"},
836                                                                     
      \hyperlink{group__makeboundcallback_ga1725d6362e6065faa0709f7c93f8d770}{MakeBoundCallback} (&\hyperlink{namespacens3_aa6faccffe4e7ec3e0a1f5ea80ed7f81d}{Ipv4L3ProtocolDropSinkWithoutContext}
      , theStream));
837           \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (result == \textcolor{keyword}{true}, \textcolor{stringliteral}{"InternetStackHelper::EnableAsciiIpv4Internal():  "}
838                          \textcolor{stringliteral}{"Unable to connect ipv4L3Protocol \(\backslash\)"Drop\(\backslash\)""});
839           result = ipv4L3Protocol->TraceConnectWithoutContext (\textcolor{stringliteral}{"Tx"}, 
840                                                                \hyperlink{group__makeboundcallback_ga1725d6362e6065faa0709f7c93f8d770}{MakeBoundCallback} (&
      \hyperlink{namespacens3_ae08dabf17f5254377bcce237263a3c4d}{Ipv4L3ProtocolTxSinkWithoutContext}, theStream));
841           \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (result == \textcolor{keyword}{true}, \textcolor{stringliteral}{"InternetStackHelper::EnableAsciiIpv4Internal():  "}
842                          \textcolor{stringliteral}{"Unable to connect ipv4L3Protocol \(\backslash\)"Tx\(\backslash\)""});
843           result = ipv4L3Protocol->TraceConnectWithoutContext (\textcolor{stringliteral}{"Rx"}, 
844                                                                \hyperlink{group__makeboundcallback_ga1725d6362e6065faa0709f7c93f8d770}{MakeBoundCallback} (&
      \hyperlink{namespacens3_ab7f559cb75bca820ec86b2be4523b8bf}{Ipv4L3ProtocolRxSinkWithoutContext}, theStream));
845           \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (result == \textcolor{keyword}{true}, \textcolor{stringliteral}{"InternetStackHelper::EnableAsciiIpv4Internal():  "}
846                          \textcolor{stringliteral}{"Unable to connect ipv4L3Protocol \(\backslash\)"Rx\(\backslash\)""});
847         \}
848 
849       \hyperlink{namespacens3_ad7720e08dcb21331d85c00128abc175a}{g\_interfaceStreamMapIpv4}[std::make\_pair (ipv4, interface)] = theStream;
850       \textcolor{keywordflow}{return};
851     \}
852 
853   \textcolor{comment}{//}
854   \textcolor{comment}{// If we are provided an OutputStreamWrapper, we are expected to use it, and}
855   \textcolor{comment}{// to provide a context.  We are free to come up with our own context if we}
856   \textcolor{comment}{// want, and use the AsciiTraceHelper Hook*WithContext functions, but for }
857   \textcolor{comment}{// compatibility and simplicity, we just use Config::Connect and let it deal}
858   \textcolor{comment}{// with the context.}
859   \textcolor{comment}{//}
860   \textcolor{comment}{// We need to associate the ipv4/interface with a stream to express interest}
861   \textcolor{comment}{// in tracing events on that pair, however, we only hook the trace sources }
862   \textcolor{comment}{// once to avoid multiple trace sink calls per event (connect is independent}
863   \textcolor{comment}{// of interface).}
864   \textcolor{comment}{//}
865   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1InternetStackHelper_a4b26d61d78933a884a03fbda4ec6eddc}{AsciiHooked} (ipv4))
866     \{
867       Ptr<Node> node = ipv4->GetObject<Node> ();
868       std::ostringstream oss;
869 
870       \textcolor{comment}{//}
871       \textcolor{comment}{// For the ARP Drop, we are going to use the default trace sink provided by }
872       \textcolor{comment}{// the ascii trace helper.  There is actually no AsciiTraceHelper in sight }
873       \textcolor{comment}{// here, but the default trace sinks are actually publicly available static }
874       \textcolor{comment}{// functions that are always there waiting for just such a case.}
875       \textcolor{comment}{//}
876       oss << \textcolor{stringliteral}{"/NodeList/"} << node->GetId () << \textcolor{stringliteral}{"/$ns3::ArpL3Protocol/Drop"};
877       \hyperlink{group__config_ga4014f151241cd0939b6cb64409605736}{Config::Connect} (oss.str (), \hyperlink{group__makeboundcallback_ga1725d6362e6065faa0709f7c93f8d770}{MakeBoundCallback} (&
      \hyperlink{classns3_1_1AsciiTraceHelper_a23bfa6926e104f782e1a8c87e54cc7e8}{AsciiTraceHelper::DefaultDropSinkWithContext}, stream));
878 
879       \textcolor{comment}{//}
880       \textcolor{comment}{// This has all kinds of parameters coming with, so we have to cook up our}
881       \textcolor{comment}{// own sink.}
882       \textcolor{comment}{//}
883       oss.str (\textcolor{stringliteral}{""});
884       oss << \textcolor{stringliteral}{"/NodeList/"} << node->GetId () << \textcolor{stringliteral}{"/$ns3::Ipv4L3Protocol/Drop"};
885       \hyperlink{group__config_ga4014f151241cd0939b6cb64409605736}{Config::Connect} (oss.str (), \hyperlink{group__makeboundcallback_ga1725d6362e6065faa0709f7c93f8d770}{MakeBoundCallback} (&
      \hyperlink{namespacens3_ab731704e54609d989a8b5ab8790f5948}{Ipv4L3ProtocolDropSinkWithContext}, stream));
886       oss.str (\textcolor{stringliteral}{""});
887       oss << \textcolor{stringliteral}{"/NodeList/"} << node->GetId () << \textcolor{stringliteral}{"/$ns3::Ipv4L3Protocol/Tx"};
888       \hyperlink{group__config_ga4014f151241cd0939b6cb64409605736}{Config::Connect} (oss.str (), \hyperlink{group__makeboundcallback_ga1725d6362e6065faa0709f7c93f8d770}{MakeBoundCallback} (&
      \hyperlink{namespacens3_ae5c3b272528df0f20c90e9619ae8d4c1}{Ipv4L3ProtocolTxSinkWithContext}, stream));
889       oss.str (\textcolor{stringliteral}{""});
890       oss << \textcolor{stringliteral}{"/NodeList/"} << node->GetId () << \textcolor{stringliteral}{"/$ns3::Ipv4L3Protocol/Rx"};
891       \hyperlink{group__config_ga4014f151241cd0939b6cb64409605736}{Config::Connect} (oss.str (), \hyperlink{group__makeboundcallback_ga1725d6362e6065faa0709f7c93f8d770}{MakeBoundCallback} (&
      \hyperlink{namespacens3_a861f020898d092a9027edf46576a4033}{Ipv4L3ProtocolRxSinkWithContext}, stream));
892     \}
893 
894   \hyperlink{namespacens3_ad7720e08dcb21331d85c00128abc175a}{g\_interfaceStreamMapIpv4}[std::make\_pair (ipv4, interface)] = stream;
895 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9


\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!Enable\+Ascii\+Ipv6\+Internal@{Enable\+Ascii\+Ipv6\+Internal}}
\index{Enable\+Ascii\+Ipv6\+Internal@{Enable\+Ascii\+Ipv6\+Internal}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{Enable\+Ascii\+Ipv6\+Internal(\+Ptr$<$ Output\+Stream\+Wrapper $>$ stream, std\+::string prefix, Ptr$<$ Ipv6 $>$ ipv6, uint32\+\_\+t interface, bool explicit\+Filename)}{EnableAsciiIpv6Internal(Ptr< OutputStreamWrapper > stream, std::string prefix, Ptr< Ipv6 > ipv6, uint32_t interface, bool explicitFilename)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Internet\+Stack\+Helper\+::\+Enable\+Ascii\+Ipv6\+Internal (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream, }
\item[{std\+::string}]{prefix, }
\item[{{\bf Ptr}$<$ {\bf Ipv6} $>$}]{ipv6, }
\item[{uint32\+\_\+t}]{interface, }
\item[{bool}]{explicit\+Filename}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1InternetStackHelper_a812b901ab8c2aff1f7feca6a9864b9c2}{}\label{classns3_1_1InternetStackHelper_a812b901ab8c2aff1f7feca6a9864b9c2}


Enable ascii trace output on the indicated \hyperlink{classns3_1_1Ipv6}{Ipv6} and interface pair. 


\begin{DoxyParams}{Parameters}
{\em stream} & An \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} representing an existing file to use when writing trace data. \\
\hline
{\em prefix} & Filename prefix to use for ascii trace files. \\
\hline
{\em ipv6} & \hyperlink{classns3_1_1Ptr}{Ptr} to the \hyperlink{classns3_1_1Ipv6}{Ipv6} interface on which you want to enable tracing. \\
\hline
{\em interface} & Interface ID on the \hyperlink{classns3_1_1Ipv6}{Ipv6} on which you want to enable tracing. \\
\hline
{\em explicit\+Filename} & Treat the prefix as an explicit filename if true \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1AsciiTraceHelperForIpv6_a4e9b410a23a53a76ef5f625867889618}{ns3\+::\+Ascii\+Trace\+Helper\+For\+Ipv6}.


\begin{DoxyCode}
1108 \{
1109   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1InternetStackHelper_a2eade9878232a41166cd0638cab7c3bf}{m\_ipv6Enabled})
1110     \{
1111       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Call to enable Ipv6 ascii tracing but Ipv6 not enabled"});
1112       \textcolor{keywordflow}{return};
1113     \}
1114 
1115   \textcolor{comment}{//}
1116   \textcolor{comment}{// Our trace sinks are going to use packet printing, so we have to }
1117   \textcolor{comment}{// make sure that is turned on.}
1118   \textcolor{comment}{//}
1119   \hyperlink{classns3_1_1Packet_ae17c0cd8e63e83df3c9273801e3d5d7f}{Packet::EnablePrinting} ();
1120 
1121   \textcolor{comment}{//}
1122   \textcolor{comment}{// If we are not provided an OutputStreamWrapper, we are expected to create }
1123   \textcolor{comment}{// one using the usual trace filename conventions and do a hook WithoutContext}
1124   \textcolor{comment}{// since there will be one file per context and therefore the context would}
1125   \textcolor{comment}{// be redundant.}
1126   \textcolor{comment}{//}
1127   \textcolor{keywordflow}{if} (stream == 0)
1128     \{
1129       \textcolor{comment}{//}
1130       \textcolor{comment}{// Set up an output stream object to deal with private ofstream copy }
1131       \textcolor{comment}{// constructor and lifetime issues.  Let the helper decide the actual}
1132       \textcolor{comment}{// name of the file given the prefix.}
1133       \textcolor{comment}{//}
1134       \textcolor{comment}{// We have to create a stream and a mapping from protocol/interface to }
1135       \textcolor{comment}{// stream irrespective of how many times we want to trace a particular }
1136       \textcolor{comment}{// protocol.}
1137       \textcolor{comment}{//}
1138       AsciiTraceHelper asciiTraceHelper;
1139 
1140       std::string filename;
1141       \textcolor{keywordflow}{if} (explicitFilename)
1142         \{
1143           filename = prefix;
1144         \}
1145       \textcolor{keywordflow}{else}
1146         \{
1147           filename = asciiTraceHelper.GetFilenameFromInterfacePair (prefix, ipv6, interface);
1148         \}
1149 
1150       Ptr<OutputStreamWrapper> theStream = asciiTraceHelper.CreateFileStream (filename);
1151 
1152       \textcolor{comment}{//}
1153       \textcolor{comment}{// However, we only hook the trace sources once to avoid multiple trace sink}
1154       \textcolor{comment}{// calls per event (connect is independent of interface).}
1155       \textcolor{comment}{//}
1156       \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1InternetStackHelper_a4b26d61d78933a884a03fbda4ec6eddc}{AsciiHooked} (ipv6))
1157         \{
1158           \textcolor{comment}{//}
1159           \textcolor{comment}{// The drop sink for the Ipv6L3Protocol uses a different signature than}
1160           \textcolor{comment}{// the default sink, so we have to cook one up for ourselves.  We can get}
1161           \textcolor{comment}{// to the Ptr<Ipv6L3Protocol> through our Ptr<Ipv6> since they must both }
1162           \textcolor{comment}{// be aggregated to the same node.}
1163           \textcolor{comment}{//}
1164           Ptr<Ipv6L3Protocol> ipv6L3Protocol = ipv6->GetObject<Ipv6L3Protocol> ();
1165           \textcolor{keywordtype}{bool} result = ipv6L3Protocol->TraceConnectWithoutContext (\textcolor{stringliteral}{"Drop"},
1166                                                                     
      \hyperlink{group__makeboundcallback_ga1725d6362e6065faa0709f7c93f8d770}{MakeBoundCallback} (&\hyperlink{namespacens3_a7ced21c98bc6aea53aacc04207dcf51c}{Ipv6L3ProtocolDropSinkWithoutContext}
      , theStream));
1167           \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (result == \textcolor{keyword}{true}, \textcolor{stringliteral}{"InternetStackHelper::EnableAsciiIpv6Internal():  "}
1168                          \textcolor{stringliteral}{"Unable to connect ipv6L3Protocol \(\backslash\)"Drop\(\backslash\)""});
1169           result = ipv6L3Protocol->TraceConnectWithoutContext (\textcolor{stringliteral}{"Tx"}, 
1170                                                                \hyperlink{group__makeboundcallback_ga1725d6362e6065faa0709f7c93f8d770}{MakeBoundCallback} (&
      \hyperlink{namespacens3_afefdbba2df6c6e8aaaf8cd04d4c65ed8}{Ipv6L3ProtocolTxSinkWithoutContext}, theStream));
1171           \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (result == \textcolor{keyword}{true}, \textcolor{stringliteral}{"InternetStackHelper::EnableAsciiIpv6Internal():  "}
1172                          \textcolor{stringliteral}{"Unable to connect ipv6L3Protocol \(\backslash\)"Tx\(\backslash\)""});
1173           result = ipv6L3Protocol->TraceConnectWithoutContext (\textcolor{stringliteral}{"Rx"}, 
1174                                                                \hyperlink{group__makeboundcallback_ga1725d6362e6065faa0709f7c93f8d770}{MakeBoundCallback} (&
      \hyperlink{namespacens3_afebee98eb19d40184517bb4806b90130}{Ipv6L3ProtocolRxSinkWithoutContext}, theStream));
1175           \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (result == \textcolor{keyword}{true}, \textcolor{stringliteral}{"InternetStackHelper::EnableAsciiIpv6Internal():  "}
1176                          \textcolor{stringliteral}{"Unable to connect ipv6L3Protocol \(\backslash\)"Rx\(\backslash\)""});
1177         \}
1178 
1179       \hyperlink{namespacens3_a7148863f60ffa7dcfbb51441f0a623fd}{g\_interfaceStreamMapIpv6}[std::make\_pair (ipv6, interface)] = theStream;
1180       \textcolor{keywordflow}{return};
1181     \}
1182 
1183   \textcolor{comment}{//}
1184   \textcolor{comment}{// If we are provided an OutputStreamWrapper, we are expected to use it, and}
1185   \textcolor{comment}{// to provide a context.  We are free to come up with our own context if we}
1186   \textcolor{comment}{// want, and use the AsciiTraceHelper Hook*WithContext functions, but for }
1187   \textcolor{comment}{// compatibility and simplicity, we just use Config::Connect and let it deal}
1188   \textcolor{comment}{// with the context.}
1189   \textcolor{comment}{//}
1190   \textcolor{comment}{// We need to associate the ipv4/interface with a stream to express interest}
1191   \textcolor{comment}{// in tracing events on that pair, however, we only hook the trace sources }
1192   \textcolor{comment}{// once to avoid multiple trace sink calls per event (connect is independent}
1193   \textcolor{comment}{// of interface).}
1194   \textcolor{comment}{//}
1195   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1InternetStackHelper_a4b26d61d78933a884a03fbda4ec6eddc}{AsciiHooked} (ipv6))
1196     \{
1197       Ptr<Node> node = ipv6->GetObject<Node> ();
1198       std::ostringstream oss;
1199 
1200       oss.str (\textcolor{stringliteral}{""});
1201       oss << \textcolor{stringliteral}{"/NodeList/"} << node->GetId () << \textcolor{stringliteral}{"/$ns3::Ipv6L3Protocol/Drop"};
1202       \hyperlink{group__config_ga4014f151241cd0939b6cb64409605736}{Config::Connect} (oss.str (), \hyperlink{group__makeboundcallback_ga1725d6362e6065faa0709f7c93f8d770}{MakeBoundCallback} (&
      \hyperlink{namespacens3_a4c8acaeda2989dceadb214af568d89a1}{Ipv6L3ProtocolDropSinkWithContext}, stream));
1203       oss.str (\textcolor{stringliteral}{""});
1204       oss << \textcolor{stringliteral}{"/NodeList/"} << node->GetId () << \textcolor{stringliteral}{"/$ns3::Ipv6L3Protocol/Tx"};
1205       \hyperlink{group__config_ga4014f151241cd0939b6cb64409605736}{Config::Connect} (oss.str (), \hyperlink{group__makeboundcallback_ga1725d6362e6065faa0709f7c93f8d770}{MakeBoundCallback} (&
      \hyperlink{namespacens3_aaf7b2964128423d1fa02e622009b0e04}{Ipv6L3ProtocolTxSinkWithContext}, stream));
1206       oss.str (\textcolor{stringliteral}{""});
1207       oss << \textcolor{stringliteral}{"/NodeList/"} << node->GetId () << \textcolor{stringliteral}{"/$ns3::Ipv6L3Protocol/Rx"};
1208       \hyperlink{group__config_ga4014f151241cd0939b6cb64409605736}{Config::Connect} (oss.str (), \hyperlink{group__makeboundcallback_ga1725d6362e6065faa0709f7c93f8d770}{MakeBoundCallback} (&
      \hyperlink{namespacens3_a694eb22660f7c8a45732d834395e3900}{Ipv6L3ProtocolRxSinkWithContext}, stream));
1209     \}
1210 
1211   \hyperlink{namespacens3_a7148863f60ffa7dcfbb51441f0a623fd}{g\_interfaceStreamMapIpv6}[std::make\_pair (ipv6, interface)] = stream;
1212 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10


\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!Enable\+Pcap\+Ipv4\+Internal@{Enable\+Pcap\+Ipv4\+Internal}}
\index{Enable\+Pcap\+Ipv4\+Internal@{Enable\+Pcap\+Ipv4\+Internal}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{Enable\+Pcap\+Ipv4\+Internal(std\+::string prefix, Ptr$<$ Ipv4 $>$ ipv4, uint32\+\_\+t interface, bool explicit\+Filename)}{EnablePcapIpv4Internal(std::string prefix, Ptr< Ipv4 > ipv4, uint32_t interface, bool explicitFilename)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Internet\+Stack\+Helper\+::\+Enable\+Pcap\+Ipv4\+Internal (
\begin{DoxyParamCaption}
\item[{std\+::string}]{prefix, }
\item[{{\bf Ptr}$<$ {\bf Ipv4} $>$}]{ipv4, }
\item[{uint32\+\_\+t}]{interface, }
\item[{bool}]{explicit\+Filename}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1InternetStackHelper_aec9bacdd0e3902ad274270d914fdee23}{}\label{classns3_1_1InternetStackHelper_aec9bacdd0e3902ad274270d914fdee23}


Enable pcap output the indicated \hyperlink{classns3_1_1Ipv4}{Ipv4} and interface pair. 


\begin{DoxyParams}{Parameters}
{\em prefix} & Filename prefix to use for pcap files. \\
\hline
{\em ipv4} & \hyperlink{classns3_1_1Ptr}{Ptr} to the \hyperlink{classns3_1_1Ipv4}{Ipv4} interface on which you want to enable tracing. \\
\hline
{\em interface} & Interface ID on the \hyperlink{classns3_1_1Ipv4}{Ipv4} on which you want to enable tracing. \\
\hline
{\em explicit\+Filename} & Treat the prefix as an explicit filename if true \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1PcapHelperForIpv4_a53c5d7ab4e9cd1f079d1ea3be49787ea}{ns3\+::\+Pcap\+Helper\+For\+Ipv4}.


\begin{DoxyCode}
408 \{
409   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (prefix << ipv4 << interface);
410 
411   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1InternetStackHelper_a52b041bc6e084a821e6885c71d38df31}{m\_ipv4Enabled})
412     \{
413       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Call to enable Ipv4 pcap tracing but Ipv4 not enabled"});
414       \textcolor{keywordflow}{return};
415     \}
416 
417   \textcolor{comment}{//}
418   \textcolor{comment}{// We have to create a file and a mapping from protocol/interface to file }
419   \textcolor{comment}{// irrespective of how many times we want to trace a particular protocol.}
420   \textcolor{comment}{//}
421   PcapHelper pcapHelper;
422 
423   std::string filename;
424   \textcolor{keywordflow}{if} (explicitFilename)
425     \{
426       filename = prefix;
427     \}
428   \textcolor{keywordflow}{else}
429     \{
430       filename = pcapHelper.GetFilenameFromInterfacePair (prefix, ipv4, interface);
431     \}
432 
433   Ptr<PcapFileWrapper> file = pcapHelper.CreateFile (filename, std::ios::out, 
      \hyperlink{classns3_1_1PcapHelper_a2ee4dad28ddd9a1fe636f51835eaa77facaa0d4a941d8f04ddafaa202c18298c1}{PcapHelper::DLT\_RAW});
434 
435   \textcolor{comment}{//}
436   \textcolor{comment}{// However, we only hook the trace source once to avoid multiple trace sink}
437   \textcolor{comment}{// calls per event (connect is independent of interface).}
438   \textcolor{comment}{//}
439   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1InternetStackHelper_a884260b23b3df90bf09eeb403df4d988}{PcapHooked} (ipv4))
440     \{
441       \textcolor{comment}{//}
442       \textcolor{comment}{// Ptr<Ipv4> is aggregated to node and Ipv4L3Protocol is aggregated to }
443       \textcolor{comment}{// node so we can get to Ipv4L3Protocol through Ipv4.}
444       \textcolor{comment}{//}
445       Ptr<Ipv4L3Protocol> ipv4L3Protocol = ipv4->GetObject<Ipv4L3Protocol> ();
446       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (ipv4L3Protocol, \textcolor{stringliteral}{"InternetStackHelper::EnablePcapIpv4Internal(): "}
447                      \textcolor{stringliteral}{"m\_ipv4Enabled and ipv4L3Protocol inconsistent"});
448 
449       \textcolor{keywordtype}{bool} result = ipv4L3Protocol->TraceConnectWithoutContext (\textcolor{stringliteral}{"Tx"}, 
      \hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&\hyperlink{namespacens3_a6531bb0b805a5b9a1ef7f4f1c4fb8002}{Ipv4L3ProtocolRxTxSink}));
450       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (result == \textcolor{keyword}{true}, \textcolor{stringliteral}{"InternetStackHelper::EnablePcapIpv4Internal():  "}
451                      \textcolor{stringliteral}{"Unable to connect ipv4L3Protocol \(\backslash\)"Tx\(\backslash\)""});
452 
453       result = ipv4L3Protocol->TraceConnectWithoutContext (\textcolor{stringliteral}{"Rx"}, \hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{namespacens3_a6531bb0b805a5b9a1ef7f4f1c4fb8002}{Ipv4L3ProtocolRxTxSink}));
454       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (result == \textcolor{keyword}{true}, \textcolor{stringliteral}{"InternetStackHelper::EnablePcapIpv4Internal():  "}
455                      \textcolor{stringliteral}{"Unable to connect ipv4L3Protocol \(\backslash\)"Rx\(\backslash\)""});
456     \}
457 
458   \hyperlink{namespacens3_ac1df4c15ca334fd8713f6600d097c1a6}{g\_interfaceFileMapIpv4}[std::make\_pair (ipv4, interface)] = file;
459 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 11


\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!Enable\+Pcap\+Ipv6\+Internal@{Enable\+Pcap\+Ipv6\+Internal}}
\index{Enable\+Pcap\+Ipv6\+Internal@{Enable\+Pcap\+Ipv6\+Internal}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{Enable\+Pcap\+Ipv6\+Internal(std\+::string prefix, Ptr$<$ Ipv6 $>$ ipv6, uint32\+\_\+t interface, bool explicit\+Filename)}{EnablePcapIpv6Internal(std::string prefix, Ptr< Ipv6 > ipv6, uint32_t interface, bool explicitFilename)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Internet\+Stack\+Helper\+::\+Enable\+Pcap\+Ipv6\+Internal (
\begin{DoxyParamCaption}
\item[{std\+::string}]{prefix, }
\item[{{\bf Ptr}$<$ {\bf Ipv6} $>$}]{ipv6, }
\item[{uint32\+\_\+t}]{interface, }
\item[{bool}]{explicit\+Filename}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1InternetStackHelper_a2ddebb75d6e8ce2c2b1b6fb55016ec00}{}\label{classns3_1_1InternetStackHelper_a2ddebb75d6e8ce2c2b1b6fb55016ec00}


Enable pcap output the indicated \hyperlink{classns3_1_1Ipv6}{Ipv6} and interface pair. 


\begin{DoxyParams}{Parameters}
{\em prefix} & Filename prefix to use for pcap files. \\
\hline
{\em ipv6} & \hyperlink{classns3_1_1Ptr}{Ptr} to the \hyperlink{classns3_1_1Ipv6}{Ipv6} interface on which you want to enable tracing. \\
\hline
{\em interface} & Interface ID on the \hyperlink{classns3_1_1Ipv6}{Ipv6} on which you want to enable tracing. \\
\hline
{\em explicit\+Filename} & Treat the prefix as an explicit filename if true \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1PcapHelperForIpv6_afdb171c84a6ffb3dc21010efbcd7957c}{ns3\+::\+Pcap\+Helper\+For\+Ipv6}.


\begin{DoxyCode}
506 \{
507   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (prefix << ipv6 << interface);
508 
509   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1InternetStackHelper_a2eade9878232a41166cd0638cab7c3bf}{m\_ipv6Enabled})
510     \{
511       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Call to enable Ipv6 pcap tracing but Ipv6 not enabled"});
512       \textcolor{keywordflow}{return};
513     \}
514 
515   \textcolor{comment}{//}
516   \textcolor{comment}{// We have to create a file and a mapping from protocol/interface to file }
517   \textcolor{comment}{// irrespective of how many times we want to trace a particular protocol.}
518   \textcolor{comment}{//}
519   PcapHelper pcapHelper;
520 
521   std::string filename;
522   \textcolor{keywordflow}{if} (explicitFilename)
523     \{
524       filename = prefix;
525     \}
526   \textcolor{keywordflow}{else}
527     \{
528       filename = pcapHelper.GetFilenameFromInterfacePair (prefix, ipv6, interface);
529     \}
530 
531   Ptr<PcapFileWrapper> file = pcapHelper.CreateFile (filename, std::ios::out, 
      \hyperlink{classns3_1_1PcapHelper_a2ee4dad28ddd9a1fe636f51835eaa77facaa0d4a941d8f04ddafaa202c18298c1}{PcapHelper::DLT\_RAW});
532 
533   \textcolor{comment}{//}
534   \textcolor{comment}{// However, we only hook the trace source once to avoid multiple trace sink}
535   \textcolor{comment}{// calls per event (connect is independent of interface).}
536   \textcolor{comment}{//}
537   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1InternetStackHelper_a884260b23b3df90bf09eeb403df4d988}{PcapHooked} (ipv6))
538     \{
539       \textcolor{comment}{//}
540       \textcolor{comment}{// Ptr<Ipv6> is aggregated to node and Ipv6L3Protocol is aggregated to }
541       \textcolor{comment}{// node so we can get to Ipv6L3Protocol through Ipv6.}
542       \textcolor{comment}{//}
543       Ptr<Ipv6L3Protocol> ipv6L3Protocol = ipv6->GetObject<Ipv6L3Protocol> ();
544       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (ipv6L3Protocol, \textcolor{stringliteral}{"InternetStackHelper::EnablePcapIpv6Internal(): "}
545                      \textcolor{stringliteral}{"m\_ipv6Enabled and ipv6L3Protocol inconsistent"});
546 
547       \textcolor{keywordtype}{bool} result = ipv6L3Protocol->TraceConnectWithoutContext (\textcolor{stringliteral}{"Tx"}, 
      \hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&\hyperlink{namespacens3_a3af463351b1701a7898a00fc29f2f016}{Ipv6L3ProtocolRxTxSink}));
548       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (result == \textcolor{keyword}{true}, \textcolor{stringliteral}{"InternetStackHelper::EnablePcapIpv6Internal():  "}
549                      \textcolor{stringliteral}{"Unable to connect ipv6L3Protocol \(\backslash\)"Tx\(\backslash\)""});
550 
551       result = ipv6L3Protocol->TraceConnectWithoutContext (\textcolor{stringliteral}{"Rx"}, \hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{namespacens3_a3af463351b1701a7898a00fc29f2f016}{Ipv6L3ProtocolRxTxSink}));
552       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (result == \textcolor{keyword}{true}, \textcolor{stringliteral}{"InternetStackHelper::EnablePcapIpv6Internal():  "}
553                      \textcolor{stringliteral}{"Unable to connect ipv6L3Protocol \(\backslash\)"Rx\(\backslash\)""});
554     \}
555 
556   \hyperlink{namespacens3_ae5afbbb41177e63c1b4d1c3ac635215d}{g\_interfaceFileMapIpv6}[std::make\_pair (ipv6, interface)] = file;
557 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12


\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!Initialize@{Initialize}}
\index{Initialize@{Initialize}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{Initialize(void)}{Initialize(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Internet\+Stack\+Helper\+::\+Initialize (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1InternetStackHelper_a51479cdc84af52b048ce586785643856}{}\label{classns3_1_1InternetStackHelper_a51479cdc84af52b048ce586785643856}


Initialize the helper to its default values. 


\begin{DoxyCode}
119 \{
120   \hyperlink{classns3_1_1InternetStackHelper_ac76e9cf493ef559f311c4ef85945129f}{SetTcp} (\textcolor{stringliteral}{"ns3::TcpL4Protocol"});
121   Ipv4StaticRoutingHelper staticRouting;
122   Ipv4GlobalRoutingHelper globalRouting;
123   Ipv4ListRoutingHelper listRouting;
124   Ipv6StaticRoutingHelper staticRoutingv6;
125   listRouting.Add (staticRouting, 0);
126   listRouting.Add (globalRouting, -10);
127   \hyperlink{classns3_1_1InternetStackHelper_a3e382c02df022dec79952a7eca8cd5ba}{SetRoutingHelper} (listRouting);
128   \hyperlink{classns3_1_1InternetStackHelper_a3e382c02df022dec79952a7eca8cd5ba}{SetRoutingHelper} (staticRoutingv6);
129 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13




Here is the caller graph for this function\+:
% FIG 14


\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!Install@{Install}}
\index{Install@{Install}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{Install(std\+::string node\+Name) const }{Install(std::string nodeName) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Internet\+Stack\+Helper\+::\+Install (
\begin{DoxyParamCaption}
\item[{std\+::string}]{node\+Name}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1InternetStackHelper_a6645b412f31283d2d9bc3d8a95cebbc0}{}\label{classns3_1_1InternetStackHelper_a6645b412f31283d2d9bc3d8a95cebbc0}
Aggregate implementations of the \hyperlink{classns3_1_1Ipv4}{ns3\+::\+Ipv4}, \hyperlink{classns3_1_1Ipv6}{ns3\+::\+Ipv6}, ns3\+::\+Udp, and ns3\+::\+Tcp classes onto the provided node. This method will assert if called on a node that already has an \hyperlink{classns3_1_1Ipv4}{Ipv4} object aggregated to it.


\begin{DoxyParams}{Parameters}
{\em node\+Name} & The name of the node on which to install the stack. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
358 \{
359   Ptr<Node> node = Names::Find<Node> (nodeName);
360   \hyperlink{classns3_1_1InternetStackHelper_a6645b412f31283d2d9bc3d8a95cebbc0}{Install} (node);
361 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 15


\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!Install@{Install}}
\index{Install@{Install}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{Install(\+Ptr$<$ Node $>$ node) const }{Install(Ptr< Node > node) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Internet\+Stack\+Helper\+::\+Install (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1InternetStackHelper_a14b0da37b1617255bf1078c11a108dce}{}\label{classns3_1_1InternetStackHelper_a14b0da37b1617255bf1078c11a108dce}
Aggregate implementations of the \hyperlink{classns3_1_1Ipv4}{ns3\+::\+Ipv4}, \hyperlink{classns3_1_1Ipv6}{ns3\+::\+Ipv6}, ns3\+::\+Udp, and ns3\+::\+Tcp classes onto the provided node. This method will assert if called on a node that already has an \hyperlink{classns3_1_1Ipv4}{Ipv4} object aggregated to it.


\begin{DoxyParams}{Parameters}
{\em node} & The node on which to install the stack. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
293 \{
294   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1InternetStackHelper_a52b041bc6e084a821e6885c71d38df31}{m\_ipv4Enabled})
295     \{
296       \textcolor{keywordflow}{if} (node->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv4> () != 0)
297         \{
298           \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"InternetStackHelper::Install (): Aggregating "} 
299                           \textcolor{stringliteral}{"an InternetStack to a node with an existing Ipv4 object"});
300           \textcolor{keywordflow}{return};
301         \}
302 
303       \hyperlink{classns3_1_1InternetStackHelper_a6605ba9c1bbfdf9ebe09c5dbcfce2451}{CreateAndAggregateObjectFromTypeId} (node, \textcolor{stringliteral}{"ns3::ArpL3Protocol"});
304       \hyperlink{classns3_1_1InternetStackHelper_a6605ba9c1bbfdf9ebe09c5dbcfce2451}{CreateAndAggregateObjectFromTypeId} (node, \textcolor{stringliteral}{"ns3::Ipv4L3Protocol"});
305       \hyperlink{classns3_1_1InternetStackHelper_a6605ba9c1bbfdf9ebe09c5dbcfce2451}{CreateAndAggregateObjectFromTypeId} (node, \textcolor{stringliteral}{"ns3::Icmpv4L4Protocol"});
306       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1InternetStackHelper_a9b4460c9d7b52d6ce2d390ffd1074bfa}{m\_ipv4ArpJitterEnabled} == \textcolor{keyword}{false})
307         \{
308           Ptr<ArpL3Protocol> arp = node->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<ArpL3Protocol> ();
309           \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (arp);
310           arp->SetAttribute (\textcolor{stringliteral}{"RequestJitter"}, StringValue (\textcolor{stringliteral}{"ns3::ConstantRandomVariable[Constant=0.0]"}));
311         \}
312       \textcolor{comment}{// Set routing}
313       Ptr<Ipv4> ipv4 = node->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv4> ();
314       Ptr<Ipv4RoutingProtocol> ipv4Routing = \hyperlink{classns3_1_1InternetStackHelper_a575127688a08b5a2f3f8e07839ea9807}{m\_routing}->\hyperlink{classns3_1_1Ipv4RoutingHelper_aa00350f9ab9f2ea2ff83f6ef04dae209}{Create} (node);
315       ipv4->SetRoutingProtocol (ipv4Routing);
316     \}
317 
318   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1InternetStackHelper_a2eade9878232a41166cd0638cab7c3bf}{m\_ipv6Enabled})
319     \{
320       \textcolor{comment}{/* IPv6 stack */}
321       \textcolor{keywordflow}{if} (node->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv6> () != 0)
322         \{
323           \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"InternetStackHelper::Install (): Aggregating "} 
324                           \textcolor{stringliteral}{"an InternetStack to a node with an existing Ipv6 object"});
325           \textcolor{keywordflow}{return};
326         \}
327 
328       \hyperlink{classns3_1_1InternetStackHelper_a6605ba9c1bbfdf9ebe09c5dbcfce2451}{CreateAndAggregateObjectFromTypeId} (node, \textcolor{stringliteral}{"ns3::Ipv6L3Protocol"});
329       \hyperlink{classns3_1_1InternetStackHelper_a6605ba9c1bbfdf9ebe09c5dbcfce2451}{CreateAndAggregateObjectFromTypeId} (node, \textcolor{stringliteral}{"ns3::Icmpv6L4Protocol"});
330       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1InternetStackHelper_a465f1786b918e4b3b3640d958d6e3212}{m\_ipv6NsRsJitterEnabled} == \textcolor{keyword}{false})
331         \{
332           Ptr<Icmpv6L4Protocol> icmpv6l4 = node->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Icmpv6L4Protocol> ();
333           \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (icmpv6l4);
334           icmpv6l4->SetAttribute (\textcolor{stringliteral}{"SolicitationJitter"}, StringValue (\textcolor{stringliteral}{"
      ns3::ConstantRandomVariable[Constant=0.0]"}));
335         \}
336       \textcolor{comment}{// Set routing}
337       Ptr<Ipv6> ipv6 = node->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv6> ();
338       Ptr<Ipv6RoutingProtocol> ipv6Routing = \hyperlink{classns3_1_1InternetStackHelper_ab00253ad66b420c44ab0226d333c51dd}{m\_routingv6}->\hyperlink{classns3_1_1Ipv6RoutingHelper_aee8501a0e661843ccf9da08e3e56614b}{Create} (node);
339       ipv6->SetRoutingProtocol (ipv6Routing);
340 
341       \textcolor{comment}{/* register IPv6 extensions and options */}
342       ipv6->RegisterExtensions ();
343       ipv6->RegisterOptions ();
344     \}
345 
346   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1InternetStackHelper_a52b041bc6e084a821e6885c71d38df31}{m\_ipv4Enabled} || \hyperlink{classns3_1_1InternetStackHelper_a2eade9878232a41166cd0638cab7c3bf}{m\_ipv6Enabled})
347     \{
348       \hyperlink{classns3_1_1InternetStackHelper_a6605ba9c1bbfdf9ebe09c5dbcfce2451}{CreateAndAggregateObjectFromTypeId} (node, \textcolor{stringliteral}{"ns3::TrafficControlLayer
      "});
349       \hyperlink{classns3_1_1InternetStackHelper_a6605ba9c1bbfdf9ebe09c5dbcfce2451}{CreateAndAggregateObjectFromTypeId} (node, \textcolor{stringliteral}{"ns3::UdpL4Protocol"});
350       node->\hyperlink{classns3_1_1Object_a79dd435d300f3deca814553f561a2922}{AggregateObject} (\hyperlink{classns3_1_1InternetStackHelper_a70733544910e58abfe1b238263ea5a68}{m\_tcpFactory}.\hyperlink{classns3_1_1ObjectFactory_a18152e93f0a6fe184ed7300cb31e9896}{Create}<Object> ());
351       Ptr<PacketSocketFactory> factory = CreateObject<PacketSocketFactory> ();
352       node->\hyperlink{classns3_1_1Object_a79dd435d300f3deca814553f561a2922}{AggregateObject} (factory);
353     \}
354 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 16


\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!Install@{Install}}
\index{Install@{Install}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{Install(\+Node\+Container c) const }{Install(NodeContainer c) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Internet\+Stack\+Helper\+::\+Install (
\begin{DoxyParamCaption}
\item[{{\bf Node\+Container}}]{c}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1InternetStackHelper_a3575bfbaafc7b35b107d8ac8abad57b5}{}\label{classns3_1_1InternetStackHelper_a3575bfbaafc7b35b107d8ac8abad57b5}
For each node in the input container, aggregate implementations of the \hyperlink{classns3_1_1Ipv4}{ns3\+::\+Ipv4}, \hyperlink{classns3_1_1Ipv6}{ns3\+::\+Ipv6}, ns3\+::\+Udp, and, ns3\+::\+Tcp classes. The program will assert if this method is called on a container with a node that already has an \hyperlink{classns3_1_1Ipv4}{Ipv4} object aggregated to it.


\begin{DoxyParams}{Parameters}
{\em c} & \hyperlink{classns3_1_1NodeContainer}{Node\+Container} that holds the set of nodes on which to install the new stacks. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
269 \{
270   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1NodeContainer_aa1a9f2d2b09bfef7d066d3974bca2cc4}{NodeContainer::Iterator} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c}.Begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c}.End (); ++
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
271     \{
272       \hyperlink{classns3_1_1InternetStackHelper_a6645b412f31283d2d9bc3d8a95cebbc0}{Install} (*\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
273     \}
274 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 17


\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!Install\+All@{Install\+All}}
\index{Install\+All@{Install\+All}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{Install\+All(void) const }{InstallAll(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Internet\+Stack\+Helper\+::\+Install\+All (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1InternetStackHelper_a6cfa73782fd4071c4cfbd73ebf1bbb44}{}\label{classns3_1_1InternetStackHelper_a6cfa73782fd4071c4cfbd73ebf1bbb44}
Aggregate I\+Pv4, I\+Pv6, U\+DP, and T\+CP stacks to all nodes in the simulation 
\begin{DoxyCode}
278 \{
279   \hyperlink{classns3_1_1InternetStackHelper_a6645b412f31283d2d9bc3d8a95cebbc0}{Install} (\hyperlink{classns3_1_1NodeContainer_a687e8f9ceb74d0ce3b06591c9f44c9ed}{NodeContainer::GetGlobal} ());
280 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 18




Here is the caller graph for this function\+:
% FIG 19


\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!operator=@{operator=}}
\index{operator=@{operator=}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{operator=(const Internet\+Stack\+Helper \&o)}{operator=(const InternetStackHelper &o)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Internet\+Stack\+Helper} \& ns3\+::\+Internet\+Stack\+Helper\+::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf Internet\+Stack\+Helper} \&}]{o}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1InternetStackHelper_abcbbffe4bb2c8dcfb8ffc495c5ebaba9}{}\label{classns3_1_1InternetStackHelper_abcbbffe4bb2c8dcfb8ffc495c5ebaba9}


Copy constructor. 


\begin{DoxyParams}{Parameters}
{\em o} & \hyperlink{classns3_1_1Object}{Object} to copy from. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A copy of the \hyperlink{classns3_1_1InternetStackHelper}{Internet\+Stack\+Helper}. 
\end{DoxyReturn}

\begin{DoxyCode}
150 \{
151   \textcolor{keywordflow}{if} (\textcolor{keyword}{this} == &o)
152     \{
153       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
154     \}
155   \hyperlink{classns3_1_1InternetStackHelper_a575127688a08b5a2f3f8e07839ea9807}{m\_routing} = o.m\_routing->\hyperlink{classns3_1_1Ipv4RoutingHelper_acf569a0ecf95d5b5186456f368eaa465}{Copy} ();
156   \hyperlink{classns3_1_1InternetStackHelper_ab00253ad66b420c44ab0226d333c51dd}{m\_routingv6} = o.m\_routingv6->\hyperlink{classns3_1_1Ipv6RoutingHelper_a324f924df9565843a0964e844e35927c}{Copy} ();
157   \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
158 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 20


\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!Pcap\+Hooked@{Pcap\+Hooked}}
\index{Pcap\+Hooked@{Pcap\+Hooked}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{Pcap\+Hooked(\+Ptr$<$ Ipv4 $>$ ipv4)}{PcapHooked(Ptr< Ipv4 > ipv4)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Internet\+Stack\+Helper\+::\+Pcap\+Hooked (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv4} $>$}]{ipv4}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1InternetStackHelper_a884260b23b3df90bf09eeb403df4d988}{}\label{classns3_1_1InternetStackHelper_a884260b23b3df90bf09eeb403df4d988}


checks if there is an hook to a Pcap wrapper 


\begin{DoxyParams}{Parameters}
{\em ipv4} & pointer to the I\+Pv4 object \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if a hook is found 
\end{DoxyReturn}

\begin{DoxyCode}
393 \{
394   \textcolor{keywordflow}{for} (  InterfaceFileMapIpv4::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{namespacens3_ac1df4c15ca334fd8713f6600d097c1a6}{g\_interfaceFileMapIpv4}.begin (); 
395          \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{namespacens3_ac1df4c15ca334fd8713f6600d097c1a6}{g\_interfaceFileMapIpv4}.end (); 
396          ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
397     \{
398       \textcolor{keywordflow}{if} ((*i).first.first == ipv4)
399         \{
400           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
401         \}
402     \}
403   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
404 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 21


\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!Pcap\+Hooked@{Pcap\+Hooked}}
\index{Pcap\+Hooked@{Pcap\+Hooked}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{Pcap\+Hooked(\+Ptr$<$ Ipv6 $>$ ipv6)}{PcapHooked(Ptr< Ipv6 > ipv6)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Internet\+Stack\+Helper\+::\+Pcap\+Hooked (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv6} $>$}]{ipv6}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1InternetStackHelper_a02016af4653dffbda1aa746d4a55b3b5}{}\label{classns3_1_1InternetStackHelper_a02016af4653dffbda1aa746d4a55b3b5}


checks if there is an hook to a Pcap wrapper 


\begin{DoxyParams}{Parameters}
{\em ipv6} & pointer to the I\+Pv6 object \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if a hook is found 
\end{DoxyReturn}

\begin{DoxyCode}
491 \{
492   \textcolor{keywordflow}{for} (  InterfaceFileMapIpv6::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{namespacens3_ae5afbbb41177e63c1b4d1c3ac635215d}{g\_interfaceFileMapIpv6}.begin (); 
493          \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{namespacens3_ae5afbbb41177e63c1b4d1c3ac635215d}{g\_interfaceFileMapIpv6}.end (); 
494          ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
495     \{
496       \textcolor{keywordflow}{if} ((*i).first.first == ipv6)
497         \{
498           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
499         \}
500     \}
501   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
502 \}
\end{DoxyCode}
\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!Reset@{Reset}}
\index{Reset@{Reset}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{Reset(void)}{Reset(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Internet\+Stack\+Helper\+::\+Reset (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1InternetStackHelper_a2c9c2074c78e3914eb4760fb1e222d49}{}\label{classns3_1_1InternetStackHelper_a2c9c2074c78e3914eb4760fb1e222d49}
Return helper internal state to that of a newly constructed one 
\begin{DoxyCode}
162 \{
163   \textcolor{keyword}{delete} \hyperlink{classns3_1_1InternetStackHelper_a575127688a08b5a2f3f8e07839ea9807}{m\_routing};
164   \hyperlink{classns3_1_1InternetStackHelper_a575127688a08b5a2f3f8e07839ea9807}{m\_routing} = 0;
165   \textcolor{keyword}{delete} \hyperlink{classns3_1_1InternetStackHelper_ab00253ad66b420c44ab0226d333c51dd}{m\_routingv6};
166   \hyperlink{classns3_1_1InternetStackHelper_ab00253ad66b420c44ab0226d333c51dd}{m\_routingv6} = 0;
167   \hyperlink{classns3_1_1InternetStackHelper_a52b041bc6e084a821e6885c71d38df31}{m\_ipv4Enabled} = \textcolor{keyword}{true};
168   \hyperlink{classns3_1_1InternetStackHelper_a2eade9878232a41166cd0638cab7c3bf}{m\_ipv6Enabled} = \textcolor{keyword}{true};
169   \hyperlink{classns3_1_1InternetStackHelper_a9b4460c9d7b52d6ce2d390ffd1074bfa}{m\_ipv4ArpJitterEnabled} = \textcolor{keyword}{true};
170   \hyperlink{classns3_1_1InternetStackHelper_a465f1786b918e4b3b3640d958d6e3212}{m\_ipv6NsRsJitterEnabled} = \textcolor{keyword}{true};
171   \hyperlink{classns3_1_1InternetStackHelper_a51479cdc84af52b048ce586785643856}{Initialize} ();
172 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 22


\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!Set\+Ipv4\+Arp\+Jitter@{Set\+Ipv4\+Arp\+Jitter}}
\index{Set\+Ipv4\+Arp\+Jitter@{Set\+Ipv4\+Arp\+Jitter}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{Set\+Ipv4\+Arp\+Jitter(bool enable)}{SetIpv4ArpJitter(bool enable)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Internet\+Stack\+Helper\+::\+Set\+Ipv4\+Arp\+Jitter (
\begin{DoxyParamCaption}
\item[{bool}]{enable}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1InternetStackHelper_a24eb534b7da530992ed34b9c620bcc8a}{}\label{classns3_1_1InternetStackHelper_a24eb534b7da530992ed34b9c620bcc8a}


Enable/disable I\+Pv4 A\+RP Jitter. 


\begin{DoxyParams}{Parameters}
{\em enable} & enable state \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
200 \{
201   \hyperlink{classns3_1_1InternetStackHelper_a9b4460c9d7b52d6ce2d390ffd1074bfa}{m\_ipv4ArpJitterEnabled} = enable;
202 \}
\end{DoxyCode}
\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!Set\+Ipv4\+Stack\+Install@{Set\+Ipv4\+Stack\+Install}}
\index{Set\+Ipv4\+Stack\+Install@{Set\+Ipv4\+Stack\+Install}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{Set\+Ipv4\+Stack\+Install(bool enable)}{SetIpv4StackInstall(bool enable)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Internet\+Stack\+Helper\+::\+Set\+Ipv4\+Stack\+Install (
\begin{DoxyParamCaption}
\item[{bool}]{enable}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1InternetStackHelper_a10e2a35f410d0d1c90d979542c8bfd6e}{}\label{classns3_1_1InternetStackHelper_a10e2a35f410d0d1c90d979542c8bfd6e}


Enable/disable I\+Pv4 stack install. 


\begin{DoxyParams}{Parameters}
{\em enable} & enable state \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
190 \{
191   \hyperlink{classns3_1_1InternetStackHelper_a52b041bc6e084a821e6885c71d38df31}{m\_ipv4Enabled} = enable;
192 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 23


\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!Set\+Ipv6\+Ns\+Rs\+Jitter@{Set\+Ipv6\+Ns\+Rs\+Jitter}}
\index{Set\+Ipv6\+Ns\+Rs\+Jitter@{Set\+Ipv6\+Ns\+Rs\+Jitter}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{Set\+Ipv6\+Ns\+Rs\+Jitter(bool enable)}{SetIpv6NsRsJitter(bool enable)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Internet\+Stack\+Helper\+::\+Set\+Ipv6\+Ns\+Rs\+Jitter (
\begin{DoxyParamCaption}
\item[{bool}]{enable}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1InternetStackHelper_a82214073afab2b64fe89ca60b8238e6b}{}\label{classns3_1_1InternetStackHelper_a82214073afab2b64fe89ca60b8238e6b}


Enable/disable I\+Pv6 NS and RS Jitter. 


\begin{DoxyParams}{Parameters}
{\em enable} & enable state \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
205 \{
206   \hyperlink{classns3_1_1InternetStackHelper_a465f1786b918e4b3b3640d958d6e3212}{m\_ipv6NsRsJitterEnabled} = enable;
207 \}
\end{DoxyCode}
\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!Set\+Ipv6\+Stack\+Install@{Set\+Ipv6\+Stack\+Install}}
\index{Set\+Ipv6\+Stack\+Install@{Set\+Ipv6\+Stack\+Install}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{Set\+Ipv6\+Stack\+Install(bool enable)}{SetIpv6StackInstall(bool enable)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Internet\+Stack\+Helper\+::\+Set\+Ipv6\+Stack\+Install (
\begin{DoxyParamCaption}
\item[{bool}]{enable}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1InternetStackHelper_a5fa8d34e5834305b6aa1b0fe43e1132b}{}\label{classns3_1_1InternetStackHelper_a5fa8d34e5834305b6aa1b0fe43e1132b}


Enable/disable I\+Pv6 stack install. 


\begin{DoxyParams}{Parameters}
{\em enable} & enable state \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
195 \{
196   \hyperlink{classns3_1_1InternetStackHelper_a2eade9878232a41166cd0638cab7c3bf}{m\_ipv6Enabled} = enable;
197 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 24


\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!Set\+Routing\+Helper@{Set\+Routing\+Helper}}
\index{Set\+Routing\+Helper@{Set\+Routing\+Helper}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{Set\+Routing\+Helper(const Ipv4\+Routing\+Helper \&routing)}{SetRoutingHelper(const Ipv4RoutingHelper &routing)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Internet\+Stack\+Helper\+::\+Set\+Routing\+Helper (
\begin{DoxyParamCaption}
\item[{const {\bf Ipv4\+Routing\+Helper} \&}]{routing}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1InternetStackHelper_a3e382c02df022dec79952a7eca8cd5ba}{}\label{classns3_1_1InternetStackHelper_a3e382c02df022dec79952a7eca8cd5ba}

\begin{DoxyParams}{Parameters}
{\em routing} & a new routing helper\\
\hline
\end{DoxyParams}
Set the routing helper to use during Install. The routing helper is really an object factory which is used to create an object of type \hyperlink{classns3_1_1Ipv4RoutingProtocol}{ns3\+::\+Ipv4\+Routing\+Protocol} per node. This routing object is then associated to a single \hyperlink{classns3_1_1Ipv4}{ns3\+::\+Ipv4} object through its \hyperlink{classns3_1_1Ipv4_a2d165c3bafd4ca580f02a03536db80d3}{ns3\+::\+Ipv4\+::\+Set\+Routing\+Protocol}. 
\begin{DoxyCode}
176 \{
177   \textcolor{keyword}{delete} \hyperlink{classns3_1_1InternetStackHelper_a575127688a08b5a2f3f8e07839ea9807}{m\_routing};
178   \hyperlink{classns3_1_1InternetStackHelper_a575127688a08b5a2f3f8e07839ea9807}{m\_routing} = routing.\hyperlink{classns3_1_1Ipv4RoutingHelper_acf569a0ecf95d5b5186456f368eaa465}{Copy} ();
179 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 25




Here is the caller graph for this function\+:
% FIG 26


\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!Set\+Routing\+Helper@{Set\+Routing\+Helper}}
\index{Set\+Routing\+Helper@{Set\+Routing\+Helper}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{Set\+Routing\+Helper(const Ipv6\+Routing\+Helper \&routing)}{SetRoutingHelper(const Ipv6RoutingHelper &routing)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Internet\+Stack\+Helper\+::\+Set\+Routing\+Helper (
\begin{DoxyParamCaption}
\item[{const {\bf Ipv6\+Routing\+Helper} \&}]{routing}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1InternetStackHelper_af3b2b9f74fdf4aa20317a8996564921a}{}\label{classns3_1_1InternetStackHelper_af3b2b9f74fdf4aa20317a8996564921a}


Set I\+Pv6 routing helper. 


\begin{DoxyParams}{Parameters}
{\em routing} & I\+Pv6 routing helper \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
183 \{
184   \textcolor{keyword}{delete} \hyperlink{classns3_1_1InternetStackHelper_ab00253ad66b420c44ab0226d333c51dd}{m\_routingv6};
185   \hyperlink{classns3_1_1InternetStackHelper_ab00253ad66b420c44ab0226d333c51dd}{m\_routingv6} = routing.\hyperlink{classns3_1_1Ipv6RoutingHelper_a324f924df9565843a0964e844e35927c}{Copy} ();
186 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 27


\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!Set\+Tcp@{Set\+Tcp}}
\index{Set\+Tcp@{Set\+Tcp}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{Set\+Tcp(std\+::string tid)}{SetTcp(std::string tid)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Internet\+Stack\+Helper\+::\+Set\+Tcp (
\begin{DoxyParamCaption}
\item[{std\+::string}]{tid}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1InternetStackHelper_ac76e9cf493ef559f311c4ef85945129f}{}\label{classns3_1_1InternetStackHelper_ac76e9cf493ef559f311c4ef85945129f}


set the Tcp stack which will not need any other parameter. 

This function sets up the tcp stack to the given \hyperlink{classns3_1_1TypeId}{Type\+Id}. It should not be used for N\+SC stack setup because the nsc stack needs the Library attribute to be setup, please use instead the version that requires an attribute and a value. If you choose to use this function anyways to set nsc stack the default value for the linux library will be used\+: \char`\"{}liblinux2.\+6.\+26.\+so\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em tid} & the type id, typically it is set to \char`\"{}ns3\+::\+Tcp\+L4\+Protocol\char`\"{} \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
256 \{
257   \hyperlink{classns3_1_1InternetStackHelper_a70733544910e58abfe1b238263ea5a68}{m\_tcpFactory}.\hyperlink{classns3_1_1ObjectFactory_a77dcd099064038a1eb7a6b8251229ec3}{SetTypeId} (tid);
258 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 28




Here is the caller graph for this function\+:
% FIG 29


\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!Set\+Tcp@{Set\+Tcp}}
\index{Set\+Tcp@{Set\+Tcp}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{Set\+Tcp(std\+::string tid, std\+::string attr, const Attribute\+Value \&val)}{SetTcp(std::string tid, std::string attr, const AttributeValue &val)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Internet\+Stack\+Helper\+::\+Set\+Tcp (
\begin{DoxyParamCaption}
\item[{std\+::string}]{tid, }
\item[{std\+::string}]{attr, }
\item[{const {\bf Attribute\+Value} \&}]{val}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1InternetStackHelper_a665afc046449275066145dcfa2f5790e}{}\label{classns3_1_1InternetStackHelper_a665afc046449275066145dcfa2f5790e}


This function is used to setup the Network Simulation Cradle stack with library value. 

Give the N\+SC stack a shared library file name to use when creating the stack implementation. The attr string is actually the attribute name to be setup and val is its value. The attribute is the stack implementation to be used and the value is the shared library name.


\begin{DoxyParams}{Parameters}
{\em tid} & The type id, for the case of nsc it would be \char`\"{}ns3\+::\+Nsc\+Tcp\+L4\+Protocol\char`\"{} \\
\hline
{\em attr} & The attribute name that must be setup, for example \char`\"{}\+Library\char`\"{} \\
\hline
{\em val} & The attribute value, which will be in fact the shared library name (example\+:\char`\"{}liblinux2.\+6.\+26.\+so\char`\"{}) \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
262 \{
263   \hyperlink{classns3_1_1InternetStackHelper_a70733544910e58abfe1b238263ea5a68}{m\_tcpFactory}.\hyperlink{classns3_1_1ObjectFactory_a77dcd099064038a1eb7a6b8251229ec3}{SetTypeId} (tid);
264   \hyperlink{classns3_1_1InternetStackHelper_a70733544910e58abfe1b238263ea5a68}{m\_tcpFactory}.\hyperlink{classns3_1_1ObjectFactory_aef5c0d5019c96bdf01cefd1ff83f4a68}{Set} (n0,v0);
265 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 30




\subsection{Member Data Documentation}
\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!m\+\_\+ipv4\+Arp\+Jitter\+Enabled@{m\+\_\+ipv4\+Arp\+Jitter\+Enabled}}
\index{m\+\_\+ipv4\+Arp\+Jitter\+Enabled@{m\+\_\+ipv4\+Arp\+Jitter\+Enabled}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+ipv4\+Arp\+Jitter\+Enabled}{m_ipv4ArpJitterEnabled}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Internet\+Stack\+Helper\+::m\+\_\+ipv4\+Arp\+Jitter\+Enabled\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1InternetStackHelper_a9b4460c9d7b52d6ce2d390ffd1074bfa}{}\label{classns3_1_1InternetStackHelper_a9b4460c9d7b52d6ce2d390ffd1074bfa}


I\+Pv4 A\+RP Jitter state (enabled/disabled) ? 

\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!m\+\_\+ipv4\+Enabled@{m\+\_\+ipv4\+Enabled}}
\index{m\+\_\+ipv4\+Enabled@{m\+\_\+ipv4\+Enabled}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+ipv4\+Enabled}{m_ipv4Enabled}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Internet\+Stack\+Helper\+::m\+\_\+ipv4\+Enabled\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1InternetStackHelper_a52b041bc6e084a821e6885c71d38df31}{}\label{classns3_1_1InternetStackHelper_a52b041bc6e084a821e6885c71d38df31}


I\+Pv4 install state (enabled/disabled) ? 

\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!m\+\_\+ipv6\+Enabled@{m\+\_\+ipv6\+Enabled}}
\index{m\+\_\+ipv6\+Enabled@{m\+\_\+ipv6\+Enabled}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+ipv6\+Enabled}{m_ipv6Enabled}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Internet\+Stack\+Helper\+::m\+\_\+ipv6\+Enabled\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1InternetStackHelper_a2eade9878232a41166cd0638cab7c3bf}{}\label{classns3_1_1InternetStackHelper_a2eade9878232a41166cd0638cab7c3bf}


I\+Pv6 install state (enabled/disabled) ? 

\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!m\+\_\+ipv6\+Ns\+Rs\+Jitter\+Enabled@{m\+\_\+ipv6\+Ns\+Rs\+Jitter\+Enabled}}
\index{m\+\_\+ipv6\+Ns\+Rs\+Jitter\+Enabled@{m\+\_\+ipv6\+Ns\+Rs\+Jitter\+Enabled}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+ipv6\+Ns\+Rs\+Jitter\+Enabled}{m_ipv6NsRsJitterEnabled}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Internet\+Stack\+Helper\+::m\+\_\+ipv6\+Ns\+Rs\+Jitter\+Enabled\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1InternetStackHelper_a465f1786b918e4b3b3640d958d6e3212}{}\label{classns3_1_1InternetStackHelper_a465f1786b918e4b3b3640d958d6e3212}


I\+Pv6 I\+Pv6 NS and RS Jitter state (enabled/disabled) ? 

\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!m\+\_\+routing@{m\+\_\+routing}}
\index{m\+\_\+routing@{m\+\_\+routing}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+routing}{m_routing}}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Ipv4\+Routing\+Helper}$\ast$ ns3\+::\+Internet\+Stack\+Helper\+::m\+\_\+routing\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1InternetStackHelper_a575127688a08b5a2f3f8e07839ea9807}{}\label{classns3_1_1InternetStackHelper_a575127688a08b5a2f3f8e07839ea9807}


I\+Pv4 routing helper. 

\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!m\+\_\+routingv6@{m\+\_\+routingv6}}
\index{m\+\_\+routingv6@{m\+\_\+routingv6}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+routingv6}{m_routingv6}}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Ipv6\+Routing\+Helper}$\ast$ ns3\+::\+Internet\+Stack\+Helper\+::m\+\_\+routingv6\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1InternetStackHelper_ab00253ad66b420c44ab0226d333c51dd}{}\label{classns3_1_1InternetStackHelper_ab00253ad66b420c44ab0226d333c51dd}


I\+Pv6 routing helper. 

\index{ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}!m\+\_\+tcp\+Factory@{m\+\_\+tcp\+Factory}}
\index{m\+\_\+tcp\+Factory@{m\+\_\+tcp\+Factory}!ns3\+::\+Internet\+Stack\+Helper@{ns3\+::\+Internet\+Stack\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+tcp\+Factory}{m_tcpFactory}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Object\+Factory} ns3\+::\+Internet\+Stack\+Helper\+::m\+\_\+tcp\+Factory\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1InternetStackHelper_a70733544910e58abfe1b238263ea5a68}{}\label{classns3_1_1InternetStackHelper_a70733544910e58abfe1b238263ea5a68}


T\+CP objects factory. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/helper/\hyperlink{internet-stack-helper_8h}{internet-\/stack-\/helper.\+h}\item 
internet/helper/\hyperlink{internet-stack-helper_8cc}{internet-\/stack-\/helper.\+cc}\end{DoxyCompactItemize}
