\hypertarget{classns3_1_1UplinkSchedulerRtps}{}\section{ns3\+:\+:Uplink\+Scheduler\+Rtps Class Reference}
\label{classns3_1_1UplinkSchedulerRtps}\index{ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}}


This class implements a simple uplink scheduler for rt\+PS flows.  




{\ttfamily \#include $<$bs-\/uplink-\/scheduler-\/rtps.\+h$>$}



Inheritance diagram for ns3\+:\+:Uplink\+Scheduler\+Rtps\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Uplink\+Scheduler\+Rtps\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1UplinkSchedulerRtps_abb7bd631422652d8bbf06dc3b5b74f72}{Uplink\+Scheduler\+Rtps} ()
\item 
\hyperlink{classns3_1_1UplinkSchedulerRtps_a96163ef1bec8e9cfaa7e467d71758e36}{Uplink\+Scheduler\+Rtps} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1BaseStationNetDevice}{Base\+Station\+Net\+Device} $>$ bs)
\item 
\hyperlink{classns3_1_1UplinkSchedulerRtps_a8cebc01f81be845cf278948ea4e070a8}{$\sim$\+Uplink\+Scheduler\+Rtps} (void)
\item 
\hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1OfdmUlMapIe}{Ofdm\+Ul\+Map\+Ie} $>$ \hyperlink{classns3_1_1UplinkSchedulerRtps_af57c0819227d4d0690036b76c9f4c79c}{Get\+Uplink\+Allocations} (void) const 
\begin{DoxyCompactList}\small\item\em Get uplink allocations. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1UplinkSchedulerRtps_a81d2d944421fd34d2b260f406b7a0649}{Get\+Channel\+Descriptors\+To\+Update} (bool \&update\+Dcd, bool \&update\+Ucd, bool \&send\+Dcd, bool \&send\+Ucd)
\item 
uint32\+\_\+t \hyperlink{classns3_1_1UplinkSchedulerRtps_ac5ae2f7c51fd1aa551813d0b12dc8013}{Calculate\+Allocation\+Start\+Time} (void)
\item 
void \hyperlink{classns3_1_1UplinkSchedulerRtps_aea8d8f5701bf3b5f992d1b43471340d2}{Add\+Uplink\+Allocation} (\hyperlink{classns3_1_1OfdmUlMapIe}{Ofdm\+Ul\+Map\+Ie} \&ul\+Map\+Ie, const uint32\+\_\+t \&allocation\+Size, uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)
\item 
void \hyperlink{classns3_1_1UplinkSchedulerRtps_a3863d85ca853d4b8b1033a38d0ff9dcd}{Schedule} (void)
\begin{DoxyCompactList}\small\item\em Schedule function. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1UplinkSchedulerRtps_ab101ce69266831aad941b4c553d82026}{Service\+Unsolicited\+Grants} (const \hyperlink{classns3_1_1SSRecord}{S\+S\+Record} $\ast$ss\+Record, enum \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235}{Service\+Flow\+::\+Scheduling\+Type} scheduling\+Type, \hyperlink{classns3_1_1OfdmUlMapIe}{Ofdm\+Ul\+Map\+Ie} \&ul\+Map\+Ie, const \hyperlink{classns3_1_1WimaxPhy_a044c5d8a48ca992c39c2a946f6e755fa}{Wimax\+Phy\+::\+Modulation\+Type} modulation\+Type, uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)
\item 
void \hyperlink{classns3_1_1UplinkSchedulerRtps_a35d16645e1db685e5df2b5fc7527f5de}{Service\+Bandwidth\+Requests} (const \hyperlink{classns3_1_1SSRecord}{S\+S\+Record} $\ast$ss\+Record, enum \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235}{Service\+Flow\+::\+Scheduling\+Type} scheduling\+Type, \hyperlink{classns3_1_1OfdmUlMapIe}{Ofdm\+Ul\+Map\+Ie} \&ul\+Map\+Ie, const \hyperlink{classns3_1_1WimaxPhy_a044c5d8a48ca992c39c2a946f6e755fa}{Wimax\+Phy\+::\+Modulation\+Type} modulation\+Type, uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)
\item 
bool \hyperlink{classns3_1_1UplinkSchedulerRtps_a0aa40f551a0bf51ca2197ff85190f572}{Service\+Bandwidth\+Requests} (\hyperlink{classns3_1_1ServiceFlow}{Service\+Flow} $\ast$service\+Flow, enum \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235}{Service\+Flow\+::\+Scheduling\+Type} scheduling\+Type, \hyperlink{classns3_1_1OfdmUlMapIe}{Ofdm\+Ul\+Map\+Ie} \&ul\+Map\+Ie, const \hyperlink{classns3_1_1WimaxPhy_a044c5d8a48ca992c39c2a946f6e755fa}{Wimax\+Phy\+::\+Modulation\+Type} modulation\+Type, uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)
\item 
void \hyperlink{classns3_1_1UplinkSchedulerRtps_aee60dd2773cd1404f6efe04373b567ea}{U\+L\+Scheduler\+R\+T\+P\+S\+Connection} (uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)
\begin{DoxyCompactList}\small\item\em Uplink \hyperlink{classns3_1_1Scheduler}{Scheduler} for rt\+PS connections. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1UplinkSchedulerRtps_adc340ccabe8e7dcaec455bdfd111d632}{Allocate\+Initial\+Ranging\+Interval} (uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)
\item 
void \hyperlink{classns3_1_1UplinkSchedulerRtps_ac44a9146c9928da245ebcf2c55a5c0d6}{Setup\+Service\+Flow} (\hyperlink{classns3_1_1SSRecord}{S\+S\+Record} $\ast$ss\+Record, \hyperlink{classns3_1_1ServiceFlow}{Service\+Flow} $\ast$service\+Flow)
\item 
void \hyperlink{classns3_1_1UplinkSchedulerRtps_a8acb9d916577dae3c671c3aa67b1ce48}{Process\+Bandwidth\+Request} (const \hyperlink{classns3_1_1BandwidthRequestHeader}{Bandwidth\+Request\+Header} \&bw\+Request\+Hdr)
\item 
void \hyperlink{classns3_1_1UplinkSchedulerRtps_ac712136e3b5f7e856daba25d7a946747}{Init\+Once} (void)
\begin{DoxyCompactList}\small\item\em Init once function. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1UplinkSchedulerRtps_ad6e66597b048a59cb95ea3c620b59c2c}{On\+Set\+Requested\+Bandwidth} (\hyperlink{classns3_1_1ServiceFlowRecord}{Service\+Flow\+Record} $\ast$sfr)
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1UplinkSchedulerRtps_a38423d6562b7e422a5d3de6b3c1a661c}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1OfdmUlMapIe}{Ofdm\+Ul\+Map\+Ie} $>$ \hyperlink{classns3_1_1UplinkSchedulerRtps_a4cb3da7f31082b64a21b7f9adc7fd2e4}{m\+\_\+uplink\+Allocations}
\begin{DoxyCompactList}\small\item\em uplink allocations \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
This class implements a simple uplink scheduler for rt\+PS flows. 

The U\+L-\/rt\+P\+S-\/\+Scheduler work in this way\+: At the beginning of the UL sub-\/frame some symbols are allocated to the ranging\+Interval Messages, D\+SA Messages, U\+GS grants and U\+G\+S/rt\+P\+S/nrt\+P\+S/\+BE poll. Then, the remaining available symbols are allocated to the all rt\+PS flows according to their requested\+Bandwidth. The bandwidth saturation control has been implemented to redistribute the resource if the sum of requested\+Bandwidth exceed the available bandwidth. At the end, if there are some free symbols, their are allocated to nrt\+PS and BE Connections. 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}!Uplink\+Scheduler\+Rtps@{Uplink\+Scheduler\+Rtps}}
\index{Uplink\+Scheduler\+Rtps@{Uplink\+Scheduler\+Rtps}!ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}}
\subsubsection[{\texorpdfstring{Uplink\+Scheduler\+Rtps()}{UplinkSchedulerRtps()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Uplink\+Scheduler\+Rtps\+::\+Uplink\+Scheduler\+Rtps (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UplinkSchedulerRtps_abb7bd631422652d8bbf06dc3b5b74f72}{}\label{classns3_1_1UplinkSchedulerRtps_abb7bd631422652d8bbf06dc3b5b74f72}

\begin{DoxyCode}
44 \{
45   \hyperlink{classns3_1_1UplinkScheduler_a28a8d5aa6e61d4ea91388ac3c76e759f}{SetBs} (0);
46   \hyperlink{classns3_1_1UplinkScheduler_ad6e89aef6cf4a9d485762f8bd08ec24e}{SetTimeStampIrInterval} (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (0));
47   \hyperlink{classns3_1_1UplinkScheduler_a19208ce138c5e13b1a7019a67adef892}{SetNrIrOppsAllocated} (0);
48   \hyperlink{classns3_1_1UplinkScheduler_a3eee0d06486678eab4d352a274676d95}{SetIsIrIntrvlAllocated} (\textcolor{keyword}{false});
49   \hyperlink{classns3_1_1UplinkScheduler_a766e3b6c032052002929eb351934e42b}{SetIsInvIrIntrvlAllocated} (\textcolor{keyword}{false});
50   \hyperlink{classns3_1_1UplinkScheduler_a18ccfd91b3f58a55f7249bbafb858f5c}{SetDcdTimeStamp} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ());
51   \hyperlink{classns3_1_1UplinkScheduler_a0dff82b69865688622c0453a35bffe98}{SetUcdTimeStamp} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ());
52 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}!Uplink\+Scheduler\+Rtps@{Uplink\+Scheduler\+Rtps}}
\index{Uplink\+Scheduler\+Rtps@{Uplink\+Scheduler\+Rtps}!ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}}
\subsubsection[{\texorpdfstring{Uplink\+Scheduler\+Rtps(\+Ptr$<$ Base\+Station\+Net\+Device $>$ bs)}{UplinkSchedulerRtps(Ptr< BaseStationNetDevice > bs)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Uplink\+Scheduler\+Rtps\+::\+Uplink\+Scheduler\+Rtps (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Base\+Station\+Net\+Device} $>$}]{bs}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UplinkSchedulerRtps_a96163ef1bec8e9cfaa7e467d71758e36}{}\label{classns3_1_1UplinkSchedulerRtps_a96163ef1bec8e9cfaa7e467d71758e36}
Constructor


\begin{DoxyParams}{Parameters}
{\em bs} & base station device \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
55 \{
56   \hyperlink{classns3_1_1UplinkScheduler_a28a8d5aa6e61d4ea91388ac3c76e759f}{SetBs} (bs);
57   \hyperlink{classns3_1_1UplinkScheduler_ad6e89aef6cf4a9d485762f8bd08ec24e}{SetTimeStampIrInterval} (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (0));
58   \hyperlink{classns3_1_1UplinkScheduler_a19208ce138c5e13b1a7019a67adef892}{SetNrIrOppsAllocated} (0);
59   \hyperlink{classns3_1_1UplinkScheduler_a3eee0d06486678eab4d352a274676d95}{SetIsIrIntrvlAllocated} (\textcolor{keyword}{false});
60   \hyperlink{classns3_1_1UplinkScheduler_a766e3b6c032052002929eb351934e42b}{SetIsInvIrIntrvlAllocated} (\textcolor{keyword}{false});
61   \hyperlink{classns3_1_1UplinkScheduler_a18ccfd91b3f58a55f7249bbafb858f5c}{SetDcdTimeStamp} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ());
62   \hyperlink{classns3_1_1UplinkScheduler_a0dff82b69865688622c0453a35bffe98}{SetUcdTimeStamp} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ());
63 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}!````~Uplink\+Scheduler\+Rtps@{$\sim$\+Uplink\+Scheduler\+Rtps}}
\index{````~Uplink\+Scheduler\+Rtps@{$\sim$\+Uplink\+Scheduler\+Rtps}!ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}}
\subsubsection[{\texorpdfstring{$\sim$\+Uplink\+Scheduler\+Rtps(void)}{~UplinkSchedulerRtps(void)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Uplink\+Scheduler\+Rtps\+::$\sim$\+Uplink\+Scheduler\+Rtps (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UplinkSchedulerRtps_a8cebc01f81be845cf278948ea4e070a8}{}\label{classns3_1_1UplinkSchedulerRtps_a8cebc01f81be845cf278948ea4e070a8}

\begin{DoxyCode}
66 \{
67   \hyperlink{classns3_1_1UplinkScheduler_a28a8d5aa6e61d4ea91388ac3c76e759f}{SetBs} (0);
68   \hyperlink{classns3_1_1UplinkSchedulerRtps_a4cb3da7f31082b64a21b7f9adc7fd2e4}{m\_uplinkAllocations}.clear ();
69 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4




\subsection{Member Function Documentation}
\index{ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}!Add\+Uplink\+Allocation@{Add\+Uplink\+Allocation}}
\index{Add\+Uplink\+Allocation@{Add\+Uplink\+Allocation}!ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}}
\subsubsection[{\texorpdfstring{Add\+Uplink\+Allocation(\+Ofdm\+Ul\+Map\+Ie \&ul\+Map\+Ie, const uint32\+\_\+t \&allocation\+Size, uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)}{AddUplinkAllocation(OfdmUlMapIe &ulMapIe, const uint32_t &allocationSize, uint32_t &symbolsToAllocation, uint32_t &availableSymbols)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+Rtps\+::\+Add\+Uplink\+Allocation (
\begin{DoxyParamCaption}
\item[{{\bf Ofdm\+Ul\+Map\+Ie} \&}]{ul\+Map\+Ie, }
\item[{const uint32\+\_\+t \&}]{allocation\+Size, }
\item[{uint32\+\_\+t \&}]{symbols\+To\+Allocation, }
\item[{uint32\+\_\+t \&}]{available\+Symbols}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerRtps_aea8d8f5701bf3b5f992d1b43471340d2}{}\label{classns3_1_1UplinkSchedulerRtps_aea8d8f5701bf3b5f992d1b43471340d2}
Add Uplink Allocation function 
\begin{DoxyParams}{Parameters}
{\em ul\+Map\+Ie} & the UL map IE \\
\hline
{\em allocation\+Size} & the allocation size \\
\hline
{\em symbols\+To\+Allocation} & the symbols to allocation \\
\hline
{\em available\+Symbols} & the available symbols \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1UplinkScheduler_a9bb05ef2a73f18c5004a812aefece8b6}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
155 \{
156   ulMapIe.SetDuration (allocationSize);
157   ulMapIe.SetStartTime (symbolsToAllocation);
158   \hyperlink{classns3_1_1UplinkSchedulerRtps_a4cb3da7f31082b64a21b7f9adc7fd2e4}{m\_uplinkAllocations}.push\_back (ulMapIe);
159   symbolsToAllocation += allocationSize;
160   availableSymbols -= allocationSize;
161 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5




Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}!Allocate\+Initial\+Ranging\+Interval@{Allocate\+Initial\+Ranging\+Interval}}
\index{Allocate\+Initial\+Ranging\+Interval@{Allocate\+Initial\+Ranging\+Interval}!ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}}
\subsubsection[{\texorpdfstring{Allocate\+Initial\+Ranging\+Interval(uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)}{AllocateInitialRangingInterval(uint32_t &symbolsToAllocation, uint32_t &availableSymbols)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+Rtps\+::\+Allocate\+Initial\+Ranging\+Interval (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t \&}]{symbols\+To\+Allocation, }
\item[{uint32\+\_\+t \&}]{available\+Symbols}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerRtps_adc340ccabe8e7dcaec455bdfd111d632}{}\label{classns3_1_1UplinkSchedulerRtps_adc340ccabe8e7dcaec455bdfd111d632}
Allocate Initial Ranging Interval function


\begin{DoxyParams}{Parameters}
{\em symbols\+To\+Allocation} & symbols to allocation for Up\+Link Subframe \\
\hline
{\em available\+Symbols} & available symbols for rt\+PS flows \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1UplinkScheduler_ae6094447ffd6d3946a70723246faed42}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
609 \{
610   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} ssUlStartTime = \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (\hyperlink{classns3_1_1UplinkSchedulerRtps_ac5ae2f7c51fd1aa551813d0b12dc8013}{CalculateAllocationStartTime} () * 
      \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPsDuration ().GetSeconds ());
611   \hyperlink{classns3_1_1UplinkScheduler_a19208ce138c5e13b1a7019a67adef892}{SetNrIrOppsAllocated} (\hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetLinkManager ()->
      CalculateRangingOppsToAllocate ());
612   uint32\_t allocationSize = \hyperlink{classns3_1_1UplinkScheduler_a9a2cbb04c1e84a028fc1545e8f054b80}{GetNrIrOppsAllocated} () * \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetRangReqOppSize 
      ();
613   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} timeSinceLastIrInterval = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} () - 
      \hyperlink{classns3_1_1UplinkScheduler_aa7516e5a55b513a7640035a9783369c7}{GetTimeStampIrInterval} ();
614 
615   \textcolor{comment}{// adding one frame because may be the time has not elapsed now but will elapse before the next frame is
       sent}
616   \textcolor{keywordflow}{if} (timeSinceLastIrInterval + \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetFrameDuration () > 
      \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetInitialRangingInterval ()
617       && availableSymbols >= allocationSize)
618     \{
619       \hyperlink{classns3_1_1UplinkScheduler_a3eee0d06486678eab4d352a274676d95}{SetIsIrIntrvlAllocated} (\textcolor{keyword}{true});
620       OfdmUlMapIe ulMapIeIr;
621       ulMapIeIr.SetCid (\hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetBroadcastConnection ()->GetCid ());
622       ulMapIeIr.SetStartTime (symbolsToAllocation);
623       ulMapIeIr.SetUiuc (\hyperlink{classns3_1_1OfdmUlBurstProfile_ae528783c4b3c6700ff49dfd7a555cb3daaea7b6256d4bcd0125f0248c0560c94e}{OfdmUlBurstProfile::UIUC\_INITIAL\_RANGING});
624 
625       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"BS uplink scheduler, initial ranging allocation, size: "} << allocationSize
       << \textcolor{stringliteral}{" symbols"}
626                                                                               << \textcolor{stringliteral}{", modulation: BPSK 1/2"});
627 
628       \textcolor{comment}{// marking start and end of each TO, only for debugging}
629       \textcolor{keywordflow}{for} (uint8\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1UplinkScheduler_a9a2cbb04c1e84a028fc1545e8f054b80}{GetNrIrOppsAllocated} (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
630         \{
631           \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->MarkRangingOppStart (ssUlStartTime + \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (symbolsToAllocation
632                                                                   * \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetSymbolDuration ().
      GetSeconds ()) + \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} * \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetRangReqOppSize ()
633                                                                                                            
                        * \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetSymbolDuration ().GetSeconds ()));
634         \}
635 
636       \hyperlink{classns3_1_1UplinkSchedulerRtps_aea8d8f5701bf3b5f992d1b43471340d2}{AddUplinkAllocation} (ulMapIeIr, allocationSize, symbolsToAllocation, 
      availableSymbols);
637       \hyperlink{classns3_1_1UplinkScheduler_ad6e89aef6cf4a9d485762f8bd08ec24e}{SetTimeStampIrInterval} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ());
638     \}
639 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7




Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}!Calculate\+Allocation\+Start\+Time@{Calculate\+Allocation\+Start\+Time}}
\index{Calculate\+Allocation\+Start\+Time@{Calculate\+Allocation\+Start\+Time}!ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}}
\subsubsection[{\texorpdfstring{Calculate\+Allocation\+Start\+Time(void)}{CalculateAllocationStartTime(void)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Uplink\+Scheduler\+Rtps\+::\+Calculate\+Allocation\+Start\+Time (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerRtps_ac5ae2f7c51fd1aa551813d0b12dc8013}{}\label{classns3_1_1UplinkSchedulerRtps_ac5ae2f7c51fd1aa551813d0b12dc8013}
Calculate allocation start time function \begin{DoxyReturn}{Returns}
the allocation start time value 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1UplinkScheduler_a10d8a099202072dee74f879d9ae2479b}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
146 \{
147   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetNrDlSymbols () * \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetPsPerSymbol () + 
      \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetTtg ();
148 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9




Here is the caller graph for this function\+:
% FIG 10


\index{ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}!Get\+Channel\+Descriptors\+To\+Update@{Get\+Channel\+Descriptors\+To\+Update}}
\index{Get\+Channel\+Descriptors\+To\+Update@{Get\+Channel\+Descriptors\+To\+Update}!ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}}
\subsubsection[{\texorpdfstring{Get\+Channel\+Descriptors\+To\+Update(bool \&update\+Dcd, bool \&update\+Ucd, bool \&send\+Dcd, bool \&send\+Ucd)}{GetChannelDescriptorsToUpdate(bool &updateDcd, bool &updateUcd, bool &sendDcd, bool &sendUcd)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+Rtps\+::\+Get\+Channel\+Descriptors\+To\+Update (
\begin{DoxyParamCaption}
\item[{bool \&}]{update\+Dcd, }
\item[{bool \&}]{update\+Ucd, }
\item[{bool \&}]{send\+Dcd, }
\item[{bool \&}]{send\+Ucd}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerRtps_a81d2d944421fd34d2b260f406b7a0649}{}\label{classns3_1_1UplinkSchedulerRtps_a81d2d944421fd34d2b260f406b7a0649}
Determines if channel descriptors sent in the current frame are required to be updated 
\begin{DoxyParams}{Parameters}
{\em update\+Dcd} & if true update D\+CD \\
\hline
{\em update\+Ucd} & if true update U\+CD \\
\hline
{\em send\+Dcd} & if true send D\+CD \\
\hline
{\em send\+Ucd} & if true send U\+CD \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1UplinkScheduler_ae500207af8583a3595da89edcc20b851}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
90 \{
91   \textcolor{comment}{/*DCD and UCD shall actually be updated when channel or burst profile definitions}
92 \textcolor{comment}{   change. burst profiles are updated based on number of SSs, network conditions and etc.}
93 \textcolor{comment}{   for now temporarily assuming DCD/UCD shall be updated everytime */}
94 
95   uint32\_t randNr = rand ();
96   \textcolor{keywordflow}{if} (randNr % 5 == 0 || \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetNrDcdSent () == 0)
97     \{
98       sendDcd = \textcolor{keyword}{true};
99     \}
100 
101   randNr = rand ();
102   \textcolor{keywordflow}{if} (randNr % 5 == 0 || \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetNrUcdSent () == 0)
103     \{
104       sendUcd = \textcolor{keyword}{true};
105     \}
106 
107   \textcolor{comment}{// -------------------------------------}
108   \textcolor{comment}{// additional, just to send more frequently}
109   \textcolor{keywordflow}{if} (!sendDcd)
110     \{
111       randNr = rand ();
112       \textcolor{keywordflow}{if} (randNr % 4 == 0)
113         \{
114           sendDcd = \textcolor{keyword}{true};
115         \}
116     \}
117 
118   \textcolor{keywordflow}{if} (!sendUcd)
119     \{
120       randNr = rand ();
121       \textcolor{keywordflow}{if} (randNr % 4 == 0)
122         \{
123           sendUcd = \textcolor{keyword}{true};
124         \}
125     \}
126   \textcolor{comment}{// -------------------------------------}
127 
128   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} timeSinceLastDcd = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} () - \hyperlink{classns3_1_1UplinkScheduler_a3db19e92a24c71af7d6aff5e94d488fe}{GetDcdTimeStamp} ();
129   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} timeSinceLastUcd = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} () - \hyperlink{classns3_1_1UplinkScheduler_a709e1a0e3c5ab174b0e1bc123dcfd676}{GetUcdTimeStamp} ();
130 
131   \textcolor{keywordflow}{if} (timeSinceLastDcd > \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetDcdInterval ())
132     \{
133       sendDcd = \textcolor{keyword}{true};
134       \hyperlink{classns3_1_1UplinkScheduler_a18ccfd91b3f58a55f7249bbafb858f5c}{SetDcdTimeStamp} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ());
135     \}
136 
137   \textcolor{keywordflow}{if} (timeSinceLastUcd > \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetUcdInterval ())
138     \{
139       sendUcd = \textcolor{keyword}{true};
140       \hyperlink{classns3_1_1UplinkScheduler_a0dff82b69865688622c0453a35bffe98}{SetUcdTimeStamp} (\hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ());
141     \}
142 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 11


\index{ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Uplink\+Scheduler\+Rtps\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1UplinkSchedulerRtps_a38423d6562b7e422a5d3de6b3c1a661c}{}\label{classns3_1_1UplinkSchedulerRtps_a38423d6562b7e422a5d3de6b3c1a661c}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
73 \{
74   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::UplinkSchedulerRtps"})
75     .SetParent<\hyperlink{classns3_1_1UplinkScheduler_a49c38d7e63903d62bb825c38ba3be0fa}{UplinkScheduler}> ()
76     .SetGroupName(\textcolor{stringliteral}{"Wimax"})
77     .AddConstructor<\hyperlink{classns3_1_1UplinkSchedulerRtps_abb7bd631422652d8bbf06dc3b5b74f72}{UplinkSchedulerRtps}> ()
78     ;
79   \textcolor{keywordflow}{return} tid;
80 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12


\index{ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}!Get\+Uplink\+Allocations@{Get\+Uplink\+Allocations}}
\index{Get\+Uplink\+Allocations@{Get\+Uplink\+Allocations}!ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}}
\subsubsection[{\texorpdfstring{Get\+Uplink\+Allocations(void) const }{GetUplinkAllocations(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std\+::list}$<$ {\bf Ofdm\+Ul\+Map\+Ie} $>$ ns3\+::\+Uplink\+Scheduler\+Rtps\+::\+Get\+Uplink\+Allocations (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerRtps_af57c0819227d4d0690036b76c9f4c79c}{}\label{classns3_1_1UplinkSchedulerRtps_af57c0819227d4d0690036b76c9f4c79c}


Get uplink allocations. 

\begin{DoxyReturn}{Returns}
std\+::list$<$\+Ofdm\+Ul\+Map\+Ie$>$ 
\end{DoxyReturn}


Reimplemented from \hyperlink{classns3_1_1UplinkScheduler_a7170d8d32d3af5c07febafc2c6712f8c}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
84 \{
85   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1UplinkSchedulerRtps_a4cb3da7f31082b64a21b7f9adc7fd2e4}{m\_uplinkAllocations};
86 \}
\end{DoxyCode}
\index{ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}!Init\+Once@{Init\+Once}}
\index{Init\+Once@{Init\+Once}!ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}}
\subsubsection[{\texorpdfstring{Init\+Once(void)}{InitOnce(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+Rtps\+::\+Init\+Once (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerRtps_ac712136e3b5f7e856daba25d7a946747}{}\label{classns3_1_1UplinkSchedulerRtps_ac712136e3b5f7e856daba25d7a946747}


Init once function. 



Implements \hyperlink{classns3_1_1UplinkScheduler_ae427e6144919f70a361c047ddcfd5c4c}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
705 \{
706 \}
\end{DoxyCode}
\index{ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}!On\+Set\+Requested\+Bandwidth@{On\+Set\+Requested\+Bandwidth}}
\index{On\+Set\+Requested\+Bandwidth@{On\+Set\+Requested\+Bandwidth}!ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}}
\subsubsection[{\texorpdfstring{On\+Set\+Requested\+Bandwidth(\+Service\+Flow\+Record $\ast$sfr)}{OnSetRequestedBandwidth(ServiceFlowRecord *sfr)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+Rtps\+::\+On\+Set\+Requested\+Bandwidth (
\begin{DoxyParamCaption}
\item[{{\bf Service\+Flow\+Record} $\ast$}]{sfr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerRtps_ad6e66597b048a59cb95ea3c620b59c2c}{}\label{classns3_1_1UplinkSchedulerRtps_ad6e66597b048a59cb95ea3c620b59c2c}
Set requested bandwidth function 
\begin{DoxyParams}{Parameters}
{\em sfr} & the service flow record \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1UplinkScheduler_a7bd17c3434380b9a57f8dcae6f4f289c}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
715 \{
716   \textcolor{comment}{// m\_grantedBandwidth must be reset to zero}
717   uint32\_t grantedBandwidth = 0;
718   sfr->SetGrantedBandwidth (grantedBandwidth);
719 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13


\index{ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}!Process\+Bandwidth\+Request@{Process\+Bandwidth\+Request}}
\index{Process\+Bandwidth\+Request@{Process\+Bandwidth\+Request}!ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}}
\subsubsection[{\texorpdfstring{Process\+Bandwidth\+Request(const Bandwidth\+Request\+Header \&bw\+Request\+Hdr)}{ProcessBandwidthRequest(const BandwidthRequestHeader &bwRequestHdr)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+Rtps\+::\+Process\+Bandwidth\+Request (
\begin{DoxyParamCaption}
\item[{const {\bf Bandwidth\+Request\+Header} \&}]{bw\+Request\+Hdr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerRtps_a8acb9d916577dae3c671c3aa67b1ce48}{}\label{classns3_1_1UplinkSchedulerRtps_a8acb9d916577dae3c671c3aa67b1ce48}
Process bandwidth requet function 
\begin{DoxyParams}{Parameters}
{\em bw\+Request\+Hdr} & the bandwidth request header \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1UplinkScheduler_afca8bc8fcb079d7ee97c1d1f14a0ee2f}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
710 \{
711 \}
\end{DoxyCode}
\index{ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}!Schedule@{Schedule}}
\index{Schedule@{Schedule}!ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}}
\subsubsection[{\texorpdfstring{Schedule(void)}{Schedule(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+Rtps\+::\+Schedule (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerRtps_a3863d85ca853d4b8b1033a38d0ff9dcd}{}\label{classns3_1_1UplinkSchedulerRtps_a3863d85ca853d4b8b1033a38d0ff9dcd}


Schedule function. 



Implements \hyperlink{classns3_1_1UplinkScheduler_a36fc5c58146f1fb828f21f109cb1634c}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
165 \{
166   \hyperlink{classns3_1_1UplinkSchedulerRtps_a4cb3da7f31082b64a21b7f9adc7fd2e4}{m\_uplinkAllocations}.clear ();
167   \hyperlink{classns3_1_1UplinkScheduler_a3eee0d06486678eab4d352a274676d95}{SetIsIrIntrvlAllocated} (\textcolor{keyword}{false});
168   \hyperlink{classns3_1_1UplinkScheduler_a766e3b6c032052002929eb351934e42b}{SetIsInvIrIntrvlAllocated} (\textcolor{keyword}{false});
169   \textcolor{keywordtype}{bool} allocationForDsa = \textcolor{keyword}{false};
170 
171   uint32\_t symbolsToAllocation = 0;
172   uint32\_t allocationSize = 0; \textcolor{comment}{// size in symbols}
173   uint32\_t availableSymbols = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetNrUlSymbols ();
174 
175   \hyperlink{classns3_1_1WimaxPhy_a044c5d8a48ca992c39c2a946f6e755fa}{WimaxPhy::ModulationType} modulationType;
176   Cid cid;
177 
178   \hyperlink{classns3_1_1UplinkSchedulerRtps_adc340ccabe8e7dcaec455bdfd111d632}{AllocateInitialRangingInterval} (symbolsToAllocation, availableSymbols);
179 
180   std::vector<SSRecord*> *ssRecords = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetSSManager ()->GetSSRecords ();
181   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"UL Scheduler start, availableSymbols = "} << availableSymbols);
182 
183   \textcolor{keywordflow}{for} (std::vector<SSRecord*>::iterator iter = ssRecords->begin (); iter != ssRecords->end (); ++iter)
184     \{
185       SSRecord *ssRecord = *iter;
186       \textcolor{keywordflow}{if} (ssRecord->GetIsBroadcastSS ())
187         \{
188           \textcolor{keywordflow}{continue};
189         \}
190       cid = ssRecord->GetBasicCid ();
191       OfdmUlMapIe ulMapIe;
192       ulMapIe.SetCid (cid);
193 
194       \textcolor{keywordflow}{if} (ssRecord->GetPollForRanging () && ssRecord->GetRangingStatus () == 
      \hyperlink{classns3_1_1WimaxNetDevice_a2a74c0f01e51abc1851a630242e7b591ace0a03105b6d7cf2c6ec79e9789dc3a6}{WimaxNetDevice::RANGING\_STATUS\_CONTINUE})
195         \{
196           \textcolor{comment}{// SS's ranging is not yet complete}
197           \textcolor{comment}{// allocating invited initial ranging interval}
198           ulMapIe.SetUiuc (\hyperlink{classns3_1_1OfdmUlBurstProfile_ae528783c4b3c6700ff49dfd7a555cb3daaea7b6256d4bcd0125f0248c0560c94e}{OfdmUlBurstProfile::UIUC\_INITIAL\_RANGING}
      );
199           allocationSize = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetRangReqOppSize ();
200           \hyperlink{classns3_1_1UplinkScheduler_a766e3b6c032052002929eb351934e42b}{SetIsInvIrIntrvlAllocated} (\textcolor{keyword}{true});
201 
202           \textcolor{keywordflow}{if} (availableSymbols >= allocationSize)
203             \{
204               \hyperlink{classns3_1_1UplinkSchedulerRtps_aea8d8f5701bf3b5f992d1b43471340d2}{AddUplinkAllocation} (ulMapIe, allocationSize, symbolsToAllocation, 
      availableSymbols);
205             \}
206           \textcolor{keywordflow}{else}
207             \{
208               \textcolor{keywordflow}{break};
209             \}
210         \}
211       \textcolor{keywordflow}{else}
212         \{
213           modulationType = ssRecord->GetModulationType ();
214 
215           \textcolor{comment}{// need to update because modulation/FEC to UIUC mapping may vary over time}
216           ulMapIe.SetUiuc (\hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetBurstProfileManager ()->GetBurstProfile (modulationType,
217                                                                                  
      \hyperlink{classns3_1_1WimaxNetDevice_a194b6cf7eb59582328eb2531dc9ed884ad37a477621d1df190ff8d8fb933349cd}{WimaxNetDevice::DIRECTION\_UPLINK}));
218 
219           \textcolor{comment}{// establish service flows for SS}
220           \textcolor{keywordflow}{if} (ssRecord->GetRangingStatus () == 
      \hyperlink{classns3_1_1WimaxNetDevice_a2a74c0f01e51abc1851a630242e7b591a2a48f503c20971a1a5901af0b6d0746c}{WimaxNetDevice::RANGING\_STATUS\_SUCCESS}
221               && !ssRecord->GetAreServiceFlowsAllocated ())
222             \{
223               \textcolor{comment}{// allocating grant (with arbitrary size) to allow SS to send DSA messages DSA-REQ and
       DSA-ACK}
224               \textcolor{comment}{// only one DSA allocation per frame}
225               \textcolor{keywordflow}{if} (!allocationForDsa)
226                 \{
227                   allocationSize = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetNrSymbols (\textcolor{keyword}{sizeof}(DsaReq), modulationType);
228                   \textcolor{keywordflow}{if} (availableSymbols >= allocationSize)
229                     \{
230                       \hyperlink{classns3_1_1UplinkSchedulerRtps_aea8d8f5701bf3b5f992d1b43471340d2}{AddUplinkAllocation} (ulMapIe, allocationSize, symbolsToAllocation,
       availableSymbols);
231                       allocationForDsa = \textcolor{keyword}{true};
232                     \}
233                   \textcolor{keywordflow}{else}
234                     \{
235                       \textcolor{keywordflow}{break};
236                     \}
237                 \}
238             \}
239           \textcolor{keywordflow}{else}
240             \{
241               \textcolor{comment}{// all service flows associated to SS are established now}
242 
243               \textcolor{comment}{/*allocating grants for data transmission for UGS flows (Data Grant Burst Type IEs,
       6.3.7.4.3.3)}
244 \textcolor{comment}{               (grant has been referred by different names e.g. transmission opportunity, slot, uplink
       allocation, etc)*/}
245               \hyperlink{classns3_1_1UplinkSchedulerRtps_ab101ce69266831aad941b4c553d82026}{ServiceUnsolicitedGrants} (ssRecord,
246                                         \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a969e0b62fa12fef1dbb23913744ed594}{ServiceFlow::SF\_TYPE\_UGS},
247                                         ulMapIe,
248                                         modulationType,
249                                         symbolsToAllocation,
250                                         availableSymbols);
251 
252               \textcolor{comment}{// allocate unicast polls for rtPS flows if bandwidth is available}
253               \textcolor{keywordflow}{if} (availableSymbols)
254                 \{
255                   \hyperlink{classns3_1_1UplinkSchedulerRtps_ab101ce69266831aad941b4c553d82026}{ServiceUnsolicitedGrants} (ssRecord,
256                                             \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a0e98ff713b932a029acad7e5b24bbf55}{ServiceFlow::SF\_TYPE\_RTPS},
257                                             ulMapIe,
258                                             modulationType,
259                                             symbolsToAllocation,
260                                             availableSymbols);
261                 \}
262               \textcolor{comment}{// allocate unicast polls for nrtPS flows if bandwidth is available}
263               \textcolor{keywordflow}{if} (availableSymbols)
264                 \{
265                   \hyperlink{classns3_1_1UplinkSchedulerRtps_ab101ce69266831aad941b4c553d82026}{ServiceUnsolicitedGrants} (ssRecord,
266                                             \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a7f8577f851a9f01d159442a3a3fcdf48}{ServiceFlow::SF\_TYPE\_NRTPS},
267                                             ulMapIe,
268                                             modulationType,
269                                             symbolsToAllocation,
270                                             availableSymbols);
271                 \}
272               \textcolor{comment}{// finally allocate unicast polls for BE flows if bandwidth is available}
273               \textcolor{keywordflow}{if} (availableSymbols)
274                 \{
275                   \hyperlink{classns3_1_1UplinkSchedulerRtps_ab101ce69266831aad941b4c553d82026}{ServiceUnsolicitedGrants} (ssRecord,
276                                             \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235af93a8bd8fce654e688f957f6f362e5c7}{ServiceFlow::SF\_TYPE\_BE},
277                                             ulMapIe,
278                                             modulationType,
279                                             symbolsToAllocation,
280                                             availableSymbols);
281                 \}
282             \}
283         \}
284     \}
285 
286   \textcolor{comment}{/*}
287 \textcolor{comment}{   * Uplink Scheduler for rtPS Connection}
288 \textcolor{comment}{   */}
289   \textcolor{keywordflow}{if} (availableSymbols)
290     \{
291       \hyperlink{classns3_1_1UplinkSchedulerRtps_aee60dd2773cd1404f6efe04373b567ea}{ULSchedulerRTPSConnection} (symbolsToAllocation, availableSymbols);
292     \}
293 
294   \textcolor{comment}{// UL Scheduler for nrtPS and BE flows}
295   \textcolor{keywordflow}{if} (availableSymbols)
296     \{
297       \textcolor{keywordflow}{for} (std::vector<SSRecord*>::iterator iter = ssRecords->begin (); iter != ssRecords->end (); ++iter)
298         \{
299           SSRecord *ssRecord = *iter;
300           \textcolor{keywordflow}{if} (ssRecord->GetIsBroadcastSS ())
301             \{
302               \textcolor{keywordflow}{continue};
303             \}
304           \textcolor{keywordflow}{if} (!ssRecord->GetPollForRanging () && ssRecord->GetRangingStatus ()
305               != \hyperlink{classns3_1_1WimaxNetDevice_a2a74c0f01e51abc1851a630242e7b591ace0a03105b6d7cf2c6ec79e9789dc3a6}{WimaxNetDevice::RANGING\_STATUS\_CONTINUE} && ssRecord
      ->GetAreServiceFlowsAllocated ())
306             \{
307               OfdmUlMapIe ulMapIe;
308               cid = ssRecord->GetBasicCid ();
309               ulMapIe.SetCid (cid);
310               modulationType = ssRecord->GetModulationType ();
311               ulMapIe.SetUiuc (\hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetBurstProfileManager ()->GetBurstProfile (modulationType,
312                                                                                      
      \hyperlink{classns3_1_1WimaxNetDevice_a194b6cf7eb59582328eb2531dc9ed884ad37a477621d1df190ff8d8fb933349cd}{WimaxNetDevice::DIRECTION\_UPLINK}));
313 
314               \textcolor{comment}{// allocate unicast polls for nrtPS flows if bandwidth is available}
315               \textcolor{keywordflow}{if} (availableSymbols)
316                 \{
317                   \hyperlink{classns3_1_1UplinkSchedulerRtps_a35d16645e1db685e5df2b5fc7527f5de}{ServiceBandwidthRequests} (ssRecord,
318                                             \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a7f8577f851a9f01d159442a3a3fcdf48}{ServiceFlow::SF\_TYPE\_NRTPS},
319                                             ulMapIe,
320                                             modulationType,
321                                             symbolsToAllocation,
322                                             availableSymbols);
323                 \}
324               \textcolor{comment}{// finally allocate unicast polls for BE flows if bandwidth is available}
325               \textcolor{keywordflow}{if} (availableSymbols)
326                 \{
327                   \hyperlink{classns3_1_1UplinkSchedulerRtps_a35d16645e1db685e5df2b5fc7527f5de}{ServiceBandwidthRequests} (ssRecord,
328                                             \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235af93a8bd8fce654e688f957f6f362e5c7}{ServiceFlow::SF\_TYPE\_BE},
329                                             ulMapIe,
330                                             modulationType,
331                                             symbolsToAllocation,
332                                             availableSymbols);
333                 \}
334             \}
335         \}
336     \}
337 
338   OfdmUlMapIe ulMapIeEnd;
339   ulMapIeEnd.SetCid (\hyperlink{classns3_1_1Cid_a5c204ab0df783c7594c764bae1611436}{Cid::InitialRanging} ());
340   ulMapIeEnd.SetStartTime (symbolsToAllocation);
341   ulMapIeEnd.SetUiuc (\hyperlink{classns3_1_1OfdmUlBurstProfile_ae528783c4b3c6700ff49dfd7a555cb3dabef491e8d426af16beba1541b947b7e9}{OfdmUlBurstProfile::UIUC\_END\_OF\_MAP});
342   ulMapIeEnd.SetDuration (0);
343   \hyperlink{classns3_1_1UplinkSchedulerRtps_a4cb3da7f31082b64a21b7f9adc7fd2e4}{m\_uplinkAllocations}.push\_back (ulMapIeEnd);
344 
345   \textcolor{comment}{// setting DL/UL subframe allocation for the next frame}
346   \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetBandwidthManager ()->SetSubframeRatio ();
347 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 14


\index{ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}!Service\+Bandwidth\+Requests@{Service\+Bandwidth\+Requests}}
\index{Service\+Bandwidth\+Requests@{Service\+Bandwidth\+Requests}!ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}}
\subsubsection[{\texorpdfstring{Service\+Bandwidth\+Requests(const S\+S\+Record $\ast$ss\+Record, enum Service\+Flow\+::\+Scheduling\+Type scheduling\+Type, Ofdm\+Ul\+Map\+Ie \&ul\+Map\+Ie, const Wimax\+Phy\+::\+Modulation\+Type modulation\+Type, uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)}{ServiceBandwidthRequests(const SSRecord *ssRecord, enum ServiceFlow::SchedulingType schedulingType, OfdmUlMapIe &ulMapIe, const WimaxPhy::ModulationType modulationType, uint32_t &symbolsToAllocation, uint32_t &availableSymbols)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+Rtps\+::\+Service\+Bandwidth\+Requests (
\begin{DoxyParamCaption}
\item[{const {\bf S\+S\+Record} $\ast$}]{ss\+Record, }
\item[{enum {\bf Service\+Flow\+::\+Scheduling\+Type}}]{scheduling\+Type, }
\item[{{\bf Ofdm\+Ul\+Map\+Ie} \&}]{ul\+Map\+Ie, }
\item[{const {\bf Wimax\+Phy\+::\+Modulation\+Type}}]{modulation\+Type, }
\item[{uint32\+\_\+t \&}]{symbols\+To\+Allocation, }
\item[{uint32\+\_\+t \&}]{available\+Symbols}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerRtps_a35d16645e1db685e5df2b5fc7527f5de}{}\label{classns3_1_1UplinkSchedulerRtps_a35d16645e1db685e5df2b5fc7527f5de}
Service Bandwidth Requests function 
\begin{DoxyParams}{Parameters}
{\em ss\+Record} & Subscriber station record \\
\hline
{\em scheduling\+Type} & the scheduling type \\
\hline
{\em ul\+Map\+Ie} & the UL map IE \\
\hline
{\em modulation\+Type} & the modulation type \\
\hline
{\em symbols\+To\+Allocation} & the symbols to allocation \\
\hline
{\em available\+Symbols} & the available symbols \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1UplinkScheduler_ae6bbcbf3cae55770d0f100692e8af16b}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
436 \{
437   std::vector<ServiceFlow*> serviceFlows = ssRecord->GetServiceFlows (schedulingType);
438 
439   \textcolor{keywordflow}{for} (std::vector<ServiceFlow*>::iterator iter = serviceFlows.begin (); iter != serviceFlows.end (); ++
      iter)
440     \{
441       \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1UplinkSchedulerRtps_a35d16645e1db685e5df2b5fc7527f5de}{ServiceBandwidthRequests} (*iter,
442                                      schedulingType,
443                                      ulMapIe,
444                                      modulationType,
445                                      symbolsToAllocation,
446                                      availableSymbols))
447         \{
448           \textcolor{keywordflow}{break};
449         \}
450     \}
451 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 15




Here is the caller graph for this function\+:
% FIG 16


\index{ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}!Service\+Bandwidth\+Requests@{Service\+Bandwidth\+Requests}}
\index{Service\+Bandwidth\+Requests@{Service\+Bandwidth\+Requests}!ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}}
\subsubsection[{\texorpdfstring{Service\+Bandwidth\+Requests(\+Service\+Flow $\ast$service\+Flow, enum Service\+Flow\+::\+Scheduling\+Type scheduling\+Type, Ofdm\+Ul\+Map\+Ie \&ul\+Map\+Ie, const Wimax\+Phy\+::\+Modulation\+Type modulation\+Type, uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)}{ServiceBandwidthRequests(ServiceFlow *serviceFlow, enum ServiceFlow::SchedulingType schedulingType, OfdmUlMapIe &ulMapIe, const WimaxPhy::ModulationType modulationType, uint32_t &symbolsToAllocation, uint32_t &availableSymbols)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Uplink\+Scheduler\+Rtps\+::\+Service\+Bandwidth\+Requests (
\begin{DoxyParamCaption}
\item[{{\bf Service\+Flow} $\ast$}]{service\+Flow, }
\item[{enum {\bf Service\+Flow\+::\+Scheduling\+Type}}]{scheduling\+Type, }
\item[{{\bf Ofdm\+Ul\+Map\+Ie} \&}]{ul\+Map\+Ie, }
\item[{const {\bf Wimax\+Phy\+::\+Modulation\+Type}}]{modulation\+Type, }
\item[{uint32\+\_\+t \&}]{symbols\+To\+Allocation, }
\item[{uint32\+\_\+t \&}]{available\+Symbols}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerRtps_a0aa40f551a0bf51ca2197ff85190f572}{}\label{classns3_1_1UplinkSchedulerRtps_a0aa40f551a0bf51ca2197ff85190f572}
Service bandwidth requests function 
\begin{DoxyParams}{Parameters}
{\em service\+Flow} & the service flow \\
\hline
{\em scheduling\+Type} & the scheduling type \\
\hline
{\em ul\+Map\+Ie} & the UL map IE \\
\hline
{\em modulation\+Type} & the modulation type \\
\hline
{\em symbols\+To\+Allocation} & the symbols to allocation \\
\hline
{\em available\+Symbols} & the available symbols \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if successful 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1UplinkScheduler_a6e702b7f0bdb490a762b5e2b9b13c362}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
460 \{
461   uint32\_t allocSizeBytes = 0;
462   uint32\_t allocSizeSymbols = 0;
463   uint16\_t sduSize = 0;
464 
465   ServiceFlowRecord *record = serviceFlow->GetRecord ();
466   sduSize = serviceFlow->GetSduSize ();
467 
468   uint32\_t requiredBandwidth = record->GetRequestedBandwidth () - record->GetGrantedBandwidth ();
469   \textcolor{keywordflow}{if} (requiredBandwidth > 0)
470     \{
471       \textcolor{keywordflow}{if} (sduSize > 0)
472         \{
473           \textcolor{comment}{// if SDU size is mentioned, allocate grant of that size}
474           allocSizeBytes = sduSize;
475           allocSizeSymbols = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetNrSymbols (sduSize, modulationType);
476         \}
477       \textcolor{keywordflow}{else}
478         \{
479           allocSizeBytes = requiredBandwidth;
480           allocSizeSymbols = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetNrSymbols (requiredBandwidth, modulationType);
481         \}
482 
483       \textcolor{keywordflow}{if} (availableSymbols >= allocSizeSymbols)
484         \{
485 
486           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"BS uplink scheduler, "} << serviceFlow->GetSchedulingTypeStr () << \textcolor{stringliteral}{"
       allocation, size: "}
487                                                 << allocSizeSymbols << \textcolor{stringliteral}{" symbols"} << \textcolor{stringliteral}{", CID: "} << 
      serviceFlow->GetConnection ()->GetCid () << \textcolor{stringliteral}{", SFID: "}
488                                                 << serviceFlow->GetSfid () << \textcolor{stringliteral}{", bw requested: "} << record
      ->GetRequestedBandwidth () << \textcolor{stringliteral}{", bw granted: "}
489                                                 << record->GetGrantedBandwidth ());
490 
491           record->UpdateGrantedBandwidth (allocSizeBytes);
492 
493           \textcolor{keywordflow}{if} (schedulingType == \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a7f8577f851a9f01d159442a3a3fcdf48}{ServiceFlow::SF\_TYPE\_NRTPS})
494             \{
495               record->SetBwSinceLastExpiry (allocSizeBytes);
496             \}
497 
498           \hyperlink{classns3_1_1UplinkSchedulerRtps_aea8d8f5701bf3b5f992d1b43471340d2}{AddUplinkAllocation} (ulMapIe, allocSizeSymbols, symbolsToAllocation, 
      availableSymbols);
499         \}
500       \textcolor{keywordflow}{else}
501         \{
502           \textcolor{keywordflow}{return} \textcolor{keyword}{false};
503         \}
504     \}
505   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
506 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 17


\index{ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}!Service\+Unsolicited\+Grants@{Service\+Unsolicited\+Grants}}
\index{Service\+Unsolicited\+Grants@{Service\+Unsolicited\+Grants}!ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}}
\subsubsection[{\texorpdfstring{Service\+Unsolicited\+Grants(const S\+S\+Record $\ast$ss\+Record, enum Service\+Flow\+::\+Scheduling\+Type scheduling\+Type, Ofdm\+Ul\+Map\+Ie \&ul\+Map\+Ie, const Wimax\+Phy\+::\+Modulation\+Type modulation\+Type, uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)}{ServiceUnsolicitedGrants(const SSRecord *ssRecord, enum ServiceFlow::SchedulingType schedulingType, OfdmUlMapIe &ulMapIe, const WimaxPhy::ModulationType modulationType, uint32_t &symbolsToAllocation, uint32_t &availableSymbols)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+Rtps\+::\+Service\+Unsolicited\+Grants (
\begin{DoxyParamCaption}
\item[{const {\bf S\+S\+Record} $\ast$}]{ss\+Record, }
\item[{enum {\bf Service\+Flow\+::\+Scheduling\+Type}}]{scheduling\+Type, }
\item[{{\bf Ofdm\+Ul\+Map\+Ie} \&}]{ul\+Map\+Ie, }
\item[{const {\bf Wimax\+Phy\+::\+Modulation\+Type}}]{modulation\+Type, }
\item[{uint32\+\_\+t \&}]{symbols\+To\+Allocation, }
\item[{uint32\+\_\+t \&}]{available\+Symbols}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerRtps_ab101ce69266831aad941b4c553d82026}{}\label{classns3_1_1UplinkSchedulerRtps_ab101ce69266831aad941b4c553d82026}
Service Unsolicited Grants function 
\begin{DoxyParams}{Parameters}
{\em ss\+Record} & Subscriber station record \\
\hline
{\em scheduling\+Type} & the scheduling type \\
\hline
{\em ul\+Map\+Ie} & the UL map IE \\
\hline
{\em modulation\+Type} & the modulation type \\
\hline
{\em symbols\+To\+Allocation} & the symbols to allocation \\
\hline
{\em available\+Symbols} & the available symbols \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1UplinkScheduler_ab0fb68e0b8923cbec983dbcffbe7a63f}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
356 \{
357   uint32\_t allocationSize = 0; \textcolor{comment}{// size in symbols}
358   uint8\_t uiuc = ulMapIe.GetUiuc (); \textcolor{comment}{// SS's burst profile}
359   std::vector<ServiceFlow*> serviceFlows = ssRecord->GetServiceFlows (schedulingType);
360 
361   \textcolor{keywordflow}{for} (std::vector<ServiceFlow*>::iterator iter = serviceFlows.begin (); iter != serviceFlows.end (); ++
      iter)
362     \{
363       ServiceFlow *serviceFlow = *iter;
364 
365       \textcolor{comment}{/* in case of rtPS, nrtPS and BE, allocating unicast polls for bandwidth requests (Request IEs,
       6.3.7.4.3.1).}
366 \textcolor{comment}{       in case of UGS, allocating grants for data transmission (Data Grant Burst Type IEs, 6.3.7.4.3.3)
       (grant has}
367 \textcolor{comment}{       been referred in this code by different names e.g. transmission opportunity, slot, allocation, etc) 
      */}
368 
369       allocationSize = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetBandwidthManager ()->CalculateAllocationSize (ssRecord, 
      serviceFlow);
370 
371       \textcolor{comment}{// verifying that minimum reserved traffic rate of nrtPS flow is maintained}
372       \textcolor{keywordflow}{if} (serviceFlow->GetSchedulingType () == \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a7f8577f851a9f01d159442a3a3fcdf48}{ServiceFlow::SF\_TYPE\_NRTPS})
373         \{
374           \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} currentTime = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ();
375           ServiceFlowRecord *record = serviceFlow->GetRecord ();
376           \textcolor{keywordflow}{if} (currentTime - record->GetGrantTimeStamp () > \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (1))
377             \{
378               uint32\_t bps = (record->GetBwSinceLastExpiry () * 8);
379               \textcolor{keywordflow}{if} (bps < serviceFlow->GetMinReservedTrafficRate ())
380                 \{
381                   \hyperlink{classns3_1_1UplinkSchedulerRtps_a35d16645e1db685e5df2b5fc7527f5de}{ServiceBandwidthRequests} (serviceFlow,
382                                             schedulingType,
383                                             ulMapIe,
384                                             modulationType,
385                                             symbolsToAllocation,
386                                             availableSymbols);
387                   record->SetBwSinceLastExpiry (0);
388                   record->SetGrantTimeStamp (currentTime);
389                 \}
390             \}
391         \}
392 
393       \textcolor{keywordflow}{if} (availableSymbols < allocationSize)
394         \{
395           \textcolor{keywordflow}{break};
396         \}
397 
398       \textcolor{keywordflow}{if} (allocationSize > 0)
399         \{
400           ulMapIe.SetStartTime (symbolsToAllocation);
401           \textcolor{keywordflow}{if} (serviceFlow->GetSchedulingType () != \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a969e0b62fa12fef1dbb23913744ed594}{ServiceFlow::SF\_TYPE\_UGS})
402             \{
403               \textcolor{comment}{// special burst profile with most robust modulation type is used for unicast polls (Request
       IEs)}
404               ulMapIe.SetUiuc (\hyperlink{classns3_1_1OfdmUlBurstProfile_ae528783c4b3c6700ff49dfd7a555cb3daae074d10caa7fe18da973227c7f9942f}{OfdmUlBurstProfile::UIUC\_REQ\_REGION\_FULL}
      );
405             \}
406         \}
407       \textcolor{keywordflow}{else}
408         \{
409           \textcolor{keywordflow}{continue};
410         \}
411 
412       \textcolor{keywordflow}{if} (serviceFlow->GetSchedulingType () == \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a969e0b62fa12fef1dbb23913744ed594}{ServiceFlow::SF\_TYPE\_UGS})
413         \{
414           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"BS uplink scheduler, UGS allocation, size: "} << allocationSize << \textcolor{stringliteral}{"
       symbols"});
415         \}
416       \textcolor{keywordflow}{else}
417         \{
418           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"BS uplink scheduler, "} << serviceFlow->GetSchedulingTypeStr () << \textcolor{stringliteral}{"
       unicast poll, size: "}
419                                                 << allocationSize << \textcolor{stringliteral}{" symbols"} << \textcolor{stringliteral}{", modulation: BPSK 1/2"}
      );
420         \}
421 
422       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{", CID: "} << serviceFlow->GetConnection ()->GetCid () << \textcolor{stringliteral}{", SFID: "} << 
      serviceFlow->GetSfid ());
423 
424       \hyperlink{classns3_1_1UplinkSchedulerRtps_aea8d8f5701bf3b5f992d1b43471340d2}{AddUplinkAllocation} (ulMapIe, allocationSize, symbolsToAllocation, 
      availableSymbols);
425       ulMapIe.SetUiuc (uiuc);
426     \}
427 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 18




Here is the caller graph for this function\+:
% FIG 19


\index{ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}!Setup\+Service\+Flow@{Setup\+Service\+Flow}}
\index{Setup\+Service\+Flow@{Setup\+Service\+Flow}!ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}}
\subsubsection[{\texorpdfstring{Setup\+Service\+Flow(\+S\+S\+Record $\ast$ss\+Record, Service\+Flow $\ast$service\+Flow)}{SetupServiceFlow(SSRecord *ssRecord, ServiceFlow *serviceFlow)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+Rtps\+::\+Setup\+Service\+Flow (
\begin{DoxyParamCaption}
\item[{{\bf S\+S\+Record} $\ast$}]{ss\+Record, }
\item[{{\bf Service\+Flow} $\ast$}]{service\+Flow}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1UplinkSchedulerRtps_ac44a9146c9928da245ebcf2c55a5c0d6}{}\label{classns3_1_1UplinkSchedulerRtps_ac44a9146c9928da245ebcf2c55a5c0d6}
Setup service flow function 
\begin{DoxyParams}{Parameters}
{\em ss\+Record} & Subscriber station record \\
\hline
{\em service\+Flow} & the service flow \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1UplinkScheduler_a101bce0939ff2315db3d2e3b75b4fed6}{ns3\+::\+Uplink\+Scheduler}.


\begin{DoxyCode}
643 \{
644   uint8\_t delayNrFrames = 1;
645   uint32\_t bitsPerSecond = serviceFlow->GetMinReservedTrafficRate ();
646   \hyperlink{classns3_1_1WimaxPhy_a044c5d8a48ca992c39c2a946f6e755fa}{WimaxPhy::ModulationType} modulation;
647   uint32\_t bytesPerFrame =
648     (uint32\_t ((\textcolor{keywordtype}{double})(bitsPerSecond) * \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetFrameDuration ().GetSeconds ())) / 8;
649   uint32\_t frameDurationMSec = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetFrameDuration ().GetMilliSeconds ();
650 
651   \textcolor{keywordflow}{switch} (serviceFlow->GetSchedulingType ())
652     \{
653     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a969e0b62fa12fef1dbb23913744ed594}{ServiceFlow::SF\_TYPE\_UGS}:
654       \{
655         \textcolor{keywordflow}{if} (serviceFlow->GetIsMulticast () == \textcolor{keyword}{true})
656           \{
657             modulation = serviceFlow->GetModulation ();
658           \}
659         \textcolor{keywordflow}{else}
660           \{
661             modulation = ssRecord->GetModulationType ();
662           \}
663         uint32\_t grantSize = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetNrSymbols (bytesPerFrame, modulation);
664         serviceFlow->GetRecord ()->SetGrantSize (grantSize);
665 
666         uint32\_t toleratedJitter = serviceFlow->GetToleratedJitter ();
667 
668         \textcolor{keywordflow}{if} (toleratedJitter > frameDurationMSec)
669           \{
670             delayNrFrames = (uint8\_t)(toleratedJitter / frameDurationMSec);
671           \}
672 
673         uint16\_t interval = delayNrFrames * frameDurationMSec;
674         serviceFlow->SetUnsolicitedGrantInterval (interval);
675       \}
676       \textcolor{keywordflow}{break};
677     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a0e98ff713b932a029acad7e5b24bbf55}{ServiceFlow::SF\_TYPE\_RTPS}:
678       \{
679         \textcolor{keywordflow}{if} (serviceFlow->GetSduSize () > bytesPerFrame)
680           \{
681             delayNrFrames = (uint8\_t)(serviceFlow->GetSduSize () / bytesPerFrame);
682           \}
683 
684         uint16\_t interval = delayNrFrames * frameDurationMSec;
685         serviceFlow->SetUnsolicitedPollingInterval (interval);
686       \}
687       \textcolor{keywordflow}{break};
688     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a7f8577f851a9f01d159442a3a3fcdf48}{ServiceFlow::SF\_TYPE\_NRTPS}:
689       \{
690         \textcolor{comment}{// no real-time guarantees are given to NRTPS, serviced based on available bandwidth}
691       \}
692       \textcolor{keywordflow}{break};
693     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235af93a8bd8fce654e688f957f6f362e5c7}{ServiceFlow::SF\_TYPE\_BE}:
694       \{
695         \textcolor{comment}{// no real-time guarantees are given to BE, serviced based on available bandwidth}
696       \}
697       \textcolor{keywordflow}{break};
698     \textcolor{keywordflow}{default}:
699       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Invalid scheduling type"});
700     \}
701 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 20


\index{ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}!U\+L\+Scheduler\+R\+T\+P\+S\+Connection@{U\+L\+Scheduler\+R\+T\+P\+S\+Connection}}
\index{U\+L\+Scheduler\+R\+T\+P\+S\+Connection@{U\+L\+Scheduler\+R\+T\+P\+S\+Connection}!ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}}
\subsubsection[{\texorpdfstring{U\+L\+Scheduler\+R\+T\+P\+S\+Connection(uint32\+\_\+t \&symbols\+To\+Allocation, uint32\+\_\+t \&available\+Symbols)}{ULSchedulerRTPSConnection(uint32_t &symbolsToAllocation, uint32_t &availableSymbols)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Uplink\+Scheduler\+Rtps\+::\+U\+L\+Scheduler\+R\+T\+P\+S\+Connection (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t \&}]{symbols\+To\+Allocation, }
\item[{uint32\+\_\+t \&}]{available\+Symbols}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1UplinkSchedulerRtps_aee60dd2773cd1404f6efe04373b567ea}{}\label{classns3_1_1UplinkSchedulerRtps_aee60dd2773cd1404f6efe04373b567ea}


Uplink \hyperlink{classns3_1_1Scheduler}{Scheduler} for rt\+PS connections. 


\begin{DoxyParams}{Parameters}
{\em symbols\+To\+Allocation} & symbols to allocation for Up\+Link Subframe \\
\hline
{\em available\+Symbols} & available symbols for rt\+PS flows\\
\hline
\end{DoxyParams}
This method represent the UL \hyperlink{classns3_1_1Scheduler}{Scheduler} for rt\+PS connections. The scheduler is designed to serve all rt\+PS connections that have at least one packet to transmit, every UL Subframe. The methos selects all rt\+PS connection that have al least one packet to transmit. To each rt\+PS connections are allocated, at the beginning, the bandwidth to transmit a quota of data equal to (Requested\+Bandwidth -\/ Granted\+Bandwidth). If the sum of all pre-\/allocated bandwidth exceed the available symbols for rt\+PS connections, the \hyperlink{classns3_1_1Channel}{Channel} Saturation Control function is called to redistribute the available bandwidth. 
\begin{DoxyCode}
510 \{
511   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)tUL Scheduler for rtPS flows"});
512   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)t\(\backslash\)tavailableSymbols = "} << availableSymbols);
513   ServiceFlowRecord *record\_[100];
514   uint32\_t allocSizeSymbols\_[100]; \textcolor{comment}{// symbolsRequired for each SSRecord}
515   OfdmUlMapIe ulMapIe\_[100];
516   OfdmUlMapIe ulMapIe;
517   \hyperlink{classns3_1_1WimaxPhy_a044c5d8a48ca992c39c2a946f6e755fa}{WimaxPhy::ModulationType} modulationType\_[100];
518   \hyperlink{classns3_1_1WimaxPhy_a044c5d8a48ca992c39c2a946f6e755fa}{WimaxPhy::ModulationType} modulationType;
519   \textcolor{keywordtype}{int} nbAllocation = 0;
520   uint32\_t allocSizeBytes;
521   uint32\_t totAllocSizeSymbols = 0;
522 
523   Cid cid;
524   std::vector<SSRecord*> *ssRecords = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetSSManager ()->GetSSRecords ();
525 
526   \textcolor{keywordflow}{for} (std::vector<SSRecord*>::iterator iter = ssRecords->begin (); iter != ssRecords->end (); ++iter)
527     \{
528       SSRecord *ssRecord = *iter;
529       \textcolor{keywordflow}{if} (ssRecord->GetIsBroadcastSS ())
530         \{
531           \textcolor{keywordflow}{continue};
532         \}
533       \textcolor{keywordflow}{if} (!ssRecord->GetPollForRanging () && ssRecord->GetRangingStatus () != 
      \hyperlink{classns3_1_1WimaxNetDevice_a2a74c0f01e51abc1851a630242e7b591ace0a03105b6d7cf2c6ec79e9789dc3a6}{WimaxNetDevice::RANGING\_STATUS\_CONTINUE}
534           && ssRecord->GetAreServiceFlowsAllocated ())
535         \{
536           cid = ssRecord->GetBasicCid ();
537           ulMapIe.SetCid (cid);
538           modulationType = ssRecord->GetModulationType ();
539           ulMapIe.SetUiuc (\hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetBurstProfileManager ()->GetBurstProfile (modulationType,
540                                                                                  
      \hyperlink{classns3_1_1WimaxNetDevice_a194b6cf7eb59582328eb2531dc9ed884ad37a477621d1df190ff8d8fb933349cd}{WimaxNetDevice::DIRECTION\_UPLINK}));
541 
542           std::vector<ServiceFlow*> serviceFlows = ssRecord->GetServiceFlows (
      \hyperlink{classns3_1_1ServiceFlow_a7990ba10be1e098328fd1e6382a26235a0e98ff713b932a029acad7e5b24bbf55}{ServiceFlow::SF\_TYPE\_RTPS});
543           \textcolor{keywordflow}{for} (std::vector<ServiceFlow*>::iterator iter2 = serviceFlows.begin (); iter2 != serviceFlows.end
       (); ++iter2)
544             \{
545               record\_[nbAllocation] = (*iter2)->GetRecord ();
546               uint32\_t requiredBandwidth = record\_[nbAllocation]->GetRequestedBandwidth ()
547                 - record\_[nbAllocation]->GetGrantedBandwidth ();
548 
549               \textcolor{keywordflow}{if} (requiredBandwidth > 0)
550                 \{
551                   modulationType\_[nbAllocation] = modulationType;
552                   ulMapIe\_[nbAllocation] = ulMapIe;
553                   allocSizeBytes = requiredBandwidth;
554                   allocSizeSymbols\_[nbAllocation] = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetNrSymbols (allocSizeBytes,
555                                                                                        modulationType\_[
      nbAllocation]);
556                   totAllocSizeSymbols += allocSizeSymbols\_[nbAllocation];
557 
558                   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)t\(\backslash\)tUL Scheduler for CID = "} << (*iter2)->GetConnection ()->
      GetCid ());
559                   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)t\(\backslash\)t\(\backslash\)trequiredBandwidth = "} << record\_[nbAllocation]->
      GetRequestedBandwidth ()
560                                                             << \textcolor{stringliteral}{", allocSizeSymbols = "} << allocSizeSymbols\_
      [nbAllocation] << \textcolor{stringliteral}{", modulationType = "}
561                                                             << modulationType\_[nbAllocation]);
562 
563                   nbAllocation += 1;
564                 \}
565             \}
566         \}
567     \}
568 
569   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)t\(\backslash\)ttotAllocSizeSymbols = "} << totAllocSizeSymbols);
570 
571   \textcolor{comment}{// Channel Saturation}
572   \textcolor{keywordflow}{while} (totAllocSizeSymbols > availableSymbols)
573     \{
574       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)tUL Channel Saturation: totAllocSizeSymbols > availableSymbols"});
575       \textcolor{keywordtype}{double} delta = double(availableSymbols) / double(totAllocSizeSymbols);
576       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)t\(\backslash\)tdelta = "} << delta);
577       totAllocSizeSymbols = 0;
578       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < nbAllocation; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
579         \{
580           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)t\(\backslash\)tprevious allocSizeSymbols\_["} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} << \textcolor{stringliteral}{"] = "} << allocSizeSymbols\_[
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}]);
581           allocSizeSymbols\_[\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}] = (uint32\_t) std::floor (allocSizeSymbols\_[\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}] * delta);
582           totAllocSizeSymbols += allocSizeSymbols\_[\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}];
583           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)t\(\backslash\)tnew allocSizeSymbols\_["} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} << \textcolor{stringliteral}{"] = "} << allocSizeSymbols\_[
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}]);
584         \}
585       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)t\(\backslash\)ttotAllocSizeSymbols = "} << totAllocSizeSymbols);
586     \}
587 
588   \textcolor{comment}{// Uplink Bandwidth Allocation}
589   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < nbAllocation; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
590     \{
591       \hyperlink{classns3_1_1UplinkSchedulerRtps_aea8d8f5701bf3b5f992d1b43471340d2}{AddUplinkAllocation} (ulMapIe\_[\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}], allocSizeSymbols\_[i], symbolsToAllocation, 
      availableSymbols);
592       allocSizeBytes = \hyperlink{classns3_1_1UplinkScheduler_afe61b7de71d92d2dff1b135744a6ff7e}{GetBs} ()->GetPhy ()->GetNrBytes (allocSizeSymbols\_[\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}], modulationType\_[i]);
593       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)t\(\backslash\)tUpdateGrantedBandwidth for "} << i << \textcolor{stringliteral}{" = "} << allocSizeBytes);
594       \textcolor{keywordflow}{if} (record\_[i]->GetRequestedBandwidth () < allocSizeBytes)
595         \{
596           \textcolor{comment}{// the flow need new poll to set the newer requredBandwidth}
597           record\_[\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}]->SetGrantedBandwidth (0);
598           record\_[\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}]->SetRequestedBandwidth (0);
599         \}
600       \textcolor{keywordflow}{else}
601         \{
602           record\_[\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}]->UpdateGrantedBandwidth (allocSizeBytes);
603         \}
604     \}
605 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 21




Here is the caller graph for this function\+:
% FIG 22




\subsection{Member Data Documentation}
\index{ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}!m\+\_\+uplink\+Allocations@{m\+\_\+uplink\+Allocations}}
\index{m\+\_\+uplink\+Allocations@{m\+\_\+uplink\+Allocations}!ns3\+::\+Uplink\+Scheduler\+Rtps@{ns3\+::\+Uplink\+Scheduler\+Rtps}}
\subsubsection[{\texorpdfstring{m\+\_\+uplink\+Allocations}{m_uplinkAllocations}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std\+::list}$<${\bf Ofdm\+Ul\+Map\+Ie}$>$ ns3\+::\+Uplink\+Scheduler\+Rtps\+::m\+\_\+uplink\+Allocations\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1UplinkSchedulerRtps_a4cb3da7f31082b64a21b7f9adc7fd2e4}{}\label{classns3_1_1UplinkSchedulerRtps_a4cb3da7f31082b64a21b7f9adc7fd2e4}


uplink allocations 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
wimax/model/\hyperlink{bs-uplink-scheduler-rtps_8h}{bs-\/uplink-\/scheduler-\/rtps.\+h}\item 
wimax/model/\hyperlink{bs-uplink-scheduler-rtps_8cc}{bs-\/uplink-\/scheduler-\/rtps.\+cc}\end{DoxyCompactItemize}
