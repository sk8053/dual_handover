\hypertarget{classIpv4ARouting}{}\section{Ipv4\+A\+Routing Class Reference}
\label{classIpv4ARouting}\index{Ipv4\+A\+Routing@{Ipv4\+A\+Routing}}


I\+Pv4 dummy routing class (A)  




Inheritance diagram for Ipv4\+A\+Routing\+:
% FIG 0


Collaboration diagram for Ipv4\+A\+Routing\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ \hyperlink{classIpv4ARouting_a13ea767139cc112214566ccb9862c412}{Route\+Output} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ oif, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket\+::\+Socket\+Errno} \&sockerr)
\begin{DoxyCompactList}\small\item\em Query routing cache for an existing route, for an outbound packet. \end{DoxyCompactList}\item 
bool \hyperlink{classIpv4ARouting_a1cbe114fd34ed6681645ba469d52b8fe}{Route\+Input} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ idev, \hyperlink{classns3_1_1Ipv4RoutingProtocol_a3453a85764cbbb1e704da7e919aa5d19}{Unicast\+Forward\+Callback} ucb, \hyperlink{classns3_1_1Ipv4RoutingProtocol_a26e76f7a555462e6c08fceda64a99d58}{Multicast\+Forward\+Callback} mcb, \hyperlink{classns3_1_1Ipv4RoutingProtocol_aa6ffa0159cb143daa3c46d2ba69bb1b9}{Local\+Deliver\+Callback} lcb, \hyperlink{classns3_1_1Ipv4RoutingProtocol_a0348285418c30d5021b08f7a68af21ea}{Error\+Callback} ecb)
\begin{DoxyCompactList}\small\item\em Route an input packet (to be forwarded or locally delivered) \end{DoxyCompactList}\item 
void \hyperlink{classIpv4ARouting_a5ebb5358fb280a594ab6cc8434d4658f}{Notify\+Interface\+Up} (uint32\+\_\+t interface)
\item 
void \hyperlink{classIpv4ARouting_a6583e7d9c2373fe51d1c65689962fc4c}{Notify\+Interface\+Down} (uint32\+\_\+t interface)
\item 
void \hyperlink{classIpv4ARouting_ac523a0ca03a0349583e3ba8d80cbb649}{Notify\+Add\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} address)
\item 
void \hyperlink{classIpv4ARouting_aa976516ac37412365d98838718a1a09b}{Notify\+Remove\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} address)
\item 
void \hyperlink{classIpv4ARouting_af5adcc0186259a1d3f46bc12efd62f3b}{Set\+Ipv4} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$ ipv4)
\item 
void \hyperlink{classIpv4ARouting_ab78a61a72067edee90f0d1780cfa9044}{Print\+Routing\+Table} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream, \hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295a}{Time\+::\+Unit} unit) const 
\begin{DoxyCompactList}\small\item\em Print the Routing Table entries. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
I\+Pv4 dummy routing class (A) 

\subsection{Member Function Documentation}
\index{Ipv4\+A\+Routing@{Ipv4\+A\+Routing}!Notify\+Add\+Address@{Notify\+Add\+Address}}
\index{Notify\+Add\+Address@{Notify\+Add\+Address}!Ipv4\+A\+Routing@{Ipv4\+A\+Routing}}
\subsubsection[{\texorpdfstring{Notify\+Add\+Address(uint32\+\_\+t interface, Ipv4\+Interface\+Address address)}{NotifyAddAddress(uint32_t interface, Ipv4InterfaceAddress address)}}]{\setlength{\rightskip}{0pt plus 5cm}void Ipv4\+A\+Routing\+::\+Notify\+Add\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv4\+Interface\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{classIpv4ARouting_ac523a0ca03a0349583e3ba8d80cbb649}{}\label{classIpv4ARouting_ac523a0ca03a0349583e3ba8d80cbb649}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
{\em address} & a new address being added to an interface\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified whenever a new address is added to an interface. Typically used to add a \textquotesingle{}network route\textquotesingle{} on an interface. Can be invoked on an up or down interface. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_aef12fcf9cc478536876b0281505d40aa}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
40 \{\}
\end{DoxyCode}
\index{Ipv4\+A\+Routing@{Ipv4\+A\+Routing}!Notify\+Interface\+Down@{Notify\+Interface\+Down}}
\index{Notify\+Interface\+Down@{Notify\+Interface\+Down}!Ipv4\+A\+Routing@{Ipv4\+A\+Routing}}
\subsubsection[{\texorpdfstring{Notify\+Interface\+Down(uint32\+\_\+t interface)}{NotifyInterfaceDown(uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void Ipv4\+A\+Routing\+::\+Notify\+Interface\+Down (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{classIpv4ARouting_a6583e7d9c2373fe51d1c65689962fc4c}{}\label{classIpv4ARouting_a6583e7d9c2373fe51d1c65689962fc4c}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified of the state change of an interface in a node. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a90f728b73ccb1806e5a4093ff156f607}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
39 \{\}
\end{DoxyCode}
\index{Ipv4\+A\+Routing@{Ipv4\+A\+Routing}!Notify\+Interface\+Up@{Notify\+Interface\+Up}}
\index{Notify\+Interface\+Up@{Notify\+Interface\+Up}!Ipv4\+A\+Routing@{Ipv4\+A\+Routing}}
\subsubsection[{\texorpdfstring{Notify\+Interface\+Up(uint32\+\_\+t interface)}{NotifyInterfaceUp(uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void Ipv4\+A\+Routing\+::\+Notify\+Interface\+Up (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{classIpv4ARouting_a5ebb5358fb280a594ab6cc8434d4658f}{}\label{classIpv4ARouting_a5ebb5358fb280a594ab6cc8434d4658f}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified of the state change of an interface in a node. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_aabb99ce7a048e75ff4b36fa9af8745e4}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
38 \{\}
\end{DoxyCode}
\index{Ipv4\+A\+Routing@{Ipv4\+A\+Routing}!Notify\+Remove\+Address@{Notify\+Remove\+Address}}
\index{Notify\+Remove\+Address@{Notify\+Remove\+Address}!Ipv4\+A\+Routing@{Ipv4\+A\+Routing}}
\subsubsection[{\texorpdfstring{Notify\+Remove\+Address(uint32\+\_\+t interface, Ipv4\+Interface\+Address address)}{NotifyRemoveAddress(uint32_t interface, Ipv4InterfaceAddress address)}}]{\setlength{\rightskip}{0pt plus 5cm}void Ipv4\+A\+Routing\+::\+Notify\+Remove\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv4\+Interface\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{classIpv4ARouting_aa976516ac37412365d98838718a1a09b}{}\label{classIpv4ARouting_aa976516ac37412365d98838718a1a09b}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
{\em address} & a new address being added to an interface\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified whenever a new address is removed from an interface. Typically used to remove the \textquotesingle{}network route\textquotesingle{} of an interface. Can be invoked on an up or down interface. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a0160e49e509d6699ec837e5485f65cd2}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
41 \{\}
\end{DoxyCode}
\index{Ipv4\+A\+Routing@{Ipv4\+A\+Routing}!Print\+Routing\+Table@{Print\+Routing\+Table}}
\index{Print\+Routing\+Table@{Print\+Routing\+Table}!Ipv4\+A\+Routing@{Ipv4\+A\+Routing}}
\subsubsection[{\texorpdfstring{Print\+Routing\+Table(\+Ptr$<$ Output\+Stream\+Wrapper $>$ stream, Time\+::\+Unit unit) const }{PrintRoutingTable(Ptr< OutputStreamWrapper > stream, Time::Unit unit) const }}]{\setlength{\rightskip}{0pt plus 5cm}void Ipv4\+A\+Routing\+::\+Print\+Routing\+Table (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream, }
\item[{{\bf Time\+::\+Unit}}]{unit}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{classIpv4ARouting_ab78a61a72067edee90f0d1780cfa9044}{}\label{classIpv4ARouting_ab78a61a72067edee90f0d1780cfa9044}


Print the Routing Table entries. 


\begin{DoxyParams}{Parameters}
{\em stream} & The ostream the Routing table is printed to \\
\hline
{\em unit} & The time unit to be used in the report \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a86ad3fc1d17b06b6553a13b03d7e8cb4}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
43 \{\}
\end{DoxyCode}
\index{Ipv4\+A\+Routing@{Ipv4\+A\+Routing}!Route\+Input@{Route\+Input}}
\index{Route\+Input@{Route\+Input}!Ipv4\+A\+Routing@{Ipv4\+A\+Routing}}
\subsubsection[{\texorpdfstring{Route\+Input(\+Ptr$<$ const Packet $>$ p, const Ipv4\+Header \&header, Ptr$<$ const Net\+Device $>$ idev, Unicast\+Forward\+Callback ucb, Multicast\+Forward\+Callback mcb, Local\+Deliver\+Callback lcb, Error\+Callback ecb)}{RouteInput(Ptr< const Packet > p, const Ipv4Header &header, Ptr< const NetDevice > idev, UnicastForwardCallback ucb, MulticastForwardCallback mcb, LocalDeliverCallback lcb, ErrorCallback ecb)}}]{\setlength{\rightskip}{0pt plus 5cm}bool Ipv4\+A\+Routing\+::\+Route\+Input (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv4\+Header} \&}]{header, }
\item[{{\bf Ptr}$<$ const {\bf Net\+Device} $>$}]{idev, }
\item[{{\bf Unicast\+Forward\+Callback}}]{ucb, }
\item[{{\bf Multicast\+Forward\+Callback}}]{mcb, }
\item[{{\bf Local\+Deliver\+Callback}}]{lcb, }
\item[{{\bf Error\+Callback}}]{ecb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{classIpv4ARouting_a1cbe114fd34ed6681645ba469d52b8fe}{}\label{classIpv4ARouting_a1cbe114fd34ed6681645ba469d52b8fe}


Route an input packet (to be forwarded or locally delivered) 

This lookup is used in the forwarding process. The packet is handed over to the Ipv4\+Routing\+Protocol, and will get forwarded onward by one of the callbacks. The Linux equivalent is ip\+\_\+route\+\_\+input(). There are four valid outcomes, and a matching callbacks to handle each.


\begin{DoxyParams}{Parameters}
{\em p} & received packet \\
\hline
{\em header} & input parameter used to form a search key for a route \\
\hline
{\em idev} & Pointer to ingress network device \\
\hline
{\em ucb} & Callback for the case in which the packet is to be forwarded as unicast \\
\hline
{\em mcb} & Callback for the case in which the packet is to be forwarded as multicast \\
\hline
{\em lcb} & Callback for the case in which the packet is to be locally delivered \\
\hline
{\em ecb} & Callback to call if there is an error in forwarding \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the Ipv4\+Routing\+Protocol takes responsibility for forwarding or delivering the packet, false otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a67e815ff40ebb9f5f4eec4e22e23132e}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
37                                                                  \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}
\end{DoxyCode}
\index{Ipv4\+A\+Routing@{Ipv4\+A\+Routing}!Route\+Output@{Route\+Output}}
\index{Route\+Output@{Route\+Output}!Ipv4\+A\+Routing@{Ipv4\+A\+Routing}}
\subsubsection[{\texorpdfstring{Route\+Output(\+Ptr$<$ Packet $>$ p, const Ipv4\+Header \&header, Ptr$<$ Net\+Device $>$ oif, Socket\+::\+Socket\+Errno \&sockerr)}{RouteOutput(Ptr< Packet > p, const Ipv4Header &header, Ptr< NetDevice > oif, Socket::SocketErrno &sockerr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Ipv4\+Route}$>$ Ipv4\+A\+Routing\+::\+Route\+Output (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv4\+Header} \&}]{header, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{oif, }
\item[{{\bf Socket\+::\+Socket\+Errno} \&}]{sockerr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{classIpv4ARouting_a13ea767139cc112214566ccb9862c412}{}\label{classIpv4ARouting_a13ea767139cc112214566ccb9862c412}


Query routing cache for an existing route, for an outbound packet. 

This lookup is used by transport protocols. It does not cause any packet to be forwarded, and is synchronous. Can be used for multicast or unicast. The Linux equivalent is ip\+\_\+route\+\_\+output()

The header input parameter may have an uninitialized value for the source address, but the destination address should always be properly set by the caller.


\begin{DoxyParams}{Parameters}
{\em p} & packet to be routed. Note that this method may modify the packet. Callers may also pass in a null pointer. \\
\hline
{\em header} & input parameter (used to form key to search for the route) \\
\hline
{\em oif} & Output interface Netdevice. May be zero, or may be bound via socket options to a particular output interface. \\
\hline
{\em sockerr} & Output parameter; socket errno\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a code that indicates what happened in the lookup 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a9c0e9b77772a4974c06ee4577fe60547}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
34 \{ \textcolor{keywordflow}{return} 0; \}
\end{DoxyCode}
\index{Ipv4\+A\+Routing@{Ipv4\+A\+Routing}!Set\+Ipv4@{Set\+Ipv4}}
\index{Set\+Ipv4@{Set\+Ipv4}!Ipv4\+A\+Routing@{Ipv4\+A\+Routing}}
\subsubsection[{\texorpdfstring{Set\+Ipv4(\+Ptr$<$ Ipv4 $>$ ipv4)}{SetIpv4(Ptr< Ipv4 > ipv4)}}]{\setlength{\rightskip}{0pt plus 5cm}void Ipv4\+A\+Routing\+::\+Set\+Ipv4 (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv4} $>$}]{ipv4}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{classIpv4ARouting_af5adcc0186259a1d3f46bc12efd62f3b}{}\label{classIpv4ARouting_af5adcc0186259a1d3f46bc12efd62f3b}

\begin{DoxyParams}{Parameters}
{\em ipv4} & the ipv4 object this routing protocol is being associated with\\
\hline
\end{DoxyParams}
Typically, invoked directly or indirectly from \hyperlink{classns3_1_1Ipv4_a2d165c3bafd4ca580f02a03536db80d3}{ns3\+::\+Ipv4\+::\+Set\+Routing\+Protocol} 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_af3947a05b912ea3f2a1ef0e9777f723e}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
42 \{\}
\end{DoxyCode}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
internet/test/\hyperlink{ipv4-list-routing-test-suite_8cc}{ipv4-\/list-\/routing-\/test-\/suite.\+cc}\end{DoxyCompactItemize}
