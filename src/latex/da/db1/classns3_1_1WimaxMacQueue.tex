\hypertarget{classns3_1_1WimaxMacQueue}{}\section{ns3\+:\+:Wimax\+Mac\+Queue Class Reference}
\label{classns3_1_1WimaxMacQueue}\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}


{\ttfamily \#include $<$wimax-\/mac-\/queue.\+h$>$}



Inheritance diagram for ns3\+:\+:Wimax\+Mac\+Queue\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Wimax\+Mac\+Queue\+:
% FIG 1
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structns3_1_1WimaxMacQueue_1_1QueueElement}{Queue\+Element}
\begin{DoxyCompactList}\small\item\em \hyperlink{structns3_1_1WimaxMacQueue_1_1QueueElement}{Queue\+Element} structure. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1WimaxMacQueue_a2978c30111d68fc5040b9b2ce0eda457}{Wimax\+Mac\+Queue} (void)
\item 
\hyperlink{classns3_1_1WimaxMacQueue_a6ebd98be79482411ee1459c95092dd80}{Wimax\+Mac\+Queue} (uint32\+\_\+t max\+Size)
\item 
\hyperlink{classns3_1_1WimaxMacQueue_a69c675dc2eada68324b59757e94d893d}{$\sim$\+Wimax\+Mac\+Queue} (void)
\item 
void \hyperlink{classns3_1_1WimaxMacQueue_a36209a94c1f33be73c2445545a1892b0}{Set\+Max\+Size} (uint32\+\_\+t max\+Size)
\begin{DoxyCompactList}\small\item\em set the maximum queue size \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1WimaxMacQueue_a72eb630919d5c06c596546ea5924380a}{Get\+Max\+Size} (void) const 
\item 
bool \hyperlink{classns3_1_1WimaxMacQueue_acf25b96a645045ebb802d721e52e6f49}{Enqueue} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, const \hyperlink{classns3_1_1MacHeaderType}{Mac\+Header\+Type} \&hdr\+Type, const \hyperlink{classns3_1_1GenericMacHeader}{Generic\+Mac\+Header} \&hdr)
\begin{DoxyCompactList}\small\item\em Enqueue a packet. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{classns3_1_1WimaxMacQueue_a4043c5bb643fbac159a09d19a6e4bb7b}{Dequeue} (\hyperlink{classns3_1_1MacHeaderType_a54d8fc8bc93a2b7865627965cdd31c20}{Mac\+Header\+Type\+::\+Header\+Type} packet\+Type)
\begin{DoxyCompactList}\small\item\em Dequeue a packet of type packet\+Type from the queue. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{classns3_1_1WimaxMacQueue_aac94a92a71629a7d916571e4847bc035}{Dequeue} (\hyperlink{classns3_1_1MacHeaderType_a54d8fc8bc93a2b7865627965cdd31c20}{Mac\+Header\+Type\+::\+Header\+Type} packet\+Type, uint32\+\_\+t available\+Byte)
\begin{DoxyCompactList}\small\item\em Dequeue a fragment of size available\+Byte from the queue. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{classns3_1_1WimaxMacQueue_a7bf8900208851fcfca4466dd9b932fb3}{Peek} (\hyperlink{classns3_1_1GenericMacHeader}{Generic\+Mac\+Header} \&hdr) const 
\begin{DoxyCompactList}\small\item\em Exclusively for BS. Two versions of Peek function (with Generic M\+AC \hyperlink{classns3_1_1Header}{Header} as parameter) only for BS, as BS\textquotesingle{}s scheduler needs to know the C\+ID in Generic M\+AC \hyperlink{classns3_1_1Header}{Header}. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{classns3_1_1WimaxMacQueue_ae09bc0203b50fb1f0d377cdcc1ee4e9c}{Peek} (\hyperlink{classns3_1_1GenericMacHeader}{Generic\+Mac\+Header} \&hdr, \hyperlink{classns3_1_1Time}{Time} \&time\+Stamp) const 
\begin{DoxyCompactList}\small\item\em Exclusively for BS. Two versions of Peek function (with Generic M\+AC \hyperlink{classns3_1_1Header}{Header} as parameter) only for BS, as BS\textquotesingle{}s scheduler needs to know the C\+ID in Generic M\+AC \hyperlink{classns3_1_1Header}{Header}. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{classns3_1_1WimaxMacQueue_adb1a4885bd8be2e4245ad7e494c48ea7}{Peek} (\hyperlink{classns3_1_1MacHeaderType_a54d8fc8bc93a2b7865627965cdd31c20}{Mac\+Header\+Type\+::\+Header\+Type} packet\+Type) const 
\begin{DoxyCompactList}\small\item\em Two versions for SS without Generic M\+AC \hyperlink{classns3_1_1Header}{Header} parameter, as SS\textquotesingle{}s scheduler does not require to know the C\+ID in Generic M\+AC \hyperlink{classns3_1_1Header}{Header}. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{classns3_1_1WimaxMacQueue_ad7697d4f2831b59dedfb3ad4b1c65c40}{Peek} (\hyperlink{classns3_1_1MacHeaderType_a54d8fc8bc93a2b7865627965cdd31c20}{Mac\+Header\+Type\+::\+Header\+Type} packet\+Type, \hyperlink{classns3_1_1Time}{Time} \&time\+Stamp) const 
\begin{DoxyCompactList}\small\item\em Two versions for SS without Generic M\+AC \hyperlink{classns3_1_1Header}{Header} parameter, as SS\textquotesingle{}s scheduler does not require to know the C\+ID in Generic M\+AC \hyperlink{classns3_1_1Header}{Header}. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1WimaxMacQueue_a45fc4e6c31ac1789b8fdedf4a8714e12}{Is\+Empty} (void) const 
\begin{DoxyCompactList}\small\item\em Check if queue is empty. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1WimaxMacQueue_ac5441bd719302dd5e546601c19b0b23c}{Is\+Empty} (\hyperlink{classns3_1_1MacHeaderType_a54d8fc8bc93a2b7865627965cdd31c20}{Mac\+Header\+Type\+::\+Header\+Type} packet\+Type) const 
\item 
uint32\+\_\+t \hyperlink{classns3_1_1WimaxMacQueue_ac12bb7a7176fec0c2a275b181b4b5fa4}{Get\+Size} (void) const 
\item 
uint32\+\_\+t \hyperlink{classns3_1_1WimaxMacQueue_a844cc908debd8c4a4038c0c2627cfec4}{Get\+N\+Bytes} (void) const 
\item 
bool \hyperlink{classns3_1_1WimaxMacQueue_aba14f6efd4ebb33ac03afd4bbc1461b6}{Check\+For\+Fragmentation} (\hyperlink{classns3_1_1MacHeaderType_a54d8fc8bc93a2b7865627965cdd31c20}{Mac\+Header\+Type\+::\+Header\+Type} packet\+Type)
\item 
uint32\+\_\+t \hyperlink{classns3_1_1WimaxMacQueue_a768ad0214a2ed77aea0603533a45d5c6}{Get\+First\+Packet\+Hdr\+Size} (\hyperlink{classns3_1_1MacHeaderType_a54d8fc8bc93a2b7865627965cdd31c20}{Mac\+Header\+Type\+::\+Header\+Type} packet\+Type)
\item 
uint32\+\_\+t \hyperlink{classns3_1_1WimaxMacQueue_a149ce1f253758a203f0b4539ef2c1270}{Get\+First\+Packet\+Payload\+Size} (\hyperlink{classns3_1_1MacHeaderType_a54d8fc8bc93a2b7865627965cdd31c20}{Mac\+Header\+Type\+::\+Header\+Type} packet\+Type)
\item 
uint32\+\_\+t \hyperlink{classns3_1_1WimaxMacQueue_a3e407a26428eca8d2486bb60b29a612b}{Get\+First\+Packet\+Required\+Byte} (\hyperlink{classns3_1_1MacHeaderType_a54d8fc8bc93a2b7865627965cdd31c20}{Mac\+Header\+Type\+::\+Header\+Type} packet\+Type)
\item 
uint32\+\_\+t \hyperlink{classns3_1_1WimaxMacQueue_a5e0c4f03f3bf8f8c3dd6eb06cdea1c6a}{Get\+Queue\+Length\+With\+M\+A\+C\+Overhead} (void)
\item 
void \hyperlink{classns3_1_1WimaxMacQueue_a7f76b9df9eb4acabad4609839ecda8f1}{Set\+Fragmentation} (\hyperlink{classns3_1_1MacHeaderType_a54d8fc8bc93a2b7865627965cdd31c20}{Mac\+Header\+Type\+::\+Header\+Type} packet\+Type)
\begin{DoxyCompactList}\small\item\em Set fragmentation function. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1WimaxMacQueue_a7dc69d2eec5b050e18852796e502610e}{Set\+Fragment\+Number} (\hyperlink{classns3_1_1MacHeaderType_a54d8fc8bc93a2b7865627965cdd31c20}{Mac\+Header\+Type\+::\+Header\+Type} packet\+Type)
\item 
void \hyperlink{classns3_1_1WimaxMacQueue_a9cbf603913fc930f22d8ba27c14838e1}{Set\+Fragment\+Offset} (\hyperlink{classns3_1_1MacHeaderType_a54d8fc8bc93a2b7865627965cdd31c20}{Mac\+Header\+Type\+::\+Header\+Type} packet\+Type, uint32\+\_\+t offset)
\item 
const \hyperlink{classns3_1_1WimaxMacQueue_a075c9b703ce5eef7fe1844db1758657a}{Wimax\+Mac\+Queue\+::\+Packet\+Queue} \& \hyperlink{classns3_1_1WimaxMacQueue_ac996262c39bc2fb4ab9fac11cc407803}{Get\+Packet\+Queue} (void) const 
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1WimaxMacQueue_a50fd99b4012ead0ccedac32ca0a7d597}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
typedef std\+::deque$<$ \hyperlink{structns3_1_1WimaxMacQueue_1_1QueueElement}{Queue\+Element} $>$ \hyperlink{classns3_1_1WimaxMacQueue_a075c9b703ce5eef7fe1844db1758657a}{Packet\+Queue}
\begin{DoxyCompactList}\small\item\em Packet\+Queue typedef. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{structns3_1_1WimaxMacQueue_1_1QueueElement}{Wimax\+Mac\+Queue\+::\+Queue\+Element} \hyperlink{classns3_1_1WimaxMacQueue_ab02b8007b7f0090eccaf01a3d3dc0b98}{Front} (\hyperlink{classns3_1_1MacHeaderType_a54d8fc8bc93a2b7865627965cdd31c20}{Mac\+Header\+Type\+::\+Header\+Type} packet\+Type) const 
\item 
void \hyperlink{classns3_1_1WimaxMacQueue_a35f80569dacb6e4b01ecadc4f3fa7dd4}{Pop} (\hyperlink{classns3_1_1MacHeaderType_a54d8fc8bc93a2b7865627965cdd31c20}{Mac\+Header\+Type\+::\+Header\+Type} packet\+Type)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1WimaxMacQueue_a075c9b703ce5eef7fe1844db1758657a}{Packet\+Queue} \hyperlink{classns3_1_1WimaxMacQueue_ad372c20acfe0acf6df6280662d63bdae}{m\+\_\+queue}
\begin{DoxyCompactList}\small\item\em the queue \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1WimaxMacQueue_aca04b5018ab36d96092f19467d381efd}{m\+\_\+max\+Size}
\begin{DoxyCompactList}\small\item\em maximum size \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1WimaxMacQueue_a79c3fd93dfef8c78b074c2aa6f2266ea}{m\+\_\+bytes}
\begin{DoxyCompactList}\small\item\em bytes \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1WimaxMacQueue_ac47e05e3e877edf7d7a3d2b5d20d514a}{m\+\_\+nr\+Data\+Packets}
\begin{DoxyCompactList}\small\item\em number data packets \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1WimaxMacQueue_ad71c2599f50a2be15f7ce9abba5a539d}{m\+\_\+nr\+Request\+Packets}
\begin{DoxyCompactList}\small\item\em number request packets \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1WimaxMacQueue_a4adff7167ee1ca8490d246560770ea20}{m\+\_\+trace\+Enqueue}
\begin{DoxyCompactList}\small\item\em enqueue trace callback \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1WimaxMacQueue_a3a84896e087a831d26cb904927e8cbed}{m\+\_\+trace\+Dequeue}
\begin{DoxyCompactList}\small\item\em dequeue trace callback \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ $>$ \hyperlink{classns3_1_1WimaxMacQueue_af12e3058d4bac6a194db0fa730c2b81a}{m\+\_\+trace\+Drop}
\begin{DoxyCompactList}\small\item\em drop trace callback \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Class implementing the device packet queue 

\subsection{Member Typedef Documentation}
\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!Packet\+Queue@{Packet\+Queue}}
\index{Packet\+Queue@{Packet\+Queue}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{Packet\+Queue}{PacketQueue}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::deque$<${\bf Queue\+Element}$>$ {\bf ns3\+::\+Wimax\+Mac\+Queue\+::\+Packet\+Queue}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WimaxMacQueue_a075c9b703ce5eef7fe1844db1758657a}{}\label{classns3_1_1WimaxMacQueue_a075c9b703ce5eef7fe1844db1758657a}


Packet\+Queue typedef. 



\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!Wimax\+Mac\+Queue@{Wimax\+Mac\+Queue}}
\index{Wimax\+Mac\+Queue@{Wimax\+Mac\+Queue}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{Wimax\+Mac\+Queue(void)}{WimaxMacQueue(void)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Wimax\+Mac\+Queue\+::\+Wimax\+Mac\+Queue (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WimaxMacQueue_a2978c30111d68fc5040b9b2ce0eda457}{}\label{classns3_1_1WimaxMacQueue_a2978c30111d68fc5040b9b2ce0eda457}

\begin{DoxyCode}
107   : \hyperlink{classns3_1_1WimaxMacQueue_aca04b5018ab36d96092f19467d381efd}{m\_maxSize} (0),
108     \hyperlink{classns3_1_1WimaxMacQueue_a79c3fd93dfef8c78b074c2aa6f2266ea}{m\_bytes} (0),
109     \hyperlink{classns3_1_1WimaxMacQueue_ac47e05e3e877edf7d7a3d2b5d20d514a}{m\_nrDataPackets} (0),
110     \hyperlink{classns3_1_1WimaxMacQueue_ad71c2599f50a2be15f7ce9abba5a539d}{m\_nrRequestPackets} (0)
111 \{
112 \}
\end{DoxyCode}
\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!Wimax\+Mac\+Queue@{Wimax\+Mac\+Queue}}
\index{Wimax\+Mac\+Queue@{Wimax\+Mac\+Queue}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{Wimax\+Mac\+Queue(uint32\+\_\+t max\+Size)}{WimaxMacQueue(uint32_t maxSize)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Wimax\+Mac\+Queue\+::\+Wimax\+Mac\+Queue (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{max\+Size}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WimaxMacQueue_a6ebd98be79482411ee1459c95092dd80}{}\label{classns3_1_1WimaxMacQueue_a6ebd98be79482411ee1459c95092dd80}
Constructor


\begin{DoxyParams}{Parameters}
{\em max\+Size} & maximum size of queue \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
115   : \hyperlink{classns3_1_1WimaxMacQueue_aca04b5018ab36d96092f19467d381efd}{m\_maxSize} (maxSize),
116     \hyperlink{classns3_1_1WimaxMacQueue_a79c3fd93dfef8c78b074c2aa6f2266ea}{m\_bytes} (0),
117     \hyperlink{classns3_1_1WimaxMacQueue_ac47e05e3e877edf7d7a3d2b5d20d514a}{m\_nrDataPackets} (0),
118     \hyperlink{classns3_1_1WimaxMacQueue_ad71c2599f50a2be15f7ce9abba5a539d}{m\_nrRequestPackets} (0)
119 \{
120 \}
\end{DoxyCode}
\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!````~Wimax\+Mac\+Queue@{$\sim$\+Wimax\+Mac\+Queue}}
\index{````~Wimax\+Mac\+Queue@{$\sim$\+Wimax\+Mac\+Queue}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{$\sim$\+Wimax\+Mac\+Queue(void)}{~WimaxMacQueue(void)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Wimax\+Mac\+Queue\+::$\sim$\+Wimax\+Mac\+Queue (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WimaxMacQueue_a69c675dc2eada68324b59757e94d893d}{}\label{classns3_1_1WimaxMacQueue_a69c675dc2eada68324b59757e94d893d}

\begin{DoxyCode}
123 \{
124 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!Check\+For\+Fragmentation@{Check\+For\+Fragmentation}}
\index{Check\+For\+Fragmentation@{Check\+For\+Fragmentation}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{Check\+For\+Fragmentation(\+Mac\+Header\+Type\+::\+Header\+Type packet\+Type)}{CheckForFragmentation(MacHeaderType::HeaderType packetType)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Wimax\+Mac\+Queue\+::\+Check\+For\+Fragmentation (
\begin{DoxyParamCaption}
\item[{{\bf Mac\+Header\+Type\+::\+Header\+Type}}]{packet\+Type}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WimaxMacQueue_aba14f6efd4ebb33ac03afd4bbc1461b6}{}\label{classns3_1_1WimaxMacQueue_aba14f6efd4ebb33ac03afd4bbc1461b6}
Check for fragmentation of the first packet of the specified type 
\begin{DoxyParams}{Parameters}
{\em packet\+Type} & the packet type \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if fragmented 
\end{DoxyReturn}

\begin{DoxyCode}
497 \{
498   QueueElement element;
499   \textcolor{keywordflow}{for} (std::deque<QueueElement>::const\_iterator iter = \hyperlink{classns3_1_1WimaxMacQueue_ad372c20acfe0acf6df6280662d63bdae}{m\_queue}.begin (); iter
500        != \hyperlink{classns3_1_1WimaxMacQueue_ad372c20acfe0acf6df6280662d63bdae}{m\_queue}.end (); ++iter)
501     \{
502       element = *iter;
503       \textcolor{keywordflow}{if} (element.m\_hdrType.GetType () == packetType)
504         \{
505           \textcolor{keywordflow}{break};
506         \}
507     \}
508 
509   \textcolor{keywordflow}{if} (element.m\_fragmentation)
510     \{
511       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"FRAG\_DEBUG: CheckForFragmentation"}
512                    \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)t\(\backslash\)t m\_fragmentation is true "} << std::endl);
513     \}
514 
515   \textcolor{keywordflow}{return} element.m\_fragmentation;
516 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2




Here is the caller graph for this function\+:
% FIG 3


\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!Dequeue@{Dequeue}}
\index{Dequeue@{Dequeue}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{Dequeue(\+Mac\+Header\+Type\+::\+Header\+Type packet\+Type)}{Dequeue(MacHeaderType::HeaderType packetType)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Packet} $>$ ns3\+::\+Wimax\+Mac\+Queue\+::\+Dequeue (
\begin{DoxyParamCaption}
\item[{{\bf Mac\+Header\+Type\+::\+Header\+Type}}]{packet\+Type}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WimaxMacQueue_a4043c5bb643fbac159a09d19a6e4bb7b}{}\label{classns3_1_1WimaxMacQueue_a4043c5bb643fbac159a09d19a6e4bb7b}


Dequeue a packet of type packet\+Type from the queue. 


\begin{DoxyParams}{Parameters}
{\em packet\+Type} & the type of the packet \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the first packet in the queue 
\end{DoxyReturn}

\begin{DoxyCode}
169 \{
170   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1WimaxMacQueue_a45fc4e6c31ac1789b8fdedf4a8714e12}{IsEmpty} ())
171     \{
172       QueueElement element = \hyperlink{classns3_1_1WimaxMacQueue_ab02b8007b7f0090eccaf01a3d3dc0b98}{Front} (packetType);
173       \hyperlink{classns3_1_1WimaxMacQueue_a35f80569dacb6e4b01ecadc4f3fa7dd4}{Pop} (packetType);
174 
175       \textcolor{keywordflow}{if} (element.m\_hdrType.GetType () == \hyperlink{classns3_1_1MacHeaderType_a54d8fc8bc93a2b7865627965cdd31c20a48fe5b2f20cadf78008c71469b518403}{MacHeaderType::HEADER\_TYPE\_GENERIC}
      )
176         \{
177           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Enqueued Packet IS A data packet"});
178           \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\hyperlink{classns3_1_1WimaxMacQueue_ac47e05e3e877edf7d7a3d2b5d20d514a}{m\_nrDataPackets} >= 1,
179                          \textcolor{stringliteral}{"Can not enqueue more packets: no space left in the queue"});
180           \hyperlink{classns3_1_1WimaxMacQueue_ac47e05e3e877edf7d7a3d2b5d20d514a}{m\_nrDataPackets}--;
181         \}
182       \textcolor{keywordflow}{else}
183         \{
184           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Enqueued Packet IS A Request BW packet"});
185           \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\hyperlink{classns3_1_1WimaxMacQueue_ad71c2599f50a2be15f7ce9abba5a539d}{m\_nrRequestPackets} >= 1,
186                          \textcolor{stringliteral}{"Can not enqueue more packets: no space left in the queue"});
187           \hyperlink{classns3_1_1WimaxMacQueue_ad71c2599f50a2be15f7ce9abba5a539d}{m\_nrRequestPackets}--;
188         \}
189 
190       Ptr<Packet> packet = element.m\_packet;
191 
192       \textcolor{keywordflow}{if} (!element.m\_fragmentation)
193         \{
194           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"FRAG\_DEBUG: Enqueued Packet IS NOT a fragment"} << std::endl);
195           \textcolor{comment}{/*check because may be it is a bandwidth request packet (in which case a Bandwidth Request Header}
196 \textcolor{comment}{            has already been added to the packet) in which case Generic MAC Header will not be added to it.}
197 \textcolor{comment}{            this will only happen in the case of SS as only SS sends the bandwidth request packet. */}
198           \hyperlink{classns3_1_1WimaxMacQueue_a79c3fd93dfef8c78b074c2aa6f2266ea}{m\_bytes} -= element.GetSize ();
199           \textcolor{keywordflow}{if} (element.m\_hdrType.GetType () == \hyperlink{classns3_1_1MacHeaderType_a54d8fc8bc93a2b7865627965cdd31c20a48fe5b2f20cadf78008c71469b518403}{MacHeaderType::HEADER\_TYPE\_GENERIC}
      )
200             \{
201               packet->AddHeader (element.m\_hdr);
202             \}
203           packet->AddHeader (element.m\_hdrType);
204 
205           \hyperlink{classns3_1_1WimaxMacQueue_a3a84896e087a831d26cb904927e8cbed}{m\_traceDequeue} (packet);
206           \textcolor{keywordflow}{return} packet;
207         \}
208       \textcolor{keywordflow}{else}
209         \{
210           \textcolor{comment}{/*}
211 \textcolor{comment}{           The enqueued packet is a fragment (the latest fragment)}
212 \textcolor{comment}{           We must modify type field of the m\_hdr and add a fragmentation Subhdr}
213 \textcolor{comment}{           */}
214           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)t Enqueued Packet IS a fragment, add subhdr"} << std::endl);
215 
216           \textcolor{comment}{// Create a fragment}
217           uint32\_t fragmentOffset = element.m\_fragmentOffset;
218           uint32\_t fragmentSize = element.m\_packet->GetSize () - fragmentOffset;
219 
220           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)t Create a fragment"}
221                        \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)t\(\backslash\)t fragmentOffset="} << fragmentOffset <<
222                        \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)t\(\backslash\)t packetSize="} << element.m\_packet->GetSize () <<
223                        \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)t\(\backslash\)t fragmentSize="} << fragmentSize << std::endl);
224 
225           Ptr<Packet> fragment = packet->CreateFragment (fragmentOffset,fragmentSize);
226 
227           FragmentationSubheader fragmentSubhdr;
228           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)t Latest Fragment"} << std::endl);
229           fragmentSubhdr.SetFc (2);   \textcolor{comment}{// This is the latest fragment}
230           fragmentSubhdr.SetFsn (element.m\_fragmentNumber);
231 
232           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)t FragmentSize="} << fragment->GetSize () << std::endl);
233           fragment->AddHeader (fragmentSubhdr);
234 
235           \textcolor{comment}{/*check because may be it is a bandwidth request packet (in which case a Bandwidth Request Header}
236 \textcolor{comment}{          has already been added to the packet) in which case Generic MAC Header will not be added to it.}
237 \textcolor{comment}{          this will only happen in the case of SS as only SS sends the bandwidth request packet. */}
238           \textcolor{keywordflow}{if} (element.m\_hdrType.GetType () == \hyperlink{classns3_1_1MacHeaderType_a54d8fc8bc93a2b7865627965cdd31c20a48fe5b2f20cadf78008c71469b518403}{MacHeaderType::HEADER\_TYPE\_GENERIC}
      )
239             \{
240               uint8\_t tmpType = element.m\_hdr.GetType ();
241               tmpType |= 4;
242               element.m\_hdr.SetType (tmpType);
243 
244               uint32\_t length = fragmentSize + element.m\_hdr.GetSerializedSize ()
245                 + fragmentSubhdr.GetSerializedSize ();
246               element.m\_hdr.SetLen ((uint16\_t)length);
247 
248               fragment->AddHeader (element.m\_hdr);
249             \}
250           fragment->AddHeader (element.m\_hdrType);
251           \hyperlink{classns3_1_1WimaxMacQueue_a79c3fd93dfef8c78b074c2aa6f2266ea}{m\_bytes} -= fragmentSize;
252 
253           \hyperlink{classns3_1_1WimaxMacQueue_a3a84896e087a831d26cb904927e8cbed}{m\_traceDequeue} (fragment);
254           \textcolor{keywordflow}{return} fragment;
255         \}
256     \}
257   \textcolor{keywordflow}{return} 0;
258 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4


\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!Dequeue@{Dequeue}}
\index{Dequeue@{Dequeue}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{Dequeue(\+Mac\+Header\+Type\+::\+Header\+Type packet\+Type, uint32\+\_\+t available\+Byte)}{Dequeue(MacHeaderType::HeaderType packetType, uint32_t availableByte)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Packet} $>$ ns3\+::\+Wimax\+Mac\+Queue\+::\+Dequeue (
\begin{DoxyParamCaption}
\item[{{\bf Mac\+Header\+Type\+::\+Header\+Type}}]{packet\+Type, }
\item[{uint32\+\_\+t}]{available\+Byte}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WimaxMacQueue_aac94a92a71629a7d916571e4847bc035}{}\label{classns3_1_1WimaxMacQueue_aac94a92a71629a7d916571e4847bc035}


Dequeue a fragment of size available\+Byte from the queue. 


\begin{DoxyParams}{Parameters}
{\em packet\+Type} & the type of the packet \\
\hline
{\em available\+Byte} & the size of the fragment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the first packet in the queue if its size is lower than available\+Byte, the first available\+Byte of the first packet otherwise 
\end{DoxyReturn}

\begin{DoxyCode}
262 \{
263   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1WimaxMacQueue_a45fc4e6c31ac1789b8fdedf4a8714e12}{IsEmpty} ())
264     \{
265       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"FRAG\_DEBUG: Dequeue function"} << std::endl);
266       QueueElement element = \hyperlink{classns3_1_1WimaxMacQueue_ab02b8007b7f0090eccaf01a3d3dc0b98}{Front} (packetType);
267 
268       uint32\_t headerSize = 2 + element.m\_hdr.GetSerializedSize () +
269         element.m\_hdrType.GetSerializedSize ();
270 
271       \textcolor{comment}{// Create a fragment}
272       uint32\_t maxFragmentSize = availableByte - headerSize;
273       uint32\_t fragmentOffset = element.m\_fragmentOffset; \textcolor{comment}{// It is the latest byte sent.}
274 
275       Ptr<Packet> packet = element.m\_packet->Copy ();
276       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)t Create a fragment"}
277                    \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)t\(\backslash\)t availableByte="} << availableByte <<
278                    \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)t\(\backslash\)t headerSize="} << headerSize <<
279                    \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)t\(\backslash\)t maxFragmentSize="} << maxFragmentSize << \textcolor{stringliteral}{""}
280                    \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)t\(\backslash\)t fragmentOffset="} << fragmentOffset <<
281                    \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)t\(\backslash\)t payloadSize="} << packet->GetSize ()
282                                             << std::endl);
283       Ptr<Packet> fragment = packet->CreateFragment (fragmentOffset,
284                                                      maxFragmentSize);
285       \hyperlink{classns3_1_1WimaxMacQueue_a79c3fd93dfef8c78b074c2aa6f2266ea}{m\_bytes} -= maxFragmentSize;
286 
287       FragmentationSubheader fragmentSubhdr;
288       \textcolor{keywordflow}{if} (!element.m\_fragmentation)
289         \{
290           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)t First Fragment"} << std::endl);
291           \hyperlink{classns3_1_1WimaxMacQueue_a7f76b9df9eb4acabad4609839ecda8f1}{SetFragmentation} (packetType);
292           fragmentSubhdr.SetFc (1);
293         \}
294       \textcolor{keywordflow}{else}
295         \{
296           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)t Middle Fragment"} << std::endl);
297           fragmentSubhdr.SetFc (3);
298         \}
299       fragmentSubhdr.SetFsn (element.m\_fragmentNumber);
300       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)t FragmentSize="} << fragment->GetSize () << std::endl);
301       fragment->AddHeader (fragmentSubhdr);
302 
303       \hyperlink{classns3_1_1WimaxMacQueue_a7dc69d2eec5b050e18852796e502610e}{SetFragmentNumber} (packetType);
304       \hyperlink{classns3_1_1WimaxMacQueue_a9cbf603913fc930f22d8ba27c14838e1}{SetFragmentOffset} (packetType, maxFragmentSize);
305 
306       \textcolor{comment}{/*check because may be it is a bandwidth request packet (in which case a Bandwidth Request Header}
307 \textcolor{comment}{        has already been added to the packet) in which case Generic MAC Header will not be added to it.}
308 \textcolor{comment}{            this will only happen in the case of SS as only SS sends the bandwidth request packet. */}
309       \textcolor{keywordflow}{if} (element.m\_hdrType.GetType () == \hyperlink{classns3_1_1MacHeaderType_a54d8fc8bc93a2b7865627965cdd31c20a48fe5b2f20cadf78008c71469b518403}{MacHeaderType::HEADER\_TYPE\_GENERIC}
      )
310         \{
311           uint8\_t tmpType = element.m\_hdr.GetType ();
312           tmpType |= 4;
313           element.m\_hdr.SetType (tmpType);
314 
315           uint32\_t length = maxFragmentSize + element.m\_hdr.GetSerializedSize ()
316             + fragmentSubhdr.GetSerializedSize ();
317           element.m\_hdr.SetLen ((uint16\_t)length);
318 
319           fragment->AddHeader (element.m\_hdr);
320         \}
321       fragment->AddHeader (element.m\_hdrType);
322 
323       \hyperlink{classns3_1_1WimaxMacQueue_a3a84896e087a831d26cb904927e8cbed}{m\_traceDequeue} (fragment);
324       \textcolor{keywordflow}{return} fragment;
325     \}
326   \textcolor{keywordflow}{return} 0;
327 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5


\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!Enqueue@{Enqueue}}
\index{Enqueue@{Enqueue}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{Enqueue(\+Ptr$<$ Packet $>$ packet, const Mac\+Header\+Type \&hdr\+Type, const Generic\+Mac\+Header \&hdr)}{Enqueue(Ptr< Packet > packet, const MacHeaderType &hdrType, const GenericMacHeader &hdr)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Wimax\+Mac\+Queue\+::\+Enqueue (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{const {\bf Mac\+Header\+Type} \&}]{hdr\+Type, }
\item[{const {\bf Generic\+Mac\+Header} \&}]{hdr}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WimaxMacQueue_acf25b96a645045ebb802d721e52e6f49}{}\label{classns3_1_1WimaxMacQueue_acf25b96a645045ebb802d721e52e6f49}


Enqueue a packet. 


\begin{DoxyParams}{Parameters}
{\em packet} & the packet to enqueue \\
\hline
{\em hdr\+Type} & the mac header type of the packet \\
\hline
{\em hdr} & the header of the packet \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if successful 
\end{DoxyReturn}

\begin{DoxyCode}
141 \{
142 
143   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1WimaxMacQueue_ad372c20acfe0acf6df6280662d63bdae}{m\_queue}.size () == \hyperlink{classns3_1_1WimaxMacQueue_aca04b5018ab36d96092f19467d381efd}{m\_maxSize})
144     \{
145 
146       \hyperlink{classns3_1_1WimaxMacQueue_af12e3058d4bac6a194db0fa730c2b81a}{m\_traceDrop} (packet);
147       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
148     \}
149 
150   \hyperlink{classns3_1_1WimaxMacQueue_a4adff7167ee1ca8490d246560770ea20}{m\_traceEnqueue} (packet);
151   QueueElement element (packet, hdrType, hdr, \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ());
152   \hyperlink{classns3_1_1WimaxMacQueue_ad372c20acfe0acf6df6280662d63bdae}{m\_queue}.push\_back (element);
153 
154   \textcolor{keywordflow}{if} (hdrType.GetType () == \hyperlink{classns3_1_1MacHeaderType_a54d8fc8bc93a2b7865627965cdd31c20a48fe5b2f20cadf78008c71469b518403}{MacHeaderType::HEADER\_TYPE\_GENERIC})
155     \{
156       \hyperlink{classns3_1_1WimaxMacQueue_ac47e05e3e877edf7d7a3d2b5d20d514a}{m\_nrDataPackets}++;
157     \}
158   \textcolor{keywordflow}{else}
159     \{
160       \hyperlink{classns3_1_1WimaxMacQueue_ad71c2599f50a2be15f7ce9abba5a539d}{m\_nrRequestPackets}++;
161     \}
162 
163   \hyperlink{classns3_1_1WimaxMacQueue_a79c3fd93dfef8c78b074c2aa6f2266ea}{m\_bytes} += element.GetSize ();
164   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
165 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6


\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!Front@{Front}}
\index{Front@{Front}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{Front(\+Mac\+Header\+Type\+::\+Header\+Type packet\+Type) const }{Front(MacHeaderType::HeaderType packetType) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Wimax\+Mac\+Queue\+::\+Queue\+Element} ns3\+::\+Wimax\+Mac\+Queue\+::\+Front (
\begin{DoxyParamCaption}
\item[{{\bf Mac\+Header\+Type\+::\+Header\+Type}}]{packet\+Type}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WimaxMacQueue_ab02b8007b7f0090eccaf01a3d3dc0b98}{}\label{classns3_1_1WimaxMacQueue_ab02b8007b7f0090eccaf01a3d3dc0b98}
In the case of non-\/\+U\+GS service flows at the SS side the queue will store both data packets and bandwidth request packets. The two are distinguished by their headers. The below two functions are for this purpose exclusively. The Front function returns the first packet of a specific packet type from the queue (which may not necessarily be at the front of the queue), and the Pop function pops that elements. 
\begin{DoxyParams}{Parameters}
{\em packet\+Type} & the type of the packet \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the first packet in the queue of the specified type 
\end{DoxyReturn}

\begin{DoxyCode}
435 \{
436   QueueElement element;
437 
438   \textcolor{keywordflow}{for} (std::deque<QueueElement>::const\_iterator iter = \hyperlink{classns3_1_1WimaxMacQueue_ad372c20acfe0acf6df6280662d63bdae}{m\_queue}.begin (); iter
439        != \hyperlink{classns3_1_1WimaxMacQueue_ad372c20acfe0acf6df6280662d63bdae}{m\_queue}.end (); ++iter)
440     \{
441       element = *iter;
442       \textcolor{keywordflow}{if} (element.m\_hdrType.GetType () == packetType)
443         \{
444           \textcolor{keywordflow}{break};
445         \}
446     \}
447 
448   \textcolor{keywordflow}{return} element;
449 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7




Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!Get\+First\+Packet\+Hdr\+Size@{Get\+First\+Packet\+Hdr\+Size}}
\index{Get\+First\+Packet\+Hdr\+Size@{Get\+First\+Packet\+Hdr\+Size}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{Get\+First\+Packet\+Hdr\+Size(\+Mac\+Header\+Type\+::\+Header\+Type packet\+Type)}{GetFirstPacketHdrSize(MacHeaderType::HeaderType packetType)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Wimax\+Mac\+Queue\+::\+Get\+First\+Packet\+Hdr\+Size (
\begin{DoxyParamCaption}
\item[{{\bf Mac\+Header\+Type\+::\+Header\+Type}}]{packet\+Type}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WimaxMacQueue_a768ad0214a2ed77aea0603533a45d5c6}{}\label{classns3_1_1WimaxMacQueue_a768ad0214a2ed77aea0603533a45d5c6}
Get first packet header size of the specified type 
\begin{DoxyParams}{Parameters}
{\em packet\+Type} & the packet type \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the first packet header size 
\end{DoxyReturn}

\begin{DoxyCode}
520 \{
521   QueueElement element;
522   \textcolor{keywordflow}{for} (std::deque<QueueElement>::const\_iterator iter = \hyperlink{classns3_1_1WimaxMacQueue_ad372c20acfe0acf6df6280662d63bdae}{m\_queue}.begin (); iter
523        != \hyperlink{classns3_1_1WimaxMacQueue_ad372c20acfe0acf6df6280662d63bdae}{m\_queue}.end (); ++iter)
524     \{
525       element = *iter;
526       \textcolor{keywordflow}{if} (element.m\_hdrType.GetType () == packetType)
527         \{
528           \textcolor{keywordflow}{break};
529         \}
530     \}
531 
532   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)t\(\backslash\)t GetFirstPacketHdrSize ()"});
533 
534   uint32\_t hdrSize = 0;
535   \textcolor{keywordflow}{if} (element.m\_hdrType.GetType () == \hyperlink{classns3_1_1MacHeaderType_a54d8fc8bc93a2b7865627965cdd31c20a48fe5b2f20cadf78008c71469b518403}{MacHeaderType::HEADER\_TYPE\_GENERIC})
536     \{
537       hdrSize += element.m\_hdr.GetSerializedSize ();
538       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)t\(\backslash\)t\(\backslash\)t m\_hdr.GetSerializedSize="} <<
539                    element.m\_hdr.GetSerializedSize ());
540     \}
541 
542   hdrSize += element.m\_hdrType.GetSerializedSize ();
543   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)t\(\backslash\)t\(\backslash\)t m\_hdrType.GetSerializedSize="} <<
544                element.m\_hdrType.GetSerializedSize ());
545 
546   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1WimaxMacQueue_aba14f6efd4ebb33ac03afd4bbc1461b6}{CheckForFragmentation} (packetType))
547     \{
548       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)t\(\backslash\)t\(\backslash\)t fragSubhdrSize=2"});
549       hdrSize += 2;
550     \}
551 
552   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)t\(\backslash\)t hdrSize="} << hdrSize);
553 
554   \textcolor{keywordflow}{return} hdrSize;
555 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9




Here is the caller graph for this function\+:
% FIG 10


\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!Get\+First\+Packet\+Payload\+Size@{Get\+First\+Packet\+Payload\+Size}}
\index{Get\+First\+Packet\+Payload\+Size@{Get\+First\+Packet\+Payload\+Size}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{Get\+First\+Packet\+Payload\+Size(\+Mac\+Header\+Type\+::\+Header\+Type packet\+Type)}{GetFirstPacketPayloadSize(MacHeaderType::HeaderType packetType)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Wimax\+Mac\+Queue\+::\+Get\+First\+Packet\+Payload\+Size (
\begin{DoxyParamCaption}
\item[{{\bf Mac\+Header\+Type\+::\+Header\+Type}}]{packet\+Type}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WimaxMacQueue_a149ce1f253758a203f0b4539ef2c1270}{}\label{classns3_1_1WimaxMacQueue_a149ce1f253758a203f0b4539ef2c1270}
Get first packet payload size of the specified type 
\begin{DoxyParams}{Parameters}
{\em packet\+Type} & the packet type \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the first packet payload size 
\end{DoxyReturn}

\begin{DoxyCode}
559 \{
560   QueueElement element;
561   \textcolor{keywordflow}{for} (std::deque<QueueElement>::const\_iterator iter = \hyperlink{classns3_1_1WimaxMacQueue_ad372c20acfe0acf6df6280662d63bdae}{m\_queue}.begin (); iter
562        != \hyperlink{classns3_1_1WimaxMacQueue_ad372c20acfe0acf6df6280662d63bdae}{m\_queue}.end (); ++iter)
563     \{
564       element = *iter;
565       \textcolor{keywordflow}{if} (element.m\_hdrType.GetType () == packetType)
566         \{
567           \textcolor{keywordflow}{break};
568         \}
569     \}
570 
571   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)t\(\backslash\)t GetFirstPacketPayloadSize ()"});
572 
573   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1WimaxMacQueue_aba14f6efd4ebb33ac03afd4bbc1461b6}{CheckForFragmentation} (packetType))
574     \{
575       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)t\(\backslash\)t\(\backslash\)t fullPayloadSize="} << element.m\_packet->GetSize ()
576                                              << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)t\(\backslash\)t\(\backslash\)t fragmentOffset="} << element.m\_fragmentOffset
577                                              << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)t\(\backslash\)t\(\backslash\)t (fragment)payloadSize="} <<
578                    element.m\_packet->GetSize () - element.m\_fragmentOffset);
579 
580       \textcolor{keywordflow}{return} element.m\_packet->GetSize () - element.m\_fragmentOffset;
581     \}
582   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)t\(\backslash\)t payloadSize="} <<
583                element.m\_packet->GetSize ());
584 
585   \textcolor{keywordflow}{return} element.m\_packet->GetSize ();
586 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 11




Here is the caller graph for this function\+:
% FIG 12


\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!Get\+First\+Packet\+Required\+Byte@{Get\+First\+Packet\+Required\+Byte}}
\index{Get\+First\+Packet\+Required\+Byte@{Get\+First\+Packet\+Required\+Byte}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{Get\+First\+Packet\+Required\+Byte(\+Mac\+Header\+Type\+::\+Header\+Type packet\+Type)}{GetFirstPacketRequiredByte(MacHeaderType::HeaderType packetType)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Wimax\+Mac\+Queue\+::\+Get\+First\+Packet\+Required\+Byte (
\begin{DoxyParamCaption}
\item[{{\bf Mac\+Header\+Type\+::\+Header\+Type}}]{packet\+Type}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WimaxMacQueue_a3e407a26428eca8d2486bb60b29a612b}{}\label{classns3_1_1WimaxMacQueue_a3e407a26428eca8d2486bb60b29a612b}
Get required number of bytes to hold first packet of packet\+Type 
\begin{DoxyParams}{Parameters}
{\em packet\+Type} & the packet type \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the sum of the first packet header and payload (of specified type) 
\end{DoxyReturn}

\begin{DoxyCode}
590 \{
591   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)t GetFirstPacketRequiredByte ()"});
592 
593   uint32\_t requiredByte = \hyperlink{classns3_1_1WimaxMacQueue_a149ce1f253758a203f0b4539ef2c1270}{GetFirstPacketPayloadSize} (packetType) +
594     \hyperlink{classns3_1_1WimaxMacQueue_a768ad0214a2ed77aea0603533a45d5c6}{GetFirstPacketHdrSize} (packetType);
595 
596   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)t Required Bytes = "} << requiredByte << std::endl);
597 
598   \textcolor{keywordflow}{return} requiredByte;
599 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13


\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!Get\+Max\+Size@{Get\+Max\+Size}}
\index{Get\+Max\+Size@{Get\+Max\+Size}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{Get\+Max\+Size(void) const }{GetMaxSize(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Wimax\+Mac\+Queue\+::\+Get\+Max\+Size (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1WimaxMacQueue_a72eb630919d5c06c596546ea5924380a}{}\label{classns3_1_1WimaxMacQueue_a72eb630919d5c06c596546ea5924380a}
\begin{DoxyReturn}{Returns}
the maximum queue size 
\end{DoxyReturn}

\begin{DoxyCode}
134 \{
135   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1WimaxMacQueue_aca04b5018ab36d96092f19467d381efd}{m\_maxSize};
136 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 14


\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!Get\+N\+Bytes@{Get\+N\+Bytes}}
\index{Get\+N\+Bytes@{Get\+N\+Bytes}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{Get\+N\+Bytes(void) const }{GetNBytes(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Wimax\+Mac\+Queue\+::\+Get\+N\+Bytes (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1WimaxMacQueue_a844cc908debd8c4a4038c0c2627cfec4}{}\label{classns3_1_1WimaxMacQueue_a844cc908debd8c4a4038c0c2627cfec4}
Get number of bytes in queue \begin{DoxyReturn}{Returns}
the number of bytes 
\end{DoxyReturn}

\begin{DoxyCode}
416 \{
417   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1WimaxMacQueue_a79c3fd93dfef8c78b074c2aa6f2266ea}{m\_bytes};
418 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 15


\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!Get\+Packet\+Queue@{Get\+Packet\+Queue}}
\index{Get\+Packet\+Queue@{Get\+Packet\+Queue}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{Get\+Packet\+Queue(void) const }{GetPacketQueue(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Wimax\+Mac\+Queue\+::\+Packet\+Queue} \& ns3\+::\+Wimax\+Mac\+Queue\+::\+Get\+Packet\+Queue (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1WimaxMacQueue_ac996262c39bc2fb4ab9fac11cc407803}{}\label{classns3_1_1WimaxMacQueue_ac996262c39bc2fb4ab9fac11cc407803}
Get packet queue function \begin{DoxyReturn}{Returns}
the packet queue 
\end{DoxyReturn}

\begin{DoxyCode}
491 \{
492   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1WimaxMacQueue_ad372c20acfe0acf6df6280662d63bdae}{m\_queue};
493 \}
\end{DoxyCode}
\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!Get\+Queue\+Length\+With\+M\+A\+C\+Overhead@{Get\+Queue\+Length\+With\+M\+A\+C\+Overhead}}
\index{Get\+Queue\+Length\+With\+M\+A\+C\+Overhead@{Get\+Queue\+Length\+With\+M\+A\+C\+Overhead}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{Get\+Queue\+Length\+With\+M\+A\+C\+Overhead(void)}{GetQueueLengthWithMACOverhead(void)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Wimax\+Mac\+Queue\+::\+Get\+Queue\+Length\+With\+M\+A\+C\+Overhead (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WimaxMacQueue_a5e0c4f03f3bf8f8c3dd6eb06cdea1c6a}{}\label{classns3_1_1WimaxMacQueue_a5e0c4f03f3bf8f8c3dd6eb06cdea1c6a}
Get queue length considering also the M\+AC overhead \begin{DoxyReturn}{Returns}
queue length 
\end{DoxyReturn}

\begin{DoxyCode}
421 \{
422   uint32\_t queueSize = \hyperlink{classns3_1_1WimaxMacQueue_a844cc908debd8c4a4038c0c2627cfec4}{GetNBytes} ();
423   \textcolor{comment}{// Add MAC Overhead}
424   queueSize += \hyperlink{classns3_1_1WimaxMacQueue_ac12bb7a7176fec0c2a275b181b4b5fa4}{GetSize} () * 6;
425   \hyperlink{classns3_1_1MacHeaderType_a54d8fc8bc93a2b7865627965cdd31c20}{MacHeaderType::HeaderType} packetType = 
      \hyperlink{classns3_1_1MacHeaderType_a54d8fc8bc93a2b7865627965cdd31c20a48fe5b2f20cadf78008c71469b518403}{MacHeaderType::HEADER\_TYPE\_GENERIC};
426   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1WimaxMacQueue_aba14f6efd4ebb33ac03afd4bbc1461b6}{CheckForFragmentation} (packetType))
427     \{
428       queueSize += 2;
429     \}
430   \textcolor{keywordflow}{return} queueSize;
431 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 16


\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!Get\+Size@{Get\+Size}}
\index{Get\+Size@{Get\+Size}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{Get\+Size(void) const }{GetSize(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Wimax\+Mac\+Queue\+::\+Get\+Size (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1WimaxMacQueue_ac12bb7a7176fec0c2a275b181b4b5fa4}{}\label{classns3_1_1WimaxMacQueue_ac12bb7a7176fec0c2a275b181b4b5fa4}
Get size of queue \begin{DoxyReturn}{Returns}
the size 
\end{DoxyReturn}

\begin{DoxyCode}
410 \{
411   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1WimaxMacQueue_ad372c20acfe0acf6df6280662d63bdae}{m\_queue}.size ();
412 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 17


\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Wimax\+Mac\+Queue\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1WimaxMacQueue_a50fd99b4012ead0ccedac32ca0a7d597}{}\label{classns3_1_1WimaxMacQueue_a50fd99b4012ead0ccedac32ca0a7d597}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
79 \{
80   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::WimaxMacQueue"})
81     .SetParent<\hyperlink{classns3_1_1Object_a40860402e64d8008fb42329df7097cdb}{Object}> ()
82     .SetGroupName(\textcolor{stringliteral}{"Wimax"})
83     .AddAttribute (
84       \textcolor{stringliteral}{"MaxSize"},
85       \textcolor{stringliteral}{"Maximum size"},
86       UintegerValue (1024),
87       MakeUintegerAccessor (&\hyperlink{classns3_1_1WimaxMacQueue_a72eb630919d5c06c596546ea5924380a}{WimaxMacQueue::GetMaxSize},
88                             &\hyperlink{classns3_1_1WimaxMacQueue_a36209a94c1f33be73c2445545a1892b0}{WimaxMacQueue::SetMaxSize}),
89       MakeUintegerChecker<uint32\_t> ())
90     .AddTraceSource (\textcolor{stringliteral}{"Enqueue"},
91                      \textcolor{stringliteral}{"Enqueue trace"},
92                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1WimaxMacQueue_a4adff7167ee1ca8490d246560770ea20}{WimaxMacQueue::m\_traceEnqueue}),
93                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
94     .AddTraceSource (\textcolor{stringliteral}{"Dequeue"},
95                      \textcolor{stringliteral}{"Dequeue trace"},
96                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1WimaxMacQueue_a3a84896e087a831d26cb904927e8cbed}{WimaxMacQueue::m\_traceDequeue}),
97                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
98     .AddTraceSource (\textcolor{stringliteral}{"Drop"},
99                      \textcolor{stringliteral}{"Drop trace"},
100                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1WimaxMacQueue_af12e3058d4bac6a194db0fa730c2b81a}{WimaxMacQueue::m\_traceDrop}),
101                      \textcolor{stringliteral}{"ns3::Packet::TracedCallback"})
102   ;
103   \textcolor{keywordflow}{return} tid;
104 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 18


\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!Is\+Empty@{Is\+Empty}}
\index{Is\+Empty@{Is\+Empty}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{Is\+Empty(void) const }{IsEmpty(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Wimax\+Mac\+Queue\+::\+Is\+Empty (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1WimaxMacQueue_a45fc4e6c31ac1789b8fdedf4a8714e12}{}\label{classns3_1_1WimaxMacQueue_a45fc4e6c31ac1789b8fdedf4a8714e12}


Check if queue is empty. 


\begin{DoxyCode}
470 \{
471   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1WimaxMacQueue_ad372c20acfe0acf6df6280662d63bdae}{m\_queue}.empty ();
472 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 19


\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!Is\+Empty@{Is\+Empty}}
\index{Is\+Empty@{Is\+Empty}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{Is\+Empty(\+Mac\+Header\+Type\+::\+Header\+Type packet\+Type) const }{IsEmpty(MacHeaderType::HeaderType packetType) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Wimax\+Mac\+Queue\+::\+Is\+Empty (
\begin{DoxyParamCaption}
\item[{{\bf Mac\+Header\+Type\+::\+Header\+Type}}]{packet\+Type}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1WimaxMacQueue_ac5441bd719302dd5e546601c19b0b23c}{}\label{classns3_1_1WimaxMacQueue_ac5441bd719302dd5e546601c19b0b23c}
Exclusively for SS. \begin{DoxyReturn}{Returns}
true if queue is empty of type packet\+Type 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em packet\+Type} & packet type to check \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
476 \{
477   \textcolor{keywordflow}{if} (packetType == \hyperlink{classns3_1_1MacHeaderType_a54d8fc8bc93a2b7865627965cdd31c20a48fe5b2f20cadf78008c71469b518403}{MacHeaderType::HEADER\_TYPE\_GENERIC})
478     \{
479       \textcolor{keywordflow}{return} \hyperlink{classns3_1_1WimaxMacQueue_ac47e05e3e877edf7d7a3d2b5d20d514a}{m\_nrDataPackets} == 0;
480     \}
481   \textcolor{keywordflow}{else}
482     \{
483       \textcolor{keywordflow}{return} \hyperlink{classns3_1_1WimaxMacQueue_ad71c2599f50a2be15f7ce9abba5a539d}{m\_nrRequestPackets} == 0;
484     \}
485 
486   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
487 \}
\end{DoxyCode}
\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!Peek@{Peek}}
\index{Peek@{Peek}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{Peek(\+Generic\+Mac\+Header \&hdr) const }{Peek(GenericMacHeader &hdr) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Packet} $>$ ns3\+::\+Wimax\+Mac\+Queue\+::\+Peek (
\begin{DoxyParamCaption}
\item[{{\bf Generic\+Mac\+Header} \&}]{hdr}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1WimaxMacQueue_a7bf8900208851fcfca4466dd9b932fb3}{}\label{classns3_1_1WimaxMacQueue_a7bf8900208851fcfca4466dd9b932fb3}


Exclusively for BS. Two versions of Peek function (with Generic M\+AC \hyperlink{classns3_1_1Header}{Header} as parameter) only for BS, as BS\textquotesingle{}s scheduler needs to know the C\+ID in Generic M\+AC \hyperlink{classns3_1_1Header}{Header}. 


\begin{DoxyParams}{Parameters}
{\em hdr} & the header of the packet \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the first packet in the queue 
\end{DoxyReturn}

\begin{DoxyCode}
331 \{
332   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1WimaxMacQueue_a45fc4e6c31ac1789b8fdedf4a8714e12}{IsEmpty} ())
333     \{
334       QueueElement element = \hyperlink{classns3_1_1WimaxMacQueue_ad372c20acfe0acf6df6280662d63bdae}{m\_queue}.front ();
335       hdr = element.m\_hdr;
336       Ptr<Packet> packet = element.m\_packet->Copy ();
337 
338       \textcolor{comment}{// this function must not be used by SS as it may be then a bandwidth request header}
339       packet->AddHeader (element.m\_hdr);
340       \textcolor{keywordflow}{return} packet;
341     \}
342 
343   \textcolor{keywordflow}{return} 0;
344 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 20


\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!Peek@{Peek}}
\index{Peek@{Peek}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{Peek(\+Generic\+Mac\+Header \&hdr, Time \&time\+Stamp) const }{Peek(GenericMacHeader &hdr, Time &timeStamp) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Packet} $>$ ns3\+::\+Wimax\+Mac\+Queue\+::\+Peek (
\begin{DoxyParamCaption}
\item[{{\bf Generic\+Mac\+Header} \&}]{hdr, }
\item[{{\bf Time} \&}]{time\+Stamp}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1WimaxMacQueue_ae09bc0203b50fb1f0d377cdcc1ee4e9c}{}\label{classns3_1_1WimaxMacQueue_ae09bc0203b50fb1f0d377cdcc1ee4e9c}


Exclusively for BS. Two versions of Peek function (with Generic M\+AC \hyperlink{classns3_1_1Header}{Header} as parameter) only for BS, as BS\textquotesingle{}s scheduler needs to know the C\+ID in Generic M\+AC \hyperlink{classns3_1_1Header}{Header}. 


\begin{DoxyParams}{Parameters}
{\em hdr} & the header of the packet \\
\hline
{\em time\+Stamp} & the timestamp of the packet \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the first packet in the queue 
\end{DoxyReturn}

\begin{DoxyCode}
348 \{
349   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1WimaxMacQueue_a45fc4e6c31ac1789b8fdedf4a8714e12}{IsEmpty} ())
350     \{
351       QueueElement element = \hyperlink{classns3_1_1WimaxMacQueue_ad372c20acfe0acf6df6280662d63bdae}{m\_queue}.front ();
352       hdr = element.m\_hdr;
353       timeStamp = element.m\_timeStamp;
354       Ptr<Packet> packet = element.m\_packet->Copy ();
355 
356       \textcolor{comment}{// this function must not be used for by SS as it may be then a bandwidth request header}
357       packet->AddHeader (element.m\_hdr);
358       \textcolor{keywordflow}{return} packet;
359     \}
360 
361   \textcolor{keywordflow}{return} 0;
362 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 21


\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!Peek@{Peek}}
\index{Peek@{Peek}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{Peek(\+Mac\+Header\+Type\+::\+Header\+Type packet\+Type) const }{Peek(MacHeaderType::HeaderType packetType) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Packet} $>$ ns3\+::\+Wimax\+Mac\+Queue\+::\+Peek (
\begin{DoxyParamCaption}
\item[{{\bf Mac\+Header\+Type\+::\+Header\+Type}}]{packet\+Type}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1WimaxMacQueue_adb1a4885bd8be2e4245ad7e494c48ea7}{}\label{classns3_1_1WimaxMacQueue_adb1a4885bd8be2e4245ad7e494c48ea7}


Two versions for SS without Generic M\+AC \hyperlink{classns3_1_1Header}{Header} parameter, as SS\textquotesingle{}s scheduler does not require to know the C\+ID in Generic M\+AC \hyperlink{classns3_1_1Header}{Header}. 


\begin{DoxyParams}{Parameters}
{\em packet\+Type} & the type of the packet \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the first packet in the queue 
\end{DoxyReturn}

\begin{DoxyCode}
366 \{
367   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1WimaxMacQueue_a45fc4e6c31ac1789b8fdedf4a8714e12}{IsEmpty} ())
368     \{
369       QueueElement element = \hyperlink{classns3_1_1WimaxMacQueue_ab02b8007b7f0090eccaf01a3d3dc0b98}{Front} (packetType);
370       Ptr<Packet> packet = element.m\_packet->Copy ();
371 
372       \textcolor{comment}{/*check because may be it is a bandwidth request packet (in which case a Bandwidth Request Header}
373 \textcolor{comment}{       has already been added to the packet) in which case Generic MAC Header will not be added to it.}
374 \textcolor{comment}{       this will only happen in the case of SS as only SS sends the bandwidth request packet. */}
375       \textcolor{keywordflow}{if} (element.m\_hdrType.GetType () == \hyperlink{classns3_1_1MacHeaderType_a54d8fc8bc93a2b7865627965cdd31c20a48fe5b2f20cadf78008c71469b518403}{MacHeaderType::HEADER\_TYPE\_GENERIC}
      )
376         \{
377           packet->AddHeader (element.m\_hdr);
378         \}
379       \textcolor{keywordflow}{return} packet;
380     \}
381 
382   \textcolor{keywordflow}{return} 0;
383 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 22


\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!Peek@{Peek}}
\index{Peek@{Peek}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{Peek(\+Mac\+Header\+Type\+::\+Header\+Type packet\+Type, Time \&time\+Stamp) const }{Peek(MacHeaderType::HeaderType packetType, Time &timeStamp) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Packet} $>$ ns3\+::\+Wimax\+Mac\+Queue\+::\+Peek (
\begin{DoxyParamCaption}
\item[{{\bf Mac\+Header\+Type\+::\+Header\+Type}}]{packet\+Type, }
\item[{{\bf Time} \&}]{time\+Stamp}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1WimaxMacQueue_ad7697d4f2831b59dedfb3ad4b1c65c40}{}\label{classns3_1_1WimaxMacQueue_ad7697d4f2831b59dedfb3ad4b1c65c40}


Two versions for SS without Generic M\+AC \hyperlink{classns3_1_1Header}{Header} parameter, as SS\textquotesingle{}s scheduler does not require to know the C\+ID in Generic M\+AC \hyperlink{classns3_1_1Header}{Header}. 


\begin{DoxyParams}{Parameters}
{\em packet\+Type} & the type of the packet \\
\hline
{\em time\+Stamp} & the timestamp of the packet \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the first packet in the queue 
\end{DoxyReturn}

\begin{DoxyCode}
388 \{
389   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1WimaxMacQueue_a45fc4e6c31ac1789b8fdedf4a8714e12}{IsEmpty} ())
390     \{
391       QueueElement element = \hyperlink{classns3_1_1WimaxMacQueue_ab02b8007b7f0090eccaf01a3d3dc0b98}{Front} (packetType);
392       timeStamp = element.m\_timeStamp;
393       Ptr<Packet> packet = element.m\_packet->Copy ();
394 
395       \textcolor{comment}{/*check because may be it is a bandwidth request packet (in which case a Bandwidth Request Header}
396 \textcolor{comment}{       has already been added to the packet) in which case Generic MAC Header will not be added to it.}
397 \textcolor{comment}{       this will only happen in the case of SS as only SS sends the bandwidth request packet. */}
398       \textcolor{keywordflow}{if} (element.m\_hdrType.GetType () == \hyperlink{classns3_1_1MacHeaderType_a54d8fc8bc93a2b7865627965cdd31c20a48fe5b2f20cadf78008c71469b518403}{MacHeaderType::HEADER\_TYPE\_GENERIC}
      )
399         \{
400           packet->AddHeader (element.m\_hdr);
401         \}
402       \textcolor{keywordflow}{return} packet;
403     \}
404 
405   \textcolor{keywordflow}{return} 0;
406 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 23


\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!Pop@{Pop}}
\index{Pop@{Pop}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{Pop(\+Mac\+Header\+Type\+::\+Header\+Type packet\+Type)}{Pop(MacHeaderType::HeaderType packetType)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Wimax\+Mac\+Queue\+::\+Pop (
\begin{DoxyParamCaption}
\item[{{\bf Mac\+Header\+Type\+::\+Header\+Type}}]{packet\+Type}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WimaxMacQueue_a35f80569dacb6e4b01ecadc4f3fa7dd4}{}\label{classns3_1_1WimaxMacQueue_a35f80569dacb6e4b01ecadc4f3fa7dd4}
Pop function 
\begin{DoxyParams}{Parameters}
{\em packet\+Type} & the packet type \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
453 \{
454   QueueElement element;
455 
456   \textcolor{keywordflow}{for} (std::deque<QueueElement>::iterator iter = \hyperlink{classns3_1_1WimaxMacQueue_ad372c20acfe0acf6df6280662d63bdae}{m\_queue}.begin (); iter
457        != \hyperlink{classns3_1_1WimaxMacQueue_ad372c20acfe0acf6df6280662d63bdae}{m\_queue}.end (); ++iter)
458     \{
459       element = *iter;
460       \textcolor{keywordflow}{if} (element.m\_hdrType.GetType () == packetType)
461         \{
462           \hyperlink{classns3_1_1WimaxMacQueue_ad372c20acfe0acf6df6280662d63bdae}{m\_queue}.erase (iter);
463           \textcolor{keywordflow}{break};
464         \}
465     \}
466 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 24




Here is the caller graph for this function\+:
% FIG 25


\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!Set\+Fragmentation@{Set\+Fragmentation}}
\index{Set\+Fragmentation@{Set\+Fragmentation}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{Set\+Fragmentation(\+Mac\+Header\+Type\+::\+Header\+Type packet\+Type)}{SetFragmentation(MacHeaderType::HeaderType packetType)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Wimax\+Mac\+Queue\+::\+Set\+Fragmentation (
\begin{DoxyParamCaption}
\item[{{\bf Mac\+Header\+Type\+::\+Header\+Type}}]{packet\+Type}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WimaxMacQueue_a7f76b9df9eb4acabad4609839ecda8f1}{}\label{classns3_1_1WimaxMacQueue_a7f76b9df9eb4acabad4609839ecda8f1}


Set fragmentation function. 

Set fragmentation state for first packet of type packet\+Type 
\begin{DoxyParams}{Parameters}
{\em packet\+Type} & packet\+Type to check \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
603 \{
604   \textcolor{keywordflow}{for} (std::deque<QueueElement>::iterator iter = \hyperlink{classns3_1_1WimaxMacQueue_ad372c20acfe0acf6df6280662d63bdae}{m\_queue}.begin (); iter
605        != \hyperlink{classns3_1_1WimaxMacQueue_ad372c20acfe0acf6df6280662d63bdae}{m\_queue}.end (); ++iter)
606     \{
607       \textcolor{keywordflow}{if} (iter->m\_hdrType.GetType () == packetType)
608         \{
609           iter->SetFragmentation ();
610           \textcolor{keywordflow}{break};
611         \}
612     \}
613 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 26


\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!Set\+Fragment\+Number@{Set\+Fragment\+Number}}
\index{Set\+Fragment\+Number@{Set\+Fragment\+Number}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{Set\+Fragment\+Number(\+Mac\+Header\+Type\+::\+Header\+Type packet\+Type)}{SetFragmentNumber(MacHeaderType::HeaderType packetType)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Wimax\+Mac\+Queue\+::\+Set\+Fragment\+Number (
\begin{DoxyParamCaption}
\item[{{\bf Mac\+Header\+Type\+::\+Header\+Type}}]{packet\+Type}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WimaxMacQueue_a7dc69d2eec5b050e18852796e502610e}{}\label{classns3_1_1WimaxMacQueue_a7dc69d2eec5b050e18852796e502610e}
Set fragment number for first packet of type packet\+Type 
\begin{DoxyParams}{Parameters}
{\em packet\+Type} & packet\+Type to check \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
617 \{
618   \textcolor{keywordflow}{for} (std::deque<QueueElement>::iterator iter = \hyperlink{classns3_1_1WimaxMacQueue_ad372c20acfe0acf6df6280662d63bdae}{m\_queue}.begin (); iter
619        != \hyperlink{classns3_1_1WimaxMacQueue_ad372c20acfe0acf6df6280662d63bdae}{m\_queue}.end (); ++iter)
620     \{
621       \textcolor{keywordflow}{if} (iter->m\_hdrType.GetType () == packetType)
622         \{
623           iter->SetFragmentNumber ();
624           \textcolor{keywordflow}{break};
625         \}
626     \}
627 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 27


\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!Set\+Fragment\+Offset@{Set\+Fragment\+Offset}}
\index{Set\+Fragment\+Offset@{Set\+Fragment\+Offset}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{Set\+Fragment\+Offset(\+Mac\+Header\+Type\+::\+Header\+Type packet\+Type, uint32\+\_\+t offset)}{SetFragmentOffset(MacHeaderType::HeaderType packetType, uint32_t offset)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Wimax\+Mac\+Queue\+::\+Set\+Fragment\+Offset (
\begin{DoxyParamCaption}
\item[{{\bf Mac\+Header\+Type\+::\+Header\+Type}}]{packet\+Type, }
\item[{uint32\+\_\+t}]{offset}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WimaxMacQueue_a9cbf603913fc930f22d8ba27c14838e1}{}\label{classns3_1_1WimaxMacQueue_a9cbf603913fc930f22d8ba27c14838e1}
Set fragment offset for first packet of type packet\+Type 
\begin{DoxyParams}{Parameters}
{\em packet\+Type} & packet\+Type to check \\
\hline
{\em offset} & offset value to set \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
631 \{
632   \textcolor{keywordflow}{for} (std::deque<QueueElement>::iterator iter = \hyperlink{classns3_1_1WimaxMacQueue_ad372c20acfe0acf6df6280662d63bdae}{m\_queue}.begin (); iter
633        != \hyperlink{classns3_1_1WimaxMacQueue_ad372c20acfe0acf6df6280662d63bdae}{m\_queue}.end (); ++iter)
634     \{
635       \textcolor{keywordflow}{if} (iter->m\_hdrType.GetType () == packetType)
636         \{
637           iter->SetFragmentOffset (offset);
638           \textcolor{keywordflow}{break};
639         \}
640     \}
641 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 28


\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!Set\+Max\+Size@{Set\+Max\+Size}}
\index{Set\+Max\+Size@{Set\+Max\+Size}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{Set\+Max\+Size(uint32\+\_\+t max\+Size)}{SetMaxSize(uint32_t maxSize)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Wimax\+Mac\+Queue\+::\+Set\+Max\+Size (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{max\+Size}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1WimaxMacQueue_a36209a94c1f33be73c2445545a1892b0}{}\label{classns3_1_1WimaxMacQueue_a36209a94c1f33be73c2445545a1892b0}


set the maximum queue size 


\begin{DoxyParams}{Parameters}
{\em max\+Size} & the max queue size \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
128 \{
129   \hyperlink{classns3_1_1WimaxMacQueue_aca04b5018ab36d96092f19467d381efd}{m\_maxSize} = maxSize;
130 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 29




\subsection{Member Data Documentation}
\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!m\+\_\+bytes@{m\+\_\+bytes}}
\index{m\+\_\+bytes@{m\+\_\+bytes}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{m\+\_\+bytes}{m_bytes}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Wimax\+Mac\+Queue\+::m\+\_\+bytes\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WimaxMacQueue_a79c3fd93dfef8c78b074c2aa6f2266ea}{}\label{classns3_1_1WimaxMacQueue_a79c3fd93dfef8c78b074c2aa6f2266ea}


bytes 

\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!m\+\_\+max\+Size@{m\+\_\+max\+Size}}
\index{m\+\_\+max\+Size@{m\+\_\+max\+Size}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Size}{m_maxSize}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Wimax\+Mac\+Queue\+::m\+\_\+max\+Size\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WimaxMacQueue_aca04b5018ab36d96092f19467d381efd}{}\label{classns3_1_1WimaxMacQueue_aca04b5018ab36d96092f19467d381efd}


maximum size 

\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!m\+\_\+nr\+Data\+Packets@{m\+\_\+nr\+Data\+Packets}}
\index{m\+\_\+nr\+Data\+Packets@{m\+\_\+nr\+Data\+Packets}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{m\+\_\+nr\+Data\+Packets}{m_nrDataPackets}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Wimax\+Mac\+Queue\+::m\+\_\+nr\+Data\+Packets\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WimaxMacQueue_ac47e05e3e877edf7d7a3d2b5d20d514a}{}\label{classns3_1_1WimaxMacQueue_ac47e05e3e877edf7d7a3d2b5d20d514a}


number data packets 

\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!m\+\_\+nr\+Request\+Packets@{m\+\_\+nr\+Request\+Packets}}
\index{m\+\_\+nr\+Request\+Packets@{m\+\_\+nr\+Request\+Packets}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{m\+\_\+nr\+Request\+Packets}{m_nrRequestPackets}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Wimax\+Mac\+Queue\+::m\+\_\+nr\+Request\+Packets\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WimaxMacQueue_ad71c2599f50a2be15f7ce9abba5a539d}{}\label{classns3_1_1WimaxMacQueue_ad71c2599f50a2be15f7ce9abba5a539d}


number request packets 

\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!m\+\_\+queue@{m\+\_\+queue}}
\index{m\+\_\+queue@{m\+\_\+queue}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{m\+\_\+queue}{m_queue}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Packet\+Queue} ns3\+::\+Wimax\+Mac\+Queue\+::m\+\_\+queue\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WimaxMacQueue_ad372c20acfe0acf6df6280662d63bdae}{}\label{classns3_1_1WimaxMacQueue_ad372c20acfe0acf6df6280662d63bdae}


the queue 

\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!m\+\_\+trace\+Dequeue@{m\+\_\+trace\+Dequeue}}
\index{m\+\_\+trace\+Dequeue@{m\+\_\+trace\+Dequeue}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{m\+\_\+trace\+Dequeue}{m_traceDequeue}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Wimax\+Mac\+Queue\+::m\+\_\+trace\+Dequeue\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WimaxMacQueue_a3a84896e087a831d26cb904927e8cbed}{}\label{classns3_1_1WimaxMacQueue_a3a84896e087a831d26cb904927e8cbed}


dequeue trace callback 

\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!m\+\_\+trace\+Drop@{m\+\_\+trace\+Drop}}
\index{m\+\_\+trace\+Drop@{m\+\_\+trace\+Drop}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{m\+\_\+trace\+Drop}{m_traceDrop}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Wimax\+Mac\+Queue\+::m\+\_\+trace\+Drop\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WimaxMacQueue_af12e3058d4bac6a194db0fa730c2b81a}{}\label{classns3_1_1WimaxMacQueue_af12e3058d4bac6a194db0fa730c2b81a}


drop trace callback 

\index{ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}!m\+\_\+trace\+Enqueue@{m\+\_\+trace\+Enqueue}}
\index{m\+\_\+trace\+Enqueue@{m\+\_\+trace\+Enqueue}!ns3\+::\+Wimax\+Mac\+Queue@{ns3\+::\+Wimax\+Mac\+Queue}}
\subsubsection[{\texorpdfstring{m\+\_\+trace\+Enqueue}{m_traceEnqueue}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$ $>$ ns3\+::\+Wimax\+Mac\+Queue\+::m\+\_\+trace\+Enqueue\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1WimaxMacQueue_a4adff7167ee1ca8490d246560770ea20}{}\label{classns3_1_1WimaxMacQueue_a4adff7167ee1ca8490d246560770ea20}


enqueue trace callback 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
wimax/model/\hyperlink{wimax-mac-queue_8h}{wimax-\/mac-\/queue.\+h}\item 
wimax/model/\hyperlink{wimax-mac-queue_8cc}{wimax-\/mac-\/queue.\+cc}\end{DoxyCompactItemize}
