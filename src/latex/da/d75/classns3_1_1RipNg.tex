\hypertarget{classns3_1_1RipNg}{}\section{ns3\+:\+:Rip\+Ng Class Reference}
\label{classns3_1_1RipNg}\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}


R\+I\+Png Routing Protocol, defined in \{2080\}.  




{\ttfamily \#include $<$ripng.\+h$>$}



Inheritance diagram for ns3\+:\+:Rip\+Ng\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Rip\+Ng\+:
% FIG 1
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classns3_1_1RipNg_a2baa3148870b411bccfe688079fb40a7}{Split\+Horizon\+Type\+\_\+e} \{ \hyperlink{classns3_1_1RipNg_a2baa3148870b411bccfe688079fb40a7a87060df7c85bafc99b78440f423a171b}{N\+O\+\_\+\+S\+P\+L\+I\+T\+\_\+\+H\+O\+R\+I\+Z\+ON}, 
\hyperlink{classns3_1_1RipNg_a2baa3148870b411bccfe688079fb40a7a65efd4b3a6b5b8be8e16038fec0cad4e}{S\+P\+L\+I\+T\+\_\+\+H\+O\+R\+I\+Z\+ON}, 
\hyperlink{classns3_1_1RipNg_a2baa3148870b411bccfe688079fb40a7a68187e765b02506b3891b87a513fac2f}{P\+O\+I\+S\+O\+N\+\_\+\+R\+E\+V\+E\+R\+SE}
 \}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1RipNg_aa7816865151af06b32f54f67e156f9d4}{Rip\+Ng} ()
\item 
virtual \hyperlink{classns3_1_1RipNg_aff904c44cc5de62ddaa6bce16efc601a}{$\sim$\+Rip\+Ng} ()
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Route}{Ipv6\+Route} $>$ \hyperlink{classns3_1_1RipNg_acc42ebebc7e1b3ccb68c7be6b2f37f95}{Route\+Output} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ oif, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket\+::\+Socket\+Errno} \&sockerr)
\begin{DoxyCompactList}\small\item\em Query routing cache for an existing route, for an outbound packet. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1RipNg_ad85da69a6006cd5089e1a69e7a6be13b}{Route\+Input} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ idev, \hyperlink{classns3_1_1Ipv6RoutingProtocol_a579fd6755ee873009819f7117371fea7}{Unicast\+Forward\+Callback} ucb, \hyperlink{classns3_1_1Ipv6RoutingProtocol_a5f12e04512ce8e5808c3cceff6b8918f}{Multicast\+Forward\+Callback} mcb, \hyperlink{classns3_1_1Ipv6RoutingProtocol_a93f6c06be1e024747e95f4299eba74a6}{Local\+Deliver\+Callback} lcb, \hyperlink{classns3_1_1Ipv6RoutingProtocol_abfdf43594e2ae97e1a4dc340e3a086a5}{Error\+Callback} ecb)
\begin{DoxyCompactList}\small\item\em Route an input packet (to be forwarded or locally delivered) \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1RipNg_a588e191ae91316e498a8e5c84a9c77fb}{Notify\+Interface\+Up} (uint32\+\_\+t interface)
\begin{DoxyCompactList}\small\item\em Notify when specified interface goes UP. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1RipNg_a2031124814e8d817d0a40dddb7327a1b}{Notify\+Interface\+Down} (uint32\+\_\+t interface)
\begin{DoxyCompactList}\small\item\em Notify when specified interface goes D\+O\+WN. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1RipNg_a9d6ffbffc76b029e5dfc9f394549d670}{Notify\+Add\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv6InterfaceAddress}{Ipv6\+Interface\+Address} address)
\begin{DoxyCompactList}\small\item\em Notify when specified interface add an address. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1RipNg_a0658ff312aa09265ddc9ad8718789f0a}{Notify\+Remove\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv6InterfaceAddress}{Ipv6\+Interface\+Address} address)
\begin{DoxyCompactList}\small\item\em Notify when specified interface add an address. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1RipNg_a57bee3de4b39e03ad66e3fd35abf4805}{Notify\+Add\+Route} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dst, \hyperlink{classns3_1_1Ipv6Prefix}{Ipv6\+Prefix} mask, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} next\+Hop, uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} prefix\+To\+Use=\hyperlink{classns3_1_1Ipv6Address_a63a34bdb1505e05fbdd07d316d0bd7e6}{Ipv6\+Address\+::\+Get\+Zero}())
\begin{DoxyCompactList}\small\item\em Notify a new route. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1RipNg_a72de5c5fbbe3bd7f29a5b05d3dd46c16}{Notify\+Remove\+Route} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dst, \hyperlink{classns3_1_1Ipv6Prefix}{Ipv6\+Prefix} mask, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} next\+Hop, uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} prefix\+To\+Use=\hyperlink{classns3_1_1Ipv6Address_a63a34bdb1505e05fbdd07d316d0bd7e6}{Ipv6\+Address\+::\+Get\+Zero}())
\begin{DoxyCompactList}\small\item\em Notify route removing. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1RipNg_acd8e0a2b2453a28ecd4154729e45d324}{Set\+Ipv6} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6}{Ipv6} $>$ ipv6)
\begin{DoxyCompactList}\small\item\em Typically, invoked directly or indirectly from \hyperlink{classns3_1_1Ipv6_aa889d2174527a1df773d65974de83f8f}{ns3\+::\+Ipv6\+::\+Set\+Routing\+Protocol}. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1RipNg_aec30027ca8085a46d680b98291e27480}{Print\+Routing\+Table} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream, \hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295a}{Time\+::\+Unit} unit=\hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295aade8622b06524a328cd3a59db6ccf76af}{Time\+::S}) const 
\begin{DoxyCompactList}\small\item\em Print the Routing Table entries. \end{DoxyCompactList}\item 
int64\+\_\+t \hyperlink{classns3_1_1RipNg_a98e8ebdf17fdb302e0619246b88954a5}{Assign\+Streams} (int64\+\_\+t stream)
\item 
std\+::set$<$ uint32\+\_\+t $>$ \hyperlink{classns3_1_1RipNg_a5ad1b90a1ca236c9d51ee4ecba9aafe1}{Get\+Interface\+Exclusions} () const 
\begin{DoxyCompactList}\small\item\em Get the set of interface excluded from the protocol. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1RipNg_a4dce40799b2b372ef7fc31901d8b5114}{Set\+Interface\+Exclusions} (std\+::set$<$ uint32\+\_\+t $>$ exceptions)
\begin{DoxyCompactList}\small\item\em Set the set of interface excluded from the protocol. \end{DoxyCompactList}\item 
uint8\+\_\+t \hyperlink{classns3_1_1RipNg_a964ec14240c70f31176307334c00b936}{Get\+Interface\+Metric} (uint32\+\_\+t interface) const 
\begin{DoxyCompactList}\small\item\em Get the metric for an interface. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1RipNg_a98e6039328b6d70dd97bfd8edbf24ba3}{Set\+Interface\+Metric} (uint32\+\_\+t interface, uint8\+\_\+t metric)
\begin{DoxyCompactList}\small\item\em Set the metric for an interface. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1RipNg_aec1f0a59262b185e302f69395a615a87}{Add\+Default\+Route\+To} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} next\+Hop, uint32\+\_\+t interface)
\begin{DoxyCompactList}\small\item\em Add a default route to the router through the next\+Hop located on interface. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1RipNg_a4c5b07bdfcaaf3537f880d37a311a221}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1RipNg_a052d51c5f6f76871e12491780ab3ebf5}{Do\+Dispose} ()
\begin{DoxyCompactList}\small\item\em Dispose this object. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1RipNg_a81a7056d4a1d1afc266181406f5dbf64}{Do\+Initialize} ()
\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ std\+::pair$<$ \hyperlink{classns3_1_1RipNgRoutingTableEntry}{Rip\+Ng\+Routing\+Table\+Entry} $\ast$, \hyperlink{classns3_1_1EventId}{Event\+Id} $>$ $>$ \hyperlink{classns3_1_1RipNg_a1d5addc59db17a00021a99e7d6ff9ccd}{Routes}
\begin{DoxyCompactList}\small\item\em Container for the network routes -\/ pair \hyperlink{classns3_1_1RipNgRoutingTableEntry}{Rip\+Ng\+Routing\+Table\+Entry} $\ast$, \hyperlink{classns3_1_1EventId}{Event\+Id} (update event) \end{DoxyCompactList}\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ std\+::pair$<$ \hyperlink{classns3_1_1RipNgRoutingTableEntry}{Rip\+Ng\+Routing\+Table\+Entry} $\ast$, \hyperlink{classns3_1_1EventId}{Event\+Id} $>$ $>$\+::const\+\_\+iterator \hyperlink{classns3_1_1RipNg_a139e1c11e66791c62fa5ccf632723f95}{Routes\+CI}
\begin{DoxyCompactList}\small\item\em Const Iterator for container for the network routes. \end{DoxyCompactList}\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ std\+::pair$<$ \hyperlink{classns3_1_1RipNgRoutingTableEntry}{Rip\+Ng\+Routing\+Table\+Entry} $\ast$, \hyperlink{classns3_1_1EventId}{Event\+Id} $>$ $>$\+::iterator \hyperlink{classns3_1_1RipNg_aa8bc6103d67089e1e3cd507936f94887}{RoutesI}
\begin{DoxyCompactList}\small\item\em Iterator for container for the network routes. \end{DoxyCompactList}\item 
typedef std\+::map$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$, uint32\+\_\+t $>$ \hyperlink{classns3_1_1RipNg_a30c4bb1a1f2d08a0387268645d15d328}{Socket\+List}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Socket}{Socket} list type. \end{DoxyCompactList}\item 
typedef std\+::map$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$, uint32\+\_\+t $>$\+::iterator \hyperlink{classns3_1_1RipNg_a549052bbb55168d029f82d78384144b4}{Socket\+ListI}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Socket}{Socket} list type iterator. \end{DoxyCompactList}\item 
typedef std\+::map$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$, uint32\+\_\+t $>$\+::const\+\_\+iterator \hyperlink{classns3_1_1RipNg_a7b361620ae7f6a01aadf958b9822f3fb}{Socket\+List\+CI}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Socket}{Socket} list type const iterator. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classns3_1_1RipNg_ae8891520b5ae87abed2e2a15d50ba4d8}{Receive} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$ socket)
\begin{DoxyCompactList}\small\item\em Receive R\+I\+Png packets. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1RipNg_adb06ee7b823c0d7ae5b45b637c1ffd19}{Handle\+Requests} (\hyperlink{classns3_1_1RipNgHeader}{Rip\+Ng\+Header} hdr, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} sender\+Address, uint16\+\_\+t sender\+Port, uint32\+\_\+t incoming\+Interface, uint8\+\_\+t hop\+Limit)
\begin{DoxyCompactList}\small\item\em Handle R\+I\+Png requests. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1RipNg_ade057ef030dc8cd6479949e35315ed7b}{Handle\+Responses} (\hyperlink{classns3_1_1RipNgHeader}{Rip\+Ng\+Header} hdr, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} sender\+Address, uint32\+\_\+t incoming\+Interface, uint8\+\_\+t hop\+Limit)
\begin{DoxyCompactList}\small\item\em Handle R\+I\+Png responses. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Route}{Ipv6\+Route} $>$ \hyperlink{classns3_1_1RipNg_ac008f65e3fe915230191cb1099890489}{Lookup} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dest, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$=0)
\begin{DoxyCompactList}\small\item\em Lookup in the forwarding table for destination. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1RipNg_a798a6be4d3b79cb54d3f434995802049}{Recv\+Unicast\+Ripng} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$ socket)
\item 
void \hyperlink{classns3_1_1RipNg_aa0d0eaae30d312fe172fa9a7fc8d6d48}{Recv\+Multicast\+Ripng} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$ socket)
\item 
void \hyperlink{classns3_1_1RipNg_a9d8c7bb0b6622946c347a88dabc06802}{Add\+Network\+Route\+To} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} network, \hyperlink{classns3_1_1Ipv6Prefix}{Ipv6\+Prefix} network\+Prefix, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} next\+Hop, uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} prefix\+To\+Use)
\begin{DoxyCompactList}\small\item\em Add route to network. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1RipNg_ad70799f2ec1d8ecb8829e6059114967d}{Add\+Network\+Route\+To} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} network, \hyperlink{classns3_1_1Ipv6Prefix}{Ipv6\+Prefix} network\+Prefix, uint32\+\_\+t interface)
\begin{DoxyCompactList}\small\item\em Add route to network. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1RipNg_a110005349bf811e1b0f6af182298be15}{Do\+Send\+Route\+Update} (bool periodic)
\begin{DoxyCompactList}\small\item\em Send Routing Updates on all interfaces. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1RipNg_aa97c9ec93505c548bbf85ef18c532147}{Send\+Route\+Request} ()
\begin{DoxyCompactList}\small\item\em Send Routing Request on all interfaces. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1RipNg_ad7a8e445116b3dd8cdd1d50366787c66}{Send\+Triggered\+Route\+Update} ()
\begin{DoxyCompactList}\small\item\em Send Triggered Routing Updates on all interfaces. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1RipNg_af4dc944e60808380f6c5af16bf867fdc}{Send\+Unsolicited\+Route\+Update} (void)
\begin{DoxyCompactList}\small\item\em Send Unsolicited Routing Updates on all interfaces. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1RipNg_ae4fc1ca9ed948f3c028fd96fb016f7dd}{Invalidate\+Route} (\hyperlink{classns3_1_1RipNgRoutingTableEntry}{Rip\+Ng\+Routing\+Table\+Entry} $\ast$route)
\begin{DoxyCompactList}\small\item\em Invalidate a route. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1RipNg_a9d1204fd821a2a528b250e57ddb0df04}{Delete\+Route} (\hyperlink{classns3_1_1RipNgRoutingTableEntry}{Rip\+Ng\+Routing\+Table\+Entry} $\ast$route)
\begin{DoxyCompactList}\small\item\em Delete a route. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1RipNg_a1d5addc59db17a00021a99e7d6ff9ccd}{Routes} \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\+\_\+routes}
\begin{DoxyCompactList}\small\item\em the forwarding table for network. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6}{Ipv6} $>$ \hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\+\_\+ipv6}
\begin{DoxyCompactList}\small\item\em I\+Pv6 reference. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1RipNg_a11c536612cb48e139d4a3b8d34c9ec3a}{m\+\_\+startup\+Delay}
\begin{DoxyCompactList}\small\item\em Random delay before protocol startup. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1RipNg_a4da2b49a558678bd4c51a995fbfbf7af}{m\+\_\+min\+Triggered\+Update\+Delay}
\begin{DoxyCompactList}\small\item\em Min cooldown delay after a Triggered Update. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1RipNg_a7087e78333b3a5caabc13a83753a13a2}{m\+\_\+max\+Triggered\+Update\+Delay}
\begin{DoxyCompactList}\small\item\em Max cooldown delay after a Triggered Update. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1RipNg_a8bedf450622f395cc52c1d37dc4d7a40}{m\+\_\+unsolicited\+Update}
\begin{DoxyCompactList}\small\item\em time between two Unsolicited Routing Updates \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1RipNg_aed45845b278332b589e76304a3701d72}{m\+\_\+timeout\+Delay}
\begin{DoxyCompactList}\small\item\em Delay before invalidating a route. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1RipNg_aa42bd385be7a330206d02e2e721edc19}{m\+\_\+garbage\+Collection\+Delay}
\begin{DoxyCompactList}\small\item\em Delay before deleting an I\+N\+V\+A\+L\+ID route. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1RipNg_a30c4bb1a1f2d08a0387268645d15d328}{Socket\+List} \hyperlink{classns3_1_1RipNg_a761d304dc3d34cd528afe87c5fa8090b}{m\+\_\+send\+Socket\+List}
\begin{DoxyCompactList}\small\item\em list of sockets for sending (socket, interface index) \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$ \hyperlink{classns3_1_1RipNg_a87437a46d9f4e0951f9d4c6b11208d4f}{m\+\_\+recv\+Socket}
\begin{DoxyCompactList}\small\item\em receive socket \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1EventId}{Event\+Id} \hyperlink{classns3_1_1RipNg_a673a77372c3bbc67338c52f6b0291134}{m\+\_\+next\+Unsolicited\+Update}
\begin{DoxyCompactList}\small\item\em Next Unsolicited Update event. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1EventId}{Event\+Id} \hyperlink{classns3_1_1RipNg_a382578c16a30ce7de28794defeb661e9}{m\+\_\+next\+Triggered\+Update}
\begin{DoxyCompactList}\small\item\em Next Triggered Update event. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UniformRandomVariable}{Uniform\+Random\+Variable} $>$ \hyperlink{classns3_1_1RipNg_adc89174a768de707315ed3cb88a6a0aa}{m\+\_\+rng}
\begin{DoxyCompactList}\small\item\em Rng stream. \end{DoxyCompactList}\item 
std\+::set$<$ uint32\+\_\+t $>$ \hyperlink{classns3_1_1RipNg_a98c5b63bb7c56afa595c1bb568a7081f}{m\+\_\+interface\+Exclusions}
\begin{DoxyCompactList}\small\item\em Set of excluded interfaces. \end{DoxyCompactList}\item 
std\+::map$<$ uint32\+\_\+t, uint8\+\_\+t $>$ \hyperlink{classns3_1_1RipNg_aa63ca4f7ad5ad13c878220c51d8b89c5}{m\+\_\+interface\+Metrics}
\begin{DoxyCompactList}\small\item\em Map of interface metrics. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1RipNg_a2baa3148870b411bccfe688079fb40a7}{Split\+Horizon\+Type\+\_\+e} \hyperlink{classns3_1_1RipNg_a2aaaf4747380a0960cc48cb04ae99a1a}{m\+\_\+split\+Horizon\+Strategy}
\begin{DoxyCompactList}\small\item\em Split Horizon strategy. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1RipNg_a789ca251ab1d869da5f62a4286067d2d}{m\+\_\+initialized}
\begin{DoxyCompactList}\small\item\em flag to allow socket\textquotesingle{}s late-\/creation. \end{DoxyCompactList}\item 
uint8\+\_\+t \hyperlink{classns3_1_1RipNg_a6752c1bb1fc0909f0493033d426f2b92}{m\+\_\+link\+Down}
\begin{DoxyCompactList}\small\item\em Link down value. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
R\+I\+Png Routing Protocol, defined in \{2080\}. 

\subsection{Member Typedef Documentation}
\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Routes@{Routes}}
\index{Routes@{Routes}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Routes}{Routes}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<$std\+::pair $<${\bf Rip\+Ng\+Routing\+Table\+Entry} $\ast$, {\bf Event\+Id}$>$ $>$ {\bf ns3\+::\+Rip\+Ng\+::\+Routes}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_a1d5addc59db17a00021a99e7d6ff9ccd}{}\label{classns3_1_1RipNg_a1d5addc59db17a00021a99e7d6ff9ccd}


Container for the network routes -\/ pair \hyperlink{classns3_1_1RipNgRoutingTableEntry}{Rip\+Ng\+Routing\+Table\+Entry} $\ast$, \hyperlink{classns3_1_1EventId}{Event\+Id} (update event) 

\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Routes\+CI@{Routes\+CI}}
\index{Routes\+CI@{Routes\+CI}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Routes\+CI}{RoutesCI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<$std\+::pair $<${\bf Rip\+Ng\+Routing\+Table\+Entry} $\ast$, {\bf Event\+Id}$>$ $>$\+::const\+\_\+iterator {\bf ns3\+::\+Rip\+Ng\+::\+Routes\+CI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_a139e1c11e66791c62fa5ccf632723f95}{}\label{classns3_1_1RipNg_a139e1c11e66791c62fa5ccf632723f95}


Const Iterator for container for the network routes. 

\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!RoutesI@{RoutesI}}
\index{RoutesI@{RoutesI}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{RoutesI}{RoutesI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<$std\+::pair $<${\bf Rip\+Ng\+Routing\+Table\+Entry} $\ast$, {\bf Event\+Id}$>$ $>$\+::iterator {\bf ns3\+::\+Rip\+Ng\+::\+RoutesI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_aa8bc6103d67089e1e3cd507936f94887}{}\label{classns3_1_1RipNg_aa8bc6103d67089e1e3cd507936f94887}


Iterator for container for the network routes. 

\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Socket\+List@{Socket\+List}}
\index{Socket\+List@{Socket\+List}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Socket\+List}{SocketList}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::map$<$ {\bf Ptr}$<${\bf Socket}$>$, uint32\+\_\+t$>$ {\bf ns3\+::\+Rip\+Ng\+::\+Socket\+List}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_a30c4bb1a1f2d08a0387268645d15d328}{}\label{classns3_1_1RipNg_a30c4bb1a1f2d08a0387268645d15d328}


\hyperlink{classns3_1_1Socket}{Socket} list type. 

\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Socket\+List\+CI@{Socket\+List\+CI}}
\index{Socket\+List\+CI@{Socket\+List\+CI}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Socket\+List\+CI}{SocketListCI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::map$<${\bf Ptr}$<${\bf Socket}$>$, uint32\+\_\+t$>$\+::const\+\_\+iterator {\bf ns3\+::\+Rip\+Ng\+::\+Socket\+List\+CI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_a7b361620ae7f6a01aadf958b9822f3fb}{}\label{classns3_1_1RipNg_a7b361620ae7f6a01aadf958b9822f3fb}


\hyperlink{classns3_1_1Socket}{Socket} list type const iterator. 

\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Socket\+ListI@{Socket\+ListI}}
\index{Socket\+ListI@{Socket\+ListI}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Socket\+ListI}{SocketListI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::map$<${\bf Ptr}$<${\bf Socket}$>$, uint32\+\_\+t$>$\+::iterator {\bf ns3\+::\+Rip\+Ng\+::\+Socket\+ListI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_a549052bbb55168d029f82d78384144b4}{}\label{classns3_1_1RipNg_a549052bbb55168d029f82d78384144b4}


\hyperlink{classns3_1_1Socket}{Socket} list type iterator. 



\subsection{Member Enumeration Documentation}
\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Split\+Horizon\+Type\+\_\+e@{Split\+Horizon\+Type\+\_\+e}}
\index{Split\+Horizon\+Type\+\_\+e@{Split\+Horizon\+Type\+\_\+e}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Split\+Horizon\+Type\+\_\+e}{SplitHorizonType_e}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf ns3\+::\+Rip\+Ng\+::\+Split\+Horizon\+Type\+\_\+e}}\hypertarget{classns3_1_1RipNg_a2baa3148870b411bccfe688079fb40a7}{}\label{classns3_1_1RipNg_a2baa3148870b411bccfe688079fb40a7}
Split Horizon strategy type. See \{2080\}. \begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{N\+O\+\_\+\+S\+P\+L\+I\+T\+\_\+\+H\+O\+R\+I\+Z\+ON@{N\+O\+\_\+\+S\+P\+L\+I\+T\+\_\+\+H\+O\+R\+I\+Z\+ON}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!N\+O\+\_\+\+S\+P\+L\+I\+T\+\_\+\+H\+O\+R\+I\+Z\+ON@{N\+O\+\_\+\+S\+P\+L\+I\+T\+\_\+\+H\+O\+R\+I\+Z\+ON}}\item[{\em 
N\+O\+\_\+\+S\+P\+L\+I\+T\+\_\+\+H\+O\+R\+I\+Z\+ON\hypertarget{classns3_1_1RipNg_a2baa3148870b411bccfe688079fb40a7a87060df7c85bafc99b78440f423a171b}{}\label{classns3_1_1RipNg_a2baa3148870b411bccfe688079fb40a7a87060df7c85bafc99b78440f423a171b}
}]No Split Horizon. \index{S\+P\+L\+I\+T\+\_\+\+H\+O\+R\+I\+Z\+ON@{S\+P\+L\+I\+T\+\_\+\+H\+O\+R\+I\+Z\+ON}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!S\+P\+L\+I\+T\+\_\+\+H\+O\+R\+I\+Z\+ON@{S\+P\+L\+I\+T\+\_\+\+H\+O\+R\+I\+Z\+ON}}\item[{\em 
S\+P\+L\+I\+T\+\_\+\+H\+O\+R\+I\+Z\+ON\hypertarget{classns3_1_1RipNg_a2baa3148870b411bccfe688079fb40a7a65efd4b3a6b5b8be8e16038fec0cad4e}{}\label{classns3_1_1RipNg_a2baa3148870b411bccfe688079fb40a7a65efd4b3a6b5b8be8e16038fec0cad4e}
}]Split Horizon. \index{P\+O\+I\+S\+O\+N\+\_\+\+R\+E\+V\+E\+R\+SE@{P\+O\+I\+S\+O\+N\+\_\+\+R\+E\+V\+E\+R\+SE}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!P\+O\+I\+S\+O\+N\+\_\+\+R\+E\+V\+E\+R\+SE@{P\+O\+I\+S\+O\+N\+\_\+\+R\+E\+V\+E\+R\+SE}}\item[{\em 
P\+O\+I\+S\+O\+N\+\_\+\+R\+E\+V\+E\+R\+SE\hypertarget{classns3_1_1RipNg_a2baa3148870b411bccfe688079fb40a7a68187e765b02506b3891b87a513fac2f}{}\label{classns3_1_1RipNg_a2baa3148870b411bccfe688079fb40a7a68187e765b02506b3891b87a513fac2f}
}]Poison Reverse Split Horizon. \end{description}
\end{Desc}

\begin{DoxyCode}
207                           \{
208     \hyperlink{classns3_1_1RipNg_a2baa3148870b411bccfe688079fb40a7a87060df7c85bafc99b78440f423a171b}{NO\_SPLIT\_HORIZON},
209     \hyperlink{classns3_1_1RipNg_a2baa3148870b411bccfe688079fb40a7a65efd4b3a6b5b8be8e16038fec0cad4e}{SPLIT\_HORIZON},   
210     \hyperlink{classns3_1_1RipNg_a2baa3148870b411bccfe688079fb40a7a68187e765b02506b3891b87a513fac2f}{POISON\_REVERSE},  
211   \};
\end{DoxyCode}


\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Rip\+Ng@{Rip\+Ng}}
\index{Rip\+Ng@{Rip\+Ng}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Rip\+Ng()}{RipNg()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Rip\+Ng\+::\+Rip\+Ng (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1RipNg_aa7816865151af06b32f54f67e156f9d4}{}\label{classns3_1_1RipNg_aa7816865151af06b32f54f67e156f9d4}

\begin{DoxyCode}
48   : \hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6} (0), \hyperlink{classns3_1_1RipNg_a2aaaf4747380a0960cc48cb04ae99a1a}{m\_splitHorizonStrategy} (
      \hyperlink{classns3_1_1RipNg_a2baa3148870b411bccfe688079fb40a7a68187e765b02506b3891b87a513fac2f}{RipNg::POISON\_REVERSE}), \hyperlink{classns3_1_1RipNg_a789ca251ab1d869da5f62a4286067d2d}{m\_initialized} (\textcolor{keyword}{false})
49 \{
50   \hyperlink{classns3_1_1RipNg_adc89174a768de707315ed3cb88a6a0aa}{m\_rng} = CreateObject<UniformRandomVariable> ();
51 \}
\end{DoxyCode}
\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!````~Rip\+Ng@{$\sim$\+Rip\+Ng}}
\index{````~Rip\+Ng@{$\sim$\+Rip\+Ng}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{$\sim$\+Rip\+Ng()}{~RipNg()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Rip\+Ng\+::$\sim$\+Rip\+Ng (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1RipNg_aff904c44cc5de62ddaa6bce16efc601a}{}\label{classns3_1_1RipNg_aff904c44cc5de62ddaa6bce16efc601a}

\begin{DoxyCode}
54 \{
55 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Add\+Default\+Route\+To@{Add\+Default\+Route\+To}}
\index{Add\+Default\+Route\+To@{Add\+Default\+Route\+To}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Add\+Default\+Route\+To(\+Ipv6\+Address next\+Hop, uint32\+\_\+t interface)}{AddDefaultRouteTo(Ipv6Address nextHop, uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+Ng\+::\+Add\+Default\+Route\+To (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{next\+Hop, }
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1RipNg_aec1f0a59262b185e302f69395a615a87}{}\label{classns3_1_1RipNg_aec1f0a59262b185e302f69395a615a87}


Add a default route to the router through the next\+Hop located on interface. 

The default route is usually installed manually, or it is the result of some \char`\"{}other\char`\"{} routing protocol (e.\+g., B\+GP).


\begin{DoxyParams}{Parameters}
{\em next\+Hop} & the next hop \\
\hline
{\em interface} & the interface \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1270 \{
1271   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << interface);
1272 
1273   \hyperlink{classns3_1_1RipNg_a9d8c7bb0b6622946c347a88dabc06802}{AddNetworkRouteTo} (Ipv6Address (\textcolor{stringliteral}{"::"}), \hyperlink{classns3_1_1Ipv6Prefix_ab32d2dbadcd8fa048ff296cb0a0e34ff}{Ipv6Prefix::GetZero} (), 
      nextHop, interface, Ipv6Address (\textcolor{stringliteral}{"::"}));
1274 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Add\+Network\+Route\+To@{Add\+Network\+Route\+To}}
\index{Add\+Network\+Route\+To@{Add\+Network\+Route\+To}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Add\+Network\+Route\+To(\+Ipv6\+Address network, Ipv6\+Prefix network\+Prefix, Ipv6\+Address next\+Hop, uint32\+\_\+t interface, Ipv6\+Address prefix\+To\+Use)}{AddNetworkRouteTo(Ipv6Address network, Ipv6Prefix networkPrefix, Ipv6Address nextHop, uint32_t interface, Ipv6Address prefixToUse)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+Ng\+::\+Add\+Network\+Route\+To (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{network, }
\item[{{\bf Ipv6\+Prefix}}]{network\+Prefix, }
\item[{{\bf Ipv6\+Address}}]{next\+Hop, }
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv6\+Address}}]{prefix\+To\+Use}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_a9d8c7bb0b6622946c347a88dabc06802}{}\label{classns3_1_1RipNg_a9d8c7bb0b6622946c347a88dabc06802}


Add route to network. 


\begin{DoxyParams}{Parameters}
{\em network} & network address \\
\hline
{\em network\+Prefix} & network prefix \\
\hline
{\em next\+Hop} & next hop address to route the packet. \\
\hline
{\em interface} & interface index \\
\hline
{\em prefix\+To\+Use} & prefix that should be used for source address for this destination \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
635 \{
636   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << network << networkPrefix << nextHop << interface << prefixToUse);
637 
638   \textcolor{keywordflow}{if} (nextHop.IsLinkLocal())
639     \{
640       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Ripng::AddNetworkRouteTo - Next hop should be link-local"});
641     \}
642 
643   RipNgRoutingTableEntry* route = \textcolor{keyword}{new} RipNgRoutingTableEntry (network, networkPrefix, nextHop, interface, 
      prefixToUse);
644   route->SetRouteMetric (1);
645   route->SetRouteStatus (\hyperlink{classns3_1_1RipNgRoutingTableEntry_af723fc23e97afdd05c55da5162b7e673a334e33ca88fb2b8de53c814814d3c017}{RipNgRoutingTableEntry::RIPNG\_VALID});
646   route->SetRouteChanged (\textcolor{keyword}{true});
647 
648   \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.push\_back (std::make\_pair (route, EventId ()));
649 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3




Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Add\+Network\+Route\+To@{Add\+Network\+Route\+To}}
\index{Add\+Network\+Route\+To@{Add\+Network\+Route\+To}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Add\+Network\+Route\+To(\+Ipv6\+Address network, Ipv6\+Prefix network\+Prefix, uint32\+\_\+t interface)}{AddNetworkRouteTo(Ipv6Address network, Ipv6Prefix networkPrefix, uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+Ng\+::\+Add\+Network\+Route\+To (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{network, }
\item[{{\bf Ipv6\+Prefix}}]{network\+Prefix, }
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_ad70799f2ec1d8ecb8829e6059114967d}{}\label{classns3_1_1RipNg_ad70799f2ec1d8ecb8829e6059114967d}


Add route to network. 


\begin{DoxyParams}{Parameters}
{\em network} & network address \\
\hline
{\em network\+Prefix} & network prefix \\
\hline
{\em interface} & interface index \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
652 \{
653   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << network << networkPrefix << interface);
654 
655   RipNgRoutingTableEntry* route = \textcolor{keyword}{new} RipNgRoutingTableEntry (network, networkPrefix, interface);
656   route->SetRouteMetric (1);
657   route->SetRouteStatus (\hyperlink{classns3_1_1RipNgRoutingTableEntry_af723fc23e97afdd05c55da5162b7e673a334e33ca88fb2b8de53c814814d3c017}{RipNgRoutingTableEntry::RIPNG\_VALID});
658   route->SetRouteChanged (\textcolor{keyword}{true});
659 
660   \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.push\_back (std::make\_pair (route, EventId ()));
661 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5


\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Assign\+Streams@{Assign\+Streams}}
\index{Assign\+Streams@{Assign\+Streams}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Assign\+Streams(int64\+\_\+t stream)}{AssignStreams(int64_t stream)}}]{\setlength{\rightskip}{0pt plus 5cm}int64\+\_\+t ns3\+::\+Rip\+Ng\+::\+Assign\+Streams (
\begin{DoxyParamCaption}
\item[{int64\+\_\+t}]{stream}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1RipNg_a98e8ebdf17fdb302e0619246b88954a5}{}\label{classns3_1_1RipNg_a98e8ebdf17fdb302e0619246b88954a5}
Assign a fixed random variable stream number to the random variables used by this model. Return the number of streams (possibly zero) that have been assigned.


\begin{DoxyParams}{Parameters}
{\em stream} & first stream index to use \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of stream indices assigned by this model 
\end{DoxyReturn}

\begin{DoxyCode}
103 \{
104   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << stream);
105 
106   \hyperlink{classns3_1_1RipNg_adc89174a768de707315ed3cb88a6a0aa}{m\_rng}->\hyperlink{classns3_1_1RandomVariableStream_add11aaf975607746b7e271d300659a94}{SetStream} (stream);
107   \textcolor{keywordflow}{return} 1;
108 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6


\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Delete\+Route@{Delete\+Route}}
\index{Delete\+Route@{Delete\+Route}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Delete\+Route(\+Rip\+Ng\+Routing\+Table\+Entry $\ast$route)}{DeleteRoute(RipNgRoutingTableEntry *route)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+Ng\+::\+Delete\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Rip\+Ng\+Routing\+Table\+Entry} $\ast$}]{route}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_a9d1204fd821a2a528b250e57ddb0df04}{}\label{classns3_1_1RipNg_a9d1204fd821a2a528b250e57ddb0df04}


Delete a route. 


\begin{DoxyParams}{Parameters}
{\em route} & the route to be removed \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
686 \{
687   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << *route);
688 
689   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1RipNg_aa8bc6103d67089e1e3cd507936f94887}{RoutesI} it = \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.begin (); it != \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.end (); it++)
690     \{
691       \textcolor{keywordflow}{if} (it->first == route)
692         \{
693           \textcolor{keyword}{delete} route;
694           \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.erase (it);
695           \textcolor{keywordflow}{return};
696         \}
697     \}
698   \hyperlink{group__fatal_ga51ac4699be799d772ae7258d1ef6af21}{NS\_ABORT\_MSG} (\textcolor{stringliteral}{"Ripng::DeleteRoute - cannot find the route to delete"});
699 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Do\+Dispose()}{DoDispose()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+Ng\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1RipNg_a052d51c5f6f76871e12491780ab3ebf5}{}\label{classns3_1_1RipNg_a052d51c5f6f76871e12491780ab3ebf5}


Dispose this object. 



Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.


\begin{DoxyCode}
527 \{
528   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
529 
530   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1RipNg_aa8bc6103d67089e1e3cd507936f94887}{RoutesI} j = \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.begin ();  j != \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.end (); j = 
      \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.erase (j))
531     \{
532       \textcolor{keyword}{delete} j->first;
533     \}
534   \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.clear ();
535 
536   \hyperlink{classns3_1_1RipNg_a382578c16a30ce7de28794defeb661e9}{m\_nextTriggeredUpdate}.\hyperlink{classns3_1_1EventId_a993ae94e48e014e1afd47edb16db7a11}{Cancel} ();
537   \hyperlink{classns3_1_1RipNg_a673a77372c3bbc67338c52f6b0291134}{m\_nextUnsolicitedUpdate}.\hyperlink{classns3_1_1EventId_a993ae94e48e014e1afd47edb16db7a11}{Cancel} ();
538   \hyperlink{classns3_1_1RipNg_a382578c16a30ce7de28794defeb661e9}{m\_nextTriggeredUpdate} = EventId ();
539   \hyperlink{classns3_1_1RipNg_a673a77372c3bbc67338c52f6b0291134}{m\_nextUnsolicitedUpdate} = EventId ();
540 
541   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1RipNg_a549052bbb55168d029f82d78384144b4}{SocketListI} iter = \hyperlink{classns3_1_1RipNg_a761d304dc3d34cd528afe87c5fa8090b}{m\_sendSocketList}.begin (); iter != 
      \hyperlink{classns3_1_1RipNg_a761d304dc3d34cd528afe87c5fa8090b}{m\_sendSocketList}.end (); iter++ )
542     \{
543       iter->first->Close ();
544     \}
545   \hyperlink{classns3_1_1RipNg_a761d304dc3d34cd528afe87c5fa8090b}{m\_sendSocketList}.clear ();
546 
547   \hyperlink{classns3_1_1RipNg_a87437a46d9f4e0951f9d4c6b11208d4f}{m\_recvSocket}->\hyperlink{classns3_1_1Socket_abdac6e2498c5aa2963ef361d4200ddf3}{Close} ();
548   \hyperlink{classns3_1_1RipNg_a87437a46d9f4e0951f9d4c6b11208d4f}{m\_recvSocket} = 0;
549 
550   \hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6} = 0;
551 
552   \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{Ipv6RoutingProtocol::DoDispose} ();
553 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8


\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Do\+Initialize@{Do\+Initialize}}
\index{Do\+Initialize@{Do\+Initialize}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Do\+Initialize()}{DoInitialize()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+Ng\+::\+Do\+Initialize (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1RipNg_a81a7056d4a1d1afc266181406f5dbf64}{}\label{classns3_1_1RipNg_a81a7056d4a1d1afc266181406f5dbf64}
Start protocol operation 

Reimplemented from \hyperlink{classns3_1_1Object_af8482a521433409fb5c7f749398c9dbe}{ns3\+::\+Object}.


\begin{DoxyCode}
111 \{
112   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
113 
114   \textcolor{keywordtype}{bool} addedGlobal = \textcolor{keyword}{false};
115 
116   \hyperlink{classns3_1_1RipNg_a789ca251ab1d869da5f62a4286067d2d}{m\_initialized} = \textcolor{keyword}{true};
117 
118   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_a7964e6aa8f61a9d28973c8267a606ad8}{delay} = \hyperlink{classns3_1_1RipNg_a8bedf450622f395cc52c1d37dc4d7a40}{m\_unsolicitedUpdate} + \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (
      \hyperlink{classns3_1_1RipNg_adc89174a768de707315ed3cb88a6a0aa}{m\_rng}->\hyperlink{classns3_1_1UniformRandomVariable_a03822d8c86ac51e9aa83bbc73041386b}{GetValue} (0, 0.5*\hyperlink{classns3_1_1RipNg_a8bedf450622f395cc52c1d37dc4d7a40}{m\_unsolicitedUpdate}.
      \hyperlink{classns3_1_1Time_a8f20d5c3b0902d7b4320982f340b57c8}{GetSeconds} ()) );
119   \hyperlink{classns3_1_1RipNg_a673a77372c3bbc67338c52f6b0291134}{m\_nextUnsolicitedUpdate} = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (delay, &
      \hyperlink{classns3_1_1RipNg_af4dc944e60808380f6c5af16bf867fdc}{RipNg::SendUnsolicitedRouteUpdate}, \textcolor{keyword}{this});
120 
121 
122   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0 ; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->GetNInterfaces (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
123     \{
124       \textcolor{keywordtype}{bool} activeInterface = \textcolor{keyword}{false};
125       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1RipNg_a98c5b63bb7c56afa595c1bb568a7081f}{m\_interfaceExclusions}.find (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) == 
      \hyperlink{classns3_1_1RipNg_a98c5b63bb7c56afa595c1bb568a7081f}{m\_interfaceExclusions}.end ())
126         \{
127           activeInterface = \textcolor{keyword}{true};
128           \hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->SetForwarding (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, \textcolor{keyword}{true});
129         \}
130 
131       \textcolor{keywordflow}{for} (uint32\_t j = 0; j < \hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->GetNAddresses (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}); j++)
132         \{
133           Ipv6InterfaceAddress address = \hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, j);
134           \textcolor{keywordflow}{if} (address.GetScope() == \hyperlink{classns3_1_1Ipv6InterfaceAddress_ad3f03debf9dae475b81ea9cdf81f4f27a29f5cd6ebe813216f28d906d89d4c56d}{Ipv6InterfaceAddress::LINKLOCAL} && 
      activeInterface == \textcolor{keyword}{true})
135             \{
136               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"RIPng: adding socket to "} << address.GetAddress ());
137               TypeId tid = \hyperlink{classns3_1_1TypeId_a119cf99c20931fdc294602cd360b180e}{TypeId::LookupByName} (\textcolor{stringliteral}{"ns3::UdpSocketFactory"});
138               Ptr<Node> theNode = GetObject<Node> ();
139               Ptr<Socket> socket = \hyperlink{classns3_1_1Socket_ad448a62bb50ad3dbac59c879a885a8d2}{Socket::CreateSocket} (theNode, tid);
140               Inet6SocketAddress local = Inet6SocketAddress (address.GetAddress (), 
      \hyperlink{ripng_8cc_a86ce7fe00a995035f236d2463a7b761f}{RIPNG\_PORT});
141               \textcolor{keywordtype}{int} ret = socket->Bind (local);
142               \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (ret == 0, \textcolor{stringliteral}{"Bind unsuccessful"});
143               socket->BindToNetDevice (\hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->GetNetDevice (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}));
144               socket->ShutdownRecv ();
145               socket->SetIpv6RecvHopLimit (\textcolor{keyword}{true});
146               \hyperlink{classns3_1_1RipNg_a761d304dc3d34cd528afe87c5fa8090b}{m\_sendSocketList}[socket] = \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
147             \}
148           \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, j).GetScope() == 
      \hyperlink{classns3_1_1Ipv6InterfaceAddress_ad3f03debf9dae475b81ea9cdf81f4f27aaf504a3b8c1562206e6ba65b4a6cff1d}{Ipv6InterfaceAddress::GLOBAL})
149             \{
150               addedGlobal = \textcolor{keyword}{true};
151             \}
152         \}
153     \}
154 
155   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1RipNg_a87437a46d9f4e0951f9d4c6b11208d4f}{m\_recvSocket})
156     \{
157       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"RIPng: adding receiving socket"});
158       TypeId tid = \hyperlink{classns3_1_1TypeId_a119cf99c20931fdc294602cd360b180e}{TypeId::LookupByName} (\textcolor{stringliteral}{"ns3::UdpSocketFactory"});
159       Ptr<Node> theNode = GetObject<Node> ();
160       \hyperlink{classns3_1_1RipNg_a87437a46d9f4e0951f9d4c6b11208d4f}{m\_recvSocket} = \hyperlink{classns3_1_1Socket_ad448a62bb50ad3dbac59c879a885a8d2}{Socket::CreateSocket} (theNode, tid);
161       Inet6SocketAddress local = Inet6SocketAddress (\hyperlink{ripng_8cc_a74c1e9507f7b739d0ad013b552bf1daf}{RIPNG\_ALL\_NODE}, 
      \hyperlink{ripng_8cc_a86ce7fe00a995035f236d2463a7b761f}{RIPNG\_PORT});
162       m\_recvSocket->Bind (local);
163       m\_recvSocket->SetRecvCallback (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&\hyperlink{classns3_1_1RipNg_ae8891520b5ae87abed2e2a15d50ba4d8}{RipNg::Receive}, \textcolor{keyword}{this}));
164       m\_recvSocket->SetIpv6RecvHopLimit (\textcolor{keyword}{true});
165       m\_recvSocket->SetRecvPktInfo (\textcolor{keyword}{true});
166     \}
167 
168 
169   \textcolor{keywordflow}{if} (addedGlobal)
170     \{
171       \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} delay = \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (\hyperlink{classns3_1_1RipNg_adc89174a768de707315ed3cb88a6a0aa}{m\_rng}->\hyperlink{classns3_1_1UniformRandomVariable_a03822d8c86ac51e9aa83bbc73041386b}{GetValue} (
      \hyperlink{classns3_1_1RipNg_a4da2b49a558678bd4c51a995fbfbf7af}{m\_minTriggeredUpdateDelay}.\hyperlink{classns3_1_1Time_a8f20d5c3b0902d7b4320982f340b57c8}{GetSeconds} (), 
      \hyperlink{classns3_1_1RipNg_a7087e78333b3a5caabc13a83753a13a2}{m\_maxTriggeredUpdateDelay}.\hyperlink{classns3_1_1Time_a8f20d5c3b0902d7b4320982f340b57c8}{GetSeconds} ()));
172       \hyperlink{classns3_1_1RipNg_a382578c16a30ce7de28794defeb661e9}{m\_nextTriggeredUpdate} = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (delay, &
      \hyperlink{classns3_1_1RipNg_a110005349bf811e1b0f6af182298be15}{RipNg::DoSendRouteUpdate}, \textcolor{keyword}{this}, \textcolor{keyword}{false});
173     \}
174 
175   delay = \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (\hyperlink{classns3_1_1RipNg_adc89174a768de707315ed3cb88a6a0aa}{m\_rng}->\hyperlink{classns3_1_1UniformRandomVariable_a03822d8c86ac51e9aa83bbc73041386b}{GetValue} (0.01, \hyperlink{classns3_1_1RipNg_a11c536612cb48e139d4a3b8d34c9ec3a}{m\_startupDelay}.
      \hyperlink{classns3_1_1Time_a8f20d5c3b0902d7b4320982f340b57c8}{GetSeconds} ()));
176   \hyperlink{classns3_1_1RipNg_a382578c16a30ce7de28794defeb661e9}{m\_nextTriggeredUpdate} = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (delay, &
      \hyperlink{classns3_1_1RipNg_aa97c9ec93505c548bbf85ef18c532147}{RipNg::SendRouteRequest}, \textcolor{keyword}{this});
177 
178   \hyperlink{classns3_1_1Object_af8482a521433409fb5c7f749398c9dbe}{Ipv6RoutingProtocol::DoInitialize} ();
179 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9


\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Do\+Send\+Route\+Update@{Do\+Send\+Route\+Update}}
\index{Do\+Send\+Route\+Update@{Do\+Send\+Route\+Update}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Do\+Send\+Route\+Update(bool periodic)}{DoSendRouteUpdate(bool periodic)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+Ng\+::\+Do\+Send\+Route\+Update (
\begin{DoxyParamCaption}
\item[{bool}]{periodic}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_a110005349bf811e1b0f6af182298be15}{}\label{classns3_1_1RipNg_a110005349bf811e1b0f6af182298be15}


Send Routing Updates on all interfaces. 


\begin{DoxyParams}{Parameters}
{\em periodic} & true for periodic update, else triggered. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1078 \{
1079   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << (periodic ? \textcolor{stringliteral}{" periodic"} : \textcolor{stringliteral}{" triggered"}));
1080 
1081   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1RipNg_a549052bbb55168d029f82d78384144b4}{SocketListI} iter = \hyperlink{classns3_1_1RipNg_a761d304dc3d34cd528afe87c5fa8090b}{m\_sendSocketList}.begin (); iter != 
      \hyperlink{classns3_1_1RipNg_a761d304dc3d34cd528afe87c5fa8090b}{m\_sendSocketList}.end (); iter++ )
1082     \{
1083       uint32\_t \textcolor{keyword}{interface }= iter->second;
1084 
1085       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1RipNg_a98c5b63bb7c56afa595c1bb568a7081f}{m\_interfaceExclusions}.find (interface) == 
      \hyperlink{classns3_1_1RipNg_a98c5b63bb7c56afa595c1bb568a7081f}{m\_interfaceExclusions}.end ())
1086         \{
1087           uint16\_t mtu = \hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->GetMtu (interface);
1088           uint16\_t maxRte = (mtu - Ipv6Header ().GetSerializedSize () - UdpHeader ().GetSerializedSize () -
       RipNgHeader ().GetSerializedSize ()) / RipNgRte ().GetSerializedSize ();
1089 
1090           Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = Create<Packet> ();
1091           SocketIpv6HopLimitTag tag;
1092           tag.SetHopLimit (255);
1093           p->AddPacketTag (tag);
1094 
1095           RipNgHeader hdr;
1096           hdr.SetCommand (\hyperlink{classns3_1_1RipNgHeader_ad96724d6f6fdb4ffa22fe71a0ff12bd2a787536902c0e1912fd0c234def4c32b7}{RipNgHeader::RESPONSE});
1097 
1098           \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1RipNg_aa8bc6103d67089e1e3cd507936f94887}{RoutesI} rtIter = \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.begin (); rtIter != 
      \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.end (); rtIter++)
1099             \{
1100               \textcolor{keywordtype}{bool} splitHorizoning = (rtIter->first->GetInterface () == interface);
1101               Ipv6InterfaceAddress rtDestAddr = Ipv6InterfaceAddress(rtIter->first->GetDestNetwork (), 
      rtIter->first->GetDestNetworkPrefix ());
1102 
1103               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Processing RT "} << rtDestAddr << \textcolor{stringliteral}{" "} << \textcolor{keywordtype}{int}(rtIter->first->
      IsRouteChanged ()));
1104 
1105               \textcolor{keywordtype}{bool} isGlobal = (rtDestAddr.GetScope () == 
      \hyperlink{classns3_1_1Ipv6InterfaceAddress_ad3f03debf9dae475b81ea9cdf81f4f27aaf504a3b8c1562206e6ba65b4a6cff1d}{Ipv6InterfaceAddress::GLOBAL});
1106               \textcolor{keywordtype}{bool} isDefaultRoute = ((rtIter->first->GetDestNetwork () == 
      \hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} ()) &&
1107                   (rtIter->first->GetDestNetworkPrefix () == \hyperlink{classns3_1_1Ipv6Prefix_ab32d2dbadcd8fa048ff296cb0a0e34ff}{Ipv6Prefix::GetZero} ()) &&
1108                   (rtIter->first->GetInterface () != interface));
1109 
1110               \textcolor{keywordflow}{if} ((isGlobal || isDefaultRoute) &&
1111                   (periodic || rtIter->first->IsRouteChanged ()))
1112                 \{
1113                   RipNgRte rte;
1114                   rte.SetPrefix (rtIter->first->GetDestNetwork ());
1115                   rte.SetPrefixLen (rtIter->first->GetDestNetworkPrefix ().GetPrefixLength ());
1116                   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1RipNg_a2aaaf4747380a0960cc48cb04ae99a1a}{m\_splitHorizonStrategy} == 
      \hyperlink{classns3_1_1RipNg_a2baa3148870b411bccfe688079fb40a7a68187e765b02506b3891b87a513fac2f}{POISON\_REVERSE} && splitHorizoning)
1117                     \{
1118                       rte.SetRouteMetric (\hyperlink{classns3_1_1RipNg_a6752c1bb1fc0909f0493033d426f2b92}{m\_linkDown});
1119                     \}
1120                   \textcolor{keywordflow}{else}
1121                     \{
1122                       rte.SetRouteMetric (rtIter->first->GetRouteMetric ());
1123                     \}
1124                   rte.SetRouteTag (rtIter->first->GetRouteTag ());
1125                   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1RipNg_a2aaaf4747380a0960cc48cb04ae99a1a}{m\_splitHorizonStrategy} == 
      \hyperlink{classns3_1_1RipNg_a2baa3148870b411bccfe688079fb40a7a65efd4b3a6b5b8be8e16038fec0cad4e}{SPLIT\_HORIZON} && !splitHorizoning)
1126                     \{
1127                       hdr.AddRte (rte);
1128                     \}
1129                   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1RipNg_a2aaaf4747380a0960cc48cb04ae99a1a}{m\_splitHorizonStrategy} != 
      \hyperlink{classns3_1_1RipNg_a2baa3148870b411bccfe688079fb40a7a65efd4b3a6b5b8be8e16038fec0cad4e}{SPLIT\_HORIZON})
1130                     \{
1131                       hdr.AddRte (rte);
1132                     \}
1133                 \}
1134               \textcolor{keywordflow}{if} (hdr.GetRteNumber () == maxRte)
1135                 \{
1136                   p->AddHeader (hdr);
1137                   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"SendTo: "} << *p);
1138                   iter->first->SendTo (p, 0, Inet6SocketAddress (\hyperlink{ripng_8cc_a74c1e9507f7b739d0ad013b552bf1daf}{RIPNG\_ALL\_NODE}, 
      \hyperlink{ripng_8cc_a86ce7fe00a995035f236d2463a7b761f}{RIPNG\_PORT}));
1139                   p->RemoveHeader (hdr);
1140                   hdr.ClearRtes ();
1141                 \}
1142             \}
1143           \textcolor{keywordflow}{if} (hdr.GetRteNumber () > 0)
1144             \{
1145               p->AddHeader (hdr);
1146               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"SendTo: "} << *p);
1147               iter->first->SendTo (p, 0, Inet6SocketAddress (\hyperlink{ripng_8cc_a74c1e9507f7b739d0ad013b552bf1daf}{RIPNG\_ALL\_NODE}, 
      \hyperlink{ripng_8cc_a86ce7fe00a995035f236d2463a7b761f}{RIPNG\_PORT}));
1148             \}
1149         \}
1150     \}
1151   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1RipNg_aa8bc6103d67089e1e3cd507936f94887}{RoutesI} rtIter = \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.begin (); rtIter != \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.end (); rtIter++)
1152     \{
1153       rtIter->first->SetRouteChanged (\textcolor{keyword}{false});
1154     \}
1155 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10




Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Get\+Interface\+Exclusions@{Get\+Interface\+Exclusions}}
\index{Get\+Interface\+Exclusions@{Get\+Interface\+Exclusions}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Get\+Interface\+Exclusions() const }{GetInterfaceExclusions() const }}]{\setlength{\rightskip}{0pt plus 5cm}std\+::set$<$ uint32\+\_\+t $>$ ns3\+::\+Rip\+Ng\+::\+Get\+Interface\+Exclusions (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1RipNg_a5ad1b90a1ca236c9d51ee4ecba9aafe1}{}\label{classns3_1_1RipNg_a5ad1b90a1ca236c9d51ee4ecba9aafe1}


Get the set of interface excluded from the protocol. 

\begin{DoxyReturn}{Returns}
the set of excluded interfaces 
\end{DoxyReturn}

\begin{DoxyCode}
1203 \{
1204   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1RipNg_a98c5b63bb7c56afa595c1bb568a7081f}{m\_interfaceExclusions};
1205 \}
\end{DoxyCode}
\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Get\+Interface\+Metric@{Get\+Interface\+Metric}}
\index{Get\+Interface\+Metric@{Get\+Interface\+Metric}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Get\+Interface\+Metric(uint32\+\_\+t interface) const }{GetInterfaceMetric(uint32_t interface) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::\+Rip\+Ng\+::\+Get\+Interface\+Metric (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1RipNg_a964ec14240c70f31176307334c00b936}{}\label{classns3_1_1RipNg_a964ec14240c70f31176307334c00b936}


Get the metric for an interface. 


\begin{DoxyParams}{Parameters}
{\em interface} & the interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the interface metric 
\end{DoxyReturn}

\begin{DoxyCode}
1215 \{
1216   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << interface);
1217 
1218   std::map<uint32\_t, uint8\_t>::const\_iterator iter = \hyperlink{classns3_1_1RipNg_aa63ca4f7ad5ad13c878220c51d8b89c5}{m\_interfaceMetrics}.find (interface);
1219   \textcolor{keywordflow}{if} (iter != \hyperlink{classns3_1_1RipNg_aa63ca4f7ad5ad13c878220c51d8b89c5}{m\_interfaceMetrics}.end ())
1220     \{
1221       \textcolor{keywordflow}{return} iter->second;
1222     \}
1223   \textcolor{keywordflow}{return} 1;
1224 \}
\end{DoxyCode}
\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Rip\+Ng\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1RipNg_a4c5b07bdfcaaf3537f880d37a311a221}{}\label{classns3_1_1RipNg_a4c5b07bdfcaaf3537f880d37a311a221}


Get the type ID. 

\begin{DoxyReturn}{Returns}
type ID 
\end{DoxyReturn}

\begin{DoxyCode}
59 \{
60   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::RipNg"})
61     .SetParent<Ipv6RoutingProtocol> ()
62     .SetGroupName (\textcolor{stringliteral}{"Internet"})
63     .AddConstructor<\hyperlink{classns3_1_1RipNg_aa7816865151af06b32f54f67e156f9d4}{RipNg}> ()
64     .AddAttribute (\textcolor{stringliteral}{"UnsolicitedRoutingUpdate"}, \textcolor{stringliteral}{"The time between two Unsolicited Routing Updates."},
65                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds}(30)),
66                    MakeTimeAccessor (&\hyperlink{classns3_1_1RipNg_a8bedf450622f395cc52c1d37dc4d7a40}{RipNg::m\_unsolicitedUpdate}),
67                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
68     .AddAttribute (\textcolor{stringliteral}{"StartupDelay"}, \textcolor{stringliteral}{"Maximum random delay for protocol startup (send route requests)."},
69                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds}(1)),
70                    MakeTimeAccessor (&\hyperlink{classns3_1_1RipNg_a11c536612cb48e139d4a3b8d34c9ec3a}{RipNg::m\_startupDelay}),
71                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
72     .AddAttribute (\textcolor{stringliteral}{"TimeoutDelay"}, \textcolor{stringliteral}{"The delay to invalidate a route."},
73                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds}(180)),
74                    MakeTimeAccessor (&\hyperlink{classns3_1_1RipNg_aed45845b278332b589e76304a3701d72}{RipNg::m\_timeoutDelay}),
75                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
76     .AddAttribute (\textcolor{stringliteral}{"GarbageCollectionDelay"}, \textcolor{stringliteral}{"The delay to delete an expired route."},
77                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds}(120)),
78                    MakeTimeAccessor (&\hyperlink{classns3_1_1RipNg_aa42bd385be7a330206d02e2e721edc19}{RipNg::m\_garbageCollectionDelay}),
79                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
80     .AddAttribute (\textcolor{stringliteral}{"MinTriggeredCooldown"}, \textcolor{stringliteral}{"Min cooldown delay after a Triggered Update."},
81                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds}(1)),
82                    MakeTimeAccessor (&\hyperlink{classns3_1_1RipNg_a4da2b49a558678bd4c51a995fbfbf7af}{RipNg::m\_minTriggeredUpdateDelay}),
83                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
84     .AddAttribute (\textcolor{stringliteral}{"MaxTriggeredCooldown"}, \textcolor{stringliteral}{"Max cooldown delay after a Triggered Update."},
85                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds}(5)),
86                    MakeTimeAccessor (&\hyperlink{classns3_1_1RipNg_a7087e78333b3a5caabc13a83753a13a2}{RipNg::m\_maxTriggeredUpdateDelay}),
87                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
88     .AddAttribute (\textcolor{stringliteral}{"SplitHorizon"}, \textcolor{stringliteral}{"Split Horizon strategy."},
89                    EnumValue (\hyperlink{classns3_1_1RipNg_a2baa3148870b411bccfe688079fb40a7a68187e765b02506b3891b87a513fac2f}{RipNg::POISON\_REVERSE}),
90                    \hyperlink{namespacens3_af5050739867ce63896dec011e332c8ec}{MakeEnumAccessor} (&
      \hyperlink{classns3_1_1RipNg_a2aaaf4747380a0960cc48cb04ae99a1a}{RipNg::m\_splitHorizonStrategy}),
91                    \hyperlink{namespacens3_a48832781a2b521d3d0091e05ece30615}{MakeEnumChecker} (\hyperlink{classns3_1_1RipNg_a2baa3148870b411bccfe688079fb40a7a87060df7c85bafc99b78440f423a171b}{RipNg::NO\_SPLIT\_HORIZON}, \textcolor{stringliteral}{"
      NoSplitHorizon"},
92                                     \hyperlink{classns3_1_1RipNg_a2baa3148870b411bccfe688079fb40a7a65efd4b3a6b5b8be8e16038fec0cad4e}{RipNg::SPLIT\_HORIZON}, \textcolor{stringliteral}{"SplitHorizon"},
93                                     \hyperlink{classns3_1_1RipNg_a2baa3148870b411bccfe688079fb40a7a68187e765b02506b3891b87a513fac2f}{RipNg::POISON\_REVERSE}, \textcolor{stringliteral}{"PoisonReverse"}))
94     .AddAttribute (\textcolor{stringliteral}{"LinkDownValue"}, \textcolor{stringliteral}{"Value for link down in count to infinity."},
95                    UintegerValue (16),
96                    MakeUintegerAccessor (&\hyperlink{classns3_1_1RipNg_a6752c1bb1fc0909f0493033d426f2b92}{RipNg::m\_linkDown}),
97                    MakeUintegerChecker<uint8\_t> ())
98     ;
99   \textcolor{keywordflow}{return} tid;
100 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12


\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Handle\+Requests@{Handle\+Requests}}
\index{Handle\+Requests@{Handle\+Requests}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Handle\+Requests(\+Rip\+Ng\+Header hdr, Ipv6\+Address sender\+Address, uint16\+\_\+t sender\+Port, uint32\+\_\+t incoming\+Interface, uint8\+\_\+t hop\+Limit)}{HandleRequests(RipNgHeader hdr, Ipv6Address senderAddress, uint16_t senderPort, uint32_t incomingInterface, uint8_t hopLimit)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+Ng\+::\+Handle\+Requests (
\begin{DoxyParamCaption}
\item[{{\bf Rip\+Ng\+Header}}]{hdr, }
\item[{{\bf Ipv6\+Address}}]{sender\+Address, }
\item[{uint16\+\_\+t}]{sender\+Port, }
\item[{uint32\+\_\+t}]{incoming\+Interface, }
\item[{uint8\+\_\+t}]{hop\+Limit}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_adb06ee7b823c0d7ae5b45b637c1ffd19}{}\label{classns3_1_1RipNg_adb06ee7b823c0d7ae5b45b637c1ffd19}


Handle R\+I\+Png requests. 


\begin{DoxyParams}{Parameters}
{\em hdr} & message header (including R\+T\+Es) \\
\hline
{\em sender\+Address} & sender address \\
\hline
{\em sender\+Port} & sender port \\
\hline
{\em incoming\+Interface} & incoming interface \\
\hline
{\em hop\+Limit} & packet\textquotesingle{}s hop limit \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
757 \{
758   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << senderAddress << \textcolor{keywordtype}{int} (senderPort) << incomingInterface << \textcolor{keywordtype}{int} (
      hopLimit) << requestHdr);
759 
760   std::list<RipNgRte> rtes = requestHdr.GetRteList ();
761 
762   \textcolor{keywordflow}{if} (rtes.empty ())
763     \{
764       \textcolor{keywordflow}{return};
765     \}
766 
767   \textcolor{comment}{// check if it's a request for the full table from a neighbor}
768   \textcolor{keywordflow}{if} (rtes.size () == 1 && senderAddress.IsLinkLocal ())
769     \{
770       \textcolor{keywordflow}{if} (rtes.begin ()->GetPrefix () == \hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} () &&
771           rtes.begin ()->GetPrefixLen () == 0 &&
772           rtes.begin ()->GetRouteMetric () == \hyperlink{classns3_1_1RipNg_a6752c1bb1fc0909f0493033d426f2b92}{m\_linkDown})
773         \{
774           \textcolor{comment}{// Output whole thing. Use Split Horizon}
775           \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1RipNg_a98c5b63bb7c56afa595c1bb568a7081f}{m\_interfaceExclusions}.find (incomingInterface) == 
      \hyperlink{classns3_1_1RipNg_a98c5b63bb7c56afa595c1bb568a7081f}{m\_interfaceExclusions}.end ())
776             \{
777               \textcolor{comment}{// we use one of the sending sockets, as they're bound to the right interface}
778               \textcolor{comment}{// and the local address might be used on different interfaces.}
779               Ptr<Socket> sendingSoket;
780               \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1RipNg_a549052bbb55168d029f82d78384144b4}{SocketListI} iter = \hyperlink{classns3_1_1RipNg_a761d304dc3d34cd528afe87c5fa8090b}{m\_sendSocketList}.begin (); iter != 
      \hyperlink{classns3_1_1RipNg_a761d304dc3d34cd528afe87c5fa8090b}{m\_sendSocketList}.end (); iter++ )
781                 \{
782                   \textcolor{keywordflow}{if} (iter->second == incomingInterface)
783                     \{
784                       sendingSoket = iter->first;
785                     \}
786                 \}
787               \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (sendingSoket, \textcolor{stringliteral}{"HandleRequest - Impossible to find a socket to
       send the reply"});
788 
789               uint16\_t mtu = \hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->GetMtu (incomingInterface);
790               uint16\_t maxRte = (mtu - Ipv6Header ().GetSerializedSize () - UdpHeader ().GetSerializedSize 
      () - RipNgHeader ().GetSerializedSize ()) / RipNgRte ().GetSerializedSize ();
791 
792               Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = Create<Packet> ();
793               SocketIpv6HopLimitTag tag;
794               p->RemovePacketTag (tag);
795               tag.SetHopLimit (255);
796               p->AddPacketTag (tag);
797 
798               RipNgHeader hdr;
799               hdr.SetCommand (\hyperlink{classns3_1_1RipNgHeader_ad96724d6f6fdb4ffa22fe71a0ff12bd2a787536902c0e1912fd0c234def4c32b7}{RipNgHeader::RESPONSE});
800 
801               \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1RipNg_aa8bc6103d67089e1e3cd507936f94887}{RoutesI} rtIter = \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.begin (); rtIter != 
      \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.end (); rtIter++)
802                 \{
803                   \textcolor{keywordtype}{bool} splitHorizoning = (rtIter->first->GetInterface () == incomingInterface);
804 
805                   Ipv6InterfaceAddress rtDestAddr = Ipv6InterfaceAddress (rtIter->first->GetDestNetwork (),
       rtIter->first->GetDestNetworkPrefix ());
806 
807                   \textcolor{keywordtype}{bool} isGlobal = (rtDestAddr.GetScope () == 
      \hyperlink{classns3_1_1Ipv6InterfaceAddress_ad3f03debf9dae475b81ea9cdf81f4f27aaf504a3b8c1562206e6ba65b4a6cff1d}{Ipv6InterfaceAddress::GLOBAL});
808                   \textcolor{keywordtype}{bool} isDefaultRoute = ((rtIter->first->GetDestNetwork () == 
      \hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} ()) &&
809                       (rtIter->first->GetDestNetworkPrefix () == 
      \hyperlink{classns3_1_1Ipv6Prefix_ab32d2dbadcd8fa048ff296cb0a0e34ff}{Ipv6Prefix::GetZero} ()) &&
810                       (rtIter->first->GetInterface () != incomingInterface));
811 
812                   \textcolor{keywordflow}{if} ((isGlobal || isDefaultRoute) &&
813                       (rtIter->first->GetRouteStatus () == 
      \hyperlink{classns3_1_1RipNgRoutingTableEntry_af723fc23e97afdd05c55da5162b7e673a334e33ca88fb2b8de53c814814d3c017}{RipNgRoutingTableEntry::RIPNG\_VALID}) )
814                     \{
815                       RipNgRte rte;
816                       rte.SetPrefix (rtIter->first->GetDestNetwork ());
817                       rte.SetPrefixLen (rtIter->first->GetDestNetworkPrefix ().GetPrefixLength ());
818                       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1RipNg_a2aaaf4747380a0960cc48cb04ae99a1a}{m\_splitHorizonStrategy} == 
      \hyperlink{classns3_1_1RipNg_a2baa3148870b411bccfe688079fb40a7a68187e765b02506b3891b87a513fac2f}{POISON\_REVERSE} && splitHorizoning)
819                         \{
820                           rte.SetRouteMetric (\hyperlink{classns3_1_1RipNg_a6752c1bb1fc0909f0493033d426f2b92}{m\_linkDown});
821                         \}
822                       \textcolor{keywordflow}{else}
823                         \{
824                           rte.SetRouteMetric (rtIter->first->GetRouteMetric ());
825                         \}
826                       rte.SetRouteTag (rtIter->first->GetRouteTag ());
827                       \textcolor{keywordflow}{if} ((\hyperlink{classns3_1_1RipNg_a2aaaf4747380a0960cc48cb04ae99a1a}{m\_splitHorizonStrategy} != 
      \hyperlink{classns3_1_1RipNg_a2baa3148870b411bccfe688079fb40a7a65efd4b3a6b5b8be8e16038fec0cad4e}{SPLIT\_HORIZON}) ||
828                           (\hyperlink{classns3_1_1RipNg_a2aaaf4747380a0960cc48cb04ae99a1a}{m\_splitHorizonStrategy} == 
      \hyperlink{classns3_1_1RipNg_a2baa3148870b411bccfe688079fb40a7a65efd4b3a6b5b8be8e16038fec0cad4e}{SPLIT\_HORIZON} && !splitHorizoning))
829                         \{
830                           hdr.AddRte (rte);
831                         \}
832                     \}
833                   \textcolor{keywordflow}{if} (hdr.GetRteNumber () == maxRte)
834                     \{
835                       p->AddHeader (hdr);
836                       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"SendTo: "} << *p);
837                       sendingSoket->SendTo (p, 0, Inet6SocketAddress (senderAddress, 
      \hyperlink{ripng_8cc_a86ce7fe00a995035f236d2463a7b761f}{RIPNG\_PORT}));
838                       p->RemoveHeader (hdr);
839                       hdr.ClearRtes ();
840                     \}
841                 \}
842               \textcolor{keywordflow}{if} (hdr.GetRteNumber () > 0)
843                 \{
844                   p->AddHeader (hdr);
845                   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"SendTo: "} << *p);
846                   sendingSoket->SendTo (p, 0, Inet6SocketAddress (senderAddress, 
      \hyperlink{ripng_8cc_a86ce7fe00a995035f236d2463a7b761f}{RIPNG\_PORT}));
847                 \}
848             \}
849         \}
850     \}
851   \textcolor{keywordflow}{else}
852     \{
853       \textcolor{comment}{// note: we got the request as a single packet, so no check is necessary for MTU limit}
854 
855       \textcolor{comment}{// we use one of the sending sockets, as they're bound to the right interface}
856       \textcolor{comment}{// and the local address might be used on different interfaces.}
857       Ptr<Socket> sendingSoket;
858       \textcolor{keywordflow}{if} (senderAddress.IsLinkLocal ())
859         \{
860           \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1RipNg_a549052bbb55168d029f82d78384144b4}{SocketListI} iter = \hyperlink{classns3_1_1RipNg_a761d304dc3d34cd528afe87c5fa8090b}{m\_sendSocketList}.begin (); iter != 
      \hyperlink{classns3_1_1RipNg_a761d304dc3d34cd528afe87c5fa8090b}{m\_sendSocketList}.end (); iter++ )
861             \{
862               \textcolor{keywordflow}{if} (iter->second == incomingInterface)
863                 \{
864                   sendingSoket = iter->first;
865                 \}
866             \}
867         \}
868       \textcolor{keywordflow}{else}
869         \{
870           sendingSoket = \hyperlink{classns3_1_1RipNg_a87437a46d9f4e0951f9d4c6b11208d4f}{m\_recvSocket};
871         \}
872 
873       Ptr<Packet> p = Create<Packet> ();
874       SocketIpv6HopLimitTag tag;
875       p->RemovePacketTag (tag);
876       tag.SetHopLimit (255);
877       p->AddPacketTag (tag);
878 
879       RipNgHeader hdr;
880       hdr.SetCommand (\hyperlink{classns3_1_1RipNgHeader_ad96724d6f6fdb4ffa22fe71a0ff12bd2a787536902c0e1912fd0c234def4c32b7}{RipNgHeader::RESPONSE});
881 
882       \textcolor{keywordflow}{for} (std::list<RipNgRte>::iterator iter = rtes.begin ();
883           iter != rtes.end (); iter++)
884         \{
885           \textcolor{keywordtype}{bool} found = \textcolor{keyword}{false};
886           \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1RipNg_aa8bc6103d67089e1e3cd507936f94887}{RoutesI} rtIter = \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.begin (); rtIter != 
      \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.end (); rtIter++)
887             \{
888               Ipv6InterfaceAddress rtDestAddr = Ipv6InterfaceAddress(rtIter->first->GetDestNetwork (), 
      rtIter->first->GetDestNetworkPrefix ());
889               \textcolor{keywordflow}{if} ((rtDestAddr.GetScope () == \hyperlink{classns3_1_1Ipv6InterfaceAddress_ad3f03debf9dae475b81ea9cdf81f4f27aaf504a3b8c1562206e6ba65b4a6cff1d}{Ipv6InterfaceAddress::GLOBAL}) &&
890                   (rtIter->first->GetRouteStatus () == 
      \hyperlink{classns3_1_1RipNgRoutingTableEntry_af723fc23e97afdd05c55da5162b7e673a334e33ca88fb2b8de53c814814d3c017}{RipNgRoutingTableEntry::RIPNG\_VALID}))
891                 \{
892                   Ipv6Address requestedAddress = iter->GetPrefix ();
893                   requestedAddress.CombinePrefix (Ipv6Prefix (iter->GetPrefixLen ()));
894                   Ipv6Address rtAddress = rtIter->first->GetDestNetwork ();
895                   rtAddress.CombinePrefix (rtIter->first->GetDestNetworkPrefix ());
896 
897                   \textcolor{keywordflow}{if} (requestedAddress == rtAddress)
898                     \{
899                       iter->SetRouteMetric (rtIter->first->GetRouteMetric ());
900                       iter->SetRouteTag (rtIter->first->GetRouteTag ());
901                       hdr.AddRte (*iter);
902                       found = \textcolor{keyword}{true};
903                       \textcolor{keywordflow}{break};
904                     \}
905                 \}
906             \}
907           \textcolor{keywordflow}{if} (!found)
908             \{
909               iter->SetRouteMetric (\hyperlink{classns3_1_1RipNg_a6752c1bb1fc0909f0493033d426f2b92}{m\_linkDown});
910               iter->SetRouteTag (0);
911               hdr.AddRte (*iter);
912             \}
913         \}
914       p->AddHeader (hdr);
915       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"SendTo: "} << *p);
916       sendingSoket->SendTo (p, 0, Inet6SocketAddress (senderAddress, senderPort));
917     \}
918 
919 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13




Here is the caller graph for this function\+:
% FIG 14


\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Handle\+Responses@{Handle\+Responses}}
\index{Handle\+Responses@{Handle\+Responses}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Handle\+Responses(\+Rip\+Ng\+Header hdr, Ipv6\+Address sender\+Address, uint32\+\_\+t incoming\+Interface, uint8\+\_\+t hop\+Limit)}{HandleResponses(RipNgHeader hdr, Ipv6Address senderAddress, uint32_t incomingInterface, uint8_t hopLimit)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+Ng\+::\+Handle\+Responses (
\begin{DoxyParamCaption}
\item[{{\bf Rip\+Ng\+Header}}]{hdr, }
\item[{{\bf Ipv6\+Address}}]{sender\+Address, }
\item[{uint32\+\_\+t}]{incoming\+Interface, }
\item[{uint8\+\_\+t}]{hop\+Limit}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_ade057ef030dc8cd6479949e35315ed7b}{}\label{classns3_1_1RipNg_ade057ef030dc8cd6479949e35315ed7b}


Handle R\+I\+Png responses. 


\begin{DoxyParams}{Parameters}
{\em hdr} & message header (including R\+T\+Es) \\
\hline
{\em sender\+Address} & sender address \\
\hline
{\em incoming\+Interface} & incoming interface \\
\hline
{\em hop\+Limit} & packet\textquotesingle{}s hop limit \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
922 \{
923   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << senderAddress << incomingInterface << \textcolor{keywordtype}{int} (hopLimit) << hdr);
924 
925   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1RipNg_a98c5b63bb7c56afa595c1bb568a7081f}{m\_interfaceExclusions}.find (incomingInterface) != 
      \hyperlink{classns3_1_1RipNg_a98c5b63bb7c56afa595c1bb568a7081f}{m\_interfaceExclusions}.end ())
926     \{
927       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Ignoring an update message from an excluded interface: "} << 
      incomingInterface);
928       \textcolor{keywordflow}{return};
929     \}
930 
931   \textcolor{keywordflow}{if} (!senderAddress.IsLinkLocal ())
932     \{
933       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Ignoring an update message from a non-link-local source: "} << 
      senderAddress);
934       \textcolor{keywordflow}{return};
935     \}
936 
937   \textcolor{keywordflow}{if} (hopLimit != 255)
938     \{
939       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Ignoring an update message with suspicious hop count: "} << \textcolor{keywordtype}{int} (hopLimit))
      ;
940       \textcolor{keywordflow}{return};
941     \}
942 
943   std::list<RipNgRte> rtes = hdr.GetRteList ();
944 
945   \textcolor{comment}{// validate the RTEs before processing}
946   \textcolor{keywordflow}{for} (std::list<RipNgRte>::iterator iter = rtes.begin ();
947       iter != rtes.end (); iter++)
948     \{
949       \textcolor{keywordflow}{if} (iter->GetRouteMetric () == 0 || iter->GetRouteMetric () > \hyperlink{classns3_1_1RipNg_a6752c1bb1fc0909f0493033d426f2b92}{m\_linkDown})
950         \{
951           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Ignoring an update message with malformed metric: "} << \textcolor{keywordtype}{int} (iter->
      GetRouteMetric ()));
952           \textcolor{keywordflow}{return};
953         \}
954       \textcolor{keywordflow}{if} (iter->GetPrefixLen () > 128)
955         \{
956           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Ignoring an update message with malformed prefix length: "} << \textcolor{keywordtype}{int} (
      iter->GetPrefixLen ()));
957           \textcolor{keywordflow}{return};
958         \}
959       \textcolor{keywordflow}{if} (iter->GetPrefix ().IsLocalhost () ||
960           iter->GetPrefix ().IsLinkLocal () ||
961           iter->GetPrefix ().IsMulticast ())
962         \{
963           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Ignoring an update message with wrong prefixes: "} << iter->GetPrefix (
      ));
964           \textcolor{keywordflow}{return};
965         \}
966     \}
967 
968   \textcolor{keywordtype}{bool} changed = \textcolor{keyword}{false};
969 
970   \textcolor{keywordflow}{for} (std::list<RipNgRte>::iterator iter = rtes.begin ();
971       iter != rtes.end (); iter++)
972     \{
973       Ipv6Prefix rtePrefix = Ipv6Prefix (iter->GetPrefixLen ());
974       Ipv6Address rteAddr = iter->GetPrefix ().CombinePrefix (rtePrefix);
975 
976       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Processing RTE "} << *iter);
977 
978       uint8\_t interfaceMetric = 1;
979       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1RipNg_aa63ca4f7ad5ad13c878220c51d8b89c5}{m\_interfaceMetrics}.find (incomingInterface) != 
      \hyperlink{classns3_1_1RipNg_aa63ca4f7ad5ad13c878220c51d8b89c5}{m\_interfaceMetrics}.end ())
980         \{
981           interfaceMetric = \hyperlink{classns3_1_1RipNg_aa63ca4f7ad5ad13c878220c51d8b89c5}{m\_interfaceMetrics}[incomingInterface];
982         \}
983       uint16\_t rteMetric = iter->GetRouteMetric () + interfaceMetric;
984       \textcolor{keywordflow}{if} (rteMetric > \hyperlink{classns3_1_1RipNg_a6752c1bb1fc0909f0493033d426f2b92}{m\_linkDown})
985         \{
986           rteMetric = \hyperlink{classns3_1_1RipNg_a6752c1bb1fc0909f0493033d426f2b92}{m\_linkDown};
987         \}
988       \hyperlink{classns3_1_1RipNg_aa8bc6103d67089e1e3cd507936f94887}{RoutesI} it;
989       \textcolor{keywordtype}{bool} found = \textcolor{keyword}{false};
990       \textcolor{keywordflow}{for} (it = \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.begin (); it != \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.end (); it++)
991         \{
992           \textcolor{keywordflow}{if} (it->first->GetDestNetwork () == rteAddr &&
993               it->first->GetDestNetworkPrefix () == rtePrefix)
994             \{
995               found = \textcolor{keyword}{true};
996               \textcolor{keywordflow}{if} (rteMetric < it->first->GetRouteMetric ())
997                 \{
998                   \textcolor{keywordflow}{if} (senderAddress != it->first->GetGateway ())
999                     \{
1000                       RipNgRoutingTableEntry* route = \textcolor{keyword}{new} RipNgRoutingTableEntry (rteAddr, rtePrefix, 
      senderAddress, incomingInterface, \hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} ());
1001                       \textcolor{keyword}{delete} it->first;
1002                       it->first = route;
1003                     \}
1004                   it->first->SetRouteMetric (rteMetric);
1005                   it->first->SetRouteStatus (\hyperlink{classns3_1_1RipNgRoutingTableEntry_af723fc23e97afdd05c55da5162b7e673a334e33ca88fb2b8de53c814814d3c017}{RipNgRoutingTableEntry::RIPNG\_VALID}
      );
1006                   it->first->SetRouteTag (iter->GetRouteTag ());
1007                   it->first->SetRouteChanged (\textcolor{keyword}{true});
1008                   it->second.Cancel ();
1009                   it->second = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (
      \hyperlink{classns3_1_1RipNg_aed45845b278332b589e76304a3701d72}{m\_timeoutDelay}, &\hyperlink{classns3_1_1RipNg_ae4fc1ca9ed948f3c028fd96fb016f7dd}{RipNg::InvalidateRoute}, \textcolor{keyword}{this}, it->first);
1010                   changed = \textcolor{keyword}{true};
1011                 \}
1012               \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (rteMetric == it->first->GetRouteMetric ())
1013                 \{
1014                   \textcolor{keywordflow}{if} (senderAddress == it->first->GetGateway ())
1015                     \{
1016                       it->second.Cancel ();
1017                       it->second = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (
      \hyperlink{classns3_1_1RipNg_aed45845b278332b589e76304a3701d72}{m\_timeoutDelay}, &\hyperlink{classns3_1_1RipNg_ae4fc1ca9ed948f3c028fd96fb016f7dd}{RipNg::InvalidateRoute}, \textcolor{keyword}{this}, it->first);
1018                     \}
1019                   \textcolor{keywordflow}{else}
1020                     \{
1021                       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Simulator_af2c7b4285454aa5062bd2df2bb7a7ab9}{Simulator::GetDelayLeft} (it->second) < 
      \hyperlink{classns3_1_1RipNg_aed45845b278332b589e76304a3701d72}{m\_timeoutDelay}/2)
1022                         \{
1023                           RipNgRoutingTableEntry* route = \textcolor{keyword}{new} RipNgRoutingTableEntry (rteAddr, rtePrefix, 
      senderAddress, incomingInterface, \hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} ());
1024                           route->SetRouteMetric (rteMetric);
1025                           route->SetRouteStatus (
      \hyperlink{classns3_1_1RipNgRoutingTableEntry_af723fc23e97afdd05c55da5162b7e673a334e33ca88fb2b8de53c814814d3c017}{RipNgRoutingTableEntry::RIPNG\_VALID});
1026                           route->SetRouteTag (iter->GetRouteTag ());
1027                           route->SetRouteChanged (\textcolor{keyword}{true});
1028                           \textcolor{keyword}{delete} it->first;
1029                           it->first = route;
1030                           it->second.Cancel ();
1031                           it->second = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (
      \hyperlink{classns3_1_1RipNg_aed45845b278332b589e76304a3701d72}{m\_timeoutDelay}, &\hyperlink{classns3_1_1RipNg_ae4fc1ca9ed948f3c028fd96fb016f7dd}{RipNg::InvalidateRoute}, \textcolor{keyword}{this}, route);
1032                           changed = \textcolor{keyword}{true};
1033                         \}
1034                     \}
1035                 \}
1036               \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (rteMetric > it->first->GetRouteMetric () && senderAddress == it->first->GetGateway (
      ))
1037                 \{
1038                   it->second.Cancel ();
1039                   \textcolor{keywordflow}{if} (rteMetric < \hyperlink{classns3_1_1RipNg_a6752c1bb1fc0909f0493033d426f2b92}{m\_linkDown})
1040                     \{
1041                       it->first->SetRouteMetric (rteMetric);
1042                       it->first->SetRouteStatus (
      \hyperlink{classns3_1_1RipNgRoutingTableEntry_af723fc23e97afdd05c55da5162b7e673a334e33ca88fb2b8de53c814814d3c017}{RipNgRoutingTableEntry::RIPNG\_VALID});
1043                       it->first->SetRouteTag (iter->GetRouteTag ());
1044                       it->first->SetRouteChanged (\textcolor{keyword}{true});
1045                       it->second.Cancel ();
1046                       it->second = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (
      \hyperlink{classns3_1_1RipNg_aed45845b278332b589e76304a3701d72}{m\_timeoutDelay}, &\hyperlink{classns3_1_1RipNg_ae4fc1ca9ed948f3c028fd96fb016f7dd}{RipNg::InvalidateRoute}, \textcolor{keyword}{this}, it->first);
1047                     \}
1048                   \textcolor{keywordflow}{else}
1049                     \{
1050                       \hyperlink{classns3_1_1RipNg_ae4fc1ca9ed948f3c028fd96fb016f7dd}{InvalidateRoute} (it->first);
1051                     \}
1052                   changed = \textcolor{keyword}{true};
1053                 \}
1054             \}
1055         \}
1056       \textcolor{keywordflow}{if} (!found && rteMetric != \hyperlink{classns3_1_1RipNg_a6752c1bb1fc0909f0493033d426f2b92}{m\_linkDown})
1057         \{
1058           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Received a RTE with new route, adding."});
1059 
1060           RipNgRoutingTableEntry* route = \textcolor{keyword}{new} RipNgRoutingTableEntry (rteAddr, rtePrefix, senderAddress, 
      incomingInterface, \hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} ());
1061           route->SetRouteMetric (rteMetric);
1062           route->SetRouteStatus (\hyperlink{classns3_1_1RipNgRoutingTableEntry_af723fc23e97afdd05c55da5162b7e673a334e33ca88fb2b8de53c814814d3c017}{RipNgRoutingTableEntry::RIPNG\_VALID});
1063           route->SetRouteChanged (\textcolor{keyword}{true});
1064           \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.push\_front (std::make\_pair (route, EventId ()));
1065           EventId invalidateEvent = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (
      \hyperlink{classns3_1_1RipNg_aed45845b278332b589e76304a3701d72}{m\_timeoutDelay}, &\hyperlink{classns3_1_1RipNg_ae4fc1ca9ed948f3c028fd96fb016f7dd}{RipNg::InvalidateRoute}, \textcolor{keyword}{this}, route);
1066           (\hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.begin ())->second = invalidateEvent;
1067           changed = \textcolor{keyword}{true};
1068         \}
1069     \}
1070 
1071   \textcolor{keywordflow}{if} (changed)
1072     \{
1073       \hyperlink{classns3_1_1RipNg_ad7a8e445116b3dd8cdd1d50366787c66}{SendTriggeredRouteUpdate} ();
1074     \}
1075 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 15




Here is the caller graph for this function\+:
% FIG 16


\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Invalidate\+Route@{Invalidate\+Route}}
\index{Invalidate\+Route@{Invalidate\+Route}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Invalidate\+Route(\+Rip\+Ng\+Routing\+Table\+Entry $\ast$route)}{InvalidateRoute(RipNgRoutingTableEntry *route)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+Ng\+::\+Invalidate\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Rip\+Ng\+Routing\+Table\+Entry} $\ast$}]{route}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_ae4fc1ca9ed948f3c028fd96fb016f7dd}{}\label{classns3_1_1RipNg_ae4fc1ca9ed948f3c028fd96fb016f7dd}


Invalidate a route. 


\begin{DoxyParams}{Parameters}
{\em route} & the route to be removed \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
664 \{
665   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << *route);
666 
667   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1RipNg_aa8bc6103d67089e1e3cd507936f94887}{RoutesI} it = \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.begin (); it != \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.end (); it++)
668     \{
669       \textcolor{keywordflow}{if} (it->first == route)
670         \{
671           route->SetRouteStatus (\hyperlink{classns3_1_1RipNgRoutingTableEntry_af723fc23e97afdd05c55da5162b7e673a16a0f0e9e3e3ce9998da183ec37f870a}{RipNgRoutingTableEntry::RIPNG\_INVALID}
      );
672           route->SetRouteMetric (\hyperlink{classns3_1_1RipNg_a6752c1bb1fc0909f0493033d426f2b92}{m\_linkDown});
673           route->SetRouteChanged (\textcolor{keyword}{true});
674           \textcolor{keywordflow}{if} (it->second.IsRunning ())
675             \{
676               it->second.Cancel ();
677             \}
678           it->second = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (
      \hyperlink{classns3_1_1RipNg_aa42bd385be7a330206d02e2e721edc19}{m\_garbageCollectionDelay}, &\hyperlink{classns3_1_1RipNg_a9d1204fd821a2a528b250e57ddb0df04}{RipNg::DeleteRoute}, \textcolor{keyword}{this}, route);
679           \textcolor{keywordflow}{return};
680         \}
681     \}
682   \hyperlink{group__fatal_ga51ac4699be799d772ae7258d1ef6af21}{NS\_ABORT\_MSG} (\textcolor{stringliteral}{"Ripng::InvalidateRoute - cannot find the route to update"});
683 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 17




Here is the caller graph for this function\+:
% FIG 18


\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Lookup@{Lookup}}
\index{Lookup@{Lookup}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Lookup(\+Ipv6\+Address dest, Ptr$<$ Net\+Device $>$=0)}{Lookup(Ipv6Address dest, Ptr< NetDevice >=0)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv6\+Route} $>$ ns3\+::\+Rip\+Ng\+::\+Lookup (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{dest, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{interface = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_ac008f65e3fe915230191cb1099890489}{}\label{classns3_1_1RipNg_ac008f65e3fe915230191cb1099890489}


Lookup in the forwarding table for destination. 


\begin{DoxyParams}{Parameters}
{\em dest} & destination address \\
\hline
{\em interface} & output interface if any (put 0 otherwise) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{classns3_1_1Ipv6Route}{Ipv6\+Route} to route the packet to reach dest address 
\end{DoxyReturn}

\begin{DoxyCode}
557 \{
558   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << dst << interface);
559 
560   Ptr<Ipv6Route> rtentry = 0;
561   uint16\_t longestMask = 0;
562 
563   \textcolor{comment}{/* when sending on link-local multicast, there have to be interface specified */}
564   \textcolor{keywordflow}{if} (dst.IsLinkLocalMulticast ())
565     \{
566       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (interface, \textcolor{stringliteral}{"Try to send on link-local multicast address, and no interface
       index is given!"});
567       rtentry = Create<Ipv6Route> ();
568       rtentry->SetSource (\hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->SourceAddressSelection (\hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->GetInterfaceForDevice (
      interface), dst));
569       rtentry->SetDestination (dst);
570       rtentry->SetGateway (\hyperlink{classns3_1_1Ipv6Address_a63a34bdb1505e05fbdd07d316d0bd7e6}{Ipv6Address::GetZero} ());
571       rtentry->SetOutputDevice (interface);
572       \textcolor{keywordflow}{return} rtentry;
573     \}
574 
575   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1RipNg_aa8bc6103d67089e1e3cd507936f94887}{RoutesI} it = \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.begin (); it != \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.end (); it++)
576     \{
577       RipNgRoutingTableEntry* j = it->first;
578 
579       \textcolor{keywordflow}{if} (j->GetRouteStatus () == \hyperlink{classns3_1_1RipNgRoutingTableEntry_af723fc23e97afdd05c55da5162b7e673a334e33ca88fb2b8de53c814814d3c017}{RipNgRoutingTableEntry::RIPNG\_VALID})
580         \{
581           Ipv6Prefix mask = j->GetDestNetworkPrefix ();
582           uint16\_t maskLen = mask.GetPrefixLength ();
583           Ipv6Address entry = j->GetDestNetwork ();
584 
585           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Searching for route to "} << dst << \textcolor{stringliteral}{", mask length "} << maskLen);
586 
587           \textcolor{keywordflow}{if} (mask.IsMatch (dst, entry))
588             \{
589               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Found global network route "} << j << \textcolor{stringliteral}{", mask length "} << maskLen);
590 
591               \textcolor{comment}{/* if interface is given, check the route will output on this interface */}
592               \textcolor{keywordflow}{if} (!interface || interface == \hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->GetNetDevice (j->GetInterface ()))
593                 \{
594                   \textcolor{keywordflow}{if} (maskLen < longestMask)
595                     \{
596                       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Previous match longer, skipping"});
597                       \textcolor{keywordflow}{continue};
598                     \}
599 
600                   longestMask = maskLen;
601 
602                   Ipv6RoutingTableEntry* route = j;
603                   uint32\_t interfaceIdx = route->GetInterface ();
604                   rtentry = Create<Ipv6Route> ();
605 
606                   \textcolor{keywordflow}{if} (route->GetGateway ().IsAny ())
607                     \{
608                       rtentry->SetSource (\hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->SourceAddressSelection (interfaceIdx, route->
      GetDest ()));
609                     \}
610                   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (route->GetDest ().IsAny ()) \textcolor{comment}{/* default route */}
611                     \{
612                       rtentry->SetSource (\hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->SourceAddressSelection (interfaceIdx, route->
      GetPrefixToUse ().IsAny () ? dst : route->GetPrefixToUse ()));
613                     \}
614                   \textcolor{keywordflow}{else}
615                     \{
616                       rtentry->SetSource (\hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->SourceAddressSelection (interfaceIdx, route->
      GetDest ()));
617                     \}
618 
619                   rtentry->SetDestination (route->GetDest ());
620                   rtentry->SetGateway (route->GetGateway ());
621                   rtentry->SetOutputDevice (\hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->GetNetDevice (interfaceIdx));
622                 \}
623             \}
624         \}
625     \}
626 
627   \textcolor{keywordflow}{if} (rtentry)
628     \{
629       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Matching route via "} << rtentry->GetDestination () << \textcolor{stringliteral}{" (through "} << 
      rtentry->GetGateway () << \textcolor{stringliteral}{") at the end"});
630     \}
631   \textcolor{keywordflow}{return} rtentry;
632 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 19




Here is the caller graph for this function\+:
% FIG 20


\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Notify\+Add\+Address@{Notify\+Add\+Address}}
\index{Notify\+Add\+Address@{Notify\+Add\+Address}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Notify\+Add\+Address(uint32\+\_\+t interface, Ipv6\+Interface\+Address address)}{NotifyAddAddress(uint32_t interface, Ipv6InterfaceAddress address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+Ng\+::\+Notify\+Add\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv6\+Interface\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1RipNg_a9d6ffbffc76b029e5dfc9f394549d670}{}\label{classns3_1_1RipNg_a9d6ffbffc76b029e5dfc9f394549d670}


Notify when specified interface add an address. 

Protocols are expected to implement this method to be notified whenever a new address is added to an interface. Typically used to add a \textquotesingle{}network route\textquotesingle{} on an interface. Can be invoked on an up or down interface. 
\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
{\em address} & a new address being added to an interface \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6RoutingProtocol_ae8ef31faadbb3ddd1c9a8888c986cb57}{ns3\+::\+Ipv6\+Routing\+Protocol}.


\begin{DoxyCode}
375 \{
376   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << interface << address);
377 
378   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->IsUp (interface))
379     \{
380       \textcolor{keywordflow}{return};
381     \}
382 
383   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1RipNg_a98c5b63bb7c56afa595c1bb568a7081f}{m\_interfaceExclusions}.find (interface) != 
      \hyperlink{classns3_1_1RipNg_a98c5b63bb7c56afa595c1bb568a7081f}{m\_interfaceExclusions}.end ())
384     \{
385       \textcolor{keywordflow}{return};
386     \}
387 
388   Ipv6Address networkAddress = address.GetAddress ().CombinePrefix (address.GetPrefix ());
389   Ipv6Prefix networkMask = address.GetPrefix ();
390 
391   \textcolor{keywordflow}{if} (address.GetScope () == \hyperlink{classns3_1_1Ipv6InterfaceAddress_ad3f03debf9dae475b81ea9cdf81f4f27aaf504a3b8c1562206e6ba65b4a6cff1d}{Ipv6InterfaceAddress::GLOBAL})
392     \{
393       \hyperlink{classns3_1_1RipNg_a9d8c7bb0b6622946c347a88dabc06802}{AddNetworkRouteTo} (networkAddress, networkMask, interface);
394     \}
395 
396   \hyperlink{classns3_1_1RipNg_ad7a8e445116b3dd8cdd1d50366787c66}{SendTriggeredRouteUpdate} ();
397 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 21


\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Notify\+Add\+Route@{Notify\+Add\+Route}}
\index{Notify\+Add\+Route@{Notify\+Add\+Route}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Notify\+Add\+Route(\+Ipv6\+Address dst, Ipv6\+Prefix mask, Ipv6\+Address next\+Hop, uint32\+\_\+t interface, Ipv6\+Address prefix\+To\+Use=\+Ipv6\+Address\+::\+Get\+Zero())}{NotifyAddRoute(Ipv6Address dst, Ipv6Prefix mask, Ipv6Address nextHop, uint32_t interface, Ipv6Address prefixToUse=Ipv6Address::GetZero())}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+Ng\+::\+Notify\+Add\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{dst, }
\item[{{\bf Ipv6\+Prefix}}]{mask, }
\item[{{\bf Ipv6\+Address}}]{next\+Hop, }
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv6\+Address}}]{prefix\+To\+Use = {\ttfamily {\bf Ipv6\+Address\+::\+Get\+Zero}()}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1RipNg_a57bee3de4b39e03ad66e3fd35abf4805}{}\label{classns3_1_1RipNg_a57bee3de4b39e03ad66e3fd35abf4805}


Notify a new route. 

Typically this is used to add another route from I\+Pv6 stack (i.\+e. I\+C\+M\+Pv6 redirect case, ...). 
\begin{DoxyParams}{Parameters}
{\em dst} & destination address \\
\hline
{\em mask} & destination mask \\
\hline
{\em next\+Hop} & next\+Hop for this destination \\
\hline
{\em interface} & output interface \\
\hline
{\em prefix\+To\+Use} & prefix to use as source with this route \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6RoutingProtocol_ad5fee223bfdac0b1dde05de7702a87cf}{ns3\+::\+Ipv6\+Routing\+Protocol}.


\begin{DoxyCode}
437 \{
438   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << dst << mask << nextHop << interface << prefixToUse);
439   \textcolor{comment}{// \(\backslash\)todo this can be used to add delegate routes}
440 \}
\end{DoxyCode}
\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Notify\+Interface\+Down@{Notify\+Interface\+Down}}
\index{Notify\+Interface\+Down@{Notify\+Interface\+Down}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Notify\+Interface\+Down(uint32\+\_\+t interface)}{NotifyInterfaceDown(uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+Ng\+::\+Notify\+Interface\+Down (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1RipNg_a2031124814e8d817d0a40dddb7327a1b}{}\label{classns3_1_1RipNg_a2031124814e8d817d0a40dddb7327a1b}


Notify when specified interface goes D\+O\+WN. 

Protocols are expected to implement this method to be notified of the state change of an interface in a node. 
\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6RoutingProtocol_aa9b4c21a3878a1b808c9ac9d26c914bf}{ns3\+::\+Ipv6\+Routing\+Protocol}.


\begin{DoxyCode}
344 \{
345   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << interface);
346 
347   \textcolor{comment}{/* remove all routes that are going through this interface */}
348   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1RipNg_aa8bc6103d67089e1e3cd507936f94887}{RoutesI} it = \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.begin (); it != \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.end (); it++)
349     \{
350       \textcolor{keywordflow}{if} (it->first->GetInterface () == interface)
351         \{
352           \hyperlink{classns3_1_1RipNg_ae4fc1ca9ed948f3c028fd96fb016f7dd}{InvalidateRoute} (it->first);
353         \}
354     \}
355 
356   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1RipNg_a549052bbb55168d029f82d78384144b4}{SocketListI} iter = \hyperlink{classns3_1_1RipNg_a761d304dc3d34cd528afe87c5fa8090b}{m\_sendSocketList}.begin (); iter != 
      \hyperlink{classns3_1_1RipNg_a761d304dc3d34cd528afe87c5fa8090b}{m\_sendSocketList}.end (); iter++ )
357     \{
358       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Checking socket for interface "} << interface);
359       \textcolor{keywordflow}{if} (iter->second == interface)
360         \{
361           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Removed socket for interface "} << interface);
362           iter->first->Close ();
363           \hyperlink{classns3_1_1RipNg_a761d304dc3d34cd528afe87c5fa8090b}{m\_sendSocketList}.erase (iter);
364           \textcolor{keywordflow}{break};
365         \}
366     \}
367 
368   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1RipNg_a98c5b63bb7c56afa595c1bb568a7081f}{m\_interfaceExclusions}.find (interface) == 
      \hyperlink{classns3_1_1RipNg_a98c5b63bb7c56afa595c1bb568a7081f}{m\_interfaceExclusions}.end ())
369     \{
370       \hyperlink{classns3_1_1RipNg_ad7a8e445116b3dd8cdd1d50366787c66}{SendTriggeredRouteUpdate} ();
371     \}
372 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 22




Here is the caller graph for this function\+:
% FIG 23


\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Notify\+Interface\+Up@{Notify\+Interface\+Up}}
\index{Notify\+Interface\+Up@{Notify\+Interface\+Up}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Notify\+Interface\+Up(uint32\+\_\+t interface)}{NotifyInterfaceUp(uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+Ng\+::\+Notify\+Interface\+Up (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1RipNg_a588e191ae91316e498a8e5c84a9c77fb}{}\label{classns3_1_1RipNg_a588e191ae91316e498a8e5c84a9c77fb}


Notify when specified interface goes UP. 

Protocols are expected to implement this method to be notified of the state change of an interface in a node. 
\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6RoutingProtocol_a024dd60e2deb864565ba5993efc38300}{ns3\+::\+Ipv6\+Routing\+Protocol}.


\begin{DoxyCode}
268 \{
269   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
270 
271   \textcolor{keywordflow}{for} (uint32\_t j = 0; j < \hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->GetNAddresses (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}); j++)
272     \{
273       Ipv6InterfaceAddress address = \hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, j);
274       Ipv6Prefix networkMask = address.GetPrefix ();
275       Ipv6Address networkAddress = address.GetAddress ().CombinePrefix (networkMask);
276 
277       \textcolor{keywordflow}{if} (address.GetScope () == \hyperlink{classns3_1_1Ipv6InterfaceAddress_ad3f03debf9dae475b81ea9cdf81f4f27aaf504a3b8c1562206e6ba65b4a6cff1d}{Ipv6InterfaceAddress::GLOBAL})
278         \{
279           \hyperlink{classns3_1_1RipNg_a9d8c7bb0b6622946c347a88dabc06802}{AddNetworkRouteTo} (networkAddress, networkMask, \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
280         \}
281     \}
282 
283   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1RipNg_a789ca251ab1d869da5f62a4286067d2d}{m\_initialized})
284     \{
285       \textcolor{keywordflow}{return};
286     \}
287 
288 
289   \textcolor{keywordtype}{bool} sendSocketFound = \textcolor{keyword}{false};
290   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1RipNg_a549052bbb55168d029f82d78384144b4}{SocketListI} iter = \hyperlink{classns3_1_1RipNg_a761d304dc3d34cd528afe87c5fa8090b}{m\_sendSocketList}.begin (); iter != 
      \hyperlink{classns3_1_1RipNg_a761d304dc3d34cd528afe87c5fa8090b}{m\_sendSocketList}.end (); iter++ )
291     \{
292       \textcolor{keywordflow}{if} (iter->second == \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
293         \{
294           sendSocketFound = \textcolor{keyword}{true};
295           \textcolor{keywordflow}{break};
296         \}
297     \}
298 
299   \textcolor{keywordtype}{bool} activeInterface = \textcolor{keyword}{false};
300   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1RipNg_a98c5b63bb7c56afa595c1bb568a7081f}{m\_interfaceExclusions}.find (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) == 
      \hyperlink{classns3_1_1RipNg_a98c5b63bb7c56afa595c1bb568a7081f}{m\_interfaceExclusions}.end ())
301     \{
302       activeInterface = \textcolor{keyword}{true};
303       \hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->SetForwarding (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, \textcolor{keyword}{true});
304     \}
305 
306   \textcolor{keywordflow}{for} (uint32\_t j = 0; j < \hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->GetNAddresses (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}); j++)
307     \{
308       Ipv6InterfaceAddress address = \hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, j);
309 
310       \textcolor{keywordflow}{if} (address.GetScope() == \hyperlink{classns3_1_1Ipv6InterfaceAddress_ad3f03debf9dae475b81ea9cdf81f4f27a29f5cd6ebe813216f28d906d89d4c56d}{Ipv6InterfaceAddress::LINKLOCAL} && 
      sendSocketFound == \textcolor{keyword}{false} && activeInterface == \textcolor{keyword}{true})
311         \{
312           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"RIPng: adding sending socket to "} << address.GetAddress ());
313           TypeId tid = \hyperlink{classns3_1_1TypeId_a119cf99c20931fdc294602cd360b180e}{TypeId::LookupByName} (\textcolor{stringliteral}{"ns3::UdpSocketFactory"});
314           Ptr<Node> theNode = GetObject<Node> ();
315           Ptr<Socket> socket = \hyperlink{classns3_1_1Socket_ad448a62bb50ad3dbac59c879a885a8d2}{Socket::CreateSocket} (theNode, tid);
316           Inet6SocketAddress local = Inet6SocketAddress (address.GetAddress (), 
      \hyperlink{ripng_8cc_a86ce7fe00a995035f236d2463a7b761f}{RIPNG\_PORT});
317           socket->Bind (local);
318           socket->BindToNetDevice (\hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->GetNetDevice (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}));
319           socket->ShutdownRecv ();
320           socket->SetIpv6RecvHopLimit (\textcolor{keyword}{true});
321           \hyperlink{classns3_1_1RipNg_a761d304dc3d34cd528afe87c5fa8090b}{m\_sendSocketList}[socket] = \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
322         \}
323       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (address.GetScope() == \hyperlink{classns3_1_1Ipv6InterfaceAddress_ad3f03debf9dae475b81ea9cdf81f4f27aaf504a3b8c1562206e6ba65b4a6cff1d}{Ipv6InterfaceAddress::GLOBAL})
324         \{
325           \hyperlink{classns3_1_1RipNg_ad7a8e445116b3dd8cdd1d50366787c66}{SendTriggeredRouteUpdate} ();
326         \}
327     \}
328 
329   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1RipNg_a87437a46d9f4e0951f9d4c6b11208d4f}{m\_recvSocket})
330     \{
331       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"RIPng: adding receiving socket"});
332       TypeId tid = \hyperlink{classns3_1_1TypeId_a119cf99c20931fdc294602cd360b180e}{TypeId::LookupByName} (\textcolor{stringliteral}{"ns3::UdpSocketFactory"});
333       Ptr<Node> theNode = GetObject<Node> ();
334       \hyperlink{classns3_1_1RipNg_a87437a46d9f4e0951f9d4c6b11208d4f}{m\_recvSocket} = \hyperlink{classns3_1_1Socket_ad448a62bb50ad3dbac59c879a885a8d2}{Socket::CreateSocket} (theNode, tid);
335       Inet6SocketAddress local = Inet6SocketAddress (\hyperlink{ripng_8cc_a74c1e9507f7b739d0ad013b552bf1daf}{RIPNG\_ALL\_NODE}, 
      \hyperlink{ripng_8cc_a86ce7fe00a995035f236d2463a7b761f}{RIPNG\_PORT});
336       m\_recvSocket->Bind (local);
337       m\_recvSocket->SetRecvCallback (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&\hyperlink{classns3_1_1RipNg_ae8891520b5ae87abed2e2a15d50ba4d8}{RipNg::Receive}, \textcolor{keyword}{this}));
338       m\_recvSocket->SetIpv6RecvHopLimit (\textcolor{keyword}{true});
339       m\_recvSocket->SetRecvPktInfo (\textcolor{keyword}{true});
340     \}
341 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 24




Here is the caller graph for this function\+:
% FIG 25


\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Notify\+Remove\+Address@{Notify\+Remove\+Address}}
\index{Notify\+Remove\+Address@{Notify\+Remove\+Address}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Notify\+Remove\+Address(uint32\+\_\+t interface, Ipv6\+Interface\+Address address)}{NotifyRemoveAddress(uint32_t interface, Ipv6InterfaceAddress address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+Ng\+::\+Notify\+Remove\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv6\+Interface\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1RipNg_a0658ff312aa09265ddc9ad8718789f0a}{}\label{classns3_1_1RipNg_a0658ff312aa09265ddc9ad8718789f0a}


Notify when specified interface add an address. 

Protocols are expected to implement this method to be notified whenever a new address is removed from an interface. Typically used to remove the \textquotesingle{}network route\textquotesingle{} of an interface. Can be invoked on an up or down interface. 
\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
{\em address} & a new address being added to an interface \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6RoutingProtocol_a878ace2f28ea3b07417fe5751d9ec5fc}{ns3\+::\+Ipv6\+Routing\+Protocol}.


\begin{DoxyCode}
400 \{
401   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << interface << address);
402 
403   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->IsUp (interface))
404     \{
405       \textcolor{keywordflow}{return};
406     \}
407 
408   \textcolor{keywordflow}{if} (address.GetScope() != \hyperlink{classns3_1_1Ipv6InterfaceAddress_ad3f03debf9dae475b81ea9cdf81f4f27aaf504a3b8c1562206e6ba65b4a6cff1d}{Ipv6InterfaceAddress::GLOBAL})
409     \{
410       \textcolor{keywordflow}{return};
411     \}
412 
413   Ipv6Address networkAddress = address.GetAddress ().CombinePrefix (address.GetPrefix ());
414   Ipv6Prefix networkMask = address.GetPrefix ();
415 
416   \textcolor{comment}{// Remove all routes that are going through this interface}
417   \textcolor{comment}{// which reference this network}
418   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1RipNg_aa8bc6103d67089e1e3cd507936f94887}{RoutesI} it = \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.begin (); it != \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.end (); it++)
419     \{
420       \textcolor{keywordflow}{if} (it->first->GetInterface () == interface
421           && it->first->IsNetwork ()
422           && it->first->GetDestNetwork () == networkAddress
423           && it->first->GetDestNetworkPrefix () == networkMask)
424         \{
425           \hyperlink{classns3_1_1RipNg_ae4fc1ca9ed948f3c028fd96fb016f7dd}{InvalidateRoute} (it->first);
426         \}
427     \}
428 
429   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1RipNg_a98c5b63bb7c56afa595c1bb568a7081f}{m\_interfaceExclusions}.find (interface) == 
      \hyperlink{classns3_1_1RipNg_a98c5b63bb7c56afa595c1bb568a7081f}{m\_interfaceExclusions}.end ())
430     \{
431       \hyperlink{classns3_1_1RipNg_ad7a8e445116b3dd8cdd1d50366787c66}{SendTriggeredRouteUpdate} ();
432     \}
433 
434 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 26


\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Notify\+Remove\+Route@{Notify\+Remove\+Route}}
\index{Notify\+Remove\+Route@{Notify\+Remove\+Route}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Notify\+Remove\+Route(\+Ipv6\+Address dst, Ipv6\+Prefix mask, Ipv6\+Address next\+Hop, uint32\+\_\+t interface, Ipv6\+Address prefix\+To\+Use=\+Ipv6\+Address\+::\+Get\+Zero())}{NotifyRemoveRoute(Ipv6Address dst, Ipv6Prefix mask, Ipv6Address nextHop, uint32_t interface, Ipv6Address prefixToUse=Ipv6Address::GetZero())}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+Ng\+::\+Notify\+Remove\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{dst, }
\item[{{\bf Ipv6\+Prefix}}]{mask, }
\item[{{\bf Ipv6\+Address}}]{next\+Hop, }
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv6\+Address}}]{prefix\+To\+Use = {\ttfamily {\bf Ipv6\+Address\+::\+Get\+Zero}()}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1RipNg_a72de5c5fbbe3bd7f29a5b05d3dd46c16}{}\label{classns3_1_1RipNg_a72de5c5fbbe3bd7f29a5b05d3dd46c16}


Notify route removing. 


\begin{DoxyParams}{Parameters}
{\em dst} & destination address \\
\hline
{\em mask} & destination mask \\
\hline
{\em next\+Hop} & next\+Hop for this destination \\
\hline
{\em interface} & output interface \\
\hline
{\em prefix\+To\+Use} & prefix to use as source with this route \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6RoutingProtocol_afcd129c7be3b0fb78012fa68025bf553}{ns3\+::\+Ipv6\+Routing\+Protocol}.


\begin{DoxyCode}
443 \{
444   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << dst << mask << nextHop << interface);
445   \textcolor{comment}{// \(\backslash\)todo this can be used to delete delegate routes}
446 \}
\end{DoxyCode}
\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Print\+Routing\+Table@{Print\+Routing\+Table}}
\index{Print\+Routing\+Table@{Print\+Routing\+Table}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Print\+Routing\+Table(\+Ptr$<$ Output\+Stream\+Wrapper $>$ stream, Time\+::\+Unit unit=\+Time\+::\+S) const }{PrintRoutingTable(Ptr< OutputStreamWrapper > stream, Time::Unit unit=Time::S) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+Ng\+::\+Print\+Routing\+Table (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream, }
\item[{{\bf Time\+::\+Unit}}]{unit = {\ttfamily {\bf Time\+::S}}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1RipNg_aec30027ca8085a46d680b98291e27480}{}\label{classns3_1_1RipNg_aec30027ca8085a46d680b98291e27480}


Print the Routing Table entries. 


\begin{DoxyParams}{Parameters}
{\em stream} & The ostream the Routing table is printed to \\
\hline
{\em unit} & The time unit to be used in the report \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6RoutingProtocol_a2d5f8412f903a1365a1e84c06ad3da43}{ns3\+::\+Ipv6\+Routing\+Protocol}.


\begin{DoxyCode}
470 \{
471   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << stream);
472 
473   std::ostream* os = stream->\hyperlink{classns3_1_1OutputStreamWrapper_a0cf30a4188ab6fdae2b2ab74db11acc2}{GetStream} ();
474 
475   *os << \textcolor{stringliteral}{"Node: "} << \hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->GetObject<Node> ()->GetId ()
476       << \textcolor{stringliteral}{", Time: "} << \hyperlink{group__simulator_gac3635e2e87f7ce316c89290ee1b01d0d}{Now}().\hyperlink{classns3_1_1Time_a0bb1110638ce9938248bd07865a328ab}{As} (unit)
477       << \textcolor{stringliteral}{", Local time: "} << GetObject<Node> ()->GetLocalTime ().As (unit)
478       << \textcolor{stringliteral}{", IPv6 RIPng table"} << std::endl;
479 
480   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.empty ())
481     \{
482       *os << \textcolor{stringliteral}{"Destination                    Next Hop                   Flag Met Ref Use If"} << std::endl;
483       \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1RipNg_a139e1c11e66791c62fa5ccf632723f95}{RoutesCI} it = \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.begin (); it != \hyperlink{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{m\_routes}.end (); it++)
484         \{
485           RipNgRoutingTableEntry* route = it->first;
486           \hyperlink{classns3_1_1RipNgRoutingTableEntry_af723fc23e97afdd05c55da5162b7e673}{RipNgRoutingTableEntry::Status\_e} status = route->GetRouteStatus()
      ;
487 
488           \textcolor{keywordflow}{if} (status == \hyperlink{classns3_1_1RipNgRoutingTableEntry_af723fc23e97afdd05c55da5162b7e673a334e33ca88fb2b8de53c814814d3c017}{RipNgRoutingTableEntry::RIPNG\_VALID})
489             \{
490               std::ostringstream dest, gw, mask, flags;
491 
492               dest << route->GetDest () << \textcolor{stringliteral}{"/"} << int(route->GetDestNetworkPrefix ().GetPrefixLength ());
493               *os << std::setiosflags (std::ios::left) << std::setw (31) << dest.str ();
494               gw << route->GetGateway ();
495               *os << std::setiosflags (std::ios::left) << std::setw (27) << gw.str ();
496               flags << \textcolor{stringliteral}{"U"};
497               \textcolor{keywordflow}{if} (route->IsHost ())
498                 \{
499                   flags << \textcolor{stringliteral}{"H"};
500                 \}
501               \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (route->IsGateway ())
502                 \{
503                   flags << \textcolor{stringliteral}{"G"};
504                 \}
505               *os << std::setiosflags (std::ios::left) << std::setw (5) << flags.str ();
506               *os << std::setiosflags (std::ios::left) << std::setw (4) << int(route->GetRouteMetric ());
507               \textcolor{comment}{// Ref ct not implemented}
508               *os << \textcolor{stringliteral}{"-"} << \textcolor{stringliteral}{"   "};
509               \textcolor{comment}{// Use not implemented}
510               *os << \textcolor{stringliteral}{"-"} << \textcolor{stringliteral}{"   "};
511               \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Names_ab9664faf23569aaae64a2d1f65265045}{Names::FindName} (\hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->GetNetDevice (route->GetInterface ())) != \textcolor{stringliteral}{"
      "})
512                 \{
513                   *os << \hyperlink{classns3_1_1Names_ab9664faf23569aaae64a2d1f65265045}{Names::FindName} (\hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->GetNetDevice (route->GetInterface ()
      ));
514                 \}
515               \textcolor{keywordflow}{else}
516                 \{
517                   *os << route->GetInterface ();
518                 \}
519               *os << std::endl;
520             \}
521         \}
522     \}
523   *os << std::endl;
524 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 27


\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Receive@{Receive}}
\index{Receive@{Receive}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Receive(\+Ptr$<$ Socket $>$ socket)}{Receive(Ptr< Socket > socket)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+Ng\+::\+Receive (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Socket} $>$}]{socket}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_ae8891520b5ae87abed2e2a15d50ba4d8}{}\label{classns3_1_1RipNg_ae8891520b5ae87abed2e2a15d50ba4d8}


Receive R\+I\+Png packets. 


\begin{DoxyParams}{Parameters}
{\em socket} & the socket the packet was received to. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
703 \{
704   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << socket);
705 
706   Address sender;
707   Ptr<Packet> packet = socket->\hyperlink{classns3_1_1Socket_af22378d7af9a2745a9eada20210da215}{RecvFrom} (sender);
708   Inet6SocketAddress senderAddr = \hyperlink{classns3_1_1Inet6SocketAddress_a2177c66e1bcf17c85dcffb9d2a971f5a}{Inet6SocketAddress::ConvertFrom} (sender);
709   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Received "} << *packet << \textcolor{stringliteral}{" from "} << senderAddr);
710 
711   Ipv6Address senderAddress = senderAddr.GetIpv6 ();
712   uint16\_t senderPort = senderAddr.GetPort ();
713 
714   Ipv6PacketInfoTag interfaceInfo;
715   \textcolor{keywordflow}{if} (!packet->RemovePacketTag (interfaceInfo))
716     \{
717       \hyperlink{group__fatal_ga51ac4699be799d772ae7258d1ef6af21}{NS\_ABORT\_MSG} (\textcolor{stringliteral}{"No incoming interface on RIPng message, aborting."});
718     \}
719   uint32\_t incomingIf = interfaceInfo.GetRecvIf ();
720   Ptr<Node> node = this->GetObject<Node> ();
721   Ptr<NetDevice> dev = node->GetDevice (incomingIf);
722   uint32\_t ipInterfaceIndex = \hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->GetInterfaceForDevice (dev);
723 
724   SocketIpv6HopLimitTag hoplimitTag;
725   \textcolor{keywordflow}{if} (!packet->RemovePacketTag (hoplimitTag))
726     \{
727       \hyperlink{group__fatal_ga51ac4699be799d772ae7258d1ef6af21}{NS\_ABORT\_MSG} (\textcolor{stringliteral}{"No incoming Hop Count on RIPng message, aborting."});
728     \}
729   uint8\_t hopLimit = hoplimitTag.GetHopLimit ();
730 
731   int32\_t interfaceForAddress = \hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->GetInterfaceForAddress (senderAddress);
732   \textcolor{keywordflow}{if} (interfaceForAddress != -1)
733     \{
734       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Ignoring a packet sent by myself."});
735       \textcolor{keywordflow}{return};
736     \}
737 
738   RipNgHeader hdr;
739   packet->RemoveHeader (hdr);
740 
741   \textcolor{keywordflow}{if} (hdr.GetCommand () == \hyperlink{classns3_1_1RipNgHeader_ad96724d6f6fdb4ffa22fe71a0ff12bd2a787536902c0e1912fd0c234def4c32b7}{RipNgHeader::RESPONSE})
742     \{
743       \hyperlink{classns3_1_1RipNg_ade057ef030dc8cd6479949e35315ed7b}{HandleResponses} (hdr, senderAddress, ipInterfaceIndex, hopLimit);
744     \}
745   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (hdr.GetCommand () == \hyperlink{classns3_1_1RipNgHeader_ad96724d6f6fdb4ffa22fe71a0ff12bd2a5ad5fca80e45262ccf65fa6f0839984e}{RipNgHeader::REQUEST})
746     \{
747       \hyperlink{classns3_1_1RipNg_adb06ee7b823c0d7ae5b45b637c1ffd19}{HandleRequests} (hdr, senderAddress, senderPort, ipInterfaceIndex, hopLimit);
748     \}
749   \textcolor{keywordflow}{else}
750     \{
751       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Ignoring message with unknown command: "} << \textcolor{keywordtype}{int} (hdr.GetCommand ()));
752     \}
753   \textcolor{keywordflow}{return};
754 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 28




Here is the caller graph for this function\+:
% FIG 29


\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Recv\+Multicast\+Ripng@{Recv\+Multicast\+Ripng}}
\index{Recv\+Multicast\+Ripng@{Recv\+Multicast\+Ripng}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Recv\+Multicast\+Ripng(\+Ptr$<$ Socket $>$ socket)}{RecvMulticastRipng(Ptr< Socket > socket)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+Ng\+::\+Recv\+Multicast\+Ripng (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Socket} $>$}]{socket}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_aa0d0eaae30d312fe172fa9a7fc8d6d48}{}\label{classns3_1_1RipNg_aa0d0eaae30d312fe172fa9a7fc8d6d48}
Receive and process multicast packet 
\begin{DoxyParams}{Parameters}
{\em socket} & socket where packet is arrived \\
\hline
\end{DoxyParams}
\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Recv\+Unicast\+Ripng@{Recv\+Unicast\+Ripng}}
\index{Recv\+Unicast\+Ripng@{Recv\+Unicast\+Ripng}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Recv\+Unicast\+Ripng(\+Ptr$<$ Socket $>$ socket)}{RecvUnicastRipng(Ptr< Socket > socket)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+Ng\+::\+Recv\+Unicast\+Ripng (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Socket} $>$}]{socket}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_a798a6be4d3b79cb54d3f434995802049}{}\label{classns3_1_1RipNg_a798a6be4d3b79cb54d3f434995802049}
Receive and process unicast packet 
\begin{DoxyParams}{Parameters}
{\em socket} & socket where packet is arrived \\
\hline
\end{DoxyParams}
\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Route\+Input@{Route\+Input}}
\index{Route\+Input@{Route\+Input}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Route\+Input(\+Ptr$<$ const Packet $>$ p, const Ipv6\+Header \&header, Ptr$<$ const Net\+Device $>$ idev, Unicast\+Forward\+Callback ucb, Multicast\+Forward\+Callback mcb, Local\+Deliver\+Callback lcb, Error\+Callback ecb)}{RouteInput(Ptr< const Packet > p, const Ipv6Header &header, Ptr< const NetDevice > idev, UnicastForwardCallback ucb, MulticastForwardCallback mcb, LocalDeliverCallback lcb, ErrorCallback ecb)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Rip\+Ng\+::\+Route\+Input (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv6\+Header} \&}]{header, }
\item[{{\bf Ptr}$<$ const {\bf Net\+Device} $>$}]{idev, }
\item[{{\bf Unicast\+Forward\+Callback}}]{ucb, }
\item[{{\bf Multicast\+Forward\+Callback}}]{mcb, }
\item[{{\bf Local\+Deliver\+Callback}}]{lcb, }
\item[{{\bf Error\+Callback}}]{ecb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1RipNg_ad85da69a6006cd5089e1a69e7a6be13b}{}\label{classns3_1_1RipNg_ad85da69a6006cd5089e1a69e7a6be13b}


Route an input packet (to be forwarded or locally delivered) 

This lookup is used in the forwarding process. The packet is handed over to the \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol}, and will get forwarded onward by one of the callbacks. The Linux equivalent is ip\+\_\+route\+\_\+input (). There are four valid outcomes, and a matching callbacks to handle each.


\begin{DoxyParams}{Parameters}
{\em p} & received packet \\
\hline
{\em header} & input parameter used to form a search key for a route \\
\hline
{\em idev} & Pointer to ingress network device \\
\hline
{\em ucb} & \hyperlink{classns3_1_1Callback}{Callback} for the case in which the packet is to be forwarded as unicast \\
\hline
{\em mcb} & \hyperlink{classns3_1_1Callback}{Callback} for the case in which the packet is to be forwarded as multicast \\
\hline
{\em lcb} & \hyperlink{classns3_1_1Callback}{Callback} for the case in which the packet is to be locally delivered \\
\hline
{\em ecb} & \hyperlink{classns3_1_1Callback}{Callback} to call if there is an error in forwarding \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} takes responsibility for forwarding or delivering the packet, false otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv6RoutingProtocol_a73c66cddf196bf84090305f8d64df33b}{ns3\+::\+Ipv6\+Routing\+Protocol}.


\begin{DoxyCode}
214 \{
215   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} << header << header.GetSourceAddress () << header.
      GetDestinationAddress () << idev);
216 
217   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6} != 0);
218   \textcolor{comment}{// Check if input device supports IP}
219   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->GetInterfaceForDevice (idev) >= 0);
220   uint32\_t iif = \hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->GetInterfaceForDevice (idev);
221   Ipv6Address dst = header.GetDestinationAddress ();
222 
223   \textcolor{keywordflow}{if} (dst.IsMulticast ())
224     \{
225       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Multicast route not supported by RIPng"});
226       \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \textcolor{comment}{// Let other routing protocols try to handle this}
227     \}
228 
229   \textcolor{keywordflow}{if} (header.GetDestinationAddress ().IsLinkLocal () ||
230       header.GetSourceAddress ().IsLinkLocal ())
231     \{
232       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Dropping packet not for me and with src or dst LinkLocal"});
233       \textcolor{keywordflow}{if} (!ecb.IsNull ())
234         \{
235           ecb (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{Socket::ERROR\_NOROUTETOHOST});
236         \}
237       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
238     \}
239 
240   \textcolor{comment}{// Check if input device supports IP forwarding}
241   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->IsForwarding (iif) == \textcolor{keyword}{false})
242     \{
243       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Forwarding disabled for this interface"});
244       \textcolor{keywordflow}{if} (!ecb.IsNull ())
245         \{
246           ecb (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{Socket::ERROR\_NOROUTETOHOST});
247         \}
248       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
249     \}
250   \textcolor{comment}{// Next, try to find a route}
251   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Unicast destination"});
252   Ptr<Ipv6Route> rtentry = \hyperlink{classns3_1_1RipNg_ac008f65e3fe915230191cb1099890489}{Lookup} (header.GetDestinationAddress ());
253 
254   \textcolor{keywordflow}{if} (rtentry != 0)
255     \{
256       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Found unicast destination - calling unicast callback"});
257       ucb (idev, rtentry, \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header);  \textcolor{comment}{// unicast forwarding callback}
258       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
259     \}
260   \textcolor{keywordflow}{else}
261     \{
262       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Did not find unicast destination - returning false"});
263       \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \textcolor{comment}{// Let other routing protocols try to handle this}
264     \}
265 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 30


\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Route\+Output@{Route\+Output}}
\index{Route\+Output@{Route\+Output}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Route\+Output(\+Ptr$<$ Packet $>$ p, const Ipv6\+Header \&header, Ptr$<$ Net\+Device $>$ oif, Socket\+::\+Socket\+Errno \&sockerr)}{RouteOutput(Ptr< Packet > p, const Ipv6Header &header, Ptr< NetDevice > oif, Socket::SocketErrno &sockerr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv6\+Route} $>$ ns3\+::\+Rip\+Ng\+::\+Route\+Output (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv6\+Header} \&}]{header, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{oif, }
\item[{{\bf Socket\+::\+Socket\+Errno} \&}]{sockerr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1RipNg_acc42ebebc7e1b3ccb68c7be6b2f37f95}{}\label{classns3_1_1RipNg_acc42ebebc7e1b3ccb68c7be6b2f37f95}


Query routing cache for an existing route, for an outbound packet. 

This lookup is used by transport protocols. It does not cause any packet to be forwarded, and is synchronous. Can be used for multicast or unicast. The Linux equivalent is ip\+\_\+route\+\_\+output ()


\begin{DoxyParams}{Parameters}
{\em p} & packet to be routed. Note that this method may modify the packet. Callers may also pass in a null pointer. \\
\hline
{\em header} & input parameter (used to form key to search for the route) \\
\hline
{\em oif} & Output interface device. May be zero, or may be bound via socket options to a particular output interface. \\
\hline
{\em sockerr} & Output parameter; socket errno\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a code that indicates what happened in the lookup 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv6RoutingProtocol_a92e79a0364ad272392ee635ffe50644d}{ns3\+::\+Ipv6\+Routing\+Protocol}.


\begin{DoxyCode}
182 \{
183   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << header << oif);
184 
185   Ipv6Address destination = header.GetDestinationAddress ();
186   Ptr<Ipv6Route> rtentry = 0;
187 
188   \textcolor{keywordflow}{if} (destination.IsMulticast ())
189     \{
190       \textcolor{comment}{// Note:  Multicast routes for outbound packets are stored in the}
191       \textcolor{comment}{// normal unicast table.  An implication of this is that it is not}
192       \textcolor{comment}{// possible to source multicast datagrams on multiple interfaces.}
193       \textcolor{comment}{// This is a well-known property of sockets implementation on}
194       \textcolor{comment}{// many Unix variants.}
195       \textcolor{comment}{// So, we just log it and fall through to LookupStatic ()}
196       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"RouteOutput (): Multicast destination"});
197     \}
198 
199   rtentry = \hyperlink{classns3_1_1RipNg_ac008f65e3fe915230191cb1099890489}{Lookup} (destination, oif);
200   \textcolor{keywordflow}{if} (rtentry)
201     \{
202       sockerr = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaaa7eb006d73c5ad0117c5591fcb3469f7}{Socket::ERROR\_NOTERROR};
203     \}
204   \textcolor{keywordflow}{else}
205     \{
206       sockerr = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{Socket::ERROR\_NOROUTETOHOST};
207     \}
208   \textcolor{keywordflow}{return} rtentry;
209 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 31


\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Send\+Route\+Request@{Send\+Route\+Request}}
\index{Send\+Route\+Request@{Send\+Route\+Request}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Send\+Route\+Request()}{SendRouteRequest()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+Ng\+::\+Send\+Route\+Request (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_aa97c9ec93505c548bbf85ef18c532147}{}\label{classns3_1_1RipNg_aa97c9ec93505c548bbf85ef18c532147}


Send Routing Request on all interfaces. 


\begin{DoxyCode}
1237 \{
1238   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1239 
1240   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = Create<Packet> ();
1241   SocketIpv6HopLimitTag tag;
1242   p->RemovePacketTag (tag);
1243   tag.SetHopLimit (255);
1244   p->AddPacketTag (tag);
1245 
1246   RipNgHeader hdr;
1247   hdr.SetCommand (\hyperlink{classns3_1_1RipNgHeader_ad96724d6f6fdb4ffa22fe71a0ff12bd2a5ad5fca80e45262ccf65fa6f0839984e}{RipNgHeader::REQUEST});
1248 
1249   RipNgRte rte;
1250   rte.SetPrefix (\hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} ());
1251   rte.SetPrefixLen (0);
1252   rte.SetRouteMetric (\hyperlink{classns3_1_1RipNg_a6752c1bb1fc0909f0493033d426f2b92}{m\_linkDown});
1253 
1254   hdr.AddRte (rte);
1255   p->AddHeader (hdr);
1256 
1257   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1RipNg_a549052bbb55168d029f82d78384144b4}{SocketListI} iter = \hyperlink{classns3_1_1RipNg_a761d304dc3d34cd528afe87c5fa8090b}{m\_sendSocketList}.begin (); iter != 
      \hyperlink{classns3_1_1RipNg_a761d304dc3d34cd528afe87c5fa8090b}{m\_sendSocketList}.end (); iter++ )
1258     \{
1259       uint32\_t \textcolor{keyword}{interface }= iter->second;
1260 
1261       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1RipNg_a98c5b63bb7c56afa595c1bb568a7081f}{m\_interfaceExclusions}.find (interface) == 
      \hyperlink{classns3_1_1RipNg_a98c5b63bb7c56afa595c1bb568a7081f}{m\_interfaceExclusions}.end ())
1262         \{
1263           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"SendTo: "} << *p);
1264           iter->first->SendTo (p, 0, Inet6SocketAddress (\hyperlink{ripng_8cc_a74c1e9507f7b739d0ad013b552bf1daf}{RIPNG\_ALL\_NODE}, 
      \hyperlink{ripng_8cc_a86ce7fe00a995035f236d2463a7b761f}{RIPNG\_PORT}));
1265         \}
1266     \}
1267 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 32




Here is the caller graph for this function\+:
% FIG 33


\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Send\+Triggered\+Route\+Update@{Send\+Triggered\+Route\+Update}}
\index{Send\+Triggered\+Route\+Update@{Send\+Triggered\+Route\+Update}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Send\+Triggered\+Route\+Update()}{SendTriggeredRouteUpdate()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+Ng\+::\+Send\+Triggered\+Route\+Update (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_ad7a8e445116b3dd8cdd1d50366787c66}{}\label{classns3_1_1RipNg_ad7a8e445116b3dd8cdd1d50366787c66}


Send Triggered Routing Updates on all interfaces. 


\begin{DoxyCode}
1158 \{
1159   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1160 
1161   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1RipNg_a382578c16a30ce7de28794defeb661e9}{m\_nextTriggeredUpdate}.\hyperlink{classns3_1_1EventId_aabf8476d1a080c199ea0c6aa9ccea372}{IsRunning}())
1162     \{
1163       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Skipping Triggered Update due to cooldown"});
1164       \textcolor{keywordflow}{return};
1165     \}
1166 
1167   \textcolor{comment}{// DoSendRouteUpdate (false);}
1168 
1169   \textcolor{comment}{// note: The RFC states:}
1170   \textcolor{comment}{//     After a triggered}
1171   \textcolor{comment}{//     update is sent, a timer should be set for a random interval between 1}
1172   \textcolor{comment}{//     and 5 seconds.  If other changes that would trigger updates occur}
1173   \textcolor{comment}{//     before the timer expires, a single update is triggered when the timer}
1174   \textcolor{comment}{//     expires.  The timer is then reset to another random value between 1}
1175   \textcolor{comment}{//     and 5 seconds.  Triggered updates may be suppressed if a regular}
1176   \textcolor{comment}{//     update is due by the time the triggered update would be sent.}
1177   \textcolor{comment}{// Here we rely on this:}
1178   \textcolor{comment}{// When an update occurs (either Triggered or Periodic) the "IsChanged ()"}
1179   \textcolor{comment}{// route field will be cleared.}
1180   \textcolor{comment}{// Hence, the following Triggered Update will be fired, but will not send}
1181   \textcolor{comment}{// any route update.}
1182 
1183   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_a7964e6aa8f61a9d28973c8267a606ad8}{delay} = \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (\hyperlink{classns3_1_1RipNg_adc89174a768de707315ed3cb88a6a0aa}{m\_rng}->\hyperlink{classns3_1_1UniformRandomVariable_a03822d8c86ac51e9aa83bbc73041386b}{GetValue} (
      \hyperlink{classns3_1_1RipNg_a4da2b49a558678bd4c51a995fbfbf7af}{m\_minTriggeredUpdateDelay}.\hyperlink{classns3_1_1Time_a8f20d5c3b0902d7b4320982f340b57c8}{GetSeconds} (), 
      \hyperlink{classns3_1_1RipNg_a7087e78333b3a5caabc13a83753a13a2}{m\_maxTriggeredUpdateDelay}.\hyperlink{classns3_1_1Time_a8f20d5c3b0902d7b4320982f340b57c8}{GetSeconds} ()));
1184   \hyperlink{classns3_1_1RipNg_a382578c16a30ce7de28794defeb661e9}{m\_nextTriggeredUpdate} = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (delay, &
      \hyperlink{classns3_1_1RipNg_a110005349bf811e1b0f6af182298be15}{RipNg::DoSendRouteUpdate}, \textcolor{keyword}{this}, \textcolor{keyword}{false});
1185 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 34




Here is the caller graph for this function\+:
% FIG 35


\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Send\+Unsolicited\+Route\+Update@{Send\+Unsolicited\+Route\+Update}}
\index{Send\+Unsolicited\+Route\+Update@{Send\+Unsolicited\+Route\+Update}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Send\+Unsolicited\+Route\+Update(void)}{SendUnsolicitedRouteUpdate(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+Ng\+::\+Send\+Unsolicited\+Route\+Update (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_af4dc944e60808380f6c5af16bf867fdc}{}\label{classns3_1_1RipNg_af4dc944e60808380f6c5af16bf867fdc}


Send Unsolicited Routing Updates on all interfaces. 


\begin{DoxyCode}
1188 \{
1189   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1190 
1191   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1RipNg_a382578c16a30ce7de28794defeb661e9}{m\_nextTriggeredUpdate}.\hyperlink{classns3_1_1EventId_aabf8476d1a080c199ea0c6aa9ccea372}{IsRunning}())
1192     \{
1193       \hyperlink{classns3_1_1RipNg_a382578c16a30ce7de28794defeb661e9}{m\_nextTriggeredUpdate}.\hyperlink{classns3_1_1EventId_a993ae94e48e014e1afd47edb16db7a11}{Cancel} ();
1194     \}
1195 
1196   \hyperlink{classns3_1_1RipNg_a110005349bf811e1b0f6af182298be15}{DoSendRouteUpdate} (\textcolor{keyword}{true});
1197 
1198   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_a7964e6aa8f61a9d28973c8267a606ad8}{delay} = \hyperlink{classns3_1_1RipNg_a8bedf450622f395cc52c1d37dc4d7a40}{m\_unsolicitedUpdate} + \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (
      \hyperlink{classns3_1_1RipNg_adc89174a768de707315ed3cb88a6a0aa}{m\_rng}->\hyperlink{classns3_1_1UniformRandomVariable_a03822d8c86ac51e9aa83bbc73041386b}{GetValue} (0, 0.5*\hyperlink{classns3_1_1RipNg_a8bedf450622f395cc52c1d37dc4d7a40}{m\_unsolicitedUpdate}.
      \hyperlink{classns3_1_1Time_a8f20d5c3b0902d7b4320982f340b57c8}{GetSeconds} ()) );
1199   \hyperlink{classns3_1_1RipNg_a673a77372c3bbc67338c52f6b0291134}{m\_nextUnsolicitedUpdate} = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (delay, &
      \hyperlink{classns3_1_1RipNg_af4dc944e60808380f6c5af16bf867fdc}{RipNg::SendUnsolicitedRouteUpdate}, \textcolor{keyword}{this});
1200 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 36




Here is the caller graph for this function\+:
% FIG 37


\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Set\+Interface\+Exclusions@{Set\+Interface\+Exclusions}}
\index{Set\+Interface\+Exclusions@{Set\+Interface\+Exclusions}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Set\+Interface\+Exclusions(std\+::set$<$ uint32\+\_\+t $>$ exceptions)}{SetInterfaceExclusions(std::set< uint32_t > exceptions)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+Ng\+::\+Set\+Interface\+Exclusions (
\begin{DoxyParamCaption}
\item[{std\+::set$<$ uint32\+\_\+t $>$}]{exceptions}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1RipNg_a4dce40799b2b372ef7fc31901d8b5114}{}\label{classns3_1_1RipNg_a4dce40799b2b372ef7fc31901d8b5114}


Set the set of interface excluded from the protocol. 


\begin{DoxyParams}{Parameters}
{\em exceptions} & the set of excluded interfaces \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1208 \{
1209   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1210 
1211   \hyperlink{classns3_1_1RipNg_a98c5b63bb7c56afa595c1bb568a7081f}{m\_interfaceExclusions} = exceptions;
1212 \}
\end{DoxyCode}
\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Set\+Interface\+Metric@{Set\+Interface\+Metric}}
\index{Set\+Interface\+Metric@{Set\+Interface\+Metric}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Set\+Interface\+Metric(uint32\+\_\+t interface, uint8\+\_\+t metric)}{SetInterfaceMetric(uint32_t interface, uint8_t metric)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+Ng\+::\+Set\+Interface\+Metric (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{uint8\+\_\+t}]{metric}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1RipNg_a98e6039328b6d70dd97bfd8edbf24ba3}{}\label{classns3_1_1RipNg_a98e6039328b6d70dd97bfd8edbf24ba3}


Set the metric for an interface. 


\begin{DoxyParams}{Parameters}
{\em interface} & the interface \\
\hline
{\em metric} & the interface metric \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1227 \{
1228   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << interface << \textcolor{keywordtype}{int} (metric));
1229 
1230   \textcolor{keywordflow}{if} (metric < \hyperlink{classns3_1_1RipNg_a6752c1bb1fc0909f0493033d426f2b92}{m\_linkDown})
1231     \{
1232       \hyperlink{classns3_1_1RipNg_aa63ca4f7ad5ad13c878220c51d8b89c5}{m\_interfaceMetrics}[interface] = metric;
1233     \}
1234 \}
\end{DoxyCode}
\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!Set\+Ipv6@{Set\+Ipv6}}
\index{Set\+Ipv6@{Set\+Ipv6}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{Set\+Ipv6(\+Ptr$<$ Ipv6 $>$ ipv6)}{SetIpv6(Ptr< Ipv6 > ipv6)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+Ng\+::\+Set\+Ipv6 (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv6} $>$}]{ipv6}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1RipNg_acd8e0a2b2453a28ecd4154729e45d324}{}\label{classns3_1_1RipNg_acd8e0a2b2453a28ecd4154729e45d324}


Typically, invoked directly or indirectly from \hyperlink{classns3_1_1Ipv6_aa889d2174527a1df773d65974de83f8f}{ns3\+::\+Ipv6\+::\+Set\+Routing\+Protocol}. 


\begin{DoxyParams}{Parameters}
{\em ipv6} & the ipv6 object this routing protocol is being associated with \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6RoutingProtocol_ab97e8194b12a2db1d1374fc881974903}{ns3\+::\+Ipv6\+Routing\+Protocol}.


\begin{DoxyCode}
449 \{
450   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << ipv6);
451 
452   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6} == 0 && ipv6 != 0);
453   uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0;
454   \hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6} = ipv6;
455 
456   \textcolor{keywordflow}{for} (i = 0; i < \hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->GetNInterfaces (); i++)
457     \{
458       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{m\_ipv6}->IsUp (i))
459         \{
460           \hyperlink{classns3_1_1RipNg_a588e191ae91316e498a8e5c84a9c77fb}{NotifyInterfaceUp} (i);
461         \}
462       \textcolor{keywordflow}{else}
463         \{
464           \hyperlink{classns3_1_1RipNg_a2031124814e8d817d0a40dddb7327a1b}{NotifyInterfaceDown} (i);
465         \}
466     \}
467 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 38




\subsection{Member Data Documentation}
\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!m\+\_\+garbage\+Collection\+Delay@{m\+\_\+garbage\+Collection\+Delay}}
\index{m\+\_\+garbage\+Collection\+Delay@{m\+\_\+garbage\+Collection\+Delay}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{m\+\_\+garbage\+Collection\+Delay}{m_garbageCollectionDelay}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Rip\+Ng\+::m\+\_\+garbage\+Collection\+Delay\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_aa42bd385be7a330206d02e2e721edc19}{}\label{classns3_1_1RipNg_aa42bd385be7a330206d02e2e721edc19}


Delay before deleting an I\+N\+V\+A\+L\+ID route. 

\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!m\+\_\+initialized@{m\+\_\+initialized}}
\index{m\+\_\+initialized@{m\+\_\+initialized}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{m\+\_\+initialized}{m_initialized}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Rip\+Ng\+::m\+\_\+initialized\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_a789ca251ab1d869da5f62a4286067d2d}{}\label{classns3_1_1RipNg_a789ca251ab1d869da5f62a4286067d2d}


flag to allow socket\textquotesingle{}s late-\/creation. 

\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!m\+\_\+interface\+Exclusions@{m\+\_\+interface\+Exclusions}}
\index{m\+\_\+interface\+Exclusions@{m\+\_\+interface\+Exclusions}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{m\+\_\+interface\+Exclusions}{m_interfaceExclusions}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::set$<$uint32\+\_\+t$>$ ns3\+::\+Rip\+Ng\+::m\+\_\+interface\+Exclusions\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_a98c5b63bb7c56afa595c1bb568a7081f}{}\label{classns3_1_1RipNg_a98c5b63bb7c56afa595c1bb568a7081f}


Set of excluded interfaces. 

\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!m\+\_\+interface\+Metrics@{m\+\_\+interface\+Metrics}}
\index{m\+\_\+interface\+Metrics@{m\+\_\+interface\+Metrics}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{m\+\_\+interface\+Metrics}{m_interfaceMetrics}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<$uint32\+\_\+t, uint8\+\_\+t$>$ ns3\+::\+Rip\+Ng\+::m\+\_\+interface\+Metrics\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_aa63ca4f7ad5ad13c878220c51d8b89c5}{}\label{classns3_1_1RipNg_aa63ca4f7ad5ad13c878220c51d8b89c5}


Map of interface metrics. 

\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!m\+\_\+ipv6@{m\+\_\+ipv6}}
\index{m\+\_\+ipv6@{m\+\_\+ipv6}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{m\+\_\+ipv6}{m_ipv6}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Ipv6}$>$ ns3\+::\+Rip\+Ng\+::m\+\_\+ipv6\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}{}\label{classns3_1_1RipNg_aca7a023799ce2004499a826ba5d5d3fe}


I\+Pv6 reference. 

\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!m\+\_\+link\+Down@{m\+\_\+link\+Down}}
\index{m\+\_\+link\+Down@{m\+\_\+link\+Down}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{m\+\_\+link\+Down}{m_linkDown}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::\+Rip\+Ng\+::m\+\_\+link\+Down\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_a6752c1bb1fc0909f0493033d426f2b92}{}\label{classns3_1_1RipNg_a6752c1bb1fc0909f0493033d426f2b92}


Link down value. 

\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!m\+\_\+max\+Triggered\+Update\+Delay@{m\+\_\+max\+Triggered\+Update\+Delay}}
\index{m\+\_\+max\+Triggered\+Update\+Delay@{m\+\_\+max\+Triggered\+Update\+Delay}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Triggered\+Update\+Delay}{m_maxTriggeredUpdateDelay}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Rip\+Ng\+::m\+\_\+max\+Triggered\+Update\+Delay\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_a7087e78333b3a5caabc13a83753a13a2}{}\label{classns3_1_1RipNg_a7087e78333b3a5caabc13a83753a13a2}


Max cooldown delay after a Triggered Update. 

\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!m\+\_\+min\+Triggered\+Update\+Delay@{m\+\_\+min\+Triggered\+Update\+Delay}}
\index{m\+\_\+min\+Triggered\+Update\+Delay@{m\+\_\+min\+Triggered\+Update\+Delay}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{m\+\_\+min\+Triggered\+Update\+Delay}{m_minTriggeredUpdateDelay}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Rip\+Ng\+::m\+\_\+min\+Triggered\+Update\+Delay\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_a4da2b49a558678bd4c51a995fbfbf7af}{}\label{classns3_1_1RipNg_a4da2b49a558678bd4c51a995fbfbf7af}


Min cooldown delay after a Triggered Update. 

\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!m\+\_\+next\+Triggered\+Update@{m\+\_\+next\+Triggered\+Update}}
\index{m\+\_\+next\+Triggered\+Update@{m\+\_\+next\+Triggered\+Update}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{m\+\_\+next\+Triggered\+Update}{m_nextTriggeredUpdate}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Event\+Id} ns3\+::\+Rip\+Ng\+::m\+\_\+next\+Triggered\+Update\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_a382578c16a30ce7de28794defeb661e9}{}\label{classns3_1_1RipNg_a382578c16a30ce7de28794defeb661e9}


Next Triggered Update event. 

\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!m\+\_\+next\+Unsolicited\+Update@{m\+\_\+next\+Unsolicited\+Update}}
\index{m\+\_\+next\+Unsolicited\+Update@{m\+\_\+next\+Unsolicited\+Update}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{m\+\_\+next\+Unsolicited\+Update}{m_nextUnsolicitedUpdate}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Event\+Id} ns3\+::\+Rip\+Ng\+::m\+\_\+next\+Unsolicited\+Update\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_a673a77372c3bbc67338c52f6b0291134}{}\label{classns3_1_1RipNg_a673a77372c3bbc67338c52f6b0291134}


Next Unsolicited Update event. 

\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!m\+\_\+recv\+Socket@{m\+\_\+recv\+Socket}}
\index{m\+\_\+recv\+Socket@{m\+\_\+recv\+Socket}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{m\+\_\+recv\+Socket}{m_recvSocket}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Socket}$>$ ns3\+::\+Rip\+Ng\+::m\+\_\+recv\+Socket\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_a87437a46d9f4e0951f9d4c6b11208d4f}{}\label{classns3_1_1RipNg_a87437a46d9f4e0951f9d4c6b11208d4f}


receive socket 

\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!m\+\_\+rng@{m\+\_\+rng}}
\index{m\+\_\+rng@{m\+\_\+rng}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{m\+\_\+rng}{m_rng}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Uniform\+Random\+Variable}$>$ ns3\+::\+Rip\+Ng\+::m\+\_\+rng\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_adc89174a768de707315ed3cb88a6a0aa}{}\label{classns3_1_1RipNg_adc89174a768de707315ed3cb88a6a0aa}


Rng stream. 

\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!m\+\_\+routes@{m\+\_\+routes}}
\index{m\+\_\+routes@{m\+\_\+routes}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{m\+\_\+routes}{m_routes}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Routes} ns3\+::\+Rip\+Ng\+::m\+\_\+routes\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}{}\label{classns3_1_1RipNg_acfc1011b140f9e612a8c27c9bfb4c6b5}


the forwarding table for network. 

\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!m\+\_\+send\+Socket\+List@{m\+\_\+send\+Socket\+List}}
\index{m\+\_\+send\+Socket\+List@{m\+\_\+send\+Socket\+List}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{m\+\_\+send\+Socket\+List}{m_sendSocketList}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Socket\+List} ns3\+::\+Rip\+Ng\+::m\+\_\+send\+Socket\+List\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_a761d304dc3d34cd528afe87c5fa8090b}{}\label{classns3_1_1RipNg_a761d304dc3d34cd528afe87c5fa8090b}


list of sockets for sending (socket, interface index) 

\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!m\+\_\+split\+Horizon\+Strategy@{m\+\_\+split\+Horizon\+Strategy}}
\index{m\+\_\+split\+Horizon\+Strategy@{m\+\_\+split\+Horizon\+Strategy}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{m\+\_\+split\+Horizon\+Strategy}{m_splitHorizonStrategy}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Split\+Horizon\+Type\+\_\+e} ns3\+::\+Rip\+Ng\+::m\+\_\+split\+Horizon\+Strategy\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_a2aaaf4747380a0960cc48cb04ae99a1a}{}\label{classns3_1_1RipNg_a2aaaf4747380a0960cc48cb04ae99a1a}


Split Horizon strategy. 

\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!m\+\_\+startup\+Delay@{m\+\_\+startup\+Delay}}
\index{m\+\_\+startup\+Delay@{m\+\_\+startup\+Delay}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{m\+\_\+startup\+Delay}{m_startupDelay}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Rip\+Ng\+::m\+\_\+startup\+Delay\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_a11c536612cb48e139d4a3b8d34c9ec3a}{}\label{classns3_1_1RipNg_a11c536612cb48e139d4a3b8d34c9ec3a}


Random delay before protocol startup. 

\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!m\+\_\+timeout\+Delay@{m\+\_\+timeout\+Delay}}
\index{m\+\_\+timeout\+Delay@{m\+\_\+timeout\+Delay}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{m\+\_\+timeout\+Delay}{m_timeoutDelay}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Rip\+Ng\+::m\+\_\+timeout\+Delay\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_aed45845b278332b589e76304a3701d72}{}\label{classns3_1_1RipNg_aed45845b278332b589e76304a3701d72}


Delay before invalidating a route. 

\index{ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}!m\+\_\+unsolicited\+Update@{m\+\_\+unsolicited\+Update}}
\index{m\+\_\+unsolicited\+Update@{m\+\_\+unsolicited\+Update}!ns3\+::\+Rip\+Ng@{ns3\+::\+Rip\+Ng}}
\subsubsection[{\texorpdfstring{m\+\_\+unsolicited\+Update}{m_unsolicitedUpdate}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Rip\+Ng\+::m\+\_\+unsolicited\+Update\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1RipNg_a8bedf450622f395cc52c1d37dc4d7a40}{}\label{classns3_1_1RipNg_a8bedf450622f395cc52c1d37dc4d7a40}


time between two Unsolicited Routing Updates 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/model/\hyperlink{ripng_8h}{ripng.\+h}\item 
internet/model/\hyperlink{ripng_8cc}{ripng.\+cc}\end{DoxyCompactItemize}
