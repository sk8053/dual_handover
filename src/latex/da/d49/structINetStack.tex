\hypertarget{structINetStack}{}\section{I\+Net\+Stack Struct Reference}
\label{structINetStack}\index{I\+Net\+Stack@{I\+Net\+Stack}}


Struct interface to N\+SC stack.  




{\ttfamily \#include $<$sim\+\_\+interface.\+h$>$}



Collaboration diagram for I\+Net\+Stack\+:
% FIG 0
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual \hyperlink{structINetStack_aa4febc7e2b66d861acfba1f4beebda0e}{$\sim$\+I\+Net\+Stack} ()
\item 
virtual void \hyperlink{structINetStack_a586b23bb19f9161cd326a2df9a88e205}{init} (int hz)=0
\begin{DoxyCompactList}\small\item\em Initialize the stack. \end{DoxyCompactList}\item 
virtual void \hyperlink{structINetStack_a717976f6495da376e006b6ac1b54c086}{if\+\_\+receive\+\_\+packet} (int if\+\_\+id, const void $\ast$\hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data}, int datalen)=0
\begin{DoxyCompactList}\small\item\em Deliver complete packet to the N\+SC network stack. \end{DoxyCompactList}\item 
virtual void \hyperlink{structINetStack_a2aa79cbc69b2aa0003c2a0e727d6438a}{if\+\_\+send\+\_\+packet} (const void $\ast$\hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data}, int datalen)=0
\begin{DoxyCompactList}\small\item\em Send complete packet to the N\+SC network stack. \end{DoxyCompactList}\item 
virtual void \hyperlink{structINetStack_afffc356feed7f466f83c20804192df28}{if\+\_\+send\+\_\+finish} (int if\+\_\+id)=0
\begin{DoxyCompactList}\small\item\em Signal the completion of send procedure to the N\+SC network stack. \end{DoxyCompactList}\item 
virtual void \hyperlink{structINetStack_aa092e60f18b07a756727ef3d48fb23c2}{if\+\_\+attach} (const char $\ast$addr, const char $\ast$mask, int mtu)=0
\begin{DoxyCompactList}\small\item\em Attach an interface to the stack. \end{DoxyCompactList}\item 
virtual void \hyperlink{structINetStack_a73f8126b5bfa498c7558fe3144b79b22}{add\+\_\+default\+\_\+gateway} (const char $\ast$addr)=0
\begin{DoxyCompactList}\small\item\em Add a default gateway to the interface. \end{DoxyCompactList}\item 
virtual int \hyperlink{structINetStack_aa2fa7aa24856935a2141675fd735b5ff}{get\+\_\+id} ()=0
\begin{DoxyCompactList}\small\item\em Returns the internal id of the stack instance. \end{DoxyCompactList}\item 
virtual const char $\ast$ \hyperlink{structINetStack_a665ce57b538c87f2ba7b0f03ca5f89be}{get\+\_\+name} ()=0
\begin{DoxyCompactList}\small\item\em Return a short one-\/word name of the stack. \end{DoxyCompactList}\item 
virtual int \hyperlink{structINetStack_a2e4dceb2e0e63c45a251e84b5a5a380d}{get\+\_\+hz} ()=0
\begin{DoxyCompactList}\small\item\em Get the timer\+\_\+interrupt frequency. \end{DoxyCompactList}\item 
virtual void \hyperlink{structINetStack_adea013a2541f16b8cbf0548744be937b}{timer\+\_\+interrupt} ()=0
\begin{DoxyCompactList}\small\item\em The stack timer\+\_\+interrupt function. \end{DoxyCompactList}\item 
virtual void \hyperlink{structINetStack_a97a74f983e4fd5fddeeff3cf7180a617}{increment\+\_\+ticks} ()=0
\begin{DoxyCompactList}\small\item\em Increment the time ticks. \end{DoxyCompactList}\item 
virtual void \hyperlink{structINetStack_a62459a1b7e52395f643b00c4c17336a0}{buffer\+\_\+size} (int size)=0
\begin{DoxyCompactList}\small\item\em Set the buffer size. \end{DoxyCompactList}\item 
virtual struct \hyperlink{structINetDatagramSocket}{I\+Net\+Datagram\+Socket} $\ast$ \hyperlink{structINetStack_aa60d96b381e97cc1bd06d3de8797b802}{new\+\_\+udp\+\_\+socket} ()
\begin{DoxyCompactList}\small\item\em Create a new U\+DP socket. \end{DoxyCompactList}\item 
virtual struct \hyperlink{structINetStreamSocket}{I\+Net\+Stream\+Socket} $\ast$ \hyperlink{structINetStack_a6379ab96d754f8cefa330ba186bb6b2a}{new\+\_\+tcp\+\_\+socket} ()
\begin{DoxyCompactList}\small\item\em Create a new T\+CP socket. \end{DoxyCompactList}\item 
virtual struct \hyperlink{structINetStreamSocket}{I\+Net\+Stream\+Socket} $\ast$ \hyperlink{structINetStack_af4593b1f78902bc5a5c0f655ed33dd82}{new\+\_\+sctp\+\_\+socket} ()
\begin{DoxyCompactList}\small\item\em Create a new S\+C\+TP socket. \end{DoxyCompactList}\item 
virtual int \hyperlink{structINetStack_a0a438f5ca8eea27a04997801e9bc37c3}{sysctl} (const char $\ast$sysctl\+\_\+name, void $\ast$oldval, size\+\_\+t $\ast$oldlenp, void $\ast$newval, size\+\_\+t newlen)
\begin{DoxyCompactList}\small\item\em use sysctl to modify system parameters \end{DoxyCompactList}\item 
virtual int \hyperlink{structINetStack_ad237b6c2a8d492e07fbb6db85feabdda}{sysctl\+\_\+set} (const char $\ast$\hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name}, const char $\ast$value)
\begin{DoxyCompactList}\small\item\em Set system parameters using sysctl. \end{DoxyCompactList}\item 
virtual int \hyperlink{structINetStack_a396b535a199299a904f52e00d0dbf590}{sysctl\+\_\+get} (const char $\ast$\hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name}, char $\ast$value, size\+\_\+t len)
\begin{DoxyCompactList}\small\item\em Get system parameters using sysctl. \end{DoxyCompactList}\item 
virtual int \hyperlink{structINetStack_a102073dbedc3c2f290658795ede66aa0}{sysctl\+\_\+getnum} (size\+\_\+t idx, char $\ast$\hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name}, size\+\_\+t len)
\begin{DoxyCompactList}\small\item\em Tell the cradle code to put the name of sysctl number \textquotesingle{}idx\textquotesingle{} into name\mbox{[}\mbox{]}. \end{DoxyCompactList}\item 
virtual void \hyperlink{structINetStack_ac93016db66cb785cd922da2e933cec5b}{show\+\_\+config} ()
\begin{DoxyCompactList}\small\item\em Show the N\+SC configuration. \end{DoxyCompactList}\item 
virtual bool \hyperlink{structINetStack_a2245e510856bdda751196d2161e44bae}{get\+\_\+var} (const char $\ast$var, char $\ast$result, int result\+\_\+len)
\begin{DoxyCompactList}\small\item\em Optional function to get variables for this stack. \end{DoxyCompactList}\item 
virtual bool \hyperlink{structINetStack_a87dcc53b24d552658aa841d5149713e3}{set\+\_\+var} (const char $\ast$var, const char $\ast$val)
\begin{DoxyCompactList}\small\item\em Optional function to set variables for this stack. \end{DoxyCompactList}\item 
virtual void \hyperlink{structINetStack_a568cca15e43babd4483ff48ac39de10d}{set\+\_\+diagnostic} (int level)
\begin{DoxyCompactList}\small\item\em Set the level of debugging or diagnostic information to print out. \end{DoxyCompactList}\item 
virtual int \hyperlink{structINetStack_acdadbd6bddaa81e538a9fd88d90df883}{cmd} (const char $\ast$)
\begin{DoxyCompactList}\small\item\em Simple interface to support sending any textual command to a stack. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Struct interface to N\+SC stack. 

\subsection{Constructor \& Destructor Documentation}
\index{I\+Net\+Stack@{I\+Net\+Stack}!````~I\+Net\+Stack@{$\sim$\+I\+Net\+Stack}}
\index{````~I\+Net\+Stack@{$\sim$\+I\+Net\+Stack}!I\+Net\+Stack@{I\+Net\+Stack}}
\subsubsection[{\texorpdfstring{$\sim$\+I\+Net\+Stack()}{~INetStack()}}]{\setlength{\rightskip}{0pt plus 5cm}virtual I\+Net\+Stack\+::$\sim$\+I\+Net\+Stack (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{structINetStack_aa4febc7e2b66d861acfba1f4beebda0e}{}\label{structINetStack_aa4febc7e2b66d861acfba1f4beebda0e}

\begin{DoxyCode}
33 \{\}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 1




\subsection{Member Function Documentation}
\index{I\+Net\+Stack@{I\+Net\+Stack}!add\+\_\+default\+\_\+gateway@{add\+\_\+default\+\_\+gateway}}
\index{add\+\_\+default\+\_\+gateway@{add\+\_\+default\+\_\+gateway}!I\+Net\+Stack@{I\+Net\+Stack}}
\subsubsection[{\texorpdfstring{add\+\_\+default\+\_\+gateway(const char $\ast$addr)=0}{add_default_gateway(const char *addr)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void I\+Net\+Stack\+::add\+\_\+default\+\_\+gateway (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{addr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{structINetStack_a73f8126b5bfa498c7558fe3144b79b22}{}\label{structINetStack_a73f8126b5bfa498c7558fe3144b79b22}


Add a default gateway to the interface. 


\begin{DoxyParams}{Parameters}
{\em addr} & gateway address \\
\hline
\end{DoxyParams}


Here is the caller graph for this function\+:
% FIG 2


\index{I\+Net\+Stack@{I\+Net\+Stack}!buffer\+\_\+size@{buffer\+\_\+size}}
\index{buffer\+\_\+size@{buffer\+\_\+size}!I\+Net\+Stack@{I\+Net\+Stack}}
\subsubsection[{\texorpdfstring{buffer\+\_\+size(int size)=0}{buffer_size(int size)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void I\+Net\+Stack\+::buffer\+\_\+size (
\begin{DoxyParamCaption}
\item[{int}]{size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{structINetStack_a62459a1b7e52395f643b00c4c17336a0}{}\label{structINetStack_a62459a1b7e52395f643b00c4c17336a0}


Set the buffer size. 


\begin{DoxyParams}{Parameters}
{\em size} & the buffer size. \\
\hline
\end{DoxyParams}


Here is the caller graph for this function\+:
% FIG 3


\index{I\+Net\+Stack@{I\+Net\+Stack}!cmd@{cmd}}
\index{cmd@{cmd}!I\+Net\+Stack@{I\+Net\+Stack}}
\subsubsection[{\texorpdfstring{cmd(const char $\ast$)}{cmd(const char *)}}]{\setlength{\rightskip}{0pt plus 5cm}virtual int I\+Net\+Stack\+::cmd (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{structINetStack_acdadbd6bddaa81e538a9fd88d90df883}{}\label{structINetStack_acdadbd6bddaa81e538a9fd88d90df883}


Simple interface to support sending any textual command to a stack. 

\begin{DoxyReturn}{Returns}
0 on success 
\end{DoxyReturn}

\begin{DoxyCode}
250   \{
251     \textcolor{keywordflow}{return} 1;
252   \}
\end{DoxyCode}
\index{I\+Net\+Stack@{I\+Net\+Stack}!get\+\_\+hz@{get\+\_\+hz}}
\index{get\+\_\+hz@{get\+\_\+hz}!I\+Net\+Stack@{I\+Net\+Stack}}
\subsubsection[{\texorpdfstring{get\+\_\+hz()=0}{get_hz()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual int I\+Net\+Stack\+::get\+\_\+hz (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{structINetStack_a2e4dceb2e0e63c45a251e84b5a5a380d}{}\label{structINetStack_a2e4dceb2e0e63c45a251e84b5a5a380d}


Get the timer\+\_\+interrupt frequency. 

This is used so the simulator can call the stack timer\+\_\+interrupt function the correct amount of times per second. For example, lwip has a hz of 10, which it returns here to say that it\textquotesingle{}s timer\+\_\+interrupt should be called 10 times a second. Free\+B\+SD uses 100, as does Linux 2.\+4, while Linux 2.\+6 uses 1000. (This is often configurable in the kernel in question, also.)

\begin{DoxyReturn}{Returns}
frequency 
\end{DoxyReturn}


Here is the caller graph for this function\+:
% FIG 4


\index{I\+Net\+Stack@{I\+Net\+Stack}!get\+\_\+id@{get\+\_\+id}}
\index{get\+\_\+id@{get\+\_\+id}!I\+Net\+Stack@{I\+Net\+Stack}}
\subsubsection[{\texorpdfstring{get\+\_\+id()=0}{get_id()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual int I\+Net\+Stack\+::get\+\_\+id (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{structINetStack_aa2fa7aa24856935a2141675fd735b5ff}{}\label{structINetStack_aa2fa7aa24856935a2141675fd735b5ff}


Returns the internal id of the stack instance. 

Purely for debugging/diagnostic purposes. \begin{DoxyReturn}{Returns}
internal stack id 
\end{DoxyReturn}


Here is the caller graph for this function\+:
% FIG 5


\index{I\+Net\+Stack@{I\+Net\+Stack}!get\+\_\+name@{get\+\_\+name}}
\index{get\+\_\+name@{get\+\_\+name}!I\+Net\+Stack@{I\+Net\+Stack}}
\subsubsection[{\texorpdfstring{get\+\_\+name()=0}{get_name()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual const char$\ast$ I\+Net\+Stack\+::get\+\_\+name (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{structINetStack_a665ce57b538c87f2ba7b0f03ca5f89be}{}\label{structINetStack_a665ce57b538c87f2ba7b0f03ca5f89be}


Return a short one-\/word name of the stack. 

Should return a short one-\/word name of the stack. Eg. Linux 2.\+4.\+x -\/$>$ linux24, Free\+B\+SD 5.\+x -\/$>$ freebsd5. This can be used to identify output from a stack, for example a packet trace file. \begin{DoxyReturn}{Returns}
short one-\/word name of the stack 
\end{DoxyReturn}


Here is the caller graph for this function\+:
% FIG 6


\index{I\+Net\+Stack@{I\+Net\+Stack}!get\+\_\+var@{get\+\_\+var}}
\index{get\+\_\+var@{get\+\_\+var}!I\+Net\+Stack@{I\+Net\+Stack}}
\subsubsection[{\texorpdfstring{get\+\_\+var(const char $\ast$var, char $\ast$result, int result\+\_\+len)}{get_var(const char *var, char *result, int result_len)}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool I\+Net\+Stack\+::get\+\_\+var (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{var, }
\item[{char $\ast$}]{result, }
\item[{int}]{result\+\_\+len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{structINetStack_a2245e510856bdda751196d2161e44bae}{}\label{structINetStack_a2245e510856bdda751196d2161e44bae}


Optional function to get variables for this stack. 


\begin{DoxyParams}{Parameters}
{\em var} & the variable \\
\hline
{\em result} & the result \\
\hline
{\em result\+\_\+len} & result length \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success 
\end{DoxyReturn}

\begin{DoxyCode}
219   \{
220     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
221   \}
\end{DoxyCode}
\index{I\+Net\+Stack@{I\+Net\+Stack}!if\+\_\+attach@{if\+\_\+attach}}
\index{if\+\_\+attach@{if\+\_\+attach}!I\+Net\+Stack@{I\+Net\+Stack}}
\subsubsection[{\texorpdfstring{if\+\_\+attach(const char $\ast$addr, const char $\ast$mask, int mtu)=0}{if_attach(const char *addr, const char *mask, int mtu)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void I\+Net\+Stack\+::if\+\_\+attach (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{addr, }
\item[{const char $\ast$}]{mask, }
\item[{int}]{mtu}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{structINetStack_aa092e60f18b07a756727ef3d48fb23c2}{}\label{structINetStack_aa092e60f18b07a756727ef3d48fb23c2}


Attach an interface to the stack. 


\begin{DoxyParams}{Parameters}
{\em addr} & address \\
\hline
{\em mask} & network mask \\
\hline
{\em mtu} & M\+TU \\
\hline
\end{DoxyParams}


Here is the caller graph for this function\+:
% FIG 7


\index{I\+Net\+Stack@{I\+Net\+Stack}!if\+\_\+receive\+\_\+packet@{if\+\_\+receive\+\_\+packet}}
\index{if\+\_\+receive\+\_\+packet@{if\+\_\+receive\+\_\+packet}!I\+Net\+Stack@{I\+Net\+Stack}}
\subsubsection[{\texorpdfstring{if\+\_\+receive\+\_\+packet(int if\+\_\+id, const void $\ast$data, int datalen)=0}{if_receive_packet(int if_id, const void *data, int datalen)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void I\+Net\+Stack\+::if\+\_\+receive\+\_\+packet (
\begin{DoxyParamCaption}
\item[{int}]{if\+\_\+id, }
\item[{const void $\ast$}]{data, }
\item[{int}]{datalen}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{structINetStack_a717976f6495da376e006b6ac1b54c086}{}\label{structINetStack_a717976f6495da376e006b6ac1b54c086}


Deliver complete packet to the N\+SC network stack. 


\begin{DoxyParams}{Parameters}
{\em if\+\_\+id} & interface ID \\
\hline
{\em data} & data \\
\hline
{\em datalen} & data length \\
\hline
\end{DoxyParams}


Here is the caller graph for this function\+:
% FIG 8


\index{I\+Net\+Stack@{I\+Net\+Stack}!if\+\_\+send\+\_\+finish@{if\+\_\+send\+\_\+finish}}
\index{if\+\_\+send\+\_\+finish@{if\+\_\+send\+\_\+finish}!I\+Net\+Stack@{I\+Net\+Stack}}
\subsubsection[{\texorpdfstring{if\+\_\+send\+\_\+finish(int if\+\_\+id)=0}{if_send_finish(int if_id)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void I\+Net\+Stack\+::if\+\_\+send\+\_\+finish (
\begin{DoxyParamCaption}
\item[{int}]{if\+\_\+id}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{structINetStack_afffc356feed7f466f83c20804192df28}{}\label{structINetStack_afffc356feed7f466f83c20804192df28}


Signal the completion of send procedure to the N\+SC network stack. 


\begin{DoxyParams}{Parameters}
{\em if\+\_\+id} & interface ID \\
\hline
\end{DoxyParams}


Here is the caller graph for this function\+:
% FIG 9


\index{I\+Net\+Stack@{I\+Net\+Stack}!if\+\_\+send\+\_\+packet@{if\+\_\+send\+\_\+packet}}
\index{if\+\_\+send\+\_\+packet@{if\+\_\+send\+\_\+packet}!I\+Net\+Stack@{I\+Net\+Stack}}
\subsubsection[{\texorpdfstring{if\+\_\+send\+\_\+packet(const void $\ast$data, int datalen)=0}{if_send_packet(const void *data, int datalen)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void I\+Net\+Stack\+::if\+\_\+send\+\_\+packet (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{data, }
\item[{int}]{datalen}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{structINetStack_a2aa79cbc69b2aa0003c2a0e727d6438a}{}\label{structINetStack_a2aa79cbc69b2aa0003c2a0e727d6438a}


Send complete packet to the N\+SC network stack. 


\begin{DoxyParams}{Parameters}
{\em data} & data \\
\hline
{\em datalen} & data length \\
\hline
\end{DoxyParams}


Here is the caller graph for this function\+:
% FIG 10


\index{I\+Net\+Stack@{I\+Net\+Stack}!increment\+\_\+ticks@{increment\+\_\+ticks}}
\index{increment\+\_\+ticks@{increment\+\_\+ticks}!I\+Net\+Stack@{I\+Net\+Stack}}
\subsubsection[{\texorpdfstring{increment\+\_\+ticks()=0}{increment_ticks()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void I\+Net\+Stack\+::increment\+\_\+ticks (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{structINetStack_a97a74f983e4fd5fddeeff3cf7180a617}{}\label{structINetStack_a97a74f983e4fd5fddeeff3cf7180a617}


Increment the time ticks. 



Here is the caller graph for this function\+:
% FIG 11


\index{I\+Net\+Stack@{I\+Net\+Stack}!init@{init}}
\index{init@{init}!I\+Net\+Stack@{I\+Net\+Stack}}
\subsubsection[{\texorpdfstring{init(int hz)=0}{init(int hz)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void I\+Net\+Stack\+::init (
\begin{DoxyParamCaption}
\item[{int}]{hz}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{structINetStack_a586b23bb19f9161cd326a2df9a88e205}{}\label{structINetStack_a586b23bb19f9161cd326a2df9a88e205}


Initialize the stack. 


\begin{DoxyParams}{Parameters}
{\em hz} & timer\+\_\+interrupt frequency \\
\hline
\end{DoxyParams}


Here is the caller graph for this function\+:
% FIG 12


\index{I\+Net\+Stack@{I\+Net\+Stack}!new\+\_\+sctp\+\_\+socket@{new\+\_\+sctp\+\_\+socket}}
\index{new\+\_\+sctp\+\_\+socket@{new\+\_\+sctp\+\_\+socket}!I\+Net\+Stack@{I\+Net\+Stack}}
\subsubsection[{\texorpdfstring{new\+\_\+sctp\+\_\+socket()}{new_sctp_socket()}}]{\setlength{\rightskip}{0pt plus 5cm}virtual struct {\bf I\+Net\+Stream\+Socket}$\ast$ I\+Net\+Stack\+::new\+\_\+sctp\+\_\+socket (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{structINetStack_af4593b1f78902bc5a5c0f655ed33dd82}{}\label{structINetStack_af4593b1f78902bc5a5c0f655ed33dd82}


Create a new S\+C\+TP socket. 

\begin{DoxyReturn}{Returns}
A new S\+C\+TP socket. 
\end{DoxyReturn}

\begin{DoxyCode}
134 \{ \textcolor{keywordflow}{return} NULL; \}
\end{DoxyCode}
\index{I\+Net\+Stack@{I\+Net\+Stack}!new\+\_\+tcp\+\_\+socket@{new\+\_\+tcp\+\_\+socket}}
\index{new\+\_\+tcp\+\_\+socket@{new\+\_\+tcp\+\_\+socket}!I\+Net\+Stack@{I\+Net\+Stack}}
\subsubsection[{\texorpdfstring{new\+\_\+tcp\+\_\+socket()}{new_tcp_socket()}}]{\setlength{\rightskip}{0pt plus 5cm}virtual struct {\bf I\+Net\+Stream\+Socket}$\ast$ I\+Net\+Stack\+::new\+\_\+tcp\+\_\+socket (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{structINetStack_a6379ab96d754f8cefa330ba186bb6b2a}{}\label{structINetStack_a6379ab96d754f8cefa330ba186bb6b2a}


Create a new T\+CP socket. 

\begin{DoxyReturn}{Returns}
A new T\+CP socket. 
\end{DoxyReturn}

\begin{DoxyCode}
129 \{ \textcolor{keywordflow}{return} NULL; \}
\end{DoxyCode}
\index{I\+Net\+Stack@{I\+Net\+Stack}!new\+\_\+udp\+\_\+socket@{new\+\_\+udp\+\_\+socket}}
\index{new\+\_\+udp\+\_\+socket@{new\+\_\+udp\+\_\+socket}!I\+Net\+Stack@{I\+Net\+Stack}}
\subsubsection[{\texorpdfstring{new\+\_\+udp\+\_\+socket()}{new_udp_socket()}}]{\setlength{\rightskip}{0pt plus 5cm}virtual struct {\bf I\+Net\+Datagram\+Socket}$\ast$ I\+Net\+Stack\+::new\+\_\+udp\+\_\+socket (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{structINetStack_aa60d96b381e97cc1bd06d3de8797b802}{}\label{structINetStack_aa60d96b381e97cc1bd06d3de8797b802}


Create a new U\+DP socket. 

\begin{DoxyReturn}{Returns}
A new U\+DP socket. 
\end{DoxyReturn}

\begin{DoxyCode}
124 \{ \textcolor{keywordflow}{return} NULL; \}
\end{DoxyCode}
\index{I\+Net\+Stack@{I\+Net\+Stack}!set\+\_\+diagnostic@{set\+\_\+diagnostic}}
\index{set\+\_\+diagnostic@{set\+\_\+diagnostic}!I\+Net\+Stack@{I\+Net\+Stack}}
\subsubsection[{\texorpdfstring{set\+\_\+diagnostic(int level)}{set_diagnostic(int level)}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void I\+Net\+Stack\+::set\+\_\+diagnostic (
\begin{DoxyParamCaption}
\item[{int}]{level}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{structINetStack_a568cca15e43babd4483ff48ac39de10d}{}\label{structINetStack_a568cca15e43babd4483ff48ac39de10d}


Set the level of debugging or diagnostic information to print out. 

This normally means kernel messages printed out during initialisation but may also include extra debugging messages that are part of N\+SC.


\begin{DoxyParams}{Parameters}
{\em level} & debugging/diagnostic level \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
242 \{\}
\end{DoxyCode}
\index{I\+Net\+Stack@{I\+Net\+Stack}!set\+\_\+var@{set\+\_\+var}}
\index{set\+\_\+var@{set\+\_\+var}!I\+Net\+Stack@{I\+Net\+Stack}}
\subsubsection[{\texorpdfstring{set\+\_\+var(const char $\ast$var, const char $\ast$val)}{set_var(const char *var, const char *val)}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool I\+Net\+Stack\+::set\+\_\+var (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{var, }
\item[{const char $\ast$}]{val}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{structINetStack_a87dcc53b24d552658aa841d5149713e3}{}\label{structINetStack_a87dcc53b24d552658aa841d5149713e3}


Optional function to set variables for this stack. 


\begin{DoxyParams}{Parameters}
{\em var} & the variable \\
\hline
{\em val} & the new value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success 
\end{DoxyReturn}

\begin{DoxyCode}
230   \{
231     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
232   \}
\end{DoxyCode}
\index{I\+Net\+Stack@{I\+Net\+Stack}!show\+\_\+config@{show\+\_\+config}}
\index{show\+\_\+config@{show\+\_\+config}!I\+Net\+Stack@{I\+Net\+Stack}}
\subsubsection[{\texorpdfstring{show\+\_\+config()}{show_config()}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void I\+Net\+Stack\+::show\+\_\+config (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{structINetStack_ac93016db66cb785cd922da2e933cec5b}{}\label{structINetStack_ac93016db66cb785cd922da2e933cec5b}


Show the N\+SC configuration. 


\begin{DoxyCode}
207   \{
208     ;
209   \}
\end{DoxyCode}
\index{I\+Net\+Stack@{I\+Net\+Stack}!sysctl@{sysctl}}
\index{sysctl@{sysctl}!I\+Net\+Stack@{I\+Net\+Stack}}
\subsubsection[{\texorpdfstring{sysctl(const char $\ast$sysctl\+\_\+name, void $\ast$oldval, size\+\_\+t $\ast$oldlenp, void $\ast$newval, size\+\_\+t newlen)}{sysctl(const char *sysctl_name, void *oldval, size_t *oldlenp, void *newval, size_t newlen)}}]{\setlength{\rightskip}{0pt plus 5cm}virtual int I\+Net\+Stack\+::sysctl (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{sysctl\+\_\+name, }
\item[{void $\ast$}]{oldval, }
\item[{size\+\_\+t $\ast$}]{oldlenp, }
\item[{void $\ast$}]{newval, }
\item[{size\+\_\+t}]{newlen}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{structINetStack_a0a438f5ca8eea27a04997801e9bc37c3}{}\label{structINetStack_a0a438f5ca8eea27a04997801e9bc37c3}


use sysctl to modify system parameters 


\begin{DoxyParams}{Parameters}
{\em sysctl\+\_\+name} & name of the parameter to modify \\
\hline
{\em oldval} & old value \\
\hline
{\em oldlenp} & old value length \\
\hline
{\em newval} & new value \\
\hline
{\em newlen} & new value length \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The status code. 
\end{DoxyReturn}

\begin{DoxyCode}
149   \{
150     \textcolor{keywordflow}{return} -1;
151   \}
\end{DoxyCode}
\index{I\+Net\+Stack@{I\+Net\+Stack}!sysctl\+\_\+get@{sysctl\+\_\+get}}
\index{sysctl\+\_\+get@{sysctl\+\_\+get}!I\+Net\+Stack@{I\+Net\+Stack}}
\subsubsection[{\texorpdfstring{sysctl\+\_\+get(const char $\ast$name, char $\ast$value, size\+\_\+t len)}{sysctl_get(const char *name, char *value, size_t len)}}]{\setlength{\rightskip}{0pt plus 5cm}virtual int I\+Net\+Stack\+::sysctl\+\_\+get (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{name, }
\item[{char $\ast$}]{value, }
\item[{size\+\_\+t}]{len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{structINetStack_a396b535a199299a904f52e00d0dbf590}{}\label{structINetStack_a396b535a199299a904f52e00d0dbf590}


Get system parameters using sysctl. 


\begin{DoxyParams}{Parameters}
{\em name} & name of the parameter to modify \\
\hline
{\em value} & value \\
\hline
{\em len} & value length \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
length of the string in value, i.\+e. retval $>$ len\+: \textquotesingle{}output truncated\textquotesingle{}. 
\end{DoxyReturn}

\begin{DoxyCode}
179   \{
180     \textcolor{keywordflow}{return} -1;
181   \}
\end{DoxyCode}
\index{I\+Net\+Stack@{I\+Net\+Stack}!sysctl\+\_\+getnum@{sysctl\+\_\+getnum}}
\index{sysctl\+\_\+getnum@{sysctl\+\_\+getnum}!I\+Net\+Stack@{I\+Net\+Stack}}
\subsubsection[{\texorpdfstring{sysctl\+\_\+getnum(size\+\_\+t idx, char $\ast$name, size\+\_\+t len)}{sysctl_getnum(size_t idx, char *name, size_t len)}}]{\setlength{\rightskip}{0pt plus 5cm}virtual int I\+Net\+Stack\+::sysctl\+\_\+getnum (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{idx, }
\item[{char $\ast$}]{name, }
\item[{size\+\_\+t}]{len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{structINetStack_a102073dbedc3c2f290658795ede66aa0}{}\label{structINetStack_a102073dbedc3c2f290658795ede66aa0}


Tell the cradle code to put the name of sysctl number \textquotesingle{}idx\textquotesingle{} into name\mbox{[}\mbox{]}. 

The idea is that this can be used to get a list of all available sysctls\+: \begin{DoxyVerb}char buf[256]
for (i=0; sysctl_getnum(i, buf, sizeof(buf)) > 0 ;i++)
   puts(buf);
\end{DoxyVerb}



\begin{DoxyParams}{Parameters}
{\em idx} & index \\
\hline
{\em name} & sysctl name \\
\hline
{\em len} & sysctl length \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
-\/1 if idx is out of range and the length of the sysctl name otherwise. 
\end{DoxyReturn}

\begin{DoxyCode}
199   \{
200     \textcolor{keywordflow}{return} -1;
201   \}
\end{DoxyCode}
\index{I\+Net\+Stack@{I\+Net\+Stack}!sysctl\+\_\+set@{sysctl\+\_\+set}}
\index{sysctl\+\_\+set@{sysctl\+\_\+set}!I\+Net\+Stack@{I\+Net\+Stack}}
\subsubsection[{\texorpdfstring{sysctl\+\_\+set(const char $\ast$name, const char $\ast$value)}{sysctl_set(const char *name, const char *value)}}]{\setlength{\rightskip}{0pt plus 5cm}virtual int I\+Net\+Stack\+::sysctl\+\_\+set (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{name, }
\item[{const char $\ast$}]{value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{structINetStack_ad237b6c2a8d492e07fbb6db85feabdda}{}\label{structINetStack_ad237b6c2a8d492e07fbb6db85feabdda}


Set system parameters using sysctl. 


\begin{DoxyParams}{Parameters}
{\em name} & name of the parameter to modify \\
\hline
{\em value} & new value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyCode}
164   \{
165     \textcolor{keywordflow}{return} -1;
166   \}
\end{DoxyCode}
\index{I\+Net\+Stack@{I\+Net\+Stack}!timer\+\_\+interrupt@{timer\+\_\+interrupt}}
\index{timer\+\_\+interrupt@{timer\+\_\+interrupt}!I\+Net\+Stack@{I\+Net\+Stack}}
\subsubsection[{\texorpdfstring{timer\+\_\+interrupt()=0}{timer_interrupt()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void I\+Net\+Stack\+::timer\+\_\+interrupt (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{structINetStack_adea013a2541f16b8cbf0548744be937b}{}\label{structINetStack_adea013a2541f16b8cbf0548744be937b}


The stack timer\+\_\+interrupt function. 



Here is the caller graph for this function\+:
% FIG 13




The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
internet/model/\hyperlink{sim__interface_8h}{sim\+\_\+interface.\+h}\end{DoxyCompactItemize}
