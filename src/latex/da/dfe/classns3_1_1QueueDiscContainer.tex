\hypertarget{classns3_1_1QueueDiscContainer}{}\section{ns3\+:\+:Queue\+Disc\+Container Class Reference}
\label{classns3_1_1QueueDiscContainer}\index{ns3\+::\+Queue\+Disc\+Container@{ns3\+::\+Queue\+Disc\+Container}}


Holds a vector of \hyperlink{classns3_1_1QueueDisc}{ns3\+::\+Queue\+Disc} pointers.  




{\ttfamily \#include $<$queue-\/disc-\/container.\+h$>$}



Collaboration diagram for ns3\+:\+:Queue\+Disc\+Container\+:
% FIG 0
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef std\+::vector$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1QueueDisc}{Queue\+Disc} $>$ $>$\+::const\+\_\+iterator \hyperlink{classns3_1_1QueueDiscContainer_a3c46b3a107b7b15d6b638ae50b5d9b58}{Const\+Iterator}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1QueueDisc}{Queue\+Disc} container const iterator. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1QueueDiscContainer_a742cbacacaef876e93d0b097647cfacd}{Queue\+Disc\+Container} ()
\item 
\hyperlink{classns3_1_1QueueDiscContainer_af27e7a7681b95b29074afdf532a8c852}{Queue\+Disc\+Container} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1QueueDisc}{Queue\+Disc} $>$ q\+Disc)
\item 
\hyperlink{classns3_1_1QueueDiscContainer_a3c46b3a107b7b15d6b638ae50b5d9b58}{Const\+Iterator} \hyperlink{classns3_1_1QueueDiscContainer_a67517618d43724e04a2cd3c710934014}{Begin} (void) const 
\begin{DoxyCompactList}\small\item\em Get a const iterator which refers to the first \hyperlink{classns3_1_1QueueDisc}{Queue\+Disc} in the container. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1QueueDiscContainer_a3c46b3a107b7b15d6b638ae50b5d9b58}{Const\+Iterator} \hyperlink{classns3_1_1QueueDiscContainer_a8b4c3b14d4890bb5fb0e4597e6bf1135}{End} (void) const 
\begin{DoxyCompactList}\small\item\em Get a const iterator which indicates past-\/the-\/last \hyperlink{classns3_1_1QueueDisc}{Queue\+Disc} in the container. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1QueueDiscContainer_aeacbea464213a3dce96b5551e30a2f3d}{GetN} (void) const 
\begin{DoxyCompactList}\small\item\em Get the number of Ptr$<$\+Queue\+Disc$>$ stored in this container. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1QueueDisc}{Queue\+Disc} $>$ \hyperlink{classns3_1_1QueueDiscContainer_a236064f6321b5f0d32561bb2a14e74af}{Get} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) const 
\begin{DoxyCompactList}\small\item\em Get the Ptr$<$\+Queue\+Disc$>$ stored in this container at a given index. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1QueueDiscContainer_a0520ac277a87beaeda5608dd8bfd37a4}{Add} (\hyperlink{classns3_1_1QueueDiscContainer}{Queue\+Disc\+Container} other)
\begin{DoxyCompactList}\small\item\em Append the contents of another \hyperlink{classns3_1_1QueueDiscContainer}{Queue\+Disc\+Container} to the end of this container. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1QueueDiscContainer_afc3ee503f476ea697faed2dd05b70cb4}{Add} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1QueueDisc}{Queue\+Disc} $>$ q\+Disc)
\begin{DoxyCompactList}\small\item\em Append a single Ptr$<$\+Queue\+Disc$>$ to this container. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::vector$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1QueueDisc}{Queue\+Disc} $>$ $>$ \hyperlink{classns3_1_1QueueDiscContainer_a1518c7ab608bf21b84b21474131ffed5}{m\+\_\+queue\+Discs}
\begin{DoxyCompactList}\small\item\em Queue\+Discs smart pointers. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Holds a vector of \hyperlink{classns3_1_1QueueDisc}{ns3\+::\+Queue\+Disc} pointers. 

Typically ns-\/3 Queue\+Discs are installed on net devices using a traffic control helper. The helper Install method takes a \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} which holds some number of Ptr$<$\+Net\+Device$>$. For each of the net devices in the \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} the helper will instantiate a queue disc and install it to the net device. For each of the queue discs, the helper also adds the queue disc into a Container for later use by the caller. This is that container used to hold the Ptr$<$\+Queue\+Disc$>$ which are instantiated by the traffic control helper. 

\subsection{Member Typedef Documentation}
\index{ns3\+::\+Queue\+Disc\+Container@{ns3\+::\+Queue\+Disc\+Container}!Const\+Iterator@{Const\+Iterator}}
\index{Const\+Iterator@{Const\+Iterator}!ns3\+::\+Queue\+Disc\+Container@{ns3\+::\+Queue\+Disc\+Container}}
\subsubsection[{\texorpdfstring{Const\+Iterator}{ConstIterator}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::vector$<${\bf Ptr}$<${\bf Queue\+Disc}$>$ $>$\+::const\+\_\+iterator {\bf ns3\+::\+Queue\+Disc\+Container\+::\+Const\+Iterator}}\hypertarget{classns3_1_1QueueDiscContainer_a3c46b3a107b7b15d6b638ae50b5d9b58}{}\label{classns3_1_1QueueDiscContainer_a3c46b3a107b7b15d6b638ae50b5d9b58}


\hyperlink{classns3_1_1QueueDisc}{Queue\+Disc} container const iterator. 



\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Queue\+Disc\+Container@{ns3\+::\+Queue\+Disc\+Container}!Queue\+Disc\+Container@{Queue\+Disc\+Container}}
\index{Queue\+Disc\+Container@{Queue\+Disc\+Container}!ns3\+::\+Queue\+Disc\+Container@{ns3\+::\+Queue\+Disc\+Container}}
\subsubsection[{\texorpdfstring{Queue\+Disc\+Container()}{QueueDiscContainer()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Queue\+Disc\+Container\+::\+Queue\+Disc\+Container (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1QueueDiscContainer_a742cbacacaef876e93d0b097647cfacd}{}\label{classns3_1_1QueueDiscContainer_a742cbacacaef876e93d0b097647cfacd}
Create an empty \hyperlink{classns3_1_1QueueDiscContainer}{Queue\+Disc\+Container}. 
\begin{DoxyCode}
26 \{
27 \}
\end{DoxyCode}
\index{ns3\+::\+Queue\+Disc\+Container@{ns3\+::\+Queue\+Disc\+Container}!Queue\+Disc\+Container@{Queue\+Disc\+Container}}
\index{Queue\+Disc\+Container@{Queue\+Disc\+Container}!ns3\+::\+Queue\+Disc\+Container@{ns3\+::\+Queue\+Disc\+Container}}
\subsubsection[{\texorpdfstring{Queue\+Disc\+Container(\+Ptr$<$ Queue\+Disc $>$ q\+Disc)}{QueueDiscContainer(Ptr< QueueDisc > qDisc)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Queue\+Disc\+Container\+::\+Queue\+Disc\+Container (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Queue\+Disc} $>$}]{q\+Disc}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1QueueDiscContainer_af27e7a7681b95b29074afdf532a8c852}{}\label{classns3_1_1QueueDiscContainer_af27e7a7681b95b29074afdf532a8c852}

\begin{DoxyParams}{Parameters}
{\em q\+Disc} & a queue disc to add to the container\\
\hline
\end{DoxyParams}
Create a \hyperlink{classns3_1_1QueueDiscContainer}{Queue\+Disc\+Container} with exactly one queue disc that has previously been instantiated 
\begin{DoxyCode}
30 \{
31   \hyperlink{classns3_1_1QueueDiscContainer_a1518c7ab608bf21b84b21474131ffed5}{m\_queueDiscs}.push\_back (qDisc);
32 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Queue\+Disc\+Container@{ns3\+::\+Queue\+Disc\+Container}!Add@{Add}}
\index{Add@{Add}!ns3\+::\+Queue\+Disc\+Container@{ns3\+::\+Queue\+Disc\+Container}}
\subsubsection[{\texorpdfstring{Add(\+Queue\+Disc\+Container other)}{Add(QueueDiscContainer other)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Queue\+Disc\+Container\+::\+Add (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Disc\+Container}}]{other}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1QueueDiscContainer_a0520ac277a87beaeda5608dd8bfd37a4}{}\label{classns3_1_1QueueDiscContainer_a0520ac277a87beaeda5608dd8bfd37a4}


Append the contents of another \hyperlink{classns3_1_1QueueDiscContainer}{Queue\+Disc\+Container} to the end of this container. 


\begin{DoxyParams}{Parameters}
{\em other} & The \hyperlink{classns3_1_1QueueDiscContainer}{Queue\+Disc\+Container} to append. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
60 \{
61   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1QueueDiscContainer_a3c46b3a107b7b15d6b638ae50b5d9b58}{ConstIterator} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = other.Begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != other.End (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
62     \{
63       \hyperlink{classns3_1_1QueueDiscContainer_a1518c7ab608bf21b84b21474131ffed5}{m\_queueDiscs}.push\_back (*\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
64     \}
65 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 1




Here is the caller graph for this function\+:
% FIG 2


\index{ns3\+::\+Queue\+Disc\+Container@{ns3\+::\+Queue\+Disc\+Container}!Add@{Add}}
\index{Add@{Add}!ns3\+::\+Queue\+Disc\+Container@{ns3\+::\+Queue\+Disc\+Container}}
\subsubsection[{\texorpdfstring{Add(\+Ptr$<$ Queue\+Disc $>$ q\+Disc)}{Add(Ptr< QueueDisc > qDisc)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Queue\+Disc\+Container\+::\+Add (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Queue\+Disc} $>$}]{q\+Disc}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1QueueDiscContainer_afc3ee503f476ea697faed2dd05b70cb4}{}\label{classns3_1_1QueueDiscContainer_afc3ee503f476ea697faed2dd05b70cb4}


Append a single Ptr$<$\+Queue\+Disc$>$ to this container. 


\begin{DoxyParams}{Parameters}
{\em q\+Disc} & The Ptr$<$\+Queue\+Disc$>$ to append. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
69 \{
70   \hyperlink{classns3_1_1QueueDiscContainer_a1518c7ab608bf21b84b21474131ffed5}{m\_queueDiscs}.push\_back (qDisc);
71 \}
\end{DoxyCode}
\index{ns3\+::\+Queue\+Disc\+Container@{ns3\+::\+Queue\+Disc\+Container}!Begin@{Begin}}
\index{Begin@{Begin}!ns3\+::\+Queue\+Disc\+Container@{ns3\+::\+Queue\+Disc\+Container}}
\subsubsection[{\texorpdfstring{Begin(void) const }{Begin(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Queue\+Disc\+Container\+::\+Const\+Iterator} ns3\+::\+Queue\+Disc\+Container\+::\+Begin (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1QueueDiscContainer_a67517618d43724e04a2cd3c710934014}{}\label{classns3_1_1QueueDiscContainer_a67517618d43724e04a2cd3c710934014}


Get a const iterator which refers to the first \hyperlink{classns3_1_1QueueDisc}{Queue\+Disc} in the container. 

Queue\+Discs can be retrieved from the container in two ways. First, directly by an index into the container, and second, using an iterator. This method is used in the iterator method and is typically used in a for-\/loop to run through the Queue\+Discs


\begin{DoxyCode}
\hyperlink{classns3_1_1QueueDiscContainer_a3c46b3a107b7b15d6b638ae50b5d9b58}{QueueDiscContainer::ConstIterator} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
\textcolor{keywordflow}{for} (i = container.Begin (); i != container.End (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
  \{
    (*i)->method ();  \textcolor{comment}{// some QueueDisc method}
  \}
\end{DoxyCode}


\begin{DoxyReturn}{Returns}
a const iterator which refers to the first \hyperlink{classns3_1_1QueueDisc}{Queue\+Disc} in the container. 
\end{DoxyReturn}

\begin{DoxyCode}
36 \{
37   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1QueueDiscContainer_a1518c7ab608bf21b84b21474131ffed5}{m\_queueDiscs}.begin ();
38 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 3


\index{ns3\+::\+Queue\+Disc\+Container@{ns3\+::\+Queue\+Disc\+Container}!End@{End}}
\index{End@{End}!ns3\+::\+Queue\+Disc\+Container@{ns3\+::\+Queue\+Disc\+Container}}
\subsubsection[{\texorpdfstring{End(void) const }{End(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Queue\+Disc\+Container\+::\+Const\+Iterator} ns3\+::\+Queue\+Disc\+Container\+::\+End (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1QueueDiscContainer_a8b4c3b14d4890bb5fb0e4597e6bf1135}{}\label{classns3_1_1QueueDiscContainer_a8b4c3b14d4890bb5fb0e4597e6bf1135}


Get a const iterator which indicates past-\/the-\/last \hyperlink{classns3_1_1QueueDisc}{Queue\+Disc} in the container. 

Queue\+Discs can be retrieved from the container in two ways. First, directly by an index into the container, and second, using an iterator. This method is used in the iterator method and is typically used in a for-\/loop to run through the Queue\+Discs


\begin{DoxyCode}
\hyperlink{classns3_1_1QueueDiscContainer_a3c46b3a107b7b15d6b638ae50b5d9b58}{QueueDiscContainer::ConstIterator} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
\textcolor{keywordflow}{for} (i = container.Begin (); i != container.End (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
  \{
    (*i)->method ();  \textcolor{comment}{// some QueueDisc method}
  \}
\end{DoxyCode}


\begin{DoxyReturn}{Returns}
a const iterator which indicates an ending condition for a loop. 
\end{DoxyReturn}

\begin{DoxyCode}
42 \{
43   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1QueueDiscContainer_a1518c7ab608bf21b84b21474131ffed5}{m\_queueDiscs}.end ();
44 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::\+Queue\+Disc\+Container@{ns3\+::\+Queue\+Disc\+Container}!Get@{Get}}
\index{Get@{Get}!ns3\+::\+Queue\+Disc\+Container@{ns3\+::\+Queue\+Disc\+Container}}
\subsubsection[{\texorpdfstring{Get(uint32\+\_\+t i) const }{Get(uint32_t i) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Queue\+Disc} $>$ ns3\+::\+Queue\+Disc\+Container\+::\+Get (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1QueueDiscContainer_a236064f6321b5f0d32561bb2a14e74af}{}\label{classns3_1_1QueueDiscContainer_a236064f6321b5f0d32561bb2a14e74af}


Get the Ptr$<$\+Queue\+Disc$>$ stored in this container at a given index. 

Queue\+Discs can be retrieved from the container in two ways. First, directly by an index into the container, and second, using an iterator. This method is used in the direct method and is used to retrieve the indexed Ptr$<$\+Queue\+Disc$>$.


\begin{DoxyCode}
uint32\_t nQueueDiscs = container.GetN ();
\textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0 \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < nQueueDiscs; ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
  \{
    Ptr<QueueDisc> p = container.Get (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
    \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->method ();  \textcolor{comment}{// some QueueDisc method}
  \}
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em i} & the index of the requested queue disc pointer. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the requested queue disc pointer. 
\end{DoxyReturn}

\begin{DoxyCode}
54 \{
55   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1QueueDiscContainer_a1518c7ab608bf21b84b21474131ffed5}{m\_queueDiscs}[\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}];
56 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Queue\+Disc\+Container@{ns3\+::\+Queue\+Disc\+Container}!GetN@{GetN}}
\index{GetN@{GetN}!ns3\+::\+Queue\+Disc\+Container@{ns3\+::\+Queue\+Disc\+Container}}
\subsubsection[{\texorpdfstring{Get\+N(void) const }{GetN(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Queue\+Disc\+Container\+::\+GetN (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1QueueDiscContainer_aeacbea464213a3dce96b5551e30a2f3d}{}\label{classns3_1_1QueueDiscContainer_aeacbea464213a3dce96b5551e30a2f3d}


Get the number of Ptr$<$\+Queue\+Disc$>$ stored in this container. 

Queue\+Discs can be retrieved from the container in two ways. First, directly by an index into the container, and second, using an iterator. This method is used in the direct method and is typically used to define an ending condition in a for-\/loop that runs through the stored Queue\+Discs


\begin{DoxyCode}
uint32\_t nQueueDiscs = container.GetN ();
\textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0 \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < nQueueDiscs; ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
  \{
    Ptr<QueueDisc> p = container.Get (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
    \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->method ();  \textcolor{comment}{// some QueueDisc method}
  \}
\end{DoxyCode}


\begin{DoxyReturn}{Returns}
the number of Ptr$<$\+Queue\+Disc$>$ stored in this container. 
\end{DoxyReturn}

\begin{DoxyCode}
48 \{
49   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1QueueDiscContainer_a1518c7ab608bf21b84b21474131ffed5}{m\_queueDiscs}.size ();
50 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{ns3\+::\+Queue\+Disc\+Container@{ns3\+::\+Queue\+Disc\+Container}!m\+\_\+queue\+Discs@{m\+\_\+queue\+Discs}}
\index{m\+\_\+queue\+Discs@{m\+\_\+queue\+Discs}!ns3\+::\+Queue\+Disc\+Container@{ns3\+::\+Queue\+Disc\+Container}}
\subsubsection[{\texorpdfstring{m\+\_\+queue\+Discs}{m_queueDiscs}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<${\bf Ptr}$<${\bf Queue\+Disc}$>$ $>$ ns3\+::\+Queue\+Disc\+Container\+::m\+\_\+queue\+Discs\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1QueueDiscContainer_a1518c7ab608bf21b84b21474131ffed5}{}\label{classns3_1_1QueueDiscContainer_a1518c7ab608bf21b84b21474131ffed5}


Queue\+Discs smart pointers. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
traffic-\/control/helper/\hyperlink{queue-disc-container_8h}{queue-\/disc-\/container.\+h}\item 
traffic-\/control/helper/\hyperlink{queue-disc-container_8cc}{queue-\/disc-\/container.\+cc}\end{DoxyCompactItemize}
