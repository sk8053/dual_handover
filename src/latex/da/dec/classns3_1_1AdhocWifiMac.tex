\hypertarget{classns3_1_1AdhocWifiMac}{}\section{ns3\+:\+:Adhoc\+Wifi\+Mac Class Reference}
\label{classns3_1_1AdhocWifiMac}\index{ns3\+::\+Adhoc\+Wifi\+Mac@{ns3\+::\+Adhoc\+Wifi\+Mac}}


{\ttfamily \#include $<$adhoc-\/wifi-\/mac.\+h$>$}



Inheritance diagram for ns3\+:\+:Adhoc\+Wifi\+Mac\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Adhoc\+Wifi\+Mac\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1AdhocWifiMac_a3f863c5a1bee28a2843dc9a832a9d45f}{Adhoc\+Wifi\+Mac} ()
\item 
virtual \hyperlink{classns3_1_1AdhocWifiMac_ad85c44728fc9d8d14245eb2bd68553f5}{$\sim$\+Adhoc\+Wifi\+Mac} ()
\item 
void \hyperlink{classns3_1_1AdhocWifiMac_ac25794fcd3862b3bbd0147705c7b0df8}{Set\+Address} (\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} address)
\item 
void \hyperlink{classns3_1_1AdhocWifiMac_a22a0b2919b8fab54e736a113cea2b2ea}{Set\+Link\+Up\+Callback} (\hyperlink{classns3_1_1Callback}{Callback}$<$ void $>$ link\+Up)
\item 
void \hyperlink{classns3_1_1AdhocWifiMac_a743d39d87f61965d34d41292b0650b87}{Enqueue} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} to)
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1AdhocWifiMac_ae6979b019458583eeafb0cb504e73f38}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classns3_1_1AdhocWifiMac_a5abc017d64f109b0599e9cc123cbfeb8}{Receive} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, const \hyperlink{classns3_1_1WifiMacHeader}{Wifi\+Mac\+Header} $\ast$hdr)
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Adhoc\+Wifi\+Mac@{ns3\+::\+Adhoc\+Wifi\+Mac}!Adhoc\+Wifi\+Mac@{Adhoc\+Wifi\+Mac}}
\index{Adhoc\+Wifi\+Mac@{Adhoc\+Wifi\+Mac}!ns3\+::\+Adhoc\+Wifi\+Mac@{ns3\+::\+Adhoc\+Wifi\+Mac}}
\subsubsection[{\texorpdfstring{Adhoc\+Wifi\+Mac()}{AdhocWifiMac()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Adhoc\+Wifi\+Mac\+::\+Adhoc\+Wifi\+Mac (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1AdhocWifiMac_a3f863c5a1bee28a2843dc9a832a9d45f}{}\label{classns3_1_1AdhocWifiMac_a3f863c5a1bee28a2843dc9a832a9d45f}

\begin{DoxyCode}
45 \{
46   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
47   \textcolor{comment}{//Let the lower layers know that we are acting in an IBSS}
48   \hyperlink{classns3_1_1RegularWifiMac_ab388733458378c0cbf456d0368eee723}{SetTypeOfStation} (\hyperlink{namespacens3_a21fd18ff410cecc971a0c27634830445a255dea8136dbcf713e232f83d81204a9}{ADHOC\_STA});
49 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Adhoc\+Wifi\+Mac@{ns3\+::\+Adhoc\+Wifi\+Mac}!````~Adhoc\+Wifi\+Mac@{$\sim$\+Adhoc\+Wifi\+Mac}}
\index{````~Adhoc\+Wifi\+Mac@{$\sim$\+Adhoc\+Wifi\+Mac}!ns3\+::\+Adhoc\+Wifi\+Mac@{ns3\+::\+Adhoc\+Wifi\+Mac}}
\subsubsection[{\texorpdfstring{$\sim$\+Adhoc\+Wifi\+Mac()}{~AdhocWifiMac()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Adhoc\+Wifi\+Mac\+::$\sim$\+Adhoc\+Wifi\+Mac (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1AdhocWifiMac_ad85c44728fc9d8d14245eb2bd68553f5}{}\label{classns3_1_1AdhocWifiMac_ad85c44728fc9d8d14245eb2bd68553f5}

\begin{DoxyCode}
52 \{
53   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
54 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Adhoc\+Wifi\+Mac@{ns3\+::\+Adhoc\+Wifi\+Mac}!Enqueue@{Enqueue}}
\index{Enqueue@{Enqueue}!ns3\+::\+Adhoc\+Wifi\+Mac@{ns3\+::\+Adhoc\+Wifi\+Mac}}
\subsubsection[{\texorpdfstring{Enqueue(\+Ptr$<$ const Packet $>$ packet, Mac48\+Address to)}{Enqueue(Ptr< const Packet > packet, Mac48Address to)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Adhoc\+Wifi\+Mac\+::\+Enqueue (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{packet, }
\item[{{\bf Mac48\+Address}}]{to}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1AdhocWifiMac_a743d39d87f61965d34d41292b0650b87}{}\label{classns3_1_1AdhocWifiMac_a743d39d87f61965d34d41292b0650b87}

\begin{DoxyParams}{Parameters}
{\em packet} & the packet to send. \\
\hline
{\em to} & the address to which the packet should be sent.\\
\hline
\end{DoxyParams}
The packet should be enqueued in a tx queue, and should be dequeued as soon as the channel access function determines that access is granted to this M\+AC. 

Implements \hyperlink{classns3_1_1RegularWifiMac_a646c2c6e87a90501f5688dfbde765bb7}{ns3\+::\+Regular\+Wifi\+Mac}.


\begin{DoxyCode}
72 \{
73   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << to);
74   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1RegularWifiMac_a76d1a5e27b64bfe36f24a55d1eea2775}{m\_stationManager}->\hyperlink{classns3_1_1WifiRemoteStationManager_a7545940536c6520140bc7ff44b952d5d}{IsBrandNew} (to))
75     \{
76       \textcolor{comment}{//In ad hoc mode, we assume that every destination supports all}
77       \textcolor{comment}{//the rates we support.}
78       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1RegularWifiMac_a8950c44b8cf2ad1f9274821cf88adc7b}{m\_htSupported} || \hyperlink{classns3_1_1RegularWifiMac_a151f330fdeb3f83f9ec7cf07537f0e86}{m\_vhtSupported})
79         \{
80           \hyperlink{classns3_1_1RegularWifiMac_a76d1a5e27b64bfe36f24a55d1eea2775}{m\_stationManager}->\hyperlink{classns3_1_1WifiRemoteStationManager_a284f2ff0fb0cde5c8b08a3671712de58}{AddAllSupportedMcs} (to);
81           \hyperlink{classns3_1_1RegularWifiMac_a76d1a5e27b64bfe36f24a55d1eea2775}{m\_stationManager}->\hyperlink{classns3_1_1WifiRemoteStationManager_ae78d843a98a66ff2d8584da8ed189b4d}{AddStationHtCapabilities} (to, 
      \hyperlink{classns3_1_1RegularWifiMac_ae2b0a52735a938a0f1ca233397ae2185}{GetHtCapabilities}());
82         \}
83       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1RegularWifiMac_a151f330fdeb3f83f9ec7cf07537f0e86}{m\_vhtSupported})
84         \{
85           \hyperlink{classns3_1_1RegularWifiMac_a76d1a5e27b64bfe36f24a55d1eea2775}{m\_stationManager}->\hyperlink{classns3_1_1WifiRemoteStationManager_a52b9e283f99e113cba95afbc2acea72b}{AddStationVhtCapabilities} (to, 
      \hyperlink{classns3_1_1RegularWifiMac_ade487870f5663694d30a2dd6a7e614e8}{GetVhtCapabilities}());
86         \}
87       \hyperlink{classns3_1_1RegularWifiMac_a76d1a5e27b64bfe36f24a55d1eea2775}{m\_stationManager}->\hyperlink{classns3_1_1WifiRemoteStationManager_a4820bca619f254af7ff3ea2990563dbe}{AddAllSupportedModes} (to);
88       \hyperlink{classns3_1_1RegularWifiMac_a76d1a5e27b64bfe36f24a55d1eea2775}{m\_stationManager}->\hyperlink{classns3_1_1WifiRemoteStationManager_abcb92c63342aed2603c1dfb131e0fe8a}{RecordDisassociated} (to);
89     \}
90 
91   WifiMacHeader hdr;
92 
93   \textcolor{comment}{//If we are not a QoS STA then we definitely want to use AC\_BE to}
94   \textcolor{comment}{//transmit the packet. A TID of zero will map to AC\_BE (through \(\backslash\)c}
95   \textcolor{comment}{//QosUtilsMapTidToAc()), so we use that as our default here.}
96   uint8\_t tid = 0;
97 
98   \textcolor{comment}{//For now, a STA that supports QoS does not support non-QoS}
99   \textcolor{comment}{//associations, and vice versa. In future the STA model should fall}
100   \textcolor{comment}{//back to non-QoS if talking to a peer that is also non-QoS. At}
101   \textcolor{comment}{//that point there will need to be per-station QoS state maintained}
102   \textcolor{comment}{//by the association state machine, and consulted here.}
103   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1RegularWifiMac_aeecdb918687493a8efdd70304bc0cee9}{m\_qosSupported})
104     \{
105       hdr.SetType (\hyperlink{namespacens3_a9318472db39b35b2092de5c721e6ab0aafd37aea1ac3edba5410fac6367b19b1d}{WIFI\_MAC\_QOSDATA});
106       hdr.SetQosAckPolicy (\hyperlink{classns3_1_1WifiMacHeader_ae3a382482f357972019f5e1b3162adc4a9f52b9c6ca65d046ce2be9d70bce28cf}{WifiMacHeader::NORMAL\_ACK});
107       hdr.SetQosNoEosp ();
108       hdr.SetQosNoAmsdu ();
109       \textcolor{comment}{//Transmission of multiple frames in the same TXOP is not}
110       \textcolor{comment}{//supported for now}
111       hdr.SetQosTxopLimit (0);
112 
113       \textcolor{comment}{//Fill in the QoS control field in the MAC header}
114       tid = \hyperlink{group__wifi_gaa7ad20082f78b63633d0557d24927150}{QosUtilsGetTidForPacket} (packet);
115       \textcolor{comment}{//Any value greater than 7 is invalid and likely indicates that}
116       \textcolor{comment}{//the packet had no QoS tag, so we revert to zero, which will}
117       \textcolor{comment}{//mean that AC\_BE is used.}
118       \textcolor{keywordflow}{if} (tid > 7)
119         \{
120           tid = 0;
121         \}
122       hdr.SetQosTid (tid);
123     \}
124   \textcolor{keywordflow}{else}
125     \{
126       hdr.SetTypeData ();
127     \}
128 
129   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1RegularWifiMac_a8950c44b8cf2ad1f9274821cf88adc7b}{m\_htSupported} || \hyperlink{classns3_1_1RegularWifiMac_a151f330fdeb3f83f9ec7cf07537f0e86}{m\_vhtSupported})
130     \{
131       hdr.SetNoOrder ();
132     \}
133   hdr.SetAddr1 (to);
134   hdr.SetAddr2 (\hyperlink{classns3_1_1RegularWifiMac_a726ce0ade9bb7e6b7d81cd397f32dbde}{m\_low}->\hyperlink{classns3_1_1MacLow_a109922d4f2bb1ee0b2a66aa3bcc48e2f}{GetAddress} ());
135   hdr.SetAddr3 (\hyperlink{classns3_1_1RegularWifiMac_acd1705832e3f4a235c2ca6a84b5a577b}{GetBssid} ());
136   hdr.SetDsNotFrom ();
137   hdr.SetDsNotTo ();
138 
139   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1RegularWifiMac_aeecdb918687493a8efdd70304bc0cee9}{m\_qosSupported})
140     \{
141       \textcolor{comment}{//Sanity check that the TID is valid}
142       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (tid < 8);
143       \hyperlink{classns3_1_1RegularWifiMac_ac750365ab3708902cc0b7700164c706d}{m\_edca}[\hyperlink{group__wifi_ga4e36efcff6dd83eaee42e1af0de43d48}{QosUtilsMapTidToAc} (tid)]->Queue (packet, hdr);
144     \}
145   \textcolor{keywordflow}{else}
146     \{
147       \hyperlink{classns3_1_1RegularWifiMac_a152965c3def1a308b088b37c2c88a1a2}{m\_dca}->Queue (packet, hdr);
148     \}
149 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::\+Adhoc\+Wifi\+Mac@{ns3\+::\+Adhoc\+Wifi\+Mac}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Adhoc\+Wifi\+Mac@{ns3\+::\+Adhoc\+Wifi\+Mac}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Adhoc\+Wifi\+Mac\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1AdhocWifiMac_ae6979b019458583eeafb0cb504e73f38}{}\label{classns3_1_1AdhocWifiMac_ae6979b019458583eeafb0cb504e73f38}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
35 \{
36   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::AdhocWifiMac"})
37     .SetParent<\hyperlink{classns3_1_1RegularWifiMac_a56bc0e2b8ecde6fc50e6f8921ce64957}{RegularWifiMac}> ()
38     .SetGroupName (\textcolor{stringliteral}{"Wifi"})
39     .AddConstructor<\hyperlink{classns3_1_1AdhocWifiMac_a3f863c5a1bee28a2843dc9a832a9d45f}{AdhocWifiMac}> ()
40   ;
41   \textcolor{keywordflow}{return} tid;
42 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4


\index{ns3\+::\+Adhoc\+Wifi\+Mac@{ns3\+::\+Adhoc\+Wifi\+Mac}!Receive@{Receive}}
\index{Receive@{Receive}!ns3\+::\+Adhoc\+Wifi\+Mac@{ns3\+::\+Adhoc\+Wifi\+Mac}}
\subsubsection[{\texorpdfstring{Receive(\+Ptr$<$ Packet $>$ packet, const Wifi\+Mac\+Header $\ast$hdr)}{Receive(Ptr< Packet > packet, const WifiMacHeader *hdr)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Adhoc\+Wifi\+Mac\+::\+Receive (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{const {\bf Wifi\+Mac\+Header} $\ast$}]{hdr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1AdhocWifiMac_a5abc017d64f109b0599e9cc123cbfeb8}{}\label{classns3_1_1AdhocWifiMac_a5abc017d64f109b0599e9cc123cbfeb8}
This method acts as the \hyperlink{classns3_1_1MacRxMiddle}{Mac\+Rx\+Middle} receive callback and is invoked to notify us that a frame has been received. The implementation is intended to capture logic that is going to be common to all (or most) derived classes. Specifically, handling of Block Ack managment frames is dealt with here.

This method will need, however, to be overriden by derived classes so that they can perform their data handling before invoking the base version.


\begin{DoxyParams}{Parameters}
{\em packet} & the packet that has been received. \\
\hline
{\em hdr} & a pointer to the M\+AC header of the received frame. \\
\hline
\end{DoxyParams}


Reimplemented from \hyperlink{classns3_1_1RegularWifiMac_a9abbbcea65b6dc416ab1b44785c40e9f}{ns3\+::\+Regular\+Wifi\+Mac}.


\begin{DoxyCode}
165 \{
166   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << hdr);
167   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (!hdr->IsCtl ());
168   Mac48Address \hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from} = hdr->GetAddr2 ();
169   Mac48Address to = hdr->GetAddr1 ();
170   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1RegularWifiMac_a76d1a5e27b64bfe36f24a55d1eea2775}{m\_stationManager}->\hyperlink{classns3_1_1WifiRemoteStationManager_a7545940536c6520140bc7ff44b952d5d}{IsBrandNew} (from))
171     \{
172       \textcolor{comment}{//In ad hoc mode, we assume that every destination supports all}
173       \textcolor{comment}{//the rates we support.}
174       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1RegularWifiMac_a8950c44b8cf2ad1f9274821cf88adc7b}{m\_htSupported} || \hyperlink{classns3_1_1RegularWifiMac_a151f330fdeb3f83f9ec7cf07537f0e86}{m\_vhtSupported})
175         \{
176           \hyperlink{classns3_1_1RegularWifiMac_a76d1a5e27b64bfe36f24a55d1eea2775}{m\_stationManager}->\hyperlink{classns3_1_1WifiRemoteStationManager_a284f2ff0fb0cde5c8b08a3671712de58}{AddAllSupportedMcs} (from);
177           \hyperlink{classns3_1_1RegularWifiMac_a76d1a5e27b64bfe36f24a55d1eea2775}{m\_stationManager}->\hyperlink{classns3_1_1WifiRemoteStationManager_ae78d843a98a66ff2d8584da8ed189b4d}{AddStationHtCapabilities} (from, 
      \hyperlink{classns3_1_1RegularWifiMac_ae2b0a52735a938a0f1ca233397ae2185}{GetHtCapabilities}());
178         \}
179       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1RegularWifiMac_a151f330fdeb3f83f9ec7cf07537f0e86}{m\_vhtSupported})
180         \{
181           \hyperlink{classns3_1_1RegularWifiMac_a76d1a5e27b64bfe36f24a55d1eea2775}{m\_stationManager}->\hyperlink{classns3_1_1WifiRemoteStationManager_a52b9e283f99e113cba95afbc2acea72b}{AddStationVhtCapabilities} (from, 
      \hyperlink{classns3_1_1RegularWifiMac_ade487870f5663694d30a2dd6a7e614e8}{GetVhtCapabilities}());
182         \}
183       \hyperlink{classns3_1_1RegularWifiMac_a76d1a5e27b64bfe36f24a55d1eea2775}{m\_stationManager}->\hyperlink{classns3_1_1WifiRemoteStationManager_a4820bca619f254af7ff3ea2990563dbe}{AddAllSupportedModes} (from);
184       \hyperlink{classns3_1_1RegularWifiMac_a76d1a5e27b64bfe36f24a55d1eea2775}{m\_stationManager}->\hyperlink{classns3_1_1WifiRemoteStationManager_abcb92c63342aed2603c1dfb131e0fe8a}{RecordDisassociated} (from);
185     \}
186   \textcolor{keywordflow}{if} (hdr->IsData ())
187     \{
188       \textcolor{keywordflow}{if} (hdr->IsQosData () && hdr->IsQosAmsdu ())
189         \{
190           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Received A-MSDU from"} << from);
191           \hyperlink{classns3_1_1RegularWifiMac_a21621ca70e5d272de72d0609eb43cf15}{DeaggregateAmsduAndForward} (packet, hdr);
192         \}
193       \textcolor{keywordflow}{else}
194         \{
195           \hyperlink{classns3_1_1RegularWifiMac_a34df292af97e69fefda8303cdb323d1d}{ForwardUp} (packet, from, to);
196         \}
197       \textcolor{keywordflow}{return};
198     \}
199 
200   \textcolor{comment}{//Invoke the receive handler of our parent class to deal with any}
201   \textcolor{comment}{//other frames. Specifically, this will handle Block Ack-related}
202   \textcolor{comment}{//Management Action frames.}
203   \hyperlink{classns3_1_1RegularWifiMac_a9abbbcea65b6dc416ab1b44785c40e9f}{RegularWifiMac::Receive} (packet, hdr);
204 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5


\index{ns3\+::\+Adhoc\+Wifi\+Mac@{ns3\+::\+Adhoc\+Wifi\+Mac}!Set\+Address@{Set\+Address}}
\index{Set\+Address@{Set\+Address}!ns3\+::\+Adhoc\+Wifi\+Mac@{ns3\+::\+Adhoc\+Wifi\+Mac}}
\subsubsection[{\texorpdfstring{Set\+Address(\+Mac48\+Address address)}{SetAddress(Mac48Address address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Adhoc\+Wifi\+Mac\+::\+Set\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Mac48\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1AdhocWifiMac_ac25794fcd3862b3bbd0147705c7b0df8}{}\label{classns3_1_1AdhocWifiMac_ac25794fcd3862b3bbd0147705c7b0df8}

\begin{DoxyParams}{Parameters}
{\em address} & the current address of this M\+AC layer. \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1WifiMac_acb910dff0196a6ddc27efd106efa1f3a}{ns3\+::\+Wifi\+Mac}.


\begin{DoxyCode}
58 \{
59   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << address);
60   \textcolor{comment}{//In an IBSS, the BSSID is supposed to be generated per Section}
61   \textcolor{comment}{//11.1.3 of IEEE 802.11. We don't currently do this - instead we}
62   \textcolor{comment}{//make an IBSS STA a bit like an AP, with the BSSID for frames}
63   \textcolor{comment}{//transmitted by each STA set to that STA's address.}
64   \textcolor{comment}{//}
65   \textcolor{comment}{//This is why we're overriding this method.}
66   \hyperlink{classns3_1_1RegularWifiMac_a71265ac4dff0a65208bed95af4031391}{RegularWifiMac::SetAddress} (address);
67   \hyperlink{classns3_1_1RegularWifiMac_a24af45a5447f736b996a48a0db584e99}{RegularWifiMac::SetBssid} (address);
68 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6


\index{ns3\+::\+Adhoc\+Wifi\+Mac@{ns3\+::\+Adhoc\+Wifi\+Mac}!Set\+Link\+Up\+Callback@{Set\+Link\+Up\+Callback}}
\index{Set\+Link\+Up\+Callback@{Set\+Link\+Up\+Callback}!ns3\+::\+Adhoc\+Wifi\+Mac@{ns3\+::\+Adhoc\+Wifi\+Mac}}
\subsubsection[{\texorpdfstring{Set\+Link\+Up\+Callback(\+Callback$<$ void $>$ link\+Up)}{SetLinkUpCallback(Callback< void > linkUp)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Adhoc\+Wifi\+Mac\+::\+Set\+Link\+Up\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Callback}$<$ void $>$}]{link\+Up}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1AdhocWifiMac_a22a0b2919b8fab54e736a113cea2b2ea}{}\label{classns3_1_1AdhocWifiMac_a22a0b2919b8fab54e736a113cea2b2ea}

\begin{DoxyParams}{Parameters}
{\em link\+Up} & the callback to invoke when the link becomes up. \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1WifiMac_a7216f476412946276b93e413c13eca72}{ns3\+::\+Wifi\+Mac}.


\begin{DoxyCode}
153 \{
154   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << &linkUp);
155   \hyperlink{classns3_1_1RegularWifiMac_a093dd2e9fcca0c14998b2f551fa0e4e8}{RegularWifiMac::SetLinkUpCallback} (linkUp);
156 
157   \textcolor{comment}{//The approach taken here is that, from the point of view of a STA}
158   \textcolor{comment}{//in IBSS mode, the link is always up, so we immediately invoke the}
159   \textcolor{comment}{//callback if one is set}
160   linkUp ();
161 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7




The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
wifi/model/\hyperlink{adhoc-wifi-mac_8h}{adhoc-\/wifi-\/mac.\+h}\item 
wifi/model/\hyperlink{adhoc-wifi-mac_8cc}{adhoc-\/wifi-\/mac.\+cc}\end{DoxyCompactItemize}
