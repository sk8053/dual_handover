\hypertarget{classns3_1_1MmWave3gppChannel}{}\section{ns3\+:\+:Mm\+Wave3gpp\+Channel Class Reference}
\label{classns3_1_1MmWave3gppChannel}\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}


This class implements the fading computation of the 3\+G\+PP TR 38.\+900 channel model and performs the beamforming gain computation. It implements the \hyperlink{classns3_1_1SpectrumPropagationLossModel}{Spectrum\+Propagation\+Loss\+Model} interface.  




{\ttfamily \#include $<$mmwave-\/3gpp-\/channel.\+h$>$}



Inheritance diagram for ns3\+:\+:Mm\+Wave3gpp\+Channel\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Mm\+Wave3gpp\+Channel\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1MmWave3gppChannel_afdbee5420922706062627b16b492fe14}{Mm\+Wave3gpp\+Channel} ()
\item 
virtual \hyperlink{classns3_1_1MmWave3gppChannel_a8eabd72db5f2efe7955d07bfa01dbeed}{$\sim$\+Mm\+Wave3gpp\+Channel} ()
\item 
void \hyperlink{classns3_1_1MmWave3gppChannel_a04d461e913a8f5a00854c3bc9db6dce3}{Do\+Dispose} ()
\item 
void \hyperlink{classns3_1_1MmWave3gppChannel_ad2a4b9738d3630c1363eee2f7a34f68e}{Connect\+Devices} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ dev1, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ dev2)
\item 
void \hyperlink{classns3_1_1MmWave3gppChannel_ad51205a072737028520bb1bf7d255050}{Initial} (\hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} ue\+Devices, \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} enb\+Devices)
\item 
void \hyperlink{classns3_1_1MmWave3gppChannel_a47452fa275fee0e056f646379ccc9288}{Set\+Beamforming\+Vector} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ ue\+Device, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ enb\+Device)
\item 
void \hyperlink{classns3_1_1MmWave3gppChannel_a18aeca33b5a09843d342fc3abb5abf68}{Set\+Configuration\+Parameters} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1MmWavePhyMacCommon}{Mm\+Wave\+Phy\+Mac\+Common} $>$ ptr\+Config)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1MmWavePhyMacCommon}{Mm\+Wave\+Phy\+Mac\+Common} $>$ \hyperlink{classns3_1_1MmWave3gppChannel_a8ba423399c2109b66c4d63b201ae5794}{Get\+Configuration\+Parameters} (void) const 
\item 
void \hyperlink{classns3_1_1MmWave3gppChannel_a01b18ad10ea2cf6acd7ee23d53eba3fc}{Set\+Pathloss\+Model} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1PropagationLossModel}{Propagation\+Loss\+Model} $>$ pathloss)
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1MmWave3gppChannel_a63160d27a5d036e62b48eb81e374ee18}{Get\+Type\+Id} (void)
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classns3_1_1MmWave3gppChannel_a5b921c4b6e89174bf383382c1ce6523f}{is\+Additional\+Mm\+Wave\+Phy} =\hyperlink{lte__cqi__generation_8m_ab1bef239d413c4da139c4bac92cd657a}{false}
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1SpectrumValue}{Spectrum\+Value} $>$ \hyperlink{classns3_1_1MmWave3gppChannel_a598876f469ba922150b9d9b86e160ca0}{Do\+Calc\+Rx\+Power\+Spectral\+Density} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1SpectrumValue}{Spectrum\+Value} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_a684fe3101a5e48a5fcc57cab8dbcd1aa}{tx\+Psd}, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1MobilityModel}{Mobility\+Model} $>$ a, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1MobilityModel}{Mobility\+Model} $>$ \hyperlink{lte__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b}) const 
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{structns3_1_1Params3gpp}{Params3gpp} $>$ \hyperlink{classns3_1_1MmWave3gppChannel_aef5bd6982d739715d7bbba3166e75116}{Get\+New\+Channel} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{structns3_1_1ParamsTable}{Params\+Table} $>$ table3gpp, Vector loc\+UT, bool los, bool o2i, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1AntennaArrayModel}{Antenna\+Array\+Model} $>$ tx\+Antenna, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1AntennaArrayModel}{Antenna\+Array\+Model} $>$ rx\+Antenna, uint8\+\_\+t $\ast$tx\+Antenna\+Num, uint8\+\_\+t $\ast$rx\+Antenna\+Num, \hyperlink{structns3_1_1Angles}{Angles} \&rx\+Angle, \hyperlink{structns3_1_1Angles}{Angles} \&tx\+Angle, Vector \hyperlink{mmwave-amc-test_8cc_a6dc6e6f3c75c509ce943163afb5dade7}{speed}, double dis2D, double dis3D) const 
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{structns3_1_1Params3gpp}{Params3gpp} $>$ \hyperlink{classns3_1_1MmWave3gppChannel_a765f45f9d98c15655c8ea6288e86f111}{Update\+Channel} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{structns3_1_1Params3gpp}{Params3gpp} $>$ params3gpp, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{structns3_1_1ParamsTable}{Params\+Table} $>$ table3gpp, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1AntennaArrayModel}{Antenna\+Array\+Model} $>$ tx\+Antenna, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1AntennaArrayModel}{Antenna\+Array\+Model} $>$ rx\+Antenna, uint8\+\_\+t $\ast$tx\+Antenna\+Num, uint8\+\_\+t $\ast$rx\+Antenna\+Num, \hyperlink{structns3_1_1Angles}{Angles} \&rx\+Angle, \hyperlink{structns3_1_1Angles}{Angles} \&tx\+Angle) const 
\item 
void \hyperlink{classns3_1_1MmWave3gppChannel_a1ef519a7796d45ef5270e465664fd1bb}{Long\+Term\+Cov\+Matrix\+Beamforming} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{structns3_1_1Params3gpp}{Params3gpp} $>$ params) const 
\item 
void \hyperlink{classns3_1_1MmWave3gppChannel_ac361c14154934a6e7633a0a8c561e788}{Beam\+Search\+Beamforming} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1SpectrumValue}{Spectrum\+Value} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_a684fe3101a5e48a5fcc57cab8dbcd1aa}{tx\+Psd}, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{structns3_1_1Params3gpp}{Params3gpp} $>$ params, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1AntennaArrayModel}{Antenna\+Array\+Model} $>$ tx\+Antenna, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1AntennaArrayModel}{Antenna\+Array\+Model} $>$ rx\+Antenna, uint8\+\_\+t $\ast$tx\+Antenna\+Num, uint8\+\_\+t $\ast$rx\+Antenna\+Num) const 
\item 
void \hyperlink{classns3_1_1MmWave3gppChannel_ab1cacdfc31ed5b10bc2dc5206153ec57}{Cal\+Long\+Term} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{structns3_1_1Params3gpp}{Params3gpp} $>$ params) const 
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1SpectrumValue}{Spectrum\+Value} $>$ \hyperlink{classns3_1_1MmWave3gppChannel_acd8bc1db086ba52b0e77ed71a6ccb56d}{Cal\+Beamforming\+Gain} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1SpectrumValue}{Spectrum\+Value} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_a684fe3101a5e48a5fcc57cab8dbcd1aa}{tx\+Psd}, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{structns3_1_1Params3gpp}{Params3gpp} $>$ params, Vector \hyperlink{mmwave-amc-test_8cc_a6dc6e6f3c75c509ce943163afb5dade7}{speed}) const 
\item 
double \hyperlink{classns3_1_1MmWave3gppChannel_aff34062721c2775f51890cbf23702d99}{Get\+System\+Bandwidth} () const 
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{structns3_1_1ParamsTable}{Params\+Table} $>$ \hyperlink{classns3_1_1MmWave3gppChannel_a4d31cc933c700d3b6c405b47765a2b02}{Get3gpp\+Table} (bool los, bool o2i, double h\+BS, double h\+UT, double distance2D) const 
\item 
void \hyperlink{classns3_1_1MmWave3gppChannel_a3ec4e2d8d84d7876581a00fa5174a1a5}{Delete\+Channel} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1MobilityModel}{Mobility\+Model} $>$ a, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1MobilityModel}{Mobility\+Model} $>$ \hyperlink{lte__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b}) const 
\item 
\hyperlink{namespacens3_aa6f1edf6566ca6afec613bc6e40240ea}{double\+Vector\+\_\+t} \hyperlink{classns3_1_1MmWave3gppChannel_aff8853ed48d4aeb1a5d4960a843f5f1a}{Cal\+Attenuation\+Of\+Blockage} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{structns3_1_1Params3gpp}{Params3gpp} $>$ params, \hyperlink{namespacens3_aa6f1edf6566ca6afec613bc6e40240ea}{double\+Vector\+\_\+t} cluster\+A\+OA, \hyperlink{namespacens3_aa6f1edf6566ca6afec613bc6e40240ea}{double\+Vector\+\_\+t} cluster\+Z\+OA) const 
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::map$<$ \hyperlink{namespacens3_aa42bd408e172586b3b192acfaa36b070}{key\+\_\+t}, int $>$ \hyperlink{classns3_1_1MmWave3gppChannel_a43ad5b64f557a59c929fa49f3600fd9f}{m\+\_\+connected\+Pair}
\item 
std\+::map$<$ \hyperlink{namespacens3_aa42bd408e172586b3b192acfaa36b070}{key\+\_\+t}, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{structns3_1_1Params3gpp}{Params3gpp} $>$ $>$ \hyperlink{classns3_1_1MmWave3gppChannel_a31f05f0c8a438b8ce89f29813e863040}{m\+\_\+channel\+Map}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UniformRandomVariable}{Uniform\+Random\+Variable} $>$ \hyperlink{classns3_1_1MmWave3gppChannel_ac6493e4d80b717378e74a63d418f8c6f}{m\+\_\+uniform\+Rv}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UniformRandomVariable}{Uniform\+Random\+Variable} $>$ \hyperlink{classns3_1_1MmWave3gppChannel_a5afa026ce58c8b70c81c846bb7b49b4f}{m\+\_\+uniform\+Rv\+Blockage}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NormalRandomVariable}{Normal\+Random\+Variable} $>$ \hyperlink{classns3_1_1MmWave3gppChannel_ac2e02ebacc72ed96518d785f2dc87c57}{m\+\_\+normal\+Rv}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NormalRandomVariable}{Normal\+Random\+Variable} $>$ \hyperlink{classns3_1_1MmWave3gppChannel_a51e89a0f3902e6e377705871c479cf36}{m\+\_\+normal\+Rv\+Blockage}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1ExponentialRandomVariable}{Exponential\+Random\+Variable} $>$ \hyperlink{classns3_1_1MmWave3gppChannel_a139990a80eb5ae26045b434c0eb75ae4}{m\+\_\+exp\+Rv}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1MmWavePhyMacCommon}{Mm\+Wave\+Phy\+Mac\+Common} $>$ \hyperlink{classns3_1_1MmWave3gppChannel_a50988766af948ea236ce24718a6dca7d}{m\+\_\+phy\+Mac\+Config}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1PropagationLossModel}{Propagation\+Loss\+Model} $>$ \hyperlink{classns3_1_1MmWave3gppChannel_add8860051acacb1819be2f7321dbd726}{m\+\_\+3gpp\+Pathloss}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{structns3_1_1ParamsTable}{Params\+Table} $>$ \hyperlink{classns3_1_1MmWave3gppChannel_a463c1cc6d34730bbdebdd593f374914b}{m\+\_\+table3gpp}
\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1MmWave3gppChannel_a2844f8c7e7373cb777384eaf0e8a7b11}{m\+\_\+update\+Period}
\item 
bool \hyperlink{classns3_1_1MmWave3gppChannel_ac973f52321b6843ce42f036620af63e8}{m\+\_\+cell\+Scan}
\item 
bool \hyperlink{classns3_1_1MmWave3gppChannel_a5f19d0ed379e7db9448f4f668e0c7927}{m\+\_\+blockage}
\item 
uint16\+\_\+t \hyperlink{classns3_1_1MmWave3gppChannel_addfe5e6c9d8e2531fe165ff86461d2d3}{m\+\_\+num\+Non\+Self\+Bloking}
\item 
bool \hyperlink{classns3_1_1MmWave3gppChannel_a013ed012d87114993312ccfd172fe377}{m\+\_\+portrait\+Mode}
\item 
std\+::string \hyperlink{classns3_1_1MmWave3gppChannel_ae1f263fbc87682905d563221343e4447}{m\+\_\+scenario}
\item 
double \hyperlink{classns3_1_1MmWave3gppChannel_a5d7b7b759283cdf9a6781571e9eeca25}{m\+\_\+blocker\+Speed}
\item 
bool \hyperlink{classns3_1_1MmWave3gppChannel_a2d5a32e24f0d795c5ed210f8c38f4e9b}{m\+\_\+force\+Initial\+Bf\+Computation}
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
This class implements the fading computation of the 3\+G\+PP TR 38.\+900 channel model and performs the beamforming gain computation. It implements the \hyperlink{classns3_1_1SpectrumPropagationLossModel}{Spectrum\+Propagation\+Loss\+Model} interface. 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!Mm\+Wave3gpp\+Channel@{Mm\+Wave3gpp\+Channel}}
\index{Mm\+Wave3gpp\+Channel@{Mm\+Wave3gpp\+Channel}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{Mm\+Wave3gpp\+Channel()}{MmWave3gppChannel()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Mm\+Wave3gpp\+Channel\+::\+Mm\+Wave3gpp\+Channel (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1MmWave3gppChannel_afdbee5420922706062627b16b492fe14}{}\label{classns3_1_1MmWave3gppChannel_afdbee5420922706062627b16b492fe14}
Constructor 
\begin{DoxyCode}
163 \{
164         \hyperlink{classns3_1_1MmWave3gppChannel_ac6493e4d80b717378e74a63d418f8c6f}{m\_uniformRv} = CreateObject<UniformRandomVariable> ();
165         \hyperlink{classns3_1_1MmWave3gppChannel_a5afa026ce58c8b70c81c846bb7b49b4f}{m\_uniformRvBlockage} = CreateObject<UniformRandomVariable> ();
166         \hyperlink{classns3_1_1MmWave3gppChannel_a139990a80eb5ae26045b434c0eb75ae4}{m\_expRv} = CreateObject<ExponentialRandomVariable> ();
167         \hyperlink{classns3_1_1MmWave3gppChannel_ac2e02ebacc72ed96518d785f2dc87c57}{m\_normalRv} = CreateObject<NormalRandomVariable> ();
168         m\_normalRv->\hyperlink{classns3_1_1ObjectBase_ac60245d3ea4123bbc9b1d391f1f6592f}{SetAttribute} (\textcolor{stringliteral}{"Mean"}, DoubleValue (0));
169         m\_normalRv->SetAttribute (\textcolor{stringliteral}{"Variance"}, DoubleValue (1));
170         \hyperlink{classns3_1_1MmWave3gppChannel_a51e89a0f3902e6e377705871c479cf36}{m\_normalRvBlockage} = CreateObject<NormalRandomVariable> ();
171         \hyperlink{classns3_1_1MmWave3gppChannel_a51e89a0f3902e6e377705871c479cf36}{m\_normalRvBlockage}->\hyperlink{classns3_1_1ObjectBase_ac60245d3ea4123bbc9b1d391f1f6592f}{SetAttribute} (\textcolor{stringliteral}{"Mean"}, DoubleValue (0));
172         \hyperlink{classns3_1_1MmWave3gppChannel_a51e89a0f3902e6e377705871c479cf36}{m\_normalRvBlockage}->\hyperlink{classns3_1_1ObjectBase_ac60245d3ea4123bbc9b1d391f1f6592f}{SetAttribute} (\textcolor{stringliteral}{"Variance"}, DoubleValue (1));
173         \hyperlink{classns3_1_1MmWave3gppChannel_a2d5a32e24f0d795c5ed210f8c38f4e9b}{m\_forceInitialBfComputation} = \textcolor{keyword}{false};
174 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!````~Mm\+Wave3gpp\+Channel@{$\sim$\+Mm\+Wave3gpp\+Channel}}
\index{````~Mm\+Wave3gpp\+Channel@{$\sim$\+Mm\+Wave3gpp\+Channel}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{$\sim$\+Mm\+Wave3gpp\+Channel()}{~MmWave3gppChannel()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Mm\+Wave3gpp\+Channel\+::$\sim$\+Mm\+Wave3gpp\+Channel (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MmWave3gppChannel_a8eabd72db5f2efe7955d07bfa01dbeed}{}\label{classns3_1_1MmWave3gppChannel_a8eabd72db5f2efe7955d07bfa01dbeed}
Destructor 
\begin{DoxyCode}
216 \{
217 
218 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!Beam\+Search\+Beamforming@{Beam\+Search\+Beamforming}}
\index{Beam\+Search\+Beamforming@{Beam\+Search\+Beamforming}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{Beam\+Search\+Beamforming(\+Ptr$<$ const Spectrum\+Value $>$ tx\+Psd, Ptr$<$ Params3gpp $>$ params, Ptr$<$ Antenna\+Array\+Model $>$ tx\+Antenna, Ptr$<$ Antenna\+Array\+Model $>$ rx\+Antenna, uint8\+\_\+t $\ast$tx\+Antenna\+Num, uint8\+\_\+t $\ast$rx\+Antenna\+Num) const }{BeamSearchBeamforming(Ptr< const SpectrumValue > txPsd, Ptr< Params3gpp > params, Ptr< AntennaArrayModel > txAntenna, Ptr< AntennaArrayModel > rxAntenna, uint8_t *txAntennaNum, uint8_t *rxAntennaNum) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mm\+Wave3gpp\+Channel\+::\+Beam\+Search\+Beamforming (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Spectrum\+Value} $>$}]{tx\+Psd, }
\item[{{\bf Ptr}$<$ {\bf Params3gpp} $>$}]{params, }
\item[{{\bf Ptr}$<$ {\bf Antenna\+Array\+Model} $>$}]{tx\+Antenna, }
\item[{{\bf Ptr}$<$ {\bf Antenna\+Array\+Model} $>$}]{rx\+Antenna, }
\item[{uint8\+\_\+t $\ast$}]{tx\+Antenna\+Num, }
\item[{uint8\+\_\+t $\ast$}]{rx\+Antenna\+Num}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWave3gppChannel_ac361c14154934a6e7633a0a8c561e788}{}\label{classns3_1_1MmWave3gppChannel_ac361c14154934a6e7633a0a8c561e788}
Scan all sectors with predefined code book and select the one returns maximum gain. The BF vector is stored in the \hyperlink{structns3_1_1Params3gpp}{Params3gpp} object passed as parameter  the channel realizationin as a \hyperlink{structns3_1_1Params3gpp}{Params3gpp} object 
\begin{DoxyCode}
2639 \{
2640         \textcolor{keywordtype}{double} \hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{max} = 0, maxTx = 0, maxRx =0, maxTxTheta=0, maxRxTheta=0;
2641         \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC}(\textcolor{stringliteral}{"BeamSearchBeamforming method at time "} << 
      \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now}().GetSeconds());
2642         \textcolor{keywordflow}{for} (uint16\_t txTheta = 60; txTheta < 121; txTheta=txTheta+10)
2643         \{
2644                 \textcolor{keywordflow}{for}(uint16\_t tx=0; tx<=txAntennaNum[1]; tx++)
2645                 \{
2646                         \textcolor{keywordflow}{for} (uint16\_t rxTheta = 60; rxTheta < 121; rxTheta=rxTheta+10)
2647                         \{
2648                                 \textcolor{keywordflow}{for}(uint16\_t rx=0; rx<=rxAntennaNum[1]; rx++)
2649                                 \{
2650                                         \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC}(\textcolor{stringliteral}{"txTheta "} << txTheta << \textcolor{stringliteral}{" rxTheta "} << 
      rxTheta << \textcolor{stringliteral}{" tx sector "} << 
2651                                                 (M\_PI*(\textcolor{keywordtype}{double})tx/(\textcolor{keywordtype}{double})txAntennaNum[1]-0.5*M\_PI)/(M\_PI)*1
      80 << \textcolor{stringliteral}{" rx sector "} << 
2652                                                 (M\_PI*(\textcolor{keywordtype}{double})rx/(\textcolor{keywordtype}{double})rxAntennaNum[1]-0.5*M\_PI)/(M\_PI)*1
      80);
2653 
2654                                         txAntenna->SetSector(tx, txAntennaNum, txTheta);
2655                                         rxAntenna->SetSector(rx, rxAntennaNum, rxTheta);
2656                                         params->m\_txW = txAntenna->GetBeamformingVector();
2657                                         params->m\_rxW = rxAntenna->GetBeamformingVector();
2658                                         \hyperlink{classns3_1_1MmWave3gppChannel_ab1cacdfc31ed5b10bc2dc5206153ec57}{CalLongTerm}(params);
2659                                         Ptr<SpectrumValue> bfPsd = 
      \hyperlink{classns3_1_1MmWave3gppChannel_acd8bc1db086ba52b0e77ed71a6ccb56d}{CalBeamformingGain}(\hyperlink{lte__link__budget_8m_a684fe3101a5e48a5fcc57cab8dbcd1aa}{txPsd}, params, Vector(0,0,0));
2660 
2661                                         SpectrumValue bfGain = (*bfPsd)/(*txPsd);
2662                                         uint8\_t nbands = bfGain.GetSpectrumModel ()->GetNumBands ();
2663                                         \textcolor{keywordtype}{double} power = \hyperlink{namespacens3_afad5475661952172fe6ef1260360dad8}{Sum} (bfGain)/nbands;
2664 
2665                                         \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC}(\textcolor{stringliteral}{"gain "} << power);
2666                                         \textcolor{keywordflow}{if} (max < power)
2667                                         \{
2668                                                 max = power;
2669                                                 maxTx = tx;
2670                                                 maxRx = rx;
2671                                                 maxTxTheta = txTheta;
2672                                                 maxRxTheta = rxTheta;
2673                                         \}
2674                                 \}
2675                         \}
2676                 \}
2677         \}
2678         \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC}(\textcolor{stringliteral}{"maxTx "} << maxTx << \textcolor{stringliteral}{" txAntennaNum[1] "} << (uint16\_t)txAntennaNum[1]);
2679         \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC}(\textcolor{stringliteral}{"max gain "} << max << \textcolor{stringliteral}{" maxTx "} << (M\_PI*(\textcolor{keywordtype}{double})maxTx/(\textcolor{keywordtype}{double})
      txAntennaNum[1]-0.5*M\_PI)/(M\_PI)*180 << \textcolor{stringliteral}{" maxRx "} << (M\_PI*(\textcolor{keywordtype}{double})maxRx/(\textcolor{keywordtype}{double})rxAntennaNum[1]-0.5*M\_PI)/(M\_PI)*180 
      << \textcolor{stringliteral}{" maxTxTheta "} << maxTxTheta << \textcolor{stringliteral}{" maxRxTheta "} << maxRxTheta);
2680         txAntenna->SetSector(maxTx, txAntennaNum, maxTxTheta);
2681         rxAntenna->SetSector(maxRx, rxAntennaNum, maxRxTheta);
2682         params->m\_txW = txAntenna->GetBeamformingVector();
2683         params->m\_rxW = rxAntenna->GetBeamformingVector();
2684 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3




Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!Cal\+Attenuation\+Of\+Blockage@{Cal\+Attenuation\+Of\+Blockage}}
\index{Cal\+Attenuation\+Of\+Blockage@{Cal\+Attenuation\+Of\+Blockage}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{Cal\+Attenuation\+Of\+Blockage(\+Ptr$<$ Params3gpp $>$ params, double\+Vector\+\_\+t cluster\+A\+O\+A, double\+Vector\+\_\+t cluster\+Z\+O\+A) const }{CalAttenuationOfBlockage(Ptr< Params3gpp > params, doubleVector_t clusterAOA, doubleVector_t clusterZOA) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf double\+Vector\+\_\+t} ns3\+::\+Mm\+Wave3gpp\+Channel\+::\+Cal\+Attenuation\+Of\+Blockage (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Params3gpp} $>$}]{params, }
\item[{{\bf double\+Vector\+\_\+t}}]{cluster\+A\+OA, }
\item[{{\bf double\+Vector\+\_\+t}}]{cluster\+Z\+OA}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWave3gppChannel_aff8853ed48d4aeb1a5d4960a843f5f1a}{}\label{classns3_1_1MmWave3gppChannel_aff8853ed48d4aeb1a5d4960a843f5f1a}

\begin{DoxyCode}
2689 \{
2690         \hyperlink{namespacens3_aa6f1edf6566ca6afec613bc6e40240ea}{doubleVector\_t} powerAttenuation;
2691         uint8\_t clusterNum = clusterAOA.size ();
2692         \textcolor{keywordflow}{for}(uint8\_t cInd = 0; cInd < clusterNum; cInd++)
2693         \{
2694                 powerAttenuation.push\_back(0); \textcolor{comment}{//Initial power attenuation for all clusters to be 0 dB;}
2695         \}
2696         \textcolor{comment}{//step a: the number of non-self blocking blockers is stored in m\_numNonSelfBloking.}
2697 
2698         \textcolor{comment}{//step b:Generate the size and location of each blocker}
2699         \textcolor{comment}{//generate self blocking (i.e., for blockage from the human body)}
2700         \textcolor{keywordtype}{double} phi\_sb, x\_sb, theta\_sb, y\_sb;
2701         \textcolor{comment}{//table 7.6.4.1-1 Self-blocking region parameters.}
2702         \textcolor{keywordflow}{if}(\hyperlink{classns3_1_1MmWave3gppChannel_a013ed012d87114993312ccfd172fe377}{m\_portraitMode})
2703         \{
2704                 phi\_sb = 260;
2705                 x\_sb = 120;
2706                 theta\_sb = 100;
2707                 y\_sb = 80;
2708         \}
2709         \textcolor{keywordflow}{else}\textcolor{comment}{// landscape mode}
2710         \{
2711                 phi\_sb = 40;
2712                 x\_sb = 160;
2713                 theta\_sb = 110;
2714                 y\_sb = 75;
2715         \}
2716 
2717         \textcolor{comment}{//generate or update non-self blocking}
2718         \textcolor{keywordflow}{if}(params->m\_nonSelfBlocking.size ()==0)\textcolor{comment}{//generate new blocking regions}
2719         \{
2720                 \textcolor{keywordflow}{for}(uint16\_t blockInd=0; blockInd<\hyperlink{classns3_1_1MmWave3gppChannel_addfe5e6c9d8e2531fe165ff86461d2d3}{m\_numNonSelfBloking}; blockInd++)
2721                 \{
2722                         \textcolor{comment}{//draw value from table 7.6.4.1-2 Blocking region parameters}
2723                         \hyperlink{namespacens3_aa6f1edf6566ca6afec613bc6e40240ea}{doubleVector\_t} table;
2724                         table.push\_back (\hyperlink{classns3_1_1MmWave3gppChannel_a51e89a0f3902e6e377705871c479cf36}{m\_normalRvBlockage}->
      \hyperlink{classns3_1_1NormalRandomVariable_a0134d131477bc439cc6ff7cbe84b03a9}{GetValue}()); \textcolor{comment}{//phi\_k: store the normal RV that will be mapped to uniform (0,360) later.}
2725                         \textcolor{keywordflow}{if}(\hyperlink{classns3_1_1MmWave3gppChannel_ae1f263fbc87682905d563221343e4447}{m\_scenario} == \textcolor{stringliteral}{"InH-OfficeMixed"} || 
      \hyperlink{classns3_1_1MmWave3gppChannel_ae1f263fbc87682905d563221343e4447}{m\_scenario} == \textcolor{stringliteral}{"InH-OfficeOpen"})
2726                         \{
2727                                 table.push\_back (\hyperlink{classns3_1_1MmWave3gppChannel_a5afa026ce58c8b70c81c846bb7b49b4f}{m\_uniformRvBlockage}->
      \hyperlink{classns3_1_1UniformRandomVariable_a03822d8c86ac51e9aa83bbc73041386b}{GetValue}(15, 45)); \textcolor{comment}{//x\_k}
2728                                 table.push\_back (90); \textcolor{comment}{//Theta\_k}
2729                                 table.push\_back (\hyperlink{classns3_1_1MmWave3gppChannel_a5afa026ce58c8b70c81c846bb7b49b4f}{m\_uniformRvBlockage}->
      \hyperlink{classns3_1_1UniformRandomVariable_a03822d8c86ac51e9aa83bbc73041386b}{GetValue}(5, 15)); \textcolor{comment}{//y\_k}
2730                                 table.push\_back (2); \textcolor{comment}{//r}
2731                         \}
2732                         \textcolor{keywordflow}{else}
2733                         \{
2734                                 table.push\_back (\hyperlink{classns3_1_1MmWave3gppChannel_a5afa026ce58c8b70c81c846bb7b49b4f}{m\_uniformRvBlockage}->
      \hyperlink{classns3_1_1UniformRandomVariable_a03822d8c86ac51e9aa83bbc73041386b}{GetValue}(5, 15)); \textcolor{comment}{//x\_k}
2735                                 table.push\_back (90); \textcolor{comment}{//Theta\_k}
2736                                 table.push\_back (5); \textcolor{comment}{//y\_k}
2737                                 table.push\_back (10); \textcolor{comment}{//r}
2738                         \}
2739                         params->m\_nonSelfBlocking.push\_back(table);
2740                 \}
2741         \}
2742         \textcolor{keywordflow}{else}
2743         \{
2744                 \textcolor{keywordtype}{double} deltaX =sqrt(pow(params->m\_preLocUT.x-params->m\_locUT.x, 2)+pow(params->m\_preLocUT.y
      -params->m\_locUT.y, 2));
2745                 \textcolor{comment}{//if deltaX and speed are both 0, the autocorrelation is 1, skip updating}
2746                 \textcolor{keywordflow}{if}(deltaX > 1e-6 || \hyperlink{classns3_1_1MmWave3gppChannel_a5d7b7b759283cdf9a6781571e9eeca25}{m\_blockerSpeed} > 1e-6)
2747                 \{
2748                         \textcolor{keywordtype}{double} corrDis;
2749                         \textcolor{comment}{//draw value from table 7.6.4.1-4: Spatial correlation distance for different
       scenarios.}
2750                         \textcolor{keywordflow}{if}(\hyperlink{classns3_1_1MmWave3gppChannel_ae1f263fbc87682905d563221343e4447}{m\_scenario} == \textcolor{stringliteral}{"InH-OfficeMixed"} || 
      \hyperlink{classns3_1_1MmWave3gppChannel_ae1f263fbc87682905d563221343e4447}{m\_scenario} == \textcolor{stringliteral}{"InH-OfficeOpen"})
2751                         \{
2752                                 \textcolor{comment}{//InH, correlation distance = 5;}
2753                                 corrDis = 5;
2754                         \}
2755                         \textcolor{keywordflow}{else}
2756                         \{
2757                                 \textcolor{keywordflow}{if}(params->m\_o2i)\textcolor{comment}{// outdoor to indoor}
2758                                 \{
2759                                         corrDis = 5;
2760                                 \}
2761                                 \textcolor{keywordflow}{else} \textcolor{comment}{//LOS or NLOS}
2762                                 \{
2763                                         corrDis = 10;
2764                                 \}
2765                         \}
2766                         \textcolor{keywordtype}{double} R;
2767                         \textcolor{keywordflow}{if}(\hyperlink{classns3_1_1MmWave3gppChannel_a5d7b7b759283cdf9a6781571e9eeca25}{m\_blockerSpeed} > 1e-6) \textcolor{comment}{// speed not equal to 0}
2768                         \{
2769                                 \textcolor{keywordtype}{double} corrT = corrDis/\hyperlink{classns3_1_1MmWave3gppChannel_a5d7b7b759283cdf9a6781571e9eeca25}{m\_blockerSpeed};
2770                                 R = exp(-1*(deltaX/corrDis+(\hyperlink{group__simulator_gac3635e2e87f7ce316c89290ee1b01d0d}{Now}().GetSeconds()-params->m\_generatedTime.
      \hyperlink{classns3_1_1Time_a8f20d5c3b0902d7b4320982f340b57c8}{GetSeconds}())/corrT));
2771                         \}
2772                         \textcolor{keywordflow}{else}
2773                         \{
2774                                 R = exp(-1*(deltaX/corrDis));
2775                         \}
2776 
2777                         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Distance change:"}<<deltaX<<\textcolor{stringliteral}{" Speed:"}<<
      \hyperlink{classns3_1_1MmWave3gppChannel_a5d7b7b759283cdf9a6781571e9eeca25}{m\_blockerSpeed}
2778                                         <<\textcolor{stringliteral}{" Time difference:"}<<\hyperlink{group__simulator_gac3635e2e87f7ce316c89290ee1b01d0d}{Now}().GetSeconds()-params->
      m\_generatedTime.\hyperlink{classns3_1_1Time_a8f20d5c3b0902d7b4320982f340b57c8}{GetSeconds}()
2779                                         <<\textcolor{stringliteral}{" correlation:"}<<R);
2780 
2781                         \textcolor{comment}{//In order to generate correlated uniform random variables, we first generate
       correlated normal random variables and map the normal RV to uniform RV.}
2782                         \textcolor{comment}{//Notice the correlation will change if the RV is transformed from normal to
       uniform.}
2783                         \textcolor{comment}{//To compensate the distortion, the correlation of the normal RV is computed}
2784                         \textcolor{comment}{//such that the uniform RV would have the desired correlation when transformed from
       normal RV.}
2785 
2786                         \textcolor{comment}{//The following formula was obtained from MATLAB numerical simulation.}
2787 
2788                         \textcolor{keywordflow}{if}(R*R*(-0.069)+R*1.074-0.002 < 1)\textcolor{comment}{//transform only when the correlation of normal
       RV is smaller than 1}
2789                         \{
2790                                 R = R*R*(-0.069)+R*1.074-0.002;
2791                         \}
2792                         \textcolor{keywordflow}{for}(uint16\_t blockInd=0; blockInd<\hyperlink{classns3_1_1MmWave3gppChannel_addfe5e6c9d8e2531fe165ff86461d2d3}{m\_numNonSelfBloking}; blockInd+
      +)
2793                         \{
2794 
2795                                 \textcolor{comment}{//Generate a new correlated normal RV with the following formula}
2796                                 params->m\_nonSelfBlocking.at(blockInd).at(
      \hyperlink{mmwave-3gpp-channel_8h_aac1933f496abe567e4380fc99112f6dc}{PHI\_INDEX}) =
2797                                                 R*params->m\_nonSelfBlocking.at(blockInd).at(
      \hyperlink{mmwave-3gpp-channel_8h_aac1933f496abe567e4380fc99112f6dc}{PHI\_INDEX}) + sqrt(1-R*R)*\hyperlink{classns3_1_1MmWave3gppChannel_a51e89a0f3902e6e377705871c479cf36}{m\_normalRvBlockage}->\hyperlink{classns3_1_1NormalRandomVariable_a0134d131477bc439cc6ff7cbe84b03a9}{GetValue} ();
2798                         \}
2799                 \}
2800 
2801         \}
2802 
2803         \textcolor{comment}{//step c: Determine the attenuation of each blocker due to blockers}
2804         \textcolor{keywordflow}{for}(uint8\_t cInd = 0; cInd < clusterNum; cInd++)
2805         \{
2806                 \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG}(clusterAOA.at (cInd)>=0 && clusterAOA.at (cInd)<=360, \textcolor{stringliteral}{"the AOA
       should be the range of [0,360]"});
2807                 \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG}(clusterZOA.at (cInd)>=0 && clusterZOA.at (cInd)<=180, \textcolor{stringliteral}{"the ZOA
       should be the range of [0,180]"});
2808 
2809                 \textcolor{comment}{//check self blocking}
2810                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"AOA="}<<clusterAOA.at (cInd) << \textcolor{stringliteral}{" Block Region["} << phi\_sb - x\_sb/2
      << \textcolor{stringliteral}{","}<<phi\_sb + x\_sb/2<<\textcolor{stringliteral}{"]"});
2811                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"ZOA="}<<clusterZOA.at (cInd) << \textcolor{stringliteral}{" Block Region["} << theta\_sb - y\_sb
      /2<< \textcolor{stringliteral}{","}<<theta\_sb + y\_sb/2<<\textcolor{stringliteral}{"]"});
2812                 \textcolor{keywordflow}{if}( std::abs(clusterAOA.at (cInd)-phi\_sb)<(x\_sb/2) && std::abs(clusterZOA.at (cInd)-
      theta\_sb)<(y\_sb/2))
2813                 \{
2814                         powerAttenuation.at (cInd) += 30; \textcolor{comment}{//anttenuate by 30 dB.}
2815                         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Cluster["}<<(\textcolor{keywordtype}{int})cInd<<\textcolor{stringliteral}{"] is blocked by self blocking
       region and reduce 30 dB power,"}
2816                                         \textcolor{stringliteral}{"the attenuation is ["}<<powerAttenuation.at (cInd)<<\textcolor{stringliteral}{" dB]"});
2817                 \}
2818 
2819                 \textcolor{comment}{//check non-self blocking}
2820                 \textcolor{keywordtype}{double} phiK, xK, thetaK, yK;
2821                 \textcolor{keywordflow}{for}(uint16\_t blockInd=0; blockInd<\hyperlink{classns3_1_1MmWave3gppChannel_addfe5e6c9d8e2531fe165ff86461d2d3}{m\_numNonSelfBloking}; blockInd++)
2822                 \{
2823                         \textcolor{comment}{//The normal RV is transformed to uniform RV with the desired correlation.}
2824                         phiK = (0.5*erfc(-1*params->m\_nonSelfBlocking.at(blockInd).at(
      \hyperlink{mmwave-3gpp-channel_8h_aac1933f496abe567e4380fc99112f6dc}{PHI\_INDEX})/sqrt(2)))*360;
2825                         \textcolor{keywordflow}{while}(phiK > 360)
2826                         \{
2827                                 phiK -= 360;
2828                         \}
2829 
2830                         \textcolor{keywordflow}{while} (phiK < 0)
2831                         \{
2832                                 phiK += 360;
2833                         \}
2834 
2835                         xK = params->m\_nonSelfBlocking.at(blockInd).at(\hyperlink{mmwave-3gpp-channel_8h_a023beaacdde3cbaf70604cf4da305e42}{X\_INDEX});
2836                         thetaK = params->m\_nonSelfBlocking.at(blockInd).at(
      \hyperlink{mmwave-3gpp-channel_8h_a5d773c28fd925701ed291c2401cddff0}{THETA\_INDEX});
2837                         yK = params->m\_nonSelfBlocking.at(blockInd).at(\hyperlink{mmwave-3gpp-channel_8h_a061187b89198cb94cc331d5a76476bc1}{Y\_INDEX});
2838                         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"AOA="}<<clusterAOA.at (cInd) << \textcolor{stringliteral}{" Block Region["} << phiK - 
      xK<< \textcolor{stringliteral}{","}<<phiK + xK<<\textcolor{stringliteral}{"]"});
2839                         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"ZOA="}<<clusterZOA.at (cInd) << \textcolor{stringliteral}{" Block Region["} << thetaK 
      - yK<< \textcolor{stringliteral}{","}<<thetaK + yK<<\textcolor{stringliteral}{"]"});
2840 
2841                         \textcolor{keywordflow}{if}( std::abs(clusterAOA.at (cInd)-phiK)<(xK)
2842                                         && std::abs(clusterZOA.at (cInd)-thetaK)<(yK))
2843                         \{
2844                                 \textcolor{keywordtype}{double} A1 = clusterAOA.at (cInd)-(phiK+xK/2); \textcolor{comment}{//(7.6-24)}
2845                                 \textcolor{keywordtype}{double} A2 = clusterAOA.at (cInd)-(phiK-xK/2); \textcolor{comment}{//(7.6-25)}
2846                                 \textcolor{keywordtype}{double} Z1 = clusterZOA.at (cInd)-(thetaK+yK/2); \textcolor{comment}{//(7.6-26)}
2847                                 \textcolor{keywordtype}{double} Z2 = clusterZOA.at (cInd)-(thetaK-yK/2); \textcolor{comment}{//(7.6-27)}
2848                                 \textcolor{keywordtype}{int} signA1, signA2, signZ1, signZ2;
2849                                 \textcolor{comment}{//draw sign for the above parameters according to table 7.6.4.1-3
       Description of signs}
2850                                 \textcolor{keywordflow}{if} (xK/2<clusterAOA.at (cInd)-phiK && clusterAOA.at (cInd)-phiK<=xK)
2851                                 \{
2852                                         signA1 = -1;
2853                                 \}
2854                                 \textcolor{keywordflow}{else}
2855                                 \{
2856                                         signA1 = 1;
2857                                 \}
2858                                 \textcolor{keywordflow}{if} (-1*xK<clusterAOA.at (cInd)-phiK && clusterAOA.at (cInd)-phiK<=-1*xK/2)
2859                                 \{
2860                                         signA2 = -1;
2861                                 \}
2862                                 \textcolor{keywordflow}{else}
2863                                 \{
2864                                         signA2 = 1;
2865                                 \}
2866 
2867                                 \textcolor{keywordflow}{if} (yK/2<clusterZOA.at (cInd)-thetaK && clusterZOA.at (cInd)-thetaK<=yK)
2868                                 \{
2869                                         signZ1 = -1;
2870                                 \}
2871                                 \textcolor{keywordflow}{else}
2872                                 \{
2873                                         signZ1 = 1;
2874                                 \}
2875                                 \textcolor{keywordflow}{if} (-1*yK<clusterZOA.at (cInd)-thetaK && clusterZOA.at (cInd)-thetaK<=-1*yK
      /2)
2876                                 \{
2877                                         signZ2 = -1;
2878                                 \}
2879                                 \textcolor{keywordflow}{else}
2880                                 \{
2881                                         signZ2 = 1;
2882                                 \}
2883                                 \textcolor{keywordtype}{double} \hyperlink{loss__ITU1238_8m_aca36b09d6e71a60cfa3837d7e24c07ca}{lambda} = 3e8/\hyperlink{classns3_1_1MmWave3gppChannel_a50988766af948ea236ce24718a6dca7d}{m\_phyMacConfig}->
      \hyperlink{classns3_1_1MmWavePhyMacCommon_a0850d2e37c7075b9bce242723b722019}{GetCenterFrequency} ();
2884                                 \textcolor{keywordtype}{double} F\_A1 = atan(signA1*M\_PI/2*sqrt(M\_PI/lambda*
2885                                                 params->m\_nonSelfBlocking.at(blockInd).at(
      \hyperlink{mmwave-3gpp-channel_8h_a8f6974deb00a9a41c7352e23e76b879a}{R\_INDEX})*(1/cos(A1*M\_PI/180)-1)))/M\_PI; \textcolor{comment}{//(7.6-23)}
2886                                 \textcolor{keywordtype}{double} F\_A2 = atan(signA2*M\_PI/2*sqrt(M\_PI/lambda*
2887                                                 params->m\_nonSelfBlocking.at(blockInd).at(
      \hyperlink{mmwave-3gpp-channel_8h_a8f6974deb00a9a41c7352e23e76b879a}{R\_INDEX})*(1/cos(A2*M\_PI/180)-1)))/M\_PI;
2888                                 \textcolor{keywordtype}{double} F\_Z1 = atan(signZ1*M\_PI/2*sqrt(M\_PI/lambda*
2889                                                 params->m\_nonSelfBlocking.at(blockInd).at(
      \hyperlink{mmwave-3gpp-channel_8h_a8f6974deb00a9a41c7352e23e76b879a}{R\_INDEX})*(1/cos(Z1*M\_PI/180)-1)))/M\_PI;
2890                                 \textcolor{keywordtype}{double} F\_Z2 = atan(signZ2*M\_PI/2*sqrt(M\_PI/lambda*
2891                                                 params->m\_nonSelfBlocking.at(blockInd).at(
      \hyperlink{mmwave-3gpp-channel_8h_a8f6974deb00a9a41c7352e23e76b879a}{R\_INDEX})*(1/cos(Z2*M\_PI/180)-1)))/M\_PI;
2892                                 \textcolor{keywordtype}{double} L\_dB = -20*log10(1-(F\_A1+F\_A2)*(F\_Z1+F\_Z2)); \textcolor{comment}{//(7.6-22)}
2893                                 powerAttenuation.at(cInd) += L\_dB;
2894                                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Cluster["}<<(\textcolor{keywordtype}{int})cInd<<\textcolor{stringliteral}{"] is blocked by no-self
       blocking, "}
2895                                                 \textcolor{stringliteral}{"the loss is ["}<<L\_dB<<\textcolor{stringliteral}{"]"}<<\textcolor{stringliteral}{" dB"});
2896 
2897                         \}
2898                 \}
2899         \}
2900         \textcolor{keywordflow}{return} powerAttenuation;
2901 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5




Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!Cal\+Beamforming\+Gain@{Cal\+Beamforming\+Gain}}
\index{Cal\+Beamforming\+Gain@{Cal\+Beamforming\+Gain}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{Cal\+Beamforming\+Gain(\+Ptr$<$ const Spectrum\+Value $>$ tx\+Psd, Ptr$<$ Params3gpp $>$ params, Vector speed) const }{CalBeamformingGain(Ptr< const SpectrumValue > txPsd, Ptr< Params3gpp > params, Vector speed) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Spectrum\+Value} $>$ ns3\+::\+Mm\+Wave3gpp\+Channel\+::\+Cal\+Beamforming\+Gain (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Spectrum\+Value} $>$}]{tx\+Psd, }
\item[{{\bf Ptr}$<$ {\bf Params3gpp} $>$}]{params, }
\item[{Vector}]{speed}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWave3gppChannel_acd8bc1db086ba52b0e77ed71a6ccb56d}{}\label{classns3_1_1MmWave3gppChannel_acd8bc1db086ba52b0e77ed71a6ccb56d}
Compute the BF gain, apply frequency selectivity by phase-\/shifting with the cluster delays and scale the tx\+Psd to get the rx\+Psd  the tx P\+SD  the channel realizationin as a \hyperlink{structns3_1_1Params3gpp}{Params3gpp} object  the relative speed between UE and e\+NB \begin{DoxyReturn}{Returns}
the rx P\+SD 
\end{DoxyReturn}

\begin{DoxyCode}
895 \{
896         \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
897 
898         Ptr<SpectrumValue> tempPsd = Copy<SpectrumValue> (\hyperlink{lte__link__budget_8m_a684fe3101a5e48a5fcc57cab8dbcd1aa}{txPsd});
899 
900         \textcolor{comment}{//NS\_ASSERT\_MSG (params->m\_delay.size()==params->m\_channel.at(0).at(0).size(), "the cluster number
       of channel and delay spread should be the same");}
901         \textcolor{comment}{//NS\_ASSERT\_MSG (params->m\_txW.size()==params->m\_channel.at(0).size(), "the tx antenna size of
       channel and antenna weights should be the same");}
902         \textcolor{comment}{//NS\_ASSERT\_MSG (params->m\_rxW.size()==params->m\_channel.size(), "the rx antenna size of channel
       and antenna weights should be the same");}
903         \textcolor{comment}{//NS\_ASSERT\_MSG (params->m\_angle.at(0).size()==params->m\_channel.at(0).at(0).size(), "the cluster
       number of channel and AOA should be the same");}
904         \textcolor{comment}{//NS\_ASSERT\_MSG (params->m\_angle.at(1).size()==params->m\_channel.at(0).at(0).size(), "the cluster
       number of channel and ZOA should be the same");}
905 
906         \textcolor{comment}{//channel[rx][tx][cluster]}
907         uint8\_t numCluster = params->m\_delay.size();
908         \textcolor{comment}{//uint8\_t txAntenna = params->m\_txW.size();}
909         \textcolor{comment}{//uint8\_t rxAntenna = params->m\_rxW.size();}
910         \textcolor{comment}{//the update of Doppler is simplified by only taking the center angle of each cluster in to
       consideration.}
911         Values::iterator vit = tempPsd->ValuesBegin ();
912         uint16\_t iSubband = 0;
913         \textcolor{keywordtype}{double} slotTime = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ().\hyperlink{classns3_1_1Time_a8f20d5c3b0902d7b4320982f340b57c8}{GetSeconds} ();
914         \hyperlink{namespacens3_a6a7f75817ae50e6ac47414955b17d926}{complexVector\_t} doppler;
915         \textcolor{keywordflow}{for} (uint8\_t cIndex = 0; cIndex < numCluster; cIndex++)
916         \{
917                 \textcolor{comment}{//cluster angle angle[direction][n],where, direction = 0(aoa), 1(zoa).}
918                 \textcolor{keywordtype}{double} temp\_doppler = 2*M\_PI*(sin(params->m\_angle.at(\hyperlink{mmwave-3gpp-channel_8h_a86ab9a21bb66f50f7f4b0c0a0ee1f474}{ZOA\_INDEX}).at(cIndex)*M\_PI/
      180)*cos(params->m\_angle.at(\hyperlink{mmwave-3gpp-channel_8h_a7f1d5772b72f2ce425d85a2b41e8842f}{AOA\_INDEX}).at(cIndex)*M\_PI/180)*\hyperlink{mmwave-amc-test_8cc_a6dc6e6f3c75c509ce943163afb5dade7}{speed}.x
919                                 + sin(params->m\_angle.at(\hyperlink{mmwave-3gpp-channel_8h_a86ab9a21bb66f50f7f4b0c0a0ee1f474}{ZOA\_INDEX}).at(cIndex)*M\_PI/180)*sin(
      params->m\_angle.at(\hyperlink{mmwave-3gpp-channel_8h_a7f1d5772b72f2ce425d85a2b41e8842f}{AOA\_INDEX}).at(cIndex)*M\_PI/180)*\hyperlink{mmwave-amc-test_8cc_a6dc6e6f3c75c509ce943163afb5dade7}{speed}.y
920                                 + cos(params->m\_angle.at(\hyperlink{mmwave-3gpp-channel_8h_a86ab9a21bb66f50f7f4b0c0a0ee1f474}{ZOA\_INDEX}).at(cIndex)*M\_PI/180)*
      \hyperlink{mmwave-amc-test_8cc_a6dc6e6f3c75c509ce943163afb5dade7}{speed}.z)*slotTime*\hyperlink{classns3_1_1MmWave3gppChannel_a50988766af948ea236ce24718a6dca7d}{m\_phyMacConfig}->\hyperlink{classns3_1_1MmWavePhyMacCommon_a0850d2e37c7075b9bce242723b722019}{GetCenterFrequency} ()/3e8;
921                 doppler.push\_back(exp(std::complex<double> (0, temp\_doppler)));
922 
923         \}
924 
925         \textcolor{keywordflow}{while} (vit != tempPsd->ValuesEnd ())
926         \{
927                 std::complex<double> subsbandGain (0.0,0.0);
928                 \textcolor{keywordflow}{if} ((*vit) != 0.00)
929                 \{
930                         \textcolor{keywordtype}{double} fsb = \hyperlink{classns3_1_1MmWave3gppChannel_a50988766af948ea236ce24718a6dca7d}{m\_phyMacConfig}->
      \hyperlink{classns3_1_1MmWavePhyMacCommon_a0850d2e37c7075b9bce242723b722019}{GetCenterFrequency} () - \hyperlink{classns3_1_1MmWave3gppChannel_aff34062721c2775f51890cbf23702d99}{GetSystemBandwidth} ()/2 + 
      \hyperlink{classns3_1_1MmWave3gppChannel_a50988766af948ea236ce24718a6dca7d}{m\_phyMacConfig}->\hyperlink{classns3_1_1MmWavePhyMacCommon_acc801566d527f1893d67a618ea3be203}{GetChunkWidth} ()*iSubband ;
931                         \textcolor{keywordflow}{for} (uint8\_t cIndex = 0; cIndex < numCluster; cIndex++)
932                         \{
933                                 \textcolor{keywordtype}{double} \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_a7964e6aa8f61a9d28973c8267a606ad8}{delay} = -2*M\_PI*fsb*(params->m\_delay.at (cIndex));
934                                 std::complex<double> txSum(0,0);
935                                 subsbandGain = subsbandGain + params->m\_longTerm.at(cIndex)*doppler.at(
      cIndex)*exp(std::complex<double>(0, delay));
936                         \}
937                         *vit = (*vit)*(norm (subsbandGain));
938                 \}
939                 vit++;
940                 iSubband++;
941         \}
942         \textcolor{keywordflow}{return} tempPsd;
943 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7




Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!Cal\+Long\+Term@{Cal\+Long\+Term}}
\index{Cal\+Long\+Term@{Cal\+Long\+Term}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{Cal\+Long\+Term(\+Ptr$<$ Params3gpp $>$ params) const }{CalLongTerm(Ptr< Params3gpp > params) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mm\+Wave3gpp\+Channel\+::\+Cal\+Long\+Term (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Params3gpp} $>$}]{params}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWave3gppChannel_ab1cacdfc31ed5b10bc2dc5206153ec57}{}\label{classns3_1_1MmWave3gppChannel_ab1cacdfc31ed5b10bc2dc5206153ec57}
Compute and store the long term fading params in order to decrease the computational load  the channel realizationin as a \hyperlink{structns3_1_1Params3gpp}{Params3gpp} object 
\begin{DoxyCode}
974 \{
975         uint8\_t txAntenna = params->m\_txW.size();
976         uint8\_t rxAntenna = params->m\_rxW.size();
977 
978         \textcolor{comment}{//store the long term part to reduce computation load}
979         \textcolor{comment}{//only the small scale fading is need to be updated if the large scale parameters and antenna
       weights remain unchanged.}
980         \hyperlink{namespacens3_a6a7f75817ae50e6ac47414955b17d926}{complexVector\_t} longTerm;
981         uint8\_t numCluster = params->m\_delay.size();
982 
983         \textcolor{keywordflow}{for} (uint8\_t cIndex = 0; cIndex < numCluster; cIndex++)
984         \{
985                 std::complex<double> txSum(0,0);
986                 \textcolor{keywordflow}{for}(uint8\_t txIndex = 0; txIndex < txAntenna; txIndex++)
987                 \{
988                         std::complex<double> rxSum(0,0);
989                         \textcolor{keywordflow}{for} (uint8\_t rxIndex = 0; rxIndex < rxAntenna; rxIndex++)
990                         \{
991                                 rxSum = rxSum + std::conj(params->m\_rxW.at(rxIndex))*params->m\_channel.at(
      rxIndex).at(txIndex).at(cIndex);
992                         \}
993                         txSum = txSum + params->m\_txW.at(txIndex)*rxSum;
994                 \}
995                 longTerm.push\_back(txSum);
996         \}
997         params->m\_longTerm = longTerm;
998 
999 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 9


\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!Connect\+Devices@{Connect\+Devices}}
\index{Connect\+Devices@{Connect\+Devices}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{Connect\+Devices(\+Ptr$<$ Net\+Device $>$ dev1, Ptr$<$ Net\+Device $>$ dev2)}{ConnectDevices(Ptr< NetDevice > dev1, Ptr< NetDevice > dev2)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mm\+Wave3gpp\+Channel\+::\+Connect\+Devices (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{dev1, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{dev2}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1MmWave3gppChannel_ad2a4b9738d3630c1363eee2f7a34f68e}{}\label{classns3_1_1MmWave3gppChannel_ad2a4b9738d3630c1363eee2f7a34f68e}
Register the connection between two devices 
\begin{DoxyParams}{Parameters}
{\em a} & pointer to a \hyperlink{classns3_1_1NetDevice}{Net\+Device} \\
\hline
{\em a} & pointer to a \hyperlink{classns3_1_1NetDevice}{Net\+Device} \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
241 \{
242         \hyperlink{namespacens3_aa42bd408e172586b3b192acfaa36b070}{key\_t} key = std::make\_pair(dev1,dev2);
243 
244         std::map< key\_t, int >::iterator iter = \hyperlink{classns3_1_1MmWave3gppChannel_a43ad5b64f557a59c929fa49f3600fd9f}{m\_connectedPair}.find(key);
245         \textcolor{keywordflow}{if} (iter != \hyperlink{classns3_1_1MmWave3gppChannel_a43ad5b64f557a59c929fa49f3600fd9f}{m\_connectedPair}.end ())
246         \{
247                 \hyperlink{classns3_1_1MmWave3gppChannel_a43ad5b64f557a59c929fa49f3600fd9f}{m\_connectedPair}.erase (iter);
248         \}
249         \hyperlink{classns3_1_1MmWave3gppChannel_a43ad5b64f557a59c929fa49f3600fd9f}{m\_connectedPair}.insert(std::make\_pair(key,1));
250 \}
\end{DoxyCode}
\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!Delete\+Channel@{Delete\+Channel}}
\index{Delete\+Channel@{Delete\+Channel}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{Delete\+Channel(\+Ptr$<$ const Mobility\+Model $>$ a, Ptr$<$ const Mobility\+Model $>$ b) const }{DeleteChannel(Ptr< const MobilityModel > a, Ptr< const MobilityModel > b) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mm\+Wave3gpp\+Channel\+::\+Delete\+Channel (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Mobility\+Model} $>$}]{a, }
\item[{{\bf Ptr}$<$ const {\bf Mobility\+Model} $>$}]{b}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWave3gppChannel_a3ec4e2d8d84d7876581a00fa5174a1a5}{}\label{classns3_1_1MmWave3gppChannel_a3ec4e2d8d84d7876581a00fa5174a1a5}
Delete the m\+\_\+channel entry associated to the \hyperlink{structns3_1_1Params3gpp}{Params3gpp} object of pair (a,b) but keep the other parameters, so that the spatial consistency procedure can be used  the mobility model of the transmitter  the mobility model of the receiver 
\begin{DoxyCode}
1191 \{
1192         Ptr<NetDevice> dev1 = a->GetObject<Node> ()->GetDevice (0);
1193         Ptr<NetDevice> dev2 = \hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b}->GetObject<Node> ()->GetDevice (0);
1194         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO}(\textcolor{stringliteral}{"a position "} << a->GetPosition() << \textcolor{stringliteral}{" b "} << \hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b}->GetPosition());
1195         Ptr<Params3gpp> params = \hyperlink{classns3_1_1MmWave3gppChannel_a31f05f0c8a438b8ce89f29813e863040}{m\_channelMap}.find(std::make\_pair(dev1,dev2))->second;
1196         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO}(\textcolor{stringliteral}{"params "} << params);
1197         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO}(\textcolor{stringliteral}{"params m\_channel size"} << params->m\_channel.size());
1198         \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG}(\hyperlink{classns3_1_1MmWave3gppChannel_a31f05f0c8a438b8ce89f29813e863040}{m\_channelMap}.find(std::make\_pair(dev1,dev2)) != 
      \hyperlink{classns3_1_1MmWave3gppChannel_a31f05f0c8a438b8ce89f29813e863040}{m\_channelMap}.end(), \textcolor{stringliteral}{"Channel not found"});
1199         params->m\_channel.clear();
1200         \hyperlink{classns3_1_1MmWave3gppChannel_a31f05f0c8a438b8ce89f29813e863040}{m\_channelMap}[std::make\_pair(dev1,dev2)] = params;
1201 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 10


\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!Do\+Calc\+Rx\+Power\+Spectral\+Density@{Do\+Calc\+Rx\+Power\+Spectral\+Density}}
\index{Do\+Calc\+Rx\+Power\+Spectral\+Density@{Do\+Calc\+Rx\+Power\+Spectral\+Density}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{Do\+Calc\+Rx\+Power\+Spectral\+Density(\+Ptr$<$ const Spectrum\+Value $>$ tx\+Psd, Ptr$<$ const Mobility\+Model $>$ a, Ptr$<$ const Mobility\+Model $>$ b) const }{DoCalcRxPowerSpectralDensity(Ptr< const SpectrumValue > txPsd, Ptr< const MobilityModel > a, Ptr< const MobilityModel > b) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Spectrum\+Value} $>$ ns3\+::\+Mm\+Wave3gpp\+Channel\+::\+Do\+Calc\+Rx\+Power\+Spectral\+Density (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Spectrum\+Value} $>$}]{tx\+Psd, }
\item[{{\bf Ptr}$<$ const {\bf Mobility\+Model} $>$}]{a, }
\item[{{\bf Ptr}$<$ const {\bf Mobility\+Model} $>$}]{b}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1MmWave3gppChannel_a598876f469ba922150b9d9b86e160ca0}{}\label{classns3_1_1MmWave3gppChannel_a598876f469ba922150b9d9b86e160ca0}
Inherited from \hyperlink{classns3_1_1SpectrumPropagationLossModel}{Spectrum\+Propagation\+Loss\+Model}, it returns the P\+SD at the receiver  the transmitted P\+SD  the mobility model of the transmitter  the mobility model of the receiver \begin{DoxyReturn}{Returns}
the received P\+SD 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1SpectrumPropagationLossModel_a84c0da581e8828ee013fe164a899e5c9}{ns3\+::\+Spectrum\+Propagation\+Loss\+Model}.


\begin{DoxyCode}
383 \{
384         \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
385         Ptr<SpectrumValue> rxPsd = \hyperlink{namespacens3_a952d99f6d759fee74dda19f308451bc1}{Copy} (\hyperlink{lte__link__budget_8m_a684fe3101a5e48a5fcc57cab8dbcd1aa}{txPsd});
386 
387         Ptr<NetDevice> txDevice = a->GetObject<Node> ()->GetDevice (0);
388         Ptr<NetDevice> rxDevice = \hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b}->GetObject<Node> ()->GetDevice (0);
389         Ptr<MmWaveEnbNetDevice> txEnb =
390                                         DynamicCast<MmWaveEnbNetDevice> (txDevice);
391         Ptr<McUeNetDevice> rxMcUe =
392                                         DynamicCast<McUeNetDevice> (rxDevice);
393         Ptr<McUeNetDevice> txMcUe =
394                                         DynamicCast<McUeNetDevice> (txDevice);
395         Ptr<MmWaveUeNetDevice> rxUe =
396                                         DynamicCast<MmWaveUeNetDevice> (rxDevice);
397 
398         \textcolor{keywordtype}{bool} downlink = \textcolor{keyword}{false};
399         \textcolor{keywordtype}{bool} downlinkMc = \textcolor{keyword}{false};
400         \textcolor{keywordtype}{bool} uplink = \textcolor{keyword}{false};
401         \textcolor{keywordtype}{bool} uplinkMc = \textcolor{keyword}{false};
402 
403         \textcolor{comment}{/* txAntennaNum[0]-number of vertical antenna elements}
404 \textcolor{comment}{         * txAntennaNum[1]-number of horizontal antenna elements*/}
405         uint8\_t txAntennaNum[2];
406         uint8\_t rxAntennaNum[2];
407         Ptr<AntennaArrayModel> txAntennaArray, rxAntennaArray;
408 
409         Vector locUT;
410         \textcolor{keywordflow}{if}(txEnb!=0 && rxUe!=0 && rxMcUe==0)
411         \{
412                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"this is downlink case, a tx "} << a->GetPosition() << \textcolor{stringliteral}{" b rx "} << 
      \hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b}->GetPosition());
413                 downlink = \textcolor{keyword}{true};
414                 txAntennaNum[0] = sqrt (txEnb->GetAntennaNum ());
415                 txAntennaNum[1] = sqrt (txEnb->GetAntennaNum ());
416                 rxAntennaNum[0] = sqrt (rxUe->GetAntennaNum ());
417                 rxAntennaNum[1] = sqrt (rxUe->GetAntennaNum ());
418 
419                 txAntennaArray = DynamicCast<AntennaArrayModel> (
420                                         txEnb->GetPhy ()->GetDlSpectrumPhy ()->GetRxAntenna ());
421                 rxAntennaArray = DynamicCast<AntennaArrayModel> (
422                                         rxUe->GetPhy ()->GetDlSpectrumPhy ()->GetRxAntenna ());
423                 locUT = \hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b}->GetPosition();
424 
425         \}
426         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(txEnb!=0 && rxMcUe!=0 && rxUe==0)
427         \{
428                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"this is MC downlink case, a tx "} << a->GetPosition() << \textcolor{stringliteral}{" b rx "} <
      < \hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b}->GetPosition());
429                 downlinkMc = \textcolor{keyword}{true};
430                 txAntennaNum[0] = sqrt (txEnb->GetAntennaNum ());
431                 txAntennaNum[1] = sqrt (txEnb->GetAntennaNum ());
432                 rxAntennaNum[0] = sqrt (rxMcUe->GetAntennaNum ());
433                 rxAntennaNum[1] = sqrt (rxMcUe->GetAntennaNum ());
434 
435                 txAntennaArray = DynamicCast<AntennaArrayModel> (
436                                         txEnb->GetPhy ()->GetDlSpectrumPhy ()->GetRxAntenna ());
437                 \textcolor{keywordflow}{if}(\hyperlink{classns3_1_1MmWave3gppChannel_a5b921c4b6e89174bf383382c1ce6523f}{isAdditionalMmWavePhy})
438                 rxAntennaArray = DynamicCast<AntennaArrayModel> (
439                                         rxMcUe->GetMmWavePhy\_2 ()->GetDlSpectrumPhy ()->GetRxAntenna ());
440                 \textcolor{keywordflow}{else}
441                         rxAntennaArray = DynamicCast<AntennaArrayModel> (
442                                                         rxMcUe->GetMmWavePhy ()->GetDlSpectrumPhy ()->
      GetRxAntenna ()); \textcolor{comment}{//sjkang1125}
443 
444                 locUT = \hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b}->GetPosition();              
445         \}
446         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (txEnb==0 && rxUe==0 && txMcUe==0 && rxMcUe==0)
447         \{
448                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"this is uplink case, a tx "} << a->GetPosition() << \textcolor{stringliteral}{" b rx "} << 
      \hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b}->GetPosition());
449                 uplink = \textcolor{keyword}{true};
450                 Ptr<MmWaveUeNetDevice> txUe =
451                                                 DynamicCast<MmWaveUeNetDevice> (txDevice);
452                 Ptr<MmWaveEnbNetDevice> rxEnb =
453                                                 DynamicCast<MmWaveEnbNetDevice> (rxDevice);
454 
455                 txAntennaNum[0] = sqrt (txUe->GetAntennaNum ());
456                 txAntennaNum[1] = sqrt (txUe->GetAntennaNum ());
457                 rxAntennaNum[0] = sqrt (rxEnb->GetAntennaNum ());
458                 rxAntennaNum[1] = sqrt (rxEnb->GetAntennaNum ());
459 
460                 txAntennaArray = DynamicCast<AntennaArrayModel> (
461                                         txUe->GetPhy ()->GetDlSpectrumPhy ()->GetRxAntenna ());
462                 rxAntennaArray = DynamicCast<AntennaArrayModel> (
463                                         rxEnb->GetPhy ()->GetDlSpectrumPhy ()->GetRxAntenna ());
464                 locUT = a->GetPosition();
465 
466         \}
467         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (txEnb==0 && rxUe==0 && txMcUe!=0 && rxMcUe==0)
468         \{
469                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"this is MC uplink case, a tx "} << a->GetPosition() << \textcolor{stringliteral}{" b rx "} << 
      \hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b}->GetPosition());
470                 uplinkMc=\textcolor{keyword}{true};
471                 Ptr<MmWaveEnbNetDevice> rxEnb =
472                                                 DynamicCast<MmWaveEnbNetDevice> (rxDevice);
473 
474                 txAntennaNum[0] = sqrt (txMcUe->GetAntennaNum ());
475                 txAntennaNum[1] = sqrt (txMcUe->GetAntennaNum ());
476                 rxAntennaNum[0] = sqrt (rxEnb->GetAntennaNum ());
477                 rxAntennaNum[1] = sqrt (rxEnb->GetAntennaNum ());
478 
479                 \textcolor{keywordflow}{if}(\hyperlink{classns3_1_1MmWave3gppChannel_a5b921c4b6e89174bf383382c1ce6523f}{isAdditionalMmWavePhy}) \textcolor{comment}{//sjkang1125}
480                 txAntennaArray = DynamicCast<AntennaArrayModel> (
481                                         txMcUe->GetMmWavePhy\_2 ()->GetDlSpectrumPhy ()->GetRxAntenna ());
482                 \textcolor{keywordflow}{else}
483                         txAntennaArray = DynamicCast<AntennaArrayModel> (
484                                                                 txMcUe->GetMmWavePhy ()->GetDlSpectrumPhy (
      )->GetRxAntenna ());
485 
486                 rxAntennaArray = DynamicCast<AntennaArrayModel> (
487                                         rxEnb->GetPhy ()->GetDlSpectrumPhy ()->GetRxAntenna ());
488                 locUT = a->GetPosition();
489         \}
490         \textcolor{keywordflow}{else}
491         \{
492                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"enb to enb or ue to ue transmission, skip beamforming a tx "} << a
      ->GetPosition() << \textcolor{stringliteral}{" b rx "} << \hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b}->GetPosition());
493                 \textcolor{keywordflow}{return} rxPsd;
494         \}
495 
496         \textcolor{keywordflow}{if}(txAntennaArray->IsOmniTx() || rxAntennaArray->IsOmniTx() )
497         \{
498                 \textcolor{comment}{//omi transmission, do nothing.}
499                 \textcolor{keywordflow}{return} rxPsd;
500         \}
501 
502         \textcolor{comment}{/*txAntennaNum[0] = 1;}
503 \textcolor{comment}{        txAntennaNum[1] = 1;}
504 \textcolor{comment}{        rxAntennaNum[0] = 1;}
505 \textcolor{comment}{        rxAntennaNum[1] = 1;*/}
506 
507         \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG}(a->GetDistanceFrom(\hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b})!=0, \textcolor{stringliteral}{"the position of tx and rx devices cannot be
       the same"});
508 
509         Vector rxSpeed = \hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b}->GetVelocity();
510         Vector txSpeed = a->GetVelocity();
511         Vector relativeSpeed (rxSpeed.x-txSpeed.x,rxSpeed.y-txSpeed.y,rxSpeed.z-txSpeed.z);
512 
513         \hyperlink{namespacens3_aa42bd408e172586b3b192acfaa36b070}{key\_t} key = std::make\_pair(txDevice,rxDevice);
514         \hyperlink{namespacens3_aa42bd408e172586b3b192acfaa36b070}{key\_t} keyReverse = std::make\_pair(rxDevice,txDevice);
515 
516         std::map< key\_t, Ptr<Params3gpp> >::iterator it = \hyperlink{classns3_1_1MmWave3gppChannel_a31f05f0c8a438b8ce89f29813e863040}{m\_channelMap}.find (key);
517         std::map< key\_t, Ptr<Params3gpp> >::iterator itReverse = \hyperlink{classns3_1_1MmWave3gppChannel_a31f05f0c8a438b8ce89f29813e863040}{m\_channelMap}.find (keyReverse)
      ;
518 
519         Ptr<Params3gpp> channelParams;
520 
521         \textcolor{keywordtype}{bool} reverseLink = \textcolor{keyword}{false};
522 
523         \textcolor{comment}{//Step 2: Assign propagation condition (LOS/NLOS).}
524 
525         \textcolor{keywordtype}{char} condition;
526         \textcolor{keywordflow}{if} (DynamicCast<MmWave3gppPropagationLossModel> (\hyperlink{classns3_1_1MmWave3gppChannel_add8860051acacb1819be2f7321dbd726}{m\_3gppPathloss})!=0)
527         \{
528                 condition = \hyperlink{classns3_1_1MmWave3gppChannel_add8860051acacb1819be2f7321dbd726}{m\_3gppPathloss}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<
      \hyperlink{classMmWave3gppPropagationLossModel}{MmWave3gppPropagationLossModel}> ()
529                                 ->GetChannelCondition(a->GetObject<MobilityModel>(),
      \hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b}->GetObject<MobilityModel>());
530         \}
531         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (DynamicCast<MmWave3gppBuildingsPropagationLossModel> (
      \hyperlink{classns3_1_1MmWave3gppChannel_add8860051acacb1819be2f7321dbd726}{m\_3gppPathloss})!=0)
532         \{
533                 condition = \hyperlink{classns3_1_1MmWave3gppChannel_add8860051acacb1819be2f7321dbd726}{m\_3gppPathloss}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<
      MmWave3gppBuildingsPropagationLossModel> ()
534                                 ->GetChannelCondition(a->GetObject<MobilityModel>(),
      \hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b}->GetObject<MobilityModel>());
535         \}
536         \textcolor{keywordflow}{else}
537         \{
538                 \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR}(\textcolor{stringliteral}{"unkonw pathloss model"});
539         \}
540         \textcolor{keywordtype}{bool} los = \textcolor{keyword}{false};
541         \textcolor{keywordtype}{bool} o2i = \textcolor{keyword}{false};
542         \textcolor{keywordflow}{if}(condition == \textcolor{charliteral}{'l'})
543         \{
544                 los = \textcolor{keyword}{true};
545         \}
546         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(condition == \textcolor{charliteral}{'i'})
547         \{
548                 o2i = \textcolor{keyword}{true};
549         \}
550         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(condition == \textcolor{charliteral}{'s'})
551         \{
552                 \textcolor{comment}{// in this special case, we condiser los + outdoor to indoor.}
553                 los = \textcolor{keyword}{true};
554                 o2i = \textcolor{keyword}{true};
555         \}
556 
557         \textcolor{comment}{//Every m\_updatedPeriod, the channel matrix is deleted and a consistent channel update is
       triggered.}
558         \textcolor{comment}{//When there is a LOS/NLOS switch, a new uncorrelated channel is created.}
559         \textcolor{comment}{//Therefore, LOS/NLOS condition of updating is always consistent with the previous channel.}
560 
561         \textcolor{comment}{//I only update the fowrad channel.}
562         \textcolor{keywordflow}{if} ((it == \hyperlink{classns3_1_1MmWave3gppChannel_a31f05f0c8a438b8ce89f29813e863040}{m\_channelMap}.end () && itReverse == \hyperlink{classns3_1_1MmWave3gppChannel_a31f05f0c8a438b8ce89f29813e863040}{m\_channelMap}.end ()) ||
563                         (it != \hyperlink{classns3_1_1MmWave3gppChannel_a31f05f0c8a438b8ce89f29813e863040}{m\_channelMap}.end () && it->second->m\_channel.size() == 0)||
564                         (it != \hyperlink{classns3_1_1MmWave3gppChannel_a31f05f0c8a438b8ce89f29813e863040}{m\_channelMap}.end () && it->second->m\_los != los))
565         \{
566                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO}(\textcolor{stringliteral}{"Update or create the forward channel"});
567                 \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC}(\textcolor{stringliteral}{"it == m\_channelMap.end () "} << (it == 
      \hyperlink{classns3_1_1MmWave3gppChannel_a31f05f0c8a438b8ce89f29813e863040}{m\_channelMap}.end ()));
568                 \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC}(\textcolor{stringliteral}{"itReverse == m\_channelMap.end () "} << (itReverse == 
      \hyperlink{classns3_1_1MmWave3gppChannel_a31f05f0c8a438b8ce89f29813e863040}{m\_channelMap}.end ()));
569                 \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC}(\textcolor{stringliteral}{"it->second->m\_channel.size() == 0 "} << (it->second->m\_channel.
      size() == 0));
570                 \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC}(\textcolor{stringliteral}{"it->second->m\_los != los"} << (it->second->m\_los != los));
571                 
572                 \textcolor{comment}{//Step 1: The parameters are configured in the example code.}
573                 \textcolor{comment}{/*make sure txAngle rxAngle exist, i.e., the position of tx and rx cannot be the same*/}
574                 Angles txAngle (\hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b}->GetPosition (), a->GetPosition ());
575                 Angles rxAngle (a->GetPosition (), \hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b}->GetPosition ());
576 
577                 \textcolor{comment}{//Step 2: Assign propagation condition (LOS/NLOS).}
578                 \textcolor{comment}{//los, o2i condition is computed above.}
579 
580                 \textcolor{comment}{//Step 3: The propagation loss is handled in the mmWavePropagationLossModel class.}
581 
582 
583                 \textcolor{keywordtype}{double} \hyperlink{lte__link__budget__x2__handover__measures_8m_a9336ebf25087d91c818ee6e9ec29f8c1}{x} = a->GetPosition().x-\hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b}->GetPosition().x;
584                 \textcolor{keywordtype}{double} y = a->GetPosition().y-\hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b}->GetPosition().y;
585                 \textcolor{keywordtype}{double} distance2D = sqrt (x*x +y*y);
586                 \textcolor{keywordtype}{double} hUT, hBS;
587                 \textcolor{keywordflow}{if}(rxUe != 0 || rxMcUe != 0)
588                 \{
589                         hUT = \hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b}->GetPosition().z;
590                         hBS = a->GetPosition().z;
591                 \}
592                 \textcolor{keywordflow}{else}
593                 \{
594                         hUT = a->GetPosition().z;
595                         hBS = \hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b}->GetPosition().z;
596                 \}
597                 \textcolor{comment}{//Draw parameters from table 7.5-6 and 7.5-7 to 7.5-10.}
598                 Ptr<ParamsTable> table3gpp = \hyperlink{classns3_1_1MmWave3gppChannel_a4d31cc933c700d3b6c405b47765a2b02}{Get3gppTable}(los, o2i, hBS, hUT, distance2D);
599 
600                 \textcolor{comment}{// Step 4-11 are performed in function GetNewChannel()}
601                 \textcolor{keywordflow}{if}((it == \hyperlink{classns3_1_1MmWave3gppChannel_a31f05f0c8a438b8ce89f29813e863040}{m\_channelMap}.end () && itReverse == 
      \hyperlink{classns3_1_1MmWave3gppChannel_a31f05f0c8a438b8ce89f29813e863040}{m\_channelMap}.end ()) ||
602                                 (it != \hyperlink{classns3_1_1MmWave3gppChannel_a31f05f0c8a438b8ce89f29813e863040}{m\_channelMap}.end () && it->second->m\_channel.size() == 0
      ))
603                 \{
604                         \textcolor{comment}{//delete the channel parameter to cause the channel to be updated again.}
605                         \textcolor{comment}{//The m\_updatePeriod can be configured to be relatively large in order to disable
       updates.}
606                         \textcolor{keywordflow}{if}(\hyperlink{classns3_1_1MmWave3gppChannel_a2844f8c7e7373cb777384eaf0e8a7b11}{m\_updatePeriod}.\hyperlink{classns3_1_1Time_aba3428a8b6c4c8d9014ce44145081f34}{GetMilliSeconds}() > 0)
607                         \{
608                                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO}(\textcolor{stringliteral}{"Time "} << \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now}().GetSeconds
      () << \textcolor{stringliteral}{" schedule delete for a "} << a->GetPosition() << \textcolor{stringliteral}{" b "} << \hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b}->GetPosition());
609                                 \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (
      \hyperlink{classns3_1_1MmWave3gppChannel_a2844f8c7e7373cb777384eaf0e8a7b11}{m\_updatePeriod}, &\hyperlink{classns3_1_1MmWave3gppChannel_a3ec4e2d8d84d7876581a00fa5174a1a5}{MmWave3gppChannel::DeleteChannel},\textcolor{keyword}{this},a,
      \hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b});
610                         \}
611                 \}
612 
613                 \textcolor{keywordtype}{double} distance3D = a->GetDistanceFrom(\hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b});
614 
615                 \textcolor{keywordtype}{bool} channelUpdate = \textcolor{keyword}{false};
616                 \textcolor{keywordflow}{if}(it != \hyperlink{classns3_1_1MmWave3gppChannel_a31f05f0c8a438b8ce89f29813e863040}{m\_channelMap}.end () && it->second->m\_channel.size() == 0)
617                 \{
618                         \textcolor{comment}{//if the channel map is not empty, we only update the channel.}
619                         \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Update forward channel consistently between device "} << 
      a << \textcolor{stringliteral}{" "} << \hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b});
620                         it->second->m\_locUT = locUT;
621                         it->second->m\_los = los;
622                         it->second->m\_o2i = o2i;
623                         channelParams = \hyperlink{classns3_1_1MmWave3gppChannel_a765f45f9d98c15655c8ea6288e86f111}{UpdateChannel}(it->second, table3gpp, txAntennaArray, 
      rxAntennaArray,
624                                         txAntennaNum, rxAntennaNum, rxAngle, txAngle);
625                         it->second->m\_dis3D = distance3D;
626                         it->second->m\_dis2D = distance2D;
627                         it->second->m\_speed = relativeSpeed;
628                         it->second->m\_generatedTime = \hyperlink{group__simulator_gac3635e2e87f7ce316c89290ee1b01d0d}{Now}();
629                         it->second->m\_preLocUT = locUT;
630                         channelUpdate = \textcolor{keyword}{true};
631                 \}
632                 \textcolor{keywordflow}{else}
633                 \{
634                         \textcolor{comment}{//if the channel map is empty, we create a new channel.}
635                         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO}(\textcolor{stringliteral}{"Create new channel"});
636                         channelParams = \hyperlink{classns3_1_1MmWave3gppChannel_aef5bd6982d739715d7bbba3166e75116}{GetNewChannel}(table3gpp, locUT, los, o2i, 
      txAntennaArray, rxAntennaArray,
637                                         txAntennaNum, rxAntennaNum, rxAngle, txAngle, relativeSpeed, 
      distance2D, distance3D);
638                 \}
639                 \textcolor{comment}{// the connected pair cannot be trusted anymore! Not initialized at the beginning}
640                 \textcolor{comment}{// since the UE may connect at any mmWave eNB}
641                 \textcolor{comment}{// we can look for if the eNB is the target eNB in the UE}
642                 \textcolor{keywordtype}{bool} connectedPair = \textcolor{keyword}{false};
643                 \textcolor{keywordflow}{if}(downlink)
644                 \{
645                         Ptr<MmWaveEnbNetDevice> enbTx = DynamicCast<MmWaveEnbNetDevice>(txDevice);
646                         Ptr<MmWaveUeNetDevice> ueRx = DynamicCast<MmWaveUeNetDevice>(rxDevice);
647                         \textcolor{keywordflow}{if}(enbTx == ueRx->GetTargetEnb())
648                         \{
649                                 connectedPair = \textcolor{keyword}{true};
650                         \}       
651                 \}
652                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(downlinkMc)
653                 \{
654                         Ptr<MmWaveEnbNetDevice> enbTx = DynamicCast<MmWaveEnbNetDevice>(txDevice);
655                         Ptr<McUeNetDevice> ueRx = DynamicCast<McUeNetDevice>(rxDevice);
656                         \textcolor{keywordflow}{if}(enbTx == ueRx->GetMmWaveTargetEnb())
657                         \{
658                                 connectedPair = \textcolor{keyword}{true};
659                         \}       
660                 \}
661                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(uplink)
662                 \{
663                         Ptr<MmWaveUeNetDevice> ueTx = DynamicCast<MmWaveUeNetDevice>(txDevice);
664                         Ptr<MmWaveEnbNetDevice> enbRx = DynamicCast<MmWaveEnbNetDevice>(rxDevice);
665                         \textcolor{keywordflow}{if}(enbRx == ueTx->GetTargetEnb())
666                         \{
667                                 connectedPair = \textcolor{keyword}{true};
668                         \}       
669                 \}
670                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(uplinkMc)
671                 \{
672                         Ptr<McUeNetDevice> ueTx = DynamicCast<McUeNetDevice>(txDevice);
673                         Ptr<MmWaveEnbNetDevice> enbRx = DynamicCast<MmWaveEnbNetDevice>(rxDevice);
674                         \textcolor{keywordflow}{if}(enbRx == ueTx->GetMmWaveTargetEnb())
675                         \{
676                                 connectedPair = \textcolor{keyword}{true};
677                         \}       
678                 \}
679 
680                 \textcolor{comment}{//std::map< key\_t, int >::iterator it1 = m\_connectedPair.find (key);}
681                 \textcolor{keywordflow}{if}(connectedPair || \hyperlink{classns3_1_1MmWave3gppChannel_a2d5a32e24f0d795c5ed210f8c38f4e9b}{m\_forceInitialBfComputation} || channelUpdate
      )
682                 \textcolor{comment}{// this is true for connected devices at each transmission,}
683                 \textcolor{comment}{// and for non-connected devices at each channel update or at the beginning of the
       simulation}
684                 \{
685                         \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG}(\textcolor{stringliteral}{"connectedPair "} << connectedPair << \textcolor{stringliteral}{"
       m\_forceInitialBfComputation "} << \hyperlink{classns3_1_1MmWave3gppChannel_a2d5a32e24f0d795c5ed210f8c38f4e9b}{m\_forceInitialBfComputation} << 
686                                 \textcolor{stringliteral}{" channelUpdate "} << channelUpdate);
687                         \textcolor{keywordflow}{if}(\hyperlink{classns3_1_1MmWave3gppChannel_ac973f52321b6843ce42f036620af63e8}{m\_cellScan})
688                         \{
689                                 \hyperlink{classns3_1_1MmWave3gppChannel_ac361c14154934a6e7633a0a8c561e788}{BeamSearchBeamforming} (rxPsd, channelParams,
      txAntennaArray,rxAntennaArray, txAntennaNum, rxAntennaNum);
690                         \}
691                         \textcolor{keywordflow}{else}
692                         \{
693                                 \hyperlink{classns3_1_1MmWave3gppChannel_a1ef519a7796d45ef5270e465664fd1bb}{LongTermCovMatrixBeamforming} (channelParams);
694                         \}
695                         txAntennaArray->SetBeamformingVector (channelParams->m\_txW, rxDevice);
696                         rxAntennaArray->SetBeamformingVector (channelParams->m\_rxW, txDevice);
697                 \}
698                 \textcolor{keywordflow}{else}
699                 \{
700                         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO}(\textcolor{stringliteral}{"Not a connected pair"});
701                         channelParams->m\_txW = txAntennaArray->GetBeamformingVector();
702                         channelParams->m\_rxW = rxAntennaArray->GetBeamformingVector();
703                         \textcolor{keywordflow}{if}(channelParams->m\_txW.size() == 0 || channelParams->m\_rxW.size() == 0)
704                         \{
705                                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO}(\textcolor{stringliteral}{"channelParams->m\_txW.size() == 0 "} << (
      channelParams->m\_txW.size() == 0));
706                                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO}(\textcolor{stringliteral}{"channelParams->m\_rxW.size() == 0 "} << (
      channelParams->m\_rxW.size() == 0));
707                                 \hyperlink{classns3_1_1MmWave3gppChannel_a31f05f0c8a438b8ce89f29813e863040}{m\_channelMap}[key] = channelParams;
708                                 \textcolor{keywordflow}{return} rxPsd;
709                         \}
710                 \}
711 
712                 \hyperlink{classns3_1_1MmWave3gppChannel_ab1cacdfc31ed5b10bc2dc5206153ec57}{CalLongTerm} (channelParams);
713                 \hyperlink{classns3_1_1MmWave3gppChannel_a31f05f0c8a438b8ce89f29813e863040}{m\_channelMap}[key] = channelParams;
714         \}
715         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (itReverse == \hyperlink{classns3_1_1MmWave3gppChannel_a31f05f0c8a438b8ce89f29813e863040}{m\_channelMap}.end ()) \textcolor{comment}{//Find channel matrix in the forward link}
716         \{
717                 channelParams = (*it).second;
718         \}
719         \textcolor{keywordflow}{else} \textcolor{comment}{//Find channel matrix in the Reverse link}
720         \{
721                 reverseLink = \textcolor{keyword}{true};
722                 channelParams = (*itReverse).second;
723         \}
724 
725         Ptr<SpectrumValue> bfPsd = \hyperlink{classns3_1_1MmWave3gppChannel_acd8bc1db086ba52b0e77ed71a6ccb56d}{CalBeamformingGain}(rxPsd, channelParams, relativeSpeed
      );
726 
727         SpectrumValue bfGain = (*bfPsd)/(*rxPsd);
728         uint8\_t nbands = bfGain.GetSpectrumModel ()->GetNumBands ();
729         \textcolor{keywordflow}{if} (reverseLink == \textcolor{keyword}{false})
730         \{
731                 \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"****** DL BF gain == "} << \hyperlink{namespacens3_afad5475661952172fe6ef1260360dad8}{Sum} (bfGain)/nbands << \textcolor{stringliteral}{" RX PSD "} 
      << \hyperlink{namespacens3_afad5475661952172fe6ef1260360dad8}{Sum}(*rxPsd)/nbands); \textcolor{comment}{// print avg bf gain}
732         \}
733         \textcolor{keywordflow}{else}
734         \{
735                 \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"****** UL BF gain == "} << \hyperlink{namespacens3_afad5475661952172fe6ef1260360dad8}{Sum} (bfGain)/nbands << \textcolor{stringliteral}{" RX PSD "} 
      << \hyperlink{namespacens3_afad5475661952172fe6ef1260360dad8}{Sum}(*rxPsd)/nbands);
736         \}
737         \textcolor{keywordflow}{return} bfPsd;
738 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 11




Here is the caller graph for this function\+:
% FIG 12


\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{Do\+Dispose()}{DoDispose()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mm\+Wave3gpp\+Channel\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MmWave3gppChannel_a04d461e913a8f5a00854c3bc9db6dce3}{}\label{classns3_1_1MmWave3gppChannel_a04d461e913a8f5a00854c3bc9db6dce3}
Destructor implementation.

This method is called by \hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose()} or by the \hyperlink{classns3_1_1Object}{Object}\textquotesingle{}s destructor, whichever comes first.

Subclasses are expected to implement their real destruction code in an overriden version of this method and chain up to their parent\textquotesingle{}s implementation once they are done. {\itshape i.\+e}, for simplicity, the destructor of every subclass should be empty and its content should be moved to the associated \hyperlink{classns3_1_1MmWave3gppChannel_a04d461e913a8f5a00854c3bc9db6dce3}{Do\+Dispose()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1SpectrumPropagationLossModel_a26259057c97ea893d472b5ac52d6649e}{ns3\+::\+Spectrum\+Propagation\+Loss\+Model}.


\begin{DoxyCode}
222 \{
223         \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
224 \}
\end{DoxyCode}
\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!Get3gpp\+Table@{Get3gpp\+Table}}
\index{Get3gpp\+Table@{Get3gpp\+Table}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{Get3gpp\+Table(bool los, bool o2i, double h\+B\+S, double h\+U\+T, double distance2\+D) const }{Get3gppTable(bool los, bool o2i, double hBS, double hUT, double distance2D) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Params\+Table} $>$ ns3\+::\+Mm\+Wave3gpp\+Channel\+::\+Get3gpp\+Table (
\begin{DoxyParamCaption}
\item[{bool}]{los, }
\item[{bool}]{o2i, }
\item[{double}]{h\+BS, }
\item[{double}]{h\+UT, }
\item[{double}]{distance2D}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWave3gppChannel_a4d31cc933c700d3b6c405b47765a2b02}{}\label{classns3_1_1MmWave3gppChannel_a4d31cc933c700d3b6c405b47765a2b02}
Returns the \hyperlink{structns3_1_1ParamsTable}{Params\+Table} with the parameters of TR 38.\+900 Table 7.\+5-\/6 that apply to a certain scenario  the los condition  the o2i condition  the BS height (i.\+e., e\+NB)  the UT height (i.\+e., UE)  the 2D distance \begin{DoxyReturn}{Returns}
the \hyperlink{structns3_1_1ParamsTable}{Params\+Table} structure 
\end{DoxyReturn}

\begin{DoxyCode}
1003 \{
1004         \textcolor{keywordtype}{double} fcGHz = \hyperlink{classns3_1_1MmWave3gppChannel_a50988766af948ea236ce24718a6dca7d}{m\_phyMacConfig}->\hyperlink{classns3_1_1MmWavePhyMacCommon_a0850d2e37c7075b9bce242723b722019}{GetCenterFrequency} ()/1e9;
1005         Ptr<ParamsTable> table3gpp = CreateObject<ParamsTable> ();
1006         \textcolor{comment}{// table3gpp includes the following parameters:}
1007         \textcolor{comment}{// numOfCluster, raysPerCluster, uLgDS, sigLgDS, uLgASD, sigLgASD,}
1008         \textcolor{comment}{// uLgASA, sigLgASA, uLgZSA, sigLgZSA, uLgZSD, sigLgZSD, offsetZOD,}
1009         \textcolor{comment}{// cDS, cASD, cASA, cZSA, uK, sigK, rTau, shadowingStd}
1010 
1011         \textcolor{comment}{//In NLOS case, parameter uK and sigK are not used and 0 is passed into the SetParams() function.}
1012         \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1MmWave3gppChannel_ae1f263fbc87682905d563221343e4447}{m\_scenario} == \textcolor{stringliteral}{"RMa"})
1013         \{
1014                 \textcolor{comment}{//For RMa, the outdoor LOS/NLOS and o2i LOS/NLOS is the same.}
1015                 \textcolor{keywordflow}{if}(los)
1016                 \{
1017                         \textcolor{comment}{//3GPP mentioned that 3.91 ns should be used when the Cluster DS (cDS) entry is
       N/A.}
1018                         table3gpp->SetParams(11, 20, -7.49, 0.55, 0.90, 0.38, 1.52, 0.24, 0.60, 0.16,
1019                                         0.3, 0.4, 0, 3.91e-9, 2, 3, 3, 7, 4, 3.8, 3);
1020                         \textcolor{keywordflow}{for} (uint8\_t row = 0; row < 7; row++)
1021                         \{
1022                                 \textcolor{keywordflow}{for} (uint8\_t column = 0; column < 7; column++)
1023                                 \{
1024                                         table3gpp->m\_sqrtC[row][column] = 
      \hyperlink{namespacens3_a94d0f9da9e007c8579b09abe4c003e51}{sqrtC\_RMa\_LOS}[row][column];
1025                                 \}
1026                         \}
1027                 \}
1028                 \textcolor{keywordflow}{else}
1029                 \{
1030                         \textcolor{keywordtype}{double} offsetZod = atan((35-5)/distance2D)-atan((35-1.5)/distance2D);
1031                         table3gpp->SetParams(10, 20, -7.43, 0.48, 0.95, 0.45, 1.52, 0.13, 0.88, 0.16,
1032                                         0.3, 0.49, offsetZod, 3.91e-9, 2, 3, 3, 0, 0, 1.7 ,3);
1033                         \textcolor{keywordflow}{for} (uint8\_t row = 0; row < 6; row++)
1034                         \{
1035                                 \textcolor{keywordflow}{for} (uint8\_t column = 0; column < 6; column++)
1036                                 \{
1037                                         table3gpp->m\_sqrtC[row][column] = 
      \hyperlink{namespacens3_a5956658e14c03e840f117722cf0bbbb6}{sqrtC\_RMa\_NLOS}[row][column];
1038                                 \}
1039                         \}
1040                 \}
1041         \}
1042         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1MmWave3gppChannel_ae1f263fbc87682905d563221343e4447}{m\_scenario} == \textcolor{stringliteral}{"UMa"})
1043         \{
1044                 \textcolor{keywordflow}{if}(los && !o2i)
1045                 \{
1046                         \textcolor{keywordtype}{double} uLgZSD = \hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{std::max}(-0.5, -2.1*distance2D/1000-0.01*(hUT-1.5)+0.75);
1047                         \textcolor{keywordtype}{double} cDs = \hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{std::max}(0.25, -3.4084*log10(fcGHz)+6.5622)*1e-9;
1048                         table3gpp->SetParams(12, 20, -6.955-0.0963*log10(fcGHz), 0.66, 1.06+0.1114*log10(
      fcGHz),
1049                                         0.28, 1.81, 0.20, 0.95, 0.16, uLgZSD, 0.40, 0, cDs, 5, 11, 7, 9, 3.
      5, 2.5, 3);
1050                         \textcolor{keywordflow}{for} (uint8\_t row = 0; row < 7; row++)
1051                         \{
1052                                 \textcolor{keywordflow}{for} (uint8\_t column = 0; column < 7; column++)
1053                                 \{
1054                                         table3gpp->m\_sqrtC[row][column] = 
      \hyperlink{namespacens3_a6f06e6813ea09282bd2323f4499220b5}{sqrtC\_UMa\_LOS}[row][column];
1055                                 \}
1056                         \}
1057                 \}
1058                 \textcolor{keywordflow}{else}
1059                 \{
1060                         \textcolor{keywordtype}{double} uLgZSD = \hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{std::max}(-0.5, -2.1*distance2D/1000-0.01*(hUT-1.5)+0.9);
1061 
1062                         \textcolor{keywordtype}{double} afc = 0.208*log10(fcGHz)-0.782;
1063                         \textcolor{keywordtype}{double} bfc = 25;
1064                         \textcolor{keywordtype}{double} cfc = -0.13*log10(fcGHz)+2.03;
1065                         \textcolor{keywordtype}{double} efc = 7.66*log10(fcGHz)-5.96;
1066 
1067                         \textcolor{keywordtype}{double} offsetZOD = efc-std::pow(10, afc*log10(\hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{std::max}(bfc,distance2D))+cfc
      );
1068                         \textcolor{keywordtype}{double} cDS = \hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{std::max}(0.25, -3.4084*log10(fcGHz)+6.5622)*1e-9;
1069 
1070                         \textcolor{keywordflow}{if} (!los && !o2i)
1071                         \{
1072                                 table3gpp->SetParams(20, 20, -6.28-0.204*log10(fcGHz), 0.39, 1.5-0.1144*
      log10(fcGHz),
1073                                                 0.28, 2.08-0.27*log10(fcGHz), 0.11, -0.3236*log10(fcGHz)+1.
      512, 0.16, uLgZSD,
1074                                                 0.49, offsetZOD, cDS, 2, 15, 7, 0, 0, 2.3, 3);
1075                                 \textcolor{keywordflow}{for} (uint8\_t row = 0; row < 6; row++)
1076                                 \{
1077                                         \textcolor{keywordflow}{for} (uint8\_t column = 0; column < 6; column++)
1078                                         \{
1079                                                 table3gpp->m\_sqrtC[row][column] = 
      \hyperlink{namespacens3_ad5e4bf11a5acb312f0bc8a5326e39df2}{sqrtC\_UMa\_NLOS}[row][column];
1080                                         \}
1081                                 \}
1082                         \}
1083                         \textcolor{keywordflow}{else}\textcolor{comment}{//(o2i)}
1084                         \{
1085                                 table3gpp->SetParams(12, 20, -6.62, 0.32, 1.25, 0.42, 1.76, 0.16, 1.01, 0.4
      3,
1086                                                 uLgZSD, 0.49, offsetZOD, 11e-9, 5, 20, 6, 0, 0, 2.2, 4);
1087                                 \textcolor{keywordflow}{for} (uint8\_t row = 0; row < 6; row++)
1088                                 \{
1089                                         \textcolor{keywordflow}{for} (uint8\_t column = 0; column < 6; column++)
1090                                         \{
1091                                                 table3gpp->m\_sqrtC[row][column] = 
      \hyperlink{namespacens3_a39f2ef4de462777b91687b3f7f9d72f8}{sqrtC\_UMa\_O2I}[row][column];
1092                                         \}
1093                                 \}
1094 
1095                         \}
1096 
1097                 \}
1098 
1099         \}
1100         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1MmWave3gppChannel_ae1f263fbc87682905d563221343e4447}{m\_scenario} == \textcolor{stringliteral}{"UMi-StreetCanyon"})
1101         \{
1102                 \textcolor{keywordflow}{if}(los && !o2i)
1103                 \{
1104                         \textcolor{keywordtype}{double} uLgZSD = \hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{std::max}(-0.21, -14.8*distance2D/1000+0.01*std::abs(hUT-hBS
      )+0.83);
1105                         table3gpp->SetParams(12, 20, -0.24*log10(1+fcGHz)-7.14, 0.38, -0.05*log10(1+fcGHz)+
      1.21, 0.41,
1106                                         -0.08*log10(1+fcGHz)+1.73, 0.014*log10(1+fcGHz)+0.28, -0.1*log10(1+
      fcGHz)+0.73, -0.04*log10(1+fcGHz)+0.34,
1107                                         uLgZSD, 0.35, 0, 5e-9, 3, 17, 7, 9, 5, 3, 3);
1108                         \textcolor{keywordflow}{for} (uint8\_t row = 0; row < 7; row++)
1109                         \{
1110                                 \textcolor{keywordflow}{for} (uint8\_t column = 0; column < 7; column++)
1111                                 \{
1112                                         table3gpp->m\_sqrtC[row][column] = 
      \hyperlink{namespacens3_a34f94bc21850882c7e480c4a8bc5036d}{sqrtC\_UMi\_LOS}[row][column];
1113                                 \}
1114                         \}
1115                 \}
1116                 \textcolor{keywordflow}{else}
1117                 \{
1118                         \textcolor{keywordtype}{double} uLgZSD = \hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{std::max}(-0.5, -3.1*distance2D/1000+0.01*
      \hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{std::max}(hUT-hBS,0.0)+0.2);
1119                         \textcolor{keywordtype}{double} offsetZOD = -1*std::pow(10, -1.5*log10(\hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{std::max}(10.0, distance2D))+3
      .3);
1120                         \textcolor{keywordflow}{if} (!los && !o2i)
1121                         \{
1122                                 table3gpp->SetParams(19, 20, -0.24*log10(1+fcGHz)-6.83, 0.16*log10(1+fcGHz)
      +0.28, -0.23*log10(1+fcGHz)+1.53,
1123                                                 0.11*log10(1+fcGHz)+0.33, -0.08*log10(1+fcGHz)+1.81, 0.05*
      log10(1+fcGHz)+0.3,
1124                                                 -0.04*log10(1+fcGHz)+0.92, -0.07*log10(1+fcGHz)+0.41, 
      uLgZSD, 0.35, offsetZOD,
1125                                                 11e-9, 10, 22, 7, 0, 0, 2.1, 3);
1126                                 \textcolor{keywordflow}{for} (uint8\_t row = 0; row < 6; row++)
1127                                 \{
1128                                         \textcolor{keywordflow}{for} (uint8\_t column = 0; column < 6; column++)
1129                                         \{
1130                                                 table3gpp->m\_sqrtC[row][column] = 
      \hyperlink{namespacens3_a6fd885aaf93f9727bfb2331d67dffec7}{sqrtC\_UMi\_NLOS}[row][column];
1131                                         \}
1132                                 \}
1133                         \}
1134                         \textcolor{keywordflow}{else}\textcolor{comment}{//(o2i)}
1135                         \{
1136                                 table3gpp->SetParams(12, 20, -6.62, 0.32, 1.25, 0.42, 1.76, 0.16, 1.01, 0.4
      3,
1137                                                 uLgZSD, 0.35, offsetZOD, 11e-9, 5, 20, 6, 0, 0, 2.2, 4);
1138                                 \textcolor{keywordflow}{for} (uint8\_t row = 0; row < 6; row++)
1139                                 \{
1140                                         \textcolor{keywordflow}{for} (uint8\_t column = 0; column < 6; column++)
1141                                         \{
1142                                                 table3gpp->m\_sqrtC[row][column] = 
      \hyperlink{namespacens3_ac79a159d07651583d79482e4429cf74a}{sqrtC\_UMi\_O2I}[row][column];
1143                                         \}
1144                                 \}
1145                         \}
1146                 \}
1147         \}
1148         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1MmWave3gppChannel_ae1f263fbc87682905d563221343e4447}{m\_scenario} == \textcolor{stringliteral}{"InH-OfficeMixed"}||\hyperlink{classns3_1_1MmWave3gppChannel_ae1f263fbc87682905d563221343e4447}{m\_scenario} == \textcolor{stringliteral}{"InH-OfficeOpen"})
1149         \{
1150                 \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (!o2i, \textcolor{stringliteral}{"The indoor scenario does out support outdoor to indoor"})
      ;
1151                 \textcolor{keywordflow}{if}(los)
1152                 \{
1153                         table3gpp->SetParams(8, 20, -0.01*log10(1+fcGHz)-7.79, -0.16*log10(1+fcGHz)+0.50, 1
      .60, 0.18,
1154                                         -0.19*log10(1+fcGHz)+1.86, 0.12*log10(1+fcGHz), -0.26*log10(1+fcGHz
      )+1.21, -0.04*log10(1+fcGHz)+0.17,
1155                                         -1.43*log10(1+fcGHz)+2.25, 0.13*log10(1+fcGHz)+0.15, 0, 3.91e-9, 7,
       -6.2*log10(1+fcGHz)+16.72,
1156                                         -3.85*log10(1+fcGHz)+10.28, 0.84*log10(1+fcGHz)+2.12, -0.58*log10(1
      +fcGHz)+6.19, 2.15, 6);
1157                         \textcolor{keywordflow}{for} (uint8\_t row = 0; row < 7; row++)
1158                         \{
1159                                 \textcolor{keywordflow}{for} (uint8\_t column = 0; column < 7; column++)
1160                                 \{
1161                                         table3gpp->m\_sqrtC[row][column] = 
      \hyperlink{namespacens3_a39c2b4fa4d7bd533a6b2ecfa96b848ee}{sqrtC\_office\_LOS}[row][column];
1162                                 \}
1163                         \}
1164                 \}
1165                 \textcolor{keywordflow}{else}
1166                 \{
1167                         table3gpp->SetParams(10, 20, -0.28*log10(1+fcGHz)-7.29, 0.1*log10(1+fcGHz)+0.11, 1.
      49, 0.17,
1168                                         -0.11*log10(1+fcGHz)+1.8, 0.12*log10(1+fcGHz), -0.15*log10(1+fcGHz)
      +1.04, -0.09*log10(1+fcGHz)+0.24,
1169                                         1.37, 0.38, 0, 3.91e-9, 3, -13.0*log10(1+fcGHz)+30.53, -3.72*log10(
      1+fcGHz)+10.25, 0, 0, 1.84, 3);
1170                         \textcolor{keywordflow}{for} (uint8\_t row = 0; row < 6; row++)
1171                         \{
1172                                 \textcolor{keywordflow}{for} (uint8\_t column = 0; column < 6; column++)
1173                                 \{
1174                                         table3gpp->m\_sqrtC[row][column] = 
      \hyperlink{namespacens3_acc73441dd0287914f581fca4a7b36f3c}{sqrtC\_office\_NLOS}[row][column];
1175                                 \}
1176                         \}
1177                 \}
1178         \}
1179         \textcolor{keywordflow}{else}
1180         \{
1181                 \textcolor{comment}{//Note that the InH-ShoppingMall scenario is not given in the table 7.5-6}
1182                 \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR}(\textcolor{stringliteral}{"unkonw scenarios"});
1183         \}
1184 
1185         \textcolor{keywordflow}{return} table3gpp;
1186 
1187 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13




Here is the caller graph for this function\+:
% FIG 14


\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!Get\+Configuration\+Parameters@{Get\+Configuration\+Parameters}}
\index{Get\+Configuration\+Parameters@{Get\+Configuration\+Parameters}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{Get\+Configuration\+Parameters(void) const }{GetConfigurationParameters(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Mm\+Wave\+Phy\+Mac\+Common} $>$ ns3\+::\+Mm\+Wave3gpp\+Channel\+::\+Get\+Configuration\+Parameters (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1MmWave3gppChannel_a8ba423399c2109b66c4d63b201ae5794}{}\label{classns3_1_1MmWave3gppChannel_a8ba423399c2109b66c4d63b201ae5794}
Get the \hyperlink{classns3_1_1MmWavePhyMacCommon}{Mm\+Wave\+Phy\+Mac\+Common} object with the parameters of the scenario \begin{DoxyReturn}{Returns}
a pointer to the \hyperlink{classns3_1_1MmWavePhyMacCommon}{Mm\+Wave\+Phy\+Mac\+Common} configuration 
\end{DoxyReturn}

\begin{DoxyCode}
234 \{
235         \textcolor{keywordflow}{return} \hyperlink{classns3_1_1MmWave3gppChannel_a50988766af948ea236ce24718a6dca7d}{m\_phyMacConfig};
236 \}
\end{DoxyCode}
\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!Get\+New\+Channel@{Get\+New\+Channel}}
\index{Get\+New\+Channel@{Get\+New\+Channel}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{Get\+New\+Channel(\+Ptr$<$ Params\+Table $>$ table3gpp, Vector loc\+U\+T, bool los, bool o2i, Ptr$<$ Antenna\+Array\+Model $>$ tx\+Antenna, Ptr$<$ Antenna\+Array\+Model $>$ rx\+Antenna, uint8\+\_\+t $\ast$tx\+Antenna\+Num, uint8\+\_\+t $\ast$rx\+Antenna\+Num, Angles \&rx\+Angle, Angles \&tx\+Angle, Vector speed, double dis2\+D, double dis3\+D) const }{GetNewChannel(Ptr< ParamsTable > table3gpp, Vector locUT, bool los, bool o2i, Ptr< AntennaArrayModel > txAntenna, Ptr< AntennaArrayModel > rxAntenna, uint8_t *txAntennaNum, uint8_t *rxAntennaNum, Angles &rxAngle, Angles &txAngle, Vector speed, double dis2D, double dis3D) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Params3gpp} $>$ ns3\+::\+Mm\+Wave3gpp\+Channel\+::\+Get\+New\+Channel (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Params\+Table} $>$}]{table3gpp, }
\item[{Vector}]{loc\+UT, }
\item[{bool}]{los, }
\item[{bool}]{o2i, }
\item[{{\bf Ptr}$<$ {\bf Antenna\+Array\+Model} $>$}]{tx\+Antenna, }
\item[{{\bf Ptr}$<$ {\bf Antenna\+Array\+Model} $>$}]{rx\+Antenna, }
\item[{uint8\+\_\+t $\ast$}]{tx\+Antenna\+Num, }
\item[{uint8\+\_\+t $\ast$}]{rx\+Antenna\+Num, }
\item[{{\bf Angles} \&}]{rx\+Angle, }
\item[{{\bf Angles} \&}]{tx\+Angle, }
\item[{Vector}]{speed, }
\item[{double}]{dis2D, }
\item[{double}]{dis3D}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWave3gppChannel_aef5bd6982d739715d7bbba3166e75116}{}\label{classns3_1_1MmWave3gppChannel_aef5bd6982d739715d7bbba3166e75116}
Get a new realization of the channel  the \hyperlink{structns3_1_1ParamsTable}{Params\+Table} for the specific scenario  the location of UT  the los condition  the o2i condition  the Array\+Antenna\+Model for the tx\+Antenna  the Array\+Antenna\+Model for the rx\+Antenna  the number of tx\+Antenna per row  the number of rx\+Antenna per row  the rx\+Angle  the tx\+Angle  the relative speed between tx and rx  the 2D distance between tx and rx  the 3D distance between tx and rx \begin{DoxyReturn}{Returns}
the channel realization in a \hyperlink{structns3_1_1Params3gpp}{Params3gpp} object 
\end{DoxyReturn}

\begin{DoxyCode}
1208 \{
1209         uint8\_t numOfCluster = table3gpp->m\_numOfCluster;
1210         uint8\_t raysPerCluster = table3gpp->m\_raysPerCluster;
1211         Ptr<Params3gpp> channelParams = Create<Params3gpp> ();
1212         \textcolor{comment}{//for new channel, the previous and current location is the same.}
1213         channelParams->m\_preLocUT = locUT;
1214         channelParams->m\_locUT = locUT;
1215         channelParams->m\_los = los;
1216         channelParams->m\_o2i = o2i;
1217         channelParams->m\_generatedTime = \hyperlink{group__simulator_gac3635e2e87f7ce316c89290ee1b01d0d}{Now}();
1218         channelParams->m\_speed = \hyperlink{mmwave-amc-test_8cc_a6dc6e6f3c75c509ce943163afb5dade7}{speed};
1219         channelParams->m\_dis2D = dis2D;
1220         channelParams->m\_dis3D = dis3D;
1221         \textcolor{comment}{//Step 4: Generate large scale parameters. All LSPS are uncorrelated.}
1222         \hyperlink{namespacens3_aa6f1edf6566ca6afec613bc6e40240ea}{doubleVector\_t} LSPsIndep, LSPs;
1223         uint8\_t paramNum;
1224         \textcolor{keywordflow}{if}(los)
1225         \{
1226                 paramNum = 7;
1227         \}
1228         \textcolor{keywordflow}{else}
1229         \{
1230                 paramNum = 6;
1231         \}
1232         \textcolor{comment}{//Generate paramNum independent LSPs.}
1233         \textcolor{keywordflow}{for} (uint8\_t iter = 0; iter < paramNum; iter++)
1234         \{
1235                 LSPsIndep.push\_back(\hyperlink{classns3_1_1MmWave3gppChannel_ac2e02ebacc72ed96518d785f2dc87c57}{m\_normalRv}->\hyperlink{classns3_1_1NormalRandomVariable_a0134d131477bc439cc6ff7cbe84b03a9}{GetValue}());
1236         \}
1237         \textcolor{keywordflow}{for} (uint8\_t row = 0; row < paramNum; row++)
1238         \{
1239                 \textcolor{keywordtype}{double} temp = 0;
1240                 \textcolor{keywordflow}{for} (uint8\_t column = 0; column < paramNum; column++)
1241                 \{
1242                         temp += table3gpp->m\_sqrtC[row][column]*LSPsIndep.at(column);
1243                 \}
1244                 LSPs.push\_back(temp);
1245         \}
1246 
1247         \textcolor{comment}{/*std::cout << "LSPsIndep:";}
1248 \textcolor{comment}{        for (uint8\_t i = 0; i < paramNum; i++)}
1249 \textcolor{comment}{        \{}
1250 \textcolor{comment}{                std::cout <<LSPsIndep.at(i)<<"\(\backslash\)t";}
1251 \textcolor{comment}{        \}}
1252 \textcolor{comment}{        std::cout << "\(\backslash\)n";}
1253 \textcolor{comment}{        std::cout << "LSPs:";}
1254 \textcolor{comment}{        for (uint8\_t i = 0; i < paramNum; i++)}
1255 \textcolor{comment}{        \{}
1256 \textcolor{comment}{                std::cout <<LSPs.at(i)<<"\(\backslash\)t";}
1257 \textcolor{comment}{        \}}
1258 \textcolor{comment}{        std::cout << "\(\backslash\)n";*/}
1259 
1260         \textcolor{comment}{/* Notice the shadowing is updated much frequently (every transmission),}
1261 \textcolor{comment}{         * therefore it is generated separately in the 3GPP propagation loss model.*/}
1262 
1263         \textcolor{keywordtype}{double} DS,ASD,ASA,ZSA,ZSD,K\_factor=0;
1264         \textcolor{keywordflow}{if}(los)
1265         \{
1266                 K\_factor = LSPs.at(1)*table3gpp->m\_sigK+table3gpp->m\_uK;
1267                 DS = pow(10, LSPs.at(2)*table3gpp->m\_sigLgDS+table3gpp->m\_uLgDS);
1268                 ASD = pow(10, LSPs.at(3)*table3gpp->m\_sigLgASD+table3gpp->m\_uLgASD);
1269                 ASA = pow(10, LSPs.at(4)*table3gpp->m\_sigLgASA+table3gpp->m\_uLgASA);
1270                 ZSD = pow(10, LSPs.at(5)*table3gpp->m\_sigLgZSD+table3gpp->m\_uLgZSD);
1271                 ZSA = pow(10, LSPs.at(6)*table3gpp->m\_sigLgZSA+table3gpp->m\_uLgZSA);
1272         \}
1273         \textcolor{keywordflow}{else}
1274         \{
1275                 DS = pow(10, LSPs.at(1)*table3gpp->m\_sigLgDS+table3gpp->m\_uLgDS);
1276                 ASD = pow(10, LSPs.at(2)*table3gpp->m\_sigLgASD+table3gpp->m\_uLgASD);
1277                 ASA = pow(10, LSPs.at(3)*table3gpp->m\_sigLgASA+table3gpp->m\_uLgASA);
1278                 ZSD = pow(10, LSPs.at(4)*table3gpp->m\_sigLgZSD+table3gpp->m\_uLgZSD);
1279                 ZSA = pow(10, LSPs.at(5)*table3gpp->m\_sigLgZSA+table3gpp->m\_uLgZSA);
1280 
1281         \}
1282         ASD = \hyperlink{80211b_8c_ac6afabdc09a49a433ee19d8a9486056d}{std::min}(ASD, 104.0);
1283         ASA = \hyperlink{80211b_8c_ac6afabdc09a49a433ee19d8a9486056d}{std::min}(ASA, 104.0);
1284         ZSD = \hyperlink{80211b_8c_ac6afabdc09a49a433ee19d8a9486056d}{std::min}(ZSD, 52.0);
1285         ZSA = \hyperlink{80211b_8c_ac6afabdc09a49a433ee19d8a9486056d}{std::min}(ZSA, 52.0);
1286 
1287         channelParams->m\_DS = DS;
1288         channelParams->m\_K = K\_factor;
1289 
1290         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"K-factor="}<<K\_factor<<\textcolor{stringliteral}{",DS="}<<DS<<\textcolor{stringliteral}{", ASD="}<<ASD<<\textcolor{stringliteral}{", ASA="}<<ASA<<\textcolor{stringliteral}{", ZSD="}<<
      ZSD<<\textcolor{stringliteral}{", ZSA="}<<ZSA);
1291 
1292         \textcolor{comment}{//Step 5: Generate Delays.}
1293         \hyperlink{namespacens3_aa6f1edf6566ca6afec613bc6e40240ea}{doubleVector\_t} clusterDelay;
1294         \textcolor{keywordtype}{double} minTau = 100.0;
1295         \textcolor{keywordflow}{for} (uint8\_t cIndex = 0; cIndex < numOfCluster; cIndex++)
1296         \{
1297                 \textcolor{keywordtype}{double} tau = -1*table3gpp->m\_rTau*DS*log(\hyperlink{classns3_1_1MmWave3gppChannel_ac6493e4d80b717378e74a63d418f8c6f}{m\_uniformRv}->
      \hyperlink{classns3_1_1UniformRandomVariable_a03822d8c86ac51e9aa83bbc73041386b}{GetValue}(0,1)); \textcolor{comment}{//(7.5-1)}
1298                 \textcolor{keywordflow}{if}(minTau > tau)
1299                 \{
1300                         minTau = tau;
1301                 \}
1302                 clusterDelay.push\_back (tau);
1303         \}
1304 
1305         \textcolor{keywordflow}{for} (uint8\_t cIndex = 0; cIndex < numOfCluster; cIndex++)
1306         \{
1307                 clusterDelay.at(cIndex) -= minTau;
1308         \}
1309         std::sort (clusterDelay.begin (), clusterDelay.end ()); \textcolor{comment}{//(7.5-2)}
1310 
1311         \textcolor{comment}{/* since the scaled Los delays are not to be used in cluster power generation,}
1312 \textcolor{comment}{         * we will generate cluster power first and resume to compute Los cluster delay later.*/}
1313 
1314         \textcolor{comment}{//Step 6: Generate cluster powers.}
1315         \hyperlink{namespacens3_aa6f1edf6566ca6afec613bc6e40240ea}{doubleVector\_t} clusterPower;
1316         \textcolor{keywordtype}{double} powerSum = 0;
1317         \textcolor{keywordflow}{for} (uint8\_t cIndex = 0; cIndex < numOfCluster; cIndex++)
1318         \{
1319                 \textcolor{keywordtype}{double} power = exp(-1*clusterDelay.at(cIndex)*(table3gpp->m\_rTau-1)/table3gpp->m\_rTau/DS)*
1320                                 pow(10,-1*\hyperlink{classns3_1_1MmWave3gppChannel_ac2e02ebacc72ed96518d785f2dc87c57}{m\_normalRv}->\hyperlink{classns3_1_1NormalRandomVariable_a0134d131477bc439cc6ff7cbe84b03a9}{GetValue}()*table3gpp->
      m\_shadowingStd/10); \textcolor{comment}{//(7.5-5)}
1321                 powerSum +=power;
1322                 clusterPower.push\_back(power);
1323         \}
1324         \textcolor{keywordtype}{double} powerMax = 0;
1325 
1326         \textcolor{keywordflow}{for} (uint8\_t cIndex = 0; cIndex < numOfCluster; cIndex++)
1327         \{
1328                 clusterPower.at(cIndex) = clusterPower.at(cIndex)/powerSum; \textcolor{comment}{//(7.5-6)}
1329         \}
1330 
1331         \hyperlink{namespacens3_aa6f1edf6566ca6afec613bc6e40240ea}{doubleVector\_t} clusterPowerForAngles; \textcolor{comment}{// this power is only for equation (7.5-9) and
       (7.5-14), not for (7.5-22)}
1332         \textcolor{keywordflow}{if}(los)
1333         \{
1334                 \textcolor{keywordtype}{double} K\_linear = pow(10,K\_factor/10);
1335 
1336                 \textcolor{keywordflow}{for} (uint8\_t cIndex = 0; cIndex < numOfCluster; cIndex++)
1337                 \{
1338                         \textcolor{keywordflow}{if}(cIndex == 0)
1339                         \{
1340                                 clusterPowerForAngles.push\_back (clusterPower.at(cIndex)/(1+K\_linear)+
      K\_linear/(1+K\_linear)); \textcolor{comment}{//(7.5-8)}
1341                         \}
1342                         \textcolor{keywordflow}{else}
1343                         \{
1344                                 clusterPowerForAngles.push\_back (clusterPower.at(cIndex)/(1+K\_linear)); \textcolor{comment}{//
      (7.5-8)}
1345                         \}
1346                         \textcolor{keywordflow}{if}(powerMax < clusterPowerForAngles.at(cIndex))
1347                         \{
1348                                 powerMax = clusterPowerForAngles.at(cIndex);
1349                         \}
1350                 \}
1351         \}
1352         \textcolor{keywordflow}{else}
1353         \{
1354                 \textcolor{keywordflow}{for} (uint8\_t cIndex = 0; cIndex < numOfCluster; cIndex++)
1355                 \{
1356                         clusterPowerForAngles.push\_back (clusterPower.at(cIndex)); \textcolor{comment}{//(7.5-6)}
1357                         \textcolor{keywordflow}{if}(powerMax < clusterPowerForAngles.at(cIndex))
1358                         \{
1359                                 powerMax = clusterPowerForAngles.at(cIndex);
1360                         \}
1361                 \}
1362         \}
1363 
1364         \textcolor{comment}{//remove clusters with less than -25 dB power compared to the maxim cluster power;}
1365         \textcolor{comment}{//double thresh = pow(10,-2.5);}
1366         \textcolor{keywordtype}{double} thresh = 0.0032;
1367         \textcolor{keywordflow}{for} (uint8\_t cIndex = numOfCluster; cIndex > 0; cIndex--)
1368         \{
1369                 \textcolor{keywordflow}{if}(clusterPowerForAngles.at (cIndex-1) < thresh*powerMax )
1370                 \{
1371                         clusterPowerForAngles.erase(clusterPowerForAngles.begin()+cIndex-1);
1372                         clusterPower.erase(clusterPower.begin()+cIndex-1);
1373                         clusterDelay.erase(clusterDelay.begin()+cIndex-1);
1374                 \}
1375         \}
1376         uint8\_t numReducedCluster = clusterPower.size();
1377 
1378         channelParams->m\_numCluster = numReducedCluster;
1379         \textcolor{comment}{// Resume step 5 to compute the delay for LoS condition.}
1380         \textcolor{keywordflow}{if}(los)
1381         \{
1382                 \textcolor{keywordtype}{double} C\_tau =0.7705-0.0433*K\_factor+2e-4*pow(K\_factor,2)+17e-6*pow(K\_factor,3); \textcolor{comment}{//(7.5-3)}
1383                 \textcolor{keywordflow}{for} (uint8\_t cIndex = 0; cIndex < numReducedCluster; cIndex++)
1384                 \{
1385                         clusterDelay.at(cIndex) = clusterDelay.at(cIndex)/C\_tau; \textcolor{comment}{//(7.5-4)}
1386                 \}
1387         \}
1388 
1389         \textcolor{comment}{/*for (uint8\_t i = 0; i < clusterPowerForAngles.size(); i++)}
1390 \textcolor{comment}{        \{}
1391 \textcolor{comment}{                std::cout <<clusterPowerForAngles.at(i)<<"s\(\backslash\)t";}
1392 \textcolor{comment}{        \}}
1393 \textcolor{comment}{        std::cout << "\(\backslash\)n";*/}
1394 
1395         \textcolor{comment}{/*std::cout << "Delay:";}
1396 \textcolor{comment}{        for (uint8\_t i = 0; i < numReducedCluster; i++)}
1397 \textcolor{comment}{        \{}
1398 \textcolor{comment}{                std::cout <<clusterDelay.at(i)<<"s\(\backslash\)t";}
1399 \textcolor{comment}{        \}}
1400 \textcolor{comment}{        std::cout << "\(\backslash\)n";}
1401 \textcolor{comment}{        std::cout << "Power:";}
1402 \textcolor{comment}{        for (uint8\_t i = 0; i < numReducedCluster; i++)}
1403 \textcolor{comment}{        \{}
1404 \textcolor{comment}{                std::cout <<clusterPower.at(i)<<"\(\backslash\)t";}
1405 \textcolor{comment}{        \}}
1406 \textcolor{comment}{        std::cout << "\(\backslash\)n";*/}
1407 
1408         \textcolor{comment}{//step 7: Generate arrival and departure angles for both azimuth and elevation.}
1409 
1410         \textcolor{keywordtype}{double} C\_NLOS, C\_phi;
1411         \textcolor{comment}{//According to table 7.5-6, only cluster number equals to 8, 10, 11, 12, 19 and 20 is valid.}
1412         \textcolor{comment}{//Not sure why the other cases are in Table 7.5-2.}
1413         \textcolor{keywordflow}{switch}(numOfCluster) \textcolor{comment}{// Table 7.5-2}
1414         \{
1415                 \textcolor{keywordflow}{case} 4: C\_NLOS = 0.779;
1416                                 \textcolor{keywordflow}{break};
1417                 \textcolor{keywordflow}{case} 5: C\_NLOS = 0.860;
1418                                 \textcolor{keywordflow}{break};
1419                 \textcolor{keywordflow}{case} 8: C\_NLOS = 1.018;
1420                                 \textcolor{keywordflow}{break};
1421                 \textcolor{keywordflow}{case} 10: C\_NLOS = 1.090;
1422                                  \textcolor{keywordflow}{break};
1423                 \textcolor{keywordflow}{case} 11: C\_NLOS = 1.123;
1424                                  \textcolor{keywordflow}{break};
1425                 \textcolor{keywordflow}{case} 12: C\_NLOS = 1.146;
1426                                  \textcolor{keywordflow}{break};
1427                 \textcolor{keywordflow}{case} 14: C\_NLOS = 1.190;
1428                                  \textcolor{keywordflow}{break};
1429                 \textcolor{keywordflow}{case} 15: C\_NLOS = 1.221;
1430                                  \textcolor{keywordflow}{break};
1431                 \textcolor{keywordflow}{case} 16: C\_NLOS = 1.226;
1432                                  \textcolor{keywordflow}{break};
1433                 \textcolor{keywordflow}{case} 19: C\_NLOS = 1.273;
1434                                  \textcolor{keywordflow}{break};
1435                 \textcolor{keywordflow}{case} 20: C\_NLOS = 1.289;
1436                                  \textcolor{keywordflow}{break};
1437                 \textcolor{keywordflow}{default}: \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR}(\textcolor{stringliteral}{"Invalide cluster number"});
1438         \}
1439 
1440         \textcolor{keywordflow}{if}(los)
1441         \{
1442                 C\_phi = C\_NLOS*(1.1035-0.028*K\_factor-2e-3*pow(K\_factor,2)+1e-4*pow(K\_factor,3)); \textcolor{comment}{//
      (7.5-10))}
1443         \}
1444         \textcolor{keywordflow}{else}
1445         \{
1446                 C\_phi = C\_NLOS; \textcolor{comment}{//(7.5-10))}
1447         \}
1448 
1449         \textcolor{keywordtype}{double} C\_theta;
1450         \textcolor{keywordflow}{switch}(numOfCluster) \textcolor{comment}{//Table 7.5-4}
1451         \{
1452                 \textcolor{keywordflow}{case} 8: C\_NLOS = 0.889;
1453                                 \textcolor{keywordflow}{break};
1454                 \textcolor{keywordflow}{case} 10: C\_NLOS = 0.957;
1455                                 \textcolor{keywordflow}{break};
1456                 \textcolor{keywordflow}{case} 11: C\_NLOS = 1.031;
1457                                 \textcolor{keywordflow}{break};
1458                 \textcolor{keywordflow}{case} 12: C\_NLOS = 1.104;
1459                                  \textcolor{keywordflow}{break};
1460                 \textcolor{keywordflow}{case} 19: C\_NLOS = 1.184;
1461                                  \textcolor{keywordflow}{break};
1462                 \textcolor{keywordflow}{case} 20: C\_NLOS = 1.178;
1463                                  \textcolor{keywordflow}{break};
1464                 \textcolor{keywordflow}{default}: \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR}(\textcolor{stringliteral}{"Invalide cluster number"});
1465         \}
1466 
1467         \textcolor{keywordflow}{if}(los)
1468         \{
1469                 C\_theta = C\_NLOS*(1.3086+0.0339*K\_factor-0.0077*pow(K\_factor,2)+2e-4*pow(K\_factor,3)); \textcolor{comment}{//
      (7.5-15)}
1470         \}
1471         \textcolor{keywordflow}{else}
1472         \{
1473                 C\_theta = C\_NLOS;
1474         \}
1475 
1476 
1477         \hyperlink{namespacens3_aa6f1edf6566ca6afec613bc6e40240ea}{doubleVector\_t} clusterAoa, clusterAod, clusterZoa, clusterZod;
1478         \textcolor{keywordtype}{double} angle;
1479         \textcolor{keywordflow}{for} (uint8\_t cIndex = 0; cIndex < numReducedCluster; cIndex++)
1480         \{
1481                 angle = 2*ASA*sqrt(-1*log(clusterPowerForAngles.at(cIndex)/powerMax))/1.4/C\_phi; \textcolor{comment}{//(7.5-9)}
1482                 clusterAoa.push\_back(angle);
1483                 angle = 2*ASD*sqrt(-1*log(clusterPowerForAngles.at(cIndex)/powerMax))/1.4/C\_phi; \textcolor{comment}{//(7.5-9)}
1484                 clusterAod.push\_back(angle);
1485                 angle = -1*ZSA*log(clusterPowerForAngles.at(cIndex)/powerMax)/C\_theta; \textcolor{comment}{//(7.5-14)}
1486                 clusterZoa.push\_back(angle);
1487                 angle = -1*ZSD*log(clusterPowerForAngles.at(cIndex)/powerMax)/C\_theta;
1488                 clusterZod.push\_back(angle);
1489         \}
1490 
1491         \textcolor{keywordflow}{for} (uint8\_t cIndex = 0; cIndex < numReducedCluster; cIndex++)
1492         \{
1493                 \textcolor{keywordtype}{int} Xn = 1;
1494                 \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1MmWave3gppChannel_ac6493e4d80b717378e74a63d418f8c6f}{m\_uniformRv}->\hyperlink{classns3_1_1UniformRandomVariable_a03822d8c86ac51e9aa83bbc73041386b}{GetValue}(0,1) < 0.5)
1495                 \{
1496                         Xn = -1;
1497                 \}
1498                 clusterAoa.at(cIndex) = clusterAoa.at(cIndex)*Xn+(\hyperlink{classns3_1_1MmWave3gppChannel_ac2e02ebacc72ed96518d785f2dc87c57}{m\_normalRv}->
      \hyperlink{classns3_1_1NormalRandomVariable_a0134d131477bc439cc6ff7cbe84b03a9}{GetValue}()*ASA/7)+rxAngle.phi*180/M\_PI; \textcolor{comment}{//(7.5-11)}
1499                 clusterAod.at(cIndex) = clusterAod.at(cIndex)*Xn+(\hyperlink{classns3_1_1MmWave3gppChannel_ac2e02ebacc72ed96518d785f2dc87c57}{m\_normalRv}->
      \hyperlink{classns3_1_1NormalRandomVariable_a0134d131477bc439cc6ff7cbe84b03a9}{GetValue}()*ASD/7)+txAngle.phi*180/M\_PI;
1500                 \hyperlink{loss__ITU1238_8m_a419d895abe1313c35fa353c93802647e}{if} (o2i)
1501                 \{
1502                         clusterZoa.at(cIndex) = clusterZoa.at(cIndex)*Xn+(
      \hyperlink{classns3_1_1MmWave3gppChannel_ac2e02ebacc72ed96518d785f2dc87c57}{m\_normalRv}->\hyperlink{classns3_1_1NormalRandomVariable_a0134d131477bc439cc6ff7cbe84b03a9}{GetValue}()*ZSA/7)+90; \textcolor{comment}{//(7.5-16)}
1503                 \}
1504                 \textcolor{keywordflow}{else}
1505                 \{
1506                         clusterZoa.at(cIndex) = clusterZoa.at(cIndex)*Xn+(
      \hyperlink{classns3_1_1MmWave3gppChannel_ac2e02ebacc72ed96518d785f2dc87c57}{m\_normalRv}->\hyperlink{classns3_1_1NormalRandomVariable_a0134d131477bc439cc6ff7cbe84b03a9}{GetValue}()*ZSA/7)+rxAngle.theta*180/M\_PI; \textcolor{comment}{//(7.5-16)}
1507                 \}
1508                 clusterZod.at(cIndex) = clusterZod.at(cIndex)*Xn+(\hyperlink{classns3_1_1MmWave3gppChannel_ac2e02ebacc72ed96518d785f2dc87c57}{m\_normalRv}->
      \hyperlink{classns3_1_1NormalRandomVariable_a0134d131477bc439cc6ff7cbe84b03a9}{GetValue}()*ZSD/7)+txAngle.theta*180/M\_PI+table3gpp->m\_offsetZOD; \textcolor{comment}{//(7.5-19)}
1509 
1510         \}
1511 
1512         \textcolor{keywordflow}{if}(los)
1513         \{
1514                 \textcolor{comment}{//The 7.5-12 can be rewrite as Theta\_n,ZOA = Theta\_n,ZOA - (Theta\_1,ZOA - Theta\_LOS,ZOA) =
       Theta\_n,ZOA - diffZOA,}
1515                 \textcolor{comment}{//Similar as AOD, ZSA and ZSD.}
1516                 \textcolor{keywordtype}{double} diffAoa = clusterAoa.at(0) - rxAngle.phi*180/M\_PI;
1517                 \textcolor{keywordtype}{double} diffAod = clusterAod.at(0) - txAngle.phi*180/M\_PI;
1518                 \textcolor{keywordtype}{double} diffZsa = clusterZoa.at(0) - rxAngle.theta*180/M\_PI;
1519                 \textcolor{keywordtype}{double} diffZsd = clusterZod.at(0) - txAngle.theta*180/M\_PI;
1520 
1521                 \textcolor{keywordflow}{for} (uint8\_t cIndex = 0; cIndex < numReducedCluster; cIndex++)
1522                 \{
1523                         clusterAoa.at(cIndex) -= diffAoa; \textcolor{comment}{//(7.5-12)}
1524                         clusterAod.at(cIndex) -= diffAod;
1525                         clusterZoa.at(cIndex) -= diffZsa; \textcolor{comment}{//(7.5-17)}
1526                         clusterZod.at(cIndex) -= diffZsd;
1527 
1528                 \}
1529         \}
1530 
1531         \textcolor{keywordtype}{double} rayAoa\_radian[numReducedCluster][raysPerCluster]; \textcolor{comment}{//rayAoa\_radian[n][m], where n is cluster
       index, m is ray index}
1532         \textcolor{keywordtype}{double} rayAod\_radian[numReducedCluster][raysPerCluster]; \textcolor{comment}{//rayAod\_radian[n][m], where n is cluster
       index, m is ray index}
1533         \textcolor{keywordtype}{double} rayZoa\_radian[numReducedCluster][raysPerCluster]; \textcolor{comment}{//rayZoa\_radian[n][m], where n is cluster
       index, m is ray index}
1534         \textcolor{keywordtype}{double} rayZod\_radian[numReducedCluster][raysPerCluster]; \textcolor{comment}{//rayZod\_radian[n][m], where n is cluster
       index, m is ray index}
1535 
1536         \textcolor{keywordflow}{for} (uint8\_t nInd = 0; nInd < numReducedCluster; nInd++)
1537         \{
1538                 \textcolor{keywordflow}{for}(uint8\_t mInd = 0; mInd < raysPerCluster; mInd++)
1539                 \{
1540                         \textcolor{keywordtype}{double} tempAoa = clusterAoa.at(nInd) + table3gpp->m\_cASA*
      \hyperlink{namespacens3_a2344173eeb094a196c555a159e87bc6f}{offSetAlpha}[mInd]; \textcolor{comment}{//(7.5-13)}
1541                         \textcolor{keywordflow}{while} (tempAoa > 360)
1542                         \{
1543                                 tempAoa -= 360;
1544                         \}
1545 
1546                         \textcolor{keywordflow}{while} (tempAoa < 0)
1547                         \{
1548                                 tempAoa += 360;
1549 
1550                         \}
1551                         \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG}(tempAoa>=0 && tempAoa<=360, \textcolor{stringliteral}{"the AOA should be the range
       of [0,360]"});
1552                         rayAoa\_radian[nInd][mInd] = tempAoa*M\_PI/180;
1553 
1554                         \textcolor{keywordtype}{double} tempAod = clusterAod.at(nInd) + table3gpp->m\_cASD*
      \hyperlink{namespacens3_a2344173eeb094a196c555a159e87bc6f}{offSetAlpha}[mInd];
1555                         \textcolor{keywordflow}{while} (tempAod > 360)
1556                         \{
1557                                 tempAod -= 360;
1558                         \}
1559 
1560                         \textcolor{keywordflow}{while} (tempAod < 0)
1561                         \{
1562                                 tempAod += 360;
1563                         \}
1564                         \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG}(tempAod>=0 && tempAod<=360, \textcolor{stringliteral}{"the AOD should be the range
       of [0,360]"});
1565                         rayAod\_radian[nInd][mInd] = tempAod*M\_PI/180;
1566 
1567                         \textcolor{keywordtype}{double} tempZoa = clusterZoa.at(nInd) + table3gpp->m\_cZSA*
      \hyperlink{namespacens3_a2344173eeb094a196c555a159e87bc6f}{offSetAlpha}[mInd]; \textcolor{comment}{//(7.5-18)}
1568 
1569                         \textcolor{keywordflow}{while}(tempZoa > 360)
1570                         \{
1571                                 tempZoa -= 360;
1572                         \}
1573 
1574                         \textcolor{keywordflow}{while} (tempZoa < 0)
1575                         \{
1576                                 tempZoa += 360;
1577                         \}
1578 
1579                         \textcolor{keywordflow}{if} (tempZoa > 180)
1580                         \{
1581                                 tempZoa = 360-tempZoa;
1582                         \}
1583 
1584                         \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG}(tempZoa>=0&&tempZoa<=180, \textcolor{stringliteral}{"the ZOA should be the range
       of [0,180]"});
1585                         rayZoa\_radian[nInd][mInd] = tempZoa*M\_PI/180;
1586 
1587                         \textcolor{keywordtype}{double} tempZod = clusterZod.at(nInd)+0.375*pow(10,table3gpp->m\_uLgZSD)*
      \hyperlink{namespacens3_a2344173eeb094a196c555a159e87bc6f}{offSetAlpha}[mInd]; \textcolor{comment}{//(7.5-20)}
1588 
1589                         \textcolor{keywordflow}{while}(tempZod > 360)
1590                         \{
1591                                 tempZod -= 360;
1592                         \}
1593 
1594                         \textcolor{keywordflow}{while} (tempZod < 0)
1595                         \{
1596                                 tempZod += 360;
1597                         \}
1598                         \textcolor{keywordflow}{if} (tempZod > 180)
1599                         \{
1600                                 tempZod = 360-tempZod;
1601                         \}
1602                         \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG}(tempZod>=0&&tempZod<=180, \textcolor{stringliteral}{"the ZOD should be the range
       of [0,180]"});
1603                         rayZod\_radian[nInd][mInd] = tempZod*M\_PI/180;
1604                 \}
1605         \}
1606         \hyperlink{namespacens3_aa6f1edf6566ca6afec613bc6e40240ea}{doubleVector\_t} angle\_degree;
1607         \textcolor{keywordtype}{double} sizeTemp = clusterZoa.size();
1608         \textcolor{keywordflow}{for} (uint8\_t ind = 0; ind < 4; ind++)
1609         \{
1610                 \textcolor{keywordflow}{switch}(ind)
1611                 \{
1612                 \textcolor{keywordflow}{case} 0: angle\_degree = clusterAoa;
1613                                 \textcolor{keywordflow}{break};
1614                 \textcolor{keywordflow}{case} 1: angle\_degree = clusterZoa;
1615                                 \textcolor{keywordflow}{break};
1616                 \textcolor{keywordflow}{case} 2: angle\_degree = clusterAod;
1617                                 \textcolor{keywordflow}{break};
1618                 \textcolor{keywordflow}{case} 3: angle\_degree = clusterZod;
1619                                 \textcolor{keywordflow}{break};
1620                 \textcolor{keywordflow}{default}:
1621                         \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR}(\textcolor{stringliteral}{"Programming Error"});
1622                 \}
1623 
1624                 \textcolor{keywordflow}{for}(uint8\_t nIndex = 0; nIndex < sizeTemp; nIndex++)
1625                 \{
1626                         \textcolor{keywordflow}{while}(angle\_degree[nIndex] > 360)
1627                         \{
1628                                 angle\_degree[nIndex] -= 360;
1629                         \}
1630 
1631                         \textcolor{keywordflow}{while} (angle\_degree[nIndex] < 0)
1632                         \{
1633                                 angle\_degree[nIndex] += 360;
1634                         \}
1635 
1636                         \textcolor{keywordflow}{if}(ind==1 || ind==3)
1637                         \{
1638                                 \textcolor{keywordflow}{if}(angle\_degree[nIndex]>180)
1639                                 \{
1640                                         angle\_degree[nIndex] = 360-angle\_degree[nIndex];
1641                                 \}
1642                         \}
1643                 \}
1644                 \textcolor{keywordflow}{switch}(ind)
1645                 \{
1646                 \textcolor{keywordflow}{case} 0: clusterAoa = angle\_degree;
1647                                 \textcolor{keywordflow}{break};
1648                 \textcolor{keywordflow}{case} 1: clusterZoa = angle\_degree;
1649                                 \textcolor{keywordflow}{break};
1650                 \textcolor{keywordflow}{case} 2: clusterAod = angle\_degree;
1651                                 \textcolor{keywordflow}{break};
1652                 \textcolor{keywordflow}{case} 3: clusterZod = angle\_degree;
1653                                 \textcolor{keywordflow}{break};
1654                 \textcolor{keywordflow}{default}:
1655                         \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR}(\textcolor{stringliteral}{"Programming Error"});
1656                 \}
1657         \}
1658 
1659         \hyperlink{namespacens3_aa6f1edf6566ca6afec613bc6e40240ea}{doubleVector\_t} attenuation\_dB;
1660         \textcolor{keywordflow}{if}(\hyperlink{classns3_1_1MmWave3gppChannel_a5f19d0ed379e7db9448f4f668e0c7927}{m\_blockage})
1661         \{
1662                  attenuation\_dB = \hyperlink{classns3_1_1MmWave3gppChannel_aff8853ed48d4aeb1a5d4960a843f5f1a}{CalAttenuationOfBlockage} (channelParams, 
      clusterAoa, clusterZoa);
1663                  \textcolor{keywordflow}{for} (uint8\_t cInd = 0; cInd < numReducedCluster; cInd++)
1664                  \{
1665                          clusterPower.at (cInd) = clusterPower.at (cInd)/pow(10,attenuation\_dB.at (cInd)/10
      );
1666                  \}
1667         \}
1668         \textcolor{keywordflow}{else}
1669         \{
1670                 attenuation\_dB.push\_back(0);
1671         \}
1672 
1673         \textcolor{comment}{/*std::cout << "BlockedPower:";}
1674 \textcolor{comment}{        for (uint8\_t i = 0; i < numReducedCluster; i++)}
1675 \textcolor{comment}{        \{}
1676 \textcolor{comment}{                std::cout <<clusterPower.at(i)<<"\(\backslash\)t";}
1677 \textcolor{comment}{        \}}
1678 \textcolor{comment}{        std::cout << "\(\backslash\)n";}
1679 \textcolor{comment}{}
1680 \textcolor{comment}{        std::cout << "AOD:";}
1681 \textcolor{comment}{        for (uint8\_t i = 0; i < numReducedCluster; i++)}
1682 \textcolor{comment}{        \{}
1683 \textcolor{comment}{                std::cout <<clusterAod.at(i)<<"'\(\backslash\)t";}
1684 \textcolor{comment}{        \}}
1685 \textcolor{comment}{        std::cout << "\(\backslash\)n";}
1686 \textcolor{comment}{}
1687 \textcolor{comment}{        std::cout << "AOA:";}
1688 \textcolor{comment}{        for (uint8\_t i = 0; i < numReducedCluster; i++)}
1689 \textcolor{comment}{        \{}
1690 \textcolor{comment}{                std::cout <<clusterAoa.at(i)<<"'\(\backslash\)t";}
1691 \textcolor{comment}{        \}}
1692 \textcolor{comment}{        std::cout << "\(\backslash\)n";}
1693 \textcolor{comment}{}
1694 \textcolor{comment}{        std::cout << "ZOD:";}
1695 \textcolor{comment}{        for (uint8\_t i = 0; i < numReducedCluster; i++)}
1696 \textcolor{comment}{        \{}
1697 \textcolor{comment}{                std::cout <<clusterZod.at(i)<<"'\(\backslash\)t";}
1698 \textcolor{comment}{                for (uint8\_t d = 0; d < raysPerCluster; d++)}
1699 \textcolor{comment}{                \{}
1700 \textcolor{comment}{                        std::cout <<rayZod\_radian[i][d]<<"\(\backslash\)t";}
1701 \textcolor{comment}{                \}}
1702 \textcolor{comment}{                std::cout << "\(\backslash\)n";}
1703 \textcolor{comment}{        \}}
1704 \textcolor{comment}{        std::cout << "\(\backslash\)n";}
1705 \textcolor{comment}{}
1706 \textcolor{comment}{        std::cout << "ZOA:";}
1707 \textcolor{comment}{        for (uint8\_t i = 0; i < numReducedCluster; i++)}
1708 \textcolor{comment}{        \{}
1709 \textcolor{comment}{                std::cout <<clusterZoa.at(i)<<"'\(\backslash\)t";}
1710 \textcolor{comment}{        \}}
1711 \textcolor{comment}{        std::cout << "\(\backslash\)n";*/}
1712 
1713 
1714         \textcolor{comment}{//Step 8: Coupling of rays within a cluster for both azimuth and elevation}
1715         \textcolor{comment}{//shuffle all the arrays to perform random coupling}
1716         \textcolor{keywordflow}{for} (uint8\_t cIndex = 0; cIndex < numReducedCluster; cIndex++)
1717         \{
1718                 std::shuffle(&rayAod\_radian[cIndex][0],&rayAod\_radian[cIndex][raysPerCluster],
      std::default\_random\_engine(cIndex*1000+100));
1719                 std::shuffle(&rayAoa\_radian[cIndex][0],&rayAoa\_radian[cIndex][raysPerCluster],
      std::default\_random\_engine(cIndex*1000+200));
1720                 std::shuffle(&rayZod\_radian[cIndex][0],&rayZod\_radian[cIndex][raysPerCluster],
      std::default\_random\_engine(cIndex*1000+300));
1721                 std::shuffle(&rayZoa\_radian[cIndex][0],&rayZoa\_radian[cIndex][raysPerCluster],
      std::default\_random\_engine(cIndex*1000+400));
1722         \}
1723 
1724         \textcolor{comment}{//Step 9: Generate the cross polarization power ratios}
1725         \textcolor{comment}{//This step is skipped, only vertical polarization is considered in this version}
1726 
1727         \textcolor{comment}{//Step 10: Draw initial phases}
1728         \hyperlink{namespacens3_a908ae777c72964ccedbcf2310527a67e}{double2DVector\_t} clusterPhase; \textcolor{comment}{//rayAoa\_radian[n][m], where n is cluster index, m
       is ray index}
1729         \textcolor{keywordflow}{for} (uint8\_t nInd = 0; nInd < numReducedCluster; nInd++)
1730         \{
1731                 \hyperlink{namespacens3_aa6f1edf6566ca6afec613bc6e40240ea}{doubleVector\_t} temp;
1732                 \textcolor{keywordflow}{for}(uint8\_t mInd = 0; mInd < raysPerCluster; mInd++)
1733                 \{
1734                         temp.push\_back(\hyperlink{classns3_1_1MmWave3gppChannel_ac6493e4d80b717378e74a63d418f8c6f}{m\_uniformRv}->\hyperlink{classns3_1_1UniformRandomVariable_a03822d8c86ac51e9aa83bbc73041386b}{GetValue}(-1*M\_PI, M\_PI));
1735                 \}
1736                 clusterPhase.push\_back(temp);
1737         \}
1738         \textcolor{keywordtype}{double} losPhase = \hyperlink{classns3_1_1MmWave3gppChannel_ac6493e4d80b717378e74a63d418f8c6f}{m\_uniformRv}->\hyperlink{classns3_1_1UniformRandomVariable_a03822d8c86ac51e9aa83bbc73041386b}{GetValue}(-1*M\_PI, M\_PI);
1739         channelParams->m\_clusterPhase = clusterPhase;
1740         channelParams->m\_losPhase = losPhase;
1741 
1742         \textcolor{comment}{//Step 11: Generate channel coefficients for each cluster n and each receiver and transmitter
       element pair u,s.}
1743 
1744         \hyperlink{namespacens3_afbc512ea4e4657e80b7ac44f78fc81ad}{complex3DVector\_t} H\_NLOS; \textcolor{comment}{// channel coefficients H\_NLOS [u][s][n],}
1745                                                           \textcolor{comment}{// where u and s are receive and transmit antenna
       element, n is cluster index.}
1746         uint16\_t uSize = rxAntennaNum[0]*rxAntennaNum[1];
1747         uint16\_t sSize = txAntennaNum[0]*txAntennaNum[1];
1748 
1749         uint8\_t cluster1st = 0, cluster2nd = 0; \textcolor{comment}{// first and second strongest cluster;}
1750         \textcolor{keywordtype}{double} maxPower = 0;
1751         \textcolor{keywordflow}{for} (uint8\_t cIndex = 0; cIndex < numReducedCluster; cIndex++)
1752         \{
1753                 \textcolor{keywordflow}{if} (maxPower<clusterPower.at (cIndex))
1754                 \{
1755                         maxPower = clusterPower.at (cIndex);
1756                         cluster1st = cIndex;
1757                 \}
1758         \}
1759         maxPower = 0;
1760         \textcolor{keywordflow}{for} (uint8\_t cIndex = 0; cIndex < numReducedCluster; cIndex++)
1761         \{
1762                 \textcolor{keywordflow}{if} (maxPower<clusterPower.at (cIndex) && cluster1st != cIndex)
1763                 \{
1764                         maxPower = clusterPower.at (cIndex);
1765                         cluster2nd = cIndex;
1766                 \}
1767         \}
1768 
1769         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"1st strongest cluster:"}<<(\textcolor{keywordtype}{int})cluster1st<<\textcolor{stringliteral}{", 2nd strongest cluster:"}<<(\textcolor{keywordtype}{int}
      )cluster2nd);
1770 
1771         \hyperlink{namespacens3_afbc512ea4e4657e80b7ac44f78fc81ad}{complex3DVector\_t} H\_usn; \textcolor{comment}{//channel coffecient H\_usn[u][s][n];}
1772         \textcolor{comment}{//Since each of the strongest 2 clusters are divided into 3 sub-clusters, the total cluster will be
       numReducedCLuster + 4.}
1773 
1774         H\_usn.resize(uSize);
1775         \textcolor{keywordflow}{for} (uint16\_t uIndex = 0; uIndex < uSize; uIndex++)
1776         \{
1777                 H\_usn.at(uIndex).resize(sSize);
1778                 \textcolor{keywordflow}{for} (uint16\_t sIndex = 0; sIndex < sSize; sIndex++)
1779                 \{
1780                         H\_usn.at(uIndex).at(sIndex).resize(numReducedCluster);
1781                 \}
1782         \}
1783         \textcolor{comment}{//double slotTime = Simulator::Now ().GetSeconds ();}
1784         \textcolor{comment}{// The following for loops computes the channel coefficients}
1785         \textcolor{keywordflow}{for} (uint16\_t uIndex = 0; uIndex < uSize; uIndex++)
1786         \{
1787                 Vector uLoc = rxAntenna->GetAntennaLocation(uIndex,rxAntennaNum);
1788 
1789                 \textcolor{keywordflow}{for} (uint16\_t sIndex = 0; sIndex < sSize; sIndex++)
1790                 \{
1791 
1792                         Vector sLoc = txAntenna->GetAntennaLocation(sIndex,txAntennaNum);
1793 
1794                         \textcolor{keywordflow}{for} (uint8\_t nIndex = 0; nIndex < numReducedCluster; nIndex++)
1795                         \{
1796                                 \textcolor{comment}{//Compute the N-2 weakest cluster, only vertical polarization. (7.5-22)}
1797                                 \textcolor{keywordflow}{if}(nIndex != cluster1st && nIndex != cluster2nd)
1798                                 \{
1799                                         std::complex<double> rays(0,0);
1800                                         \textcolor{keywordflow}{for}(uint8\_t mIndex = 0; mIndex < raysPerCluster; mIndex++)
1801                                         \{
1802                                                 \textcolor{keywordtype}{double} initialPhase = clusterPhase.at(nIndex).at(mIndex);
1803                                                 \textcolor{comment}{//lambda\_0 is accounted in the antenna spacing uLoc and
       sLoc.}
1804                                                 \textcolor{keywordtype}{double} rxPhaseDiff = 2*M\_PI*(sin(rayZoa\_radian[nIndex][
      mIndex])*cos(rayAoa\_radian[nIndex][mIndex])*uLoc.x
1805                                                                 + sin(rayZoa\_radian[nIndex][mIndex])*sin(
      rayAoa\_radian[nIndex][mIndex])*uLoc.y
1806                                                                 + cos(rayZoa\_radian[nIndex][mIndex])*uLoc.z
      );
1807 
1808                                                 \textcolor{keywordtype}{double} txPhaseDiff = 2*M\_PI*(sin(rayZod\_radian[nIndex][
      mIndex])*cos(rayAod\_radian[nIndex][mIndex])*sLoc.x
1809                                                                 + sin(rayZod\_radian[nIndex][mIndex])*sin(
      rayAod\_radian[nIndex][mIndex])*sLoc.y
1810                                                                 + cos(rayZod\_radian[nIndex][mIndex])*sLoc.z
      );
1811                                                 \textcolor{comment}{//Doppler is computed in the CalBeamformingGain function
       and is simplified to only account for the center anngle of each cluster.}
1812                                                 \textcolor{comment}{//double doppler =
       2*M\_PI*(sin(rayZoa\_radian[nIndex][mIndex])*cos(rayAoa\_radian[nIndex][mIndex])*relativeSpeed.x}
1813                                                 \textcolor{comment}{//              +
       sin(rayZoa\_radian[nIndex][mIndex])*sin(rayAoa\_radian[nIndex][mIndex])*relativeSpeed.y}
1814                                                 \textcolor{comment}{//              +
       cos(rayZoa\_radian[nIndex][mIndex])*relativeSpeed.z)*slotTime*m\_phyMacConfig->GetCenterFrequency ()/3e8;}
1815                                                 rays += exp(std::complex<double>(0, initialPhase))
1816                                                                 *(rxAntenna->GetRadiationPattern(
      rayZoa\_radian[nIndex][mIndex])*txAntenna->GetRadiationPattern(rayZod\_radian[nIndex][mIndex]))
1817                                                                 *exp(std::complex<double>(0, rxPhaseDiff))
1818                                                                 *exp(std::complex<double>(0, txPhaseDiff));
1819                                                                 \textcolor{comment}{//*exp(std::complex<double>(0, doppler));}
1820                                                 \textcolor{comment}{//rays += 1;}
1821                                         \}
1822                                         \textcolor{comment}{//rays *= sqrt(clusterPower.at(nIndex))/raysPerCluster;}
1823                                         rays *= sqrt(clusterPower.at(nIndex)/raysPerCluster);
1824                                         H\_usn.at(uIndex).at(sIndex).at(nIndex) = rays;
1825                                 \}
1826                                 \textcolor{keywordflow}{else} \textcolor{comment}{//(7.5-28)}
1827                                 \{
1828                                         std::complex<double> raysSub1(0,0);
1829                                         std::complex<double> raysSub2(0,0);
1830                                         std::complex<double> raysSub3(0,0);
1831 
1832                                         \textcolor{keywordflow}{for}(uint8\_t mIndex = 0; mIndex < raysPerCluster; mIndex++)
1833                                         \{
1834 
1835                                                 \textcolor{comment}{//ZML:Just remind me that the angle offsets for the 3
       subclusters were not generated correctly.}
1836 
1837                                                 \textcolor{keywordtype}{double} initialPhase = clusterPhase.at(nIndex).at(mIndex);
1838                                                 \textcolor{keywordtype}{double} rxPhaseDiff = 2*M\_PI*(sin(rayZoa\_radian[nIndex][
      mIndex])*cos(rayAoa\_radian[nIndex][mIndex])*uLoc.x
1839                                                                 + sin(rayZoa\_radian[nIndex][mIndex])*sin(
      rayAoa\_radian[nIndex][mIndex])*uLoc.y
1840                                                                 + cos(rayZoa\_radian[nIndex][mIndex])*uLoc.z
      );
1841                                                 \textcolor{keywordtype}{double} txPhaseDiff = 2*M\_PI*(sin(rayZod\_radian[nIndex][
      mIndex])*cos(rayAod\_radian[nIndex][mIndex])*sLoc.x
1842                                                                 + sin(rayZod\_radian[nIndex][mIndex])*sin(
      rayAod\_radian[nIndex][mIndex])*sLoc.y
1843                                                                 + cos(rayZod\_radian[nIndex][mIndex])*sLoc.z
      );
1844                                                 \textcolor{comment}{//double doppler =
       2*M\_PI*(sin(rayZoa\_radian[nIndex][mIndex])*cos(rayAoa\_radian[nIndex][mIndex])*relativeSpeed.x}
1845                                                 \textcolor{comment}{//              +
       sin(rayZoa\_radian[nIndex][mIndex])*sin(rayAoa\_radian[nIndex][mIndex])*relativeSpeed.y}
1846                                                 \textcolor{comment}{//              +
       cos(rayZoa\_radian[nIndex][mIndex])*relativeSpeed.z)*slotTime*m\_phyMacConfig->GetCenterFrequency ()/3e8;}
1847                                                 \textcolor{comment}{//double delaySpread;}
1848                                                 \textcolor{keywordflow}{switch}(mIndex)
1849                                                 \{
1850                                                 \textcolor{keywordflow}{case} 9:
1851                                                 \textcolor{keywordflow}{case} 10:
1852                                                 \textcolor{keywordflow}{case} 11:
1853                                                 \textcolor{keywordflow}{case} 12:
1854                                                 \textcolor{keywordflow}{case} 17:
1855                                                 \textcolor{keywordflow}{case} 18:
1856                                                         \textcolor{comment}{//delaySpread=
       -2*M\_PI*(clusterDelay.at(nIndex)+1.28*c\_DS)*m\_phyMacConfig->GetCenterFrequency ();}
1857                                                         raysSub2 += exp(std::complex<double>(0, 
      initialPhase))
1858                                                                 *(rxAntenna->GetRadiationPattern(
      rayZoa\_radian[nIndex][mIndex])*txAntenna->GetRadiationPattern(rayZod\_radian[nIndex][mIndex]))
1859                                                                 *exp(std::complex<double>(0, rxPhaseDiff))
1860                                                                 *exp(std::complex<double>(0, txPhaseDiff));
1861                                                                 \textcolor{comment}{//*exp(std::complex<double>(0, doppler));}
1862                                                         \textcolor{comment}{//raysSub2 +=1;}
1863                                                         \textcolor{keywordflow}{break};
1864                                                 \textcolor{keywordflow}{case} 13:
1865                                                 \textcolor{keywordflow}{case} 14:
1866                                                 \textcolor{keywordflow}{case} 15:
1867                                                 \textcolor{keywordflow}{case} 16:
1868                                                         \textcolor{comment}{//delaySpread =
       -2*M\_PI*(clusterDelay.at(nIndex)+2.56*c\_DS)*m\_phyMacConfig->GetCenterFrequency ();}
1869                                                         raysSub3 += exp(std::complex<double>(0, 
      initialPhase))
1870                                                                 *(rxAntenna->GetRadiationPattern(
      rayZoa\_radian[nIndex][mIndex])*txAntenna->GetRadiationPattern(rayZod\_radian[nIndex][mIndex]))
1871                                                                 *exp(std::complex<double>(0, rxPhaseDiff))
1872                                                                 *exp(std::complex<double>(0, txPhaseDiff));
1873                                                                 \textcolor{comment}{//*exp(std::complex<double>(0, doppler));}
1874                                                         \textcolor{comment}{//raysSub3 +=1;}
1875                                                         \textcolor{keywordflow}{break};
1876                                                 \textcolor{keywordflow}{default}:\textcolor{comment}{//case 1,2,3,4,5,6,7,8,19,20}
1877                                                         \textcolor{comment}{//delaySpread =
       -2*M\_PI*clusterDelay.at(nIndex)*m\_phyMacConfig->GetCenterFrequency ();}
1878                                                         raysSub1 += exp(std::complex<double>(0, 
      initialPhase))
1879                                                                 *(rxAntenna->GetRadiationPattern(
      rayZoa\_radian[nIndex][mIndex])*txAntenna->GetRadiationPattern(rayZod\_radian[nIndex][mIndex]))
1880                                                                 *exp(std::complex<double>(0, rxPhaseDiff))
1881                                                                 *exp(std::complex<double>(0, txPhaseDiff));
1882                                                                 \textcolor{comment}{//*exp(std::complex<double>(0, doppler));}
1883                                                         \textcolor{comment}{//raysSub1 +=1;}
1884                                                         \textcolor{keywordflow}{break};
1885                                                 \}
1886                                         \}
1887                                         \textcolor{comment}{//raysSub1 *= sqrt(clusterPower.at(nIndex))/raysPerCluster;}
1888                                         \textcolor{comment}{//raysSub2 *= sqrt(clusterPower.at(nIndex))/raysPerCluster;}
1889                                         \textcolor{comment}{//raysSub3 *= sqrt(clusterPower.at(nIndex))/raysPerCluster;}
1890                                         raysSub1 *= sqrt(clusterPower.at(nIndex)/raysPerCluster);
1891                                         raysSub2 *= sqrt(clusterPower.at(nIndex)/raysPerCluster);
1892                                         raysSub3 *= sqrt(clusterPower.at(nIndex)/raysPerCluster);
1893                                         H\_usn.at(uIndex).at(sIndex).at(nIndex) = raysSub1;
1894                                         H\_usn.at(uIndex).at(sIndex).push\_back(raysSub2);
1895                                         H\_usn.at(uIndex).at(sIndex).push\_back(raysSub3);
1896 
1897                                 \}
1898                         \}
1899                         \textcolor{keywordflow}{if}(los) \textcolor{comment}{//(7.5-29) && (7.5-30)}
1900                         \{
1901                                 std::complex<double> ray(0,0);
1902                                 \textcolor{keywordtype}{double} rxPhaseDiff = 2*M\_PI*(sin(rxAngle.theta)*cos(rxAngle.phi)*uLoc.x
1903                                                 + sin(rxAngle.theta)*sin(rxAngle.phi)*uLoc.y
1904                                                 + cos(rxAngle.theta)*uLoc.z);
1905                                 \textcolor{keywordtype}{double} txPhaseDiff = 2*M\_PI*(sin(txAngle.theta)*cos(txAngle.phi)*sLoc.x
1906                                                 + sin(txAngle.theta)*sin(txAngle.phi)*sLoc.y
1907                                                 + cos(txAngle.theta)*sLoc.z);
1908                                 \textcolor{comment}{//double doppler =
       2*M\_PI*(sin(rxAngle.theta)*cos(rxAngle.phi)*relativeSpeed.x}
1909                                 \textcolor{comment}{//              + sin(rxAngle.theta)*sin(rxAngle.phi)*relativeSpeed.y}
1910                                 \textcolor{comment}{//              +
       cos(rxAngle.theta)*relativeSpeed.z)*slotTime*m\_phyMacConfig->GetCenterFrequency ()/3e8;}
1911 
1912                                 ray = exp(std::complex<double>(0, losPhase))
1913                                                 *(rxAntenna->GetRadiationPattern(rxAngle.theta)*txAntenna->
      GetRadiationPattern(txAngle.theta))
1914                                                 *exp(std::complex<double>(0, rxPhaseDiff))
1915                                                 *exp(std::complex<double>(0, txPhaseDiff));
1916                                                 \textcolor{comment}{//*exp(std::complex<double>(0, doppler));}
1917 
1918                                 \textcolor{keywordtype}{double} K\_linear = pow(10,K\_factor/10);
1919                                 \textcolor{comment}{// the LOS path should be attenuated if blockage is enabled.}
1920                                 H\_usn.at(uIndex).at(sIndex).at(0) = sqrt(1/(K\_linear+1))*H\_usn.at(uIndex).
      at(sIndex).at(0)+sqrt(K\_linear/(1+K\_linear))*ray/pow(10,attenuation\_dB.at (0)/10);  \textcolor{comment}{//(7.5-30) for tau = tau1}
1921                                 \textcolor{keywordtype}{double} tempSize = H\_usn.at(uIndex).at(sIndex).size();
1922                                 \textcolor{keywordflow}{for}(uint8\_t nIndex = 1; nIndex < tempSize; nIndex++)
1923                                 \{
1924                                         H\_usn.at(uIndex).at(sIndex).at(nIndex) *= sqrt(1/(K\_linear+1)); \textcolor{comment}{//
      (7.5-30) for tau = tau2...taunN}
1925                                 \}
1926 
1927                         \}
1928                 \}
1929         \}
1930 
1931         \textcolor{keywordflow}{if} (cluster1st == cluster2nd)
1932         \{
1933                 clusterDelay.push\_back(clusterDelay.at(cluster1st)+1.28*table3gpp->m\_cDS);
1934                 clusterDelay.push\_back(clusterDelay.at(cluster1st)+2.56*table3gpp->m\_cDS);
1935 
1936                 clusterAoa.push\_back(clusterAoa.at(cluster1st));
1937                 clusterAoa.push\_back(clusterAoa.at(cluster1st));
1938 
1939                 clusterZoa.push\_back(clusterZoa.at(cluster1st));
1940                 clusterZoa.push\_back(clusterZoa.at(cluster1st));
1941 
1942                 clusterAod.push\_back(clusterAod.at(cluster1st));
1943                 clusterAod.push\_back(clusterAod.at(cluster1st));
1944 
1945                 clusterZod.push\_back(clusterZod.at(cluster1st));
1946                 clusterZod.push\_back(clusterZod.at(cluster1st));
1947         \}
1948         \textcolor{keywordflow}{else}
1949         \{
1950                 \textcolor{keywordtype}{double} \hyperlink{80211b_8c_ac6afabdc09a49a433ee19d8a9486056d}{min}, \hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{max};
1951                 \textcolor{keywordflow}{if}(cluster1st < cluster2nd)
1952                 \{
1953                         min = cluster1st;
1954                         max = cluster2nd;
1955                 \}
1956                 \textcolor{keywordflow}{else}
1957                 \{
1958                         min = cluster2nd;
1959                         max = cluster1st;
1960                 \}
1961                 clusterDelay.push\_back(clusterDelay.at(min)+1.28*table3gpp->m\_cDS);
1962                 clusterDelay.push\_back(clusterDelay.at(min)+2.56*table3gpp->m\_cDS);
1963                 clusterDelay.push\_back(clusterDelay.at(max)+1.28*table3gpp->m\_cDS);
1964                 clusterDelay.push\_back(clusterDelay.at(max)+2.56*table3gpp->m\_cDS);
1965 
1966                 clusterAoa.push\_back(clusterAoa.at(min));
1967                 clusterAoa.push\_back(clusterAoa.at(min));
1968                 clusterAoa.push\_back(clusterAoa.at(max));
1969                 clusterAoa.push\_back(clusterAoa.at(max));
1970 
1971                 clusterZoa.push\_back(clusterZoa.at(min));
1972                 clusterZoa.push\_back(clusterZoa.at(min));
1973                 clusterZoa.push\_back(clusterZoa.at(max));
1974                 clusterZoa.push\_back(clusterZoa.at(max));
1975 
1976                 clusterAod.push\_back(clusterAod.at(min));
1977                 clusterAod.push\_back(clusterAod.at(min));
1978                 clusterAod.push\_back(clusterAod.at(max));
1979                 clusterAod.push\_back(clusterAod.at(max));
1980 
1981                 clusterZod.push\_back(clusterZod.at(min));
1982                 clusterZod.push\_back(clusterZod.at(min));
1983                 clusterZod.push\_back(clusterZod.at(max));
1984                 clusterZod.push\_back(clusterZod.at(max));
1985 
1986 
1987         \}
1988 
1989         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"size of coefficient matrix =["}<<H\_usn.size() << \textcolor{stringliteral}{"]["} << H\_usn.at(0).size()
       << \textcolor{stringliteral}{"]["} << H\_usn.at (0).at(0).size()<<\textcolor{stringliteral}{"]"});
1990 
1991 
1992         \textcolor{comment}{/*std::cout << "Delay:";}
1993 \textcolor{comment}{        for (uint8\_t i = 0; i < clusterDelay.size(); i++)}
1994 \textcolor{comment}{        \{}
1995 \textcolor{comment}{                std::cout <<clusterDelay.at(i)<<"s\(\backslash\)t";}
1996 \textcolor{comment}{        \}}
1997 \textcolor{comment}{        std::cout << "\(\backslash\)n";*/}
1998 
1999         channelParams->m\_channel = H\_usn;
2000         channelParams->m\_delay = clusterDelay;
2001 
2002         channelParams->m\_angle.clear();
2003         channelParams->m\_angle.push\_back(clusterAoa);
2004         channelParams->m\_angle.push\_back(clusterZoa);
2005         channelParams->m\_angle.push\_back(clusterAod);
2006         channelParams->m\_angle.push\_back(clusterZod);
2007 
2008         \textcolor{keywordflow}{return} channelParams;
2009 
2010 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 15




Here is the caller graph for this function\+:
% FIG 16


\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!Get\+System\+Bandwidth@{Get\+System\+Bandwidth}}
\index{Get\+System\+Bandwidth@{Get\+System\+Bandwidth}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{Get\+System\+Bandwidth() const }{GetSystemBandwidth() const }}]{\setlength{\rightskip}{0pt plus 5cm}double ns3\+::\+Mm\+Wave3gpp\+Channel\+::\+Get\+System\+Bandwidth (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWave3gppChannel_aff34062721c2775f51890cbf23702d99}{}\label{classns3_1_1MmWave3gppChannel_aff34062721c2775f51890cbf23702d99}
Returns the bandwidth used in a scenario \begin{DoxyReturn}{Returns}
a double with the bandwidth 
\end{DoxyReturn}

\begin{DoxyCode}
947 \{
948         \textcolor{keywordtype}{double} \hyperlink{generate__test__data__lte__spectrum__model_8m_a3f7228a3941f19f282647a09dd494528}{bw} = 0.00;
949         bw = \hyperlink{classns3_1_1MmWave3gppChannel_a50988766af948ea236ce24718a6dca7d}{m\_phyMacConfig}->\hyperlink{classns3_1_1MmWavePhyMacCommon_acc801566d527f1893d67a618ea3be203}{GetChunkWidth} () * 
      \hyperlink{classns3_1_1MmWave3gppChannel_a50988766af948ea236ce24718a6dca7d}{m\_phyMacConfig}->\hyperlink{classns3_1_1MmWavePhyMacCommon_a8a303f463053dadea5902859a00d481f}{GetNumChunkPerRb} () * 
      \hyperlink{classns3_1_1MmWave3gppChannel_a50988766af948ea236ce24718a6dca7d}{m\_phyMacConfig}->\hyperlink{classns3_1_1MmWavePhyMacCommon_a4c5f323fd722d6eec52efda5d76f97ad}{GetNumRb} ();
950         \textcolor{keywordflow}{return} \hyperlink{generate__test__data__lte__spectrum__model_8m_a3f7228a3941f19f282647a09dd494528}{bw};
951 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 17




Here is the caller graph for this function\+:
% FIG 18


\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Mm\+Wave3gpp\+Channel\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1MmWave3gppChannel_a63160d27a5d036e62b48eb81e374ee18}{}\label{classns3_1_1MmWave3gppChannel_a63160d27a5d036e62b48eb81e374ee18}

\begin{DoxyCode}
178 \{
179         \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::MmWave3gppChannel"})
180         .SetParent<\hyperlink{classns3_1_1Object_a40860402e64d8008fb42329df7097cdb}{Object}> ()
181         .AddAttribute (\textcolor{stringliteral}{"UpdatePeriod"},
182                                 \textcolor{stringliteral}{"Enable spatially-consistent UT mobility modeling procedure A, the update
       period unit is in ms, set to 0 ms to disable update"},
183                                 TimeValue (\hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (0)),
184                                 MakeTimeAccessor (&
      \hyperlink{classns3_1_1MmWave3gppChannel_a2844f8c7e7373cb777384eaf0e8a7b11}{MmWave3gppChannel::m\_updatePeriod}),
185                                 \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
186         .AddAttribute (\textcolor{stringliteral}{"CellScan"},
187                                 \textcolor{stringliteral}{"Use beam search method to determine beamforming vector, the default is
       long-term covariance matrix method"},
188                                 BooleanValue (\textcolor{keyword}{false}),
189                                 MakeBooleanAccessor (&
      \hyperlink{classns3_1_1MmWave3gppChannel_ac973f52321b6843ce42f036620af63e8}{MmWave3gppChannel::m\_cellScan}),
190                                 MakeBooleanChecker ())
191         .AddAttribute (\textcolor{stringliteral}{"Blockage"},
192                                 \textcolor{stringliteral}{"Enable blockage model A (sec 7.6.4.1)"},
193                                 BooleanValue (\textcolor{keyword}{false}),
194                                 MakeBooleanAccessor (&
      \hyperlink{classns3_1_1MmWave3gppChannel_a5f19d0ed379e7db9448f4f668e0c7927}{MmWave3gppChannel::m\_blockage}),
195                                 MakeBooleanChecker ())
196         .AddAttribute (\textcolor{stringliteral}{"NumNonselfBlocking"},
197                                 \textcolor{stringliteral}{"number of non-self-blocking regions"},
198                                 IntegerValue (4),
199                                 MakeIntegerAccessor (&
      \hyperlink{classns3_1_1MmWave3gppChannel_addfe5e6c9d8e2531fe165ff86461d2d3}{MmWave3gppChannel::m\_numNonSelfBloking}),
200                                 MakeIntegerChecker<uint16\_t> ())
201         .AddAttribute (\textcolor{stringliteral}{"BlockerSpeed"},
202                                 \textcolor{stringliteral}{"The speed of moving blockers, the unit is m/s"},
203                                 DoubleValue (1),
204                                 MakeDoubleAccessor (&
      \hyperlink{classns3_1_1MmWave3gppChannel_a5d7b7b759283cdf9a6781571e9eeca25}{MmWave3gppChannel::m\_blockerSpeed}),
205                                 MakeDoubleChecker<double> ())
206         .AddAttribute (\textcolor{stringliteral}{"PortraitMode"},
207                                 \textcolor{stringliteral}{"true for portrait mode, false for landscape mode"},
208                                 BooleanValue (\textcolor{keyword}{true}),
209                                 MakeBooleanAccessor (&
      \hyperlink{classns3_1_1MmWave3gppChannel_a013ed012d87114993312ccfd172fe377}{MmWave3gppChannel::m\_portraitMode}),
210                                 MakeBooleanChecker ())
211         ;
212         \textcolor{keywordflow}{return} tid;
213 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 19


\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!Initial@{Initial}}
\index{Initial@{Initial}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{Initial(\+Net\+Device\+Container ue\+Devices, Net\+Device\+Container enb\+Devices)}{Initial(NetDeviceContainer ueDevices, NetDeviceContainer enbDevices)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mm\+Wave3gpp\+Channel\+::\+Initial (
\begin{DoxyParamCaption}
\item[{{\bf Net\+Device\+Container}}]{ue\+Devices, }
\item[{{\bf Net\+Device\+Container}}]{enb\+Devices}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1MmWave3gppChannel_ad51205a072737028520bb1bf7d255050}{}\label{classns3_1_1MmWave3gppChannel_ad51205a072737028520bb1bf7d255050}
Register the connection between all the devices in the \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} given as input 
\begin{DoxyParams}{Parameters}
{\em a} & \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} for the U\+Es \\
\hline
{\em a} & \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} for the e\+N\+Bs \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
304 \{
305 
306         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (&ueDevices<<&enbDevices);
307 
308         \hyperlink{classns3_1_1MmWave3gppChannel_a2d5a32e24f0d795c5ed210f8c38f4e9b}{m\_forceInitialBfComputation} = \textcolor{keyword}{true};
309 
310         \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1NetDeviceContainer_a45709bb572f975569ed985fa89b132f8}{NetDeviceContainer::Iterator} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = ueDevices.Begin(); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != ueDevices.End(); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
311         \{
312                 \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1NetDeviceContainer_a45709bb572f975569ed985fa89b132f8}{NetDeviceContainer::Iterator} j = enbDevices.Begin(); j != 
      enbDevices.End(); j++)
313                 \{
314                         \hyperlink{classns3_1_1MmWave3gppChannel_a47452fa275fee0e056f646379ccc9288}{SetBeamformingVector}(*\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i},*j);
315 
316                         \textcolor{comment}{// get the mobility objects}
317                         Ptr<const MobilityModel> a = (*j)->GetNode()->GetObject<MobilityModel> ();
318                         Ptr<const MobilityModel> \hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b} = (*i)->GetNode()->GetObject<MobilityModel> ();
319                         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO}(\textcolor{stringliteral}{"a "} << a << \textcolor{stringliteral}{" b "} << b);
320 
321                         \textcolor{comment}{// initialize the pathloss and channel condition}
322                         \textcolor{keywordflow}{if} (DynamicCast<MmWave3gppPropagationLossModel> (
      \hyperlink{classns3_1_1MmWave3gppChannel_add8860051acacb1819be2f7321dbd726}{m\_3gppPathloss})!=0)
323                         \{
324                                 \hyperlink{classns3_1_1MmWave3gppChannel_add8860051acacb1819be2f7321dbd726}{m\_3gppPathloss}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<
      \hyperlink{classMmWave3gppPropagationLossModel}{MmWave3gppPropagationLossModel}> ()
325                                                 ->GetLoss(a->GetObject<MobilityModel>(),b->GetObject<
      MobilityModel>());
326                         \}                       \textcolor{comment}{// the GetObject trick is a trick against the const keyword}
327                         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (DynamicCast<MmWave3gppBuildingsPropagationLossModel> (
      \hyperlink{classns3_1_1MmWave3gppChannel_add8860051acacb1819be2f7321dbd726}{m\_3gppPathloss})!=0)
328                         \{
329                                 \hyperlink{classns3_1_1MmWave3gppChannel_add8860051acacb1819be2f7321dbd726}{m\_3gppPathloss}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<
      MmWave3gppBuildingsPropagationLossModel> ()
330                                                 ->GetLoss(a->GetObject<MobilityModel>(),b->GetObject<
      MobilityModel>());
331                         \}
332                         \textcolor{keywordflow}{else}
333                         \{
334                                 \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR}(\textcolor{stringliteral}{"unknow pathloss model"});
335                         \}
336 
337 
338                         std::vector<int> listOfSubchannels;
339                         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} subChannelIndex = 0; subChannelIndex < 
      \hyperlink{classns3_1_1MmWave3gppChannel_a50988766af948ea236ce24718a6dca7d}{m\_phyMacConfig}->\hyperlink{classns3_1_1MmWavePhyMacCommon_a97e82c809a351fea9d5058ac1bb4c3c6}{GetTotalNumChunk}(); subChannelIndex++)
340                         \{
341                                 listOfSubchannels.push\_back(subChannelIndex);
342                         \}
343 
344                         Ptr<const SpectrumValue> fakePsd = 
345                                 
      \hyperlink{classns3_1_1MmWaveSpectrumValueHelper_a1a968ae81d81f346027fe474e7962148}{MmWaveSpectrumValueHelper::CreateTxPowerSpectralDensity}
       (\hyperlink{classns3_1_1MmWave3gppChannel_a50988766af948ea236ce24718a6dca7d}{m\_phyMacConfig}, 0, listOfSubchannels);
346                         \hyperlink{classns3_1_1MmWave3gppChannel_a598876f469ba922150b9d9b86e160ca0}{DoCalcRxPowerSpectralDensity}(fakePsd, a, b);
347 
348 
349                         \textcolor{comment}{// Ptr<MmWaveUeNetDevice> UeDev =}
350                         \textcolor{comment}{//                      DynamicCast<MmWaveUeNetDevice> (*i);}
351                         \textcolor{comment}{// if (UeDev != 0)}
352                         \textcolor{comment}{// \{}
353 
354                         \textcolor{comment}{// \}    }
355                         \textcolor{comment}{// else}
356                         \textcolor{comment}{// \{}
357                         \textcolor{comment}{//      Ptr<McUeNetDevice> UeDev = DynamicCast<MmWaveUeNetDevice> (*i);}
358                         \textcolor{comment}{//      if (UeDev !=0)}
359                         \textcolor{comment}{// \}            }
360                         \textcolor{comment}{// if (UeDev->GetTargetEnb ()) }
361                         \textcolor{comment}{// \{}
362                         \textcolor{comment}{//      Ptr<NetDevice> targetBs = UeDev->GetTargetEnb ();}
363                         \textcolor{comment}{//      ConnectDevices (*i, targetBs);}
364                         \textcolor{comment}{//      ConnectDevices (targetBs, *i);}
365 
366                                 
367                         \textcolor{comment}{// \}    }
368                 \}
369 
370                 
371         \}
372 
373         \hyperlink{classns3_1_1MmWave3gppChannel_a2d5a32e24f0d795c5ed210f8c38f4e9b}{m\_forceInitialBfComputation} = \textcolor{keyword}{false};
374 
375 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 20


\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!Long\+Term\+Cov\+Matrix\+Beamforming@{Long\+Term\+Cov\+Matrix\+Beamforming}}
\index{Long\+Term\+Cov\+Matrix\+Beamforming@{Long\+Term\+Cov\+Matrix\+Beamforming}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{Long\+Term\+Cov\+Matrix\+Beamforming(\+Ptr$<$ Params3gpp $>$ params) const }{LongTermCovMatrixBeamforming(Ptr< Params3gpp > params) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mm\+Wave3gpp\+Channel\+::\+Long\+Term\+Cov\+Matrix\+Beamforming (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Params3gpp} $>$}]{params}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWave3gppChannel_a1ef519a7796d45ef5270e465664fd1bb}{}\label{classns3_1_1MmWave3gppChannel_a1ef519a7796d45ef5270e465664fd1bb}
Compute the optimal BF vector with the Power Method (Maximum Ratio Transmission method). The vector is stored in the \hyperlink{structns3_1_1Params3gpp}{Params3gpp} object passed as parameter  the channel realizationin as a \hyperlink{structns3_1_1Params3gpp}{Params3gpp} object 
\begin{DoxyCode}
742 \{
743         \textcolor{comment}{//generate transmitter side spatial correlation matrix}
744         uint8\_t txSize = params->m\_channel.at(0).size();
745         uint8\_t rxSize = params->m\_channel.size();
746         \hyperlink{namespacens3_aa25e3feece2676fd7470d50d4ba3d1d1}{complex2DVector\_t} txQ;
747         txQ.resize(txSize);
748 
749         \textcolor{keywordflow}{for} (uint8\_t txIndex = 0; txIndex < txSize; txIndex++)
750         \{
751                 txQ.at(txIndex).resize(txSize);
752         \}
753 
754         \textcolor{comment}{//compute the transmitter side spatial correlation matrix txQ = H*H, where H is the sum of H\_n over
       n clusters.}
755         \textcolor{keywordflow}{for} (uint8\_t t1Index = 0; t1Index < txSize; t1Index++)
756         \{
757                 \textcolor{keywordflow}{for} (uint8\_t t2Index = 0; t2Index < txSize; t2Index++)
758                 \{
759                         \textcolor{keywordflow}{for}(uint8\_t rxIndex = 0; rxIndex < rxSize; rxIndex++)
760                         \{
761                                 std::complex<double> cSum (0,0);
762                                 \textcolor{keywordflow}{for} (uint8\_t cIndex = 0; cIndex < params->m\_channel.at(rxIndex).at(t1Index)
      .size(); cIndex++)
763                                 \{
764                                         cSum = cSum + std::conj(params->m\_channel.at(rxIndex).at(t1Index).
      at(cIndex))*
765                                                         (params->m\_channel.at(rxIndex).at(t2Index).at(
      cIndex));
766                                 \}
767                                 txQ[t1Index][t2Index] += cSum;
768                         \}
769 
770                 \}
771         \}
772 
773 
774         \textcolor{comment}{//calculate beamforming vector from spatial correlation matrix.}
775         \hyperlink{namespacens3_a6a7f75817ae50e6ac47414955b17d926}{complexVector\_t} antennaWeights;
776         uint8\_t txAntenna = txQ.size ();
777         \textcolor{keywordflow}{for} (uint8\_t eIndex = 0; eIndex < txAntenna; eIndex++)
778         \{
779                 antennaWeights.push\_back(txQ.at (0).at (eIndex));
780         \}
781 
782 
783         \textcolor{keywordtype}{int} iter = 10;
784         \textcolor{keywordtype}{double} diff = 1;
785         \textcolor{keywordflow}{while}(iter != 0 && diff>1e-10)
786         \{
787                 \hyperlink{namespacens3_a6a7f75817ae50e6ac47414955b17d926}{complexVector\_t} antennaWeights\_New;
788 
789                 \textcolor{keywordflow}{for}(uint8\_t row = 0; row<txAntenna; row++)
790                 \{
791                         std::complex<double> sum(0,0);
792                         \textcolor{keywordflow}{for} (uint8\_t col = 0; col< txAntenna; col++)
793                         \{
794                                 sum += txQ.at (row).at (col)*antennaWeights.at (col);
795                         \}
796 
797                     antennaWeights\_New.push\_back(sum);
798                 \}
799                 \textcolor{comment}{//normalize antennaWeights;}
800                 \textcolor{keywordtype}{double} weightSum = 0;
801                 \textcolor{keywordflow}{for} (uint8\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}< txAntenna; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
802                 \{
803                         weightSum += norm(antennaWeights\_New. at(\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}));
804                 \}
805                 \textcolor{keywordflow}{for} (uint8\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}< txAntenna; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
806                 \{
807                         antennaWeights\_New. at(\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) = antennaWeights\_New. at(\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})/sqrt(weightSum);
808                 \}
809                 diff = 0;
810                 \textcolor{keywordflow}{for} (uint8\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}< txAntenna; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
811                 \{
812                         diff += std::norm(antennaWeights\_New. at(\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})-antennaWeights. at(
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}));
813                 \}
814                 iter--;
815                 antennaWeights = antennaWeights\_New;
816         \}
817 
818         params->m\_txW = antennaWeights;
819 
820         \textcolor{comment}{//compute the receiver side spatial correlation matrix rxQ = HH*, where H is the sum of H\_n over n
       clusters.}
821         \hyperlink{namespacens3_aa25e3feece2676fd7470d50d4ba3d1d1}{complex2DVector\_t} rxQ;
822         rxQ.resize(rxSize);
823         \textcolor{keywordflow}{for} (uint8\_t r1Index = 0; r1Index < rxSize; r1Index++)
824         \{
825                 rxQ.at(r1Index).resize(rxSize);
826         \}
827 
828         \textcolor{keywordflow}{for} (uint8\_t r1Index = 0; r1Index < rxSize; r1Index++)
829         \{
830                 \textcolor{keywordflow}{for} (uint8\_t r2Index = 0; r2Index < rxSize; r2Index++)
831                 \{
832                         \textcolor{keywordflow}{for}(uint8\_t txIndex = 0; txIndex < txSize; txIndex++)
833             \{
834                                 std::complex<double> cSum (0,0);
835                                 \textcolor{keywordflow}{for} (uint8\_t cIndex = 0; cIndex < params->m\_channel.at(r1Index).at(txIndex)
      .size(); cIndex++)
836                                 \{
837                                         cSum = cSum + params->m\_channel.at(r1Index).at(txIndex).at(cIndex)*
838                                                         std::conj(params->m\_channel.at(r2Index).at(txIndex)
      .at(cIndex));
839                                 \}
840                                 rxQ[r1Index][r2Index] += cSum;
841             \}
842 
843                 \}
844         \}
845 
846         \textcolor{comment}{//calculate beamforming vector from spatial correlation matrix.}
847         antennaWeights.clear();
848         uint8\_t rxAntenna = rxQ.size ();
849         \textcolor{keywordflow}{for} (uint8\_t eIndex = 0; eIndex < rxAntenna; eIndex++)
850         \{
851                 antennaWeights.push\_back(rxQ.at (0).at (eIndex));
852         \}
853 
854         iter = 10;
855         diff = 1;
856         \textcolor{keywordflow}{while}(iter != 0 && diff>1e-10)
857         \{
858                 \hyperlink{namespacens3_a6a7f75817ae50e6ac47414955b17d926}{complexVector\_t} antennaWeights\_New;
859 
860                 \textcolor{keywordflow}{for}(uint8\_t row = 0; row<rxAntenna; row++)
861                 \{
862                         std::complex<double> sum(0,0);
863                         \textcolor{keywordflow}{for} (uint8\_t col = 0; col< rxAntenna; col++)
864                         \{
865                                 sum += rxQ.at (row).at (col)*antennaWeights.at (col);
866                         \}
867 
868                     antennaWeights\_New.push\_back(sum);
869                 \}
870 
871                 \textcolor{comment}{//normalize antennaWeights;}
872                 \textcolor{keywordtype}{double} weightSum = 0;
873                 \textcolor{keywordflow}{for} (uint8\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}< rxAntenna; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
874                 \{
875                         weightSum += norm(antennaWeights\_New. at(\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}));
876                 \}
877                 \textcolor{keywordflow}{for} (uint8\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}< rxAntenna; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
878                 \{
879                         antennaWeights\_New. at(\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) = antennaWeights\_New. at(\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})/sqrt(weightSum);
880                 \}
881                 diff = 0;
882                 \textcolor{keywordflow}{for} (uint8\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}< rxAntenna; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
883                 \{
884                         diff += std::norm(antennaWeights\_New. at(\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})-antennaWeights. at(
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}));
885                 \}
886                 iter--;
887                 antennaWeights = antennaWeights\_New;
888         \}
889 
890         params->m\_rxW = antennaWeights;
891 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 21


\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!Set\+Beamforming\+Vector@{Set\+Beamforming\+Vector}}
\index{Set\+Beamforming\+Vector@{Set\+Beamforming\+Vector}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{Set\+Beamforming\+Vector(\+Ptr$<$ Net\+Device $>$ ue\+Device, Ptr$<$ Net\+Device $>$ enb\+Device)}{SetBeamformingVector(Ptr< NetDevice > ueDevice, Ptr< NetDevice > enbDevice)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mm\+Wave3gpp\+Channel\+::\+Set\+Beamforming\+Vector (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{ue\+Device, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{enb\+Device}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1MmWave3gppChannel_a47452fa275fee0e056f646379ccc9288}{}\label{classns3_1_1MmWave3gppChannel_a47452fa275fee0e056f646379ccc9288}
Set the initial BF vector between two devices 
\begin{DoxyParams}{Parameters}
{\em a} & pointer to a \hyperlink{classns3_1_1NetDevice}{Net\+Device} for the UE \\
\hline
{\em a} & pointer to a \hyperlink{classns3_1_1NetDevice}{Net\+Device} for the e\+NB \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
254 \{
255         \hyperlink{namespacens3_aa42bd408e172586b3b192acfaa36b070}{key\_t} key = std::make\_pair(ueDevice,enbDevice);
256         Ptr<MmWaveEnbNetDevice> EnbDev =
257                                 DynamicCast<MmWaveEnbNetDevice> (enbDevice);
258         Ptr<MmWaveUeNetDevice> UeDev =
259                                 DynamicCast<MmWaveUeNetDevice> (ueDevice);
260         \textcolor{keywordflow}{if}(UeDev != 0)
261         \{
262                 \hyperlink{log-macros-disabled_8h_a0b36e5e182b37194f85ef1c5e979fb2e}{NS\_LOG\_UNCOND}(\textcolor{stringliteral}{"SetBeamformingVector between UE "} << ueDevice << \textcolor{stringliteral}{" and
       enbDevice "} << enbDevice);
263                 Ptr<AntennaArrayModel> ueAntennaArray = DynamicCast<AntennaArrayModel> (
264                                 UeDev->GetPhy ()->GetDlSpectrumPhy ()->GetRxAntenna ());
265                 Ptr<AntennaArrayModel> enbAntennaArray = DynamicCast<AntennaArrayModel> (
266                                 EnbDev->GetPhy ()->GetDlSpectrumPhy ()->GetRxAntenna ());
267                 \hyperlink{namespacens3_a6a7f75817ae50e6ac47414955b17d926}{complexVector\_t} dummy;
268                 ueAntennaArray->SetBeamformingVector (dummy,enbDevice);
269                 enbAntennaArray->SetBeamformingVector (dummy,ueDevice);
270         \}
271         \textcolor{keywordflow}{else}
272         \{
273                 Ptr<McUeNetDevice> UeDev =
274                                 DynamicCast<McUeNetDevice> (ueDevice);
275                 \textcolor{keywordflow}{if}(UeDev != 0)
276                 \{
277                         \hyperlink{log-macros-disabled_8h_a0b36e5e182b37194f85ef1c5e979fb2e}{NS\_LOG\_UNCOND}(\textcolor{stringliteral}{"SetBeamformingVector between UE "} << ueDevice << \textcolor{stringliteral}{" and
       enbDevice "} << enbDevice);
278                         Ptr<AntennaArrayModel> ueAntennaArray;
279                         \textcolor{keywordflow}{if}(\hyperlink{classns3_1_1MmWave3gppChannel_a5b921c4b6e89174bf383382c1ce6523f}{isAdditionalMmWavePhy}) \textcolor{comment}{//sjkang11125}
280                          ueAntennaArray= DynamicCast<AntennaArrayModel> (
281                                         UeDev->GetMmWavePhy\_2 ()->GetDlSpectrumPhy ()->GetRxAntenna ());
282                         \textcolor{keywordflow}{else}
283                                 ueAntennaArray = DynamicCast<AntennaArrayModel> (
284                                                                 UeDev->GetMmWavePhy ()->GetDlSpectrumPhy ()
      ->GetRxAntenna ());
285 
286                         Ptr<AntennaArrayModel> enbAntennaArray = DynamicCast<AntennaArrayModel> (
287                                         EnbDev->GetPhy ()->GetDlSpectrumPhy ()->GetRxAntenna ());
288                         \hyperlink{namespacens3_a6a7f75817ae50e6ac47414955b17d926}{complexVector\_t} dummy;
289                         ueAntennaArray->SetBeamformingVector (dummy,enbDevice);
290                         enbAntennaArray->SetBeamformingVector (dummy,ueDevice);
291                 \}
292                 \textcolor{keywordflow}{else}
293                 \{
294                         \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR}(\textcolor{stringliteral}{"Unrecognized pair of devices"});
295                 \}
296         \}
297 
298 
299 
300 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 22


\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!Set\+Configuration\+Parameters@{Set\+Configuration\+Parameters}}
\index{Set\+Configuration\+Parameters@{Set\+Configuration\+Parameters}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{Set\+Configuration\+Parameters(\+Ptr$<$ Mm\+Wave\+Phy\+Mac\+Common $>$ ptr\+Config)}{SetConfigurationParameters(Ptr< MmWavePhyMacCommon > ptrConfig)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mm\+Wave3gpp\+Channel\+::\+Set\+Configuration\+Parameters (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Mm\+Wave\+Phy\+Mac\+Common} $>$}]{ptr\+Config}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1MmWave3gppChannel_a18aeca33b5a09843d342fc3abb5abf68}{}\label{classns3_1_1MmWave3gppChannel_a18aeca33b5a09843d342fc3abb5abf68}
Set the \hyperlink{classns3_1_1MmWavePhyMacCommon}{Mm\+Wave\+Phy\+Mac\+Common} object with the parameters of the scenario 
\begin{DoxyParams}{Parameters}
{\em a} & pointer to the \hyperlink{classns3_1_1MmWavePhyMacCommon}{Mm\+Wave\+Phy\+Mac\+Common} configuration \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
228 \{
229         \hyperlink{classns3_1_1MmWave3gppChannel_a50988766af948ea236ce24718a6dca7d}{m\_phyMacConfig} = ptrConfig;
230 \}
\end{DoxyCode}
\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!Set\+Pathloss\+Model@{Set\+Pathloss\+Model}}
\index{Set\+Pathloss\+Model@{Set\+Pathloss\+Model}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{Set\+Pathloss\+Model(\+Ptr$<$ Propagation\+Loss\+Model $>$ pathloss)}{SetPathlossModel(Ptr< PropagationLossModel > pathloss)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mm\+Wave3gpp\+Channel\+::\+Set\+Pathloss\+Model (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Propagation\+Loss\+Model} $>$}]{pathloss}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1MmWave3gppChannel_a01b18ad10ea2cf6acd7ee23d53eba3fc}{}\label{classns3_1_1MmWave3gppChannel_a01b18ad10ea2cf6acd7ee23d53eba3fc}
Set the pathloss model associated to this class 
\begin{DoxyParams}{Parameters}
{\em a} & pointer to the pathloss model, which has to implement the \hyperlink{classns3_1_1PropagationLossModel}{Propagation\+Loss\+Model} interface \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
955 \{
956         \hyperlink{classns3_1_1MmWave3gppChannel_add8860051acacb1819be2f7321dbd726}{m\_3gppPathloss} = pathloss;
957         \textcolor{keywordflow}{if} (DynamicCast<MmWave3gppPropagationLossModel> (\hyperlink{classns3_1_1MmWave3gppChannel_add8860051acacb1819be2f7321dbd726}{m\_3gppPathloss})!=0)
958         \{
959                 \hyperlink{classns3_1_1MmWave3gppChannel_ae1f263fbc87682905d563221343e4447}{m\_scenario} = \hyperlink{classns3_1_1MmWave3gppChannel_add8860051acacb1819be2f7321dbd726}{m\_3gppPathloss}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<
      \hyperlink{classMmWave3gppPropagationLossModel}{MmWave3gppPropagationLossModel}> ()->GetScenario();
960         \}
961         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (DynamicCast<MmWave3gppBuildingsPropagationLossModel> (
      \hyperlink{classns3_1_1MmWave3gppChannel_add8860051acacb1819be2f7321dbd726}{m\_3gppPathloss})!=0)
962         \{
963                 \hyperlink{classns3_1_1MmWave3gppChannel_ae1f263fbc87682905d563221343e4447}{m\_scenario} = \hyperlink{classns3_1_1MmWave3gppChannel_add8860051acacb1819be2f7321dbd726}{m\_3gppPathloss}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<
      MmWave3gppBuildingsPropagationLossModel> ()->GetScenario();
964         \}
965         \textcolor{keywordflow}{else}
966         \{
967                 \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR}(\textcolor{stringliteral}{"unkonw pathloss model"});
968         \}
969 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 23


\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!Update\+Channel@{Update\+Channel}}
\index{Update\+Channel@{Update\+Channel}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{Update\+Channel(\+Ptr$<$ Params3gpp $>$ params3gpp, Ptr$<$ Params\+Table $>$ table3gpp, Ptr$<$ Antenna\+Array\+Model $>$ tx\+Antenna, Ptr$<$ Antenna\+Array\+Model $>$ rx\+Antenna, uint8\+\_\+t $\ast$tx\+Antenna\+Num, uint8\+\_\+t $\ast$rx\+Antenna\+Num, Angles \&rx\+Angle, Angles \&tx\+Angle) const }{UpdateChannel(Ptr< Params3gpp > params3gpp, Ptr< ParamsTable > table3gpp, Ptr< AntennaArrayModel > txAntenna, Ptr< AntennaArrayModel > rxAntenna, uint8_t *txAntennaNum, uint8_t *rxAntennaNum, Angles &rxAngle, Angles &txAngle) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Params3gpp} $>$ ns3\+::\+Mm\+Wave3gpp\+Channel\+::\+Update\+Channel (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Params3gpp} $>$}]{params3gpp, }
\item[{{\bf Ptr}$<$ {\bf Params\+Table} $>$}]{table3gpp, }
\item[{{\bf Ptr}$<$ {\bf Antenna\+Array\+Model} $>$}]{tx\+Antenna, }
\item[{{\bf Ptr}$<$ {\bf Antenna\+Array\+Model} $>$}]{rx\+Antenna, }
\item[{uint8\+\_\+t $\ast$}]{tx\+Antenna\+Num, }
\item[{uint8\+\_\+t $\ast$}]{rx\+Antenna\+Num, }
\item[{{\bf Angles} \&}]{rx\+Angle, }
\item[{{\bf Angles} \&}]{tx\+Angle}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWave3gppChannel_a765f45f9d98c15655c8ea6288e86f111}{}\label{classns3_1_1MmWave3gppChannel_a765f45f9d98c15655c8ea6288e86f111}
Update the channel realization with procedure A of TR 38.\+900 Sec 7.\+6.\+3.\+2 for the spatial consistency  the previous channel realization in a \hyperlink{structns3_1_1Params3gpp}{Params3gpp} object  the \hyperlink{structns3_1_1ParamsTable}{Params\+Table} for the specific scenario  the Array\+Antenna\+Model for the tx\+Antenna  the Array\+Antenna\+Model for the rx\+Antenna  the number of tx\+Antenna per row  the number of rx\+Antenna per row  the rx\+Angle  the tx\+Angle \begin{DoxyReturn}{Returns}
the channel realization in a \hyperlink{structns3_1_1Params3gpp}{Params3gpp} object 
\end{DoxyReturn}

\begin{DoxyCode}
2016 \{
2017         Ptr<Params3gpp> params = params3gpp;
2018         uint8\_t raysPerCluster = table3gpp->m\_raysPerCluster;
2019         \textcolor{comment}{//We first update the current location, the previous location will be updated in the end.}
2020 
2021 
2022         \textcolor{comment}{//Step 4: Get LSP from previous channel}
2023         \textcolor{keywordtype}{double} DS = params->m\_DS;
2024         \textcolor{keywordtype}{double} K\_factor = params->m\_K;
2025 
2026         \textcolor{comment}{//Step 5: Update Delays.}
2027         \textcolor{comment}{//copy delay from previous channel.}
2028         \hyperlink{namespacens3_aa6f1edf6566ca6afec613bc6e40240ea}{doubleVector\_t} clusterDelay;
2029         \textcolor{keywordflow}{for}(uint8\_t cInd = 0; cInd < params->m\_numCluster; cInd++)
2030         \{
2031                 clusterDelay.push\_back(params->m\_delay.at(cInd));
2032         \}
2033         \textcolor{comment}{//If LOS condition, we need to revert the tau^LOS\_n back to tau\_n.}
2034         \textcolor{keywordflow}{if}(params->m\_los)
2035         \{
2036                 \textcolor{keywordtype}{double} C\_tau =0.7705-0.0433*K\_factor+2e-4*pow(K\_factor,2)+17e-6*pow(K\_factor,3); \textcolor{comment}{//(7.5-3)}
2037                 \textcolor{keywordflow}{for} (uint8\_t cIndex = 0; cIndex < params->m\_numCluster; cIndex++)
2038                 \{
2039                         clusterDelay.at(cIndex) = clusterDelay.at(cIndex)*C\_tau;
2040                 \}
2041         \}
2042         \textcolor{comment}{//update delay based on equation (7.6-9)}
2043         \textcolor{keywordflow}{for} (uint8\_t cIndex = 0; cIndex < params->m\_numCluster; cIndex++)
2044         \{
2045                 clusterDelay.at(cIndex) -= (sin(params->m\_angle.at(\hyperlink{mmwave-3gpp-channel_8h_a86ab9a21bb66f50f7f4b0c0a0ee1f474}{ZOA\_INDEX}).at(cIndex)*M\_PI/180)
      *cos(params->m\_angle.at(\hyperlink{mmwave-3gpp-channel_8h_a7f1d5772b72f2ce425d85a2b41e8842f}{AOA\_INDEX}).at(cIndex)*M\_PI/180)*params->m\_speed.x
2046                                 + sin(params->m\_angle.at(\hyperlink{mmwave-3gpp-channel_8h_a86ab9a21bb66f50f7f4b0c0a0ee1f474}{ZOA\_INDEX}).at(cIndex)*M\_PI/180)*sin(
      params->m\_angle.at(\hyperlink{mmwave-3gpp-channel_8h_a7f1d5772b72f2ce425d85a2b41e8842f}{AOA\_INDEX}).at(cIndex)*M\_PI/180)*params->m\_speed.y)*
      \hyperlink{classns3_1_1MmWave3gppChannel_a2844f8c7e7373cb777384eaf0e8a7b11}{m\_updatePeriod}.\hyperlink{classns3_1_1Time_a8f20d5c3b0902d7b4320982f340b57c8}{GetSeconds}()/3e8;     \textcolor{comment}{//(7.6-9)}
2047         \}
2048 
2049         \textcolor{comment}{/* since the scaled Los delays are not to be used in cluster power generation,}
2050 \textcolor{comment}{         * we will generate cluster power first and resume to compute Los cluster delay later.*/}
2051 
2052         \textcolor{comment}{//Step 6: Generate cluster powers.}
2053         \hyperlink{namespacens3_aa6f1edf6566ca6afec613bc6e40240ea}{doubleVector\_t} clusterPower;
2054         \textcolor{keywordtype}{double} powerSum = 0;
2055         \textcolor{keywordflow}{for} (uint8\_t cIndex = 0; cIndex < params->m\_numCluster; cIndex++)
2056         \{
2057                 \textcolor{keywordtype}{double} power = exp(-1*clusterDelay.at(cIndex)*(table3gpp->m\_rTau-1)/table3gpp->m\_rTau/DS)*
2058                                 pow(10,-1*\hyperlink{classns3_1_1MmWave3gppChannel_ac2e02ebacc72ed96518d785f2dc87c57}{m\_normalRv}->\hyperlink{classns3_1_1NormalRandomVariable_a0134d131477bc439cc6ff7cbe84b03a9}{GetValue}()*table3gpp->
      m\_shadowingStd/10); \textcolor{comment}{//(7.5-5)}
2059                 powerSum +=power;
2060                 clusterPower.push\_back(power);
2061         \}
2062 
2063         \textcolor{comment}{// we do not need to compute the cluster power of LOS case, since it is used for generating angles.}
2064         \textcolor{keywordflow}{for} (uint8\_t cIndex = 0; cIndex < params->m\_numCluster; cIndex++)
2065         \{
2066                 clusterPower.at(cIndex) = clusterPower.at(cIndex)/powerSum; \textcolor{comment}{//(7.5-6)}
2067         \}
2068 
2069         \textcolor{comment}{// Resume step 5 to compute the delay for LoS condition.}
2070         \textcolor{keywordflow}{if}(params->m\_los)
2071         \{
2072                 \textcolor{keywordtype}{double} C\_tau =0.7705-0.0433*K\_factor+2e-4*pow(K\_factor,2)+17e-6*pow(K\_factor,3); \textcolor{comment}{//(7.5-3)}
2073                 \textcolor{keywordflow}{for} (uint8\_t cIndex = 0; cIndex < params->m\_numCluster; cIndex++)
2074                 \{
2075                         clusterDelay.at(cIndex) = clusterDelay.at(cIndex)/C\_tau; \textcolor{comment}{//(7.5-4)}
2076                 \}
2077         \}
2078 
2079         \textcolor{comment}{/*std::cout << "Delay:";}
2080 \textcolor{comment}{        for (uint8\_t i = 0; i < params->m\_numCluster; i++)}
2081 \textcolor{comment}{        \{}
2082 \textcolor{comment}{                std::cout <<clusterDelay.at(i)<<"s\(\backslash\)t";}
2083 \textcolor{comment}{        \}}
2084 \textcolor{comment}{        std::cout << "\(\backslash\)n";}
2085 \textcolor{comment}{        std::cout << "Power:";}
2086 \textcolor{comment}{        for (uint8\_t i = 0; i < params->m\_numCluster; i++)}
2087 \textcolor{comment}{        \{}
2088 \textcolor{comment}{                std::cout <<clusterPower.at(i)<<"\(\backslash\)t";}
2089 \textcolor{comment}{        \}}
2090 \textcolor{comment}{        std::cout << "\(\backslash\)n";*/}
2091 
2092         \textcolor{comment}{//step 7: Generate arrival and departure angles for both azimuth and elevation.}
2093 
2094         \textcolor{comment}{//copy the angles from previous channel}
2095         \hyperlink{namespacens3_aa6f1edf6566ca6afec613bc6e40240ea}{doubleVector\_t} clusterAoa, clusterZoa, clusterAod, clusterZod;
2096         \textcolor{comment}{/*}
2097 \textcolor{comment}{         * copy the angles from previous channel}
2098 \textcolor{comment}{         * need to change the angle according to equations (7.6-11) - (7.6-14)*/}
2099         \textcolor{keywordflow}{for} (uint8\_t cIndex = 0; cIndex < params->m\_numCluster; cIndex++)
2100         \{
2101                 clusterAoa.push\_back(params->m\_angle.at(\hyperlink{mmwave-3gpp-channel_8h_a7f1d5772b72f2ce425d85a2b41e8842f}{AOA\_INDEX}).at(cIndex));
2102                 clusterZoa.push\_back(params->m\_angle.at(\hyperlink{mmwave-3gpp-channel_8h_a86ab9a21bb66f50f7f4b0c0a0ee1f474}{ZOA\_INDEX}).at(cIndex));
2103                 clusterAod.push\_back(params->m\_angle.at(\hyperlink{mmwave-3gpp-channel_8h_af0ca9ddb9e3346bd827d865de86dc5cb}{AOD\_INDEX}).at(cIndex));
2104                 clusterZod.push\_back(params->m\_angle.at(\hyperlink{mmwave-3gpp-channel_8h_ae854b569d54c7f279a42fae34ad464f9}{ZOD\_INDEX}).at(cIndex));
2105         \}
2106         \textcolor{keywordtype}{double} v = sqrt(params->m\_speed.x*params->m\_speed.x + params->m\_speed.y*params->m\_speed.y);
2107         \textcolor{keywordflow}{if}(v > 1e-6)\textcolor{comment}{//Update the angles only when the speed is not 0.}
2108         \{
2109                 \textcolor{keywordflow}{if}(params->m\_norRvAngles.size () ==0)
2110                 \{
2111                         \textcolor{comment}{//initial case}
2112                         \textcolor{keywordflow}{for} (uint8\_t cInd = 0; cInd < params->m\_numCluster; cInd++)
2113                         \{
2114                                 \hyperlink{namespacens3_aa6f1edf6566ca6afec613bc6e40240ea}{doubleVector\_t} temp;
2115                                 temp.push\_back(0); \textcolor{comment}{//initial random angle for AOA}
2116                                 temp.push\_back(0); \textcolor{comment}{//initial random angle for ZOA}
2117                                 temp.push\_back(0); \textcolor{comment}{//initial random angle for AOD}
2118                                 temp.push\_back(0); \textcolor{comment}{//initial random angle for ZOD}
2119                                 params->m\_norRvAngles.push\_back(temp);
2120                         \}
2121                 \}
2122                 \textcolor{keywordflow}{for} (uint8\_t cInd = 0; cInd < params->m\_numCluster; cInd++)
2123                 \{
2124                         \textcolor{keywordtype}{double}  timeDiff = \hyperlink{group__simulator_gac3635e2e87f7ce316c89290ee1b01d0d}{Now}().\hyperlink{classns3_1_1Time_a8f20d5c3b0902d7b4320982f340b57c8}{GetSeconds}()-params->m\_generatedTime.
      GetSeconds();
2125                         \textcolor{keywordtype}{double} ranPhiAOD, ranThetaZOD, ranPhiAOA, ranThetaZOA;
2126                         \textcolor{keywordflow}{if}(params->m\_los && cInd == 0)\textcolor{comment}{//These angles equal 0 for LOS path.}
2127                         \{
2128                                 ranPhiAOD = 0;
2129                                 ranThetaZOD = 0;
2130                                 ranPhiAOA = 0;
2131                                 ranThetaZOA = 0;
2132                         \}
2133                         \textcolor{keywordflow}{else}
2134                         \{
2135                                 \textcolor{keywordtype}{double} deltaX =sqrt(pow(params->m\_preLocUT.x-params->m\_locUT.x, 2)+pow(
      params->m\_preLocUT.y-params->m\_locUT.y, 2));
2136                                 \textcolor{keywordtype}{double} R\_phi = exp(-1*deltaX/50); \textcolor{comment}{// 50 m is the correlation distance as
       specified in TR 38.900 Sec 7.6.3.2}
2137                                 \textcolor{keywordtype}{double} R\_theta = exp(-1*deltaX/100); \textcolor{comment}{// 100 m is the correlation distance
       as specified in TR 38.900 Sec 7.6.3.2}
2138 
2139                                 \textcolor{comment}{//In order to generate correlated uniform random variables, we first
       generate correlated normal random variables and map the normal RV to uniform RV.}
2140                                 \textcolor{comment}{//Notice the correlation will change if the RV is transformed from normal
       to uniform.}
2141                                 \textcolor{comment}{//To compensate the distortion, the correlation of the normal RV is
       computed}
2142                                 \textcolor{comment}{//such that the uniform RV would have the desired correlation when
       transformed from normal RV.}
2143 
2144                                 \textcolor{comment}{//The following formula was obtained from MATLAB numerical simulation.}
2145 
2146                                 \textcolor{keywordflow}{if}(R\_phi*R\_phi*(-0.069)+R\_phi*1.074-0.002 < 1)\textcolor{comment}{//When the correlation for
       normal RV is close to 1, no need to transform.}
2147                                 \{
2148                                         R\_phi = R\_phi*R\_phi*(-0.069)+R\_phi*1.074-0.002;
2149                                 \}
2150                                 \textcolor{keywordflow}{if}(R\_theta*R\_theta*(-0.069)+R\_theta*1.074-0.002 < 1)
2151                                 \{
2152                                         R\_theta = R\_theta*R\_theta*(-0.069)+R\_theta*1.074-0.002;
2153                                 \}
2154 
2155                                 \textcolor{comment}{//We can generate a new correlated normal RV with the following formula}
2156                                 params->m\_norRvAngles.at(cInd).at(\hyperlink{mmwave-3gpp-channel_8h_af0ca9ddb9e3346bd827d865de86dc5cb}{AOD\_INDEX}) = R\_phi*params->
      m\_norRvAngles.at(cInd).at(\hyperlink{mmwave-3gpp-channel_8h_af0ca9ddb9e3346bd827d865de86dc5cb}{AOD\_INDEX})+sqrt(1-R\_phi*R\_phi)*\hyperlink{classns3_1_1MmWave3gppChannel_ac2e02ebacc72ed96518d785f2dc87c57}{m\_normalRv}->
      \hyperlink{classns3_1_1NormalRandomVariable_a0134d131477bc439cc6ff7cbe84b03a9}{GetValue}();
2157                                 params->m\_norRvAngles.at(cInd).at(\hyperlink{mmwave-3gpp-channel_8h_ae854b569d54c7f279a42fae34ad464f9}{ZOD\_INDEX}) = R\_theta*params->
      m\_norRvAngles.at(cInd).at(\hyperlink{mmwave-3gpp-channel_8h_ae854b569d54c7f279a42fae34ad464f9}{ZOD\_INDEX})+sqrt(1-R\_theta*R\_theta)*\hyperlink{classns3_1_1MmWave3gppChannel_ac2e02ebacc72ed96518d785f2dc87c57}{m\_normalRv}->
      \hyperlink{classns3_1_1NormalRandomVariable_a0134d131477bc439cc6ff7cbe84b03a9}{GetValue}();
2158                                 params->m\_norRvAngles.at(cInd).at(\hyperlink{mmwave-3gpp-channel_8h_a7f1d5772b72f2ce425d85a2b41e8842f}{AOA\_INDEX}) = R\_phi*params->
      m\_norRvAngles.at(cInd).at(\hyperlink{mmwave-3gpp-channel_8h_a7f1d5772b72f2ce425d85a2b41e8842f}{AOA\_INDEX})+sqrt(1-R\_phi*R\_phi)*\hyperlink{classns3_1_1MmWave3gppChannel_ac2e02ebacc72ed96518d785f2dc87c57}{m\_normalRv}->
      \hyperlink{classns3_1_1NormalRandomVariable_a0134d131477bc439cc6ff7cbe84b03a9}{GetValue}();
2159                                 params->m\_norRvAngles.at(cInd).at(\hyperlink{mmwave-3gpp-channel_8h_a86ab9a21bb66f50f7f4b0c0a0ee1f474}{ZOA\_INDEX}) = R\_theta*params->
      m\_norRvAngles.at(cInd).at(\hyperlink{mmwave-3gpp-channel_8h_a86ab9a21bb66f50f7f4b0c0a0ee1f474}{ZOA\_INDEX})+sqrt(1-R\_theta*R\_theta)*\hyperlink{classns3_1_1MmWave3gppChannel_ac2e02ebacc72ed96518d785f2dc87c57}{m\_normalRv}->
      \hyperlink{classns3_1_1NormalRandomVariable_a0134d131477bc439cc6ff7cbe84b03a9}{GetValue}();
2160 
2161                                 \textcolor{comment}{//The normal RV is transformed to uniform RV with the desired correlation.}
2162                                 ranPhiAOD = (0.5*erfc(-1*params->m\_norRvAngles.at(cInd).at(
      \hyperlink{mmwave-3gpp-channel_8h_af0ca9ddb9e3346bd827d865de86dc5cb}{AOD\_INDEX})/sqrt(2)))*2*M\_PI-M\_PI;
2163                                 ranThetaZOD = (0.5*erfc(-1*params->m\_norRvAngles.at(cInd).at(
      \hyperlink{mmwave-3gpp-channel_8h_ae854b569d54c7f279a42fae34ad464f9}{ZOD\_INDEX})/sqrt(2)))*M\_PI-0.5*M\_PI;
2164                                 ranPhiAOA = (0.5*erfc(-1*params->m\_norRvAngles.at(cInd).at(
      \hyperlink{mmwave-3gpp-channel_8h_a7f1d5772b72f2ce425d85a2b41e8842f}{AOA\_INDEX})/sqrt(2)))*2*M\_PI-M\_PI;
2165                                 ranThetaZOA = (0.5*erfc(-1*params->m\_norRvAngles.at(cInd).at(
      \hyperlink{mmwave-3gpp-channel_8h_a86ab9a21bb66f50f7f4b0c0a0ee1f474}{ZOA\_INDEX})/sqrt(2)))*M\_PI-0.5*M\_PI;
2166                         \}
2167                         clusterAod.at(cInd) += v*timeDiff*
2168                                         sin(atan(params->m\_speed.y/params->m\_speed.x)-clusterAod.at(cInd)*
      M\_PI/180+ranPhiAOD)*180/(M\_PI*params->m\_dis2D);
2169                         clusterZod.at(cInd) -= v*timeDiff*
2170                                         cos(atan(params->m\_speed.y/params->m\_speed.x)-clusterAod.at(cInd)*
      M\_PI/180+ranThetaZOD)*180/(M\_PI*params->m\_dis3D);
2171                         clusterAoa.at(cInd) -= v*timeDiff*
2172                                         sin(atan(params->m\_speed.y/params->m\_speed.x)-clusterAoa.at(cInd)*
      M\_PI/180+ranPhiAOA)*180/(M\_PI*params->m\_dis2D);
2173                         clusterZoa.at(cInd) -= v*timeDiff*
2174                                         cos(atan(params->m\_speed.y/params->m\_speed.x)-clusterAoa.at(cInd)*
      M\_PI/180+ranThetaZOA)*180/(M\_PI*params->m\_dis3D);
2175                 \}
2176         \}
2177 
2178 
2179         \textcolor{keywordtype}{double} rayAoa\_radian[params->m\_numCluster][raysPerCluster]; \textcolor{comment}{//rayAoa\_radian[n][m], where n is
       cluster index, m is ray index}
2180         \textcolor{keywordtype}{double} rayAod\_radian[params->m\_numCluster][raysPerCluster]; \textcolor{comment}{//rayAod\_radian[n][m], where n is
       cluster index, m is ray index}
2181         \textcolor{keywordtype}{double} rayZoa\_radian[params->m\_numCluster][raysPerCluster]; \textcolor{comment}{//rayZoa\_radian[n][m], where n is
       cluster index, m is ray index}
2182         \textcolor{keywordtype}{double} rayZod\_radian[params->m\_numCluster][raysPerCluster]; \textcolor{comment}{//rayZod\_radian[n][m], where n is
       cluster index, m is ray index}
2183 
2184         \textcolor{keywordflow}{for} (uint8\_t nInd = 0; nInd < params->m\_numCluster; nInd++)
2185         \{
2186                 \textcolor{keywordflow}{for}(uint8\_t mInd = 0; mInd < raysPerCluster; mInd++)
2187                 \{
2188                         \textcolor{keywordtype}{double} tempAoa = clusterAoa.at(nInd) + table3gpp->m\_cASA*
      \hyperlink{namespacens3_a2344173eeb094a196c555a159e87bc6f}{offSetAlpha}[mInd]; \textcolor{comment}{//(7.5-13)}
2189                         \textcolor{keywordflow}{while} (tempAoa > 360)
2190                         \{
2191                                 tempAoa -= 360;
2192                         \}
2193 
2194                         \textcolor{keywordflow}{while} (tempAoa < 0)
2195                         \{
2196                                 tempAoa += 360;
2197 
2198                         \}
2199                         \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG}(tempAoa>=0 && tempAoa<=360, \textcolor{stringliteral}{"the AOA should be the range
       of [0,360]"});
2200                         rayAoa\_radian[nInd][mInd] = tempAoa*M\_PI/180;
2201 
2202                         \textcolor{keywordtype}{double} tempAod = clusterAod.at(nInd) + table3gpp->m\_cASD*
      \hyperlink{namespacens3_a2344173eeb094a196c555a159e87bc6f}{offSetAlpha}[mInd];
2203                         \textcolor{keywordflow}{while} (tempAod > 360)
2204                         \{
2205                                 tempAod -= 360;
2206                         \}
2207 
2208                         \textcolor{keywordflow}{while} (tempAod < 0)
2209                         \{
2210                                 tempAod += 360;
2211                         \}
2212                         \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG}(tempAod>=0 && tempAod<=360, \textcolor{stringliteral}{"the AOD should be the range
       of [0,360]"});
2213                         rayAod\_radian[nInd][mInd] = tempAod*M\_PI/180;
2214 
2215                         \textcolor{keywordtype}{double} tempZoa = clusterZoa.at(nInd) + table3gpp->m\_cZSA*
      \hyperlink{namespacens3_a2344173eeb094a196c555a159e87bc6f}{offSetAlpha}[mInd]; \textcolor{comment}{//(7.5-18)}
2216 
2217                         \textcolor{keywordflow}{while}(tempZoa > 360)
2218                         \{
2219                                 tempZoa -= 360;
2220                         \}
2221 
2222                         \textcolor{keywordflow}{while} (tempZoa < 0)
2223                         \{
2224                                 tempZoa += 360;
2225                         \}
2226 
2227                         \textcolor{keywordflow}{if} (tempZoa > 180)
2228                         \{
2229                                 tempZoa = 360-tempZoa;
2230                         \}
2231 
2232                         \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG}(tempZoa>=0&&tempZoa<=180, \textcolor{stringliteral}{"the ZOA should be the range
       of [0,180]"});
2233                         rayZoa\_radian[nInd][mInd] = tempZoa*M\_PI/180;
2234 
2235                         \textcolor{keywordtype}{double} tempZod = clusterZod.at(nInd)+0.375*pow(10,table3gpp->m\_uLgZSD)*
      \hyperlink{namespacens3_a2344173eeb094a196c555a159e87bc6f}{offSetAlpha}[mInd]; \textcolor{comment}{//(7.5-20)}
2236 
2237                         \textcolor{keywordflow}{while}(tempZod > 360)
2238                         \{
2239                                 tempZod -= 360;
2240                         \}
2241 
2242                         \textcolor{keywordflow}{while} (tempZod < 0)
2243                         \{
2244                                 tempZod += 360;
2245                         \}
2246                         \textcolor{keywordflow}{if} (tempZod > 180)
2247                         \{
2248                                 tempZod = 360-tempZod;
2249                         \}
2250                         \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG}(tempZod>=0&&tempZod<=180, \textcolor{stringliteral}{"the ZOD should be the range
       of [0,180]"});
2251                         rayZod\_radian[nInd][mInd] = tempZod*M\_PI/180;
2252                 \}
2253         \}
2254 
2255         \hyperlink{namespacens3_aa6f1edf6566ca6afec613bc6e40240ea}{doubleVector\_t} angle\_degree;
2256         \textcolor{keywordtype}{double} sizeTemp = clusterZoa.size();
2257         \textcolor{keywordflow}{for} (uint8\_t ind = 0; ind < 4; ind++)
2258         \{
2259                 \textcolor{keywordflow}{switch}(ind)
2260                 \{
2261                 \textcolor{keywordflow}{case} 0: angle\_degree = clusterAoa;
2262                                 \textcolor{keywordflow}{break};
2263                 \textcolor{keywordflow}{case} 1: angle\_degree = clusterZoa;
2264                                 \textcolor{keywordflow}{break};
2265                 \textcolor{keywordflow}{case} 2: angle\_degree = clusterAod;
2266                                 \textcolor{keywordflow}{break};
2267                 \textcolor{keywordflow}{case} 3: angle\_degree = clusterZod;
2268                                 \textcolor{keywordflow}{break};
2269                 \textcolor{keywordflow}{default}:
2270                         \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR}(\textcolor{stringliteral}{"Programming Error"});
2271                 \}
2272 
2273                 \textcolor{keywordflow}{for}(uint8\_t nIndex = 0; nIndex < sizeTemp; nIndex++)
2274                 \{
2275                         \textcolor{keywordflow}{while}(angle\_degree[nIndex] > 360)
2276                         \{
2277                                 angle\_degree[nIndex] -= 360;
2278                         \}
2279 
2280                         \textcolor{keywordflow}{while} (angle\_degree[nIndex] < 0)
2281                         \{
2282                                 angle\_degree[nIndex] += 360;
2283                         \}
2284 
2285                         \textcolor{keywordflow}{if}(ind==1 || ind==3)
2286                         \{
2287                                 \textcolor{keywordflow}{if}(angle\_degree[nIndex]>180)
2288                                 \{
2289                                         angle\_degree[nIndex] = 360-angle\_degree[nIndex];
2290                                 \}
2291                         \}
2292                 \}
2293                 \textcolor{keywordflow}{switch}(ind)
2294                 \{
2295                 \textcolor{keywordflow}{case} 0: clusterAoa = angle\_degree;
2296                                 \textcolor{keywordflow}{break};
2297                 \textcolor{keywordflow}{case} 1: clusterZoa = angle\_degree;
2298                                 \textcolor{keywordflow}{break};
2299                 \textcolor{keywordflow}{case} 2: clusterAod = angle\_degree;
2300                                 \textcolor{keywordflow}{break};
2301                 \textcolor{keywordflow}{case} 3: clusterZod = angle\_degree;
2302                                 \textcolor{keywordflow}{break};
2303                 \textcolor{keywordflow}{default}:
2304                         \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR}(\textcolor{stringliteral}{"Programming Error"});
2305                 \}
2306         \}
2307         \hyperlink{namespacens3_aa6f1edf6566ca6afec613bc6e40240ea}{doubleVector\_t} attenuation\_dB;
2308         \textcolor{keywordflow}{if}(\hyperlink{classns3_1_1MmWave3gppChannel_a5f19d0ed379e7db9448f4f668e0c7927}{m\_blockage})
2309         \{
2310                  attenuation\_dB = \hyperlink{classns3_1_1MmWave3gppChannel_aff8853ed48d4aeb1a5d4960a843f5f1a}{CalAttenuationOfBlockage} (params, clusterAoa, 
      clusterZoa);
2311                  \textcolor{keywordflow}{for} (uint8\_t cInd = 0; cInd < params->m\_numCluster; cInd++)
2312                  \{
2313                          clusterPower.at (cInd) = clusterPower.at (cInd)/pow(10,attenuation\_dB.at (cInd)/10
      );
2314                  \}
2315         \}
2316         \textcolor{keywordflow}{else}
2317         \{
2318                 attenuation\_dB.push\_back(0);
2319         \}
2320 
2321         \textcolor{comment}{/*std::cout << "BlockedPower:";}
2322 \textcolor{comment}{        for (uint8\_t i = 0; i < params->m\_numCluster; i++)}
2323 \textcolor{comment}{        \{}
2324 \textcolor{comment}{                std::cout <<clusterPower.at(i)<<"\(\backslash\)t";}
2325 \textcolor{comment}{        \}}
2326 \textcolor{comment}{        std::cout << "\(\backslash\)n";*/}
2327 
2328         \textcolor{comment}{/*std::cout << "AOD:";}
2329 \textcolor{comment}{        for (uint8\_t i = 0; i < params->m\_numCluster; i++)}
2330 \textcolor{comment}{        \{}
2331 \textcolor{comment}{                std::cout <<clusterAod.at(i)<<"'\(\backslash\)t";}
2332 \textcolor{comment}{        \}}
2333 \textcolor{comment}{        std::cout << "\(\backslash\)n";}
2334 \textcolor{comment}{}
2335 \textcolor{comment}{        std::cout << "AOA:";}
2336 \textcolor{comment}{        for (uint8\_t i = 0; i < params->m\_numCluster; i++)}
2337 \textcolor{comment}{        \{}
2338 \textcolor{comment}{                std::cout <<clusterAoa.at(i)<<"'\(\backslash\)t";}
2339 \textcolor{comment}{        \}}
2340 \textcolor{comment}{        std::cout << "\(\backslash\)n";}
2341 \textcolor{comment}{}
2342 \textcolor{comment}{        std::cout << "ZOD:";}
2343 \textcolor{comment}{        for (uint8\_t i = 0; i < params->m\_numCluster; i++)}
2344 \textcolor{comment}{        \{}
2345 \textcolor{comment}{                std::cout <<clusterZod.at(i)<<"'\(\backslash\)t";}
2346 \textcolor{comment}{                for (uint8\_t d = 0; d < raysPerCluster; d++)}
2347 \textcolor{comment}{                \{}
2348 \textcolor{comment}{                        std::cout <<rayZod\_radian[i][d]<<"\(\backslash\)t";}
2349 \textcolor{comment}{                \}}
2350 \textcolor{comment}{                std::cout << "\(\backslash\)n";}
2351 \textcolor{comment}{        \}}
2352 \textcolor{comment}{        std::cout << "\(\backslash\)n";}
2353 \textcolor{comment}{}
2354 \textcolor{comment}{        std::cout << "ZOA:";}
2355 \textcolor{comment}{        for (uint8\_t i = 0; i < params->m\_numCluster; i++)}
2356 \textcolor{comment}{        \{}
2357 \textcolor{comment}{                std::cout <<clusterZoa.at(i)<<"'\(\backslash\)t";}
2358 \textcolor{comment}{        \}}
2359 \textcolor{comment}{        std::cout << "\(\backslash\)n";*/}
2360 
2361 
2362         \textcolor{comment}{//Step 8: Coupling of rays within a cluster for both azimuth and elevation}
2363         \textcolor{comment}{//shuffle all the arrays to perform random coupling}
2364 
2365 
2366         \textcolor{comment}{//since the updating and original generated angles should have the same order of "random coupling",}
2367         \textcolor{comment}{//I control the seed of each shuffle, so that the update and original generated angle use the same
       seed.}
2368         \textcolor{comment}{//Is this correct?}
2369 
2370         \textcolor{keywordflow}{for} (uint8\_t cIndex = 0; cIndex < params->m\_numCluster; cIndex++)
2371         \{
2372                 std::shuffle(&rayAod\_radian[cIndex][0],&rayAod\_radian[cIndex][raysPerCluster],
      std::default\_random\_engine(cIndex*1000+100));
2373                 std::shuffle(&rayAoa\_radian[cIndex][0],&rayAoa\_radian[cIndex][raysPerCluster],
      std::default\_random\_engine(cIndex*1000+200));
2374                 std::shuffle(&rayZod\_radian[cIndex][0],&rayZod\_radian[cIndex][raysPerCluster],
      std::default\_random\_engine(cIndex*1000+300));
2375                 std::shuffle(&rayZoa\_radian[cIndex][0],&rayZoa\_radian[cIndex][raysPerCluster],
      std::default\_random\_engine(cIndex*1000+400));
2376         \}
2377 
2378         \textcolor{comment}{//Step 9: Generate the cross polarization power ratios}
2379         \textcolor{comment}{//This step is skipped, only vertical polarization is considered in this version}
2380 
2381         \textcolor{comment}{//Step 10: Draw initial phases}
2382         \hyperlink{namespacens3_a908ae777c72964ccedbcf2310527a67e}{double2DVector\_t} clusterPhase = params->m\_clusterPhase; \textcolor{comment}{//rayAoa\_radian[n][m],
       where n is cluster index, m is ray index}
2383         \textcolor{keywordtype}{double} losPhase = params->m\_losPhase;
2384         \textcolor{comment}{// these two should also be generated from previous channel.}
2385 
2386         \textcolor{comment}{//Step 11: Generate channel coefficients for each cluster n and each receiver and transmitter
       element pair u,s.}
2387 
2388         \hyperlink{namespacens3_afbc512ea4e4657e80b7ac44f78fc81ad}{complex3DVector\_t} H\_NLOS; \textcolor{comment}{// channel coefficients H\_NLOS [u][s][n],}
2389                                                           \textcolor{comment}{// where u and s are receive and transmit antenna
       element, n is cluster index.}
2390         uint16\_t uSize = rxAntennaNum[0]*rxAntennaNum[1];
2391         uint16\_t sSize = txAntennaNum[0]*txAntennaNum[1];
2392 
2393         uint8\_t cluster1st = 0, cluster2nd = 0; \textcolor{comment}{// first and second strongest cluster;}
2394         \textcolor{keywordtype}{double} maxPower = 0;
2395         \textcolor{keywordflow}{for} (uint8\_t cIndex = 0; cIndex < params->m\_numCluster; cIndex++)
2396         \{
2397                 \textcolor{keywordflow}{if} (maxPower<clusterPower.at (cIndex))
2398                 \{
2399                         maxPower = clusterPower.at (cIndex);
2400                         cluster1st = cIndex;
2401                 \}
2402         \}
2403         maxPower = 0;
2404         \textcolor{keywordflow}{for} (uint8\_t cIndex = 0; cIndex < params->m\_numCluster; cIndex++)
2405         \{
2406                 \textcolor{keywordflow}{if} (maxPower<clusterPower.at (cIndex) && cluster1st != cIndex)
2407                 \{
2408                         maxPower = clusterPower.at (cIndex);
2409                         cluster2nd = cIndex;
2410                 \}
2411         \}
2412 
2413         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"1st strongest cluster:"}<<(\textcolor{keywordtype}{int})cluster1st<<\textcolor{stringliteral}{", 2nd strongest cluster:"}<<(\textcolor{keywordtype}{int}
      )cluster2nd);
2414 
2415         \hyperlink{namespacens3_afbc512ea4e4657e80b7ac44f78fc81ad}{complex3DVector\_t} H\_usn; \textcolor{comment}{//channel coffecient H\_usn[u][s][n];}
2416         \textcolor{comment}{//Since each of the strongest 2 clusters are divided into 3 sub-clusters, the total cluster will be
       numReducedCLuster + 4.}
2417 
2418         H\_usn.resize(uSize);
2419         \textcolor{keywordflow}{for} (uint16\_t uIndex = 0; uIndex < uSize; uIndex++)
2420         \{
2421                 H\_usn.at(uIndex).resize(sSize);
2422                 \textcolor{keywordflow}{for} (uint16\_t sIndex = 0; sIndex < sSize; sIndex++)
2423                 \{
2424                         H\_usn.at(uIndex).at(sIndex).resize(params->m\_numCluster);
2425                 \}
2426         \}
2427         \textcolor{comment}{//double slotTime = Simulator::Now ().GetSeconds ();}
2428         \textcolor{comment}{// The following for loops computes the channel coefficients}
2429         \textcolor{keywordflow}{for} (uint16\_t uIndex = 0; uIndex < uSize; uIndex++)
2430         \{
2431                 Vector uLoc = rxAntenna->GetAntennaLocation(uIndex,rxAntennaNum);
2432 
2433                 \textcolor{keywordflow}{for} (uint16\_t sIndex = 0; sIndex < sSize; sIndex++)
2434                 \{
2435 
2436                         Vector sLoc = txAntenna->GetAntennaLocation(sIndex,txAntennaNum);
2437 
2438                         \textcolor{keywordflow}{for} (uint8\_t nIndex = 0; nIndex < params->m\_numCluster; nIndex++)
2439                         \{
2440                                 \textcolor{comment}{//Compute the N-2 weakest cluster, only vertical polarization. (7.5-22)}
2441                                 \textcolor{keywordflow}{if}(nIndex != cluster1st && nIndex != cluster2nd)
2442                                 \{
2443                                         std::complex<double> rays(0,0);
2444                                         \textcolor{keywordflow}{for}(uint8\_t mIndex = 0; mIndex < raysPerCluster; mIndex++)
2445                                         \{
2446                                                 \textcolor{keywordtype}{double} initialPhase = clusterPhase.at(nIndex).at(mIndex);
2447                                                 \textcolor{comment}{//lambda\_0 is accounted in the antenna spacing uLoc and
       sLoc.}
2448                                                 \textcolor{keywordtype}{double} rxPhaseDiff = 2*M\_PI*(sin(rayZoa\_radian[nIndex][
      mIndex])*cos(rayAoa\_radian[nIndex][mIndex])*uLoc.x
2449                                                                 + sin(rayZoa\_radian[nIndex][mIndex])*sin(
      rayAoa\_radian[nIndex][mIndex])*uLoc.y
2450                                                                 + cos(rayZoa\_radian[nIndex][mIndex])*uLoc.z
      );
2451 
2452                                                 \textcolor{keywordtype}{double} txPhaseDiff = 2*M\_PI*(sin(rayZod\_radian[nIndex][
      mIndex])*cos(rayAod\_radian[nIndex][mIndex])*sLoc.x
2453                                                                 + sin(rayZod\_radian[nIndex][mIndex])*sin(
      rayAod\_radian[nIndex][mIndex])*sLoc.y
2454                                                                 + cos(rayZod\_radian[nIndex][mIndex])*sLoc.z
      );
2455                                                 \textcolor{comment}{//Doppler is computed in the CalBeamformingGain function
       and is simplified to only account for the center anngle of each cluster.}
2456                                                 \textcolor{comment}{//double doppler =
       2*M\_PI*(sin(rayZoa\_radian[nIndex][mIndex])*cos(rayAoa\_radian[nIndex][mIndex])*relativeSpeed.x}
2457                                                 \textcolor{comment}{//              +
       sin(rayZoa\_radian[nIndex][mIndex])*sin(rayAoa\_radian[nIndex][mIndex])*relativeSpeed.y}
2458                                                 \textcolor{comment}{//              +
       cos(rayZoa\_radian[nIndex][mIndex])*relativeSpeed.z)*slotTime*m\_phyMacConfig->GetCenterFrequency ()/3e8;}
2459                                                 rays += exp(std::complex<double>(0, initialPhase))
2460                                                                 *(rxAntenna->GetRadiationPattern(
      rayZoa\_radian[nIndex][mIndex])*txAntenna->GetRadiationPattern(rayZod\_radian[nIndex][mIndex]))
2461                                                                 *exp(std::complex<double>(0, rxPhaseDiff))
2462                                                                 *exp(std::complex<double>(0, txPhaseDiff));
2463                                                                 \textcolor{comment}{//*exp(std::complex<double>(0, doppler));}
2464                                                 \textcolor{comment}{//rays += 1;}
2465                                         \}
2466                                         \textcolor{comment}{//rays *= sqrt(clusterPower.at(nIndex))/raysPerCluster;}
2467                                         rays *= sqrt(clusterPower.at(nIndex)/raysPerCluster);
2468                                         H\_usn.at(uIndex).at(sIndex).at(nIndex) = rays;
2469                                 \}
2470                                 \textcolor{keywordflow}{else} \textcolor{comment}{//(7.5-28)}
2471                                 \{
2472                                         std::complex<double> raysSub1(0,0);
2473                                         std::complex<double> raysSub2(0,0);
2474                                         std::complex<double> raysSub3(0,0);
2475 
2476                                         \textcolor{keywordflow}{for}(uint8\_t mIndex = 0; mIndex < raysPerCluster; mIndex++)
2477                                         \{
2478                                                 \textcolor{keywordtype}{double} initialPhase = clusterPhase.at(nIndex).at(mIndex);
2479                                                 \textcolor{keywordtype}{double} rxPhaseDiff = 2*M\_PI*(sin(rayZoa\_radian[nIndex][
      mIndex])*cos(rayAoa\_radian[nIndex][mIndex])*uLoc.x
2480                                                                 + sin(rayZoa\_radian[nIndex][mIndex])*sin(
      rayAoa\_radian[nIndex][mIndex])*uLoc.y
2481                                                                 + cos(rayZoa\_radian[nIndex][mIndex])*uLoc.z
      );
2482                                                 \textcolor{keywordtype}{double} txPhaseDiff = 2*M\_PI*(sin(rayZod\_radian[nIndex][
      mIndex])*cos(rayAod\_radian[nIndex][mIndex])*sLoc.x
2483                                                                 + sin(rayZod\_radian[nIndex][mIndex])*sin(
      rayAod\_radian[nIndex][mIndex])*sLoc.y
2484                                                                 + cos(rayZod\_radian[nIndex][mIndex])*sLoc.z
      );
2485                                                 \textcolor{comment}{//double doppler =
       2*M\_PI*(sin(rayZoa\_radian[nIndex][mIndex])*cos(rayAoa\_radian[nIndex][mIndex])*relativeSpeed.x}
2486                                                 \textcolor{comment}{//              +
       sin(rayZoa\_radian[nIndex][mIndex])*sin(rayAoa\_radian[nIndex][mIndex])*relativeSpeed.y}
2487                                                 \textcolor{comment}{//              +
       cos(rayZoa\_radian[nIndex][mIndex])*relativeSpeed.z)*slotTime*m\_phyMacConfig->GetCenterFrequency ()/3e8;}
2488                                                 \textcolor{comment}{//double delaySpread;}
2489                                                 \textcolor{keywordflow}{switch}(mIndex)
2490                                                 \{
2491                                                 \textcolor{keywordflow}{case} 9:
2492                                                 \textcolor{keywordflow}{case} 10:
2493                                                 \textcolor{keywordflow}{case} 11:
2494                                                 \textcolor{keywordflow}{case} 12:
2495                                                 \textcolor{keywordflow}{case} 17:
2496                                                 \textcolor{keywordflow}{case} 18:
2497                                                         \textcolor{comment}{//delaySpread=
       -2*M\_PI*(clusterDelay.at(nIndex)+1.28*c\_DS)*m\_phyMacConfig->GetCenterFrequency ();}
2498                                                         raysSub2 += exp(std::complex<double>(0, 
      initialPhase))
2499                                                                 *(rxAntenna->GetRadiationPattern(
      rayZoa\_radian[nIndex][mIndex])*txAntenna->GetRadiationPattern(rayZod\_radian[nIndex][mIndex]))
2500                                                                 *exp(std::complex<double>(0, rxPhaseDiff))
2501                                                                 *exp(std::complex<double>(0, txPhaseDiff));
2502                                                                 \textcolor{comment}{//*exp(std::complex<double>(0, doppler));}
2503                                                         \textcolor{comment}{//raysSub2 +=1;}
2504                                                         \textcolor{keywordflow}{break};
2505                                                 \textcolor{keywordflow}{case} 13:
2506                                                 \textcolor{keywordflow}{case} 14:
2507                                                 \textcolor{keywordflow}{case} 15:
2508                                                 \textcolor{keywordflow}{case} 16:
2509                                                         \textcolor{comment}{//delaySpread =
       -2*M\_PI*(clusterDelay.at(nIndex)+2.56*c\_DS)*m\_phyMacConfig->GetCenterFrequency ();}
2510                                                         raysSub3 += exp(std::complex<double>(0, 
      initialPhase))
2511                                                                 *(rxAntenna->GetRadiationPattern(
      rayZoa\_radian[nIndex][mIndex])*txAntenna->GetRadiationPattern(rayZod\_radian[nIndex][mIndex]))
2512                                                                 *exp(std::complex<double>(0, rxPhaseDiff))
2513                                                                 *exp(std::complex<double>(0, txPhaseDiff));
2514                                                                 \textcolor{comment}{//*exp(std::complex<double>(0, doppler));}
2515                                                         \textcolor{comment}{//raysSub3 +=1;}
2516                                                         \textcolor{keywordflow}{break};
2517                                                 \textcolor{keywordflow}{default}:\textcolor{comment}{//case 1,2,3,4,5,6,7,8,19,20}
2518                                                         \textcolor{comment}{//delaySpread =
       -2*M\_PI*clusterDelay.at(nIndex)*m\_phyMacConfig->GetCenterFrequency ();}
2519                                                         raysSub1 += exp(std::complex<double>(0, 
      initialPhase))
2520                                                                 *(rxAntenna->GetRadiationPattern(
      rayZoa\_radian[nIndex][mIndex])*txAntenna->GetRadiationPattern(rayZod\_radian[nIndex][mIndex]))
2521                                                                 *exp(std::complex<double>(0, rxPhaseDiff))
2522                                                                 *exp(std::complex<double>(0, txPhaseDiff));
2523                                                                 \textcolor{comment}{//*exp(std::complex<double>(0, doppler));}
2524                                                         \textcolor{comment}{//raysSub1 +=1;}
2525                                                         \textcolor{keywordflow}{break};
2526                                                 \}
2527                                         \}
2528                                         \textcolor{comment}{//raysSub1 *= sqrt(clusterPower.at(nIndex))/raysPerCluster;}
2529                                         \textcolor{comment}{//raysSub2 *= sqrt(clusterPower.at(nIndex))/raysPerCluster;}
2530                                         \textcolor{comment}{//raysSub3 *= sqrt(clusterPower.at(nIndex))/raysPerCluster;}
2531                                         raysSub1 *= sqrt(clusterPower.at(nIndex)/raysPerCluster);
2532                                         raysSub2 *= sqrt(clusterPower.at(nIndex)/raysPerCluster);
2533                                         raysSub3 *= sqrt(clusterPower.at(nIndex)/raysPerCluster);
2534                                         H\_usn.at(uIndex).at(sIndex).at(nIndex) = raysSub1;
2535                                         H\_usn.at(uIndex).at(sIndex).push\_back(raysSub2);
2536                                         H\_usn.at(uIndex).at(sIndex).push\_back(raysSub3);
2537 
2538                                 \}
2539                         \}
2540                         \textcolor{keywordflow}{if}(params->m\_los) \textcolor{comment}{//(7.5-29) && (7.5-30)}
2541                         \{
2542                                 std::complex<double> ray(0,0);
2543                                 \textcolor{keywordtype}{double} rxPhaseDiff = 2*M\_PI*(sin(rxAngle.theta)*cos(rxAngle.phi)*uLoc.x
2544                                                 + sin(rxAngle.theta)*sin(rxAngle.phi)*uLoc.y
2545                                                 + cos(rxAngle.theta)*uLoc.z);
2546                                 \textcolor{keywordtype}{double} txPhaseDiff = 2*M\_PI*(sin(txAngle.theta)*cos(txAngle.phi)*sLoc.x
2547                                                 + sin(txAngle.theta)*sin(txAngle.phi)*sLoc.y
2548                                                 + cos(txAngle.theta)*sLoc.z);
2549                                 \textcolor{comment}{//double doppler =
       2*M\_PI*(sin(rxAngle.theta)*cos(rxAngle.phi)*relativeSpeed.x}
2550                                 \textcolor{comment}{//              + sin(rxAngle.theta)*sin(rxAngle.phi)*relativeSpeed.y}
2551                                 \textcolor{comment}{//              +
       cos(rxAngle.theta)*relativeSpeed.z)*slotTime*m\_phyMacConfig->GetCenterFrequency ()/3e8;}
2552 
2553                                 ray = exp(std::complex<double>(0, losPhase))
2554                                                 *(rxAntenna->GetRadiationPattern(rxAngle.theta)*txAntenna->
      GetRadiationPattern(txAngle.theta))
2555                                                 *exp(std::complex<double>(0, rxPhaseDiff))
2556                                                 *exp(std::complex<double>(0, txPhaseDiff));
2557                                                 \textcolor{comment}{//*exp(std::complex<double>(0, doppler));}
2558 
2559                                 \textcolor{keywordtype}{double} K\_linear = pow(10,K\_factor/10);
2560 
2561                                 H\_usn.at(uIndex).at(sIndex).at(0) = sqrt(1/(K\_linear+1))*H\_usn.at(uIndex).
      at(sIndex).at(0)+sqrt(K\_linear/(1+K\_linear))*ray/pow(10,attenuation\_dB.at (0)/10);  \textcolor{comment}{//(7.5-30) for tau = tau1}
2562                                 \textcolor{keywordtype}{double} tempSize = H\_usn.at(uIndex).at(sIndex).size();
2563                                 \textcolor{keywordflow}{for}(uint8\_t nIndex = 1; nIndex < tempSize; nIndex++)
2564                                 \{
2565                                         H\_usn.at(uIndex).at(sIndex).at(nIndex) *= sqrt(1/(K\_linear+1)); \textcolor{comment}{//
      (7.5-30) for tau = tau2...taunN}
2566                                 \}
2567 
2568                         \}
2569                 \}
2570         \}
2571 
2572         \textcolor{keywordflow}{if} (cluster1st == cluster2nd)
2573         \{
2574                 clusterDelay.push\_back(clusterDelay.at(cluster2nd)+1.28*table3gpp->m\_cDS);
2575                 clusterDelay.push\_back(clusterDelay.at(cluster2nd)+2.56*table3gpp->m\_cDS);
2576 
2577                 clusterAoa.push\_back(clusterAoa.at(cluster2nd));
2578                 clusterAoa.push\_back(clusterAoa.at(cluster2nd));
2579                 clusterZoa.push\_back(clusterZoa.at(cluster2nd));
2580                 clusterZoa.push\_back(clusterZoa.at(cluster2nd));
2581         \}
2582         \textcolor{keywordflow}{else}
2583         \{
2584                 \textcolor{keywordtype}{double} \hyperlink{80211b_8c_ac6afabdc09a49a433ee19d8a9486056d}{min}, \hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{max};
2585                 \textcolor{keywordflow}{if}(cluster1st < cluster2nd)
2586                 \{
2587                         min = cluster1st;
2588                         max = cluster2nd;
2589                 \}
2590                 \textcolor{keywordflow}{else}
2591                 \{
2592                         min = cluster2nd;
2593                         max = cluster1st;
2594                 \}
2595                 clusterDelay.push\_back(clusterDelay.at(min)+1.28*table3gpp->m\_cDS);
2596                 clusterDelay.push\_back(clusterDelay.at(min)+2.56*table3gpp->m\_cDS);
2597                 clusterDelay.push\_back(clusterDelay.at(max)+1.28*table3gpp->m\_cDS);
2598                 clusterDelay.push\_back(clusterDelay.at(max)+2.56*table3gpp->m\_cDS);
2599 
2600                 clusterAoa.push\_back(clusterAoa.at(min));
2601                 clusterAoa.push\_back(clusterAoa.at(min));
2602                 clusterAoa.push\_back(clusterAoa.at(max));
2603                 clusterAoa.push\_back(clusterAoa.at(max));
2604 
2605                 clusterZoa.push\_back(clusterZoa.at(min));
2606                 clusterZoa.push\_back(clusterZoa.at(min));
2607                 clusterZoa.push\_back(clusterZoa.at(max));
2608                 clusterZoa.push\_back(clusterZoa.at(max));
2609 
2610 
2611         \}
2612 
2613         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"size of coefficient matrix =["}<<H\_usn.size() << \textcolor{stringliteral}{"]["} << H\_usn.at(0).size()
       << \textcolor{stringliteral}{"]["} << H\_usn.at (0).at(0).size()<<\textcolor{stringliteral}{"]"});
2614 
2615 
2616         \textcolor{comment}{/*std::cout << "Delay:";}
2617 \textcolor{comment}{        for (uint8\_t i = 0; i < clusterDelay.size(); i++)}
2618 \textcolor{comment}{        \{}
2619 \textcolor{comment}{                std::cout <<clusterDelay.at(i)<<"s\(\backslash\)t";}
2620 \textcolor{comment}{        \}}
2621 \textcolor{comment}{        std::cout << "\(\backslash\)n";*/}
2622 
2623         params->m\_delay = clusterDelay;
2624         params->m\_channel = H\_usn;
2625         params->m\_angle.clear();
2626         params->m\_angle.push\_back(clusterAoa);
2627         params->m\_angle.push\_back(clusterZoa);
2628         params->m\_angle.push\_back(clusterAod);
2629         params->m\_angle.push\_back(clusterZod);
2630         \textcolor{comment}{//update the previous location.}
2631 
2632         \textcolor{keywordflow}{return} params;
2633 
2634 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 24




Here is the caller graph for this function\+:
% FIG 25




\subsection{Member Data Documentation}
\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!is\+Additional\+Mm\+Wave\+Phy@{is\+Additional\+Mm\+Wave\+Phy}}
\index{is\+Additional\+Mm\+Wave\+Phy@{is\+Additional\+Mm\+Wave\+Phy}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{is\+Additional\+Mm\+Wave\+Phy}{isAdditionalMmWavePhy}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Mm\+Wave3gpp\+Channel\+::is\+Additional\+Mm\+Wave\+Phy ={\bf false}}\hypertarget{classns3_1_1MmWave3gppChannel_a5b921c4b6e89174bf383382c1ce6523f}{}\label{classns3_1_1MmWave3gppChannel_a5b921c4b6e89174bf383382c1ce6523f}
\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!m\+\_\+3gpp\+Pathloss@{m\+\_\+3gpp\+Pathloss}}
\index{m\+\_\+3gpp\+Pathloss@{m\+\_\+3gpp\+Pathloss}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{m\+\_\+3gpp\+Pathloss}{m_3gppPathloss}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Propagation\+Loss\+Model}$>$ ns3\+::\+Mm\+Wave3gpp\+Channel\+::m\+\_\+3gpp\+Pathloss\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWave3gppChannel_add8860051acacb1819be2f7321dbd726}{}\label{classns3_1_1MmWave3gppChannel_add8860051acacb1819be2f7321dbd726}
\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!m\+\_\+blockage@{m\+\_\+blockage}}
\index{m\+\_\+blockage@{m\+\_\+blockage}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{m\+\_\+blockage}{m_blockage}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Mm\+Wave3gpp\+Channel\+::m\+\_\+blockage\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWave3gppChannel_a5f19d0ed379e7db9448f4f668e0c7927}{}\label{classns3_1_1MmWave3gppChannel_a5f19d0ed379e7db9448f4f668e0c7927}
\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!m\+\_\+blocker\+Speed@{m\+\_\+blocker\+Speed}}
\index{m\+\_\+blocker\+Speed@{m\+\_\+blocker\+Speed}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{m\+\_\+blocker\+Speed}{m_blockerSpeed}}]{\setlength{\rightskip}{0pt plus 5cm}double ns3\+::\+Mm\+Wave3gpp\+Channel\+::m\+\_\+blocker\+Speed\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWave3gppChannel_a5d7b7b759283cdf9a6781571e9eeca25}{}\label{classns3_1_1MmWave3gppChannel_a5d7b7b759283cdf9a6781571e9eeca25}
\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!m\+\_\+cell\+Scan@{m\+\_\+cell\+Scan}}
\index{m\+\_\+cell\+Scan@{m\+\_\+cell\+Scan}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{m\+\_\+cell\+Scan}{m_cellScan}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Mm\+Wave3gpp\+Channel\+::m\+\_\+cell\+Scan\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWave3gppChannel_ac973f52321b6843ce42f036620af63e8}{}\label{classns3_1_1MmWave3gppChannel_ac973f52321b6843ce42f036620af63e8}
\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!m\+\_\+channel\+Map@{m\+\_\+channel\+Map}}
\index{m\+\_\+channel\+Map@{m\+\_\+channel\+Map}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{m\+\_\+channel\+Map}{m_channelMap}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<$ {\bf key\+\_\+t}, {\bf Ptr}$<${\bf Params3gpp}$>$ $>$ ns3\+::\+Mm\+Wave3gpp\+Channel\+::m\+\_\+channel\+Map\hspace{0.3cm}{\ttfamily [mutable]}, {\ttfamily [private]}}\hypertarget{classns3_1_1MmWave3gppChannel_a31f05f0c8a438b8ce89f29813e863040}{}\label{classns3_1_1MmWave3gppChannel_a31f05f0c8a438b8ce89f29813e863040}
\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!m\+\_\+connected\+Pair@{m\+\_\+connected\+Pair}}
\index{m\+\_\+connected\+Pair@{m\+\_\+connected\+Pair}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{m\+\_\+connected\+Pair}{m_connectedPair}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<$ {\bf key\+\_\+t}, int $>$ ns3\+::\+Mm\+Wave3gpp\+Channel\+::m\+\_\+connected\+Pair\hspace{0.3cm}{\ttfamily [mutable]}, {\ttfamily [private]}}\hypertarget{classns3_1_1MmWave3gppChannel_a43ad5b64f557a59c929fa49f3600fd9f}{}\label{classns3_1_1MmWave3gppChannel_a43ad5b64f557a59c929fa49f3600fd9f}
\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!m\+\_\+exp\+Rv@{m\+\_\+exp\+Rv}}
\index{m\+\_\+exp\+Rv@{m\+\_\+exp\+Rv}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{m\+\_\+exp\+Rv}{m_expRv}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Exponential\+Random\+Variable}$>$ ns3\+::\+Mm\+Wave3gpp\+Channel\+::m\+\_\+exp\+Rv\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWave3gppChannel_a139990a80eb5ae26045b434c0eb75ae4}{}\label{classns3_1_1MmWave3gppChannel_a139990a80eb5ae26045b434c0eb75ae4}
\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!m\+\_\+force\+Initial\+Bf\+Computation@{m\+\_\+force\+Initial\+Bf\+Computation}}
\index{m\+\_\+force\+Initial\+Bf\+Computation@{m\+\_\+force\+Initial\+Bf\+Computation}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{m\+\_\+force\+Initial\+Bf\+Computation}{m_forceInitialBfComputation}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Mm\+Wave3gpp\+Channel\+::m\+\_\+force\+Initial\+Bf\+Computation\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWave3gppChannel_a2d5a32e24f0d795c5ed210f8c38f4e9b}{}\label{classns3_1_1MmWave3gppChannel_a2d5a32e24f0d795c5ed210f8c38f4e9b}
\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!m\+\_\+normal\+Rv@{m\+\_\+normal\+Rv}}
\index{m\+\_\+normal\+Rv@{m\+\_\+normal\+Rv}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{m\+\_\+normal\+Rv}{m_normalRv}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Normal\+Random\+Variable}$>$ ns3\+::\+Mm\+Wave3gpp\+Channel\+::m\+\_\+normal\+Rv\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWave3gppChannel_ac2e02ebacc72ed96518d785f2dc87c57}{}\label{classns3_1_1MmWave3gppChannel_ac2e02ebacc72ed96518d785f2dc87c57}
\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!m\+\_\+normal\+Rv\+Blockage@{m\+\_\+normal\+Rv\+Blockage}}
\index{m\+\_\+normal\+Rv\+Blockage@{m\+\_\+normal\+Rv\+Blockage}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{m\+\_\+normal\+Rv\+Blockage}{m_normalRvBlockage}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Normal\+Random\+Variable}$>$ ns3\+::\+Mm\+Wave3gpp\+Channel\+::m\+\_\+normal\+Rv\+Blockage\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWave3gppChannel_a51e89a0f3902e6e377705871c479cf36}{}\label{classns3_1_1MmWave3gppChannel_a51e89a0f3902e6e377705871c479cf36}
\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!m\+\_\+num\+Non\+Self\+Bloking@{m\+\_\+num\+Non\+Self\+Bloking}}
\index{m\+\_\+num\+Non\+Self\+Bloking@{m\+\_\+num\+Non\+Self\+Bloking}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{m\+\_\+num\+Non\+Self\+Bloking}{m_numNonSelfBloking}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Mm\+Wave3gpp\+Channel\+::m\+\_\+num\+Non\+Self\+Bloking\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWave3gppChannel_addfe5e6c9d8e2531fe165ff86461d2d3}{}\label{classns3_1_1MmWave3gppChannel_addfe5e6c9d8e2531fe165ff86461d2d3}
\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!m\+\_\+phy\+Mac\+Config@{m\+\_\+phy\+Mac\+Config}}
\index{m\+\_\+phy\+Mac\+Config@{m\+\_\+phy\+Mac\+Config}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{m\+\_\+phy\+Mac\+Config}{m_phyMacConfig}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Mm\+Wave\+Phy\+Mac\+Common}$>$ ns3\+::\+Mm\+Wave3gpp\+Channel\+::m\+\_\+phy\+Mac\+Config\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWave3gppChannel_a50988766af948ea236ce24718a6dca7d}{}\label{classns3_1_1MmWave3gppChannel_a50988766af948ea236ce24718a6dca7d}
\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!m\+\_\+portrait\+Mode@{m\+\_\+portrait\+Mode}}
\index{m\+\_\+portrait\+Mode@{m\+\_\+portrait\+Mode}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{m\+\_\+portrait\+Mode}{m_portraitMode}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Mm\+Wave3gpp\+Channel\+::m\+\_\+portrait\+Mode\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWave3gppChannel_a013ed012d87114993312ccfd172fe377}{}\label{classns3_1_1MmWave3gppChannel_a013ed012d87114993312ccfd172fe377}
\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!m\+\_\+scenario@{m\+\_\+scenario}}
\index{m\+\_\+scenario@{m\+\_\+scenario}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{m\+\_\+scenario}{m_scenario}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string ns3\+::\+Mm\+Wave3gpp\+Channel\+::m\+\_\+scenario\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWave3gppChannel_ae1f263fbc87682905d563221343e4447}{}\label{classns3_1_1MmWave3gppChannel_ae1f263fbc87682905d563221343e4447}
\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!m\+\_\+table3gpp@{m\+\_\+table3gpp}}
\index{m\+\_\+table3gpp@{m\+\_\+table3gpp}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{m\+\_\+table3gpp}{m_table3gpp}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Params\+Table}$>$ ns3\+::\+Mm\+Wave3gpp\+Channel\+::m\+\_\+table3gpp\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWave3gppChannel_a463c1cc6d34730bbdebdd593f374914b}{}\label{classns3_1_1MmWave3gppChannel_a463c1cc6d34730bbdebdd593f374914b}
\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!m\+\_\+uniform\+Rv@{m\+\_\+uniform\+Rv}}
\index{m\+\_\+uniform\+Rv@{m\+\_\+uniform\+Rv}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{m\+\_\+uniform\+Rv}{m_uniformRv}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Uniform\+Random\+Variable}$>$ ns3\+::\+Mm\+Wave3gpp\+Channel\+::m\+\_\+uniform\+Rv\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWave3gppChannel_ac6493e4d80b717378e74a63d418f8c6f}{}\label{classns3_1_1MmWave3gppChannel_ac6493e4d80b717378e74a63d418f8c6f}
\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!m\+\_\+uniform\+Rv\+Blockage@{m\+\_\+uniform\+Rv\+Blockage}}
\index{m\+\_\+uniform\+Rv\+Blockage@{m\+\_\+uniform\+Rv\+Blockage}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{m\+\_\+uniform\+Rv\+Blockage}{m_uniformRvBlockage}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Uniform\+Random\+Variable}$>$ ns3\+::\+Mm\+Wave3gpp\+Channel\+::m\+\_\+uniform\+Rv\+Blockage\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWave3gppChannel_a5afa026ce58c8b70c81c846bb7b49b4f}{}\label{classns3_1_1MmWave3gppChannel_a5afa026ce58c8b70c81c846bb7b49b4f}
\index{ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}!m\+\_\+update\+Period@{m\+\_\+update\+Period}}
\index{m\+\_\+update\+Period@{m\+\_\+update\+Period}!ns3\+::\+Mm\+Wave3gpp\+Channel@{ns3\+::\+Mm\+Wave3gpp\+Channel}}
\subsubsection[{\texorpdfstring{m\+\_\+update\+Period}{m_updatePeriod}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Mm\+Wave3gpp\+Channel\+::m\+\_\+update\+Period\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWave3gppChannel_a2844f8c7e7373cb777384eaf0e8a7b11}{}\label{classns3_1_1MmWave3gppChannel_a2844f8c7e7373cb777384eaf0e8a7b11}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
mmwave/model/\hyperlink{mmwave-3gpp-channel_8h}{mmwave-\/3gpp-\/channel.\+h}\item 
mmwave/model/\hyperlink{mmwave-3gpp-channel_8cc}{mmwave-\/3gpp-\/channel.\+cc}\end{DoxyCompactItemize}
