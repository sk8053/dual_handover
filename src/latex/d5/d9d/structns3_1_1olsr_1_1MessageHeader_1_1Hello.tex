\hypertarget{structns3_1_1olsr_1_1MessageHeader_1_1Hello}{}\section{ns3\+:\+:olsr\+:\+:Message\+Header\+:\+:Hello Struct Reference}
\label{structns3_1_1olsr_1_1MessageHeader_1_1Hello}\index{ns3\+::olsr\+::\+Message\+Header\+::\+Hello@{ns3\+::olsr\+::\+Message\+Header\+::\+Hello}}


{\ttfamily \#include $<$olsr-\/header.\+h$>$}



Collaboration diagram for ns3\+:\+:olsr\+:\+:Message\+Header\+:\+:Hello\+:
% FIG 0
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Hello_1_1LinkMessage}{Link\+Message}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Hello_a393fd82122e9554019d4059d5bbf705b}{Set\+H\+Time} (\hyperlink{classns3_1_1Time}{Time} time)
\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Hello_aa5bf473b19bc8da0ebd6543a7368d814}{Get\+H\+Time} () const 
\item 
void \hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Hello_a23b35236d7d96cbcdffc3095e797da97}{Print} (std\+::ostream \&os) const 
\item 
uint32\+\_\+t \hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Hello_ad2862d60d2ef6372d01d0e1786d57827}{Get\+Serialized\+Size} (void) const 
\item 
void \hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Hello_a842601093dd98a192375bf4cca885670}{Serialize} (\hyperlink{classns3_1_1Buffer_1_1Iterator}{Buffer\+::\+Iterator} start) const 
\item 
uint32\+\_\+t \hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Hello_a500cb55e5f8de7afc7bece2a0237e090}{Deserialize} (\hyperlink{classns3_1_1Buffer_1_1Iterator}{Buffer\+::\+Iterator} start, uint32\+\_\+t message\+Size)
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
uint8\+\_\+t \hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Hello_ab3ca4a7d3f354ac3c022cf9e7f799ae2}{h\+Time}
\begin{DoxyCompactList}\small\item\em H\+E\+L\+LO emission interval (coded) \end{DoxyCompactList}\item 
uint8\+\_\+t \hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Hello_a6458c9b671b767990245f81d1c64c56f}{willingness}
\begin{DoxyCompactList}\small\item\em The willingness of a node to carry and forward traffic for other nodes. \end{DoxyCompactList}\item 
std\+::vector$<$ \hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Hello_1_1LinkMessage}{Link\+Message} $>$ \hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Hello_aa6eb8d2a413314c764f5eaf669655f59}{link\+Messages}
\begin{DoxyCompactList}\small\item\em Link messages container. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
H\+E\+L\+LO Message Format

\begin{DoxyVerb}  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1

 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |          Reserved             |     Htime     |  Willingness  |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   Link Code   |   Reserved    |       Link Message Size       |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                  Neighbor Interface Address                   |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                  Neighbor Interface Address                   |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 :                             .  .  .                           :
 :                                                               :
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   Link Code   |   Reserved    |       Link Message Size       |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                  Neighbor Interface Address                   |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                  Neighbor Interface Address                   |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 :                                                               :
   (etc.)
\end{DoxyVerb}
 

\subsection{Member Function Documentation}
\index{ns3\+::olsr\+::\+Message\+Header\+::\+Hello@{ns3\+::olsr\+::\+Message\+Header\+::\+Hello}!Deserialize@{Deserialize}}
\index{Deserialize@{Deserialize}!ns3\+::olsr\+::\+Message\+Header\+::\+Hello@{ns3\+::olsr\+::\+Message\+Header\+::\+Hello}}
\subsubsection[{\texorpdfstring{Deserialize(\+Buffer\+::\+Iterator start, uint32\+\_\+t message\+Size)}{Deserialize(Buffer::Iterator start, uint32_t messageSize)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::olsr\+::\+Message\+Header\+::\+Hello\+::\+Deserialize (
\begin{DoxyParamCaption}
\item[{{\bf Buffer\+::\+Iterator}}]{start, }
\item[{uint32\+\_\+t}]{message\+Size}
\end{DoxyParamCaption}
)}\hypertarget{structns3_1_1olsr_1_1MessageHeader_1_1Hello_a500cb55e5f8de7afc7bece2a0237e090}{}\label{structns3_1_1olsr_1_1MessageHeader_1_1Hello_a500cb55e5f8de7afc7bece2a0237e090}
This method is used by \hyperlink{classns3_1_1Packet_a0961eccf975d75f902d40956c93ba63e}{Packet\+::\+Remove\+Header} to re-\/create a header from the byte buffer of a packet.


\begin{DoxyParams}{Parameters}
{\em start} & an iterator which points to where the header should read from. \\
\hline
{\em message\+Size} & the message size. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of bytes read. 
\end{DoxyReturn}

\begin{DoxyCode}
387 \{
388   Buffer::Iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{namespacevisualizer_1_1core_a2a35e5d8a34af358b508dac8635754e0}{start};
389 
390   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (messageSize >= 4);
391 
392   this->\hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Hello_aa6eb8d2a413314c764f5eaf669655f59}{linkMessages}.clear ();
393 
394   uint16\_t helloSizeLeft = messageSize;
395 
396   i.ReadNtohU16 (); \textcolor{comment}{// Reserved}
397   this->\hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Hello_ab3ca4a7d3f354ac3c022cf9e7f799ae2}{hTime} = i.ReadU8 ();
398   this->\hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Hello_a6458c9b671b767990245f81d1c64c56f}{willingness} = i.ReadU8 ();
399 
400   helloSizeLeft -= 4;
401 
402   \textcolor{keywordflow}{while} (helloSizeLeft)
403     \{
404       LinkMessage lm;
405       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (helloSizeLeft >= 4);
406       lm.linkCode = i.ReadU8 ();
407       i.ReadU8 (); \textcolor{comment}{// Reserved}
408       uint16\_t lmSize = i.ReadNtohU16 ();
409       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} ((lmSize - 4) % \hyperlink{olsr-header_8cc_a78eabd4fb6c036f7de9b598066b3c39e}{IPV4\_ADDRESS\_SIZE} == 0);
410       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} \hyperlink{namespacesample-rng-plot_aeb5ee5c431e338ef39b7ac5431242e1d}{n} = (lmSize - 4) / \hyperlink{olsr-header_8cc_a78eabd4fb6c036f7de9b598066b3c39e}{IPV4\_ADDRESS\_SIZE}; \hyperlink{namespacesample-rng-plot_aeb5ee5c431e338ef39b7ac5431242e1d}{n}; --\hyperlink{namespacesample-rng-plot_aeb5ee5c431e338ef39b7ac5431242e1d}{n})
411         \{
412           lm.neighborInterfaceAddresses.push\_back (Ipv4Address (i.ReadNtohU32 ()));
413         \}
414       helloSizeLeft -= lmSize;
415       this->\hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Hello_aa6eb8d2a413314c764f5eaf669655f59}{linkMessages}.push\_back (lm);
416     \}
417 
418   \textcolor{keywordflow}{return} messageSize;
419 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 1


\index{ns3\+::olsr\+::\+Message\+Header\+::\+Hello@{ns3\+::olsr\+::\+Message\+Header\+::\+Hello}!Get\+H\+Time@{Get\+H\+Time}}
\index{Get\+H\+Time@{Get\+H\+Time}!ns3\+::olsr\+::\+Message\+Header\+::\+Hello@{ns3\+::olsr\+::\+Message\+Header\+::\+Hello}}
\subsubsection[{\texorpdfstring{Get\+H\+Time() const }{GetHTime() const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::olsr\+::\+Message\+Header\+::\+Hello\+::\+Get\+H\+Time (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{structns3_1_1olsr_1_1MessageHeader_1_1Hello_aa5bf473b19bc8da0ebd6543a7368d814}{}\label{structns3_1_1olsr_1_1MessageHeader_1_1Hello_aa5bf473b19bc8da0ebd6543a7368d814}
Get the H\+E\+L\+LO emission interval. \begin{DoxyReturn}{Returns}
The H\+E\+L\+LO emission interval. 
\end{DoxyReturn}

\begin{DoxyCode}
403     \{
404       \textcolor{keywordflow}{return} \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (\hyperlink{namespacens3_1_1olsr_a6d7d7cac3867eec9f70686ab69f1ded6}{EmfToSeconds} (this->\hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Hello_ab3ca4a7d3f354ac3c022cf9e7f799ae2}{hTime}));
405     \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2




Here is the caller graph for this function\+:
% FIG 3


\index{ns3\+::olsr\+::\+Message\+Header\+::\+Hello@{ns3\+::olsr\+::\+Message\+Header\+::\+Hello}!Get\+Serialized\+Size@{Get\+Serialized\+Size}}
\index{Get\+Serialized\+Size@{Get\+Serialized\+Size}!ns3\+::olsr\+::\+Message\+Header\+::\+Hello@{ns3\+::olsr\+::\+Message\+Header\+::\+Hello}}
\subsubsection[{\texorpdfstring{Get\+Serialized\+Size(void) const }{GetSerializedSize(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::olsr\+::\+Message\+Header\+::\+Hello\+::\+Get\+Serialized\+Size (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{structns3_1_1olsr_1_1MessageHeader_1_1Hello_ad2862d60d2ef6372d01d0e1786d57827}{}\label{structns3_1_1olsr_1_1MessageHeader_1_1Hello_ad2862d60d2ef6372d01d0e1786d57827}
Returns the expected size of the header. \begin{DoxyReturn}{Returns}
the expected size of the header. 
\end{DoxyReturn}

\begin{DoxyCode}
336 \{
337   uint32\_t size = 4;
338   \textcolor{keywordflow}{for} (std::vector<LinkMessage>::const\_iterator iter = this->\hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Hello_aa6eb8d2a413314c764f5eaf669655f59}{linkMessages}.begin ();
339        iter != this->\hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Hello_aa6eb8d2a413314c764f5eaf669655f59}{linkMessages}.end (); iter++)
340     \{
341       \textcolor{keyword}{const} LinkMessage &lm = *iter;
342       size += 4;
343       size += \hyperlink{olsr-header_8cc_a78eabd4fb6c036f7de9b598066b3c39e}{IPV4\_ADDRESS\_SIZE} * lm.neighborInterfaceAddresses.size ();
344     \}
345   \textcolor{keywordflow}{return} size;
346 \}
\end{DoxyCode}
\index{ns3\+::olsr\+::\+Message\+Header\+::\+Hello@{ns3\+::olsr\+::\+Message\+Header\+::\+Hello}!Print@{Print}}
\index{Print@{Print}!ns3\+::olsr\+::\+Message\+Header\+::\+Hello@{ns3\+::olsr\+::\+Message\+Header\+::\+Hello}}
\subsubsection[{\texorpdfstring{Print(std\+::ostream \&os) const }{Print(std::ostream &os) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Message\+Header\+::\+Hello\+::\+Print (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os}
\end{DoxyParamCaption}
) const}\hypertarget{structns3_1_1olsr_1_1MessageHeader_1_1Hello_a23b35236d7d96cbcdffc3095e797da97}{}\label{structns3_1_1olsr_1_1MessageHeader_1_1Hello_a23b35236d7d96cbcdffc3095e797da97}
This method is used to print the content of a M\+ID message. 
\begin{DoxyParams}{Parameters}
{\em os} & output stream \\
\hline
\end{DoxyParams}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000153}{Todo}]\end{DoxyRefDesc}

\begin{DoxyCode}
350 \{
352 \}
\end{DoxyCode}
\index{ns3\+::olsr\+::\+Message\+Header\+::\+Hello@{ns3\+::olsr\+::\+Message\+Header\+::\+Hello}!Serialize@{Serialize}}
\index{Serialize@{Serialize}!ns3\+::olsr\+::\+Message\+Header\+::\+Hello@{ns3\+::olsr\+::\+Message\+Header\+::\+Hello}}
\subsubsection[{\texorpdfstring{Serialize(\+Buffer\+::\+Iterator start) const }{Serialize(Buffer::Iterator start) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Message\+Header\+::\+Hello\+::\+Serialize (
\begin{DoxyParamCaption}
\item[{{\bf Buffer\+::\+Iterator}}]{start}
\end{DoxyParamCaption}
) const}\hypertarget{structns3_1_1olsr_1_1MessageHeader_1_1Hello_a842601093dd98a192375bf4cca885670}{}\label{structns3_1_1olsr_1_1MessageHeader_1_1Hello_a842601093dd98a192375bf4cca885670}
This method is used by \hyperlink{classns3_1_1Packet_a465108c595a0bc592095cbcab1832ed8}{Packet\+::\+Add\+Header} to store a header into the byte buffer of a packet.


\begin{DoxyParams}{Parameters}
{\em start} & an iterator which points to where the header should be written. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
356 \{
357   Buffer::Iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{namespacevisualizer_1_1core_a2a35e5d8a34af358b508dac8635754e0}{start};
358 
359   i.WriteU16 (0); \textcolor{comment}{// Reserved}
360   i.WriteU8 (this->\hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Hello_ab3ca4a7d3f354ac3c022cf9e7f799ae2}{hTime});
361   i.WriteU8 (this->\hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Hello_a6458c9b671b767990245f81d1c64c56f}{willingness});
362 
363   \textcolor{keywordflow}{for} (std::vector<LinkMessage>::const\_iterator iter = this->\hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Hello_aa6eb8d2a413314c764f5eaf669655f59}{linkMessages}.begin ();
364        iter != this->\hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Hello_aa6eb8d2a413314c764f5eaf669655f59}{linkMessages}.end (); iter++)
365     \{
366       \textcolor{keyword}{const} LinkMessage &lm = *iter;
367 
368       i.WriteU8 (lm.linkCode);
369       i.WriteU8 (0); \textcolor{comment}{// Reserved}
370 
371       \textcolor{comment}{// The size of the link message, counted in bytes and measured}
372       \textcolor{comment}{// from the beginning of the "Link Code" field and until the}
373       \textcolor{comment}{// next "Link Code" field (or - if there are no more link types}
374       \textcolor{comment}{// - the end of the message).}
375       i.WriteHtonU16 (4 + lm.neighborInterfaceAddresses.size () * 
      \hyperlink{olsr-header_8cc_a78eabd4fb6c036f7de9b598066b3c39e}{IPV4\_ADDRESS\_SIZE});
376 
377       \textcolor{keywordflow}{for} (std::vector<Ipv4Address>::const\_iterator neigh\_iter = lm.neighborInterfaceAddresses.begin ();
378            neigh\_iter != lm.neighborInterfaceAddresses.end (); neigh\_iter++)
379         \{
380           i.WriteHtonU32 (neigh\_iter->Get ());
381         \}
382     \}
383 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4


\index{ns3\+::olsr\+::\+Message\+Header\+::\+Hello@{ns3\+::olsr\+::\+Message\+Header\+::\+Hello}!Set\+H\+Time@{Set\+H\+Time}}
\index{Set\+H\+Time@{Set\+H\+Time}!ns3\+::olsr\+::\+Message\+Header\+::\+Hello@{ns3\+::olsr\+::\+Message\+Header\+::\+Hello}}
\subsubsection[{\texorpdfstring{Set\+H\+Time(\+Time time)}{SetHTime(Time time)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::olsr\+::\+Message\+Header\+::\+Hello\+::\+Set\+H\+Time (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{time}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{structns3_1_1olsr_1_1MessageHeader_1_1Hello_a393fd82122e9554019d4059d5bbf705b}{}\label{structns3_1_1olsr_1_1MessageHeader_1_1Hello_a393fd82122e9554019d4059d5bbf705b}
Set the H\+E\+L\+LO emission interval. 
\begin{DoxyParams}{Parameters}
{\em time} & The H\+E\+L\+LO emission interval. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
394     \{
395       this->\hyperlink{structns3_1_1olsr_1_1MessageHeader_1_1Hello_ab3ca4a7d3f354ac3c022cf9e7f799ae2}{hTime} = \hyperlink{namespacens3_1_1olsr_aa544b806b38a4a63280ce21a9b706628}{SecondsToEmf} (time.GetSeconds ());
396     \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5




Here is the caller graph for this function\+:
% FIG 6




\subsection{Member Data Documentation}
\index{ns3\+::olsr\+::\+Message\+Header\+::\+Hello@{ns3\+::olsr\+::\+Message\+Header\+::\+Hello}!h\+Time@{h\+Time}}
\index{h\+Time@{h\+Time}!ns3\+::olsr\+::\+Message\+Header\+::\+Hello@{ns3\+::olsr\+::\+Message\+Header\+::\+Hello}}
\subsubsection[{\texorpdfstring{h\+Time}{hTime}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::olsr\+::\+Message\+Header\+::\+Hello\+::h\+Time}\hypertarget{structns3_1_1olsr_1_1MessageHeader_1_1Hello_ab3ca4a7d3f354ac3c022cf9e7f799ae2}{}\label{structns3_1_1olsr_1_1MessageHeader_1_1Hello_ab3ca4a7d3f354ac3c022cf9e7f799ae2}


H\+E\+L\+LO emission interval (coded) 

\index{ns3\+::olsr\+::\+Message\+Header\+::\+Hello@{ns3\+::olsr\+::\+Message\+Header\+::\+Hello}!link\+Messages@{link\+Messages}}
\index{link\+Messages@{link\+Messages}!ns3\+::olsr\+::\+Message\+Header\+::\+Hello@{ns3\+::olsr\+::\+Message\+Header\+::\+Hello}}
\subsubsection[{\texorpdfstring{link\+Messages}{linkMessages}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<${\bf Link\+Message}$>$ ns3\+::olsr\+::\+Message\+Header\+::\+Hello\+::link\+Messages}\hypertarget{structns3_1_1olsr_1_1MessageHeader_1_1Hello_aa6eb8d2a413314c764f5eaf669655f59}{}\label{structns3_1_1olsr_1_1MessageHeader_1_1Hello_aa6eb8d2a413314c764f5eaf669655f59}


Link messages container. 

\index{ns3\+::olsr\+::\+Message\+Header\+::\+Hello@{ns3\+::olsr\+::\+Message\+Header\+::\+Hello}!willingness@{willingness}}
\index{willingness@{willingness}!ns3\+::olsr\+::\+Message\+Header\+::\+Hello@{ns3\+::olsr\+::\+Message\+Header\+::\+Hello}}
\subsubsection[{\texorpdfstring{willingness}{willingness}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::olsr\+::\+Message\+Header\+::\+Hello\+::willingness}\hypertarget{structns3_1_1olsr_1_1MessageHeader_1_1Hello_a6458c9b671b767990245f81d1c64c56f}{}\label{structns3_1_1olsr_1_1MessageHeader_1_1Hello_a6458c9b671b767990245f81d1c64c56f}


The willingness of a node to carry and forward traffic for other nodes. 



The documentation for this struct was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
olsr/model/\hyperlink{olsr-header_8h}{olsr-\/header.\+h}\item 
olsr/model/\hyperlink{olsr-header_8cc}{olsr-\/header.\+cc}\end{DoxyCompactItemize}
