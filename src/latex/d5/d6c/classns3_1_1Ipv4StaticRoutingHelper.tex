\hypertarget{classns3_1_1Ipv4StaticRoutingHelper}{}\section{ns3\+:\+:Ipv4\+Static\+Routing\+Helper Class Reference}
\label{classns3_1_1Ipv4StaticRoutingHelper}\index{ns3\+::\+Ipv4\+Static\+Routing\+Helper@{ns3\+::\+Ipv4\+Static\+Routing\+Helper}}


Helper class that adds \hyperlink{classns3_1_1Ipv4StaticRouting}{ns3\+::\+Ipv4\+Static\+Routing} objects.  




{\ttfamily \#include $<$ipv4-\/static-\/routing-\/helper.\+h$>$}



Inheritance diagram for ns3\+:\+:Ipv4\+Static\+Routing\+Helper\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Ipv4\+Static\+Routing\+Helper\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ipv4StaticRoutingHelper_a8dac1b77f202bd0a3de3b442dfdf34dd}{Ipv4\+Static\+Routing\+Helper} ()
\item 
\hyperlink{classns3_1_1Ipv4StaticRoutingHelper_a5dab2c4bc67a155ebaf0042496209ab1}{Ipv4\+Static\+Routing\+Helper} (const \hyperlink{classns3_1_1Ipv4StaticRoutingHelper}{Ipv4\+Static\+Routing\+Helper} \&)
\begin{DoxyCompactList}\small\item\em Construct an \hyperlink{classns3_1_1Ipv4StaticRoutingHelper}{Ipv4\+Static\+Routing\+Helper} from another previously initialized instance (Copy Constructor). \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4StaticRoutingHelper}{Ipv4\+Static\+Routing\+Helper} $\ast$ \hyperlink{classns3_1_1Ipv4StaticRoutingHelper_a0cf5ca3ae4ffbfab2ed392e47327ee43}{Copy} (void) const 
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} $>$ \hyperlink{classns3_1_1Ipv4StaticRoutingHelper_afb0392b022183275e7949eb9235334e9}{Create} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node) const 
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4StaticRouting}{Ipv4\+Static\+Routing} $>$ \hyperlink{classns3_1_1Ipv4StaticRoutingHelper_a731206e50d305695dac7fb2ef963a4bb}{Get\+Static\+Routing} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$ ipv4) const 
\item 
void \hyperlink{classns3_1_1Ipv4StaticRoutingHelper_aa8d55f28361e24aefb961fe2eddc2192}{Add\+Multicast\+Route} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_abdb05bc5a064cf642a06c83b3392f148}{n}, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} source, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} group, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ input, \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} output)
\begin{DoxyCompactList}\small\item\em Add a multicast route to a node and net device using explicit \hyperlink{classns3_1_1Ptr}{Ptr$<$\+Node$>$} and Ptr$<$\+Net\+Device$>$ \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4StaticRoutingHelper_a52046284c4a7d33f84a81ad33dfd66d4}{Add\+Multicast\+Route} (std\+::string \hyperlink{lte__link__budget__x2__handover__measures_8m_abdb05bc5a064cf642a06c83b3392f148}{n}, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} source, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} group, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ input, \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} output)
\begin{DoxyCompactList}\small\item\em Add a multicast route to a node and device using a name string previously associated to the node using the \hyperlink{classns3_1_1Object}{Object} Name Service and a Ptr$<$\+Net\+Device$>$ \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4StaticRoutingHelper_a8f1c020b21aedf9fd8effcef3940b0f0}{Add\+Multicast\+Route} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_abdb05bc5a064cf642a06c83b3392f148}{n}, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} source, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} group, std\+::string input\+Name, \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} output)
\begin{DoxyCompactList}\small\item\em Add a multicast route to a node and device using a \hyperlink{classns3_1_1Ptr}{Ptr$<$\+Node$>$} and a name string previously associated to the device using the \hyperlink{classns3_1_1Object}{Object} Name Service. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4StaticRoutingHelper_ad4e1b19d7df693754de7f808dbce521e}{Add\+Multicast\+Route} (std\+::string n\+Name, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} source, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} group, std\+::string input\+Name, \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} output)
\begin{DoxyCompactList}\small\item\em Add a multicast route to a node and device using name strings previously associated to both the node and device using the \hyperlink{classns3_1_1Object}{Object} Name Service. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4StaticRoutingHelper_ae69a07ded3139dfd4e21bb7c10eba416}{Set\+Default\+Multicast\+Route} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_abdb05bc5a064cf642a06c83b3392f148}{n}, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ nd)
\begin{DoxyCompactList}\small\item\em Add a default route to the static routing protocol to forward packets out a particular interface. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4StaticRoutingHelper_ab755c8e22952804d93c47b914819e1db}{Set\+Default\+Multicast\+Route} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_abdb05bc5a064cf642a06c83b3392f148}{n}, std\+::string nd\+Name)
\begin{DoxyCompactList}\small\item\em Add a default route to the static routing protocol to forward packets out a particular interface. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4StaticRoutingHelper_adcdf30e8246096f94535fb2472bf9701}{Set\+Default\+Multicast\+Route} (std\+::string n\+Name, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ nd)
\begin{DoxyCompactList}\small\item\em Add a default route to the static routing protocol to forward packets out a particular interface. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4StaticRoutingHelper_ac9e71b7b9d1f958df552166cbc210768}{Set\+Default\+Multicast\+Route} (std\+::string n\+Name, std\+::string nd\+Name)
\begin{DoxyCompactList}\small\item\em Add a default route to the static routing protocol to forward packets out a particular interface. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ipv4StaticRoutingHelper}{Ipv4\+Static\+Routing\+Helper} \& \hyperlink{classns3_1_1Ipv4StaticRoutingHelper_a732a01272d46668aa2cdffa3d05ac3ac}{operator=} (const \hyperlink{classns3_1_1Ipv4StaticRoutingHelper}{Ipv4\+Static\+Routing\+Helper} \&)
\begin{DoxyCompactList}\small\item\em Assignment operator declared private and not implemented to disallow assignment and prevent the compiler from happily inserting its own. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Helper class that adds \hyperlink{classns3_1_1Ipv4StaticRouting}{ns3\+::\+Ipv4\+Static\+Routing} objects. 

This class is expected to be used in conjunction with \hyperlink{classns3_1_1InternetStackHelper_a3e382c02df022dec79952a7eca8cd5ba}{ns3\+::\+Internet\+Stack\+Helper\+::\+Set\+Routing\+Helper} 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Ipv4\+Static\+Routing\+Helper@{ns3\+::\+Ipv4\+Static\+Routing\+Helper}!Ipv4\+Static\+Routing\+Helper@{Ipv4\+Static\+Routing\+Helper}}
\index{Ipv4\+Static\+Routing\+Helper@{Ipv4\+Static\+Routing\+Helper}!ns3\+::\+Ipv4\+Static\+Routing\+Helper@{ns3\+::\+Ipv4\+Static\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Ipv4\+Static\+Routing\+Helper()}{Ipv4StaticRoutingHelper()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv4\+Static\+Routing\+Helper\+::\+Ipv4\+Static\+Routing\+Helper (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4StaticRoutingHelper_a8dac1b77f202bd0a3de3b442dfdf34dd}{}\label{classns3_1_1Ipv4StaticRoutingHelper_a8dac1b77f202bd0a3de3b442dfdf34dd}

\begin{DoxyCode}
37 \{
38 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 2


\index{ns3\+::\+Ipv4\+Static\+Routing\+Helper@{ns3\+::\+Ipv4\+Static\+Routing\+Helper}!Ipv4\+Static\+Routing\+Helper@{Ipv4\+Static\+Routing\+Helper}}
\index{Ipv4\+Static\+Routing\+Helper@{Ipv4\+Static\+Routing\+Helper}!ns3\+::\+Ipv4\+Static\+Routing\+Helper@{ns3\+::\+Ipv4\+Static\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Ipv4\+Static\+Routing\+Helper(const Ipv4\+Static\+Routing\+Helper \&)}{Ipv4StaticRoutingHelper(const Ipv4StaticRoutingHelper &)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv4\+Static\+Routing\+Helper\+::\+Ipv4\+Static\+Routing\+Helper (
\begin{DoxyParamCaption}
\item[{const {\bf Ipv4\+Static\+Routing\+Helper} \&}]{o}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4StaticRoutingHelper_a5dab2c4bc67a155ebaf0042496209ab1}{}\label{classns3_1_1Ipv4StaticRoutingHelper_a5dab2c4bc67a155ebaf0042496209ab1}


Construct an \hyperlink{classns3_1_1Ipv4StaticRoutingHelper}{Ipv4\+Static\+Routing\+Helper} from another previously initialized instance (Copy Constructor). 


\begin{DoxyCode}
41 \{
42 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Ipv4\+Static\+Routing\+Helper@{ns3\+::\+Ipv4\+Static\+Routing\+Helper}!Add\+Multicast\+Route@{Add\+Multicast\+Route}}
\index{Add\+Multicast\+Route@{Add\+Multicast\+Route}!ns3\+::\+Ipv4\+Static\+Routing\+Helper@{ns3\+::\+Ipv4\+Static\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Add\+Multicast\+Route(\+Ptr$<$ Node $>$ n, Ipv4\+Address source, Ipv4\+Address group, Ptr$<$ Net\+Device $>$ input, Net\+Device\+Container output)}{AddMulticastRoute(Ptr< Node > n, Ipv4Address source, Ipv4Address group, Ptr< NetDevice > input, NetDeviceContainer output)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Static\+Routing\+Helper\+::\+Add\+Multicast\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{n, }
\item[{{\bf Ipv4\+Address}}]{source, }
\item[{{\bf Ipv4\+Address}}]{group, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{input, }
\item[{{\bf Net\+Device\+Container}}]{output}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4StaticRoutingHelper_aa8d55f28361e24aefb961fe2eddc2192}{}\label{classns3_1_1Ipv4StaticRoutingHelper_aa8d55f28361e24aefb961fe2eddc2192}


Add a multicast route to a node and net device using explicit \hyperlink{classns3_1_1Ptr}{Ptr$<$\+Node$>$} and Ptr$<$\+Net\+Device$>$ 


\begin{DoxyParams}{Parameters}
{\em n} & The node. \\
\hline
{\em source} & Source address. \\
\hline
{\em group} & Multicast group. \\
\hline
{\em input} & Input \hyperlink{classns3_1_1NetDevice}{Net\+Device}. \\
\hline
{\em output} & Output Net\+Devices. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
94 \{
95   Ptr<Ipv4> ipv4 = n->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv4> ();
96 
97   \textcolor{comment}{// We need to convert the NetDeviceContainer to an array of interface }
98   \textcolor{comment}{// numbers}
99   std::vector<uint32\_t> outputInterfaces;
100   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1NetDeviceContainer_a45709bb572f975569ed985fa89b132f8}{NetDeviceContainer::Iterator} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = output.Begin (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != output.End (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
101     \{
102       Ptr<NetDevice> nd = *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
103       int32\_t \textcolor{keyword}{interface }= ipv4->GetInterfaceForDevice (nd);
104       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (interface >= 0,
105                      \textcolor{stringliteral}{"Ipv4StaticRoutingHelper::AddMulticastRoute(): "}
106                      \textcolor{stringliteral}{"Expected an interface associated with the device nd"});
107       outputInterfaces.push\_back (interface);
108     \}
109 
110   int32\_t inputInterface = ipv4->GetInterfaceForDevice (input);
111   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (inputInterface >= 0,
112                  \textcolor{stringliteral}{"Ipv4StaticRoutingHelper::AddMulticastRoute(): "}
113                  \textcolor{stringliteral}{"Expected an interface associated with the device input"});
114   \hyperlink{classns3_1_1Ipv4StaticRoutingHelper_a8dac1b77f202bd0a3de3b442dfdf34dd}{Ipv4StaticRoutingHelper} helper;
115   Ptr<Ipv4StaticRouting> ipv4StaticRouting = helper.GetStaticRouting (ipv4);
116   \textcolor{keywordflow}{if} (!ipv4StaticRouting)
117     \{
118       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (ipv4StaticRouting,
119                      \textcolor{stringliteral}{"Ipv4StaticRoutingHelper::SetDefaultMulticastRoute(): "}
120                      \textcolor{stringliteral}{"Expected an Ipv4StaticRouting associated with this node"});
121     \}
122   ipv4StaticRouting->AddMulticastRoute (source, \hyperlink{namespacevisualizer_1_1higcontainer_aa6ad2b76790275bfce7783429beaa23f}{group}, inputInterface, outputInterfaces);
123 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3




Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::\+Ipv4\+Static\+Routing\+Helper@{ns3\+::\+Ipv4\+Static\+Routing\+Helper}!Add\+Multicast\+Route@{Add\+Multicast\+Route}}
\index{Add\+Multicast\+Route@{Add\+Multicast\+Route}!ns3\+::\+Ipv4\+Static\+Routing\+Helper@{ns3\+::\+Ipv4\+Static\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Add\+Multicast\+Route(std\+::string n, Ipv4\+Address source, Ipv4\+Address group, Ptr$<$ Net\+Device $>$ input, Net\+Device\+Container output)}{AddMulticastRoute(std::string n, Ipv4Address source, Ipv4Address group, Ptr< NetDevice > input, NetDeviceContainer output)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Static\+Routing\+Helper\+::\+Add\+Multicast\+Route (
\begin{DoxyParamCaption}
\item[{std\+::string}]{n, }
\item[{{\bf Ipv4\+Address}}]{source, }
\item[{{\bf Ipv4\+Address}}]{group, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{input, }
\item[{{\bf Net\+Device\+Container}}]{output}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4StaticRoutingHelper_a52046284c4a7d33f84a81ad33dfd66d4}{}\label{classns3_1_1Ipv4StaticRoutingHelper_a52046284c4a7d33f84a81ad33dfd66d4}


Add a multicast route to a node and device using a name string previously associated to the node using the \hyperlink{classns3_1_1Object}{Object} Name Service and a Ptr$<$\+Net\+Device$>$ 


\begin{DoxyParams}{Parameters}
{\em n} & The node. \\
\hline
{\em source} & Source address. \\
\hline
{\em group} & Multicast group. \\
\hline
{\em input} & Input \hyperlink{classns3_1_1NetDevice}{Net\+Device}. \\
\hline
{\em output} & Output Net\+Devices. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
144 \{
145   Ptr<Node> \hyperlink{namespacesample-rng-plot_aeb5ee5c431e338ef39b7ac5431242e1d}{n} = Names::Find<Node> (nName);
146   \hyperlink{classns3_1_1Ipv4StaticRoutingHelper_aa8d55f28361e24aefb961fe2eddc2192}{AddMulticastRoute} (n, source, \hyperlink{namespacevisualizer_1_1higcontainer_aa6ad2b76790275bfce7783429beaa23f}{group}, input, output);
147 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5


\index{ns3\+::\+Ipv4\+Static\+Routing\+Helper@{ns3\+::\+Ipv4\+Static\+Routing\+Helper}!Add\+Multicast\+Route@{Add\+Multicast\+Route}}
\index{Add\+Multicast\+Route@{Add\+Multicast\+Route}!ns3\+::\+Ipv4\+Static\+Routing\+Helper@{ns3\+::\+Ipv4\+Static\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Add\+Multicast\+Route(\+Ptr$<$ Node $>$ n, Ipv4\+Address source, Ipv4\+Address group, std\+::string input\+Name, Net\+Device\+Container output)}{AddMulticastRoute(Ptr< Node > n, Ipv4Address source, Ipv4Address group, std::string inputName, NetDeviceContainer output)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Static\+Routing\+Helper\+::\+Add\+Multicast\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{n, }
\item[{{\bf Ipv4\+Address}}]{source, }
\item[{{\bf Ipv4\+Address}}]{group, }
\item[{std\+::string}]{input\+Name, }
\item[{{\bf Net\+Device\+Container}}]{output}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4StaticRoutingHelper_a8f1c020b21aedf9fd8effcef3940b0f0}{}\label{classns3_1_1Ipv4StaticRoutingHelper_a8f1c020b21aedf9fd8effcef3940b0f0}


Add a multicast route to a node and device using a \hyperlink{classns3_1_1Ptr}{Ptr$<$\+Node$>$} and a name string previously associated to the device using the \hyperlink{classns3_1_1Object}{Object} Name Service. 


\begin{DoxyParams}{Parameters}
{\em n} & The node. \\
\hline
{\em source} & Source address. \\
\hline
{\em group} & Multicast group. \\
\hline
{\em input\+Name} & Input \hyperlink{classns3_1_1NetDevice}{Net\+Device}. \\
\hline
{\em output} & Output Net\+Devices. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
132 \{
133   Ptr<NetDevice> input = Names::Find<NetDevice> (inputName);
134   \hyperlink{classns3_1_1Ipv4StaticRoutingHelper_aa8d55f28361e24aefb961fe2eddc2192}{AddMulticastRoute} (n, source, \hyperlink{namespacevisualizer_1_1higcontainer_aa6ad2b76790275bfce7783429beaa23f}{group}, input, output);
135 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6


\index{ns3\+::\+Ipv4\+Static\+Routing\+Helper@{ns3\+::\+Ipv4\+Static\+Routing\+Helper}!Add\+Multicast\+Route@{Add\+Multicast\+Route}}
\index{Add\+Multicast\+Route@{Add\+Multicast\+Route}!ns3\+::\+Ipv4\+Static\+Routing\+Helper@{ns3\+::\+Ipv4\+Static\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Add\+Multicast\+Route(std\+::string n\+Name, Ipv4\+Address source, Ipv4\+Address group, std\+::string input\+Name, Net\+Device\+Container output)}{AddMulticastRoute(std::string nName, Ipv4Address source, Ipv4Address group, std::string inputName, NetDeviceContainer output)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Static\+Routing\+Helper\+::\+Add\+Multicast\+Route (
\begin{DoxyParamCaption}
\item[{std\+::string}]{n\+Name, }
\item[{{\bf Ipv4\+Address}}]{source, }
\item[{{\bf Ipv4\+Address}}]{group, }
\item[{std\+::string}]{input\+Name, }
\item[{{\bf Net\+Device\+Container}}]{output}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4StaticRoutingHelper_ad4e1b19d7df693754de7f808dbce521e}{}\label{classns3_1_1Ipv4StaticRoutingHelper_ad4e1b19d7df693754de7f808dbce521e}


Add a multicast route to a node and device using name strings previously associated to both the node and device using the \hyperlink{classns3_1_1Object}{Object} Name Service. 


\begin{DoxyParams}{Parameters}
{\em n\+Name} & The node. \\
\hline
{\em source} & Source address. \\
\hline
{\em group} & Multicast group. \\
\hline
{\em input\+Name} & Input \hyperlink{classns3_1_1NetDevice}{Net\+Device}. \\
\hline
{\em output} & Output Net\+Devices. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
156 \{
157   Ptr<NetDevice> input = Names::Find<NetDevice> (inputName);
158   Ptr<Node> \hyperlink{namespacesample-rng-plot_aeb5ee5c431e338ef39b7ac5431242e1d}{n} = Names::Find<Node> (nName);
159   \hyperlink{classns3_1_1Ipv4StaticRoutingHelper_aa8d55f28361e24aefb961fe2eddc2192}{AddMulticastRoute} (n, source, \hyperlink{namespacevisualizer_1_1higcontainer_aa6ad2b76790275bfce7783429beaa23f}{group}, input, output);
160 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7


\index{ns3\+::\+Ipv4\+Static\+Routing\+Helper@{ns3\+::\+Ipv4\+Static\+Routing\+Helper}!Copy@{Copy}}
\index{Copy@{Copy}!ns3\+::\+Ipv4\+Static\+Routing\+Helper@{ns3\+::\+Ipv4\+Static\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Copy(void) const }{Copy(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Static\+Routing\+Helper} $\ast$ ns3\+::\+Ipv4\+Static\+Routing\+Helper\+::\+Copy (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4StaticRoutingHelper_a0cf5ca3ae4ffbfab2ed392e47327ee43}{}\label{classns3_1_1Ipv4StaticRoutingHelper_a0cf5ca3ae4ffbfab2ed392e47327ee43}
\begin{DoxyReturn}{Returns}
pointer to clone of this \hyperlink{classns3_1_1Ipv4StaticRoutingHelper}{Ipv4\+Static\+Routing\+Helper}
\end{DoxyReturn}
This method is mainly for internal use by the other helpers; clients are expected to free the dynamic memory allocated by this method 

Implements \hyperlink{classns3_1_1Ipv4RoutingHelper_acf569a0ecf95d5b5186456f368eaa465}{ns3\+::\+Ipv4\+Routing\+Helper}.


\begin{DoxyCode}
46 \{
47   \textcolor{keywordflow}{return} \textcolor{keyword}{new} \hyperlink{classns3_1_1Ipv4StaticRoutingHelper_a8dac1b77f202bd0a3de3b442dfdf34dd}{Ipv4StaticRoutingHelper} (*\textcolor{keyword}{this});
48 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8


\index{ns3\+::\+Ipv4\+Static\+Routing\+Helper@{ns3\+::\+Ipv4\+Static\+Routing\+Helper}!Create@{Create}}
\index{Create@{Create}!ns3\+::\+Ipv4\+Static\+Routing\+Helper@{ns3\+::\+Ipv4\+Static\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Create(\+Ptr$<$ Node $>$ node) const }{Create(Ptr< Node > node) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv4\+Routing\+Protocol} $>$ ns3\+::\+Ipv4\+Static\+Routing\+Helper\+::\+Create (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4StaticRoutingHelper_afb0392b022183275e7949eb9235334e9}{}\label{classns3_1_1Ipv4StaticRoutingHelper_afb0392b022183275e7949eb9235334e9}

\begin{DoxyParams}{Parameters}
{\em node} & the node on which the routing protocol will run \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a newly-\/created routing protocol
\end{DoxyReturn}
This method will be called by \hyperlink{classns3_1_1InternetStackHelper_a6645b412f31283d2d9bc3d8a95cebbc0}{ns3\+::\+Internet\+Stack\+Helper\+::\+Install} 

Implements \hyperlink{classns3_1_1Ipv4RoutingHelper_aa00350f9ab9f2ea2ff83f6ef04dae209}{ns3\+::\+Ipv4\+Routing\+Helper}.


\begin{DoxyCode}
52 \{
53   \textcolor{keywordflow}{return} CreateObject<Ipv4StaticRouting> ();
54 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Static\+Routing\+Helper@{ns3\+::\+Ipv4\+Static\+Routing\+Helper}!Get\+Static\+Routing@{Get\+Static\+Routing}}
\index{Get\+Static\+Routing@{Get\+Static\+Routing}!ns3\+::\+Ipv4\+Static\+Routing\+Helper@{ns3\+::\+Ipv4\+Static\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Get\+Static\+Routing(\+Ptr$<$ Ipv4 $>$ ipv4) const }{GetStaticRouting(Ptr< Ipv4 > ipv4) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv4\+Static\+Routing} $>$ ns3\+::\+Ipv4\+Static\+Routing\+Helper\+::\+Get\+Static\+Routing (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv4} $>$}]{ipv4}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv4StaticRoutingHelper_a731206e50d305695dac7fb2ef963a4bb}{}\label{classns3_1_1Ipv4StaticRoutingHelper_a731206e50d305695dac7fb2ef963a4bb}
Try and find the static routing protocol as either the main routing protocol or in the list of routing protocols associated with the \hyperlink{classns3_1_1Ipv4}{Ipv4} provided.


\begin{DoxyParams}{Parameters}
{\em ipv4} & the Ptr$<$\+Ipv4$>$ to search for the static routing protocol \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{classns3_1_1Ipv4StaticRouting}{Ipv4\+Static\+Routing} pointer or 0 if not found 
\end{DoxyReturn}

\begin{DoxyCode}
59 \{
60   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
61   Ptr<Ipv4RoutingProtocol> ipv4rp = ipv4->GetRoutingProtocol ();
62   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (ipv4rp, \textcolor{stringliteral}{"No routing protocol associated with Ipv4"});
63   \textcolor{keywordflow}{if} (DynamicCast<Ipv4StaticRouting> (ipv4rp))
64     \{
65       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Static routing found as the main IPv4 routing protocol."});
66       \textcolor{keywordflow}{return} DynamicCast<Ipv4StaticRouting> (ipv4rp); 
67     \} 
68   \textcolor{keywordflow}{if} (DynamicCast<Ipv4ListRouting> (ipv4rp))
69     \{
70       Ptr<Ipv4ListRouting> lrp = DynamicCast<Ipv4ListRouting> (ipv4rp);
71       int16\_t priority;
72       \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < lrp->GetNRoutingProtocols ();  \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
73         \{
74           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Searching for static routing in list"});
75           Ptr<Ipv4RoutingProtocol> temp = lrp->GetRoutingProtocol (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, priority);
76           \textcolor{keywordflow}{if} (DynamicCast<Ipv4StaticRouting> (temp))
77             \{
78               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Found static routing in list"});
79               \textcolor{keywordflow}{return} DynamicCast<Ipv4StaticRouting> (temp);
80             \}
81         \}
82     \}
83   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Static routing not found"});
84   \textcolor{keywordflow}{return} 0;
85 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 9


\index{ns3\+::\+Ipv4\+Static\+Routing\+Helper@{ns3\+::\+Ipv4\+Static\+Routing\+Helper}!operator=@{operator=}}
\index{operator=@{operator=}!ns3\+::\+Ipv4\+Static\+Routing\+Helper@{ns3\+::\+Ipv4\+Static\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{operator=(const Ipv4\+Static\+Routing\+Helper \&)}{operator=(const Ipv4StaticRoutingHelper &)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Static\+Routing\+Helper}\& ns3\+::\+Ipv4\+Static\+Routing\+Helper\+::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf Ipv4\+Static\+Routing\+Helper} \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4StaticRoutingHelper_a732a01272d46668aa2cdffa3d05ac3ac}{}\label{classns3_1_1Ipv4StaticRoutingHelper_a732a01272d46668aa2cdffa3d05ac3ac}


Assignment operator declared private and not implemented to disallow assignment and prevent the compiler from happily inserting its own. 

\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\index{ns3\+::\+Ipv4\+Static\+Routing\+Helper@{ns3\+::\+Ipv4\+Static\+Routing\+Helper}!Set\+Default\+Multicast\+Route@{Set\+Default\+Multicast\+Route}}
\index{Set\+Default\+Multicast\+Route@{Set\+Default\+Multicast\+Route}!ns3\+::\+Ipv4\+Static\+Routing\+Helper@{ns3\+::\+Ipv4\+Static\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Set\+Default\+Multicast\+Route(\+Ptr$<$ Node $>$ n, Ptr$<$ Net\+Device $>$ nd)}{SetDefaultMulticastRoute(Ptr< Node > n, Ptr< NetDevice > nd)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Static\+Routing\+Helper\+::\+Set\+Default\+Multicast\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{n, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{nd}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4StaticRoutingHelper_ae69a07ded3139dfd4e21bb7c10eba416}{}\label{classns3_1_1Ipv4StaticRoutingHelper_ae69a07ded3139dfd4e21bb7c10eba416}


Add a default route to the static routing protocol to forward packets out a particular interface. 

Functionally equivalent to\+: route add 224.\+0.\+0.\+0 netmask 240.\+0.\+0.\+0 dev nd 
\begin{DoxyParams}{Parameters}
{\em n} & node \\
\hline
{\em nd} & device of the node to add default route \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
166 \{
167   Ptr<Ipv4> ipv4 = n->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv4> ();
168   int32\_t interfaceSrc = ipv4->GetInterfaceForDevice (nd);
169   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (interfaceSrc >= 0,
170                  \textcolor{stringliteral}{"Ipv4StaticRoutingHelper::SetDefaultMulticastRoute(): "}
171                  \textcolor{stringliteral}{"Expected an interface associated with the device"});
172   \hyperlink{classns3_1_1Ipv4StaticRoutingHelper_a8dac1b77f202bd0a3de3b442dfdf34dd}{Ipv4StaticRoutingHelper} helper;
173   Ptr<Ipv4StaticRouting> ipv4StaticRouting = helper.GetStaticRouting (ipv4);
174   \textcolor{keywordflow}{if} (!ipv4StaticRouting)
175     \{
176       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (ipv4StaticRouting, 
177                      \textcolor{stringliteral}{"Ipv4StaticRoutingHelper::SetDefaultMulticastRoute(): "}
178                      \textcolor{stringliteral}{"Expected an Ipv4StaticRouting associated with this node"});
179     \}
180   ipv4StaticRouting->SetDefaultMulticastRoute (interfaceSrc);
181 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10




Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::\+Ipv4\+Static\+Routing\+Helper@{ns3\+::\+Ipv4\+Static\+Routing\+Helper}!Set\+Default\+Multicast\+Route@{Set\+Default\+Multicast\+Route}}
\index{Set\+Default\+Multicast\+Route@{Set\+Default\+Multicast\+Route}!ns3\+::\+Ipv4\+Static\+Routing\+Helper@{ns3\+::\+Ipv4\+Static\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Set\+Default\+Multicast\+Route(\+Ptr$<$ Node $>$ n, std\+::string nd\+Name)}{SetDefaultMulticastRoute(Ptr< Node > n, std::string ndName)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Static\+Routing\+Helper\+::\+Set\+Default\+Multicast\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{n, }
\item[{std\+::string}]{nd\+Name}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4StaticRoutingHelper_ab755c8e22952804d93c47b914819e1db}{}\label{classns3_1_1Ipv4StaticRoutingHelper_ab755c8e22952804d93c47b914819e1db}


Add a default route to the static routing protocol to forward packets out a particular interface. 

Functionally equivalent to\+: route add 224.\+0.\+0.\+0 netmask 240.\+0.\+0.\+0 dev nd 
\begin{DoxyParams}{Parameters}
{\em n} & node \\
\hline
{\em nd\+Name} & string with name previously associated to device using the \hyperlink{classns3_1_1Object}{Object} Name Service \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
187 \{
188   Ptr<NetDevice> nd = Names::Find<NetDevice> (ndName);
189   \hyperlink{classns3_1_1Ipv4StaticRoutingHelper_ae69a07ded3139dfd4e21bb7c10eba416}{SetDefaultMulticastRoute} (n, nd);
190 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12


\index{ns3\+::\+Ipv4\+Static\+Routing\+Helper@{ns3\+::\+Ipv4\+Static\+Routing\+Helper}!Set\+Default\+Multicast\+Route@{Set\+Default\+Multicast\+Route}}
\index{Set\+Default\+Multicast\+Route@{Set\+Default\+Multicast\+Route}!ns3\+::\+Ipv4\+Static\+Routing\+Helper@{ns3\+::\+Ipv4\+Static\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Set\+Default\+Multicast\+Route(std\+::string n\+Name, Ptr$<$ Net\+Device $>$ nd)}{SetDefaultMulticastRoute(std::string nName, Ptr< NetDevice > nd)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Static\+Routing\+Helper\+::\+Set\+Default\+Multicast\+Route (
\begin{DoxyParamCaption}
\item[{std\+::string}]{n\+Name, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{nd}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4StaticRoutingHelper_adcdf30e8246096f94535fb2472bf9701}{}\label{classns3_1_1Ipv4StaticRoutingHelper_adcdf30e8246096f94535fb2472bf9701}


Add a default route to the static routing protocol to forward packets out a particular interface. 

Functionally equivalent to\+: route add 224.\+0.\+0.\+0 netmask 240.\+0.\+0.\+0 dev nd 
\begin{DoxyParams}{Parameters}
{\em n\+Name} & string with name previously associated to node using the \hyperlink{classns3_1_1Object}{Object} Name Service \\
\hline
{\em nd} & device of the node to add default route \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
196 \{
197   Ptr<Node> \hyperlink{namespacesample-rng-plot_aeb5ee5c431e338ef39b7ac5431242e1d}{n} = Names::Find<Node> (nName);
198   \hyperlink{classns3_1_1Ipv4StaticRoutingHelper_ae69a07ded3139dfd4e21bb7c10eba416}{SetDefaultMulticastRoute} (n, nd);
199 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13


\index{ns3\+::\+Ipv4\+Static\+Routing\+Helper@{ns3\+::\+Ipv4\+Static\+Routing\+Helper}!Set\+Default\+Multicast\+Route@{Set\+Default\+Multicast\+Route}}
\index{Set\+Default\+Multicast\+Route@{Set\+Default\+Multicast\+Route}!ns3\+::\+Ipv4\+Static\+Routing\+Helper@{ns3\+::\+Ipv4\+Static\+Routing\+Helper}}
\subsubsection[{\texorpdfstring{Set\+Default\+Multicast\+Route(std\+::string n\+Name, std\+::string nd\+Name)}{SetDefaultMulticastRoute(std::string nName, std::string ndName)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Static\+Routing\+Helper\+::\+Set\+Default\+Multicast\+Route (
\begin{DoxyParamCaption}
\item[{std\+::string}]{n\+Name, }
\item[{std\+::string}]{nd\+Name}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4StaticRoutingHelper_ac9e71b7b9d1f958df552166cbc210768}{}\label{classns3_1_1Ipv4StaticRoutingHelper_ac9e71b7b9d1f958df552166cbc210768}


Add a default route to the static routing protocol to forward packets out a particular interface. 

Functionally equivalent to\+: route add 224.\+0.\+0.\+0 netmask 240.\+0.\+0.\+0 dev nd 
\begin{DoxyParams}{Parameters}
{\em n\+Name} & string with name previously associated to node using the \hyperlink{classns3_1_1Object}{Object} Name Service \\
\hline
{\em nd\+Name} & string with name previously associated to device using the \hyperlink{classns3_1_1Object}{Object} Name Service \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
205 \{
206   Ptr<Node> \hyperlink{namespacesample-rng-plot_aeb5ee5c431e338ef39b7ac5431242e1d}{n} = Names::Find<Node> (nName);
207   Ptr<NetDevice> nd = Names::Find<NetDevice> (ndName);
208   \hyperlink{classns3_1_1Ipv4StaticRoutingHelper_ae69a07ded3139dfd4e21bb7c10eba416}{SetDefaultMulticastRoute} (n, nd);
209 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 14




The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/helper/\hyperlink{ipv4-static-routing-helper_8h}{ipv4-\/static-\/routing-\/helper.\+h}\item 
internet/helper/\hyperlink{ipv4-static-routing-helper_8cc}{ipv4-\/static-\/routing-\/helper.\+cc}\end{DoxyCompactItemize}
