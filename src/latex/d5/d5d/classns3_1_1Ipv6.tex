\hypertarget{classns3_1_1Ipv6}{}\section{ns3\+:\+:Ipv6 Class Reference}
\label{classns3_1_1Ipv6}\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}


Access to the I\+Pv6 forwarding table, interfaces, and configuration.  




{\ttfamily \#include $<$ipv6.\+h$>$}



Inheritance diagram for ns3\+:\+:Ipv6\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Ipv6\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ipv6_adccc58acd14d3f9a28f75dc09e794998}{Ipv6} ()
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ipv6_a9e8db744ad2d252a50b1f19192a22225}{$\sim$\+Ipv6} ()
\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6_aa889d2174527a1df773d65974de83f8f}{Set\+Routing\+Protocol} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} $>$ routing\+Protocol)=0
\begin{DoxyCompactList}\small\item\em Register a new routing protocol to be used by this I\+Pv6 stack. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} $>$ \hyperlink{classns3_1_1Ipv6_af14dc67ff4c251776e5d0fca16c5cc7c}{Get\+Routing\+Protocol} (void) const =0
\begin{DoxyCompactList}\small\item\em Get the routing protocol to be used by this I\+Pv6 stack. \end{DoxyCompactList}\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1Ipv6_a4fd7da82c16b8abf9ca15f982918e6a4}{Add\+Interface} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device)=0
\begin{DoxyCompactList}\small\item\em Add a \hyperlink{classns3_1_1NetDevice}{Net\+Device} interface. \end{DoxyCompactList}\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1Ipv6_af024eb66563d0958b00ba79ed00b0642}{Get\+N\+Interfaces} (void) const =0
\begin{DoxyCompactList}\small\item\em Get number of interfaces. \end{DoxyCompactList}\item 
virtual int32\+\_\+t \hyperlink{classns3_1_1Ipv6_aa8003b6741a18e196d7cb8369e2ef80f}{Get\+Interface\+For\+Address} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} address) const =0
\begin{DoxyCompactList}\small\item\em Return the interface number of the interface that has been assigned the specified IP address. \end{DoxyCompactList}\item 
virtual int32\+\_\+t \hyperlink{classns3_1_1Ipv6_a5f3369dd6c6b2e40aae5af0eed096f48}{Get\+Interface\+For\+Prefix} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} address, \hyperlink{classns3_1_1Ipv6Prefix}{Ipv6\+Prefix} mask) const =0
\begin{DoxyCompactList}\small\item\em Return the interface number of first interface found that has an I\+Pv6 address within the prefix specified by the input address and mask parameters. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ \hyperlink{classns3_1_1Ipv6_a6e7c9dea7730b4414e543241399faecf}{Get\+Net\+Device} (uint32\+\_\+t interface)=0
\begin{DoxyCompactList}\small\item\em Get the \hyperlink{classns3_1_1NetDevice}{Net\+Device} of the specified interface number. \end{DoxyCompactList}\item 
virtual int32\+\_\+t \hyperlink{classns3_1_1Ipv6_a3337dc6ce66612b0fa9b57f7f0338745}{Get\+Interface\+For\+Device} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device) const =0
\begin{DoxyCompactList}\small\item\em Get the interface index of the specified \hyperlink{classns3_1_1NetDevice}{Net\+Device}. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1Ipv6_a5cd576e83cf65445be3a0b5ffd1ddc5c}{Add\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv6InterfaceAddress}{Ipv6\+Interface\+Address} address)=0
\begin{DoxyCompactList}\small\item\em Add an address on the specified I\+Pv6 interface. \end{DoxyCompactList}\item 
virtual uint32\+\_\+t \hyperlink{classns3_1_1Ipv6_ac62012f48487d1e957a45f40a9386697}{Get\+N\+Addresses} (uint32\+\_\+t interface) const =0
\begin{DoxyCompactList}\small\item\em Get number of addresses on specified I\+Pv6 interface. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ipv6InterfaceAddress}{Ipv6\+Interface\+Address} \hyperlink{classns3_1_1Ipv6_a00f1aa203323d9afa48d58af8af0e73b}{Get\+Address} (uint32\+\_\+t interface, uint32\+\_\+t address\+Index) const =0
\begin{DoxyCompactList}\small\item\em Get I\+Pv6 address on specified I\+Pv6 interface. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1Ipv6_ad1e1c4d33ad96a76683ce8cea9d01780}{Remove\+Address} (uint32\+\_\+t interface, uint32\+\_\+t address\+Index)=0
\begin{DoxyCompactList}\small\item\em Remove an address on specified I\+Pv6 interface. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1Ipv6_a29f451acbf047880073add4d0bd40550}{Remove\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} address)=0
\begin{DoxyCompactList}\small\item\em Remove the given address on named \hyperlink{classns3_1_1Ipv6}{Ipv6} interface. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6_ab8dfd51c931ebc11c107bff673bae827}{Set\+Metric} (uint32\+\_\+t interface, uint16\+\_\+t metric)=0
\begin{DoxyCompactList}\small\item\em Set metric on specified \hyperlink{classns3_1_1Ipv6}{Ipv6} interface. \end{DoxyCompactList}\item 
virtual uint16\+\_\+t \hyperlink{classns3_1_1Ipv6_a6bae4637f2a7f1e566a53c3270b891d4}{Get\+Metric} (uint32\+\_\+t interface) const =0
\begin{DoxyCompactList}\small\item\em Get metric for the specified I\+Pv6 interface. \end{DoxyCompactList}\item 
virtual uint16\+\_\+t \hyperlink{classns3_1_1Ipv6_a2eb71c704b0ed9f92161a988b644600d}{Get\+Mtu} (uint32\+\_\+t interface) const =0
\begin{DoxyCompactList}\small\item\em Get M\+TU for the specified I\+Pv6 interface. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6_a2f791bd08927bcbbba2694813cb52710}{Set\+Pmtu} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dst, uint32\+\_\+t pmtu)=0
\begin{DoxyCompactList}\small\item\em Set the Path M\+TU for the specified I\+Pv6 destination address. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1Ipv6_a4aad08a05734df75ca70bff43188068f}{Is\+Up} (uint32\+\_\+t interface) const =0
\begin{DoxyCompactList}\small\item\em If the specified interface index is in \char`\"{}up\char`\"{} state. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6_a8e61d85ec7fd342ed38fef2d040ed1b9}{Set\+Up} (uint32\+\_\+t interface)=0
\begin{DoxyCompactList}\small\item\em Set the interface into the \char`\"{}up\char`\"{} state. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6_ada8ade0638959d7acf65682580c43ee6}{Set\+Down} (uint32\+\_\+t interface)=0
\begin{DoxyCompactList}\small\item\em Set the interface into the \char`\"{}down\char`\"{} state. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1Ipv6_a7240bf60410f8398d072641c6460339f}{Is\+Forwarding} (uint32\+\_\+t interface) const =0
\begin{DoxyCompactList}\small\item\em If the specified I\+Pv6 interface has forwarding enabled. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6_a8f7c711267860c54bf3a645b24bf2eef}{Set\+Forwarding} (uint32\+\_\+t interface, bool val)=0
\begin{DoxyCompactList}\small\item\em Set forwarding on specified I\+Pv6 interface. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} \hyperlink{classns3_1_1Ipv6_a07bfb23e4bee98b2a2bfb56c16908cd4}{Source\+Address\+Selection} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dest)=0
\begin{DoxyCompactList}\small\item\em Choose the source address to use with destination address. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6_af696a13faee7772aa155e6b06a752220}{Insert} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} $>$ protocol)=0
\begin{DoxyCompactList}\small\item\em Add a L4 protocol. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6_abac82ab5421240d8011131f0f49a080b}{Insert} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} $>$ protocol, uint32\+\_\+t interface\+Index)=0
\begin{DoxyCompactList}\small\item\em Add a L4 protocol to a specific interface. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6_abb09312c165a45923cd88061a3be2c82}{Remove} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} $>$ protocol)=0
\begin{DoxyCompactList}\small\item\em Remove a L4 protocol. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6_ac8f460ea4a38988cbc80b91a14e45912}{Remove} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} $>$ protocol, uint32\+\_\+t interface\+Index)=0
\begin{DoxyCompactList}\small\item\em Remove a L4 protocol from a specific interface. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} $>$ \hyperlink{classns3_1_1Ipv6_aef0e6be6a6def36087298f48e0b235a3}{Get\+Protocol} (int protocol\+Number) const =0
\begin{DoxyCompactList}\small\item\em Get L4 protocol by protocol number. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} $>$ \hyperlink{classns3_1_1Ipv6_a8fa557713b63afce0b11b720d6e639d4}{Get\+Protocol} (int protocol\+Number, int32\+\_\+t interface\+Index) const =0
\begin{DoxyCompactList}\small\item\em Get L4 protocol by protocol number for the specified interface. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6_a2aad308983b20eb54334bb0d3db31004}{Send} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} source, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} destination, uint8\+\_\+t protocol, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Route}{Ipv6\+Route} $>$ route)=0
\begin{DoxyCompactList}\small\item\em Higher-\/level layers call this method to send a packet down the stack to the M\+AC and P\+HY layers. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6_a57bd0dd1c4b1b9bb63b748124a548fe5}{Register\+Extensions} ()=0
\begin{DoxyCompactList}\small\item\em Register the I\+Pv6 Extensions. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6_a95905b14fff6edf0c4de70f47f6312cb}{Register\+Options} ()=0
\begin{DoxyCompactList}\small\item\em Register the I\+Pv6 Options. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1Ipv6_a286c4af336a746ceb5cfd655da1a42dd}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const uint32\+\_\+t \hyperlink{classns3_1_1Ipv6_a1e55b17e6e1a4e1b439778543458bbe3}{I\+F\+\_\+\+A\+NY} = 0xffffffff
\begin{DoxyCompactList}\small\item\em Any interface magic number. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1Ipv6_a173e9acf3a03e1d333ca3be56a6c4f38}{Set\+Ip\+Forward} (bool forward)=0
\begin{DoxyCompactList}\small\item\em Set I\+Pv6 forwarding state. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1Ipv6_a26466999fd77426c00a4afd8b9a1ba32}{Get\+Ip\+Forward} (void) const =0
\begin{DoxyCompactList}\small\item\em Get I\+Pv6 forwarding state. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6_a3204b23a92a2495b428bd882a988369a}{Set\+Mtu\+Discover} (bool mtu\+Discover)=0
\begin{DoxyCompactList}\small\item\em Set I\+Pv6 M\+TU discover state. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1Ipv6_a0de538c1b10148675d4d49efa32258f9}{Get\+Mtu\+Discover} (void) const =0
\begin{DoxyCompactList}\small\item\em Get I\+Pv6 M\+TU discover state. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Access to the I\+Pv6 forwarding table, interfaces, and configuration. 

This class defines the A\+PI to manipulate the following aspects of the I\+Pv6 implementation\+:
\begin{DoxyEnumerate}
\item set/get an \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol}
\item register a \hyperlink{classns3_1_1NetDevice}{Net\+Device} for use by the I\+Pv6 layer (basically, to create I\+Pv6-\/related state such as addressing and neighbor cache that is associated with a \hyperlink{classns3_1_1NetDevice}{Net\+Device})
\item manipulate the status of the \hyperlink{classns3_1_1NetDevice}{Net\+Device} from the I\+Pv6 perspective, such as marking it as Up or Down,
\item adding, deleting, and getting addresses associated to the I\+Pv6 interfaces.
\item exporting I\+Pv6 configuration attributes
\end{DoxyEnumerate}

Each \hyperlink{classns3_1_1NetDevice}{Net\+Device} has conceptually a single I\+Pv6 interface associated with it (the corresponding structure in the Linux I\+Pv6 implementation is struct in\+\_\+device). Each interface may have one or more I\+Pv6 addresses associated with it. Each I\+Pv6 address may have different subnet mask, scope, etc., so all of this per-\/address information is stored in an \hyperlink{classns3_1_1Ipv6InterfaceAddress}{Ipv6\+Interface\+Address} class (the corresponding structure in Linux is struct in6\+\_\+ifaddr)

I\+Pv6 attributes such as whether IP forwarding is enabled and disabled are also stored in this class

TO DO\+: Add A\+PI to allow access to the I\+Pv6 neighbor table

\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} 

\hyperlink{classns3_1_1Ipv6InterfaceAddress}{Ipv6\+Interface\+Address} 
\end{DoxySeeAlso}


\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Ipv6@{Ipv6}}
\index{Ipv6@{Ipv6}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Ipv6()}{Ipv6()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv6\+::\+Ipv6 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6_adccc58acd14d3f9a28f75dc09e794998}{}\label{classns3_1_1Ipv6_adccc58acd14d3f9a28f75dc09e794998}


Constructor. 


\begin{DoxyCode}
54 \{
55 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!````~Ipv6@{$\sim$\+Ipv6}}
\index{````~Ipv6@{$\sim$\+Ipv6}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{$\sim$\+Ipv6()}{~Ipv6()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv6\+::$\sim$\+Ipv6 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6_a9e8db744ad2d252a50b1f19192a22225}{}\label{classns3_1_1Ipv6_a9e8db744ad2d252a50b1f19192a22225}


Destructor. 


\begin{DoxyCode}
58 \{
59 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Add\+Address@{Add\+Address}}
\index{Add\+Address@{Add\+Address}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Add\+Address(uint32\+\_\+t interface, Ipv6\+Interface\+Address address)=0}{AddAddress(uint32_t interface, Ipv6InterfaceAddress address)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool ns3\+::\+Ipv6\+::\+Add\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv6\+Interface\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_a5cd576e83cf65445be3a0b5ffd1ddc5c}{}\label{classns3_1_1Ipv6_a5cd576e83cf65445be3a0b5ffd1ddc5c}


Add an address on the specified I\+Pv6 interface. 


\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of an I\+Pv6 interface \\
\hline
{\em address} & \hyperlink{classns3_1_1Ipv6InterfaceAddress}{Ipv6\+Interface\+Address} address to associate with the underlying I\+Pv6 interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the operation succeeded 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_a33135677dcaa195be223eaf4f38a6efe}{ns3\+::\+Ipv6\+L3\+Protocol}.



Here is the caller graph for this function\+:
% FIG 2


\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Add\+Interface@{Add\+Interface}}
\index{Add\+Interface@{Add\+Interface}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Add\+Interface(\+Ptr$<$ Net\+Device $>$ device)=0}{AddInterface(Ptr< NetDevice > device)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual uint32\+\_\+t ns3\+::\+Ipv6\+::\+Add\+Interface (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{device}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_a4fd7da82c16b8abf9ca15f982918e6a4}{}\label{classns3_1_1Ipv6_a4fd7da82c16b8abf9ca15f982918e6a4}


Add a \hyperlink{classns3_1_1NetDevice}{Net\+Device} interface. 

Once a device has been added, it can never be removed\+: if you want to disable it, you can invoke \hyperlink{classns3_1_1Ipv6_ada8ade0638959d7acf65682580c43ee6}{Ipv6\+::\+Set\+Down} which will make sure that it is never used during packet forwarding. 
\begin{DoxyParams}{Parameters}
{\em device} & device to add to the list of I\+Pv6 interfaces which can be used as output interfaces during packet forwarding. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the index of the I\+Pv6 interface added. 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_a56047c2ee7db15185af07538c609cbb5}{ns3\+::\+Ipv6\+L3\+Protocol}.



Here is the caller graph for this function\+:
% FIG 3


\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Get\+Address@{Get\+Address}}
\index{Get\+Address@{Get\+Address}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Get\+Address(uint32\+\_\+t interface, uint32\+\_\+t address\+Index) const =0}{GetAddress(uint32_t interface, uint32_t addressIndex) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Ipv6\+Interface\+Address} ns3\+::\+Ipv6\+::\+Get\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{uint32\+\_\+t}]{address\+Index}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_a00f1aa203323d9afa48d58af8af0e73b}{}\label{classns3_1_1Ipv6_a00f1aa203323d9afa48d58af8af0e73b}


Get I\+Pv6 address on specified I\+Pv6 interface. 

Because addresses can be removed, the address\+Index is not guaranteed to be static across calls to this method.


\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of an I\+Pv6 interface \\
\hline
{\em address\+Index} & index of \hyperlink{classns3_1_1Ipv6InterfaceAddress}{Ipv6\+Interface\+Address} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the \hyperlink{classns3_1_1Ipv6InterfaceAddress}{Ipv6\+Interface\+Address} associated to the interface and address\+Index 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_a0321a9ac3f79b5a7b7542cecf11bfe44}{ns3\+::\+Ipv6\+L3\+Protocol}.

\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Get\+Interface\+For\+Address@{Get\+Interface\+For\+Address}}
\index{Get\+Interface\+For\+Address@{Get\+Interface\+For\+Address}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Get\+Interface\+For\+Address(\+Ipv6\+Address address) const =0}{GetInterfaceForAddress(Ipv6Address address) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual int32\+\_\+t ns3\+::\+Ipv6\+::\+Get\+Interface\+For\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{address}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_aa8003b6741a18e196d7cb8369e2ef80f}{}\label{classns3_1_1Ipv6_aa8003b6741a18e196d7cb8369e2ef80f}


Return the interface number of the interface that has been assigned the specified IP address. 


\begin{DoxyParams}{Parameters}
{\em address} & The IP address being searched for \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The interface number of the I\+Pv6 interface with the given address or -\/1 if not found.
\end{DoxyReturn}
Each IP interface has one or more IP addresses associated with it. This method searches the list of interfaces for one that holds a particular address. This call takes an IP address as a parameter and returns the interface number of the first interface that has been assigned that address, or -\/1 if not found. There must be an exact match. 

Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_ae8d652431e374e8b05425ae9e1bf0f1b}{ns3\+::\+Ipv6\+L3\+Protocol}.

\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Get\+Interface\+For\+Device@{Get\+Interface\+For\+Device}}
\index{Get\+Interface\+For\+Device@{Get\+Interface\+For\+Device}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Get\+Interface\+For\+Device(\+Ptr$<$ const Net\+Device $>$ device) const =0}{GetInterfaceForDevice(Ptr< const NetDevice > device) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual int32\+\_\+t ns3\+::\+Ipv6\+::\+Get\+Interface\+For\+Device (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Net\+Device} $>$}]{device}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_a3337dc6ce66612b0fa9b57f7f0338745}{}\label{classns3_1_1Ipv6_a3337dc6ce66612b0fa9b57f7f0338745}


Get the interface index of the specified \hyperlink{classns3_1_1NetDevice}{Net\+Device}. 


\begin{DoxyParams}{Parameters}
{\em device} & The \hyperlink{classns3_1_1NetDevice}{Net\+Device} for an \hyperlink{classns3_1_1Ipv6Interface}{Ipv6\+Interface} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The interface number of an I\+Pv6 interface or -\/1 if not found. 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_a878292513d6294e2dfdeccbe1ed1d996}{ns3\+::\+Ipv6\+L3\+Protocol}.



Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Get\+Interface\+For\+Prefix@{Get\+Interface\+For\+Prefix}}
\index{Get\+Interface\+For\+Prefix@{Get\+Interface\+For\+Prefix}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Get\+Interface\+For\+Prefix(\+Ipv6\+Address address, Ipv6\+Prefix mask) const =0}{GetInterfaceForPrefix(Ipv6Address address, Ipv6Prefix mask) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual int32\+\_\+t ns3\+::\+Ipv6\+::\+Get\+Interface\+For\+Prefix (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{address, }
\item[{{\bf Ipv6\+Prefix}}]{mask}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_a5f3369dd6c6b2e40aae5af0eed096f48}{}\label{classns3_1_1Ipv6_a5f3369dd6c6b2e40aae5af0eed096f48}


Return the interface number of first interface found that has an I\+Pv6 address within the prefix specified by the input address and mask parameters. 


\begin{DoxyParams}{Parameters}
{\em address} & The IP address assigned to the interface of interest. \\
\hline
{\em mask} & The IP prefix to use in the mask \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The interface number of the I\+Pv6 interface with the given address or -\/1 if not found.
\end{DoxyReturn}
Each IP interface has one or more IP addresses associated with it. This method searches the list of interfaces for the first one found that holds an address that is included within the prefix formed by the input address and mask parameters. The value -\/1 is returned if no match is found. 

Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_ad6454a2718ec03a97ff11a29bc015ef2}{ns3\+::\+Ipv6\+L3\+Protocol}.

\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Get\+Ip\+Forward@{Get\+Ip\+Forward}}
\index{Get\+Ip\+Forward@{Get\+Ip\+Forward}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Get\+Ip\+Forward(void) const =0}{GetIpForward(void) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool ns3\+::\+Ipv6\+::\+Get\+Ip\+Forward (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_a26466999fd77426c00a4afd8b9a1ba32}{}\label{classns3_1_1Ipv6_a26466999fd77426c00a4afd8b9a1ba32}


Get I\+Pv6 forwarding state. 

\begin{DoxyReturn}{Returns}
forwarding state (enabled or not) 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_a5ea6340dc5eef31896c71201dd789d49}{ns3\+::\+Ipv6\+L3\+Protocol}.



Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Get\+Metric@{Get\+Metric}}
\index{Get\+Metric@{Get\+Metric}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Get\+Metric(uint32\+\_\+t interface) const =0}{GetMetric(uint32_t interface) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual uint16\+\_\+t ns3\+::\+Ipv6\+::\+Get\+Metric (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_a6bae4637f2a7f1e566a53c3270b891d4}{}\label{classns3_1_1Ipv6_a6bae4637f2a7f1e566a53c3270b891d4}


Get metric for the specified I\+Pv6 interface. 


\begin{DoxyParams}{Parameters}
{\em interface} & The interface number of an I\+Pv6 interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
routing metric (cost) associated to the underlying I\+Pv6 interface 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_ad8b41a67f3f99823d6d5e0a5441970de}{ns3\+::\+Ipv6\+L3\+Protocol}.

\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Get\+Mtu@{Get\+Mtu}}
\index{Get\+Mtu@{Get\+Mtu}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Get\+Mtu(uint32\+\_\+t interface) const =0}{GetMtu(uint32_t interface) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual uint16\+\_\+t ns3\+::\+Ipv6\+::\+Get\+Mtu (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_a2eb71c704b0ed9f92161a988b644600d}{}\label{classns3_1_1Ipv6_a2eb71c704b0ed9f92161a988b644600d}


Get M\+TU for the specified I\+Pv6 interface. 


\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of I\+Pv6 interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the Maximum Transmission Unit (in bytes) associated to the underlying I\+Pv6 interface 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_a33cfa3ccae2ee968d581fc689c73beb5}{ns3\+::\+Ipv6\+L3\+Protocol}.

\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Get\+Mtu\+Discover@{Get\+Mtu\+Discover}}
\index{Get\+Mtu\+Discover@{Get\+Mtu\+Discover}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Get\+Mtu\+Discover(void) const =0}{GetMtuDiscover(void) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool ns3\+::\+Ipv6\+::\+Get\+Mtu\+Discover (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_a0de538c1b10148675d4d49efa32258f9}{}\label{classns3_1_1Ipv6_a0de538c1b10148675d4d49efa32258f9}


Get I\+Pv6 M\+TU discover state. 

\begin{DoxyReturn}{Returns}
M\+TU discover state (enabled or not) 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_a3214a558eb2b6549243f39eb821bd543}{ns3\+::\+Ipv6\+L3\+Protocol}.



Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Get\+N\+Addresses@{Get\+N\+Addresses}}
\index{Get\+N\+Addresses@{Get\+N\+Addresses}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Get\+N\+Addresses(uint32\+\_\+t interface) const =0}{GetNAddresses(uint32_t interface) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual uint32\+\_\+t ns3\+::\+Ipv6\+::\+Get\+N\+Addresses (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_ac62012f48487d1e957a45f40a9386697}{}\label{classns3_1_1Ipv6_ac62012f48487d1e957a45f40a9386697}


Get number of addresses on specified I\+Pv6 interface. 


\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of an I\+Pv6 interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of \hyperlink{classns3_1_1Ipv6InterfaceAddress}{Ipv6\+Interface\+Address} entries for the interface. 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_a3b09a9f504a311ecc08fdc026d897514}{ns3\+::\+Ipv6\+L3\+Protocol}.

\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Get\+Net\+Device@{Get\+Net\+Device}}
\index{Get\+Net\+Device@{Get\+Net\+Device}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Get\+Net\+Device(uint32\+\_\+t interface)=0}{GetNetDevice(uint32_t interface)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Ptr}$<${\bf Net\+Device}$>$ ns3\+::\+Ipv6\+::\+Get\+Net\+Device (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_a6e7c9dea7730b4414e543241399faecf}{}\label{classns3_1_1Ipv6_a6e7c9dea7730b4414e543241399faecf}


Get the \hyperlink{classns3_1_1NetDevice}{Net\+Device} of the specified interface number. 


\begin{DoxyParams}{Parameters}
{\em interface} & The interface number of an I\+Pv6 interface. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The \hyperlink{classns3_1_1NetDevice}{Net\+Device} associated with the I\+Pv6 interface number. 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_a574d1beafc86062acf582e75dc437a47}{ns3\+::\+Ipv6\+L3\+Protocol}.

\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Get\+N\+Interfaces@{Get\+N\+Interfaces}}
\index{Get\+N\+Interfaces@{Get\+N\+Interfaces}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Get\+N\+Interfaces(void) const =0}{GetNInterfaces(void) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual uint32\+\_\+t ns3\+::\+Ipv6\+::\+Get\+N\+Interfaces (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_af024eb66563d0958b00ba79ed00b0642}{}\label{classns3_1_1Ipv6_af024eb66563d0958b00ba79ed00b0642}


Get number of interfaces. 

\begin{DoxyReturn}{Returns}
the number of interfaces added by the user. 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_a53882c40f6fb32e2a6fe0a7a2858698d}{ns3\+::\+Ipv6\+L3\+Protocol}.

\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Get\+Protocol@{Get\+Protocol}}
\index{Get\+Protocol@{Get\+Protocol}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Get\+Protocol(int protocol\+Number) const =0}{GetProtocol(int protocolNumber) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Ptr}$<${\bf Ip\+L4\+Protocol}$>$ ns3\+::\+Ipv6\+::\+Get\+Protocol (
\begin{DoxyParamCaption}
\item[{int}]{protocol\+Number}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_aef0e6be6a6def36087298f48e0b235a3}{}\label{classns3_1_1Ipv6_aef0e6be6a6def36087298f48e0b235a3}


Get L4 protocol by protocol number. 


\begin{DoxyParams}{Parameters}
{\em protocol\+Number} & protocol number \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
corresponding \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} or 0 if not found 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_acb189bb5deceb95e78f2a443609c8d64}{ns3\+::\+Ipv6\+L3\+Protocol}.

\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Get\+Protocol@{Get\+Protocol}}
\index{Get\+Protocol@{Get\+Protocol}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Get\+Protocol(int protocol\+Number, int32\+\_\+t interface\+Index) const =0}{GetProtocol(int protocolNumber, int32_t interfaceIndex) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Ptr}$<${\bf Ip\+L4\+Protocol}$>$ ns3\+::\+Ipv6\+::\+Get\+Protocol (
\begin{DoxyParamCaption}
\item[{int}]{protocol\+Number, }
\item[{int32\+\_\+t}]{interface\+Index}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_a8fa557713b63afce0b11b720d6e639d4}{}\label{classns3_1_1Ipv6_a8fa557713b63afce0b11b720d6e639d4}


Get L4 protocol by protocol number for the specified interface. 


\begin{DoxyParams}{Parameters}
{\em protocol\+Number} & protocol number \\
\hline
{\em interface\+Index} & interface index, -\/1 means \char`\"{}any\char`\"{} interface. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
corresponding \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} or 0 if not found 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_a8c7d6e8831a6606311f0dd0eab0a3f56}{ns3\+::\+Ipv6\+L3\+Protocol}.

\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Get\+Routing\+Protocol@{Get\+Routing\+Protocol}}
\index{Get\+Routing\+Protocol@{Get\+Routing\+Protocol}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Get\+Routing\+Protocol(void) const =0}{GetRoutingProtocol(void) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Ptr}$<${\bf Ipv6\+Routing\+Protocol}$>$ ns3\+::\+Ipv6\+::\+Get\+Routing\+Protocol (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_af14dc67ff4c251776e5d0fca16c5cc7c}{}\label{classns3_1_1Ipv6_af14dc67ff4c251776e5d0fca16c5cc7c}


Get the routing protocol to be used by this I\+Pv6 stack. 

\begin{DoxyReturn}{Returns}
smart pointer to \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} object, or null pointer if none 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_aea90446045bb78b99b150ef1dd9afdb4}{ns3\+::\+Ipv6\+L3\+Protocol}.

\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Ipv6\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv6_a286c4af336a746ceb5cfd655da1a42dd}{}\label{classns3_1_1Ipv6_a286c4af336a746ceb5cfd655da1a42dd}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
35 \{
36   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::Ipv6"})
37     .SetParent<\hyperlink{classns3_1_1Object_a40860402e64d8008fb42329df7097cdb}{Object}> ()
38     .SetGroupName (\textcolor{stringliteral}{"Internet"})
39     .AddAttribute (\textcolor{stringliteral}{"IpForward"}, \textcolor{stringliteral}{"Globally enable or disable IP forwarding for all current and future IPv6
       devices."},
40                    BooleanValue (\textcolor{keyword}{false}),
41                    MakeBooleanAccessor (&\hyperlink{classns3_1_1Ipv6_a173e9acf3a03e1d333ca3be56a6c4f38}{Ipv6::SetIpForward},
42                                         &\hyperlink{classns3_1_1Ipv6_a26466999fd77426c00a4afd8b9a1ba32}{Ipv6::GetIpForward}),
43                    MakeBooleanChecker ())
44     .AddAttribute (\textcolor{stringliteral}{"MtuDiscover"}, \textcolor{stringliteral}{"If disabled, every interface will have its MTU set to 1280 bytes."},
45                    BooleanValue (\textcolor{keyword}{true}),
46                    MakeBooleanAccessor (&\hyperlink{classns3_1_1Ipv6_a3204b23a92a2495b428bd882a988369a}{Ipv6::SetMtuDiscover},
47                                         &\hyperlink{classns3_1_1Ipv6_a0de538c1b10148675d4d49efa32258f9}{Ipv6::GetMtuDiscover}),
48                    MakeBooleanChecker ())
49   ;
50   \textcolor{keywordflow}{return} tid;
51 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7


\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Insert@{Insert}}
\index{Insert@{Insert}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Insert(\+Ptr$<$ Ip\+L4\+Protocol $>$ protocol)=0}{Insert(Ptr< IpL4Protocol > protocol)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv6\+::\+Insert (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ip\+L4\+Protocol} $>$}]{protocol}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_af696a13faee7772aa155e6b06a752220}{}\label{classns3_1_1Ipv6_af696a13faee7772aa155e6b06a752220}


Add a L4 protocol. 


\begin{DoxyParams}{Parameters}
{\em protocol} & L4 protocol \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_afcdf13ca065622b8cb4691f2d3e92002}{ns3\+::\+Ipv6\+L3\+Protocol}.

\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Insert@{Insert}}
\index{Insert@{Insert}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Insert(\+Ptr$<$ Ip\+L4\+Protocol $>$ protocol, uint32\+\_\+t interface\+Index)=0}{Insert(Ptr< IpL4Protocol > protocol, uint32_t interfaceIndex)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv6\+::\+Insert (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ip\+L4\+Protocol} $>$}]{protocol, }
\item[{uint32\+\_\+t}]{interface\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_abac82ab5421240d8011131f0f49a080b}{}\label{classns3_1_1Ipv6_abac82ab5421240d8011131f0f49a080b}


Add a L4 protocol to a specific interface. 

This may be called multiple times for multiple interfaces for the same protocol. To insert for all interfaces, use the separate Insert (Ptr$<$\+Ip\+L4\+Protocol$>$ protocol) method.

Setting a protocol on a specific interface will overwrite the previously bound protocol.


\begin{DoxyParams}{Parameters}
{\em protocol} & L4 protocol. \\
\hline
{\em interface\+Index} & interface index. \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_a8b7f000d9d6d897dff787bfddab34872}{ns3\+::\+Ipv6\+L3\+Protocol}.

\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Is\+Forwarding@{Is\+Forwarding}}
\index{Is\+Forwarding@{Is\+Forwarding}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Is\+Forwarding(uint32\+\_\+t interface) const =0}{IsForwarding(uint32_t interface) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool ns3\+::\+Ipv6\+::\+Is\+Forwarding (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_a7240bf60410f8398d072641c6460339f}{}\label{classns3_1_1Ipv6_a7240bf60410f8398d072641c6460339f}


If the specified I\+Pv6 interface has forwarding enabled. 


\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of I\+Pv6 interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if I\+Pv6 forwarding enabled for input datagrams on this device 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_adae9c781382073a1db0429a4f156dee2}{ns3\+::\+Ipv6\+L3\+Protocol}.

\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Is\+Up@{Is\+Up}}
\index{Is\+Up@{Is\+Up}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Is\+Up(uint32\+\_\+t interface) const =0}{IsUp(uint32_t interface) const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool ns3\+::\+Ipv6\+::\+Is\+Up (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_a4aad08a05734df75ca70bff43188068f}{}\label{classns3_1_1Ipv6_a4aad08a05734df75ca70bff43188068f}


If the specified interface index is in \char`\"{}up\char`\"{} state. 


\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of I\+Pv6 interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the underlying interface is in the \char`\"{}up\char`\"{} state, false otherwise. 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_a34fb6e5caedebf7c257bb4fa7c125a3c}{ns3\+::\+Ipv6\+L3\+Protocol}.

\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Register\+Extensions@{Register\+Extensions}}
\index{Register\+Extensions@{Register\+Extensions}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Register\+Extensions()=0}{RegisterExtensions()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv6\+::\+Register\+Extensions (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_a57bd0dd1c4b1b9bb63b748124a548fe5}{}\label{classns3_1_1Ipv6_a57bd0dd1c4b1b9bb63b748124a548fe5}


Register the I\+Pv6 Extensions. 



Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_a25cb7eac8f79c3461ec50b8464db2f8f}{ns3\+::\+Ipv6\+L3\+Protocol}.

\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Register\+Options@{Register\+Options}}
\index{Register\+Options@{Register\+Options}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Register\+Options()=0}{RegisterOptions()=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv6\+::\+Register\+Options (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_a95905b14fff6edf0c4de70f47f6312cb}{}\label{classns3_1_1Ipv6_a95905b14fff6edf0c4de70f47f6312cb}


Register the I\+Pv6 Options. 



Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_ac9c52b73b294e0b592a5034b87278d92}{ns3\+::\+Ipv6\+L3\+Protocol}.

\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Remove@{Remove}}
\index{Remove@{Remove}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Remove(\+Ptr$<$ Ip\+L4\+Protocol $>$ protocol)=0}{Remove(Ptr< IpL4Protocol > protocol)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv6\+::\+Remove (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ip\+L4\+Protocol} $>$}]{protocol}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_abb09312c165a45923cd88061a3be2c82}{}\label{classns3_1_1Ipv6_abb09312c165a45923cd88061a3be2c82}


Remove a L4 protocol. 


\begin{DoxyParams}{Parameters}
{\em protocol} & L4 protocol to remove. \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_a70024f0b3f0cca53815ddf98eb49176a}{ns3\+::\+Ipv6\+L3\+Protocol}.

\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Remove@{Remove}}
\index{Remove@{Remove}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Remove(\+Ptr$<$ Ip\+L4\+Protocol $>$ protocol, uint32\+\_\+t interface\+Index)=0}{Remove(Ptr< IpL4Protocol > protocol, uint32_t interfaceIndex)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv6\+::\+Remove (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ip\+L4\+Protocol} $>$}]{protocol, }
\item[{uint32\+\_\+t}]{interface\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_ac8f460ea4a38988cbc80b91a14e45912}{}\label{classns3_1_1Ipv6_ac8f460ea4a38988cbc80b91a14e45912}


Remove a L4 protocol from a specific interface. 


\begin{DoxyParams}{Parameters}
{\em protocol} & L4 protocol to remove. \\
\hline
{\em interface\+Index} & interface index. \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_a2119b6e87a951156aec7a93199bf2b19}{ns3\+::\+Ipv6\+L3\+Protocol}.

\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Remove\+Address@{Remove\+Address}}
\index{Remove\+Address@{Remove\+Address}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Remove\+Address(uint32\+\_\+t interface, uint32\+\_\+t address\+Index)=0}{RemoveAddress(uint32_t interface, uint32_t addressIndex)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool ns3\+::\+Ipv6\+::\+Remove\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{uint32\+\_\+t}]{address\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_ad1e1c4d33ad96a76683ce8cea9d01780}{}\label{classns3_1_1Ipv6_ad1e1c4d33ad96a76683ce8cea9d01780}


Remove an address on specified I\+Pv6 interface. 

Remove the address at address\+Index on named interface. The address\+Index for all higher indices will decrement by one after this method is called; so, for example, to remove 5 addresses from an interface i, one could call Remove\+Address (i, 0); 5 times.


\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of an I\+Pv6 interface \\
\hline
{\em address\+Index} & index of \hyperlink{classns3_1_1Ipv6InterfaceAddress}{Ipv6\+Interface\+Address} to remove \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the operation succeeded 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_a6e955b0de62f2c28fea71108e8df2545}{ns3\+::\+Ipv6\+L3\+Protocol}.

\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Remove\+Address@{Remove\+Address}}
\index{Remove\+Address@{Remove\+Address}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Remove\+Address(uint32\+\_\+t interface, Ipv6\+Address address)=0}{RemoveAddress(uint32_t interface, Ipv6Address address)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool ns3\+::\+Ipv6\+::\+Remove\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv6\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_a29f451acbf047880073add4d0bd40550}{}\label{classns3_1_1Ipv6_a29f451acbf047880073add4d0bd40550}


Remove the given address on named \hyperlink{classns3_1_1Ipv6}{Ipv6} interface. 


\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of an I\+Pv6 interface \\
\hline
{\em address} & the address to remove \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the operation succeeded 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_a7e3a0ee9e79a09f208285e4f788ad4ed}{ns3\+::\+Ipv6\+L3\+Protocol}.

\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Send@{Send}}
\index{Send@{Send}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Send(\+Ptr$<$ Packet $>$ packet, Ipv6\+Address source, Ipv6\+Address destination, uint8\+\_\+t protocol, Ptr$<$ Ipv6\+Route $>$ route)=0}{Send(Ptr< Packet > packet, Ipv6Address source, Ipv6Address destination, uint8_t protocol, Ptr< Ipv6Route > route)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv6\+::\+Send (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Ipv6\+Address}}]{source, }
\item[{{\bf Ipv6\+Address}}]{destination, }
\item[{uint8\+\_\+t}]{protocol, }
\item[{{\bf Ptr}$<$ {\bf Ipv6\+Route} $>$}]{route}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_a2aad308983b20eb54334bb0d3db31004}{}\label{classns3_1_1Ipv6_a2aad308983b20eb54334bb0d3db31004}


Higher-\/level layers call this method to send a packet down the stack to the M\+AC and P\+HY layers. 


\begin{DoxyParams}{Parameters}
{\em packet} & packet to send \\
\hline
{\em source} & source address of packet \\
\hline
{\em destination} & address of packet \\
\hline
{\em protocol} & number of packet \\
\hline
{\em route} & route to take \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_ac281dd6c5aff55330904e7a298c1881b}{ns3\+::\+Ipv6\+L3\+Protocol}.



Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Set\+Down@{Set\+Down}}
\index{Set\+Down@{Set\+Down}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Set\+Down(uint32\+\_\+t interface)=0}{SetDown(uint32_t interface)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv6\+::\+Set\+Down (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_ada8ade0638959d7acf65682580c43ee6}{}\label{classns3_1_1Ipv6_ada8ade0638959d7acf65682580c43ee6}


Set the interface into the \char`\"{}down\char`\"{} state. 

In this state, it is ignored during I\+Pv6 forwarding. 
\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of I\+Pv6 interface \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_aac61d62990fdfa91000cffe7fd918062}{ns3\+::\+Ipv6\+L3\+Protocol}.

\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Set\+Forwarding@{Set\+Forwarding}}
\index{Set\+Forwarding@{Set\+Forwarding}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Set\+Forwarding(uint32\+\_\+t interface, bool val)=0}{SetForwarding(uint32_t interface, bool val)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv6\+::\+Set\+Forwarding (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{bool}]{val}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_a8f7c711267860c54bf3a645b24bf2eef}{}\label{classns3_1_1Ipv6_a8f7c711267860c54bf3a645b24bf2eef}


Set forwarding on specified I\+Pv6 interface. 


\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of I\+Pv6 interface \\
\hline
{\em val} & Value to set the forwarding flag\\
\hline
\end{DoxyParams}
If set to true, I\+Pv6 forwarding is enabled for input datagrams on this device 

Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_a1a8bef4362f31f4f2b32ea6e7051467a}{ns3\+::\+Ipv6\+L3\+Protocol}.

\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Set\+Ip\+Forward@{Set\+Ip\+Forward}}
\index{Set\+Ip\+Forward@{Set\+Ip\+Forward}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Set\+Ip\+Forward(bool forward)=0}{SetIpForward(bool forward)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv6\+::\+Set\+Ip\+Forward (
\begin{DoxyParamCaption}
\item[{bool}]{forward}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_a173e9acf3a03e1d333ca3be56a6c4f38}{}\label{classns3_1_1Ipv6_a173e9acf3a03e1d333ca3be56a6c4f38}


Set I\+Pv6 forwarding state. 


\begin{DoxyParams}{Parameters}
{\em forward} & I\+Pv6 forwarding enabled or not \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_af305cd631f4f5b4acaf75f3d4243c08b}{ns3\+::\+Ipv6\+L3\+Protocol}.



Here is the caller graph for this function\+:
% FIG 9


\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Set\+Metric@{Set\+Metric}}
\index{Set\+Metric@{Set\+Metric}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Set\+Metric(uint32\+\_\+t interface, uint16\+\_\+t metric)=0}{SetMetric(uint32_t interface, uint16_t metric)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv6\+::\+Set\+Metric (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{uint16\+\_\+t}]{metric}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_ab8dfd51c931ebc11c107bff673bae827}{}\label{classns3_1_1Ipv6_ab8dfd51c931ebc11c107bff673bae827}


Set metric on specified \hyperlink{classns3_1_1Ipv6}{Ipv6} interface. 


\begin{DoxyParams}{Parameters}
{\em interface} & The interface number of an I\+Pv6 interface \\
\hline
{\em metric} & routing metric (cost) associated to the underlying I\+Pv6 interface \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_a5d0a141d4b667d8f39f903b9d3fbeffd}{ns3\+::\+Ipv6\+L3\+Protocol}.



Here is the caller graph for this function\+:
% FIG 10


\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Set\+Mtu\+Discover@{Set\+Mtu\+Discover}}
\index{Set\+Mtu\+Discover@{Set\+Mtu\+Discover}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Set\+Mtu\+Discover(bool mtu\+Discover)=0}{SetMtuDiscover(bool mtuDiscover)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv6\+::\+Set\+Mtu\+Discover (
\begin{DoxyParamCaption}
\item[{bool}]{mtu\+Discover}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_a3204b23a92a2495b428bd882a988369a}{}\label{classns3_1_1Ipv6_a3204b23a92a2495b428bd882a988369a}


Set I\+Pv6 M\+TU discover state. 


\begin{DoxyParams}{Parameters}
{\em mtu\+Discover} & I\+Pv6 M\+TU discover enabled or not \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_a9954be60f9cfc8b7570a18eb0b8b92f9}{ns3\+::\+Ipv6\+L3\+Protocol}.



Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Set\+Pmtu@{Set\+Pmtu}}
\index{Set\+Pmtu@{Set\+Pmtu}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Set\+Pmtu(\+Ipv6\+Address dst, uint32\+\_\+t pmtu)=0}{SetPmtu(Ipv6Address dst, uint32_t pmtu)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv6\+::\+Set\+Pmtu (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{dst, }
\item[{uint32\+\_\+t}]{pmtu}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_a2f791bd08927bcbbba2694813cb52710}{}\label{classns3_1_1Ipv6_a2f791bd08927bcbbba2694813cb52710}


Set the Path M\+TU for the specified I\+Pv6 destination address. 


\begin{DoxyParams}{Parameters}
{\em dst} & \hyperlink{classns3_1_1Ipv6}{Ipv6} destination address \\
\hline
{\em pmtu} & the Path M\+TU \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_ab99ee90351fb7bbe9d2582376c3597ae}{ns3\+::\+Ipv6\+L3\+Protocol}.

\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Set\+Routing\+Protocol@{Set\+Routing\+Protocol}}
\index{Set\+Routing\+Protocol@{Set\+Routing\+Protocol}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Set\+Routing\+Protocol(\+Ptr$<$ Ipv6\+Routing\+Protocol $>$ routing\+Protocol)=0}{SetRoutingProtocol(Ptr< Ipv6RoutingProtocol > routingProtocol)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv6\+::\+Set\+Routing\+Protocol (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv6\+Routing\+Protocol} $>$}]{routing\+Protocol}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_aa889d2174527a1df773d65974de83f8f}{}\label{classns3_1_1Ipv6_aa889d2174527a1df773d65974de83f8f}


Register a new routing protocol to be used by this I\+Pv6 stack. 

This call will replace any routing protocol that has been previously registered. If you want to add multiple routing protocols, you must add them to a Ipv6\+List\+Routing\+Protocol directly.


\begin{DoxyParams}{Parameters}
{\em routing\+Protocol} & smart pointer to \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} object \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_a9f65728e13ee4a2fb5588d3601e7634f}{ns3\+::\+Ipv6\+L3\+Protocol}.

\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Set\+Up@{Set\+Up}}
\index{Set\+Up@{Set\+Up}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Set\+Up(uint32\+\_\+t interface)=0}{SetUp(uint32_t interface)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void ns3\+::\+Ipv6\+::\+Set\+Up (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_a8e61d85ec7fd342ed38fef2d040ed1b9}{}\label{classns3_1_1Ipv6_a8e61d85ec7fd342ed38fef2d040ed1b9}


Set the interface into the \char`\"{}up\char`\"{} state. 

In this state, it is considered valid during I\+Pv6 forwarding. 
\begin{DoxyParams}{Parameters}
{\em interface} & Interface number of I\+Pv6 interface \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_a834eba3100efc8f71e5292bbfdcde6e6}{ns3\+::\+Ipv6\+L3\+Protocol}.



Here is the caller graph for this function\+:
% FIG 12


\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!Source\+Address\+Selection@{Source\+Address\+Selection}}
\index{Source\+Address\+Selection@{Source\+Address\+Selection}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{Source\+Address\+Selection(uint32\+\_\+t interface, Ipv6\+Address dest)=0}{SourceAddressSelection(uint32_t interface, Ipv6Address dest)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Ipv6\+Address} ns3\+::\+Ipv6\+::\+Source\+Address\+Selection (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv6\+Address}}]{dest}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classns3_1_1Ipv6_a07bfb23e4bee98b2a2bfb56c16908cd4}{}\label{classns3_1_1Ipv6_a07bfb23e4bee98b2a2bfb56c16908cd4}


Choose the source address to use with destination address. 


\begin{DoxyParams}{Parameters}
{\em interface} & interface index \\
\hline
{\em dest} & I\+Pv6 destination address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
I\+Pv6 source address to use 
\end{DoxyReturn}


Implemented in \hyperlink{classns3_1_1Ipv6L3Protocol_a77acb50e395f36951381977368ebc5cb}{ns3\+::\+Ipv6\+L3\+Protocol}.



\subsection{Member Data Documentation}
\index{ns3\+::\+Ipv6@{ns3\+::\+Ipv6}!I\+F\+\_\+\+A\+NY@{I\+F\+\_\+\+A\+NY}}
\index{I\+F\+\_\+\+A\+NY@{I\+F\+\_\+\+A\+NY}!ns3\+::\+Ipv6@{ns3\+::\+Ipv6}}
\subsubsection[{\texorpdfstring{I\+F\+\_\+\+A\+NY}{IF_ANY}}]{\setlength{\rightskip}{0pt plus 5cm}const uint32\+\_\+t ns3\+::\+Ipv6\+::\+I\+F\+\_\+\+A\+NY = 0xffffffff\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv6_a1e55b17e6e1a4e1b439778543458bbe3}{}\label{classns3_1_1Ipv6_a1e55b17e6e1a4e1b439778543458bbe3}


Any interface magic number. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/model/\hyperlink{ipv6_8h}{ipv6.\+h}\item 
internet/model/\hyperlink{ipv6_8cc}{ipv6.\+cc}\end{DoxyCompactItemize}
