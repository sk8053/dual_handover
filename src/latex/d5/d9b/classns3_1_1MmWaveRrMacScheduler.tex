\hypertarget{classns3_1_1MmWaveRrMacScheduler}{}\section{ns3\+:\+:Mm\+Wave\+Rr\+Mac\+Scheduler Class Reference}
\label{classns3_1_1MmWaveRrMacScheduler}\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}


{\ttfamily \#include $<$mmwave-\/rr-\/mac-\/scheduler.\+h$>$}



Inheritance diagram for ns3\+:\+:Mm\+Wave\+Rr\+Mac\+Scheduler\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Mm\+Wave\+Rr\+Mac\+Scheduler\+:
% FIG 1
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef std\+::vector$<$ uint8\+\_\+t $>$ \hyperlink{classns3_1_1MmWaveRrMacScheduler_a4edf77bbe56479bae12f56826a43b134}{Dl\+Harq\+Processes\+Status\+\_\+t}
\item 
typedef std\+::vector$<$ uint8\+\_\+t $>$ \hyperlink{classns3_1_1MmWaveRrMacScheduler_a750009728f27d7ea202009e12cf7f6de}{Dl\+Harq\+Processes\+Timer\+\_\+t}
\item 
typedef std\+::vector$<$ \hyperlink{structns3_1_1TbInfoElement}{Tb\+Info\+Element} $>$ \hyperlink{classns3_1_1MmWaveRrMacScheduler_a0ca6ed6e2801f50786257fc6ef19a907}{Dl\+Harq\+Processes\+Tb\+Info\+List\+\_\+t}
\item 
typedef std\+::vector$<$ std\+::vector$<$ struct \hyperlink{structns3_1_1RlcPduInfo}{Rlc\+Pdu\+Info} $>$ $>$ \hyperlink{classns3_1_1MmWaveRrMacScheduler_a1cd0bc1339970dc27da4f599233b911c}{Dl\+Harq\+Rlc\+Pdu\+List\+\_\+t}
\item 
typedef std\+::vector$<$ \hyperlink{structns3_1_1TbInfoElement}{Tb\+Info\+Element} $>$ \hyperlink{classns3_1_1MmWaveRrMacScheduler_a8be4bb7220253ad506048ff37620c7f1}{Ul\+Harq\+Processes\+Tb\+Info\+List\+\_\+t}
\item 
typedef std\+::vector$<$ uint8\+\_\+t $>$ \hyperlink{classns3_1_1MmWaveRrMacScheduler_aaa0e5dc99185dddba2e9617f3bc8b9bd}{Ul\+Harq\+Processes\+Status\+\_\+t}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1MmWaveRrMacScheduler_a383fa5909bb225783e5cb4ec0ef2f199}{Mm\+Wave\+Rr\+Mac\+Scheduler} ()
\item 
virtual \hyperlink{classns3_1_1MmWaveRrMacScheduler_a81765bb17010d15e780b39cb8dfaa728}{$\sim$\+Mm\+Wave\+Rr\+Mac\+Scheduler} ()
\item 
virtual void \hyperlink{classns3_1_1MmWaveRrMacScheduler_a3e4831ffdd2b9253f7f0bd334b66e0e3}{Do\+Dispose} (void)
\item 
virtual void \hyperlink{classns3_1_1MmWaveRrMacScheduler_a455ebd26767f800f77dc1c8005cd7d3c}{Set\+Mac\+Sched\+Sap\+User} (\hyperlink{classns3_1_1MmWaveMacSchedSapUser}{Mm\+Wave\+Mac\+Sched\+Sap\+User} $\ast$sap)
\item 
virtual \hyperlink{classns3_1_1MmWaveMacSchedSapProvider}{Mm\+Wave\+Mac\+Sched\+Sap\+Provider} $\ast$ \hyperlink{classns3_1_1MmWaveRrMacScheduler_a17add5325a0d6d1a249aa6fac8ec3cbc}{Get\+Mac\+Sched\+Sap\+Provider} ()
\item 
virtual void \hyperlink{classns3_1_1MmWaveRrMacScheduler_a848387e2d4605be3abb399cc10016b76}{Configure\+Common\+Parameters} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1MmWavePhyMacCommon}{Mm\+Wave\+Phy\+Mac\+Common} $>$ config)
\item 
void \hyperlink{classns3_1_1MmWaveRrMacScheduler_af3929899f775a5da4c2103ea20dc31a4}{Do\+Sched\+Dl\+Rlc\+Buffer\+Req} (const struct \hyperlink{structns3_1_1MmWaveMacSchedSapProvider_1_1SchedDlRlcBufferReqParameters}{Mm\+Wave\+Mac\+Sched\+Sap\+Provider\+::\+Sched\+Dl\+Rlc\+Buffer\+Req\+Parameters} \&params)
\item 
void \hyperlink{classns3_1_1MmWaveRrMacScheduler_a02891734f11dd8fd2feb98fdd2bcac94}{Do\+Sched\+Dl\+Cqi\+Info\+Req} (const \hyperlink{structns3_1_1MmWaveMacSchedSapProvider_1_1SchedDlCqiInfoReqParameters}{Mm\+Wave\+Mac\+Sched\+Sap\+Provider\+::\+Sched\+Dl\+Cqi\+Info\+Req\+Parameters} \&params)
\item 
void \hyperlink{classns3_1_1MmWaveRrMacScheduler_a7914f7ed4851eabd5b88838da3399971}{Do\+Sched\+Ul\+Cqi\+Info\+Req} (const struct \hyperlink{structns3_1_1MmWaveMacSchedSapProvider_1_1SchedUlCqiInfoReqParameters}{Mm\+Wave\+Mac\+Sched\+Sap\+Provider\+::\+Sched\+Ul\+Cqi\+Info\+Req\+Parameters} \&params)
\item 
void \hyperlink{classns3_1_1MmWaveRrMacScheduler_ab99149a6961ca02b605ce4c89c12e4c7}{Do\+Sched\+Ul\+Mac\+Ctrl\+Info\+Req} (const struct \hyperlink{structns3_1_1MmWaveMacSchedSapProvider_1_1SchedUlMacCtrlInfoReqParameters}{Mm\+Wave\+Mac\+Sched\+Sap\+Provider\+::\+Sched\+Ul\+Mac\+Ctrl\+Info\+Req\+Parameters} \&params)
\item 
void \hyperlink{classns3_1_1MmWaveRrMacScheduler_a7e934e11a18ac6fccd3eb11e41693523}{Refresh\+Dl\+Cqi\+Maps} (void)
\item 
void \hyperlink{classns3_1_1MmWaveRrMacScheduler_a08bd59d628f7a0115392e00c9cf44c59}{Refresh\+Ul\+Cqi\+Maps} (void)
\item 
void \hyperlink{classns3_1_1MmWaveRrMacScheduler_a005e51f10e6d477bf11d6993f081ed24}{Update\+Dl\+Rlc\+Buffer\+Info} (uint16\+\_\+t rnti, uint8\+\_\+t lcid, uint16\+\_\+t size)
\item 
void \hyperlink{classns3_1_1MmWaveRrMacScheduler_a57725a4bd9ba6cfe462d804a131c0255}{Update\+Ul\+Rlc\+Buffer\+Info} (uint16\+\_\+t rnti, uint16\+\_\+t size)
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1MmWaveRrMacScheduler_a9cc402ee93f6e866bfc290ad6bb3cc8d}{Get\+Type\+Id} (void)
\item 
static bool \hyperlink{classns3_1_1MmWaveRrMacScheduler_ae0fee4909466a1900ad3d92b6b6fe3e2}{Sort\+Rlc\+Buffer\+Req} (\hyperlink{structns3_1_1MmWaveMacSchedSapProvider_1_1SchedDlRlcBufferReqParameters}{Mm\+Wave\+Mac\+Sched\+Sap\+Provider\+::\+Sched\+Dl\+Rlc\+Buffer\+Req\+Parameters} \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, \hyperlink{structns3_1_1MmWaveMacSchedSapProvider_1_1SchedDlRlcBufferReqParameters}{Mm\+Wave\+Mac\+Sched\+Sap\+Provider\+::\+Sched\+Dl\+Rlc\+Buffer\+Req\+Parameters} j)
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
uint32\+\_\+t \hyperlink{classns3_1_1MmWaveRrMacScheduler_ad748b4ad6a90547493f1bfd4a95fa055}{Bsr\+Id2\+Buffer\+Size} (uint8\+\_\+t val)
\item 
uint8\+\_\+t \hyperlink{classns3_1_1MmWaveRrMacScheduler_a3186afb36a652a68908b932e2ceb2567}{Buffer\+Size2\+Bsr\+Id} (uint32\+\_\+t val)
\item 
uint8\+\_\+t \hyperlink{classns3_1_1MmWaveRrMacScheduler_a0c01cd018ece348fa17da5babacd3bae}{Update\+Dl\+Harq\+Process\+Id} (uint16\+\_\+t rnti)
\item 
uint8\+\_\+t \hyperlink{classns3_1_1MmWaveRrMacScheduler_addd7405298c9c95bf87ef2c32c3a477b}{Update\+Ul\+Harq\+Process\+Id} (uint16\+\_\+t rnti)
\item 
void \hyperlink{classns3_1_1MmWaveRrMacScheduler_a48f0e305c3d706ac557bcb877f6cd2d0}{Do\+Sched\+Trigger\+Req} (const struct \hyperlink{structns3_1_1MmWaveMacSchedSapProvider_1_1SchedTriggerReqParameters}{Mm\+Wave\+Mac\+Sched\+Sap\+Provider\+::\+Sched\+Trigger\+Req\+Parameters} \&params)
\item 
bool \hyperlink{classns3_1_1MmWaveRrMacScheduler_a17b839c05a05ce1ef83b9b806c943789}{Do\+Sched\+Dl\+Trigger\+Req} (const struct \hyperlink{structns3_1_1MmWaveMacSchedSapProvider_1_1SchedTriggerReqParameters}{Mm\+Wave\+Mac\+Sched\+Sap\+Provider\+::\+Sched\+Trigger\+Req\+Parameters} \&params, \hyperlink{structns3_1_1MmWaveMacSchedSapUser_1_1SchedConfigIndParameters}{Mm\+Wave\+Mac\+Sched\+Sap\+User\+::\+Sched\+Config\+Ind\+Parameters} \&ret, unsigned int frame\+Num, unsigned int sf\+Num, unsigned int islot)
\item 
bool \hyperlink{classns3_1_1MmWaveRrMacScheduler_a60261f8b46716986bd8d0ae245fab35a}{Do\+Sched\+Ul\+Trigger\+Req} (const struct \hyperlink{structns3_1_1MmWaveMacSchedSapProvider_1_1SchedTriggerReqParameters}{Mm\+Wave\+Mac\+Sched\+Sap\+Provider\+::\+Sched\+Trigger\+Req\+Parameters} \&params, \hyperlink{structns3_1_1MmWaveMacSchedSapUser_1_1SchedConfigIndParameters}{Mm\+Wave\+Mac\+Sched\+Sap\+User\+::\+Sched\+Config\+Ind\+Parameters} \&ret, unsigned int frame\+Num, unsigned int sf\+Num, unsigned int islot)
\item 
void \hyperlink{classns3_1_1MmWaveRrMacScheduler_a5b4fe59b80549148440a6e5f3e05f8e6}{Refresh\+Harq\+Processes} ()
\begin{DoxyCompactList}\small\item\em Refresh H\+A\+RQ processes according to the timers. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1MmWaveRrMacScheduler_ac0c71520f7ed311a0d99dfed182faf66}{Set\+T\+B\+Size\+Assigned} ()
\item 
\hyperlink{structns3_1_1SfAllocInfo}{Sf\+Alloc\+Info} \hyperlink{classns3_1_1MmWaveRrMacScheduler_aa81369a8badc00db9ad5259cadec7e82}{Schedule\+Users\+In\+Time} (uint32\+\_\+t slot\+Num)
\item 
void \hyperlink{classns3_1_1MmWaveRrMacScheduler_a3c009919ec557272944849b0da580c10}{Set\+Schedule\+Direction} (std\+::string patt)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{namespacens3_a74052c5410c5c8e0028017dbf985cd1f}{Tdd\+Slot\+Type\+List} \hyperlink{classns3_1_1MmWaveRrMacScheduler_adbd5d8631590dbbb160aa707757cd75c}{m\+\_\+tdd\+Map}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1MmWaveAmc}{Mm\+Wave\+Amc} $>$ \hyperlink{classns3_1_1MmWaveRrMacScheduler_abbcdddd7d8733f372963069e1d0395d3}{m\+\_\+amc}
\item 
\hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{structns3_1_1MmWaveMacSchedSapProvider_1_1SchedDlRlcBufferReqParameters}{Mm\+Wave\+Mac\+Sched\+Sap\+Provider\+::\+Sched\+Dl\+Rlc\+Buffer\+Req\+Parameters} $>$ \hyperlink{classns3_1_1MmWaveRrMacScheduler_a4808ca626b0b12682c3f1a079d016997}{m\+\_\+rlc\+Buffer\+Req}
\item 
std\+::map$<$ uint16\+\_\+t, uint8\+\_\+t $>$ \hyperlink{classns3_1_1MmWaveRrMacScheduler_ab048c846f6d5d71795b65b9f91c6766a}{m\+\_\+wb\+Cqi\+Rxed}
\item 
std\+::map$<$ uint16\+\_\+t, uint32\+\_\+t $>$ \hyperlink{classns3_1_1MmWaveRrMacScheduler_ae70383b2b2b66701ea96205d5ad60c41}{m\+\_\+wb\+Cqi\+Timers}
\item 
uint32\+\_\+t \hyperlink{classns3_1_1MmWaveRrMacScheduler_a21360d09f2e5e4b9fc304752aef8ae6a}{m\+\_\+cqi\+Timers\+Threshold}
\item 
std\+::map$<$ uint16\+\_\+t, std\+::vector$<$ double $>$ $>$ \hyperlink{classns3_1_1MmWaveRrMacScheduler_aeb890d54a9f369fe677a64efa78d2402}{m\+\_\+ue\+Ul\+Cqi}
\item 
std\+::map$<$ uint16\+\_\+t, uint32\+\_\+t $>$ \hyperlink{classns3_1_1MmWaveRrMacScheduler_a48957bee7e937b6d8627194fa429a473}{m\+\_\+ue\+Cqi\+Timers}
\item 
std\+::map$<$ uint16\+\_\+t, uint32\+\_\+t $>$ \hyperlink{classns3_1_1MmWaveRrMacScheduler_a2ebec374f1ff5014f115ff8b68ff5ebb}{m\+\_\+ce\+Bsr\+Rxed}
\item 
std\+::string \hyperlink{classns3_1_1MmWaveRrMacScheduler_ac4c00a9f08cd90ac861753f28c9d6a69}{m\+\_\+directions}
\item 
bool \hyperlink{classns3_1_1MmWaveRrMacScheduler_ac45c41dd1fc03ca53d6580cf1dfca939}{m\+\_\+is\+Dirn\+Updated}
\item 
uint64\+\_\+t \hyperlink{classns3_1_1MmWaveRrMacScheduler_a0de8f79fecf022efca5e65228d35cca6}{m\+\_\+next\+Rnti\+Dl}
\item 
uint64\+\_\+t \hyperlink{classns3_1_1MmWaveRrMacScheduler_ac9c27bbc2f828923b14cbc3b6ed5be57}{m\+\_\+next\+Rnti\+Ul}
\item 
uint32\+\_\+t \hyperlink{classns3_1_1MmWaveRrMacScheduler_a68cb1fd503ce4845a2d0d83c6466e58a}{m\+\_\+tdd\+Bitmap}
\item 
uint32\+\_\+t \hyperlink{classns3_1_1MmWaveRrMacScheduler_a5ec88f3d708e5ba3b2c4bfe478d458bc}{m\+\_\+subframe\+No}
\item 
uint32\+\_\+t \hyperlink{classns3_1_1MmWaveRrMacScheduler_af6f030cab6b897d4d116df8d5ed2973c}{m\+\_\+frame\+No}
\item 
uint8\+\_\+t \hyperlink{classns3_1_1MmWaveRrMacScheduler_a379f6c5cc3404d41c4082879498fc38b}{m\+\_\+tb\+Uid}
\item 
\hyperlink{classns3_1_1MmWaveMacSchedSapProvider}{Mm\+Wave\+Mac\+Sched\+Sap\+Provider} $\ast$ \hyperlink{classns3_1_1MmWaveRrMacScheduler_af7bd93ab339121af06c7594fb83654c4}{m\+\_\+mac\+Sched\+Sap\+Provider}
\item 
\hyperlink{classns3_1_1MmWaveMacSchedSapUser}{Mm\+Wave\+Mac\+Sched\+Sap\+User} $\ast$ \hyperlink{classns3_1_1MmWaveRrMacScheduler_a5f6adc4e7eabd10266ede796be0d1bca}{m\+\_\+mac\+Sched\+Sap\+User}
\item 
uint32\+\_\+t \hyperlink{classns3_1_1MmWaveRrMacScheduler_a400c28eae2329becd132ff0a462bfb3a}{m\+\_\+num\+Chunks}
\item 
std\+::map$<$ uint32\+\_\+t, std\+::vector$<$ uint16\+\_\+t $>$ $>$ \hyperlink{classns3_1_1MmWaveRrMacScheduler_aac1f8a8418e80a70a78e8fb710697588}{m\+\_\+allocation\+Maps}
\item 
bool \hyperlink{classns3_1_1MmWaveRrMacScheduler_ad8bb79b5853000b363b42a158633a942}{m\+\_\+harq\+On}
\item 
uint8\+\_\+t \hyperlink{classns3_1_1MmWaveRrMacScheduler_aa123b20bcc92d47a9590e40eeaa30806}{m\+\_\+num\+Harq\+Process}
\item 
uint8\+\_\+t \hyperlink{classns3_1_1MmWaveRrMacScheduler_a77ec3d7f7e1cf5c72faba03fea768930}{m\+\_\+harq\+Timeout}
\item 
std\+::map$<$ uint16\+\_\+t, uint8\+\_\+t $>$ \hyperlink{classns3_1_1MmWaveRrMacScheduler_a6ff50e3af4095ffc47155de7d30c8d6d}{m\+\_\+dl\+Harq\+Current\+Process\+Id}
\item 
std\+::map$<$ uint16\+\_\+t, \hyperlink{classns3_1_1MmWaveRrMacScheduler_a4edf77bbe56479bae12f56826a43b134}{Dl\+Harq\+Processes\+Status\+\_\+t} $>$ \hyperlink{classns3_1_1MmWaveRrMacScheduler_a5734289010d38bd8dfe04ed50ba99936}{m\+\_\+dl\+Harq\+Processes\+Status}
\item 
std\+::map$<$ uint16\+\_\+t, \hyperlink{classns3_1_1MmWaveRrMacScheduler_a750009728f27d7ea202009e12cf7f6de}{Dl\+Harq\+Processes\+Timer\+\_\+t} $>$ \hyperlink{classns3_1_1MmWaveRrMacScheduler_aa52dc4680386f8ccf85d6b9c685463d1}{m\+\_\+dl\+Harq\+Processes\+Timer}
\item 
std\+::map$<$ uint16\+\_\+t, \hyperlink{classns3_1_1MmWaveRrMacScheduler_a0ca6ed6e2801f50786257fc6ef19a907}{Dl\+Harq\+Processes\+Tb\+Info\+List\+\_\+t} $>$ \hyperlink{classns3_1_1MmWaveRrMacScheduler_a8d14c222701c0a57ecbd40a51d0391da}{m\+\_\+dl\+Harq\+Processes\+Tb\+Info\+Map}
\item 
std\+::map$<$ uint16\+\_\+t, \hyperlink{classns3_1_1MmWaveRrMacScheduler_a1cd0bc1339970dc27da4f599233b911c}{Dl\+Harq\+Rlc\+Pdu\+List\+\_\+t} $>$ \hyperlink{classns3_1_1MmWaveRrMacScheduler_a51e5c8d3c34be4e070f2fb3e621cd418}{m\+\_\+dl\+Harq\+Processes\+Rlc\+Pdu\+Map}
\item 
std\+::vector$<$ \hyperlink{structns3_1_1DlHarqInfo}{Dl\+Harq\+Info} $>$ \hyperlink{classns3_1_1MmWaveRrMacScheduler_a1b1043d7f9994e2ee6a7e1b368e9d7a1}{m\+\_\+dl\+Harq\+Info\+List}
\item 
std\+::map$<$ uint16\+\_\+t, uint8\+\_\+t $>$ \hyperlink{classns3_1_1MmWaveRrMacScheduler_a9d9d27b704770d34cb1ce158e9ed51ba}{m\+\_\+ul\+Harq\+Current\+Process\+Id}
\item 
std\+::map$<$ uint16\+\_\+t, \hyperlink{classns3_1_1MmWaveRrMacScheduler_aaa0e5dc99185dddba2e9617f3bc8b9bd}{Ul\+Harq\+Processes\+Status\+\_\+t} $>$ \hyperlink{classns3_1_1MmWaveRrMacScheduler_af963cfe7e5dc36fce45c16d60b506465}{m\+\_\+ul\+Harq\+Processes\+Status}
\item 
std\+::map$<$ uint16\+\_\+t, \hyperlink{classns3_1_1MmWaveRrMacScheduler_a8be4bb7220253ad506048ff37620c7f1}{Ul\+Harq\+Processes\+Tb\+Info\+List\+\_\+t} $>$ \hyperlink{classns3_1_1MmWaveRrMacScheduler_a3fb20c8b0644fdd05f5545ec0b685b10}{m\+\_\+ul\+Harq\+Processes\+Tb\+Info\+Map}
\item 
\hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{structns3_1_1SfAllocInfo}{Sf\+Alloc\+Info} $>$ \hyperlink{classns3_1_1MmWaveRrMacScheduler_a330485babfcd56bfbea128ebe3b66daa}{m\+\_\+ul\+Sf\+Alloc\+Info}
\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classns3_1_1MmWaveRrMacScheduler_a2753d5040bae8b11d6b7975e70a2c811}{Mm\+Wave\+Rr\+Mac\+Sched\+Sap\+Provider}
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Member Typedef Documentation}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Dl\+Harq\+Processes\+Status\+\_\+t@{Dl\+Harq\+Processes\+Status\+\_\+t}}
\index{Dl\+Harq\+Processes\+Status\+\_\+t@{Dl\+Harq\+Processes\+Status\+\_\+t}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Dl\+Harq\+Processes\+Status\+\_\+t}{DlHarqProcessesStatus_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::vector$<$ uint8\+\_\+t $>$ {\bf ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Dl\+Harq\+Processes\+Status\+\_\+t}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a4edf77bbe56479bae12f56826a43b134}{}\label{classns3_1_1MmWaveRrMacScheduler_a4edf77bbe56479bae12f56826a43b134}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Dl\+Harq\+Processes\+Tb\+Info\+List\+\_\+t@{Dl\+Harq\+Processes\+Tb\+Info\+List\+\_\+t}}
\index{Dl\+Harq\+Processes\+Tb\+Info\+List\+\_\+t@{Dl\+Harq\+Processes\+Tb\+Info\+List\+\_\+t}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Dl\+Harq\+Processes\+Tb\+Info\+List\+\_\+t}{DlHarqProcessesTbInfoList_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::vector$<$ {\bf Tb\+Info\+Element} $>$ {\bf ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Dl\+Harq\+Processes\+Tb\+Info\+List\+\_\+t}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a0ca6ed6e2801f50786257fc6ef19a907}{}\label{classns3_1_1MmWaveRrMacScheduler_a0ca6ed6e2801f50786257fc6ef19a907}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Dl\+Harq\+Processes\+Timer\+\_\+t@{Dl\+Harq\+Processes\+Timer\+\_\+t}}
\index{Dl\+Harq\+Processes\+Timer\+\_\+t@{Dl\+Harq\+Processes\+Timer\+\_\+t}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Dl\+Harq\+Processes\+Timer\+\_\+t}{DlHarqProcessesTimer_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::vector$<$ uint8\+\_\+t $>$ {\bf ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Dl\+Harq\+Processes\+Timer\+\_\+t}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a750009728f27d7ea202009e12cf7f6de}{}\label{classns3_1_1MmWaveRrMacScheduler_a750009728f27d7ea202009e12cf7f6de}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Dl\+Harq\+Rlc\+Pdu\+List\+\_\+t@{Dl\+Harq\+Rlc\+Pdu\+List\+\_\+t}}
\index{Dl\+Harq\+Rlc\+Pdu\+List\+\_\+t@{Dl\+Harq\+Rlc\+Pdu\+List\+\_\+t}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Dl\+Harq\+Rlc\+Pdu\+List\+\_\+t}{DlHarqRlcPduList_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::vector$<$ std\+::vector $<$struct {\bf Rlc\+Pdu\+Info}$>$ $>$ {\bf ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Dl\+Harq\+Rlc\+Pdu\+List\+\_\+t}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a1cd0bc1339970dc27da4f599233b911c}{}\label{classns3_1_1MmWaveRrMacScheduler_a1cd0bc1339970dc27da4f599233b911c}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Ul\+Harq\+Processes\+Status\+\_\+t@{Ul\+Harq\+Processes\+Status\+\_\+t}}
\index{Ul\+Harq\+Processes\+Status\+\_\+t@{Ul\+Harq\+Processes\+Status\+\_\+t}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Ul\+Harq\+Processes\+Status\+\_\+t}{UlHarqProcessesStatus_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::vector$<$ uint8\+\_\+t $>$ {\bf ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Ul\+Harq\+Processes\+Status\+\_\+t}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_aaa0e5dc99185dddba2e9617f3bc8b9bd}{}\label{classns3_1_1MmWaveRrMacScheduler_aaa0e5dc99185dddba2e9617f3bc8b9bd}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Ul\+Harq\+Processes\+Tb\+Info\+List\+\_\+t@{Ul\+Harq\+Processes\+Tb\+Info\+List\+\_\+t}}
\index{Ul\+Harq\+Processes\+Tb\+Info\+List\+\_\+t@{Ul\+Harq\+Processes\+Tb\+Info\+List\+\_\+t}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Ul\+Harq\+Processes\+Tb\+Info\+List\+\_\+t}{UlHarqProcessesTbInfoList_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::vector$<$ {\bf Tb\+Info\+Element} $>$ {\bf ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Ul\+Harq\+Processes\+Tb\+Info\+List\+\_\+t}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a8be4bb7220253ad506048ff37620c7f1}{}\label{classns3_1_1MmWaveRrMacScheduler_a8be4bb7220253ad506048ff37620c7f1}


\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Mm\+Wave\+Rr\+Mac\+Scheduler@{Mm\+Wave\+Rr\+Mac\+Scheduler}}
\index{Mm\+Wave\+Rr\+Mac\+Scheduler@{Mm\+Wave\+Rr\+Mac\+Scheduler}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Mm\+Wave\+Rr\+Mac\+Scheduler()}{MmWaveRrMacScheduler()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a383fa5909bb225783e5cb4ec0ef2f199}{}\label{classns3_1_1MmWaveRrMacScheduler_a383fa5909bb225783e5cb4ec0ef2f199}

\begin{DoxyCode}
103 : \hyperlink{classns3_1_1MmWaveRrMacScheduler_ac4c00a9f08cd90ac861753f28c9d6a69}{m\_directions} (\textcolor{stringliteral}{""}),
104   \hyperlink{classns3_1_1MmWaveRrMacScheduler_ac45c41dd1fc03ca53d6580cf1dfca939}{m\_isDirnUpdated} (\textcolor{keyword}{false}),
105   \hyperlink{classns3_1_1MmWaveRrMacScheduler_a0de8f79fecf022efca5e65228d35cca6}{m\_nextRntiDl} (0),
106   \hyperlink{classns3_1_1MmWaveRrMacScheduler_ac9c27bbc2f828923b14cbc3b6ed5be57}{m\_nextRntiUl} (0),
107   \hyperlink{classns3_1_1MmWaveRrMacScheduler_a5ec88f3d708e5ba3b2c4bfe478d458bc}{m\_subframeNo} (0),
108   \hyperlink{classns3_1_1MmWaveRrMacScheduler_a379f6c5cc3404d41c4082879498fc38b}{m\_tbUid} (0),
109   \hyperlink{classns3_1_1MmWaveRrMacScheduler_a5f6adc4e7eabd10266ede796be0d1bca}{m\_macSchedSapUser} (0)
110 \{
111         \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
112 
113         \hyperlink{classns3_1_1MmWaveRrMacScheduler_af7bd93ab339121af06c7594fb83654c4}{m\_macSchedSapProvider} = \textcolor{keyword}{new} 
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_a2753d5040bae8b11d6b7975e70a2c811}{MmWaveRrMacSchedSapProvider} (\textcolor{keyword}{this});
114 \}
\end{DoxyCode}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!````~Mm\+Wave\+Rr\+Mac\+Scheduler@{$\sim$\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\index{````~Mm\+Wave\+Rr\+Mac\+Scheduler@{$\sim$\+Mm\+Wave\+Rr\+Mac\+Scheduler}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{$\sim$\+Mm\+Wave\+Rr\+Mac\+Scheduler()}{~MmWaveRrMacScheduler()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::$\sim$\+Mm\+Wave\+Rr\+Mac\+Scheduler (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a81765bb17010d15e780b39cb8dfaa728}{}\label{classns3_1_1MmWaveRrMacScheduler_a81765bb17010d15e780b39cb8dfaa728}

\begin{DoxyCode}
117 \{
118         \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
119 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Bsr\+Id2\+Buffer\+Size@{Bsr\+Id2\+Buffer\+Size}}
\index{Bsr\+Id2\+Buffer\+Size@{Bsr\+Id2\+Buffer\+Size}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Bsr\+Id2\+Buffer\+Size(uint8\+\_\+t val)}{BsrId2BufferSize(uint8_t val)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Bsr\+Id2\+Buffer\+Size (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{val}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_ad748b4ad6a90547493f1bfd4a95fa055}{}\label{classns3_1_1MmWaveRrMacScheduler_ad748b4ad6a90547493f1bfd4a95fa055}

\begin{DoxyCode}
89         \{
90           \hyperlink{group__fatal_ga0bd3f62c55e7347ff814572f3aaa3864}{NS\_ABORT\_MSG\_UNLESS} (val < 64, \textcolor{stringliteral}{"val = "} << val << \textcolor{stringliteral}{" is out of range"});
91           \textcolor{keywordflow}{return} \hyperlink{namespacens3_a693da1bbfe2b27cb7ebe207d565a67a8}{BufferSizeLevelBsrTable}[val];
92         \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 2


\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Buffer\+Size2\+Bsr\+Id@{Buffer\+Size2\+Bsr\+Id}}
\index{Buffer\+Size2\+Bsr\+Id@{Buffer\+Size2\+Bsr\+Id}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Buffer\+Size2\+Bsr\+Id(uint32\+\_\+t val)}{BufferSize2BsrId(uint32_t val)}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Buffer\+Size2\+Bsr\+Id (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{val}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a3186afb36a652a68908b932e2ceb2567}{}\label{classns3_1_1MmWaveRrMacScheduler_a3186afb36a652a68908b932e2ceb2567}

\begin{DoxyCode}
96         \{
97           \textcolor{keywordtype}{int} index = 0;
98           \textcolor{keywordflow}{if} (\hyperlink{namespacens3_a693da1bbfe2b27cb7ebe207d565a67a8}{BufferSizeLevelBsrTable}[63] < val)
99             \{
100               index = 63;
101             \}
102           \textcolor{keywordflow}{else}
103             \{
104               \textcolor{keywordflow}{while} (\hyperlink{namespacens3_a693da1bbfe2b27cb7ebe207d565a67a8}{BufferSizeLevelBsrTable}[index] < val)
105                 \{
106                   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (index < 64);
107                   index++;
108                 \}
109             \}
110 
111           \textcolor{keywordflow}{return} (index);
112         \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Configure\+Common\+Parameters@{Configure\+Common\+Parameters}}
\index{Configure\+Common\+Parameters@{Configure\+Common\+Parameters}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Configure\+Common\+Parameters(\+Ptr$<$ Mm\+Wave\+Phy\+Mac\+Common $>$ config)}{ConfigureCommonParameters(Ptr< MmWavePhyMacCommon > config)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Configure\+Common\+Parameters (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Mm\+Wave\+Phy\+Mac\+Common} $>$}]{config}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a848387e2d4605be3abb399cc10016b76}{}\label{classns3_1_1MmWaveRrMacScheduler_a848387e2d4605be3abb399cc10016b76}


Implements \hyperlink{classns3_1_1MmWaveMacScheduler_a90f58ca507cb0ca6b68bf38e55cd73ac}{ns3\+::\+Mm\+Wave\+Mac\+Scheduler}.


\begin{DoxyCode}
173 \{
174         \hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig} = config;
175         \hyperlink{classns3_1_1MmWaveRrMacScheduler_abbcdddd7d8733f372963069e1d0395d3}{m\_amc} = CreateObject <MmWaveAmc> (\hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig});
176         \hyperlink{classns3_1_1MmWaveMacScheduler_a2009724b6771c34c55825772f644c9c8}{m\_numRbg} = \hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->\hyperlink{classns3_1_1MmWavePhyMacCommon_a4c5f323fd722d6eec52efda5d76f97ad}{GetNumRb} () / 
      \hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->\hyperlink{classns3_1_1MmWavePhyMacCommon_a765574aedfb4a53b9be7de93ccb306e6}{GetNumRbPerRbg} ();
177         \hyperlink{classns3_1_1MmWaveRrMacScheduler_aa123b20bcc92d47a9590e40eeaa30806}{m\_numHarqProcess} = \hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->
      \hyperlink{classns3_1_1MmWavePhyMacCommon_a40773d84172ebeb5aff125f56ebcc5ac}{GetNumHarqProcess} ();
178         \hyperlink{classns3_1_1MmWaveRrMacScheduler_a77ec3d7f7e1cf5c72faba03fea768930}{m\_harqTimeout} = \hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->
      \hyperlink{classns3_1_1MmWavePhyMacCommon_a6a3b10cda74091e0579e24e3b4dbad80}{GetHarqTimeout} ();
179 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4


\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Do\+Dispose(void)}{DoDispose(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a3e4831ffdd2b9253f7f0bd334b66e0e3}{}\label{classns3_1_1MmWaveRrMacScheduler_a3e4831ffdd2b9253f7f0bd334b66e0e3}
Destructor implementation.

This method is called by \hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose()} or by the \hyperlink{classns3_1_1Object}{Object}\textquotesingle{}s destructor, whichever comes first.

Subclasses are expected to implement their real destruction code in an overriden version of this method and chain up to their parent\textquotesingle{}s implementation once they are done. {\itshape i.\+e}, for simplicity, the destructor of every subclass should be empty and its content should be moved to the associated \hyperlink{classns3_1_1MmWaveRrMacScheduler_a3e4831ffdd2b9253f7f0bd334b66e0e3}{Do\+Dispose()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1MmWaveMacScheduler_a2ddcc9f234db5b831b81cfa653047640}{ns3\+::\+Mm\+Wave\+Mac\+Scheduler}.


\begin{DoxyCode}
123 \{
124         \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
125         \hyperlink{classns3_1_1MmWaveRrMacScheduler_ab048c846f6d5d71795b65b9f91c6766a}{m\_wbCqiRxed}.clear();
126   \hyperlink{classns3_1_1MmWaveRrMacScheduler_a8d14c222701c0a57ecbd40a51d0391da}{m\_dlHarqProcessesTbInfoMap}.clear ();
127   \hyperlink{classns3_1_1MmWaveRrMacScheduler_aa52dc4680386f8ccf85d6b9c685463d1}{m\_dlHarqProcessesTimer}.clear ();
128   \hyperlink{classns3_1_1MmWaveRrMacScheduler_a51e5c8d3c34be4e070f2fb3e621cd418}{m\_dlHarqProcessesRlcPduMap}.clear ();
129   \hyperlink{classns3_1_1MmWaveRrMacScheduler_a1b1043d7f9994e2ee6a7e1b368e9d7a1}{m\_dlHarqInfoList}.clear ();
130   \hyperlink{classns3_1_1MmWaveRrMacScheduler_a9d9d27b704770d34cb1ce158e9ed51ba}{m\_ulHarqCurrentProcessId}.clear ();
131   \hyperlink{classns3_1_1MmWaveRrMacScheduler_af963cfe7e5dc36fce45c16d60b506465}{m\_ulHarqProcessesStatus}.clear ();
132   \hyperlink{classns3_1_1MmWaveRrMacScheduler_a3fb20c8b0644fdd05f5545ec0b685b10}{m\_ulHarqProcessesTbInfoMap}.clear ();
133 \textcolor{comment}{//  delete m\_cschedSapProvider;}
134   \textcolor{keyword}{delete} \hyperlink{classns3_1_1MmWaveRrMacScheduler_af7bd93ab339121af06c7594fb83654c4}{m\_macSchedSapProvider};
135         \hyperlink{classns3_1_1MmWaveRrMacScheduler_ac4c00a9f08cd90ac861753f28c9d6a69}{m\_directions}.clear ();
136 \}
\end{DoxyCode}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Do\+Sched\+Dl\+Cqi\+Info\+Req@{Do\+Sched\+Dl\+Cqi\+Info\+Req}}
\index{Do\+Sched\+Dl\+Cqi\+Info\+Req@{Do\+Sched\+Dl\+Cqi\+Info\+Req}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Do\+Sched\+Dl\+Cqi\+Info\+Req(const Mm\+Wave\+Mac\+Sched\+Sap\+Provider\+::\+Sched\+Dl\+Cqi\+Info\+Req\+Parameters \&params)}{DoSchedDlCqiInfoReq(const MmWaveMacSchedSapProvider::SchedDlCqiInfoReqParameters &params)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Do\+Sched\+Dl\+Cqi\+Info\+Req (
\begin{DoxyParamCaption}
\item[{const {\bf Mm\+Wave\+Mac\+Sched\+Sap\+Provider\+::\+Sched\+Dl\+Cqi\+Info\+Req\+Parameters} \&}]{params}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a02891734f11dd8fd2feb98fdd2bcac94}{}\label{classns3_1_1MmWaveRrMacScheduler_a02891734f11dd8fd2feb98fdd2bcac94}

\begin{DoxyCode}
241 \{
242   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
243 
244   std::map <uint16\_t,uint8\_t>::iterator it;
245   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < params.m\_cqiList.size (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
246     \{
247       \textcolor{keywordflow}{if} ( params.m\_cqiList.at (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}).m\_cqiType == \hyperlink{structns3_1_1DlCqiInfo_a58a9fff4b49e4a8df1fdea1005c4735caa1097f844b06ac6dbdbac42802ba2403}{DlCqiInfo::WB} )
248         \{
249           \textcolor{comment}{// wideband CQI reporting}
250           std::map <uint16\_t,uint8\_t>::iterator it;
251           uint16\_t rnti = params.m\_cqiList.at (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}).m\_rnti;
252           it = \hyperlink{classns3_1_1MmWaveRrMacScheduler_ab048c846f6d5d71795b65b9f91c6766a}{m\_wbCqiRxed}.find (rnti);
253           \textcolor{keywordflow}{if} (it == \hyperlink{classns3_1_1MmWaveRrMacScheduler_ab048c846f6d5d71795b65b9f91c6766a}{m\_wbCqiRxed}.end ())
254             \{
255               \textcolor{comment}{// create the new entry}
256               \hyperlink{classns3_1_1MmWaveRrMacScheduler_ab048c846f6d5d71795b65b9f91c6766a}{m\_wbCqiRxed}.insert ( std::pair<uint16\_t, uint8\_t > (rnti, params.m\_cqiList.at (
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}).m\_wbCqi) ); \textcolor{comment}{// only codeword 0 at this stage (SISO)}
257               \textcolor{comment}{// generate correspondent timer}
258               \hyperlink{classns3_1_1MmWaveRrMacScheduler_ae70383b2b2b66701ea96205d5ad60c41}{m\_wbCqiTimers}.insert ( std::pair<uint16\_t, uint32\_t > (rnti, 
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_a21360d09f2e5e4b9fc304752aef8ae6a}{m\_cqiTimersThreshold}));
259             \}
260           \textcolor{keywordflow}{else}
261             \{
262               \textcolor{comment}{// update the CQI value}
263               (*it).second = params.m\_cqiList.at (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}).m\_wbCqi;
264               \textcolor{comment}{// update correspondent timer}
265               std::map <uint16\_t,uint32\_t>::iterator itTimers;
266               itTimers = \hyperlink{classns3_1_1MmWaveRrMacScheduler_ae70383b2b2b66701ea96205d5ad60c41}{m\_wbCqiTimers}.find (rnti);
267               (*itTimers).second = \hyperlink{classns3_1_1MmWaveRrMacScheduler_a21360d09f2e5e4b9fc304752aef8ae6a}{m\_cqiTimersThreshold};
268             \}
269         \}
270       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( params.m\_cqiList.at (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}).m\_cqiType == \hyperlink{structns3_1_1DlCqiInfo_a58a9fff4b49e4a8df1fdea1005c4735ca034739d53a545902d795f3b2b6c8564c}{DlCqiInfo::SB} )
271         \{
272           \textcolor{comment}{// subband CQI reporting high layer configured}
273           \textcolor{comment}{// Not used by RR Scheduler}
274         \}
275       \textcolor{keywordflow}{else}
276         \{
277           \hyperlink{group__logging_ga0261a8db1d4ac5f79417d117634fd455}{NS\_LOG\_ERROR} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" CQI type unknown"});
278         \}
279     \}
280 
281   \textcolor{keywordflow}{return};
282 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Do\+Sched\+Dl\+Rlc\+Buffer\+Req@{Do\+Sched\+Dl\+Rlc\+Buffer\+Req}}
\index{Do\+Sched\+Dl\+Rlc\+Buffer\+Req@{Do\+Sched\+Dl\+Rlc\+Buffer\+Req}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Do\+Sched\+Dl\+Rlc\+Buffer\+Req(const struct Mm\+Wave\+Mac\+Sched\+Sap\+Provider\+::\+Sched\+Dl\+Rlc\+Buffer\+Req\+Parameters \&params)}{DoSchedDlRlcBufferReq(const struct MmWaveMacSchedSapProvider::SchedDlRlcBufferReqParameters &params)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Do\+Sched\+Dl\+Rlc\+Buffer\+Req (
\begin{DoxyParamCaption}
\item[{const struct {\bf Mm\+Wave\+Mac\+Sched\+Sap\+Provider\+::\+Sched\+Dl\+Rlc\+Buffer\+Req\+Parameters} \&}]{params}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1MmWaveRrMacScheduler_af3929899f775a5da4c2103ea20dc31a4}{}\label{classns3_1_1MmWaveRrMacScheduler_af3929899f775a5da4c2103ea20dc31a4}

\begin{DoxyCode}
183 \{
184   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << params.m\_rnti << (uint32\_t) params.m\_logicalChannelIdentity);
185   \textcolor{comment}{// API generated by RLC for updating RLC parameters on a LC (tx and retx queues)}
186   std::list<MmWaveMacSchedSapProvider::SchedDlRlcBufferReqParameters>::iterator it = 
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_a4808ca626b0b12682c3f1a079d016997}{m\_rlcBufferReq}.begin ();
187   \textcolor{keywordtype}{bool} newLc = \textcolor{keyword}{true};
188   \textcolor{keywordflow}{while} (it != \hyperlink{classns3_1_1MmWaveRrMacScheduler_a4808ca626b0b12682c3f1a079d016997}{m\_rlcBufferReq}.end ())
189     \{
190       \textcolor{comment}{// remove old entries of this UE-LC}
191       \textcolor{keywordflow}{if} (((*it).m\_rnti == params.m\_rnti)&&((*it).m\_logicalChannelIdentity == params.
      m\_logicalChannelIdentity))
192         \{
193           it = \hyperlink{classns3_1_1MmWaveRrMacScheduler_a4808ca626b0b12682c3f1a079d016997}{m\_rlcBufferReq}.erase (it);
194           newLc = \textcolor{keyword}{false};
195         \}
196       \textcolor{keywordflow}{else}
197         \{
198           ++it;
199         \}
200     \}
201   \textcolor{comment}{// add the new parameters}
202   \hyperlink{classns3_1_1MmWaveRrMacScheduler_a4808ca626b0b12682c3f1a079d016997}{m\_rlcBufferReq}.insert (it, params);
203   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" RNTI "} << params.m\_rnti << \textcolor{stringliteral}{" LC "} << (uint16\_t)params.
      m\_logicalChannelIdentity << \textcolor{stringliteral}{" RLC tx size "} << params.m\_rlcTransmissionQueueHolDelay << \textcolor{stringliteral}{" RLC retx size "} << params.
      m\_rlcRetransmissionQueueSize << \textcolor{stringliteral}{" RLC stat size "} <<  params.m\_rlcStatusPduSize);
204   \textcolor{comment}{// initialize statistics of the flow in case of new flows}
205   \textcolor{keywordflow}{if} (newLc == \textcolor{keyword}{true})
206   \{
207         \hyperlink{classns3_1_1MmWaveRrMacScheduler_ab048c846f6d5d71795b65b9f91c6766a}{m\_wbCqiRxed}.insert ( std::pair<uint16\_t, uint8\_t > (params.m\_rnti, 1)); \textcolor{comment}{// only codeword
       0 at this stage (SISO)}
208         \textcolor{comment}{// initialized to 1 (i.e., the lowest value for transmitting a signal)}
209         \hyperlink{classns3_1_1MmWaveRrMacScheduler_ae70383b2b2b66701ea96205d5ad60c41}{m\_wbCqiTimers}.insert ( std::pair<uint16\_t, uint32\_t > (params.m\_rnti, 
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_a21360d09f2e5e4b9fc304752aef8ae6a}{m\_cqiTimersThreshold}));
210   \}
211 
212   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1MmWaveRrMacScheduler_a6ff50e3af4095ffc47155de7d30c8d6d}{m\_dlHarqCurrentProcessId}.find (params.m\_rnti) == 
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_a6ff50e3af4095ffc47155de7d30c8d6d}{m\_dlHarqCurrentProcessId}.end ())
213   \{
214         \textcolor{comment}{// TODO: Add Csched SAP (currently no csched sap methods, so put this code here for now - RDF)}
215         \hyperlink{classns3_1_1MmWaveRrMacScheduler_a6ff50e3af4095ffc47155de7d30c8d6d}{m\_dlHarqCurrentProcessId}.insert (std::pair <uint16\_t,uint8\_t > (params.
      m\_rnti, 0));
216         \hyperlink{classns3_1_1MmWaveRrMacScheduler_a4edf77bbe56479bae12f56826a43b134}{DlHarqProcessesStatus\_t} dlHarqPrcStatus;
217         dlHarqPrcStatus.resize (\hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->\hyperlink{classns3_1_1MmWavePhyMacCommon_a40773d84172ebeb5aff125f56ebcc5ac}{GetNumHarqProcess} (), 0);
218         \hyperlink{classns3_1_1MmWaveRrMacScheduler_a5734289010d38bd8dfe04ed50ba99936}{m\_dlHarqProcessesStatus}.insert (std::pair <uint16\_t,
       DlHarqProcessesStatus\_t> (params.m\_rnti, dlHarqPrcStatus));
219         \hyperlink{classns3_1_1MmWaveRrMacScheduler_a750009728f27d7ea202009e12cf7f6de}{DlHarqProcessesTimer\_t} dlHarqProcessesTimer;
220         dlHarqProcessesTimer.resize (\hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->
      \hyperlink{classns3_1_1MmWavePhyMacCommon_a40773d84172ebeb5aff125f56ebcc5ac}{GetNumHarqProcess} (),0);
221         \hyperlink{classns3_1_1MmWaveRrMacScheduler_aa52dc4680386f8ccf85d6b9c685463d1}{m\_dlHarqProcessesTimer}.insert (std::pair <uint16\_t, DlHarqProcessesTimer\_t> (
      params.m\_rnti, dlHarqProcessesTimer));
222         \hyperlink{classns3_1_1MmWaveRrMacScheduler_a0ca6ed6e2801f50786257fc6ef19a907}{DlHarqProcessesTbInfoList\_t} dlHarqTbInfoList;
223         dlHarqTbInfoList.resize (\hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->\hyperlink{classns3_1_1MmWavePhyMacCommon_a40773d84172ebeb5aff125f56ebcc5ac}{GetNumHarqProcess} ());
224         \hyperlink{classns3_1_1MmWaveRrMacScheduler_a8d14c222701c0a57ecbd40a51d0391da}{m\_dlHarqProcessesTbInfoMap}.insert (std::pair <uint16\_t,
       DlHarqProcessesTbInfoList\_t> (params.m\_rnti, dlHarqTbInfoList));
225         \hyperlink{classns3_1_1MmWaveRrMacScheduler_a1cd0bc1339970dc27da4f599233b911c}{DlHarqRlcPduList\_t} dlHarqRlcPduList;
226         dlHarqRlcPduList.resize (\hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->\hyperlink{classns3_1_1MmWavePhyMacCommon_a40773d84172ebeb5aff125f56ebcc5ac}{GetNumHarqProcess} ());
227         \hyperlink{classns3_1_1MmWaveRrMacScheduler_a51e5c8d3c34be4e070f2fb3e621cd418}{m\_dlHarqProcessesRlcPduMap}.insert (std::pair <uint16\_t,
       DlHarqRlcPduList\_t> (params.m\_rnti, dlHarqRlcPduList));
228         \hyperlink{classns3_1_1MmWaveRrMacScheduler_a9d9d27b704770d34cb1ce158e9ed51ba}{m\_ulHarqCurrentProcessId}.insert (std::pair <uint16\_t,uint8\_t > (params.
      m\_rnti, 0));
229         \hyperlink{classns3_1_1MmWaveRrMacScheduler_aaa0e5dc99185dddba2e9617f3bc8b9bd}{UlHarqProcessesStatus\_t} ulHarqPrcStatus;
230         ulHarqPrcStatus.resize (\hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->\hyperlink{classns3_1_1MmWavePhyMacCommon_a40773d84172ebeb5aff125f56ebcc5ac}{GetNumHarqProcess} (), 0);
231         \hyperlink{classns3_1_1MmWaveRrMacScheduler_af963cfe7e5dc36fce45c16d60b506465}{m\_ulHarqProcessesStatus}.insert (std::pair <uint16\_t,
       UlHarqProcessesStatus\_t> (params.m\_rnti, ulHarqPrcStatus));
232         \hyperlink{classns3_1_1MmWaveRrMacScheduler_a8be4bb7220253ad506048ff37620c7f1}{UlHarqProcessesTbInfoList\_t} ulHarqTbInfoList;
233         ulHarqTbInfoList.resize (\hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->\hyperlink{classns3_1_1MmWavePhyMacCommon_a40773d84172ebeb5aff125f56ebcc5ac}{GetNumHarqProcess} ());
234         \hyperlink{classns3_1_1MmWaveRrMacScheduler_a3fb20c8b0644fdd05f5545ec0b685b10}{m\_ulHarqProcessesTbInfoMap}.insert (std::pair <uint16\_t,
       UlHarqProcessesTbInfoList\_t> (params.m\_rnti, ulHarqTbInfoList));
235   \}
236   \textcolor{keywordflow}{return};
237 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6




Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Do\+Sched\+Dl\+Trigger\+Req@{Do\+Sched\+Dl\+Trigger\+Req}}
\index{Do\+Sched\+Dl\+Trigger\+Req@{Do\+Sched\+Dl\+Trigger\+Req}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Do\+Sched\+Dl\+Trigger\+Req(const struct Mm\+Wave\+Mac\+Sched\+Sap\+Provider\+::\+Sched\+Trigger\+Req\+Parameters \&params, Mm\+Wave\+Mac\+Sched\+Sap\+User\+::\+Sched\+Config\+Ind\+Parameters \&ret, unsigned int frame\+Num, unsigned int sf\+Num, unsigned int islot)}{DoSchedDlTriggerReq(const struct MmWaveMacSchedSapProvider::SchedTriggerReqParameters &params, MmWaveMacSchedSapUser::SchedConfigIndParameters &ret, unsigned int frameNum, unsigned int sfNum, unsigned int islot)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Do\+Sched\+Dl\+Trigger\+Req (
\begin{DoxyParamCaption}
\item[{const struct {\bf Mm\+Wave\+Mac\+Sched\+Sap\+Provider\+::\+Sched\+Trigger\+Req\+Parameters} \&}]{params, }
\item[{{\bf Mm\+Wave\+Mac\+Sched\+Sap\+User\+::\+Sched\+Config\+Ind\+Parameters} \&}]{ret, }
\item[{unsigned int}]{frame\+Num, }
\item[{unsigned int}]{sf\+Num, }
\item[{unsigned int}]{islot}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a17b839c05a05ce1ef83b9b806c943789}{}\label{classns3_1_1MmWaveRrMacScheduler_a17b839c05a05ce1ef83b9b806c943789}

\begin{DoxyCode}
511 \{
512         \textcolor{keywordtype}{bool} success = \textcolor{keyword}{false}; \textcolor{comment}{// was able to allocate at least 1 UE}
513         \textcolor{comment}{// Create RBG map (DL res alloc type 0)}
514         std::vector <bool> rbgMap;
515         uint16\_t rbgAllocatedNum = 0;
516         std::set <uint16\_t> rntiAllocated;
517         rbgMap.resize (\hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->\hyperlink{classns3_1_1MmWavePhyMacCommon_a4c5f323fd722d6eec52efda5d76f97ad}{GetNumRb} (), \textcolor{keyword}{false});
518 
519         std::map<uint16\_t,SchedInfo>& schedInfoMap = ret.m\_schedInfoMap;
520 
521         \textcolor{comment}{// ****************** this section for HARQ retx ******************}
522 
523         \textcolor{comment}{//   update UL HARQ proc id}
524 \textcolor{comment}{//      std::map <uint16\_t, uint8\_t>::iterator itProcId;}
525 \textcolor{comment}{//      for (itProcId = m\_ulHarqCurrentProcessId.begin (); itProcId != m\_ulHarqCurrentProcessId.end ();
       itProcId++)}
526 \textcolor{comment}{//      \{}
527 \textcolor{comment}{//              (*itProcId).second = ((*itProcId).second + 1) % m\_phyMacConfig->GetNumHarqProcess ();}
528 \textcolor{comment}{//      \}}
529 
530         \textcolor{comment}{// Process DL HARQ feedback}
531         \hyperlink{classns3_1_1MmWaveRrMacScheduler_a5b4fe59b80549148440a6e5f3e05f8e6}{RefreshHarqProcesses} ();
532         \textcolor{comment}{// retrieve past HARQ retx buffered}
533         \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1MmWaveRrMacScheduler_a1b1043d7f9994e2ee6a7e1b368e9d7a1}{m\_dlHarqInfoList}.size () > 0)
534         \{
535                 \textcolor{keywordflow}{if} (params.m\_dlHarqInfoList.size () > 0)
536                 \{
537                         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" Received DL-HARQ feedback"});
538                         \hyperlink{classns3_1_1MmWaveRrMacScheduler_a1b1043d7f9994e2ee6a7e1b368e9d7a1}{m\_dlHarqInfoList}.insert (
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_a1b1043d7f9994e2ee6a7e1b368e9d7a1}{m\_dlHarqInfoList}.end (), params.m\_dlHarqInfoList.begin (), params.m\_dlHarqInfoList.end ());
539                 \}
540         \}
541         \textcolor{keywordflow}{else}
542         \{
543                 \textcolor{keywordflow}{if} (params.m\_dlHarqInfoList.size () > 0)
544                 \{
545                         \hyperlink{classns3_1_1MmWaveRrMacScheduler_a1b1043d7f9994e2ee6a7e1b368e9d7a1}{m\_dlHarqInfoList} = params.m\_dlHarqInfoList;
546                 \}
547         \}
548         \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1MmWaveRrMacScheduler_ad8bb79b5853000b363b42a158633a942}{m\_harqOn} == \textcolor{keyword}{false})
549         \{
550                 \textcolor{comment}{// Ignore HARQ feedback}
551                 \hyperlink{classns3_1_1MmWaveRrMacScheduler_a1b1043d7f9994e2ee6a7e1b368e9d7a1}{m\_dlHarqInfoList}.clear ();
552         \}
553         \textcolor{keywordflow}{else}
554         \{
555                 std::vector <struct DlHarqInfo> dlInfoListUntxed;
556                 \textcolor{keywordflow}{for} (uint16\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1MmWaveRrMacScheduler_a1b1043d7f9994e2ee6a7e1b368e9d7a1}{m\_dlHarqInfoList}.size (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
557                 \{
558                         std::set <uint16\_t>::iterator itRnti = rntiAllocated.find (
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_a1b1043d7f9994e2ee6a7e1b368e9d7a1}{m\_dlHarqInfoList}.at (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}).m\_rnti);
559                         \textcolor{keywordflow}{if} (itRnti != rntiAllocated.end ())
560                         \{
561                                 \textcolor{comment}{// RNTI already allocated for retx}
562                                 \textcolor{keywordflow}{continue};
563                         \}
564                         \textcolor{comment}{//              uint8\_t nLayers = m\_dlHarqInfoList.at (i).m\_harqStatus.size ();}
565                         \textcolor{comment}{//                              std::vector <bool> retx;}
566                         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" Processing DLHARQ feedback"});
567                         \textcolor{comment}{//                              if (nLayers == 1)}
568                         \textcolor{comment}{//                                \{}
569                         \textcolor{comment}{//                                  retx.push\_back (m\_dlHarqInfoList.at
       (i).m\_harqStatus.at (0) == DlInfoListElement\_s::NACK);}
570                         \textcolor{comment}{//                                  retx.push\_back (false);}
571                         \textcolor{comment}{//                                \}}
572                         \textcolor{comment}{//                              else}
573                         \textcolor{comment}{//                                \{}
574                         \textcolor{comment}{//                                  retx.push\_back (m\_dlHarqInfoList.at
       (i).m\_harqStatus.at (0) == DlInfoListElement\_s::NACK);}
575                         \textcolor{comment}{//                                  retx.push\_back (m\_dlHarqInfoList.at
       (i).m\_harqStatus.at (1) == DlInfoListElement\_s::NACK);}
576                         \textcolor{comment}{//                                \}}
577                         \textcolor{comment}{//                              if (retx.at (0) || retx.at (1))}
578                         \textcolor{keywordflow}{if}(\hyperlink{classns3_1_1MmWaveRrMacScheduler_a1b1043d7f9994e2ee6a7e1b368e9d7a1}{m\_dlHarqInfoList}.at (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}).m\_harqStatus.at (0) == 
      \hyperlink{structns3_1_1DlHarqInfo_a922d2bc13ae01f93cde1a8b4bfccad14ae0560b883a5e22a4d4c40ac562e80374}{DlHarqInfo::NACK})
579                         \{
580                                 \textcolor{comment}{// retrieve HARQ process information}
581                                 uint16\_t rnti = \hyperlink{classns3_1_1MmWaveRrMacScheduler_a1b1043d7f9994e2ee6a7e1b368e9d7a1}{m\_dlHarqInfoList}.at (
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}).m\_rnti;
582                                 uint8\_t harqId = \hyperlink{classns3_1_1MmWaveRrMacScheduler_a1b1043d7f9994e2ee6a7e1b368e9d7a1}{m\_dlHarqInfoList}.at (
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}).m\_harqProcessId;
583                                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" HARQ retx RNTI "} << rnti << \textcolor{stringliteral}{" harqId "} <<
       (uint16\_t)harqId);
584                                 std::map <uint16\_t, DlHarqProcessesTbInfoList\_t>::iterator itHarq = 
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_a8d14c222701c0a57ecbd40a51d0391da}{m\_dlHarqProcessesTbInfoMap}.find (rnti);
585                                 \textcolor{keywordflow}{if} (itHarq == \hyperlink{classns3_1_1MmWaveRrMacScheduler_a8d14c222701c0a57ecbd40a51d0391da}{m\_dlHarqProcessesTbInfoMap}.end ())
586                                 \{
587                                         \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"No info find in HARQ buffer for UE "}
       << rnti);
588                                 \}
589 
590                                 TbInfoElement harqTbInfo = (*itHarq).second.at (harqId);
591                                 \textcolor{comment}{//                      if (dci.m\_rv.size () == 1)}
592                                 \textcolor{comment}{//                      \{}
593                                 \textcolor{comment}{//                              rv = dci.m\_rv.at (0);}
594                                 \textcolor{comment}{//                      \}}
595                                 \textcolor{comment}{//                      else}
596                                 \textcolor{comment}{//                      \{}
597                                 \textcolor{comment}{//                              rv = (dci.m\_rv.at (0) > dci.m\_rv.at (1) ?
       dci.m\_rv.at (0) : dci.m\_rv.at (1));}
598                                 \textcolor{comment}{//                      \}}
599 
600                                 \textcolor{keywordflow}{if} (harqTbInfo.m\_rv == 3)
601                                 \{
602                                         \textcolor{comment}{// maximum number of retx reached -> drop process}
603                                         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Max number of retransmissions reached ->
       drop process"});
604                                         std::map <uint16\_t, DlHarqProcessesStatus\_t>::iterator it = 
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_a5734289010d38bd8dfe04ed50ba99936}{m\_dlHarqProcessesStatus}.find (rnti);
605                                         \textcolor{keywordflow}{if} (it == \hyperlink{classns3_1_1MmWaveRrMacScheduler_a5734289010d38bd8dfe04ed50ba99936}{m\_dlHarqProcessesStatus}.end ())
606                                         \{
607                                                 \hyperlink{group__logging_ga0261a8db1d4ac5f79417d117634fd455}{NS\_LOG\_ERROR} (\textcolor{stringliteral}{"No info find in HARQ buffer for
       UE (might change eNB) "} << \hyperlink{classns3_1_1MmWaveRrMacScheduler_a1b1043d7f9994e2ee6a7e1b368e9d7a1}{m\_dlHarqInfoList}.at (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}).m\_rnti);
608                                         \}
609                                         (*it).second.at (harqId) = 0;
610                                         std::map <uint16\_t, DlHarqRlcPduList\_t>::iterator itRlcPdu =  
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_a51e5c8d3c34be4e070f2fb3e621cd418}{m\_dlHarqProcessesRlcPduMap}.find (rnti);
611                                         \textcolor{keywordflow}{if} (itRlcPdu == 
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_a51e5c8d3c34be4e070f2fb3e621cd418}{m\_dlHarqProcessesRlcPduMap}.end ())
612                                         \{
613                                                 \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Unable to find RlcPdcList in
       HARQ buffer for RNTI "} << \hyperlink{classns3_1_1MmWaveRrMacScheduler_a1b1043d7f9994e2ee6a7e1b368e9d7a1}{m\_dlHarqInfoList}.at (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}).m\_rnti);
614                                         \}
615                                         \textcolor{keywordflow}{for} (uint16\_t k = 0; k < (*itRlcPdu).second.size (); k++)
616                                         \{
617                                                 (*itRlcPdu).second.at (harqId).clear ();
618                                         \}
619                                         \textcolor{keywordflow}{continue};
620                                 \}
621                                 \textcolor{comment}{// check the feasibility of retransmitting on the same RBGs}
622                                 \textcolor{comment}{// translate the DCI to Spectrum framework}
623                                 std::vector <int> dciRbg;
624                                 uint32\_t mask = 0x1;
625                                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Original RBGs "} << harqTbInfo.m\_rbBitmap << \textcolor{stringliteral}{" rnti
       "} << rnti);
626                                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j = 0; j < \hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->
      \hyperlink{classns3_1_1MmWavePhyMacCommon_a4c5f323fd722d6eec52efda5d76f97ad}{GetNumRb} (); j++)
627                                 \{
628                                         \textcolor{keywordflow}{if} (((harqTbInfo.m\_rbBitmap & mask) >> j) == 1)
629                                         \{
630                                                 dciRbg.push\_back (j);
631                                                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)t"} << j);
632                                         \}
633                                         mask = (mask << 1);
634                                 \}
635                                 \textcolor{keywordtype}{bool} free = \textcolor{keyword}{true};
636                                 \textcolor{keywordflow}{for} (uint8\_t j = 0; j < dciRbg.size (); j++)
637                                 \{
638                                         \textcolor{keywordflow}{if} (rbgMap.at (dciRbg.at (j)) == \textcolor{keyword}{true})
639                                         \{
640                                                 free = \textcolor{keyword}{false};
641                                                 \textcolor{keywordflow}{break};
642                                         \}
643                                 \}
644                                 \textcolor{keywordflow}{if} (free)
645                                 \{
646                                         \textcolor{comment}{// use the same RBGs for the retx}
647                                         \textcolor{comment}{// reserve RBGs}
648                                         \textcolor{keywordflow}{for} (uint8\_t j = 0; j < dciRbg.size (); j++)
649                                         \{
650                                                 rbgMap.at (dciRbg.at (j)) = \textcolor{keyword}{true};
651                                                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"RBG "} << dciRbg.at (j) << \textcolor{stringliteral}{"
       assigned"});
652                                                 rbgAllocatedNum++;
653                                         \}
654 
655                                         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" Send retx in the same RBGs"});
656                                 \}
657                                 \textcolor{keywordflow}{else}
658                                 \{
659                                         \textcolor{comment}{// find RBGs for sending HARQ retx}
660                                         uint8\_t j = 0;
661                                         uint8\_t rbgId = (dciRbg.at (dciRbg.size () - 1) + 1) % 
      \hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->\hyperlink{classns3_1_1MmWavePhyMacCommon_a4c5f323fd722d6eec52efda5d76f97ad}{GetNumRb} ();
662                                         uint8\_t startRbg = dciRbg.at (dciRbg.size () - 1);
663                                         std::vector <bool> rbgMapCopy = rbgMap;
664                                         \textcolor{keywordflow}{while} ((j < dciRbg.size ())&&(startRbg != rbgId))
665                                         \{
666                                                 \textcolor{keywordflow}{if} (rbgMapCopy.at (rbgId) == \textcolor{keyword}{false})
667                                                 \{
668                                                         rbgMapCopy.at (rbgId) = \textcolor{keyword}{true};
669                                                         dciRbg.at (j) = rbgId;
670                                                         j++;
671                                                 \}
672                                                 rbgId = (rbgId + 1) % 
      \hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->\hyperlink{classns3_1_1MmWavePhyMacCommon_a4c5f323fd722d6eec52efda5d76f97ad}{GetNumRb} ();
673                                         \}
674                                         \textcolor{keywordflow}{if} (j == dciRbg.size ())
675                                         \{
676                                                 \textcolor{comment}{// find new RBGs -> update DCI map}
677                                                 uint32\_t rbgMask = 0;
678                                                 \textcolor{keywordflow}{for} (uint16\_t k = 0; k < dciRbg.size (); k++)
679                                                 \{
680                                                         rbgMask = rbgMask + (0x1 << dciRbg.at (k));
681                                                         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" New allocated RBG
       "} << dciRbg.at (k));
682                                                         rbgAllocatedNum++;
683                                                 \}
684                                                 harqTbInfo.m\_rbBitmap = rbgMask;
685                                                 rbgMap = rbgMapCopy;
686                                         \}
687                                         \textcolor{keywordflow}{else}
688                                         \{
689                                                 \textcolor{comment}{// HARQ retx cannot be performed on this TTI -> store it}
690                                                 dlInfoListUntxed.push\_back (
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_a1b1043d7f9994e2ee6a7e1b368e9d7a1}{m\_dlHarqInfoList}.at (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}));
691                                                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" No resource for this retx
       -> buffer it"});
692                                         \}
693                                 \}
694                                 \textcolor{comment}{// retrieve RLC PDU list for retx TBsize and update DCI}
695                                 \textcolor{comment}{//                      BuildDataListElement\_s newEl;}
696                                 std::map<uint16\_t, SchedInfo>::iterator schedIt = schedInfoMap.find (rnti);
697                                 \textcolor{keywordflow}{if} (schedIt == schedInfoMap.end ())
698                                 \{
699                                         SchedInfo newSchedInfo (\hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->
      \hyperlink{classns3_1_1MmWavePhyMacCommon_a7b6552d2e0ffbeaf3bc2f9db6d0d6e63}{GetSlotsPerSubframe} ());
700                                         newSchedInfo.m\_rnti = rnti;
701                                         DciInfoElement newDci;
702                                         newDci.m\_rnti = rnti;
703                                         newDci.m\_tddBitmap = 0;
704                                         newDci.m\_format = 0;
705                                         newDci.m\_cceIndex = 0;
706                                         \textcolor{comment}{//                              newDci.m\_harqProcess =
       UpdateHarqProcessId ((*it).m\_rnti);}
707                                         newSchedInfo.m\_dci = newDci;
708                                         newSchedInfo.m\_frameNum = frameNum;
709                                         newSchedInfo.m\_sfNum = sfNum;
710                                         schedIt = (schedInfoMap.insert (std::pair<uint16\_t,SchedInfo> (rnti
      , newSchedInfo))).first;
711                                 \}
712                                 SchedInfo& schedInfo = schedIt->second;
713                                 harqTbInfo.m\_ndi = 0;
714                                 harqTbInfo.m\_slotIdx = slotNum;
715                                 harqTbInfo.m\_rv++;
716                                 (*itHarq).second.at (harqId).m\_rv++;
717                                 \textcolor{comment}{//schedInfo.m\_rlcPduList.push\_back(std::vector<RlcPduInfo> ());  // vector
       to store RLC PDUs for new TB}
718                                 std::map<uint8\_t, std::vector<RlcPduInfo> >::iterator rlcPduMapIt = 
      schedInfo.m\_rlcPduMap.insert (std::pair<uint8\_t, std::vector<RlcPduInfo> > (harqId, std::vector<RlcPduInfo>() )).
      first;
719                                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \textcolor{stringliteral}{"HARQ ReTx RV "} << (uint16\_t)harqTbInfo.
      m\_rv);
720 
721 
722                                 \textcolor{comment}{/*                      for (uint8\_t j = 0; j < nLayers; j++)}
723 \textcolor{comment}{                        \{}
724 \textcolor{comment}{                                if (retx.at (j))}
725 \textcolor{comment}{                                \{}
726 \textcolor{comment}{                                        if (j >= dci.m\_ndi.size ())}
727 \textcolor{comment}{                                        \{}
728 \textcolor{comment}{                                                // for avoiding errors in MIMO transient phases}
729 \textcolor{comment}{                                                dci.m\_ndi.push\_back (0);}
730 \textcolor{comment}{                                                dci.m\_rv.push\_back (0);}
731 \textcolor{comment}{                                                dci.m\_mcs.push\_back (0);}
732 \textcolor{comment}{                                                dci.m\_tbsSize.push\_back (0);}
733 \textcolor{comment}{                                                NS\_LOG\_INFO (this << " layer " << (uint16\_t)j << " no txed
       (MIMO transition)");}
734 \textcolor{comment}{}
735 \textcolor{comment}{                                        \}}
736 \textcolor{comment}{                                        else}
737 \textcolor{comment}{                                        \{}
738 \textcolor{comment}{                                                dci.m\_ndi.at (j) = 0;}
739 \textcolor{comment}{                                                dci.m\_rv.at (j)++;}
740 \textcolor{comment}{                                                (*itHarq).second.at (harqId).m\_rv.at (j)++;}
741 \textcolor{comment}{                                                NS\_LOG\_INFO (this << " layer " << (uint16\_t)j << " RV " <<
       (uint16\_t)dci.m\_rv.at (j));}
742 \textcolor{comment}{                                        \}}
743 \textcolor{comment}{                                \}}
744 \textcolor{comment}{                                else}
745 \textcolor{comment}{                                \{}
746 \textcolor{comment}{                                        // empty TB of layer j}
747 \textcolor{comment}{                                        dci.m\_ndi.at (j) = 0;}
748 \textcolor{comment}{                                        dci.m\_rv.at (j) = 0;}
749 \textcolor{comment}{                                        dci.m\_mcs.at (j) = 0;}
750 \textcolor{comment}{                                        dci.m\_tbsSize.at (j) = 0;}
751 \textcolor{comment}{                                        NS\_LOG\_INFO (this << " layer " << (uint16\_t)j << " no retx");}
752 \textcolor{comment}{                                \}}
753 \textcolor{comment}{                        \}*/}
754 
755                                 std::map <uint16\_t, DlHarqRlcPduList\_t>::iterator itRlcList =  
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_a51e5c8d3c34be4e070f2fb3e621cd418}{m\_dlHarqProcessesRlcPduMap}.find (rnti);
756                                 \textcolor{keywordflow}{if} (itRlcList == \hyperlink{classns3_1_1MmWaveRrMacScheduler_a51e5c8d3c34be4e070f2fb3e621cd418}{m\_dlHarqProcessesRlcPduMap}.end (
      ))
757                                 \{
758                                         \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Unable to find RlcPdcList in HARQ
       buffer for RNTI "} << rnti);
759                                 \}
760 
761 \textcolor{comment}{//                              std::vector <RlcPduInfo> rlcPduListPerLc;}
762                                 \textcolor{keywordflow}{for} (uint16\_t k = 0; k < (*itRlcList).second.at(harqTbInfo.m\_harqProcess).
      size (); k++)
763                                 \{
764                                         \textcolor{comment}{//                                      for (uint8\_t j = 0; j <
       nLayers; j++)}
765                                         \textcolor{comment}{//                                      \{}
766                                         \textcolor{comment}{//                                              if (retx.at (j))}
767                                         \textcolor{comment}{//                                              \{}
768                                         \textcolor{comment}{//                                                      if (j <
       dci.m\_ndi.size ())}
769                                         \textcolor{comment}{//                                                      \{}
770                                         \textcolor{comment}{//                                                              
      rlcPduListPerLc.push\_back ((*itRlcPdu).second.at (j).at (dci.m\_harqProcess).at (k));}
771                                         \textcolor{comment}{//                                                      \}}
772                                         \textcolor{comment}{//                                              \}}
773                                         \textcolor{comment}{//                                      \}}
774 
775                                         \textcolor{comment}{//rlcPduListPerLc.push\_back ((*itRlcList).second.at
       (harqTbInfo.m\_harqProcess).at (k));}
776                                         rlcPduMapIt->second.push\_back ((*itRlcList).second.at (harqTbInfo.
      m\_harqProcess).at (k));
777                                 \}
778 \textcolor{comment}{//                              if (rlcPduListPerLc.size () > 0)}
779 \textcolor{comment}{//                              \{}
780 \textcolor{comment}{//                                      schedInfo.m\_rlcPduList.push\_back (rlcPduListPerLc);}
781 \textcolor{comment}{//                              \}}
782                                 \textcolor{comment}{//                              schedIt->second.m\_rnti = rnti;}
783                                 schedInfo.m\_dci.m\_tbInfoElements.push\_back (harqTbInfo);
784                                 success = \textcolor{keyword}{true};
785                                 (*itHarq).second.at (harqId).m\_rv = harqTbInfo.m\_rv;
786                                 \textcolor{comment}{// refresh timer}
787                                 std::map <uint16\_t, DlHarqProcessesTimer\_t>::iterator itHarqTimer = 
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_aa52dc4680386f8ccf85d6b9c685463d1}{m\_dlHarqProcessesTimer}.find (rnti);
788                                 \textcolor{keywordflow}{if} (itHarqTimer== \hyperlink{classns3_1_1MmWaveRrMacScheduler_aa52dc4680386f8ccf85d6b9c685463d1}{m\_dlHarqProcessesTimer}.end ())
789                                 \{
790                                         \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Unable to find HARQ timer for RNTI "}
       << (uint16\_t)rnti);
791                                 \}
792                                 (*itHarqTimer).second.at (harqId) = 0;
793                                 rntiAllocated.insert (rnti);
794                         \}
795                         \textcolor{keywordflow}{else}
796                         \{
797                                 \textcolor{comment}{// update HARQ process status}
798                                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" HARQ ACK UE "} << 
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_a1b1043d7f9994e2ee6a7e1b368e9d7a1}{m\_dlHarqInfoList}.at (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}).m\_rnti);
799                                 std::map <uint16\_t, DlHarqProcessesStatus\_t>::iterator it = 
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_a5734289010d38bd8dfe04ed50ba99936}{m\_dlHarqProcessesStatus}.find (\hyperlink{classns3_1_1MmWaveRrMacScheduler_a1b1043d7f9994e2ee6a7e1b368e9d7a1}{m\_dlHarqInfoList}.at (
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}).m\_rnti);
800                                 \textcolor{keywordflow}{if} (it == \hyperlink{classns3_1_1MmWaveRrMacScheduler_a5734289010d38bd8dfe04ed50ba99936}{m\_dlHarqProcessesStatus}.end ())
801                                 \{
802                                         \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"No info find in HARQ buffer for UE "}
       << \hyperlink{classns3_1_1MmWaveRrMacScheduler_a1b1043d7f9994e2ee6a7e1b368e9d7a1}{m\_dlHarqInfoList}.at (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}).m\_rnti);
803                                 \}
804                                 (*it).second.at (\hyperlink{classns3_1_1MmWaveRrMacScheduler_a1b1043d7f9994e2ee6a7e1b368e9d7a1}{m\_dlHarqInfoList}.at (
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}).m\_harqProcessId) = 0;
805                                 std::map <uint16\_t, DlHarqRlcPduList\_t>::iterator itRlcPdu =  
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_a51e5c8d3c34be4e070f2fb3e621cd418}{m\_dlHarqProcessesRlcPduMap}.find (\hyperlink{classns3_1_1MmWaveRrMacScheduler_a1b1043d7f9994e2ee6a7e1b368e9d7a1}{m\_dlHarqInfoList}.at (
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}).m\_rnti);
806                                 \textcolor{keywordflow}{if} (itRlcPdu == \hyperlink{classns3_1_1MmWaveRrMacScheduler_a51e5c8d3c34be4e070f2fb3e621cd418}{m\_dlHarqProcessesRlcPduMap}.end ()
      )
807                                 \{
808                                         \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Unable to find RlcPdcList in HARQ
       buffer for RNTI "} << \hyperlink{classns3_1_1MmWaveRrMacScheduler_a1b1043d7f9994e2ee6a7e1b368e9d7a1}{m\_dlHarqInfoList}.at (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}).m\_rnti);
809                                 \}
810                                 (*itRlcPdu).second.at (\hyperlink{classns3_1_1MmWaveRrMacScheduler_a1b1043d7f9994e2ee6a7e1b368e9d7a1}{m\_dlHarqInfoList}.at (
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}).m\_harqProcessId).clear ();
811 
812                                 \textcolor{comment}{//                              for (uint16\_t k = 0; k <
       (*itRlcPdu).second.size (); k++)}
813                                 \textcolor{comment}{//                              \{}
814                                 \textcolor{comment}{//                                      (*itRlcPdu).second.at (k).at
       (m\_dlHarqInfoList.at (i).m\_harqProcessId).clear ();}
815                                 \textcolor{comment}{//                              \}}
816                         \}
817                 \}
818                 \hyperlink{classns3_1_1MmWaveRrMacScheduler_a1b1043d7f9994e2ee6a7e1b368e9d7a1}{m\_dlHarqInfoList}.clear ();
819                 \hyperlink{classns3_1_1MmWaveRrMacScheduler_a1b1043d7f9994e2ee6a7e1b368e9d7a1}{m\_dlHarqInfoList} = dlInfoListUntxed;
820 
821                 \textcolor{keywordflow}{if} (rbgAllocatedNum == \hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->\hyperlink{classns3_1_1MmWavePhyMacCommon_a4c5f323fd722d6eec52efda5d76f97ad}{GetNumRb} ())
822                 \{
823                         \textcolor{comment}{// all the RBGs are already allocated -> exit}
824                         \textcolor{comment}{//                      if ((ret.m\_buildDataList.size () > 0) ||
       (ret.m\_buildRarList.size () > 0))}
825                         \textcolor{comment}{//                      \{}
826                         \textcolor{comment}{//                              m\_schedSapUser->SchedDlConfigInd (ret);}
827                         \textcolor{comment}{//                      \}}
828                         \textcolor{keywordflow}{return} success;
829                 \}
830         \}
831         \textcolor{comment}{// END OF HARQ SECTION}
832 
833         \textcolor{comment}{// Get the actual active flows (unique RNTI-LCID pairs)}
834         std::list<MmWaveMacSchedSapProvider::SchedDlRlcBufferReqParameters>::iterator it;
835         \hyperlink{classns3_1_1MmWaveRrMacScheduler_a4808ca626b0b12682c3f1a079d016997}{m\_rlcBufferReq}.sort (\hyperlink{classns3_1_1MmWaveRrMacScheduler_ae0fee4909466a1900ad3d92b6b6fe3e2}{SortRlcBufferReq});
836         \textcolor{keywordtype}{int} nflows = 0;
837         \textcolor{keywordtype}{int} nTbs = 0;
838 
839         std::map <uint16\_t,uint8\_t> lcActivesPerRnti; \textcolor{comment}{// tracks how many active LCs per RNTI there are}
840         std::map <uint16\_t,uint8\_t>::iterator itLcRnti;
841         \textcolor{keywordflow}{for} (it = \hyperlink{classns3_1_1MmWaveRrMacScheduler_a4808ca626b0b12682c3f1a079d016997}{m\_rlcBufferReq}.begin (); it != \hyperlink{classns3_1_1MmWaveRrMacScheduler_a4808ca626b0b12682c3f1a079d016997}{m\_rlcBufferReq}.end (); it++)
842         \{
843                 \textcolor{comment}{// remove old entries of this UE-LC}
844                 std::set <uint16\_t>::iterator itRnti = rntiAllocated.find ((*it).m\_rnti);
845 
846                 \textcolor{keywordflow}{if} ( (((*it).m\_rlcTransmissionQueueSize > 0)
847                                 || ((*it).m\_rlcRetransmissionQueueSize > 0)
848                                 || ((*it).m\_rlcStatusPduSize > 0))
849                                 && (itRnti == rntiAllocated.end ()) )  \textcolor{comment}{// UE must not be allocated for HARQ
       retx}
850                         \textcolor{comment}{//                                                                              &&
       (HarqProcessAvailability ((*it).m\_rnti))  ) // UE needs HARQ proc free}
851                 \{
852                         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" User "} << (*it).m\_rnti << \textcolor{stringliteral}{" LC "} << (uint16\_t)
      (*it).m\_logicalChannelIdentity << \textcolor{stringliteral}{" is active, status  "} << (*it).m\_rlcStatusPduSize << \textcolor{stringliteral}{" retx "} << (*it).
      m\_rlcRetransmissionQueueSize << \textcolor{stringliteral}{" tx "} << (*it).m\_rlcTransmissionQueueSize);
853                         std::map <uint16\_t,uint8\_t>::iterator itCqi = 
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_ab048c846f6d5d71795b65b9f91c6766a}{m\_wbCqiRxed}.find ((*it).m\_rnti);
854                         uint8\_t cqi = 0;
855                         \textcolor{keywordflow}{if} (itCqi != \hyperlink{classns3_1_1MmWaveRrMacScheduler_ab048c846f6d5d71795b65b9f91c6766a}{m\_wbCqiRxed}.end ())
856                         \{
857                                 cqi = (*itCqi).second;
858                         \}
859                         \textcolor{keywordflow}{else}
860                         \{
861                                 cqi = 1; \textcolor{comment}{// lowest value for trying a transmission}
862                         \}
863                         \textcolor{keywordflow}{if} (cqi != 0)
864                         \{
865                                 \textcolor{comment}{// CQI == 0 means "out of range" (see table 7.2.3-1 of 36.213)}
866                                 nflows++;
867                                 itLcRnti = lcActivesPerRnti.find ((*it).m\_rnti);
868                                 \textcolor{keywordflow}{if} (itLcRnti != lcActivesPerRnti.end ())
869                                 \{
870                                         (*itLcRnti).second++;
871                                 \}
872                                 \textcolor{keywordflow}{else}
873                                 \{
874                                         lcActivesPerRnti.insert (std::pair<uint16\_t, uint8\_t > ((*it).
      m\_rnti, 1));
875                                         nTbs++;
876                                 \}
877                         \}
878                         \textcolor{keywordflow}{else}
879                         \{
880                                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"*** RNTI "} << (*it).m\_rnti << \textcolor{stringliteral}{" DL CQI out of
       range, skipping allocation in DL for slot "} << slotNum+1);
881                         \}
882                 \}
883         \}
884 
885         \textcolor{keywordflow}{if} (nflows == 0)
886         \{
887                 \textcolor{keywordflow}{return} success; \textcolor{comment}{// no DL flows to be scheduled}
888         \}
889 
890         \textcolor{comment}{// int rbgPerTb = (nTbs > 0) ? ((numRbg - rbgAllocatedNum) / nTbs) : INT\_MAX;}
891         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rbgPerTb = (nTbs > 0) ? (\hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->
      \hyperlink{classns3_1_1MmWavePhyMacCommon_a4c5f323fd722d6eec52efda5d76f97ad}{GetNumRb} ()  / nTbs) : \hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->\hyperlink{classns3_1_1MmWavePhyMacCommon_a4c5f323fd722d6eec52efda5d76f97ad}{GetNumRb} ();
892 
893         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" Flows to be transmitted "} << nflows << \textcolor{stringliteral}{" rbgPerTb "} << rbgPerTb);
894         \textcolor{keywordflow}{if} (rbgPerTb == 0)
895         \{
896                 rbgPerTb = 1;
897         \}
898 
899         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rbgAllocated = 0;
900 
901         \textcolor{comment}{// round robin assignment to all UEs registered starting from the subsequent of the one}
902         \textcolor{comment}{// served last scheduling trigger event}
903         \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1MmWaveRrMacScheduler_a0de8f79fecf022efca5e65228d35cca6}{m\_nextRntiDl} != 0)
904         \{
905                 \textcolor{keywordflow}{for} (it = \hyperlink{classns3_1_1MmWaveRrMacScheduler_a4808ca626b0b12682c3f1a079d016997}{m\_rlcBufferReq}.begin (); it != 
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_a4808ca626b0b12682c3f1a079d016997}{m\_rlcBufferReq}.end (); it++)
906                 \{
907                         \textcolor{keywordflow}{if} ((*it).m\_rnti == \hyperlink{classns3_1_1MmWaveRrMacScheduler_a0de8f79fecf022efca5e65228d35cca6}{m\_nextRntiDl})
908                         \{
909                                 \textcolor{keywordflow}{break};
910                         \}
911                 \}
912 
913                 \textcolor{keywordflow}{if} (it == \hyperlink{classns3_1_1MmWaveRrMacScheduler_a4808ca626b0b12682c3f1a079d016997}{m\_rlcBufferReq}.end ())
914                 \{
915                         \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" no user found"});
916                 \}
917         \}
918         \textcolor{keywordflow}{else}
919         \{
920                 it = \hyperlink{classns3_1_1MmWaveRrMacScheduler_a4808ca626b0b12682c3f1a079d016997}{m\_rlcBufferReq}.begin ();
921                 \hyperlink{classns3_1_1MmWaveRrMacScheduler_a0de8f79fecf022efca5e65228d35cca6}{m\_nextRntiDl} = (*it).m\_rnti;
922         \}
923         \textcolor{comment}{//                      std::map <uint16\_t,uint8\_t>::iterator itTxMode;}
924         \textcolor{keywordflow}{do}
925         \{
926                 itLcRnti = lcActivesPerRnti.find ((*it).m\_rnti);
927                 \textcolor{comment}{//                              std::set <uint16\_t>::iterator itRnti = rntiAllocated.find
       ((*it).m\_rnti);}
928                 \textcolor{comment}{//                              if ((itLcRnti == lcActivesPerRnti.end ())||(itRnti !=
       rntiAllocated.end ()))}
929                 \textcolor{keywordflow}{if} ((itLcRnti == lcActivesPerRnti.end ()))
930                 \{
931                         \textcolor{comment}{// skip this RNTI (no active queue or already allocated for HARQ)}
932                         uint16\_t rntiDiscared = (*it).m\_rnti;
933                         \textcolor{keywordflow}{while} (it != \hyperlink{classns3_1_1MmWaveRrMacScheduler_a4808ca626b0b12682c3f1a079d016997}{m\_rlcBufferReq}.end ())
934                         \{
935                                 \textcolor{keywordflow}{if} ((*it).m\_rnti != rntiDiscared)
936                                 \{
937                                         \textcolor{keywordflow}{break};
938                                 \}
939                                 it++;
940                         \}
941                         \textcolor{keywordflow}{if} (it == \hyperlink{classns3_1_1MmWaveRrMacScheduler_a4808ca626b0b12682c3f1a079d016997}{m\_rlcBufferReq}.end ())
942                         \{
943                                 \textcolor{comment}{// restart from the first}
944                                 it = \hyperlink{classns3_1_1MmWaveRrMacScheduler_a4808ca626b0b12682c3f1a079d016997}{m\_rlcBufferReq}.begin ();
945                         \}
946                         \textcolor{keywordflow}{continue};
947                 \}
948 
949                 \textcolor{keywordtype}{int} lcNum = (*itLcRnti).second;
950 
951                 \textcolor{comment}{// find existing or create new scheduling info element/DCI element}
952                 std::map<uint16\_t,SchedInfo>::iterator schedIt = schedInfoMap.find ((*it).m\_rnti);
953                 \textcolor{keywordflow}{if} (schedIt == schedInfoMap.end ())
954                 \{
955                         SchedInfo newSchedInfo (\hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->
      \hyperlink{classns3_1_1MmWavePhyMacCommon_a7b6552d2e0ffbeaf3bc2f9db6d0d6e63}{GetSlotsPerSubframe} ());
956                         newSchedInfo.m\_rnti = (*it).m\_rnti;
957                         DciInfoElement newDci;
958                         newDci.m\_rnti = (*it).m\_rnti;
959                         newDci.m\_tddBitmap = 0;
960                         newDci.m\_format = 0;
961                         newDci.m\_cceIndex = 0;
962                         \textcolor{comment}{//                              newDci.m\_harqProcess = UpdateHarqProcessId
       ((*it).m\_rnti);}
963                         newSchedInfo.m\_dci = newDci;
964                         newSchedInfo.m\_frameNum = frameNum;
965                         newSchedInfo.m\_sfNum = sfNum;
966                         schedIt = (schedInfoMap.insert (std::pair<uint16\_t,SchedInfo> ((*it).m\_rnti, 
      newSchedInfo))).first;
967                 \}
968 
969                 SchedInfo& schedInfo = schedIt->second;
970                 \textcolor{comment}{//                              schedInfo.m\_dci.m\_tddBitmap = (schedInfo.m\_dci.m\_tddBitmap
       | (0x1 << slotNum));}
971                 TbInfoElement newTbInfoElem;
972                 newTbInfoElem.m\_resAlloc = 0;
973                 newTbInfoElem.m\_rbBitmap = 0;
974                 newTbInfoElem.m\_slotIdx = slotNum;
975                 newTbInfoElem.m\_rbShift = 0;
976                 newTbInfoElem.m\_rbStart = 0;
977                 newTbInfoElem.m\_rbLen = 0;
978                 newTbInfoElem.m\_harqProcess = \hyperlink{classns3_1_1MmWaveRrMacScheduler_a0c01cd018ece348fa17da5babacd3bae}{UpdateDlHarqProcessId} ((*it).m\_rnti);
979                 \textcolor{comment}{//schedInfo.m\_rlcPduList.push\_back(std::vector<RlcPduInfo> ());  // vector to store RLC
       PDUs for new TB}
980                 std::map<uint8\_t, std::vector<RlcPduInfo> >::iterator rlcPduMapIt = schedInfo.m\_rlcPduMap.
      insert (std::pair<uint8\_t, std::vector<RlcPduInfo> > (newTbInfoElem.m\_harqProcess, std::vector<RlcPduInfo> ()
       )).first;
981 
982                 std::map <uint16\_t,uint8\_t>::iterator itCqi = \hyperlink{classns3_1_1MmWaveRrMacScheduler_ab048c846f6d5d71795b65b9f91c6766a}{m\_wbCqiRxed}.find (schedInfo.m\_rnti
      );
983 
984                 \textcolor{keywordflow}{if} (itCqi == \hyperlink{classns3_1_1MmWaveRrMacScheduler_ab048c846f6d5d71795b65b9f91c6766a}{m\_wbCqiRxed}.end ())
985                 \{
986                         newTbInfoElem.m\_mcs = 0; \textcolor{comment}{// no info on this user -> lowest MCS}
987                 \}
988                 \textcolor{keywordflow}{else}
989                 \{
990                         newTbInfoElem.m\_mcs = \hyperlink{classns3_1_1MmWaveRrMacScheduler_abbcdddd7d8733f372963069e1d0395d3}{m\_amc}->GetMcsFromCqi ((*itCqi).second);
991                 \}
992 
993                 MmWaveMacPduHeader macHeader;
994                 \textcolor{keywordtype}{int} tbSize = (\hyperlink{classns3_1_1MmWaveRrMacScheduler_abbcdddd7d8733f372963069e1d0395d3}{m\_amc}->GetTbSizeFromMcs (newTbInfoElem.m\_mcs, 
      \hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->\hyperlink{classns3_1_1MmWavePhyMacCommon_a4c5f323fd722d6eec52efda5d76f97ad}{GetNumRb}()) / 8) - macHeader.GetSerializedSize ();
995                 uint16\_t rlcPduSize = tbSize / lcNum;
996                 \textcolor{keywordflow}{while} ((*it).m\_rnti == schedInfo.m\_rnti)
997                 \{
998                         \textcolor{keywordflow}{if} ( ((*it).m\_rlcTransmissionQueueSize > 0)
999                                         || ((*it).m\_rlcRetransmissionQueueSize > 0)
1000                                         || ((*it).m\_rlcStatusPduSize > 0) )
1001                         \{
1002 
1003                                 RlcPduInfo newRlcEl;
1004                                 newRlcEl.m\_lcid = (*it).m\_logicalChannelIdentity;
1005                                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \textcolor{stringliteral}{"LCID "} << (uint32\_t) newRlcEl.m\_lcid << \textcolor{stringliteral}{"
       size "} << rlcPduSize << \textcolor{stringliteral}{" ID "} << (*it).m\_rnti);
1006                                 newRlcEl.m\_size = rlcPduSize;
1007                                 \hyperlink{classns3_1_1MmWaveRrMacScheduler_a005e51f10e6d477bf11d6993f081ed24}{UpdateDlRlcBufferInfo} ((*it).m\_rnti, newRlcEl.m\_lcid, 
      rlcPduSize);
1008 
1009                                 \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1MmWaveRrMacScheduler_ad8bb79b5853000b363b42a158633a942}{m\_harqOn} == \textcolor{keyword}{true})
1010                                 \{
1011                                         \textcolor{comment}{// store RLC PDU list for HARQ}
1012                                         std::map <uint16\_t, DlHarqRlcPduList\_t>::iterator itRlcPdu =  
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_a51e5c8d3c34be4e070f2fb3e621cd418}{m\_dlHarqProcessesRlcPduMap}.find ((*it).m\_rnti);
1013                                         \textcolor{keywordflow}{if} (itRlcPdu == 
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_a51e5c8d3c34be4e070f2fb3e621cd418}{m\_dlHarqProcessesRlcPduMap}.end ())
1014                                         \{
1015                                                 \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Unable to find RlcPdcList in
       HARQ buffer for RNTI "} << (*it).m\_rnti);
1016                                         \}
1017                                         (*itRlcPdu).second.at (newTbInfoElem.m\_harqProcess).push\_back (
      newRlcEl);
1018                                 \}
1019 
1020                                 \textcolor{comment}{// push new element onto RLC PDU vector for this TB}
1021                                 \textcolor{comment}{//schedInfo.m\_rlcPduList[schedInfo.m\_rlcPduList.size ()-1].push\_back
       (newRlcEl);}
1022                                 rlcPduMapIt->second.push\_back (newRlcEl);
1023                                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"RLC PDU for LCID "} << (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})newRlcEl.
      m\_lcid << \textcolor{stringliteral}{" of size "} << newRlcEl.m\_size << \textcolor{stringliteral}{" added for TB "} << newTbInfoElem.m\_harqProcess);
1024                                 lcNum--;
1025                         \}
1026                         it++;
1027                         \textcolor{keywordflow}{if} (it == \hyperlink{classns3_1_1MmWaveRrMacScheduler_a4808ca626b0b12682c3f1a079d016997}{m\_rlcBufferReq}.end ())
1028                         \{
1029                                 \textcolor{comment}{// restart from the first}
1030                                 it = \hyperlink{classns3_1_1MmWaveRrMacScheduler_a4808ca626b0b12682c3f1a079d016997}{m\_rlcBufferReq}.begin ();
1031                                 \textcolor{keywordflow}{break};
1032                         \}
1033                 \}
1034                 uint32\_t rbgMask = 0;
1035                 uint16\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0;
1036                 \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"DL Allocation frame "} << frameNum << \textcolor{stringliteral}{" subframe "} << sfNum << \textcolor{stringliteral}{"
       slot "} << slotNum+1 << \textcolor{stringliteral}{" "} << \textcolor{stringliteral}{" RNTI "} << schedInfo.m\_rnti << \textcolor{stringliteral}{" LCs "} << (uint16\_t)(*itLcRnti).second << \textcolor{stringliteral}{"
       bytes "} << tbSize << \textcolor{stringliteral}{" mcs "} << (uint16\_t) newTbInfoElem.m\_mcs << \textcolor{stringliteral}{" harqId "} << (uint16\_t)newTbInfoElem.
      m\_harqProcess );
1037                 \textcolor{keywordflow}{while} (i < rbgPerTb)
1038                 \{
1039                         \textcolor{keywordflow}{if} (rbgMap.at (rbgAllocated) == \textcolor{keyword}{false})
1040                         \{
1041                                 rbgMask = rbgMask + (0x1 << rbgAllocated);
1042                                 i++;
1043                                 rbgMap.at (rbgAllocated) = \textcolor{keyword}{true};
1044                                 rbgAllocatedNum++;
1045                         \}
1046                         rbgAllocated++;
1047                 \}
1048                 newTbInfoElem.m\_rbBitmap = rbgMask; \textcolor{comment}{// (32 bit bitmap see 7.1.6 of 36.213)}
1049                 newTbInfoElem.m\_tbSize = tbSize;
1050                 newTbInfoElem.m\_ndi = 1;
1051                 newTbInfoElem.m\_rv = 0;
1052 
1053                 \textcolor{comment}{// newDci.m\_tpc = 1; //1 is mapped to 0 in Accumulated Mode and to -1 in Absolute Mode}
1054 
1055                 schedInfo.m\_dci.m\_tbInfoElements.push\_back (newTbInfoElem);
1056                 success = \textcolor{keyword}{true};
1057 
1058                 \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1MmWaveRrMacScheduler_ad8bb79b5853000b363b42a158633a942}{m\_harqOn} == \textcolor{keyword}{true})
1059                 \{
1060                         \textcolor{comment}{// store DCI for HARQ}
1061                         std::map <uint16\_t, DlHarqProcessesTbInfoList\_t>::iterator itTbInfo = 
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_a8d14c222701c0a57ecbd40a51d0391da}{m\_dlHarqProcessesTbInfoMap}.find (schedInfo.m\_dci.m\_rnti);
1062                         \textcolor{keywordflow}{if} (itTbInfo == \hyperlink{classns3_1_1MmWaveRrMacScheduler_a8d14c222701c0a57ecbd40a51d0391da}{m\_dlHarqProcessesTbInfoMap}.end ())
1063                         \{
1064                                 \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Unable to find RNTI entry in DCI HARQ buffer
       for RNTI "} << schedInfo.m\_rnti);
1065                         \}
1066                         (*itTbInfo).second.at (newTbInfoElem.m\_harqProcess) = newTbInfoElem;
1067                         \textcolor{comment}{// refresh timer}
1068                         std::map <uint16\_t, DlHarqProcessesTimer\_t>::iterator itHarqTimer =  
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_aa52dc4680386f8ccf85d6b9c685463d1}{m\_dlHarqProcessesTimer}.find (schedInfo.m\_dci.m\_rnti);
1069                         \textcolor{keywordflow}{if} (itHarqTimer== \hyperlink{classns3_1_1MmWaveRrMacScheduler_aa52dc4680386f8ccf85d6b9c685463d1}{m\_dlHarqProcessesTimer}.end ())
1070                         \{
1071                                 \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Unable to find HARQ timer for RNTI "} << (
      uint16\_t)schedInfo.m\_dci.m\_rnti);
1072                         \}
1073                         (*itHarqTimer).second.at (newTbInfoElem.m\_harqProcess) = 0;
1074                 \}
1075 
1076                 \textcolor{keywordflow}{if} (rbgAllocatedNum == \hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->\hyperlink{classns3_1_1MmWavePhyMacCommon_a4c5f323fd722d6eec52efda5d76f97ad}{GetNumRb} ())
1077                 \{
1078                         \hyperlink{classns3_1_1MmWaveRrMacScheduler_a0de8f79fecf022efca5e65228d35cca6}{m\_nextRntiDl} = (*it).m\_rnti; \textcolor{comment}{// store last RNTI served}
1079                         \textcolor{keywordflow}{break};                       \textcolor{comment}{// no more RGB to be allocated}
1080                 \}
1081         \}
1082         \textcolor{keywordflow}{while} ((*it).m\_rnti != \hyperlink{classns3_1_1MmWaveRrMacScheduler_a0de8f79fecf022efca5e65228d35cca6}{m\_nextRntiDl});
1083 
1084         \textcolor{keywordflow}{return} success;
1085 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8




Here is the caller graph for this function\+:
% FIG 9


\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Do\+Sched\+Trigger\+Req@{Do\+Sched\+Trigger\+Req}}
\index{Do\+Sched\+Trigger\+Req@{Do\+Sched\+Trigger\+Req}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Do\+Sched\+Trigger\+Req(const struct Mm\+Wave\+Mac\+Sched\+Sap\+Provider\+::\+Sched\+Trigger\+Req\+Parameters \&params)}{DoSchedTriggerReq(const struct MmWaveMacSchedSapProvider::SchedTriggerReqParameters &params)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Do\+Sched\+Trigger\+Req (
\begin{DoxyParamCaption}
\item[{const struct {\bf Mm\+Wave\+Mac\+Sched\+Sap\+Provider\+::\+Sched\+Trigger\+Req\+Parameters} \&}]{params}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a48f0e305c3d706ac557bcb877f6cd2d0}{}\label{classns3_1_1MmWaveRrMacScheduler_a48f0e305c3d706ac557bcb877f6cd2d0}

\begin{DoxyCode}
1469 \{
1470         uint16\_t frameNum = params.m\_snfSf >> 16;
1471         uint8\_t  sfNum = (params.m\_snfSf & 0xff00)>>8;
1472         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Scheduling frame "}<< (\textcolor{keywordtype}{unsigned})frameNum << \textcolor{stringliteral}{" subframe "} << (\textcolor{keywordtype}{unsigned})sfNum
       );
1473 
1474         MmWaveMacSchedSapUser::SchedConfigIndParameters ret;
1475         ret.m\_sfn = params.m\_snfSf;
1476         \textcolor{comment}{//      std::map<uint16\_t,SchedInfo>& schedInfoMap = ret.m\_schedInfoMap;}
1477 
1478         \textcolor{keywordtype}{unsigned} ulFrameNum;
1479         \textcolor{keywordtype}{unsigned} ulSfNum = sfNum + \hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->\hyperlink{classns3_1_1MmWavePhyMacCommon_afd70935ec71838fefe6a8e18198f19cb}{GetUlSchedDelay} () - 1;
1480         \textcolor{keywordflow}{if} (ulSfNum > 10)
1481         \{
1482                 ulFrameNum = frameNum + 1;
1483                 ulSfNum = ulSfNum - 10;
1484         \}
1485         \textcolor{keywordflow}{else}
1486         \{
1487                 ulFrameNum = frameNum;
1488         \}
1489 
1490         \hyperlink{classns3_1_1MmWaveRrMacScheduler_a7e934e11a18ac6fccd3eb11e41693523}{RefreshDlCqiMaps} ();
1491         \hyperlink{classns3_1_1MmWaveRrMacScheduler_a08bd59d628f7a0115392e00c9cf44c59}{RefreshUlCqiMaps} ();
1492 
1493         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} slotNum = 0; slotNum < \hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->
      \hyperlink{classns3_1_1MmWavePhyMacCommon_a7b6552d2e0ffbeaf3bc2f9db6d0d6e63}{GetSlotsPerSubframe} (); slotNum++)
1494         \{
1495                 \textcolor{keywordflow}{if} ((slotNum % 2) == 0) \textcolor{comment}{// schedule current slot for DOWNLINK}
1496                 \{
1497                         \textcolor{keywordflow}{if} ( !\hyperlink{classns3_1_1MmWaveRrMacScheduler_a17b839c05a05ce1ef83b9b806c943789}{DoSchedDlTriggerReq} (params, ret, frameNum, sfNum, slotNum
      ) && (slotNum != 0))
1498                         \{
1499                                 \textcolor{comment}{// failed to allocate any users in DL, try to allocate in UL (slot 1
       reserved for DL)}
1500                                 \textcolor{comment}{//DoSchedUlTriggerReq (params, ret, frameNum, sfNum, slotNum);}
1501                         \}
1502                 \}
1503                 \textcolor{keywordflow}{else}
1504                 \{
1505 
1506                         \textcolor{keywordflow}{if} ( !\hyperlink{classns3_1_1MmWaveRrMacScheduler_a60261f8b46716986bd8d0ae245fab35a}{DoSchedUlTriggerReq} (params, ret, ulFrameNum, ulSfNum, 
      slotNum) && (slotNum != 1))
1507                         \{
1508                                 \textcolor{comment}{// failed to allocate any users in UL, try to allocate in DL (slot 2
       reserved for UL)}
1509                                 \textcolor{comment}{//DoSchedDlTriggerReq (params, ret, frameNum, sfNum, slotNum)}
1510                         \}
1511 
1512 \textcolor{comment}{//                      std::map<uint16\_t, SchedInfo>::const\_iterator it = ret.m\_schedInfoMap.begin ();}
1513 \textcolor{comment}{//                      for (; it != ret.m\_schedInfoMap.end (); it++)}
1514 \textcolor{comment}{//                      \{}
1515 \textcolor{comment}{//                              std::cout << "RrScheduler: UL TBs for rnti " << it->second.m\_dci.m\_rnti <<
       " frame " << ulFrameNum << " subframe " << (unsigned)ulSfNum << " slotNum " << (unsigned)slotNum;}
1516 \textcolor{comment}{//                              for (unsigned itb = 0; itb < it->second.m\_dci.m\_tbInfoElements.size ();
       itb++)}
1517 \textcolor{comment}{//                              \{}
1518 \textcolor{comment}{//                                      std::cout << " tb size " <<
       it->second.m\_dci.m\_tbInfoElements[itb].m\_tbSize;}
1519 \textcolor{comment}{//                              \}}
1520 \textcolor{comment}{//                              std::cout << std::endl;}
1521 \textcolor{comment}{//                      \}}
1522                 \}
1523         \}
1524 
1525         \hyperlink{classns3_1_1MmWaveRrMacScheduler_a5f6adc4e7eabd10266ede796be0d1bca}{m\_macSchedSapUser}->\hyperlink{classns3_1_1MmWaveMacSchedSapUser_ac164dd52215c3924cf421b56089eece4}{SchedConfigInd} (ret);
1526         \textcolor{keywordflow}{return};
1527 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10




Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Do\+Sched\+Ul\+Cqi\+Info\+Req@{Do\+Sched\+Ul\+Cqi\+Info\+Req}}
\index{Do\+Sched\+Ul\+Cqi\+Info\+Req@{Do\+Sched\+Ul\+Cqi\+Info\+Req}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Do\+Sched\+Ul\+Cqi\+Info\+Req(const struct Mm\+Wave\+Mac\+Sched\+Sap\+Provider\+::\+Sched\+Ul\+Cqi\+Info\+Req\+Parameters \&params)}{DoSchedUlCqiInfoReq(const struct MmWaveMacSchedSapProvider::SchedUlCqiInfoReqParameters &params)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Do\+Sched\+Ul\+Cqi\+Info\+Req (
\begin{DoxyParamCaption}
\item[{const struct {\bf Mm\+Wave\+Mac\+Sched\+Sap\+Provider\+::\+Sched\+Ul\+Cqi\+Info\+Req\+Parameters} \&}]{params}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a7914f7ed4851eabd5b88838da3399971}{}\label{classns3_1_1MmWaveRrMacScheduler_a7914f7ed4851eabd5b88838da3399971}

\begin{DoxyCode}
287 \{
288   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
289 
290         \textcolor{keywordtype}{unsigned} frameNum = params.m\_sfnSf >> 16;
291         \textcolor{keywordtype}{unsigned} subframeNum = (params.m\_sfnSf >> 8) & 0xFF;
292         \textcolor{keywordtype}{unsigned} slotNum = params.m\_sfnSf & 0xFF;
293 
294   \textcolor{keywordflow}{switch} (params.m\_ulCqi.m\_type)
295     \{
296     \textcolor{keywordflow}{case} \hyperlink{structns3_1_1UlCqiInfo_a8241de30e4fdc8640e892ddf1e2a6c00a6d4b515df7c45a6843584459fbde26a7}{UlCqiInfo::PUSCH}:
297       \{
298         std::map <uint32\_t, std::vector <uint16\_t> >::iterator itMap;
299         std::map <uint16\_t, std::vector <double> >::iterator itCqi;
300         itMap = \hyperlink{classns3_1_1MmWaveRrMacScheduler_aac1f8a8418e80a70a78e8fb710697588}{m\_allocationMaps}.find (params.m\_sfnSf);
301         \textcolor{keywordflow}{if} (itMap == \hyperlink{classns3_1_1MmWaveRrMacScheduler_aac1f8a8418e80a70a78e8fb710697588}{m\_allocationMaps}.end ())
302           \{
303             \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" Does not find info on allocation, size : "} << 
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_aac1f8a8418e80a70a78e8fb710697588}{m\_allocationMaps}.size ());
304             \textcolor{keywordflow}{return};
305           \}
306         \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < (*itMap).second.size (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
307           \{
308             \textcolor{comment}{// convert from fixed point notation Sxxxxxxxxxxx.xxx to double}
309             \textcolor{keywordtype}{double} sinr = \hyperlink{classns3_1_1LteFfConverter_aa5d8c2a8f988dbd63da91818c18666eb}{LteFfConverter::fpS11dot3toDouble} (params.
      m\_ulCqi.m\_sinr.at (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}));
310             itCqi = \hyperlink{classns3_1_1MmWaveRrMacScheduler_aeb890d54a9f369fe677a64efa78d2402}{m\_ueUlCqi}.find ((*itMap).second.at (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}));
311             \textcolor{keywordflow}{if} (itCqi == \hyperlink{classns3_1_1MmWaveRrMacScheduler_aeb890d54a9f369fe677a64efa78d2402}{m\_ueUlCqi}.end ())
312               \{
313                 \textcolor{comment}{// create a new entry}
314                 std::vector <double> newCqi;
315                 \textcolor{keywordflow}{for} (uint32\_t j = 0; j < (\hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->\hyperlink{classns3_1_1MmWavePhyMacCommon_a4c5f323fd722d6eec52efda5d76f97ad}{GetNumRb} () * 
      \hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->\hyperlink{classns3_1_1MmWavePhyMacCommon_a8a303f463053dadea5902859a00d481f}{GetNumChunkPerRb} ()); j++)
316                   \{
317                                 \textcolor{keywordtype}{unsigned} chunkInd = \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} * \hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->
      \hyperlink{classns3_1_1MmWavePhyMacCommon_a8a303f463053dadea5902859a00d481f}{GetNumChunkPerRb} ();
318                     \textcolor{keywordflow}{if} (chunkInd == j)
319                       \{
320                         newCqi.push\_back (sinr);
321                         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"UL CQI report for RNTI "} << (*itMap).second.at (
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) << \textcolor{stringliteral}{" chunk "} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} << \textcolor{stringliteral}{" SINR "} << sinr << \(\backslash\)
322                                       \textcolor{stringliteral}{" frame "} << frameNum << \textcolor{stringliteral}{" subframe "} << subframeNum << \textcolor{stringliteral}{" slot "} << 
      slotNum);
323                       \}
324                     \textcolor{keywordflow}{else}
325                       \{
326                         \textcolor{comment}{// initialize with NO\_SINR value.}
327                         newCqi.push\_back (30.0);
328                       \}
329                   \}
330                 \hyperlink{classns3_1_1MmWaveRrMacScheduler_aeb890d54a9f369fe677a64efa78d2402}{m\_ueUlCqi}.insert (std::pair <uint16\_t, std::vector <double> > ((*itMap).second.at 
      (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}), newCqi));
331 
332 
333 
334                 \textcolor{comment}{// generate correspondent timer}
335                 \hyperlink{classns3_1_1MmWaveRrMacScheduler_a48957bee7e937b6d8627194fa429a473}{m\_ueCqiTimers}.insert (std::pair <uint16\_t, uint32\_t > ((*itMap).second.at (
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}), \hyperlink{classns3_1_1MmWaveRrMacScheduler_a21360d09f2e5e4b9fc304752aef8ae6a}{m\_cqiTimersThreshold}));
336               \}
337             \textcolor{keywordflow}{else}
338               \{
339                 \textcolor{comment}{// update the value}
340                 (*itCqi).second.at (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) = sinr;
341                 \textcolor{comment}{// update correspondent timer}
342                 std::map <uint16\_t, uint32\_t>::iterator itTimers;
343                 itTimers = \hyperlink{classns3_1_1MmWaveRrMacScheduler_a48957bee7e937b6d8627194fa429a473}{m\_ueCqiTimers}.find ((*itMap).second.at (
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}));
344                 (*itTimers).second = \hyperlink{classns3_1_1MmWaveRrMacScheduler_a21360d09f2e5e4b9fc304752aef8ae6a}{m\_cqiTimersThreshold};
345 
346                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"UL CQI report for RNTI "} << (*itMap).second.at (
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) << \textcolor{stringliteral}{" chunk "} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} << \textcolor{stringliteral}{" SINR "} << sinr << \(\backslash\)
347                                                       \textcolor{stringliteral}{" frame "} << frameNum << \textcolor{stringliteral}{" subframe "} << subframeNum 
      << \textcolor{stringliteral}{" slot "} << slotNum);
348 
349               \}
350 
351           \}
352         \textcolor{comment}{// remove obsolete info on allocation}
353         \hyperlink{classns3_1_1MmWaveRrMacScheduler_aac1f8a8418e80a70a78e8fb710697588}{m\_allocationMaps}.erase (itMap);
354       \}
355       \textcolor{keywordflow}{break};
356     \textcolor{keywordflow}{default}:
357       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Unknown type of UL-CQI"});
358     \}
359   \textcolor{keywordflow}{return};
360 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12




Here is the caller graph for this function\+:
% FIG 13


\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Do\+Sched\+Ul\+Mac\+Ctrl\+Info\+Req@{Do\+Sched\+Ul\+Mac\+Ctrl\+Info\+Req}}
\index{Do\+Sched\+Ul\+Mac\+Ctrl\+Info\+Req@{Do\+Sched\+Ul\+Mac\+Ctrl\+Info\+Req}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Do\+Sched\+Ul\+Mac\+Ctrl\+Info\+Req(const struct Mm\+Wave\+Mac\+Sched\+Sap\+Provider\+::\+Sched\+Ul\+Mac\+Ctrl\+Info\+Req\+Parameters \&params)}{DoSchedUlMacCtrlInfoReq(const struct MmWaveMacSchedSapProvider::SchedUlMacCtrlInfoReqParameters &params)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Do\+Sched\+Ul\+Mac\+Ctrl\+Info\+Req (
\begin{DoxyParamCaption}
\item[{const struct {\bf Mm\+Wave\+Mac\+Sched\+Sap\+Provider\+::\+Sched\+Ul\+Mac\+Ctrl\+Info\+Req\+Parameters} \&}]{params}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1MmWaveRrMacScheduler_ab99149a6961ca02b605ce4c89c12e4c7}{}\label{classns3_1_1MmWaveRrMacScheduler_ab99149a6961ca02b605ce4c89c12e4c7}

\begin{DoxyCode}
1531 \{
1532         \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1533 
1534         std::map <uint16\_t,uint32\_t>::iterator it;
1535 
1536         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < params.m\_macCeList.size (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
1537         \{
1538                 \textcolor{keywordflow}{if} ( params.m\_macCeList.at (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}).m\_macCeType == \hyperlink{structns3_1_1MacCeElement_a7b68183e7a7fd9b02783f92a2c645d7ba459101d6c51f15c22bfdf75d68f9c631}{MacCeElement::BSR} )
1539                 \{
1540                         \textcolor{comment}{// buffer status report}
1541                         \textcolor{comment}{// note that this scheduler does not differentiate the}
1542                         \textcolor{comment}{// allocation according to which LCGs have more/less bytes}
1543                         \textcolor{comment}{// to send.}
1544                         \textcolor{comment}{// Hence the BSR of different LCGs are just summed up to get}
1545                         \textcolor{comment}{// a total queue size that is used for allocation purposes.}
1546 
1547                         uint32\_t buffer = 0;
1548                         \textcolor{keywordflow}{for} (uint8\_t lcg = 0; lcg < 4; ++lcg)
1549                         \{
1550                                 uint8\_t bsrId = params.m\_macCeList.at (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}).m\_macCeValue.m\_bufferStatus.at (
      lcg);
1551                                 buffer += \hyperlink{classns3_1_1MmWaveRrMacScheduler_ad748b4ad6a90547493f1bfd4a95fa055}{BsrId2BufferSize} (bsrId);
1552                         \}
1553 
1554                         uint16\_t rnti = params.m\_macCeList.at (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}).m\_rnti;
1555                         it = \hyperlink{classns3_1_1MmWaveRrMacScheduler_a2ebec374f1ff5014f115ff8b68ff5ebb}{m\_ceBsrRxed}.find (rnti);
1556                         \textcolor{keywordflow}{if} (it == \hyperlink{classns3_1_1MmWaveRrMacScheduler_a2ebec374f1ff5014f115ff8b68ff5ebb}{m\_ceBsrRxed}.end ())
1557                         \{
1558                                 \textcolor{comment}{// create the new entry}
1559                                 \hyperlink{classns3_1_1MmWaveRrMacScheduler_a2ebec374f1ff5014f115ff8b68ff5ebb}{m\_ceBsrRxed}.insert ( std::pair<uint16\_t, uint32\_t > (rnti, 
      buffer));
1560                                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" Insert RNTI "} << rnti << \textcolor{stringliteral}{" queue "} << 
      buffer);
1561                         \}
1562                         \textcolor{keywordflow}{else}
1563                         \{
1564                                 \textcolor{comment}{// update the buffer size value}
1565                                 (*it).second = buffer;
1566                                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" Update RNTI "} << rnti << \textcolor{stringliteral}{" queue "} << 
      buffer);
1567                         \}
1568                 \}
1569         \}
1570 
1571         \textcolor{keywordflow}{return};
1572 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 14




Here is the caller graph for this function\+:
% FIG 15


\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Do\+Sched\+Ul\+Trigger\+Req@{Do\+Sched\+Ul\+Trigger\+Req}}
\index{Do\+Sched\+Ul\+Trigger\+Req@{Do\+Sched\+Ul\+Trigger\+Req}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Do\+Sched\+Ul\+Trigger\+Req(const struct Mm\+Wave\+Mac\+Sched\+Sap\+Provider\+::\+Sched\+Trigger\+Req\+Parameters \&params, Mm\+Wave\+Mac\+Sched\+Sap\+User\+::\+Sched\+Config\+Ind\+Parameters \&ret, unsigned int frame\+Num, unsigned int sf\+Num, unsigned int islot)}{DoSchedUlTriggerReq(const struct MmWaveMacSchedSapProvider::SchedTriggerReqParameters &params, MmWaveMacSchedSapUser::SchedConfigIndParameters &ret, unsigned int frameNum, unsigned int sfNum, unsigned int islot)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Do\+Sched\+Ul\+Trigger\+Req (
\begin{DoxyParamCaption}
\item[{const struct {\bf Mm\+Wave\+Mac\+Sched\+Sap\+Provider\+::\+Sched\+Trigger\+Req\+Parameters} \&}]{params, }
\item[{{\bf Mm\+Wave\+Mac\+Sched\+Sap\+User\+::\+Sched\+Config\+Ind\+Parameters} \&}]{ret, }
\item[{unsigned int}]{frame\+Num, }
\item[{unsigned int}]{sf\+Num, }
\item[{unsigned int}]{islot}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a60261f8b46716986bd8d0ae245fab35a}{}\label{classns3_1_1MmWaveRrMacScheduler_a60261f8b46716986bd8d0ae245fab35a}

\begin{DoxyCode}
1093 \{
1094         \textcolor{keywordtype}{bool} success = \textcolor{keyword}{false}; \textcolor{comment}{// was able to allocate at least 1 UE}
1095         \textcolor{comment}{// schedule slot in n+3th subframe for UL}
1096         \textcolor{comment}{// Create RB map (UL res alloc type 0)}
1097         std::vector <bool> rbMap;
1098   uint16\_t rbAllocatedNum = 0;
1099         std::set <uint16\_t> rntiAllocated;
1100         std::vector <uint16\_t> rbgAllocationMap;
1101         uint32\_t numRb = \hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->\hyperlink{classns3_1_1MmWavePhyMacCommon_a4c5f323fd722d6eec52efda5d76f97ad}{GetNumRb} ();
1102         rbMap.resize (numRb);
1103         rbgAllocationMap.resize (numRb);
1104         std::map<uint16\_t,SchedInfo>& schedInfoMap = ret.m\_schedInfoMap;
1105         uint32\_t sfn =  ((0x3FF & frameNum) << 16) | ((0xFF & sfNum) << 8) | (0xFF & (slotNum+1));
1106 
1107 
1108         \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1MmWaveRrMacScheduler_ad8bb79b5853000b363b42a158633a942}{m\_harqOn} == \textcolor{keyword}{true})
1109         \{
1110                 \textcolor{comment}{//   Process UL HARQ feedback}
1111                 \textcolor{keywordflow}{for} (uint16\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < params.m\_ulHarqInfoList.size (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
1112                 \{
1113                         \textcolor{keywordflow}{if} (params.m\_ulHarqInfoList.at (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}).m\_receptionStatus == 
      \hyperlink{structns3_1_1UlHarqInfo_af1ea9a1ce02c9b4a551ac978484a4336a488db5f30de0c73647fed90c4a994a83}{UlHarqInfo::NotOk})
1114                         \{
1115                                 \textcolor{comment}{// retx correspondent block: retrieve the UL-DCI}
1116                                 uint16\_t rnti = params.m\_ulHarqInfoList.at (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}).m\_rnti;
1117                                 std::map <uint16\_t, uint8\_t>::iterator itProcId = 
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_a9d9d27b704770d34cb1ce158e9ed51ba}{m\_ulHarqCurrentProcessId}.find (rnti);
1118                                 \textcolor{keywordflow}{if} (itProcId == \hyperlink{classns3_1_1MmWaveRrMacScheduler_a9d9d27b704770d34cb1ce158e9ed51ba}{m\_ulHarqCurrentProcessId}.end ())
1119                                 \{
1120                                         \hyperlink{group__logging_ga0261a8db1d4ac5f79417d117634fd455}{NS\_LOG\_ERROR} (\textcolor{stringliteral}{"No info find in HARQ buffer for UE
       (might change eNB) "} << rnti);
1121                                 \}
1122                                 uint8\_t harqId = (*itProcId).second;
1123                                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" UL-HARQ retx RNTI "} << rnti << \textcolor{stringliteral}{" harqId "}
       << (uint16\_t)harqId);
1124                                 std::map <uint16\_t, UlHarqProcessesTbInfoList\_t>::iterator itHarq = 
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_a3fb20c8b0644fdd05f5545ec0b685b10}{m\_ulHarqProcessesTbInfoMap}.find (rnti);
1125                                 \textcolor{keywordflow}{if} (itHarq == \hyperlink{classns3_1_1MmWaveRrMacScheduler_a3fb20c8b0644fdd05f5545ec0b685b10}{m\_ulHarqProcessesTbInfoMap}.end ())
1126                                 \{
1127                                         \hyperlink{group__logging_ga0261a8db1d4ac5f79417d117634fd455}{NS\_LOG\_ERROR} (\textcolor{stringliteral}{"No info find in UL-HARQ buffer for UE
       (might change eNB) "} << rnti);
1128                                 \}
1129                                 TbInfoElement harqTbInfo = (*itHarq).second.at (harqId);
1130                                 std::map <uint16\_t, UlHarqProcessesStatus\_t>::iterator itStat = 
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_af963cfe7e5dc36fce45c16d60b506465}{m\_ulHarqProcessesStatus}.find (rnti);
1131                                 \textcolor{keywordflow}{if} (itStat == \hyperlink{classns3_1_1MmWaveRrMacScheduler_af963cfe7e5dc36fce45c16d60b506465}{m\_ulHarqProcessesStatus}.end ())
1132                                 \{
1133                                         \hyperlink{group__logging_ga0261a8db1d4ac5f79417d117634fd455}{NS\_LOG\_ERROR} (\textcolor{stringliteral}{"No info find in HARQ buffer for UE
       (might change eNB) "} << rnti);
1134                                 \}
1135                                 \textcolor{keywordflow}{if} ((*itStat).second.at (harqId) > 3)
1136                                 \{
1137                                         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Max number of retransmissions reached
       (UL)-> drop process"});
1138                                         \textcolor{keywordflow}{continue};
1139                                 \}
1140                                 \textcolor{keywordtype}{bool} free = \textcolor{keyword}{true};
1141                                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = harqTbInfo.m\_rbStart; j < harqTbInfo.m\_rbStart + harqTbInfo.
      m\_rbLen; j++)
1142                                 \{
1143                                         \textcolor{keywordflow}{if} (rbMap.at (j) == \textcolor{keyword}{true})
1144                                         \{
1145                                                 free = \textcolor{keyword}{false};
1146                                                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" BUSY "} << j);
1147                                         \}
1148                                 \}
1149                                 \textcolor{keywordflow}{if} (free)
1150                                 \{
1151                                         \textcolor{comment}{// retx on the same RBs}
1152                                         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = harqTbInfo.m\_rbStart; j < harqTbInfo.m\_rbStart + 
      harqTbInfo.m\_rbLen; j++)
1153                                         \{
1154                                                 rbMap.at (j) = \textcolor{keyword}{true};
1155                                                 rbgAllocationMap.at (j) = rnti;
1156                                                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)tRB "} << j);
1157                                                 rbAllocatedNum++;
1158                                         \}
1159                                         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" Send retx in the same RBGs "} << (
      uint16\_t)harqTbInfo.m\_rbStart << \textcolor{stringliteral}{" to "} << harqTbInfo.m\_rbStart + harqTbInfo.m\_rbLen << \textcolor{stringliteral}{" RV "} << (*itStat).
      second.at (harqId) + 1);
1160                                 \}
1161 \textcolor{comment}{//                              else}
1162 \textcolor{comment}{//                              \{}
1163 \textcolor{comment}{//                                      NS\_LOG\_INFO ("Cannot allocate retx due to RACH allocations for UE "
       << rnti);}
1164 \textcolor{comment}{//                                      continue;}
1165 \textcolor{comment}{//                              \}}
1166                                 harqTbInfo.m\_ndi = 0;
1167                                 harqTbInfo.m\_slotIdx = slotNum;
1168 
1169                                 std::map<uint16\_t, SchedInfo>::iterator schedIt = schedInfoMap.find (rnti);
1170                                 \textcolor{keywordflow}{if} (schedIt == schedInfoMap.end ())
1171                                 \{
1172                                         SchedInfo newSchedInfo (\hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->
      \hyperlink{classns3_1_1MmWavePhyMacCommon_a7b6552d2e0ffbeaf3bc2f9db6d0d6e63}{GetSlotsPerSubframe} ());
1173                                         newSchedInfo.m\_rnti = rnti;
1174                                         DciInfoElement newDci;
1175                                         newDci.m\_rnti = rnti;
1176                                         newDci.m\_tddBitmap = 0;
1177                                         newDci.m\_format = 0;
1178                                         newDci.m\_cceIndex = 0;
1179                                         \textcolor{comment}{//                              newDci.m\_harqProcess =
       UpdateHarqProcessId ((*it).m\_rnti);}
1180                                         newSchedInfo.m\_dci = newDci;
1181                                         newSchedInfo.m\_frameNum = frameNum;
1182                                         newSchedInfo.m\_sfNum = sfNum;
1183                                         schedIt = (schedInfoMap.insert (std::pair<uint16\_t,SchedInfo> (rnti
      , newSchedInfo))).first;
1184                                 \}
1185                                 SchedInfo& schedInfo = schedIt->second;
1186                                 schedInfo.m\_dci.m\_tddBitmap = (schedInfo.m\_dci.m\_tddBitmap | (0x1 << 
      slotNum)); \textcolor{comment}{// set bit for UL}
1187 
1188                                 \textcolor{comment}{// Update HARQ buffers with new HarqId}
1189                                 (*itStat).second.at ((*itProcId).second) = (*itStat).second.at (harqId) + 1
      ;
1190                                 (*itStat).second.at (harqId) = 0;
1191                                 (*itHarq).second.at ((*itProcId).second) = harqTbInfo;
1192                                 schedIt->second.m\_dci.m\_tbInfoElements.push\_back (harqTbInfo);
1193                                 success = \textcolor{keyword}{true};
1194                                 rntiAllocated.insert (rnti);
1195                         \}
1196                 \}
1197         \}
1198 
1199         std::map <uint16\_t,uint32\_t>::iterator it;
1200         \textcolor{keywordtype}{int} nflows = 0;
1201 
1202         \textcolor{keywordflow}{for} (it = \hyperlink{classns3_1_1MmWaveRrMacScheduler_a2ebec374f1ff5014f115ff8b68ff5ebb}{m\_ceBsrRxed}.begin (); it != \hyperlink{classns3_1_1MmWaveRrMacScheduler_a2ebec374f1ff5014f115ff8b68ff5ebb}{m\_ceBsrRxed}.end (); it++)
1203         \{
1204                 \textcolor{comment}{//                            std::set <uint16\_t>::iterator itRnti = rntiAllocated.find
       ((*it).first);}
1205                 \textcolor{comment}{//                            // select UEs with queues not empty and not yet allocated for
       HARQ}
1206                 \textcolor{comment}{//                            NS\_LOG\_INFO (this << " UE " << (*it).first << " queue " <<
       (*it).second);}
1207                 \textcolor{comment}{//                            if (((*it).second > 0)&&(itRnti == rntiAllocated.end ()))}
1208                 \textcolor{comment}{//                              \{}
1209                 \textcolor{comment}{//                                nflows++;}
1210                 \textcolor{comment}{//                              \}}
1211                 \textcolor{keywordflow}{if} ((*it).second > 0)
1212                 \{
1213                         nflows++;
1214                 \}
1215         \}
1216         \textcolor{keywordflow}{if} (nflows == 0)
1217         \{
1218                 \textcolor{keywordflow}{return} success;  \textcolor{comment}{// no UL flows to be scheduled}
1219         \}
1220 
1221         \textcolor{comment}{// Divide the remaining resources equally among the active users starting from after the one served
       last scheduling trigger}
1222         \textcolor{comment}{//                        uint16\_t rbPerFlow = numRbg / (nflows + rntiAllocated.size ());}
1223         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rbPerFlow = \hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->\hyperlink{classns3_1_1MmWavePhyMacCommon_a4c5f323fd722d6eec52efda5d76f97ad}{GetNumRb} () / nflows;
1224         \textcolor{keywordflow}{if} (rbPerFlow == 0)
1225         \{
1226                 rbPerFlow = 1;  \textcolor{comment}{// at least 1 rbg per flow (till available resource) to ensure
       TxOpportunity >= 7 bytes}
1227         \}
1228 
1229         \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1MmWaveRrMacScheduler_ac9c27bbc2f828923b14cbc3b6ed5be57}{m\_nextRntiUl} != 0)
1230         \{
1231                 \textcolor{keywordflow}{for} (it = \hyperlink{classns3_1_1MmWaveRrMacScheduler_a2ebec374f1ff5014f115ff8b68ff5ebb}{m\_ceBsrRxed}.begin (); it != \hyperlink{classns3_1_1MmWaveRrMacScheduler_a2ebec374f1ff5014f115ff8b68ff5ebb}{m\_ceBsrRxed}.end (); it++)
1232                 \{
1233                         \textcolor{keywordflow}{if} ((*it).first == \hyperlink{classns3_1_1MmWaveRrMacScheduler_ac9c27bbc2f828923b14cbc3b6ed5be57}{m\_nextRntiUl})
1234                         \{
1235                                 \textcolor{keywordflow}{break};
1236                         \}
1237                 \}
1238                 \textcolor{keywordflow}{if} (it == \hyperlink{classns3_1_1MmWaveRrMacScheduler_a2ebec374f1ff5014f115ff8b68ff5ebb}{m\_ceBsrRxed}.end ())
1239                 \{
1240                         \hyperlink{group__logging_ga0261a8db1d4ac5f79417d117634fd455}{NS\_LOG\_ERROR} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" no user found"});
1241                 \}
1242         \}
1243         \textcolor{keywordflow}{else}
1244         \{
1245                 it = \hyperlink{classns3_1_1MmWaveRrMacScheduler_a2ebec374f1ff5014f115ff8b68ff5ebb}{m\_ceBsrRxed}.begin ();
1246                 \hyperlink{classns3_1_1MmWaveRrMacScheduler_ac9c27bbc2f828923b14cbc3b6ed5be57}{m\_nextRntiUl} = (*it).first;
1247         \}
1248 
1249         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" NFlows "} << nflows << \textcolor{stringliteral}{" RB per Flow "} << rbPerFlow);
1250         \textcolor{keywordflow}{do}
1251         \{
1252                 \textcolor{comment}{/*std::set <uint16\_t>::iterator itRnti = rntiAllocated.find ((*it).first);}
1253 \textcolor{comment}{                                        if ((itRnti != rntiAllocated.end ())||((*it).second == 0))}
1254 \textcolor{comment}{                                        \{}
1255 \textcolor{comment}{                                                // UE already allocated for UL-HARQ -> skip it}
1256 \textcolor{comment}{                                                it++;}
1257 \textcolor{comment}{                                                if (it == m\_ceBsrRxed.end ())}
1258 \textcolor{comment}{                                                \{}
1259 \textcolor{comment}{                                                        // restart from the first}
1260 \textcolor{comment}{                                                        it = m\_ceBsrRxed.begin ();}
1261 \textcolor{comment}{                                                \}}
1262 \textcolor{comment}{                                                continue;}
1263 \textcolor{comment}{                                        \}*/}
1264                 \textcolor{comment}{//                              if (rbAllocated + rbPerFlow - 1 > numRb)}
1265                 \textcolor{comment}{//                              \{}
1266                 \textcolor{comment}{//                                      // limit to physical resources last resource
       assignment}
1267                 \textcolor{comment}{//                                      rbPerFlow = numRb - rbAllocated;}
1268                 \textcolor{comment}{//                                      // at least 3 rbg per flow to ensure TxOpportunity
       >= 7 bytes}
1269                 \textcolor{comment}{//                                      if (rbPerFlow < 1)}
1270                 \textcolor{comment}{//                                      \{}
1271                 \textcolor{comment}{//                                              // terminate allocation}
1272                 \textcolor{comment}{//                                              rbPerFlow = 0;}
1273                 \textcolor{comment}{//                                      \}}
1274                 \textcolor{comment}{//                              \}}
1275                 uint16\_t rnti = (*it).first;
1276                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" try to allocate "} << rnti);
1277                 \textcolor{comment}{// find existing or create new scheduling info element/DCI element}
1278                 std::map<uint16\_t,SchedInfo>::iterator schedIt = schedInfoMap.find (rnti);
1279                 \textcolor{keywordflow}{if} (schedIt == schedInfoMap.end ())
1280                 \{
1281                         SchedInfo newSchedInfo (\hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->
      \hyperlink{classns3_1_1MmWavePhyMacCommon_a7b6552d2e0ffbeaf3bc2f9db6d0d6e63}{GetSlotsPerSubframe} ());
1282                         newSchedInfo.m\_rnti = (*it).first;
1283                         DciInfoElement newDci;
1284                         newDci.m\_rnti = (*it).first;
1285                         newDci.m\_tddBitmap = 0;
1286                         \textcolor{comment}{//                              newDci.m\_harqProcess = UpdateHarqProcessId
       ((*it).m\_rnti);}
1287                         newSchedInfo.m\_dci = newDci;
1288                         newSchedInfo.m\_frameNum = frameNum;
1289                         newSchedInfo.m\_sfNum = sfNum;
1290                         schedIt = (schedInfoMap.insert (std::pair<uint16\_t,SchedInfo> ((*it).first, 
      newSchedInfo))).first;
1291                 \}
1292 
1293                 SchedInfo& schedInfo = schedIt->second;
1294                 TbInfoElement newTbInfoElem;
1295                 newTbInfoElem.m\_resAlloc = 0;
1296                 newTbInfoElem.m\_rbLen = rbPerFlow;
1297                 newTbInfoElem.m\_slotIdx = slotNum;
1298                 newTbInfoElem.m\_rbBitmap = 0;
1299                 newTbInfoElem.m\_rbShift = 0;
1300 
1301 
1302                 \textcolor{comment}{//                              UlDciListElement uldci;}
1303                 \textcolor{comment}{//                              uldci.m\_rnti = (*it).first;}
1304                 \textcolor{comment}{//                              uldci.m\_rbLen = rbPerFlow;}
1305 
1306                 \textcolor{keywordtype}{bool} allocated = \textcolor{keyword}{false};
1307                 uint16\_t rbAllocated = 0;
1308                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" RB Allocated "} << rbAllocated << \textcolor{stringliteral}{" rbPerFlow "} << 
      rbPerFlow << \textcolor{stringliteral}{" flows "} << nflows);
1309                 \textcolor{keywordflow}{while} ((!allocated)&&((numRb - rbAllocated + rbPerFlow ) > 1) && (rbPerFlow != 0))
1310                 \{
1311                         \textcolor{comment}{// check availability}
1312                         \textcolor{keywordtype}{bool} free = \textcolor{keyword}{true};
1313                         \textcolor{keywordflow}{for} (uint16\_t j = rbAllocated; j < rbAllocated + rbPerFlow; j++)
1314                         \{
1315                                 \textcolor{keywordflow}{if} (rbMap.at (j) == \textcolor{keyword}{true})
1316                                 \{
1317                                         free = \textcolor{keyword}{false};
1318                                         \textcolor{keywordflow}{break};
1319                                 \}
1320                         \}
1321                         \textcolor{keywordflow}{if} (free)
1322                         \{
1323                                 newTbInfoElem.m\_rbStart = rbAllocated;
1324 
1325                                 \textcolor{keywordflow}{for} (uint16\_t j = rbAllocated; j < rbAllocated + rbPerFlow; j++)
1326                                 \{
1327                                         rbMap.at (j) = \textcolor{keyword}{true};
1328                                         \textcolor{comment}{// store info on allocation for managing ul-cqi interpretation}
1329                                         rbgAllocationMap.at (j) = (*it).first;
1330                                         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"\(\backslash\)t rbAllocated "} << j);
1331                                 \}
1332                                 rbAllocated += rbPerFlow;
1333                                 allocated = \textcolor{keyword}{true};
1334                                 \textcolor{keywordflow}{break};
1335                         \}
1336                         rbAllocated++;
1337                         \textcolor{comment}{//                                      if (rbAllocated + rbPerFlow - 1 > numRb)}
1338                         \textcolor{comment}{//                                      \{}
1339                         \textcolor{comment}{//                                              // limit to physical resources last
       resource assignment}
1340                         \textcolor{comment}{//                                              rbPerFlow = numRb - rbAllocated;}
1341                         \textcolor{comment}{//                                              // at least 3 rbg per flow to
       ensure TxOpportunity >= 7 bytes}
1342                         \textcolor{comment}{//                                              if (rbPerFlow < 3)}
1343                         \textcolor{comment}{//                                              \{}
1344                         \textcolor{comment}{//                                                      // terminate allocation}
1345                         \textcolor{comment}{//                                                      rbPerFlow = 0;}
1346                         \textcolor{comment}{//                                              \}}
1347                         \textcolor{comment}{//                                      \}}
1348                 \}
1349                 \textcolor{keywordflow}{if} (!allocated)
1350                 \{
1351                         \textcolor{comment}{// unable to allocate new resource: finish scheduling}
1352                         \hyperlink{classns3_1_1MmWaveRrMacScheduler_ac9c27bbc2f828923b14cbc3b6ed5be57}{m\_nextRntiUl} = (*it).first;
1353                         \hyperlink{classns3_1_1MmWaveRrMacScheduler_aac1f8a8418e80a70a78e8fb710697588}{m\_allocationMaps}.insert (std::pair <uint32\_t, std::vector
       <uint16\_t> > (sfn, rbgAllocationMap));
1354 
1355                         \textcolor{keywordflow}{break};
1356                 \}
1357                 std::map <uint16\_t, std::vector <double> >::iterator itCqi = 
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_aeb890d54a9f369fe677a64efa78d2402}{m\_ueUlCqi}.find ((*it).first);
1358                 \textcolor{keywordtype}{int} cqi = 0;
1359                 \textcolor{keywordflow}{if} (itCqi == \hyperlink{classns3_1_1MmWaveRrMacScheduler_aeb890d54a9f369fe677a64efa78d2402}{m\_ueUlCqi}.end ())
1360                 \{
1361                         \textcolor{comment}{// no cqi info about this UE}
1362                         newTbInfoElem.m\_mcs = 0; \textcolor{comment}{// MCS 0 -> UL-AMC TBD}
1363                         \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" UE does not have UL-CQI "} << (*it).first );
1364                 \}
1365                 \textcolor{keywordflow}{else}
1366                 \{
1367                         \textcolor{comment}{// take the lowest CQI value (worst RB)}
1368                         \textcolor{keywordtype}{double} minSinr = (*itCqi).second.at (newTbInfoElem.m\_rbStart);
1369                         \textcolor{keywordflow}{for} (uint16\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = newTbInfoElem.m\_rbStart; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < newTbInfoElem.m\_rbStart + 
      newTbInfoElem.m\_rbLen; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
1370                         \{
1371                                 \textcolor{keywordflow}{if} ((*itCqi).second.at (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) < minSinr)
1372                                 \{
1373                                         minSinr = (*itCqi).second.at (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
1374                                 \}
1375                         \}
1376                         \textcolor{comment}{// translate SINR -> cqi: WILD ACK: same as DL}
1377                         \textcolor{keywordtype}{double} \hyperlink{generate__test__data__lte__sinr_8m_ad83eeb3a142285d1243a08c6b7026df8}{s} = log2 ( 1 + (
1378                                         std::pow (10, minSinr / 10 )  /
1379                                         ( (-std::log (5.0 * 0.00005 )) / 1.5) ));
1380 
1381 
1382                         cqi = \hyperlink{classns3_1_1MmWaveRrMacScheduler_abbcdddd7d8733f372963069e1d0395d3}{m\_amc}->GetCqiFromSpectralEfficiency (s);
1383                         \textcolor{keywordflow}{if} (cqi == 0)
1384                         \{
1385                                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"*** RNTI "} << schedInfo.m\_rnti << \textcolor{stringliteral}{" UL CQI out of
       range, skipping allocation in UL for slot "} << slotNum+1);
1386                                 it++;
1387                                 \textcolor{keywordflow}{if} (it == \hyperlink{classns3_1_1MmWaveRrMacScheduler_a2ebec374f1ff5014f115ff8b68ff5ebb}{m\_ceBsrRxed}.end ())
1388                                 \{
1389                                         \textcolor{comment}{// restart from the first}
1390                                         it = \hyperlink{classns3_1_1MmWaveRrMacScheduler_a2ebec374f1ff5014f115ff8b68ff5ebb}{m\_ceBsrRxed}.begin ();
1391                                 \}
1392                                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" UE discared for CQI=0, RNTI "} << 
      schedInfo.m\_rnti);
1393                                 \textcolor{comment}{// remove UE from allocation map}
1394                                 \textcolor{keywordflow}{for} (uint16\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = newTbInfoElem.m\_rbStart; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < newTbInfoElem.m\_rbStart + 
      newTbInfoElem.m\_rbLen; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
1395                                 \{
1396                                         rbgAllocationMap.at (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) = 0;
1397                                         rbMap.at (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) = 0;
1398                                 \}
1399                                 \textcolor{keywordflow}{continue}; \textcolor{comment}{// CQI == 0 means "out of range" (see table 7.2.3-1 of 36.213)}
1400                         \}
1401                         newTbInfoElem.m\_mcs = \hyperlink{classns3_1_1MmWaveRrMacScheduler_abbcdddd7d8733f372963069e1d0395d3}{m\_amc}->GetMcsFromCqi (cqi);
1402                 \}
1403                 MmWaveMacPduHeader macHeader;
1404                 newTbInfoElem.m\_tbSize = (\hyperlink{classns3_1_1MmWaveRrMacScheduler_abbcdddd7d8733f372963069e1d0395d3}{m\_amc}->GetTbSizeFromMcs (newTbInfoElem.m\_mcs, rbPerFlow) / 8
      ) - macHeader.GetSerializedSize (); \textcolor{comment}{// MCS 0 -> UL-AMC TBD}
1405 
1406                 \hyperlink{classns3_1_1MmWaveRrMacScheduler_a57725a4bd9ba6cfe462d804a131c0255}{UpdateUlRlcBufferInfo} (schedInfo.m\_rnti, newTbInfoElem.m\_tbSize);
1407                 newTbInfoElem.m\_ndi = 1;
1408                 schedInfo.m\_dci.m\_tddBitmap = (schedInfo.m\_dci.m\_tddBitmap | (0x1 << slotNum)); \textcolor{comment}{// set bit
       for UL}
1409                 newTbInfoElem.m\_harqProcess = \hyperlink{classns3_1_1MmWaveRrMacScheduler_addd7405298c9c95bf87ef2c32c3a477b}{UpdateUlHarqProcessId} (rnti);
1410                 \textcolor{comment}{//schedInfo.m\_rlcPduList.push\_back(std::vector<RlcPduInfo> ());  // vector to store RLC
       PDUs for new TB}
1411                 schedInfo.m\_dci.m\_tbInfoElements.push\_back (newTbInfoElem);
1412                 success = \textcolor{keyword}{true};
1413 
1414                 uint8\_t harqId = 0;
1415                 \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1MmWaveRrMacScheduler_ad8bb79b5853000b363b42a158633a942}{m\_harqOn} == \textcolor{keyword}{true})
1416                 \{
1417                         std::map <uint16\_t, uint8\_t>::iterator itProcId = 
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_a9d9d27b704770d34cb1ce158e9ed51ba}{m\_ulHarqCurrentProcessId}.find (schedInfo.m\_rnti);
1418                         \textcolor{keywordflow}{if} (itProcId == \hyperlink{classns3_1_1MmWaveRrMacScheduler_a9d9d27b704770d34cb1ce158e9ed51ba}{m\_ulHarqCurrentProcessId}.end ())
1419                         \{
1420                                 \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"No info find in HARQ buffer for UE "} << 
      schedInfo.m\_rnti);
1421                         \}
1422                         harqId = (*itProcId).second;
1423                         std::map <uint16\_t, UlHarqProcessesTbInfoList\_t>::iterator itHarqTbInfo = 
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_a3fb20c8b0644fdd05f5545ec0b685b10}{m\_ulHarqProcessesTbInfoMap}.find (schedInfo.m\_rnti);
1424                         \textcolor{keywordflow}{if} (itHarqTbInfo == \hyperlink{classns3_1_1MmWaveRrMacScheduler_a3fb20c8b0644fdd05f5545ec0b685b10}{m\_ulHarqProcessesTbInfoMap}.end ())
1425                         \{
1426                                 \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Unable to find RNTI entry in UL DCI HARQ
       buffer for RNTI "} << schedInfo.m\_rnti);
1427                         \}
1428                         (*itHarqTbInfo).second.at (harqId) = newTbInfoElem;
1429                         \textcolor{comment}{// Update HARQ process status (RV 0)}
1430                         std::map <uint16\_t, UlHarqProcessesStatus\_t>::iterator itStat = 
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_af963cfe7e5dc36fce45c16d60b506465}{m\_ulHarqProcessesStatus}.find (schedInfo.m\_rnti);
1431                         \textcolor{keywordflow}{if} (itStat == \hyperlink{classns3_1_1MmWaveRrMacScheduler_af963cfe7e5dc36fce45c16d60b506465}{m\_ulHarqProcessesStatus}.end ())
1432                         \{
1433                                 \hyperlink{group__logging_ga0261a8db1d4ac5f79417d117634fd455}{NS\_LOG\_ERROR} (\textcolor{stringliteral}{"No info find in HARQ buffer for UE (might change
       eNB) "} << schedInfo.m\_rnti);
1434                         \}
1435                         (*itStat).second.at (harqId) = 0;
1436                 \}
1437 
1438                 \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"UL Allocation frame "} << frameNum << \textcolor{stringliteral}{" subframe "} << sfNum << \textcolor{stringliteral}{"
       slot "} << slotNum+1 << \textcolor{stringliteral}{" "} << \textcolor{stringliteral}{" RNTI "} << schedInfo.m\_dci.m\_rnti << \textcolor{stringliteral}{" startPRB "} << (uint32\_t)newTbInfoElem.
      m\_rbStart << \textcolor{stringliteral}{" nPRB "} << (uint32\_t)newTbInfoElem.m\_rbLen << \textcolor{stringliteral}{" CQI "} << cqi << \textcolor{stringliteral}{" MCS "} << (uint32\_t)
      newTbInfoElem.m\_mcs << \textcolor{stringliteral}{" TBsize "} << newTbInfoElem.m\_tbSize << \textcolor{stringliteral}{" harqId "} << (uint16\_t)harqId);
1439 
1440                 it++;
1441                 \textcolor{keywordflow}{if} (it == \hyperlink{classns3_1_1MmWaveRrMacScheduler_a2ebec374f1ff5014f115ff8b68ff5ebb}{m\_ceBsrRxed}.end ())
1442                 \{
1443                         \textcolor{comment}{// restart from the first}
1444                         it = \hyperlink{classns3_1_1MmWaveRrMacScheduler_a2ebec374f1ff5014f115ff8b68ff5ebb}{m\_ceBsrRxed}.begin ();
1445                 \}
1446                 \textcolor{keywordflow}{if} ((rbAllocated == numRb) || (rbPerFlow == 0))
1447                 \{
1448                         \textcolor{comment}{// Stop allocation: no more PRBs}
1449                         \hyperlink{classns3_1_1MmWaveRrMacScheduler_ac9c27bbc2f828923b14cbc3b6ed5be57}{m\_nextRntiUl} = (*it).first;
1450                         \textcolor{keywordflow}{break};
1451                 \}
1452         \}
1453         \textcolor{keywordflow}{while} (((*it).first != \hyperlink{classns3_1_1MmWaveRrMacScheduler_ac9c27bbc2f828923b14cbc3b6ed5be57}{m\_nextRntiUl})&&(rbPerFlow!=0));
1454 
1455         \hyperlink{classns3_1_1MmWaveRrMacScheduler_aac1f8a8418e80a70a78e8fb710697588}{m\_allocationMaps}.insert (std::pair <uint32\_t, std::vector <uint16\_t> > (sfn, 
      rbgAllocationMap));
1456 
1457 \textcolor{comment}{//      std::cout << "Inserting rbgAllocationMap for sfn " << sfn << " frame " << frameNum << " subframe "
       << sfNum << " slot " << slotNum+1 << " ";}
1458 \textcolor{comment}{//      for (unsigned i = 0; i < rbgAllocationMap.size(); i++)}
1459 \textcolor{comment}{//      \{}
1460 \textcolor{comment}{//              std::cout << "RNTI " << rbgAllocationMap[i] << " ";}
1461 \textcolor{comment}{//      \}}
1462 \textcolor{comment}{//      std::cout << std::endl;}
1463 
1464         \textcolor{keywordflow}{return} success;
1465 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 16




Here is the caller graph for this function\+:
% FIG 17


\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Get\+Mac\+Sched\+Sap\+Provider@{Get\+Mac\+Sched\+Sap\+Provider}}
\index{Get\+Mac\+Sched\+Sap\+Provider@{Get\+Mac\+Sched\+Sap\+Provider}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Get\+Mac\+Sched\+Sap\+Provider()}{GetMacSchedSapProvider()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Mm\+Wave\+Mac\+Sched\+Sap\+Provider} $\ast$ ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Get\+Mac\+Sched\+Sap\+Provider (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a17add5325a0d6d1a249aa6fac8ec3cbc}{}\label{classns3_1_1MmWaveRrMacScheduler_a17add5325a0d6d1a249aa6fac8ec3cbc}


Implements \hyperlink{classns3_1_1MmWaveMacScheduler_ad6e09da1a42a74bdc5f4e812e04b9f5f}{ns3\+::\+Mm\+Wave\+Mac\+Scheduler}.


\begin{DoxyCode}
167 \{
168         \textcolor{keywordflow}{return} \hyperlink{classns3_1_1MmWaveRrMacScheduler_af7bd93ab339121af06c7594fb83654c4}{m\_macSchedSapProvider};
169 \}
\end{DoxyCode}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a9cc402ee93f6e866bfc290ad6bb3cc8d}{}\label{classns3_1_1MmWaveRrMacScheduler_a9cc402ee93f6e866bfc290ad6bb3cc8d}

\begin{DoxyCode}
140 \{
141         \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::MmWaveRrMacScheduler"})
142             .SetParent<\hyperlink{classns3_1_1MmWaveMacScheduler_aad32d6753e98fe1699402d1a722835c4}{MmWaveMacScheduler}> ()
143                 .AddConstructor<MmWaveRrMacScheduler> ()
144     .AddAttribute (\textcolor{stringliteral}{"CqiTimerThreshold"},
145                    \textcolor{stringliteral}{"The number of TTIs a CQI is valid (default 1000 - 1 sec.)"},
146                    UintegerValue (100),
147                    MakeUintegerAccessor (&
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_a21360d09f2e5e4b9fc304752aef8ae6a}{MmWaveRrMacScheduler::m\_cqiTimersThreshold}),
148                    MakeUintegerChecker<uint32\_t> ())
149     .AddAttribute (\textcolor{stringliteral}{"HarqEnabled"},
150                    \textcolor{stringliteral}{"Activate/Deactivate the HARQ [by default is active]."},
151                    BooleanValue (\textcolor{keyword}{false}),
152                    MakeBooleanAccessor (&\hyperlink{classns3_1_1MmWaveRrMacScheduler_ad8bb79b5853000b363b42a158633a942}{MmWaveRrMacScheduler::m\_harqOn}),
153                    MakeBooleanChecker ())
154                 ;
155 
156         \textcolor{keywordflow}{return} tid;
157 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 18


\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Refresh\+Dl\+Cqi\+Maps@{Refresh\+Dl\+Cqi\+Maps}}
\index{Refresh\+Dl\+Cqi\+Maps@{Refresh\+Dl\+Cqi\+Maps}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Refresh\+Dl\+Cqi\+Maps(void)}{RefreshDlCqiMaps(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Refresh\+Dl\+Cqi\+Maps (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a7e934e11a18ac6fccd3eb11e41693523}{}\label{classns3_1_1MmWaveRrMacScheduler_a7e934e11a18ac6fccd3eb11e41693523}

\begin{DoxyCode}
1583 \{
1584   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{classns3_1_1MmWaveRrMacScheduler_ae70383b2b2b66701ea96205d5ad60c41}{m\_wbCqiTimers}.size ());
1585   \textcolor{comment}{// refresh DL CQI P01 Map}
1586   std::map <uint16\_t,uint32\_t>::iterator itP10 = \hyperlink{classns3_1_1MmWaveRrMacScheduler_ae70383b2b2b66701ea96205d5ad60c41}{m\_wbCqiTimers}.begin ();
1587   \textcolor{keywordflow}{while} (itP10 != \hyperlink{classns3_1_1MmWaveRrMacScheduler_ae70383b2b2b66701ea96205d5ad60c41}{m\_wbCqiTimers}.end ())
1588     \{
1589       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" P10-CQI for user "} << (*itP10).first << \textcolor{stringliteral}{" is "} << (uint32\_t)
      (*itP10).second << \textcolor{stringliteral}{" thr "} << (uint32\_t)\hyperlink{classns3_1_1MmWaveRrMacScheduler_a21360d09f2e5e4b9fc304752aef8ae6a}{m\_cqiTimersThreshold});
1590       \textcolor{keywordflow}{if} ((*itP10).second == 0)
1591         \{
1592           \textcolor{comment}{// delete correspondent entries}
1593           std::map <uint16\_t,uint8\_t>::iterator itMap = \hyperlink{classns3_1_1MmWaveRrMacScheduler_ab048c846f6d5d71795b65b9f91c6766a}{m\_wbCqiRxed}.find ((*itP10).first);
1594           \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (itMap != \hyperlink{classns3_1_1MmWaveRrMacScheduler_ab048c846f6d5d71795b65b9f91c6766a}{m\_wbCqiRxed}.end (), \textcolor{stringliteral}{" Does not find CQI report
       for user "} << (*itP10).first);
1595           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" P10-CQI exired for user "} << (*itP10).first);
1596           \hyperlink{classns3_1_1MmWaveRrMacScheduler_ab048c846f6d5d71795b65b9f91c6766a}{m\_wbCqiRxed}.erase (itMap);
1597           std::map <uint16\_t,uint32\_t>::iterator temp = itP10;
1598           itP10++;
1599           \hyperlink{classns3_1_1MmWaveRrMacScheduler_ae70383b2b2b66701ea96205d5ad60c41}{m\_wbCqiTimers}.erase (temp);
1600         \}
1601       \textcolor{keywordflow}{else}
1602         \{
1603           (*itP10).second--;
1604           itP10++;
1605         \}
1606     \}
1607 
1608   \textcolor{keywordflow}{return};
1609 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 19


\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Refresh\+Harq\+Processes@{Refresh\+Harq\+Processes}}
\index{Refresh\+Harq\+Processes@{Refresh\+Harq\+Processes}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Refresh\+Harq\+Processes()}{RefreshHarqProcesses()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Refresh\+Harq\+Processes (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a5b4fe59b80549148440a6e5f3e05f8e6}{}\label{classns3_1_1MmWaveRrMacScheduler_a5b4fe59b80549148440a6e5f3e05f8e6}


Refresh H\+A\+RQ processes according to the timers. 


\begin{DoxyCode}
391 \{
392         \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
393 
394         std::map <uint16\_t, DlHarqProcessesTimer\_t>::iterator itTimers;
395         \textcolor{keywordflow}{for} (itTimers = \hyperlink{classns3_1_1MmWaveRrMacScheduler_aa52dc4680386f8ccf85d6b9c685463d1}{m\_dlHarqProcessesTimer}.begin (); itTimers != 
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_aa52dc4680386f8ccf85d6b9c685463d1}{m\_dlHarqProcessesTimer}.end (); itTimers ++)
396         \{
397                 \textcolor{keywordflow}{for} (uint16\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->
      \hyperlink{classns3_1_1MmWavePhyMacCommon_a40773d84172ebeb5aff125f56ebcc5ac}{GetNumHarqProcess} (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
398                 \{
399                         \textcolor{keywordflow}{if} ((*itTimers).second.at (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) == \hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->
      \hyperlink{classns3_1_1MmWavePhyMacCommon_a6a3b10cda74091e0579e24e3b4dbad80}{GetHarqTimeout} ())
400                         \{
401                                 \textcolor{comment}{// reset HARQ process}
402 
403                                 \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" Reset HARQ proc "} << 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} << \textcolor{stringliteral}{" for RNTI "} << (*itTimers).first);
404                                 std::map <uint16\_t, DlHarqProcessesStatus\_t>::iterator itStat = 
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_a5734289010d38bd8dfe04ed50ba99936}{m\_dlHarqProcessesStatus}.find ((*itTimers).first);
405                                 \textcolor{keywordflow}{if} (itStat == \hyperlink{classns3_1_1MmWaveRrMacScheduler_a5734289010d38bd8dfe04ed50ba99936}{m\_dlHarqProcessesStatus}.end ())
406                                 \{
407                                         \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"No Process Id Status found for this
       RNTI "} << (*itTimers).first);
408                                 \}
409                                 (*itStat).second.at (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) = 0;
410                                 (*itTimers).second.at (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) = 0;
411                         \}
412                         \textcolor{keywordflow}{else}
413                         \{
414                                 (*itTimers).second.at (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})++;
415                         \}
416                 \}
417         \}
418 
419 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 20




Here is the caller graph for this function\+:
% FIG 21


\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Refresh\+Ul\+Cqi\+Maps@{Refresh\+Ul\+Cqi\+Maps}}
\index{Refresh\+Ul\+Cqi\+Maps@{Refresh\+Ul\+Cqi\+Maps}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Refresh\+Ul\+Cqi\+Maps(void)}{RefreshUlCqiMaps(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Refresh\+Ul\+Cqi\+Maps (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a08bd59d628f7a0115392e00c9cf44c59}{}\label{classns3_1_1MmWaveRrMacScheduler_a08bd59d628f7a0115392e00c9cf44c59}

\begin{DoxyCode}
1614 \{
1615   \textcolor{comment}{// refresh UL CQI  Map}
1616   std::map <uint16\_t,uint32\_t>::iterator itUl = \hyperlink{classns3_1_1MmWaveRrMacScheduler_a48957bee7e937b6d8627194fa429a473}{m\_ueCqiTimers}.begin ();
1617   \textcolor{keywordflow}{while} (itUl != \hyperlink{classns3_1_1MmWaveRrMacScheduler_a48957bee7e937b6d8627194fa429a473}{m\_ueCqiTimers}.end ())
1618     \{
1619       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" UL-CQI for user "} << (*itUl).first << \textcolor{stringliteral}{" is "} << (uint32\_t)(*itUl).
      second << \textcolor{stringliteral}{" thr "} << (uint32\_t)\hyperlink{classns3_1_1MmWaveRrMacScheduler_a21360d09f2e5e4b9fc304752aef8ae6a}{m\_cqiTimersThreshold});
1620       \textcolor{keywordflow}{if} ((*itUl).second == 0)
1621         \{
1622           \textcolor{comment}{// delete correspondent entries}
1623           std::map <uint16\_t, std::vector <double> >::iterator itMap = \hyperlink{classns3_1_1MmWaveRrMacScheduler_aeb890d54a9f369fe677a64efa78d2402}{m\_ueUlCqi}.find ((*itUl).
      first);
1624           \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (itMap != \hyperlink{classns3_1_1MmWaveRrMacScheduler_aeb890d54a9f369fe677a64efa78d2402}{m\_ueUlCqi}.end (), \textcolor{stringliteral}{" Does not find CQI report for
       user "} << (*itUl).first);
1625           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" UL-CQI expired for user "} << (*itUl).first);
1626           (*itMap).second.clear ();
1627           \hyperlink{classns3_1_1MmWaveRrMacScheduler_aeb890d54a9f369fe677a64efa78d2402}{m\_ueUlCqi}.erase (itMap);
1628           std::map <uint16\_t,uint32\_t>::iterator temp = itUl;
1629           itUl++;
1630           \hyperlink{classns3_1_1MmWaveRrMacScheduler_a48957bee7e937b6d8627194fa429a473}{m\_ueCqiTimers}.erase (temp);
1631         \}
1632       \textcolor{keywordflow}{else}
1633         \{
1634           (*itUl).second--;
1635           itUl++;
1636         \}
1637     \}
1638 
1639   \textcolor{keywordflow}{return};
1640 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 22


\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Schedule\+Users\+In\+Time@{Schedule\+Users\+In\+Time}}
\index{Schedule\+Users\+In\+Time@{Schedule\+Users\+In\+Time}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Schedule\+Users\+In\+Time(uint32\+\_\+t slot\+Num)}{ScheduleUsersInTime(uint32_t slotNum)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Sf\+Alloc\+Info} ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Schedule\+Users\+In\+Time (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{slot\+Num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_aa81369a8badc00db9ad5259cadec7e82}{}\label{classns3_1_1MmWaveRrMacScheduler_aa81369a8badc00db9ad5259cadec7e82}


Here is the caller graph for this function\+:
% FIG 23


\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Set\+Mac\+Sched\+Sap\+User@{Set\+Mac\+Sched\+Sap\+User}}
\index{Set\+Mac\+Sched\+Sap\+User@{Set\+Mac\+Sched\+Sap\+User}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Set\+Mac\+Sched\+Sap\+User(\+Mm\+Wave\+Mac\+Sched\+Sap\+User $\ast$sap)}{SetMacSchedSapUser(MmWaveMacSchedSapUser *sap)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Set\+Mac\+Sched\+Sap\+User (
\begin{DoxyParamCaption}
\item[{{\bf Mm\+Wave\+Mac\+Sched\+Sap\+User} $\ast$}]{sap}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a455ebd26767f800f77dc1c8005cd7d3c}{}\label{classns3_1_1MmWaveRrMacScheduler_a455ebd26767f800f77dc1c8005cd7d3c}


Implements \hyperlink{classns3_1_1MmWaveMacScheduler_ad47bf0b6123724e70f1c2c889d50e5fb}{ns3\+::\+Mm\+Wave\+Mac\+Scheduler}.


\begin{DoxyCode}
161 \{
162         \hyperlink{classns3_1_1MmWaveRrMacScheduler_a5f6adc4e7eabd10266ede796be0d1bca}{m\_macSchedSapUser} = sap;
163 \}
\end{DoxyCode}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Set\+Schedule\+Direction@{Set\+Schedule\+Direction}}
\index{Set\+Schedule\+Direction@{Set\+Schedule\+Direction}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Set\+Schedule\+Direction(std\+::string patt)}{SetScheduleDirection(std::string patt)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Set\+Schedule\+Direction (
\begin{DoxyParamCaption}
\item[{std\+::string}]{patt}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a3c009919ec557272944849b0da580c10}{}\label{classns3_1_1MmWaveRrMacScheduler_a3c009919ec557272944849b0da580c10}

\begin{DoxyCode}
366 \{
367         uint16\_t ctrlCount = 0;
368 
369         \textcolor{keywordflow}{for} (uint16\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}<patt.length(); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
370         \{
371                 \textcolor{keywordflow}{if} (patt.at(\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) == \textcolor{charliteral}{'c'})
372                 \{
373                         std::string ch = ((ctrlCount%2 == 0) ? \textcolor{stringliteral}{"D"}:\textcolor{stringliteral}{"U"});
374                         \hyperlink{classns3_1_1MmWaveRrMacScheduler_ac4c00a9f08cd90ac861753f28c9d6a69}{m\_directions}+= (ch);
375                         ctrlCount++;
376                 \}
377                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (patt.at(\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) == \textcolor{charliteral}{'d'})
378                 \{
379                         std::string ch1 = ( (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < (patt.length () + ctrlCount)/2) ? \textcolor{stringliteral}{"D"} : \textcolor{stringliteral}{"U"});
380                         \hyperlink{classns3_1_1MmWaveRrMacScheduler_ac4c00a9f08cd90ac861753f28c9d6a69}{m\_directions}+=  ch1;
381                 \}
382         \}
383 
384         \hyperlink{classns3_1_1MmWaveRrMacScheduler_ac45c41dd1fc03ca53d6580cf1dfca939}{m\_isDirnUpdated} = \textcolor{keyword}{true};\textcolor{comment}{/*}
385 \textcolor{comment}{        m\_directions = "CCDDDUUU";}
386 \textcolor{comment}{        m\_isDirnUpdated = true;*/}
387 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 24


\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Set\+T\+B\+Size\+Assigned@{Set\+T\+B\+Size\+Assigned}}
\index{Set\+T\+B\+Size\+Assigned@{Set\+T\+B\+Size\+Assigned}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Set\+T\+B\+Size\+Assigned()}{SetTBSizeAssigned()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Set\+T\+B\+Size\+Assigned (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_ac0c71520f7ed311a0d99dfed182faf66}{}\label{classns3_1_1MmWaveRrMacScheduler_ac0c71520f7ed311a0d99dfed182faf66}


Here is the caller graph for this function\+:
% FIG 25


\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Sort\+Rlc\+Buffer\+Req@{Sort\+Rlc\+Buffer\+Req}}
\index{Sort\+Rlc\+Buffer\+Req@{Sort\+Rlc\+Buffer\+Req}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Sort\+Rlc\+Buffer\+Req(\+Mm\+Wave\+Mac\+Sched\+Sap\+Provider\+::\+Sched\+Dl\+Rlc\+Buffer\+Req\+Parameters i, Mm\+Wave\+Mac\+Sched\+Sap\+Provider\+::\+Sched\+Dl\+Rlc\+Buffer\+Req\+Parameters j)}{SortRlcBufferReq(MmWaveMacSchedSapProvider::SchedDlRlcBufferReqParameters i, MmWaveMacSchedSapProvider::SchedDlRlcBufferReqParameters j)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Sort\+Rlc\+Buffer\+Req (
\begin{DoxyParamCaption}
\item[{{\bf Mm\+Wave\+Mac\+Sched\+Sap\+Provider\+::\+Sched\+Dl\+Rlc\+Buffer\+Req\+Parameters}}]{i, }
\item[{{\bf Mm\+Wave\+Mac\+Sched\+Sap\+Provider\+::\+Sched\+Dl\+Rlc\+Buffer\+Req\+Parameters}}]{j}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_ae0fee4909466a1900ad3d92b6b6fe3e2}{}\label{classns3_1_1MmWaveRrMacScheduler_ae0fee4909466a1900ad3d92b6b6fe3e2}

\begin{DoxyCode}
1576 \{
1577   \textcolor{keywordflow}{return} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}.m\_rnti < j.m\_rnti);
1578 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 26


\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Update\+Dl\+Harq\+Process\+Id@{Update\+Dl\+Harq\+Process\+Id}}
\index{Update\+Dl\+Harq\+Process\+Id@{Update\+Dl\+Harq\+Process\+Id}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Update\+Dl\+Harq\+Process\+Id(uint16\+\_\+t rnti)}{UpdateDlHarqProcessId(uint16_t rnti)}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Update\+Dl\+Harq\+Process\+Id (
\begin{DoxyParamCaption}
\item[{uint16\+\_\+t}]{rnti}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a0c01cd018ece348fa17da5babacd3bae}{}\label{classns3_1_1MmWaveRrMacScheduler_a0c01cd018ece348fa17da5babacd3bae}

\begin{DoxyCode}
423 \{
424   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << rnti);
425 
426 
427   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1MmWaveRrMacScheduler_ad8bb79b5853000b363b42a158633a942}{m\_harqOn} == \textcolor{keyword}{false})
428     \{
429                 uint8\_t tbUid = \hyperlink{classns3_1_1MmWaveRrMacScheduler_a379f6c5cc3404d41c4082879498fc38b}{m\_tbUid};
430                 \hyperlink{classns3_1_1MmWaveRrMacScheduler_a379f6c5cc3404d41c4082879498fc38b}{m\_tbUid} = (\hyperlink{classns3_1_1MmWaveRrMacScheduler_a379f6c5cc3404d41c4082879498fc38b}{m\_tbUid}+1) % \hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->
      \hyperlink{classns3_1_1MmWavePhyMacCommon_a40773d84172ebeb5aff125f56ebcc5ac}{GetNumHarqProcess} ();
431       \textcolor{keywordflow}{return} tbUid;
432     \}
433 
434   std::map <uint16\_t, uint8\_t>::iterator it = \hyperlink{classns3_1_1MmWaveRrMacScheduler_a6ff50e3af4095ffc47155de7d30c8d6d}{m\_dlHarqCurrentProcessId}.find (rnti);
435   \textcolor{keywordflow}{if} (it == \hyperlink{classns3_1_1MmWaveRrMacScheduler_a6ff50e3af4095ffc47155de7d30c8d6d}{m\_dlHarqCurrentProcessId}.end ())
436     \{
437       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"No Process Id found for this RNTI "} << rnti);
438     \}
439   std::map <uint16\_t, DlHarqProcessesStatus\_t>::iterator itStat = 
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_a5734289010d38bd8dfe04ed50ba99936}{m\_dlHarqProcessesStatus}.find (rnti);
440   \textcolor{keywordflow}{if} (itStat == \hyperlink{classns3_1_1MmWaveRrMacScheduler_a5734289010d38bd8dfe04ed50ba99936}{m\_dlHarqProcessesStatus}.end ())
441     \{
442       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"No Process Id Statusfound for this RNTI "} << rnti);
443     \}
444   uint8\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = (*it).second;
445   \textcolor{keywordflow}{do}
446     \{
447       i = (i + 1) % \hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->\hyperlink{classns3_1_1MmWavePhyMacCommon_a40773d84172ebeb5aff125f56ebcc5ac}{GetNumHarqProcess} ();
448     \}
449   \textcolor{keywordflow}{while} ( ((*itStat).second.at (i) != 0)&&(i != (*it).second));
450   \textcolor{keywordflow}{if} ((*itStat).second.at (i) == 0)
451     \{
452       (*it).second = \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
453       (*itStat).second.at (i) = 1;
454     \}
455   \textcolor{keywordflow}{else}
456     \{
457       \textcolor{keywordflow}{return} (\hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->\hyperlink{classns3_1_1MmWavePhyMacCommon_a40773d84172ebeb5aff125f56ebcc5ac}{GetNumHarqProcess} () + 1); \textcolor{comment}{// return a not
       valid harq proc id}
458     \}
459 
460   \textcolor{keywordflow}{return} ((*it).second);
461 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 27




Here is the caller graph for this function\+:
% FIG 28


\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Update\+Dl\+Rlc\+Buffer\+Info@{Update\+Dl\+Rlc\+Buffer\+Info}}
\index{Update\+Dl\+Rlc\+Buffer\+Info@{Update\+Dl\+Rlc\+Buffer\+Info}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Update\+Dl\+Rlc\+Buffer\+Info(uint16\+\_\+t rnti, uint8\+\_\+t lcid, uint16\+\_\+t size)}{UpdateDlRlcBufferInfo(uint16_t rnti, uint8_t lcid, uint16_t size)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Update\+Dl\+Rlc\+Buffer\+Info (
\begin{DoxyParamCaption}
\item[{uint16\+\_\+t}]{rnti, }
\item[{uint8\+\_\+t}]{lcid, }
\item[{uint16\+\_\+t}]{size}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a005e51f10e6d477bf11d6993f081ed24}{}\label{classns3_1_1MmWaveRrMacScheduler_a005e51f10e6d477bf11d6993f081ed24}

\begin{DoxyCode}
1644 \{
1645   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1646   std::list<MmWaveMacSchedSapProvider::SchedDlRlcBufferReqParameters>::iterator it;
1647   \textcolor{keywordflow}{for} (it = \hyperlink{classns3_1_1MmWaveRrMacScheduler_a4808ca626b0b12682c3f1a079d016997}{m\_rlcBufferReq}.begin (); it != \hyperlink{classns3_1_1MmWaveRrMacScheduler_a4808ca626b0b12682c3f1a079d016997}{m\_rlcBufferReq}.end (); it++)
1648     \{
1649       \textcolor{keywordflow}{if} (((*it).m\_rnti == rnti) && ((*it).m\_logicalChannelIdentity == lcid))
1650         \{
1651           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" UE "} << rnti << \textcolor{stringliteral}{" LC "} << (uint16\_t)lcid << \textcolor{stringliteral}{" txqueue "} << 
      (*it).m\_rlcTransmissionQueueSize << \textcolor{stringliteral}{" retxqueue "} << (*it).m\_rlcRetransmissionQueueSize << \textcolor{stringliteral}{" status "} << (*it).
      m\_rlcStatusPduSize << \textcolor{stringliteral}{" decrease "} << size);
1652           \textcolor{comment}{// Update queues: RLC tx order Status, ReTx, Tx}
1653           \textcolor{comment}{// Update status queue}
1654            \textcolor{keywordflow}{if} (((*it).m\_rlcStatusPduSize > 0) && (size >= (*it).m\_rlcStatusPduSize))
1655               \{
1656                 (*it).m\_rlcStatusPduSize = 0;
1657               \}
1658             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (((*it).m\_rlcRetransmissionQueueSize > 0) && (size >= (*it).
      m\_rlcRetransmissionQueueSize))
1659               \{
1660                 (*it).m\_rlcRetransmissionQueueSize = 0;
1661               \}
1662             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((*it).m\_rlcTransmissionQueueSize > 0)
1663               \{
1664                 uint32\_t rlcOverhead;
1665                 \textcolor{keywordflow}{if} (lcid == 1)
1666                   \{
1667                     \textcolor{comment}{// for SRB1 (using RLC AM) it's better to}
1668                     \textcolor{comment}{// overestimate RLC overhead rather than}
1669                     \textcolor{comment}{// underestimate it and risk unneeded}
1670                     \textcolor{comment}{// segmentation which increases delay}
1671                     rlcOverhead = 4;
1672                   \}
1673                 \textcolor{keywordflow}{else}
1674                   \{
1675                     \textcolor{comment}{// minimum RLC overhead due to header}
1676                     rlcOverhead = 2;
1677                   \}
1678                 \textcolor{comment}{// update transmission queue}
1679                 \textcolor{keywordflow}{if} ((*it).m\_rlcTransmissionQueueSize <= size - rlcOverhead)
1680                   \{
1681                     (*it).m\_rlcTransmissionQueueSize = 0;
1682                   \}
1683                 \textcolor{keywordflow}{else}
1684                   \{
1685                     (*it).m\_rlcTransmissionQueueSize -= size - rlcOverhead;
1686                   \}
1687               \}
1688           \textcolor{keywordflow}{return};
1689         \}
1690     \}
1691 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 29


\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Update\+Ul\+Harq\+Process\+Id@{Update\+Ul\+Harq\+Process\+Id}}
\index{Update\+Ul\+Harq\+Process\+Id@{Update\+Ul\+Harq\+Process\+Id}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Update\+Ul\+Harq\+Process\+Id(uint16\+\_\+t rnti)}{UpdateUlHarqProcessId(uint16_t rnti)}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Update\+Ul\+Harq\+Process\+Id (
\begin{DoxyParamCaption}
\item[{uint16\+\_\+t}]{rnti}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_addd7405298c9c95bf87ef2c32c3a477b}{}\label{classns3_1_1MmWaveRrMacScheduler_addd7405298c9c95bf87ef2c32c3a477b}

\begin{DoxyCode}
465 \{
466   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << rnti);
467 
468 
469   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1MmWaveRrMacScheduler_ad8bb79b5853000b363b42a158633a942}{m\_harqOn} == \textcolor{keyword}{false})
470   \{
471         uint8\_t tbUid = \hyperlink{classns3_1_1MmWaveRrMacScheduler_a379f6c5cc3404d41c4082879498fc38b}{m\_tbUid};
472         \hyperlink{classns3_1_1MmWaveRrMacScheduler_a379f6c5cc3404d41c4082879498fc38b}{m\_tbUid} = (\hyperlink{classns3_1_1MmWaveRrMacScheduler_a379f6c5cc3404d41c4082879498fc38b}{m\_tbUid}+1) % \hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->
      \hyperlink{classns3_1_1MmWavePhyMacCommon_a40773d84172ebeb5aff125f56ebcc5ac}{GetNumHarqProcess} ();
473         \textcolor{keywordflow}{return} tbUid;
474   \}
475 
476   std::map <uint16\_t, uint8\_t>::iterator it = \hyperlink{classns3_1_1MmWaveRrMacScheduler_a9d9d27b704770d34cb1ce158e9ed51ba}{m\_ulHarqCurrentProcessId}.find (rnti);
477   \textcolor{keywordflow}{if} (it == \hyperlink{classns3_1_1MmWaveRrMacScheduler_a9d9d27b704770d34cb1ce158e9ed51ba}{m\_ulHarqCurrentProcessId}.end ())
478     \{
479       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"No Process Id found for this RNTI "} << rnti);
480     \}
481   std::map <uint16\_t, DlHarqProcessesStatus\_t>::iterator itStat = 
      \hyperlink{classns3_1_1MmWaveRrMacScheduler_af963cfe7e5dc36fce45c16d60b506465}{m\_ulHarqProcessesStatus}.find (rnti);
482   \textcolor{keywordflow}{if} (itStat == \hyperlink{classns3_1_1MmWaveRrMacScheduler_af963cfe7e5dc36fce45c16d60b506465}{m\_ulHarqProcessesStatus}.end ())
483     \{
484       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"No Process Id Statusfound for this RNTI "} << rnti);
485     \}
486   uint8\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = (*it).second;
487   \textcolor{keywordflow}{do}
488     \{
489       i = (i + 1) % \hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->\hyperlink{classns3_1_1MmWavePhyMacCommon_a40773d84172ebeb5aff125f56ebcc5ac}{GetNumHarqProcess} ();
490     \}
491   \textcolor{keywordflow}{while} ( ((*itStat).second.at (i) != 0)&&(i != (*it).second));
492   \textcolor{keywordflow}{if} ((*itStat).second.at (i) == 0)
493     \{
494       (*it).second = \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
495       (*itStat).second.at (i) = 1;
496     \}
497   \textcolor{keywordflow}{else}
498     \{
499       \textcolor{keywordflow}{return} (\hyperlink{classns3_1_1MmWaveMacScheduler_a24d7af4971d2e500fe543cefbafa2fd9}{m\_phyMacConfig}->\hyperlink{classns3_1_1MmWavePhyMacCommon_a40773d84172ebeb5aff125f56ebcc5ac}{GetNumHarqProcess} () + 1); \textcolor{comment}{// return a not
       valid harq proc id}
500     \}
501 
502   \textcolor{keywordflow}{return} ((*it).second);
503 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 30




Here is the caller graph for this function\+:
% FIG 31


\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Update\+Ul\+Rlc\+Buffer\+Info@{Update\+Ul\+Rlc\+Buffer\+Info}}
\index{Update\+Ul\+Rlc\+Buffer\+Info@{Update\+Ul\+Rlc\+Buffer\+Info}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Update\+Ul\+Rlc\+Buffer\+Info(uint16\+\_\+t rnti, uint16\+\_\+t size)}{UpdateUlRlcBufferInfo(uint16_t rnti, uint16_t size)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::\+Update\+Ul\+Rlc\+Buffer\+Info (
\begin{DoxyParamCaption}
\item[{uint16\+\_\+t}]{rnti, }
\item[{uint16\+\_\+t}]{size}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a57725a4bd9ba6cfe462d804a131c0255}{}\label{classns3_1_1MmWaveRrMacScheduler_a57725a4bd9ba6cfe462d804a131c0255}

\begin{DoxyCode}
1695 \{
1696 
1697   size = size - 2; \textcolor{comment}{// remove the minimum RLC overhead}
1698   std::map <uint16\_t,uint32\_t>::iterator it = \hyperlink{classns3_1_1MmWaveRrMacScheduler_a2ebec374f1ff5014f115ff8b68ff5ebb}{m\_ceBsrRxed}.find (rnti);
1699   \textcolor{keywordflow}{if} (it != \hyperlink{classns3_1_1MmWaveRrMacScheduler_a2ebec374f1ff5014f115ff8b68ff5ebb}{m\_ceBsrRxed}.end ())
1700     \{
1701       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" Update RLC BSR UE "} << rnti << \textcolor{stringliteral}{" size "} << size << \textcolor{stringliteral}{" BSR "} << (*it)
      .second);
1702       \textcolor{keywordflow}{if} ((*it).second >= size)
1703         \{
1704           (*it).second -= size;
1705         \}
1706       \textcolor{keywordflow}{else}
1707         \{
1708           (*it).second = 0;
1709         \}
1710     \}
1711   \textcolor{keywordflow}{else}
1712     \{
1713       \hyperlink{group__logging_ga0261a8db1d4ac5f79417d117634fd455}{NS\_LOG\_ERROR} (\textcolor{keyword}{this} << \textcolor{stringliteral}{" Does not find BSR report info of UE "} << rnti);
1714     \}
1715 
1716 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 32




\subsection{Friends And Related Function Documentation}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!Mm\+Wave\+Rr\+Mac\+Sched\+Sap\+Provider@{Mm\+Wave\+Rr\+Mac\+Sched\+Sap\+Provider}}
\index{Mm\+Wave\+Rr\+Mac\+Sched\+Sap\+Provider@{Mm\+Wave\+Rr\+Mac\+Sched\+Sap\+Provider}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{Mm\+Wave\+Rr\+Mac\+Sched\+Sap\+Provider}{MmWaveRrMacSchedSapProvider}}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf Mm\+Wave\+Rr\+Mac\+Sched\+Sap\+Provider}\hspace{0.3cm}{\ttfamily [friend]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a2753d5040bae8b11d6b7975e70a2c811}{}\label{classns3_1_1MmWaveRrMacScheduler_a2753d5040bae8b11d6b7975e70a2c811}


\subsection{Member Data Documentation}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+allocation\+Maps@{m\+\_\+allocation\+Maps}}
\index{m\+\_\+allocation\+Maps@{m\+\_\+allocation\+Maps}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+allocation\+Maps}{m_allocationMaps}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<$uint32\+\_\+t, std\+::vector $<$uint16\+\_\+t$>$ $>$ ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+allocation\+Maps\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_aac1f8a8418e80a70a78e8fb710697588}{}\label{classns3_1_1MmWaveRrMacScheduler_aac1f8a8418e80a70a78e8fb710697588}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+amc@{m\+\_\+amc}}
\index{m\+\_\+amc@{m\+\_\+amc}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+amc}{m_amc}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Mm\+Wave\+Amc}$>$ ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+amc\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_abbcdddd7d8733f372963069e1d0395d3}{}\label{classns3_1_1MmWaveRrMacScheduler_abbcdddd7d8733f372963069e1d0395d3}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+ce\+Bsr\+Rxed@{m\+\_\+ce\+Bsr\+Rxed}}
\index{m\+\_\+ce\+Bsr\+Rxed@{m\+\_\+ce\+Bsr\+Rxed}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+ce\+Bsr\+Rxed}{m_ceBsrRxed}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<$uint16\+\_\+t,uint32\+\_\+t$>$ ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+ce\+Bsr\+Rxed\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a2ebec374f1ff5014f115ff8b68ff5ebb}{}\label{classns3_1_1MmWaveRrMacScheduler_a2ebec374f1ff5014f115ff8b68ff5ebb}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+cqi\+Timers\+Threshold@{m\+\_\+cqi\+Timers\+Threshold}}
\index{m\+\_\+cqi\+Timers\+Threshold@{m\+\_\+cqi\+Timers\+Threshold}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+cqi\+Timers\+Threshold}{m_cqiTimersThreshold}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+cqi\+Timers\+Threshold\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a21360d09f2e5e4b9fc304752aef8ae6a}{}\label{classns3_1_1MmWaveRrMacScheduler_a21360d09f2e5e4b9fc304752aef8ae6a}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+directions@{m\+\_\+directions}}
\index{m\+\_\+directions@{m\+\_\+directions}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+directions}{m_directions}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+directions\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_ac4c00a9f08cd90ac861753f28c9d6a69}{}\label{classns3_1_1MmWaveRrMacScheduler_ac4c00a9f08cd90ac861753f28c9d6a69}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+dl\+Harq\+Current\+Process\+Id@{m\+\_\+dl\+Harq\+Current\+Process\+Id}}
\index{m\+\_\+dl\+Harq\+Current\+Process\+Id@{m\+\_\+dl\+Harq\+Current\+Process\+Id}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+dl\+Harq\+Current\+Process\+Id}{m_dlHarqCurrentProcessId}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<$uint16\+\_\+t, uint8\+\_\+t$>$ ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+dl\+Harq\+Current\+Process\+Id\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a6ff50e3af4095ffc47155de7d30c8d6d}{}\label{classns3_1_1MmWaveRrMacScheduler_a6ff50e3af4095ffc47155de7d30c8d6d}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+dl\+Harq\+Info\+List@{m\+\_\+dl\+Harq\+Info\+List}}
\index{m\+\_\+dl\+Harq\+Info\+List@{m\+\_\+dl\+Harq\+Info\+List}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+dl\+Harq\+Info\+List}{m_dlHarqInfoList}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<${\bf Dl\+Harq\+Info}$>$ ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+dl\+Harq\+Info\+List\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a1b1043d7f9994e2ee6a7e1b368e9d7a1}{}\label{classns3_1_1MmWaveRrMacScheduler_a1b1043d7f9994e2ee6a7e1b368e9d7a1}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+dl\+Harq\+Processes\+Rlc\+Pdu\+Map@{m\+\_\+dl\+Harq\+Processes\+Rlc\+Pdu\+Map}}
\index{m\+\_\+dl\+Harq\+Processes\+Rlc\+Pdu\+Map@{m\+\_\+dl\+Harq\+Processes\+Rlc\+Pdu\+Map}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+dl\+Harq\+Processes\+Rlc\+Pdu\+Map}{m_dlHarqProcessesRlcPduMap}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<$uint16\+\_\+t, {\bf Dl\+Harq\+Rlc\+Pdu\+List\+\_\+t}$>$ ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+dl\+Harq\+Processes\+Rlc\+Pdu\+Map\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a51e5c8d3c34be4e070f2fb3e621cd418}{}\label{classns3_1_1MmWaveRrMacScheduler_a51e5c8d3c34be4e070f2fb3e621cd418}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+dl\+Harq\+Processes\+Status@{m\+\_\+dl\+Harq\+Processes\+Status}}
\index{m\+\_\+dl\+Harq\+Processes\+Status@{m\+\_\+dl\+Harq\+Processes\+Status}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+dl\+Harq\+Processes\+Status}{m_dlHarqProcessesStatus}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<$uint16\+\_\+t, {\bf Dl\+Harq\+Processes\+Status\+\_\+t}$>$ ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+dl\+Harq\+Processes\+Status\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a5734289010d38bd8dfe04ed50ba99936}{}\label{classns3_1_1MmWaveRrMacScheduler_a5734289010d38bd8dfe04ed50ba99936}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+dl\+Harq\+Processes\+Tb\+Info\+Map@{m\+\_\+dl\+Harq\+Processes\+Tb\+Info\+Map}}
\index{m\+\_\+dl\+Harq\+Processes\+Tb\+Info\+Map@{m\+\_\+dl\+Harq\+Processes\+Tb\+Info\+Map}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+dl\+Harq\+Processes\+Tb\+Info\+Map}{m_dlHarqProcessesTbInfoMap}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<$uint16\+\_\+t, {\bf Dl\+Harq\+Processes\+Tb\+Info\+List\+\_\+t}$>$ ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+dl\+Harq\+Processes\+Tb\+Info\+Map\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a8d14c222701c0a57ecbd40a51d0391da}{}\label{classns3_1_1MmWaveRrMacScheduler_a8d14c222701c0a57ecbd40a51d0391da}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+dl\+Harq\+Processes\+Timer@{m\+\_\+dl\+Harq\+Processes\+Timer}}
\index{m\+\_\+dl\+Harq\+Processes\+Timer@{m\+\_\+dl\+Harq\+Processes\+Timer}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+dl\+Harq\+Processes\+Timer}{m_dlHarqProcessesTimer}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<$uint16\+\_\+t, {\bf Dl\+Harq\+Processes\+Timer\+\_\+t}$>$ ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+dl\+Harq\+Processes\+Timer\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_aa52dc4680386f8ccf85d6b9c685463d1}{}\label{classns3_1_1MmWaveRrMacScheduler_aa52dc4680386f8ccf85d6b9c685463d1}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+frame\+No@{m\+\_\+frame\+No}}
\index{m\+\_\+frame\+No@{m\+\_\+frame\+No}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+frame\+No}{m_frameNo}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+frame\+No\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_af6f030cab6b897d4d116df8d5ed2973c}{}\label{classns3_1_1MmWaveRrMacScheduler_af6f030cab6b897d4d116df8d5ed2973c}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+harq\+On@{m\+\_\+harq\+On}}
\index{m\+\_\+harq\+On@{m\+\_\+harq\+On}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+harq\+On}{m_harqOn}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+harq\+On\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_ad8bb79b5853000b363b42a158633a942}{}\label{classns3_1_1MmWaveRrMacScheduler_ad8bb79b5853000b363b42a158633a942}
m\+\_\+harq\+On when false inhibit te H\+A\+RQ mechanisms (by default active) \index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+harq\+Timeout@{m\+\_\+harq\+Timeout}}
\index{m\+\_\+harq\+Timeout@{m\+\_\+harq\+Timeout}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+harq\+Timeout}{m_harqTimeout}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+harq\+Timeout\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a77ec3d7f7e1cf5c72faba03fea768930}{}\label{classns3_1_1MmWaveRrMacScheduler_a77ec3d7f7e1cf5c72faba03fea768930}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+is\+Dirn\+Updated@{m\+\_\+is\+Dirn\+Updated}}
\index{m\+\_\+is\+Dirn\+Updated@{m\+\_\+is\+Dirn\+Updated}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+is\+Dirn\+Updated}{m_isDirnUpdated}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+is\+Dirn\+Updated\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_ac45c41dd1fc03ca53d6580cf1dfca939}{}\label{classns3_1_1MmWaveRrMacScheduler_ac45c41dd1fc03ca53d6580cf1dfca939}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+mac\+Sched\+Sap\+Provider@{m\+\_\+mac\+Sched\+Sap\+Provider}}
\index{m\+\_\+mac\+Sched\+Sap\+Provider@{m\+\_\+mac\+Sched\+Sap\+Provider}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+mac\+Sched\+Sap\+Provider}{m_macSchedSapProvider}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Mm\+Wave\+Mac\+Sched\+Sap\+Provider}$\ast$ ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+mac\+Sched\+Sap\+Provider\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_af7bd93ab339121af06c7594fb83654c4}{}\label{classns3_1_1MmWaveRrMacScheduler_af7bd93ab339121af06c7594fb83654c4}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+mac\+Sched\+Sap\+User@{m\+\_\+mac\+Sched\+Sap\+User}}
\index{m\+\_\+mac\+Sched\+Sap\+User@{m\+\_\+mac\+Sched\+Sap\+User}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+mac\+Sched\+Sap\+User}{m_macSchedSapUser}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Mm\+Wave\+Mac\+Sched\+Sap\+User}$\ast$ ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+mac\+Sched\+Sap\+User\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a5f6adc4e7eabd10266ede796be0d1bca}{}\label{classns3_1_1MmWaveRrMacScheduler_a5f6adc4e7eabd10266ede796be0d1bca}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+next\+Rnti\+Dl@{m\+\_\+next\+Rnti\+Dl}}
\index{m\+\_\+next\+Rnti\+Dl@{m\+\_\+next\+Rnti\+Dl}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+next\+Rnti\+Dl}{m_nextRntiDl}}]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+next\+Rnti\+Dl\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a0de8f79fecf022efca5e65228d35cca6}{}\label{classns3_1_1MmWaveRrMacScheduler_a0de8f79fecf022efca5e65228d35cca6}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+next\+Rnti\+Ul@{m\+\_\+next\+Rnti\+Ul}}
\index{m\+\_\+next\+Rnti\+Ul@{m\+\_\+next\+Rnti\+Ul}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+next\+Rnti\+Ul}{m_nextRntiUl}}]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+next\+Rnti\+Ul\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_ac9c27bbc2f828923b14cbc3b6ed5be57}{}\label{classns3_1_1MmWaveRrMacScheduler_ac9c27bbc2f828923b14cbc3b6ed5be57}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+num\+Chunks@{m\+\_\+num\+Chunks}}
\index{m\+\_\+num\+Chunks@{m\+\_\+num\+Chunks}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+num\+Chunks}{m_numChunks}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+num\+Chunks\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a400c28eae2329becd132ff0a462bfb3a}{}\label{classns3_1_1MmWaveRrMacScheduler_a400c28eae2329becd132ff0a462bfb3a}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+num\+Harq\+Process@{m\+\_\+num\+Harq\+Process}}
\index{m\+\_\+num\+Harq\+Process@{m\+\_\+num\+Harq\+Process}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+num\+Harq\+Process}{m_numHarqProcess}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+num\+Harq\+Process\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_aa123b20bcc92d47a9590e40eeaa30806}{}\label{classns3_1_1MmWaveRrMacScheduler_aa123b20bcc92d47a9590e40eeaa30806}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+rlc\+Buffer\+Req@{m\+\_\+rlc\+Buffer\+Req}}
\index{m\+\_\+rlc\+Buffer\+Req@{m\+\_\+rlc\+Buffer\+Req}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+rlc\+Buffer\+Req}{m_rlcBufferReq}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std\+::list}$<${\bf Mm\+Wave\+Mac\+Sched\+Sap\+Provider\+::\+Sched\+Dl\+Rlc\+Buffer\+Req\+Parameters}$>$ ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+rlc\+Buffer\+Req\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a4808ca626b0b12682c3f1a079d016997}{}\label{classns3_1_1MmWaveRrMacScheduler_a4808ca626b0b12682c3f1a079d016997}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+subframe\+No@{m\+\_\+subframe\+No}}
\index{m\+\_\+subframe\+No@{m\+\_\+subframe\+No}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+subframe\+No}{m_subframeNo}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+subframe\+No\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a5ec88f3d708e5ba3b2c4bfe478d458bc}{}\label{classns3_1_1MmWaveRrMacScheduler_a5ec88f3d708e5ba3b2c4bfe478d458bc}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+tb\+Uid@{m\+\_\+tb\+Uid}}
\index{m\+\_\+tb\+Uid@{m\+\_\+tb\+Uid}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+tb\+Uid}{m_tbUid}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+tb\+Uid\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a379f6c5cc3404d41c4082879498fc38b}{}\label{classns3_1_1MmWaveRrMacScheduler_a379f6c5cc3404d41c4082879498fc38b}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+tdd\+Bitmap@{m\+\_\+tdd\+Bitmap}}
\index{m\+\_\+tdd\+Bitmap@{m\+\_\+tdd\+Bitmap}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+tdd\+Bitmap}{m_tddBitmap}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+tdd\+Bitmap\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a68cb1fd503ce4845a2d0d83c6466e58a}{}\label{classns3_1_1MmWaveRrMacScheduler_a68cb1fd503ce4845a2d0d83c6466e58a}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+tdd\+Map@{m\+\_\+tdd\+Map}}
\index{m\+\_\+tdd\+Map@{m\+\_\+tdd\+Map}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+tdd\+Map}{m_tddMap}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tdd\+Slot\+Type\+List} ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+tdd\+Map\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_adbd5d8631590dbbb160aa707757cd75c}{}\label{classns3_1_1MmWaveRrMacScheduler_adbd5d8631590dbbb160aa707757cd75c}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+ue\+Cqi\+Timers@{m\+\_\+ue\+Cqi\+Timers}}
\index{m\+\_\+ue\+Cqi\+Timers@{m\+\_\+ue\+Cqi\+Timers}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+ue\+Cqi\+Timers}{m_ueCqiTimers}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<$uint16\+\_\+t, uint32\+\_\+t$>$ ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+ue\+Cqi\+Timers\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a48957bee7e937b6d8627194fa429a473}{}\label{classns3_1_1MmWaveRrMacScheduler_a48957bee7e937b6d8627194fa429a473}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+ue\+Ul\+Cqi@{m\+\_\+ue\+Ul\+Cqi}}
\index{m\+\_\+ue\+Ul\+Cqi@{m\+\_\+ue\+Ul\+Cqi}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+ue\+Ul\+Cqi}{m_ueUlCqi}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<$uint16\+\_\+t, std\+::vector $<$double$>$ $>$ ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+ue\+Ul\+Cqi\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_aeb890d54a9f369fe677a64efa78d2402}{}\label{classns3_1_1MmWaveRrMacScheduler_aeb890d54a9f369fe677a64efa78d2402}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+ul\+Harq\+Current\+Process\+Id@{m\+\_\+ul\+Harq\+Current\+Process\+Id}}
\index{m\+\_\+ul\+Harq\+Current\+Process\+Id@{m\+\_\+ul\+Harq\+Current\+Process\+Id}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+ul\+Harq\+Current\+Process\+Id}{m_ulHarqCurrentProcessId}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<$uint16\+\_\+t, uint8\+\_\+t$>$ ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+ul\+Harq\+Current\+Process\+Id\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a9d9d27b704770d34cb1ce158e9ed51ba}{}\label{classns3_1_1MmWaveRrMacScheduler_a9d9d27b704770d34cb1ce158e9ed51ba}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+ul\+Harq\+Processes\+Status@{m\+\_\+ul\+Harq\+Processes\+Status}}
\index{m\+\_\+ul\+Harq\+Processes\+Status@{m\+\_\+ul\+Harq\+Processes\+Status}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+ul\+Harq\+Processes\+Status}{m_ulHarqProcessesStatus}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<$uint16\+\_\+t, {\bf Ul\+Harq\+Processes\+Status\+\_\+t}$>$ ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+ul\+Harq\+Processes\+Status\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_af963cfe7e5dc36fce45c16d60b506465}{}\label{classns3_1_1MmWaveRrMacScheduler_af963cfe7e5dc36fce45c16d60b506465}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+ul\+Harq\+Processes\+Tb\+Info\+Map@{m\+\_\+ul\+Harq\+Processes\+Tb\+Info\+Map}}
\index{m\+\_\+ul\+Harq\+Processes\+Tb\+Info\+Map@{m\+\_\+ul\+Harq\+Processes\+Tb\+Info\+Map}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+ul\+Harq\+Processes\+Tb\+Info\+Map}{m_ulHarqProcessesTbInfoMap}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<$uint16\+\_\+t, {\bf Ul\+Harq\+Processes\+Tb\+Info\+List\+\_\+t}$>$ ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+ul\+Harq\+Processes\+Tb\+Info\+Map\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a3fb20c8b0644fdd05f5545ec0b685b10}{}\label{classns3_1_1MmWaveRrMacScheduler_a3fb20c8b0644fdd05f5545ec0b685b10}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+ul\+Sf\+Alloc\+Info@{m\+\_\+ul\+Sf\+Alloc\+Info}}
\index{m\+\_\+ul\+Sf\+Alloc\+Info@{m\+\_\+ul\+Sf\+Alloc\+Info}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+ul\+Sf\+Alloc\+Info}{m_ulSfAllocInfo}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std\+::list}$<${\bf Sf\+Alloc\+Info}$>$ ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+ul\+Sf\+Alloc\+Info\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_a330485babfcd56bfbea128ebe3b66daa}{}\label{classns3_1_1MmWaveRrMacScheduler_a330485babfcd56bfbea128ebe3b66daa}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+wb\+Cqi\+Rxed@{m\+\_\+wb\+Cqi\+Rxed}}
\index{m\+\_\+wb\+Cqi\+Rxed@{m\+\_\+wb\+Cqi\+Rxed}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+wb\+Cqi\+Rxed}{m_wbCqiRxed}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<$uint16\+\_\+t,uint8\+\_\+t$>$ ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+wb\+Cqi\+Rxed\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_ab048c846f6d5d71795b65b9f91c6766a}{}\label{classns3_1_1MmWaveRrMacScheduler_ab048c846f6d5d71795b65b9f91c6766a}
\index{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}!m\+\_\+wb\+Cqi\+Timers@{m\+\_\+wb\+Cqi\+Timers}}
\index{m\+\_\+wb\+Cqi\+Timers@{m\+\_\+wb\+Cqi\+Timers}!ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler@{ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler}}
\subsubsection[{\texorpdfstring{m\+\_\+wb\+Cqi\+Timers}{m_wbCqiTimers}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<$uint16\+\_\+t,uint32\+\_\+t$>$ ns3\+::\+Mm\+Wave\+Rr\+Mac\+Scheduler\+::m\+\_\+wb\+Cqi\+Timers\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1MmWaveRrMacScheduler_ae70383b2b2b66701ea96205d5ad60c41}{}\label{classns3_1_1MmWaveRrMacScheduler_ae70383b2b2b66701ea96205d5ad60c41}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
mmwave/model/\hyperlink{mmwave-rr-mac-scheduler_8h}{mmwave-\/rr-\/mac-\/scheduler.\+h}\item 
mmwave/model/\hyperlink{mmwave-rr-mac-scheduler_8cc}{mmwave-\/rr-\/mac-\/scheduler.\+cc}\end{DoxyCompactItemize}
