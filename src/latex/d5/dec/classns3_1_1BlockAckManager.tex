\hypertarget{classns3_1_1BlockAckManager}{}\section{ns3\+:\+:Block\+Ack\+Manager Class Reference}
\label{classns3_1_1BlockAckManager}\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}


Manages all block ack agreements for an originator station.  




{\ttfamily \#include $<$block-\/ack-\/manager.\+h$>$}



Collaboration diagram for ns3\+:\+:Block\+Ack\+Manager\+:
% FIG 0
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structns3_1_1BlockAckManager_1_1Item}{Item}
\end{DoxyCompactItemize}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classns3_1_1Callback}{Callback}$<$ void, const \hyperlink{classns3_1_1WifiMacHeader}{Wifi\+Mac\+Header} \& $>$ \hyperlink{classns3_1_1BlockAckManager_a982d21c899e65a7d1bdc181c8d6de2b4}{Tx\+Ok}
\item 
typedef \hyperlink{classns3_1_1Callback}{Callback}$<$ void, const \hyperlink{classns3_1_1WifiMacHeader}{Wifi\+Mac\+Header} \& $>$ \hyperlink{classns3_1_1BlockAckManager_a19b8dc1978e36f011ad60a91c1c7d09c}{Tx\+Failed}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1BlockAckManager_a7a966d4ae9c3f2172545b76b7ccb8206}{Block\+Ack\+Manager} ()
\item 
\hyperlink{classns3_1_1BlockAckManager_af825fcf5b5c34784c880d95f3d0764af}{$\sim$\+Block\+Ack\+Manager} ()
\item 
void \hyperlink{classns3_1_1BlockAckManager_a7f1b2bae83d50eb0999ed609075571a8}{Set\+Wifi\+Remote\+Station\+Manager} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1WifiRemoteStationManager}{Wifi\+Remote\+Station\+Manager} $>$ manager)
\item 
bool \hyperlink{classns3_1_1BlockAckManager_a4712688bb7764d576c87fd627d3d3aba}{Exists\+Agreement} (\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} recipient, uint8\+\_\+t tid) const 
\item 
bool \hyperlink{classns3_1_1BlockAckManager_ae13c4678f75ebfda7f63d0521878662b}{Exists\+Agreement\+In\+State} (\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} recipient, uint8\+\_\+t tid, \hyperlink{classns3_1_1OriginatorBlockAckAgreement_ab33ae8af8c458aca7437a472778e4761}{Originator\+Block\+Ack\+Agreement\+::\+State} state) const 
\item 
void \hyperlink{classns3_1_1BlockAckManager_a44483ff8e6011faf1190dc0f178e66b7}{Create\+Agreement} (const \hyperlink{classns3_1_1MgtAddBaRequestHeader}{Mgt\+Add\+Ba\+Request\+Header} $\ast$req\+Hdr, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} recipient)
\item 
void \hyperlink{classns3_1_1BlockAckManager_a4f2adf7575098ab82e1d94466cc9d18a}{Destroy\+Agreement} (\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} recipient, uint8\+\_\+t tid)
\item 
void \hyperlink{classns3_1_1BlockAckManager_ac5b719210486783186579641e599d362}{Update\+Agreement} (const \hyperlink{classns3_1_1MgtAddBaResponseHeader}{Mgt\+Add\+Ba\+Response\+Header} $\ast$resp\+Hdr, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} recipient)
\item 
void \hyperlink{classns3_1_1BlockAckManager_a0d30c0aa10a79c5cc7b06b19e956c5cc}{Store\+Packet} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, const \hyperlink{classns3_1_1WifiMacHeader}{Wifi\+Mac\+Header} \&hdr, \hyperlink{classns3_1_1Time}{Time} t\+Stamp)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{classns3_1_1BlockAckManager_a11266152bf97c5ed1a06410d6fda4cc9}{Get\+Next\+Packet} (\hyperlink{classns3_1_1WifiMacHeader}{Wifi\+Mac\+Header} \&hdr)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{classns3_1_1BlockAckManager_a27160e30a1652c3a2cf4c0fca44f4166}{Peek\+Next\+Packet} (\hyperlink{classns3_1_1WifiMacHeader}{Wifi\+Mac\+Header} \&hdr)
\item 
bool \hyperlink{classns3_1_1BlockAckManager_a361d518c0824a4b353336475cda25978}{Has\+Bar} (\hyperlink{structns3_1_1Bar}{Bar} \&bar)
\item 
bool \hyperlink{classns3_1_1BlockAckManager_aa4d33e4f453efea9967dc2ebb7142210}{Has\+Packets} (void) const 
\item 
void \hyperlink{classns3_1_1BlockAckManager_a9b24f21a11eb094fa683943b7fc3c747}{Notify\+Got\+Block\+Ack} (const \hyperlink{classns3_1_1CtrlBAckResponseHeader}{Ctrl\+B\+Ack\+Response\+Header} $\ast$block\+Ack, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} recipient, double rx\+Snr, \hyperlink{classns3_1_1WifiMode}{Wifi\+Mode} tx\+Mode, double data\+Snr)
\item 
uint32\+\_\+t \hyperlink{classns3_1_1BlockAckManager_af1da67d0de14b53997fbeedaa93f7380}{Get\+N\+Buffered\+Packets} (\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} recipient, uint8\+\_\+t tid) const 
\item 
uint32\+\_\+t \hyperlink{classns3_1_1BlockAckManager_a324cd181a4aedaff46eed34f92055591}{Get\+N\+Retry\+Needed\+Packets} (\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} recipient, uint8\+\_\+t tid) const 
\item 
void \hyperlink{classns3_1_1BlockAckManager_a46a5ec91aff9a426456706443a04f4c9}{Notify\+Agreement\+Established} (\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} recipient, uint8\+\_\+t tid, uint16\+\_\+t starting\+Seq)
\item 
void \hyperlink{classns3_1_1BlockAckManager_a1bc61922d4b8fbca906162e1f5a908af}{Notify\+Agreement\+Unsuccessful} (\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} recipient, uint8\+\_\+t tid)
\item 
void \hyperlink{classns3_1_1BlockAckManager_a24ba0bcf0be39d8927e8c04c7dac0f1a}{Notify\+Mpdu\+Transmission} (\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} recipient, uint8\+\_\+t tid, uint16\+\_\+t next\+Seq\+Number, \hyperlink{classns3_1_1WifiMacHeader_ae3a382482f357972019f5e1b3162adc4}{Wifi\+Mac\+Header\+::\+Qos\+Ack\+Policy} policy)
\item 
void \hyperlink{classns3_1_1BlockAckManager_a3f42c74e86fa537d4f99353768ce3bb2}{Complete\+Ampdu\+Exchange} (\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} recipient, uint8\+\_\+t tid)
\item 
void \hyperlink{classns3_1_1BlockAckManager_a3d6ba0be51a232044d8373ada7f4d0e2}{Set\+Block\+Ack\+Threshold} (uint8\+\_\+t n\+Packets)
\item 
void \hyperlink{classns3_1_1BlockAckManager_a220aecfc19f84b497b1ee8781641e2a1}{Set\+Queue} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{namespacens3_a3ca96bcdf02c0e7cacea08ca62ead54c}{Wifi\+Mac\+Queue} $>$ queue)
\item 
void \hyperlink{classns3_1_1BlockAckManager_a76ee2237b1d65a04f96806fa25d30d24}{Set\+Tx\+Middle} (\hyperlink{classns3_1_1MacTxMiddle}{Mac\+Tx\+Middle} $\ast$tx\+Middle)
\item 
void \hyperlink{classns3_1_1BlockAckManager_ab281f28839a128021bf1a7369d75d502}{Set\+Block\+Ack\+Type} (\hyperlink{namespacens3_a90f436472d19d7d7f37cbf0b8c288ff7}{Block\+Ack\+Type} b\+Ack\+Type)
\item 
void \hyperlink{classns3_1_1BlockAckManager_ac18cb8344ca8061c116df54064aee5e4}{Tear\+Down\+Block\+Ack} (\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} recipient, uint8\+\_\+t tid)
\item 
bool \hyperlink{classns3_1_1BlockAckManager_a2928efefb708e3ad0379ab11944b9e24}{Has\+Other\+Fragments} (uint16\+\_\+t sequence\+Number) const 
\item 
uint32\+\_\+t \hyperlink{classns3_1_1BlockAckManager_a38418623e12f21f2b416bfcd700b2abe}{Get\+Next\+Packet\+Size} (void) const 
\item 
void \hyperlink{classns3_1_1BlockAckManager_abf175ea3603c1ef5cd1edd21a5911da2}{Set\+Max\+Packet\+Delay} (\hyperlink{classns3_1_1Time}{Time} max\+Delay)
\item 
void \hyperlink{classns3_1_1BlockAckManager_aba54a7f80dad49b371ebdc5ffe11d651}{Set\+Block\+Ack\+Inactivity\+Callback} (\hyperlink{classns3_1_1Callback}{Callback}$<$ void, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address}, uint8\+\_\+t, bool $>$ callback)
\item 
void \hyperlink{classns3_1_1BlockAckManager_a9ff02e52af689aa218f43e871a43503d}{Set\+Block\+Destination\+Callback} (\hyperlink{classns3_1_1Callback}{Callback}$<$ void, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address}, uint8\+\_\+t $>$ callback)
\item 
void \hyperlink{classns3_1_1BlockAckManager_a591b2a7853ffdd524a1e952cd44820eb}{Set\+Unblock\+Destination\+Callback} (\hyperlink{classns3_1_1Callback}{Callback}$<$ void, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address}, uint8\+\_\+t $>$ callback)
\item 
bool \hyperlink{classns3_1_1BlockAckManager_a20324b49d01312f731087f7f707a596a}{Switch\+To\+Block\+Ack\+If\+Needed} (\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} recipient, uint8\+\_\+t tid, uint16\+\_\+t starting\+Seq)
\item 
uint16\+\_\+t \hyperlink{classns3_1_1BlockAckManager_a32100b41ee7ee435aabb90a2e4cdd12d}{Get\+Seq\+Num\+Of\+Next\+Retry\+Packet} (\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} recipient, uint8\+\_\+t tid) const 
\item 
bool \hyperlink{classns3_1_1BlockAckManager_a36a1c566d4039034d22b9afead55c199}{Already\+Exists} (uint16\+\_\+t current\+Seq, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} recipient, uint8\+\_\+t tid) const 
\item 
bool \hyperlink{classns3_1_1BlockAckManager_a182b0fff297640c289affb334a61f544}{Remove\+Packet} (uint8\+\_\+t tid, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} recipient, uint16\+\_\+t seqnumber)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{classns3_1_1BlockAckManager_a7a235987d23102bd1e0bf0b73cb671b5}{Peek\+Next\+Packet\+By\+Tid\+And\+Address} (\hyperlink{classns3_1_1WifiMacHeader}{Wifi\+Mac\+Header} \&hdr, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} recipient, uint8\+\_\+t tid, \hyperlink{classns3_1_1Time}{Time} $\ast$timestamp)
\item 
bool \hyperlink{classns3_1_1BlockAckManager_a8be3e6dc77c96e4cbc317302ad79a5ac}{Need\+Bar\+Retransmission} (uint8\+\_\+t tid, uint16\+\_\+t seq\+Number, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} recipient)
\item 
void \hyperlink{classns3_1_1BlockAckManager_a2007df06d972c94c7e2b35b7b0bce555}{Set\+Tx\+Ok\+Callback} (\hyperlink{classns3_1_1BlockAckManager_a982d21c899e65a7d1bdc181c8d6de2b4}{Tx\+Ok} callback)
\item 
void \hyperlink{classns3_1_1BlockAckManager_a0ee71617a29e7e00ab9c62194b4501a7}{Set\+Tx\+Failed\+Callback} (\hyperlink{classns3_1_1BlockAckManager_a19b8dc1978e36f011ad60a91c1c7d09c}{Tx\+Failed} callback)
\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{structns3_1_1BlockAckManager_1_1Item}{Item} $>$ \hyperlink{classns3_1_1BlockAckManager_a19b26a2c6037c95267b6f1905feb07a5}{Packet\+Queue}
\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{structns3_1_1BlockAckManager_1_1Item}{Item} $>$\+::iterator \hyperlink{classns3_1_1BlockAckManager_a2bb94802381e70535e8a7c892fd01d48}{Packet\+QueueI}
\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{structns3_1_1BlockAckManager_1_1Item}{Item} $>$\+::const\+\_\+iterator \hyperlink{classns3_1_1BlockAckManager_a7d5306ccfcc49e44b7ffd190b2e190fa}{Packet\+Queue\+CI}
\item 
typedef std\+::map$<$ std\+::pair$<$ \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address}, uint8\+\_\+t $>$, std\+::pair$<$ \hyperlink{classns3_1_1OriginatorBlockAckAgreement}{Originator\+Block\+Ack\+Agreement}, \hyperlink{classns3_1_1BlockAckManager_a19b26a2c6037c95267b6f1905feb07a5}{Packet\+Queue} $>$ $>$ \hyperlink{classns3_1_1BlockAckManager_aada7ad4c4011ce66e28aaa2bcb7aa915}{Agreements}
\item 
typedef std\+::map$<$ std\+::pair$<$ \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address}, uint8\+\_\+t $>$, std\+::pair$<$ \hyperlink{classns3_1_1OriginatorBlockAckAgreement}{Originator\+Block\+Ack\+Agreement}, \hyperlink{classns3_1_1BlockAckManager_a19b26a2c6037c95267b6f1905feb07a5}{Packet\+Queue} $>$ $>$\+::iterator \hyperlink{classns3_1_1BlockAckManager_acbd1cf7c5f3487150955c3a4c9d04102}{AgreementsI}
\item 
typedef std\+::map$<$ std\+::pair$<$ \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address}, uint8\+\_\+t $>$, std\+::pair$<$ \hyperlink{classns3_1_1OriginatorBlockAckAgreement}{Originator\+Block\+Ack\+Agreement}, \hyperlink{classns3_1_1BlockAckManager_a19b26a2c6037c95267b6f1905feb07a5}{Packet\+Queue} $>$ $>$\+::const\+\_\+iterator \hyperlink{classns3_1_1BlockAckManager_a69f7b0d583f5a24ddcfce51260a56dae}{Agreements\+CI}
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1BlockAckManager_aa2506b792c32d3768a79112b2f2991c3}{Block\+Ack\+Manager} (const \hyperlink{classns3_1_1BlockAckManager}{Block\+Ack\+Manager} \&)
\begin{DoxyCompactList}\small\item\em type conversion operator \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1BlockAckManager}{Block\+Ack\+Manager} \& \hyperlink{classns3_1_1BlockAckManager_ae3126b45e928e89144524d3c8226c071}{operator=} (const \hyperlink{classns3_1_1BlockAckManager}{Block\+Ack\+Manager} \&)
\begin{DoxyCompactList}\small\item\em assignment operator \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{classns3_1_1BlockAckManager_a2dd74462281ab81176310ad58a35f2ea}{Schedule\+Block\+Ack\+Req\+If\+Needed} (\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} recipient, uint8\+\_\+t tid)
\item 
void \hyperlink{classns3_1_1BlockAckManager_a27603e1b5ff9a9f5922b1056c75733e1}{Cleanup\+Buffers} (void)
\item 
void \hyperlink{classns3_1_1BlockAckManager_a7846b31a39f8e2c3302020e4c66ae31f}{Inactivity\+Timeout} (\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} recipient, uint8\+\_\+t tid)
\item 
void \hyperlink{classns3_1_1BlockAckManager_aa09e2e2b119ed7a054a580971cf950e3}{Insert\+In\+Retry\+Queue} (\hyperlink{classns3_1_1BlockAckManager_a2bb94802381e70535e8a7c892fd01d48}{Packet\+QueueI} item)
\item 
void \hyperlink{classns3_1_1BlockAckManager_aa7fc7ecdb5e0171b0e84bb39554f75e2}{Remove\+From\+Retry\+Queue} (\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} address, uint8\+\_\+t tid, uint16\+\_\+t seq)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1BlockAckManager_aada7ad4c4011ce66e28aaa2bcb7aa915}{Agreements} \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\+\_\+agreements}
\item 
\hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1BlockAckManager_a2bb94802381e70535e8a7c892fd01d48}{Packet\+QueueI} $>$ \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\+\_\+retry\+Packets}
\item 
\hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{structns3_1_1Bar}{Bar} $>$ \hyperlink{classns3_1_1BlockAckManager_af2339008509896569fe53c035f27c9b4}{m\+\_\+bars}
\begin{DoxyCompactList}\small\item\em list of B\+A\+Rs \end{DoxyCompactList}\item 
uint8\+\_\+t \hyperlink{classns3_1_1BlockAckManager_a310943df91ddcf02959cd646a3b9cbce}{m\+\_\+block\+Ack\+Threshold}
\begin{DoxyCompactList}\small\item\em bock ack threshold \end{DoxyCompactList}\item 
\hyperlink{namespacens3_a90f436472d19d7d7f37cbf0b8c288ff7}{Block\+Ack\+Type} \hyperlink{classns3_1_1BlockAckManager_aa3a0c2d7132c556a98a6672de7665cb5}{m\+\_\+block\+Ack\+Type}
\begin{DoxyCompactList}\small\item\em bock ack type \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1BlockAckManager_a5eabe70b6e25dac515f8ec6c38d45f75}{m\+\_\+max\+Delay}
\begin{DoxyCompactList}\small\item\em maximum delay \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1MacTxMiddle}{Mac\+Tx\+Middle} $\ast$ \hyperlink{classns3_1_1BlockAckManager_a3c78348cca01da647d813f90d2463a44}{m\+\_\+tx\+Middle}
\begin{DoxyCompactList}\small\item\em the \hyperlink{classns3_1_1MacTxMiddle}{Mac\+Tx\+Middle} \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} \hyperlink{classns3_1_1BlockAckManager_af22b7c479eb2dbd8e1e7a360e807d889}{m\+\_\+address}
\begin{DoxyCompactList}\small\item\em address \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{namespacens3_a3ca96bcdf02c0e7cacea08ca62ead54c}{Wifi\+Mac\+Queue} $>$ \hyperlink{classns3_1_1BlockAckManager_a5bc9e0d123696600bbeff7aa37127ec7}{m\+\_\+queue}
\begin{DoxyCompactList}\small\item\em queue \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Callback}{Callback}$<$ void, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address}, uint8\+\_\+t, bool $>$ \hyperlink{classns3_1_1BlockAckManager_aca48203aee618ed997d26c5e77a246a7}{m\+\_\+block\+Ack\+Inactivity\+Timeout}
\begin{DoxyCompactList}\small\item\em block ack inactivity timeout callback \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Callback}{Callback}$<$ void, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address}, uint8\+\_\+t $>$ \hyperlink{classns3_1_1BlockAckManager_aed8b4d86e877d3e5a2ed869636328867}{m\+\_\+block\+Packets}
\begin{DoxyCompactList}\small\item\em block packets callback \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Callback}{Callback}$<$ void, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address}, uint8\+\_\+t $>$ \hyperlink{classns3_1_1BlockAckManager_a1ac5899b37bf2ffee1814cefebe8fe29}{m\+\_\+unblock\+Packets}
\begin{DoxyCompactList}\small\item\em unblock packets callback \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1BlockAckManager_a982d21c899e65a7d1bdc181c8d6de2b4}{Tx\+Ok} \hyperlink{classns3_1_1BlockAckManager_ace96f46b7c52c441becc70227b70d070}{m\+\_\+tx\+Ok\+Callback}
\begin{DoxyCompactList}\small\item\em transmit ok callback \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1BlockAckManager_a19b8dc1978e36f011ad60a91c1c7d09c}{Tx\+Failed} \hyperlink{classns3_1_1BlockAckManager_a58ccfd5da1b7e739b732699ddcc13530}{m\+\_\+tx\+Failed\+Callback}
\begin{DoxyCompactList}\small\item\em transmit failed callback \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1WifiRemoteStationManager}{Wifi\+Remote\+Station\+Manager} $>$ \hyperlink{classns3_1_1BlockAckManager_afb809abb11edae6179dc2f5b8c1f8ce5}{m\+\_\+station\+Manager}
\begin{DoxyCompactList}\small\item\em the station manager \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Manages all block ack agreements for an originator station. 

\subsection{Member Typedef Documentation}
\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Agreements@{Agreements}}
\index{Agreements@{Agreements}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Agreements}{Agreements}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::map$<$std\+::pair$<${\bf Mac48\+Address}, uint8\+\_\+t$>$, std\+::pair$<${\bf Originator\+Block\+Ack\+Agreement}, {\bf Packet\+Queue}$>$ $>$ {\bf ns3\+::\+Block\+Ack\+Manager\+::\+Agreements}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BlockAckManager_aada7ad4c4011ce66e28aaa2bcb7aa915}{}\label{classns3_1_1BlockAckManager_aada7ad4c4011ce66e28aaa2bcb7aa915}
typedef for a map between M\+AC address and block A\+CK agreement. \index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Agreements\+CI@{Agreements\+CI}}
\index{Agreements\+CI@{Agreements\+CI}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Agreements\+CI}{AgreementsCI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::map$<$std\+::pair$<${\bf Mac48\+Address}, uint8\+\_\+t$>$, std\+::pair$<${\bf Originator\+Block\+Ack\+Agreement}, {\bf Packet\+Queue}$>$ $>$\+::const\+\_\+iterator {\bf ns3\+::\+Block\+Ack\+Manager\+::\+Agreements\+CI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BlockAckManager_a69f7b0d583f5a24ddcfce51260a56dae}{}\label{classns3_1_1BlockAckManager_a69f7b0d583f5a24ddcfce51260a56dae}
typedef for a const iterator for Agreements. \index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!AgreementsI@{AgreementsI}}
\index{AgreementsI@{AgreementsI}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{AgreementsI}{AgreementsI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::map$<$std\+::pair$<${\bf Mac48\+Address}, uint8\+\_\+t$>$, std\+::pair$<${\bf Originator\+Block\+Ack\+Agreement}, {\bf Packet\+Queue}$>$ $>$\+::iterator {\bf ns3\+::\+Block\+Ack\+Manager\+::\+AgreementsI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BlockAckManager_acbd1cf7c5f3487150955c3a4c9d04102}{}\label{classns3_1_1BlockAckManager_acbd1cf7c5f3487150955c3a4c9d04102}
typedef for an iterator for Agreements. \index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Packet\+Queue@{Packet\+Queue}}
\index{Packet\+Queue@{Packet\+Queue}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Packet\+Queue}{PacketQueue}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Item}$>$ {\bf ns3\+::\+Block\+Ack\+Manager\+::\+Packet\+Queue}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BlockAckManager_a19b26a2c6037c95267b6f1905feb07a5}{}\label{classns3_1_1BlockAckManager_a19b26a2c6037c95267b6f1905feb07a5}
typedef for a list of \hyperlink{structns3_1_1BlockAckManager_1_1Item}{Item} struct. \index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Packet\+Queue\+CI@{Packet\+Queue\+CI}}
\index{Packet\+Queue\+CI@{Packet\+Queue\+CI}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Packet\+Queue\+CI}{PacketQueueCI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Item}$>$\+::const\+\_\+iterator {\bf ns3\+::\+Block\+Ack\+Manager\+::\+Packet\+Queue\+CI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BlockAckManager_a7d5306ccfcc49e44b7ffd190b2e190fa}{}\label{classns3_1_1BlockAckManager_a7d5306ccfcc49e44b7ffd190b2e190fa}
typedef for a const iterator for Packet\+Queue. \index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Packet\+QueueI@{Packet\+QueueI}}
\index{Packet\+QueueI@{Packet\+QueueI}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Packet\+QueueI}{PacketQueueI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Item}$>$\+::iterator {\bf ns3\+::\+Block\+Ack\+Manager\+::\+Packet\+QueueI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BlockAckManager_a2bb94802381e70535e8a7c892fd01d48}{}\label{classns3_1_1BlockAckManager_a2bb94802381e70535e8a7c892fd01d48}
typedef for an iterator for Packet\+Queue. \index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Tx\+Failed@{Tx\+Failed}}
\index{Tx\+Failed@{Tx\+Failed}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Tx\+Failed}{TxFailed}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Callback}$<$void, const {\bf Wifi\+Mac\+Header}\&$>$ {\bf ns3\+::\+Block\+Ack\+Manager\+::\+Tx\+Failed}}\hypertarget{classns3_1_1BlockAckManager_a19b8dc1978e36f011ad60a91c1c7d09c}{}\label{classns3_1_1BlockAckManager_a19b8dc1978e36f011ad60a91c1c7d09c}
typedef for a callback to invoke when a packet transmission was failed. \index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Tx\+Ok@{Tx\+Ok}}
\index{Tx\+Ok@{Tx\+Ok}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Tx\+Ok}{TxOk}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Callback}$<$void, const {\bf Wifi\+Mac\+Header}\&$>$ {\bf ns3\+::\+Block\+Ack\+Manager\+::\+Tx\+Ok}}\hypertarget{classns3_1_1BlockAckManager_a982d21c899e65a7d1bdc181c8d6de2b4}{}\label{classns3_1_1BlockAckManager_a982d21c899e65a7d1bdc181c8d6de2b4}
typedef for a callback to invoke when a packet transmission was completed successfully. 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Block\+Ack\+Manager@{Block\+Ack\+Manager}}
\index{Block\+Ack\+Manager@{Block\+Ack\+Manager}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Block\+Ack\+Manager(const Block\+Ack\+Manager \&)}{BlockAckManager(const BlockAckManager &)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Block\+Ack\+Manager\+::\+Block\+Ack\+Manager (
\begin{DoxyParamCaption}
\item[{const {\bf Block\+Ack\+Manager} \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BlockAckManager_aa2506b792c32d3768a79112b2f2991c3}{}\label{classns3_1_1BlockAckManager_aa2506b792c32d3768a79112b2f2991c3}


type conversion operator 

\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Block\+Ack\+Manager@{Block\+Ack\+Manager}}
\index{Block\+Ack\+Manager@{Block\+Ack\+Manager}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Block\+Ack\+Manager()}{BlockAckManager()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Block\+Ack\+Manager\+::\+Block\+Ack\+Manager (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BlockAckManager_a7a966d4ae9c3f2172545b76b7ccb8206}{}\label{classns3_1_1BlockAckManager_a7a966d4ae9c3f2172545b76b7ccb8206}

\begin{DoxyCode}
60 \{
61   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
62 \}
\end{DoxyCode}
\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!````~Block\+Ack\+Manager@{$\sim$\+Block\+Ack\+Manager}}
\index{````~Block\+Ack\+Manager@{$\sim$\+Block\+Ack\+Manager}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{$\sim$\+Block\+Ack\+Manager()}{~BlockAckManager()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Block\+Ack\+Manager\+::$\sim$\+Block\+Ack\+Manager (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BlockAckManager_af825fcf5b5c34784c880d95f3d0764af}{}\label{classns3_1_1BlockAckManager_af825fcf5b5c34784c880d95f3d0764af}

\begin{DoxyCode}
65 \{
66   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
67   \hyperlink{classns3_1_1BlockAckManager_a5bc9e0d123696600bbeff7aa37127ec7}{m\_queue} = 0;
68   \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.clear ();
69   \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.clear ();
70 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Already\+Exists@{Already\+Exists}}
\index{Already\+Exists@{Already\+Exists}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Already\+Exists(uint16\+\_\+t current\+Seq, Mac48\+Address recipient, uint8\+\_\+t tid) const }{AlreadyExists(uint16_t currentSeq, Mac48Address recipient, uint8_t tid) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Block\+Ack\+Manager\+::\+Already\+Exists (
\begin{DoxyParamCaption}
\item[{uint16\+\_\+t}]{current\+Seq, }
\item[{{\bf Mac48\+Address}}]{recipient, }
\item[{uint8\+\_\+t}]{tid}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1BlockAckManager_a36a1c566d4039034d22b9afead55c199}{}\label{classns3_1_1BlockAckManager_a36a1c566d4039034d22b9afead55c199}
Checks if the packet already exists in the retransmit queue or not if it does then it doesn\textquotesingle{}t add it again 
\begin{DoxyCode}
562 \{
563   std::list<PacketQueueI>::const\_iterator it = \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.begin ();
564   \textcolor{keywordflow}{while} (it != \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.end ())
565     \{
566       \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << (*it)->hdr.GetType ());
567       \textcolor{keywordflow}{if} (!(*it)->hdr.IsQosData ())
568         \{
569           \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Packet in blockAck manager retry queue is not Qos Data"});
570         \}
571       \textcolor{keywordflow}{if} ((*it)->hdr.GetAddr1 () == recipient && (*it)->hdr.GetQosTid () == tid && currentSeq == (*it)->hdr
      .GetSequenceNumber ())
572         \{
573           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
574         \}
575       it++;
576     \}
577   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
578 \}
\end{DoxyCode}
\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Cleanup\+Buffers@{Cleanup\+Buffers}}
\index{Cleanup\+Buffers@{Cleanup\+Buffers}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Cleanup\+Buffers(void)}{CleanupBuffers(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Block\+Ack\+Manager\+::\+Cleanup\+Buffers (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BlockAckManager_a27603e1b5ff9a9f5922b1056c75733e1}{}\label{classns3_1_1BlockAckManager_a27603e1b5ff9a9f5922b1056c75733e1}
This method removes packets whose lifetime was exceeded. 
\begin{DoxyCode}
898 \{
899   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
900   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1BlockAckManager_acbd1cf7c5f3487150955c3a4c9d04102}{AgreementsI} j = \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.begin (); j != 
      \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.end (); j++)
901     \{
902       \textcolor{keywordflow}{if} (j->second.second.empty ())
903         \{
904           \textcolor{keywordflow}{continue};
905         \}
906       \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} now = \hyperlink{classns3_1_1Simulator_ac3178fa975b419f7875e7105be122800}{Simulator::Now} ();
907       \hyperlink{classns3_1_1BlockAckManager_a2bb94802381e70535e8a7c892fd01d48}{PacketQueueI} end = j->second.second.begin ();
908       \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1BlockAckManager_a2bb94802381e70535e8a7c892fd01d48}{PacketQueueI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = j->second.second.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != j->second.second.end (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
909         \{
910           \textcolor{keywordflow}{if} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->timestamp + \hyperlink{classns3_1_1BlockAckManager_a5eabe70b6e25dac515f8ec6c38d45f75}{m\_maxDelay} > now)
911             \{
912               end = \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
913               \textcolor{keywordflow}{break};
914             \}
915           \textcolor{keywordflow}{else}
916             \{
917               \hyperlink{classns3_1_1BlockAckManager_aa7fc7ecdb5e0171b0e84bb39554f75e2}{RemoveFromRetryQueue} (j->second.first.GetPeer (),
918                                     j->second.first.GetTid (),
919                                     \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->hdr.GetSequenceNumber ());
920             \}
921         \}
922       j->second.second.erase (j->second.second.begin (), end);
923       j->second.first.SetStartingSequence (end->hdr.GetSequenceNumber ());
924     \}
925 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 1


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Complete\+Ampdu\+Exchange@{Complete\+Ampdu\+Exchange}}
\index{Complete\+Ampdu\+Exchange@{Complete\+Ampdu\+Exchange}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Complete\+Ampdu\+Exchange(\+Mac48\+Address recipient, uint8\+\_\+t tid)}{CompleteAmpduExchange(Mac48Address recipient, uint8_t tid)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Block\+Ack\+Manager\+::\+Complete\+Ampdu\+Exchange (
\begin{DoxyParamCaption}
\item[{{\bf Mac48\+Address}}]{recipient, }
\item[{uint8\+\_\+t}]{tid}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BlockAckManager_a3f42c74e86fa537d4f99353768ce3bb2}{}\label{classns3_1_1BlockAckManager_a3f42c74e86fa537d4f99353768ce3bb2}

\begin{DoxyParams}{Parameters}
{\em recipient} & \hyperlink{classns3_1_1Address}{Address} of peer station involved in block ack mechanism. \\
\hline
{\em tid} & Traffic ID of transmitted packet.\\
\hline
\end{DoxyParams}
This method to set the number of packets waitin for block\+Ack = 0 since the receiver will send the block\+Ack right away 
\begin{DoxyCode}
234 \{
235   \hyperlink{classns3_1_1BlockAckManager_acbd1cf7c5f3487150955c3a4c9d04102}{AgreementsI} it = \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.find (std::make\_pair (recipient, tid));
236   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (it != \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.end ());
237   OriginatorBlockAckAgreement &agreement = (*it).second.first;
238   agreement.CompleteExchange ();
239 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2




Here is the caller graph for this function\+:
% FIG 3


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Create\+Agreement@{Create\+Agreement}}
\index{Create\+Agreement@{Create\+Agreement}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Create\+Agreement(const Mgt\+Add\+Ba\+Request\+Header $\ast$req\+Hdr, Mac48\+Address recipient)}{CreateAgreement(const MgtAddBaRequestHeader *reqHdr, Mac48Address recipient)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Block\+Ack\+Manager\+::\+Create\+Agreement (
\begin{DoxyParamCaption}
\item[{const {\bf Mgt\+Add\+Ba\+Request\+Header} $\ast$}]{req\+Hdr, }
\item[{{\bf Mac48\+Address}}]{recipient}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BlockAckManager_a44483ff8e6011faf1190dc0f178e66b7}{}\label{classns3_1_1BlockAckManager_a44483ff8e6011faf1190dc0f178e66b7}

\begin{DoxyParams}{Parameters}
{\em req\+Hdr} & Relative Add block ack request (action frame). \\
\hline
{\em recipient} & \hyperlink{classns3_1_1Address}{Address} of peer station involved in block ack mechanism.\\
\hline
\end{DoxyParams}
Creates a new block ack agreement in pending state. When a A\+D\+D\+BA response with a successful status code is received, the relative agreement becomes established. 
\begin{DoxyCode}
107 \{
108   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << reqHdr << recipient);
109   std::pair<Mac48Address, uint8\_t> key (recipient, reqHdr->GetTid ());
110   OriginatorBlockAckAgreement agreement (recipient, reqHdr->GetTid ());
111   agreement.SetStartingSequence (reqHdr->GetStartingSequence ());
112   \textcolor{comment}{/* For now we assume that originator doesn't use this field. Use of this field}
113 \textcolor{comment}{     is mandatory only for recipient */}
114   agreement.SetBufferSize (64);
115   agreement.SetWinEnd ((agreement.GetStartingSequence () + agreement.GetBufferSize () - 1) % 4096);
116   agreement.SetTimeout (reqHdr->GetTimeout ());
117   agreement.SetAmsduSupport (reqHdr->IsAmsduSupported ());
118   agreement.SetHtSupported (\hyperlink{classns3_1_1BlockAckManager_afb809abb11edae6179dc2f5b8c1f8ce5}{m\_stationManager}->\hyperlink{classns3_1_1WifiRemoteStationManager_ac792dc8f3c77d507d25de0b87b52608c}{HasHtSupported} ());
119   \textcolor{keywordflow}{if} (reqHdr->IsImmediateBlockAck ())
120     \{
121       agreement.SetImmediateBlockAck ();
122     \}
123   \textcolor{keywordflow}{else}
124     \{
125       agreement.SetDelayedBlockAck ();
126     \}
127   agreement.SetState (\hyperlink{classns3_1_1OriginatorBlockAckAgreement_ab33ae8af8c458aca7437a472778e4761a0f8c3879c3167ef79a0d4c57ac6015ff}{OriginatorBlockAckAgreement::PENDING});
128   \hyperlink{classns3_1_1BlockAckManager_a19b26a2c6037c95267b6f1905feb07a5}{PacketQueue} queue (0);
129   std::pair<OriginatorBlockAckAgreement, PacketQueue> value (agreement, queue);
130   \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.insert (std::make\_pair (key, value));
131   \hyperlink{classns3_1_1BlockAckManager_aed8b4d86e877d3e5a2ed869636328867}{m\_blockPackets} (recipient, reqHdr->GetTid ());
132 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4




Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Destroy\+Agreement@{Destroy\+Agreement}}
\index{Destroy\+Agreement@{Destroy\+Agreement}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Destroy\+Agreement(\+Mac48\+Address recipient, uint8\+\_\+t tid)}{DestroyAgreement(Mac48Address recipient, uint8_t tid)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Block\+Ack\+Manager\+::\+Destroy\+Agreement (
\begin{DoxyParamCaption}
\item[{{\bf Mac48\+Address}}]{recipient, }
\item[{uint8\+\_\+t}]{tid}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BlockAckManager_a4f2adf7575098ab82e1d94466cc9d18a}{}\label{classns3_1_1BlockAckManager_a4f2adf7575098ab82e1d94466cc9d18a}

\begin{DoxyParams}{Parameters}
{\em recipient} & \hyperlink{classns3_1_1Address}{Address} of peer station involved in block ack mechanism. \\
\hline
{\em tid} & Tid Traffic id of transmitted packet.\\
\hline
\end{DoxyParams}
Invoked when a recipient reject a block ack agreement or when a Delba frame is Received/\+Transmitted. 
\begin{DoxyCode}
136 \{
137   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << recipient << (uint16\_t)tid);
138   \hyperlink{classns3_1_1BlockAckManager_acbd1cf7c5f3487150955c3a4c9d04102}{AgreementsI} it = \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.find (std::make\_pair (recipient, tid));
139   \textcolor{keywordflow}{if} (it != \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.end ())
140     \{
141       \textcolor{keywordflow}{for} (std::list<PacketQueueI>::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.begin (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.end (); )
142         \{
143           \textcolor{keywordflow}{if} ((*i)->hdr.GetAddr1 () == recipient && (*i)->hdr.GetQosTid () == tid)
144             \{
145               \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.erase (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
146             \}
147           \textcolor{keywordflow}{else}
148             \{
149               \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++;
150             \}
151         \}
152       \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.erase (it);
153       \textcolor{comment}{//remove scheduled bar}
154       \textcolor{keywordflow}{for} (std::list<Bar>::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1BlockAckManager_af2339008509896569fe53c035f27c9b4}{m\_bars}.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1BlockAckManager_af2339008509896569fe53c035f27c9b4}{m\_bars}.end (); )
155         \{
156           \textcolor{keywordflow}{if} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->recipient == recipient && \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->tid == tid)
157             \{
158               \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1BlockAckManager_af2339008509896569fe53c035f27c9b4}{m\_bars}.erase (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
159             \}
160           \textcolor{keywordflow}{else}
161             \{
162               \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++;
163             \}
164         \}
165     \}
166 \}
\end{DoxyCode}
\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Exists\+Agreement@{Exists\+Agreement}}
\index{Exists\+Agreement@{Exists\+Agreement}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Exists\+Agreement(\+Mac48\+Address recipient, uint8\+\_\+t tid) const }{ExistsAgreement(Mac48Address recipient, uint8_t tid) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Block\+Ack\+Manager\+::\+Exists\+Agreement (
\begin{DoxyParamCaption}
\item[{{\bf Mac48\+Address}}]{recipient, }
\item[{uint8\+\_\+t}]{tid}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1BlockAckManager_a4712688bb7764d576c87fd627d3d3aba}{}\label{classns3_1_1BlockAckManager_a4712688bb7764d576c87fd627d3d3aba}

\begin{DoxyParams}{Parameters}
{\em recipient} & \hyperlink{classns3_1_1Address}{Address} of peer station involved in block ack mechanism. \\
\hline
{\em tid} & Traffic ID.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if a block ack agreement exists, false otherwise
\end{DoxyReturn}
Checks if a block ack agreement exists with station addressed by {\itshape recipient} for tid {\itshape tid}. 
\begin{DoxyCode}
74 \{
75   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << recipient << (uint16\_t)tid);
76   \textcolor{keywordflow}{return} (\hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.find (std::make\_pair (recipient, tid)) != 
      \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.end ());
77 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Exists\+Agreement\+In\+State@{Exists\+Agreement\+In\+State}}
\index{Exists\+Agreement\+In\+State@{Exists\+Agreement\+In\+State}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Exists\+Agreement\+In\+State(\+Mac48\+Address recipient, uint8\+\_\+t tid, Originator\+Block\+Ack\+Agreement\+::\+State state) const }{ExistsAgreementInState(Mac48Address recipient, uint8_t tid, OriginatorBlockAckAgreement::State state) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Block\+Ack\+Manager\+::\+Exists\+Agreement\+In\+State (
\begin{DoxyParamCaption}
\item[{{\bf Mac48\+Address}}]{recipient, }
\item[{uint8\+\_\+t}]{tid, }
\item[{{\bf Originator\+Block\+Ack\+Agreement\+::\+State}}]{state}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1BlockAckManager_ae13c4678f75ebfda7f63d0521878662b}{}\label{classns3_1_1BlockAckManager_ae13c4678f75ebfda7f63d0521878662b}

\begin{DoxyParams}{Parameters}
{\em recipient} & \hyperlink{classns3_1_1Address}{Address} of peer station involved in block ack mechanism. \\
\hline
{\em tid} & Traffic ID. \\
\hline
{\em state} & The state for block ack agreement\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if a block ack agreement exists, false otherwise
\end{DoxyReturn}
Checks if a block ack agreement with a state equals to {\itshape state} exists with station addressed by {\itshape recipient} for tid {\itshape tid}. 
\begin{DoxyCode}
82 \{
83   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << recipient << (uint16\_t)tid << state);
84   \hyperlink{classns3_1_1BlockAckManager_a69f7b0d583f5a24ddcfce51260a56dae}{AgreementsCI} it;
85   it = \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.find (std::make\_pair (recipient, tid));
86   \textcolor{keywordflow}{if} (it != \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.end ())
87     \{
88       \textcolor{keywordflow}{switch} (state)
89         \{
90         \textcolor{keywordflow}{case} \hyperlink{classns3_1_1OriginatorBlockAckAgreement_ab33ae8af8c458aca7437a472778e4761a57155e6fa589ec94dcd8be08ef6dd837}{OriginatorBlockAckAgreement::INACTIVE}:
91           \textcolor{keywordflow}{return} it->second.first.IsInactive ();
92         \textcolor{keywordflow}{case} \hyperlink{classns3_1_1OriginatorBlockAckAgreement_ab33ae8af8c458aca7437a472778e4761a341f78e1e094b88dea42e94b32871067}{OriginatorBlockAckAgreement::ESTABLISHED}:
93           \textcolor{keywordflow}{return} it->second.first.IsEstablished ();
94         \textcolor{keywordflow}{case} \hyperlink{classns3_1_1OriginatorBlockAckAgreement_ab33ae8af8c458aca7437a472778e4761a0f8c3879c3167ef79a0d4c57ac6015ff}{OriginatorBlockAckAgreement::PENDING}:
95           \textcolor{keywordflow}{return} it->second.first.IsPending ();
96         \textcolor{keywordflow}{case} \hyperlink{classns3_1_1OriginatorBlockAckAgreement_ab33ae8af8c458aca7437a472778e4761a87f84c6aa88a34abf61f0be8313319ee}{OriginatorBlockAckAgreement::UNSUCCESSFUL}:
97           \textcolor{keywordflow}{return} it->second.first.IsUnsuccessful ();
98         \textcolor{keywordflow}{default}:
99           \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Invalid state for block ack agreement"});
100         \}
101     \}
102   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
103 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Get\+N\+Buffered\+Packets@{Get\+N\+Buffered\+Packets}}
\index{Get\+N\+Buffered\+Packets@{Get\+N\+Buffered\+Packets}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Get\+N\+Buffered\+Packets(\+Mac48\+Address recipient, uint8\+\_\+t tid) const }{GetNBufferedPackets(Mac48Address recipient, uint8_t tid) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Block\+Ack\+Manager\+::\+Get\+N\+Buffered\+Packets (
\begin{DoxyParamCaption}
\item[{{\bf Mac48\+Address}}]{recipient, }
\item[{uint8\+\_\+t}]{tid}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1BlockAckManager_af1da67d0de14b53997fbeedaa93f7380}{}\label{classns3_1_1BlockAckManager_af1da67d0de14b53997fbeedaa93f7380}

\begin{DoxyParams}{Parameters}
{\em recipient} & \hyperlink{classns3_1_1Address}{Address} of peer station involved in block ack mechanism. \\
\hline
{\em tid} & Traffic ID.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of packets buffered for a specified agreement
\end{DoxyReturn}
Returns number of packets buffered for a specified agreement. This methods doesn\textquotesingle{}t return number of buffered M\+P\+D\+Us but number of buffered M\+S\+D\+Us. 
\begin{DoxyCode}
488 \{
489   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << recipient << (uint16\_t)tid);
490   uint32\_t nPackets = 0;
491   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1BlockAckManager_a4712688bb7764d576c87fd627d3d3aba}{ExistsAgreement} (recipient, tid))
492     \{
493       \hyperlink{classns3_1_1BlockAckManager_a69f7b0d583f5a24ddcfce51260a56dae}{AgreementsCI} it = \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.find (std::make\_pair (recipient, tid));
494       \hyperlink{classns3_1_1BlockAckManager_a7d5306ccfcc49e44b7ffd190b2e190fa}{PacketQueueCI} queueIt = (*it).second.second.begin ();
495       uint16\_t currentSeq = 0;
496       \textcolor{keywordflow}{while} (queueIt != (*it).second.second.end ())
497         \{
498           currentSeq = (*queueIt).hdr.GetSequenceNumber ();
499           nPackets++;
500           \textcolor{comment}{/* a fragmented packet must be counted as one packet */}
501           \textcolor{keywordflow}{while} (queueIt != (*it).second.second.end () && (*queueIt).hdr.GetSequenceNumber () == currentSeq
      )
502             \{
503               queueIt++;
504             \}
505         \}
506       \textcolor{keywordflow}{return} nPackets;
507     \}
508   \textcolor{keywordflow}{return} 0;
509 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Get\+Next\+Packet@{Get\+Next\+Packet}}
\index{Get\+Next\+Packet@{Get\+Next\+Packet}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Get\+Next\+Packet(\+Wifi\+Mac\+Header \&hdr)}{GetNextPacket(WifiMacHeader &hdr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ const {\bf Packet} $>$ ns3\+::\+Block\+Ack\+Manager\+::\+Get\+Next\+Packet (
\begin{DoxyParamCaption}
\item[{{\bf Wifi\+Mac\+Header} \&}]{hdr}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BlockAckManager_a11266152bf97c5ed1a06410d6fda4cc9}{}\label{classns3_1_1BlockAckManager_a11266152bf97c5ed1a06410d6fda4cc9}

\begin{DoxyParams}{Parameters}
{\em hdr} & 802.\+11 header of returned packet (if exists).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the packet
\end{DoxyReturn}
This methods returns a packet (if exists) indicated as not received in corresponding block ack bitmap. 
\begin{DoxyCode}
243 \{
244   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << &hdr);
245   Ptr<const Packet> packet = 0;
246   uint8\_t tid;
247   Mac48Address recipient;
248   \hyperlink{classns3_1_1BlockAckManager_a27603e1b5ff9a9f5922b1056c75733e1}{CleanupBuffers} ();
249   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.empty ())
250     \{
251       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Retry buffer size is "} << \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.size ());
252       std::list<PacketQueueI>::iterator it = \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.begin ();
253       \textcolor{keywordflow}{while} (it != \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.end ())
254         \{
255           \textcolor{keywordflow}{if} ((*it)->hdr.IsQosData ())
256             \{
257               tid = (*it)->hdr.GetQosTid ();
258             \}
259           \textcolor{keywordflow}{else}
260             \{
261               \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Packet in blockAck manager retry queue is not Qos Data"});
262             \}
263           recipient = (*it)->hdr.GetAddr1 ();
264           \hyperlink{classns3_1_1BlockAckManager_acbd1cf7c5f3487150955c3a4c9d04102}{AgreementsI} agreement = \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.find (std::make\_pair (recipient, tid)
      );
265           \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (agreement != \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.end ());
266           \textcolor{keywordflow}{if} (\hyperlink{group__wifi_ga5cb9ea723837c5a036e622612f2d0bb0}{QosUtilsIsOldPacket} (agreement->second.first.GetStartingSequence (),(*it)
      ->hdr.GetSequenceNumber ()))
267             \{
268               \textcolor{comment}{//Standard says the originator should not send a packet with seqnum < winstart}
269               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The Retry packet have sequence number < WinStartO --> Discard "} <<
       (*it)->hdr.GetSequenceNumber () << \textcolor{stringliteral}{" "} << agreement->second.first.GetStartingSequence ());
270               agreement->second.second.erase ((*it));
271               it = \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.erase (it);
272               \textcolor{keywordflow}{continue};
273             \}
274           \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((*it)->hdr.GetSequenceNumber () > (agreement->second.first.GetStartingSequence () + 63) 
      % 4096)
275             \{
276               agreement->second.first.SetStartingSequence ((*it)->hdr.GetSequenceNumber ());
277             \}
278           packet = (*it)->packet->Copy ();
279           hdr = (*it)->hdr;
280           hdr.SetRetry ();
281           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Retry packet seq = "} << hdr.GetSequenceNumber ());
282           \textcolor{keywordflow}{if} (hdr.IsQosData ())
283             \{
284               tid = hdr.GetQosTid ();
285             \}
286           \textcolor{keywordflow}{else}
287             \{
288               \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Packet in blockAck manager retry queue is not Qos Data"});
289             \}
290           recipient = hdr.GetAddr1 ();
291           \textcolor{keywordflow}{if} (!agreement->second.first.IsHtSupported ()
292               && (\hyperlink{classns3_1_1BlockAckManager_ae13c4678f75ebfda7f63d0521878662b}{ExistsAgreementInState} (recipient, tid, 
      \hyperlink{classns3_1_1OriginatorBlockAckAgreement_ab33ae8af8c458aca7437a472778e4761a341f78e1e094b88dea42e94b32871067}{OriginatorBlockAckAgreement::ESTABLISHED})
293                   || \hyperlink{classns3_1_1BlockAckManager_a20324b49d01312f731087f7f707a596a}{SwitchToBlockAckIfNeeded} (recipient, tid, hdr.
      GetSequenceNumber ())))
294             \{
295               hdr.SetQosAckPolicy (\hyperlink{classns3_1_1WifiMacHeader_ae3a382482f357972019f5e1b3162adc4a8d2763ea0083f1265fbf7dda6fdcf9fd}{WifiMacHeader::BLOCK\_ACK});
296             \}
297           \textcolor{keywordflow}{else}
298             \{
299               \textcolor{comment}{/* From section 9.10.3 in IEEE802.11e standard:}
300 \textcolor{comment}{               * In order to improve efficiency, originators using the Block Ack facility}
301 \textcolor{comment}{               * may send MPDU frames with the Ack Policy subfield in QoS control frames}
302 \textcolor{comment}{               * set to Normal Ack if only a few MPDUs are available for transmission.[...]}
303 \textcolor{comment}{               * When there are sufficient number of MPDUs, the originator may switch back to}
304 \textcolor{comment}{               * the use of Block Ack.}
305 \textcolor{comment}{               */}
306               hdr.SetQosAckPolicy (\hyperlink{classns3_1_1WifiMacHeader_ae3a382482f357972019f5e1b3162adc4a9f52b9c6ca65d046ce2be9d70bce28cf}{WifiMacHeader::NORMAL\_ACK});
307               \hyperlink{classns3_1_1BlockAckManager_acbd1cf7c5f3487150955c3a4c9d04102}{AgreementsI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.find (std::make\_pair (recipient, tid));
308               i->second.second.erase (*it);
309             \}
310           it = \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.erase (it);
311           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Removed one packet, retry buffer size = "} << 
      \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.size () );
312           \textcolor{keywordflow}{break};
313         \}
314     \}
315   \textcolor{keywordflow}{return} packet;
316 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9




Here is the caller graph for this function\+:
% FIG 10


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Get\+Next\+Packet\+Size@{Get\+Next\+Packet\+Size}}
\index{Get\+Next\+Packet\+Size@{Get\+Next\+Packet\+Size}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Get\+Next\+Packet\+Size(void) const }{GetNextPacketSize(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Block\+Ack\+Manager\+::\+Get\+Next\+Packet\+Size (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1BlockAckManager_a38418623e12f21f2b416bfcd700b2abe}{}\label{classns3_1_1BlockAckManager_a38418623e12f21f2b416bfcd700b2abe}
\begin{DoxyReturn}{Returns}
the size of the next packet that needs retransmission
\end{DoxyReturn}
Returns size of the next packet that needs retransmission. 
\begin{DoxyCode}
849 \{
850   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
851   uint32\_t size = 0;
852   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.size () > 0)
853     \{
854       Item next = *(\hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.front ());
855       size = next.packet->GetSize ();
856     \}
857   \textcolor{keywordflow}{return} size;
858 \}
\end{DoxyCode}
\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Get\+N\+Retry\+Needed\+Packets@{Get\+N\+Retry\+Needed\+Packets}}
\index{Get\+N\+Retry\+Needed\+Packets@{Get\+N\+Retry\+Needed\+Packets}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Get\+N\+Retry\+Needed\+Packets(\+Mac48\+Address recipient, uint8\+\_\+t tid) const }{GetNRetryNeededPackets(Mac48Address recipient, uint8_t tid) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Block\+Ack\+Manager\+::\+Get\+N\+Retry\+Needed\+Packets (
\begin{DoxyParamCaption}
\item[{{\bf Mac48\+Address}}]{recipient, }
\item[{uint8\+\_\+t}]{tid}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1BlockAckManager_a324cd181a4aedaff46eed34f92055591}{}\label{classns3_1_1BlockAckManager_a324cd181a4aedaff46eed34f92055591}

\begin{DoxyParams}{Parameters}
{\em recipient} & \hyperlink{classns3_1_1Address}{Address} of peer station involved in block ack mechanism. \\
\hline
{\em tid} & Traffic ID.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of packets for a specific agreement that need retransmission
\end{DoxyReturn}
Returns number of packets for a specific agreement that need retransmission. This method doesn\textquotesingle{}t return number of M\+P\+D\+Us that need retransmission but number of M\+S\+D\+Us. 
\begin{DoxyCode}
513 \{
514   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << recipient << (uint16\_t)tid);
515   uint32\_t nPackets = 0;
516   uint16\_t currentSeq = 0;
517   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1BlockAckManager_a4712688bb7764d576c87fd627d3d3aba}{ExistsAgreement} (recipient, tid))
518     \{
519       std::list<PacketQueueI>::const\_iterator it = \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.begin ();
520       \textcolor{keywordflow}{while} (it != \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.end ())
521         \{
522           \textcolor{keywordflow}{if} (!(*it)->hdr.IsQosData ())
523             \{
524               \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Packet in blockAck manager retry queue is not Qos Data"});
525             \}
526           \textcolor{keywordflow}{if} ((*it)->hdr.GetAddr1 () == recipient && (*it)->hdr.GetQosTid () == tid)
527             \{
528               currentSeq = (*it)->hdr.GetSequenceNumber ();
529               nPackets++;
530               \textcolor{comment}{/* a fragmented packet must be counted as one packet */}
531               \textcolor{keywordflow}{while} (it != \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.end () && (*it)->hdr.GetSequenceNumber () == 
      currentSeq)
532                 \{
533                   it++;
534                 \}
535             \}
536           \textcolor{comment}{//go to next packet}
537           \textcolor{keywordflow}{else}
538             \{
539               it++;
540             \}
541         \}
542     \}
543   \textcolor{keywordflow}{return} nPackets;
544 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Get\+Seq\+Num\+Of\+Next\+Retry\+Packet@{Get\+Seq\+Num\+Of\+Next\+Retry\+Packet}}
\index{Get\+Seq\+Num\+Of\+Next\+Retry\+Packet@{Get\+Seq\+Num\+Of\+Next\+Retry\+Packet}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Get\+Seq\+Num\+Of\+Next\+Retry\+Packet(\+Mac48\+Address recipient, uint8\+\_\+t tid) const }{GetSeqNumOfNextRetryPacket(Mac48Address recipient, uint8_t tid) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Block\+Ack\+Manager\+::\+Get\+Seq\+Num\+Of\+Next\+Retry\+Packet (
\begin{DoxyParamCaption}
\item[{{\bf Mac48\+Address}}]{recipient, }
\item[{uint8\+\_\+t}]{tid}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1BlockAckManager_a32100b41ee7ee435aabb90a2e4cdd12d}{}\label{classns3_1_1BlockAckManager_a32100b41ee7ee435aabb90a2e4cdd12d}

\begin{DoxyParams}{Parameters}
{\em recipient} & \\
\hline
{\em tid} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the sequence number of the next retry packet for a specific agreement
\end{DoxyReturn}
Returns the sequence number of the next retry packet for a specific agreement. If there are no packets that need retransmission for the specified agreement or the agreement doesn\textquotesingle{}t exist the function returns 4096; 
\begin{DoxyCode}
964 \{
965   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << recipient << (uint16\_t)tid);
966   std::list<PacketQueueI>::const\_iterator it = \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.begin ();
967   \textcolor{keywordflow}{while} (it != \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.end ())
968     \{
969       \textcolor{keywordflow}{if} (!(*it)->hdr.IsQosData ())
970         \{
971           \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Packet in blockAck manager retry queue is not Qos Data"});
972         \}
973       \textcolor{keywordflow}{if} ((*it)->hdr.GetAddr1 () == recipient && (*it)->hdr.GetQosTid () == tid)
974         \{
975           \textcolor{keywordflow}{return} (*it)->hdr.GetSequenceNumber ();
976         \}
977       it++;
978     \}
979   \textcolor{keywordflow}{return} 4096;
980 \}
\end{DoxyCode}
\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Has\+Bar@{Has\+Bar}}
\index{Has\+Bar@{Has\+Bar}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Has\+Bar(\+Bar \&bar)}{HasBar(Bar &bar)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Block\+Ack\+Manager\+::\+Has\+Bar (
\begin{DoxyParamCaption}
\item[{{\bf Bar} \&}]{bar}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BlockAckManager_a361d518c0824a4b353336475cda25978}{}\label{classns3_1_1BlockAckManager_a361d518c0824a4b353336475cda25978}
Returns true if the B\+AR is scheduled. Returns false otherwise.


\begin{DoxyParams}{Parameters}
{\em bar} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if a B\+AR is scheduled, false otherwise 
\end{DoxyReturn}

\begin{DoxyCode}
468 \{
469   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << &bar);
470   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1BlockAckManager_af2339008509896569fe53c035f27c9b4}{m\_bars}.size () > 0)
471     \{
472       bar = \hyperlink{classns3_1_1BlockAckManager_af2339008509896569fe53c035f27c9b4}{m\_bars}.front ();
473       \hyperlink{classns3_1_1BlockAckManager_af2339008509896569fe53c035f27c9b4}{m\_bars}.pop\_front ();
474       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
475     \}
476   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
477 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 12


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Has\+Other\+Fragments@{Has\+Other\+Fragments}}
\index{Has\+Other\+Fragments@{Has\+Other\+Fragments}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Has\+Other\+Fragments(uint16\+\_\+t sequence\+Number) const }{HasOtherFragments(uint16_t sequenceNumber) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Block\+Ack\+Manager\+::\+Has\+Other\+Fragments (
\begin{DoxyParamCaption}
\item[{uint16\+\_\+t}]{sequence\+Number}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1BlockAckManager_a2928efefb708e3ad0379ab11944b9e24}{}\label{classns3_1_1BlockAckManager_a2928efefb708e3ad0379ab11944b9e24}

\begin{DoxyParams}{Parameters}
{\em sequence\+Number} & Sequence number of the packet which fragment is part of. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if another fragment with the given sequence number is scheduled for retransmission.
\end{DoxyReturn}
Returns true if another fragment with sequence number {\itshape sequence\+Number} is scheduled for retransmission. 
\begin{DoxyCode}
833 \{
834   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << sequenceNumber);
835   \textcolor{keywordtype}{bool} retVal = \textcolor{keyword}{false};
836   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.size () > 0)
837     \{
838       Item next = *(\hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.front ());
839       \textcolor{keywordflow}{if} (next.hdr.GetSequenceNumber () == sequenceNumber)
840         \{
841           retVal = \textcolor{keyword}{true};
842         \}
843     \}
844   \textcolor{keywordflow}{return} retVal;
845 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Has\+Packets@{Has\+Packets}}
\index{Has\+Packets@{Has\+Packets}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Has\+Packets(void) const }{HasPackets(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Block\+Ack\+Manager\+::\+Has\+Packets (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1BlockAckManager_aa4d33e4f453efea9967dc2ebb7142210}{}\label{classns3_1_1BlockAckManager_aa4d33e4f453efea9967dc2ebb7142210}
Returns true if there are packets that need of retransmission or at least a B\+AR is scheduled. Returns false otherwise.

\begin{DoxyReturn}{Returns}
true if there are packets that need of retransmission or at least a B\+AR is scheduled, false otherwise 
\end{DoxyReturn}

\begin{DoxyCode}
481 \{
482   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
483   \textcolor{keywordflow}{return} (\hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.size () > 0 || \hyperlink{classns3_1_1BlockAckManager_af2339008509896569fe53c035f27c9b4}{m\_bars}.size () > 0);
484 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 14


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Inactivity\+Timeout@{Inactivity\+Timeout}}
\index{Inactivity\+Timeout@{Inactivity\+Timeout}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Inactivity\+Timeout(\+Mac48\+Address recipient, uint8\+\_\+t tid)}{InactivityTimeout(Mac48Address recipient, uint8_t tid)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Block\+Ack\+Manager\+::\+Inactivity\+Timeout (
\begin{DoxyParamCaption}
\item[{{\bf Mac48\+Address}}]{recipient, }
\item[{uint8\+\_\+t}]{tid}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BlockAckManager_a7846b31a39f8e2c3302020e4c66ae31f}{}\label{classns3_1_1BlockAckManager_a7846b31a39f8e2c3302020e4c66ae31f}
Inactivity timeout function 
\begin{DoxyParams}{Parameters}
{\em recipient} & the recipient M\+AC address \\
\hline
{\em tid} & Traffic ID \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
742 \{
743   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << recipient << static\_cast<uint32\_t> (tid));
744   \hyperlink{classns3_1_1BlockAckManager_aca48203aee618ed997d26c5e77a246a7}{m\_blockAckInactivityTimeout} (recipient, tid, \textcolor{keyword}{true});
745 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 15


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Insert\+In\+Retry\+Queue@{Insert\+In\+Retry\+Queue}}
\index{Insert\+In\+Retry\+Queue@{Insert\+In\+Retry\+Queue}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Insert\+In\+Retry\+Queue(\+Packet\+Queue\+I item)}{InsertInRetryQueue(PacketQueueI item)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Block\+Ack\+Manager\+::\+Insert\+In\+Retry\+Queue (
\begin{DoxyParamCaption}
\item[{{\bf Packet\+QueueI}}]{item}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BlockAckManager_aa09e2e2b119ed7a054a580971cf950e3}{}\label{classns3_1_1BlockAckManager_aa09e2e2b119ed7a054a580971cf950e3}

\begin{DoxyParams}{Parameters}
{\em item} & Insert item in retransmission queue. This method ensures packets are retransmitted in the correct order. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
996 \{
997   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Adding to retry queue "} << (*item).hdr.GetSequenceNumber ());
998   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.size () == 0)
999     \{
1000       \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.push\_back (item);
1001     \}
1002   \textcolor{keywordflow}{else}
1003     \{
1004       \textcolor{keywordflow}{for} (std::list<PacketQueueI>::iterator it = \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.begin (); it != 
      \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.end (); )
1005         \{
1006           \textcolor{keywordflow}{if} (((item->hdr.GetSequenceNumber () - (*it)->hdr.GetSequenceNumber () + 4096) % 4096) > 2047)
1007             \{
1008               it = \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.insert (it, item);
1009               \textcolor{keywordflow}{break};
1010             \}
1011           \textcolor{keywordflow}{else}
1012             \{
1013               it++;
1014               \textcolor{keywordflow}{if} (it == \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.end ())
1015                 \{
1016                   \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.push\_back (item);
1017                 \}
1018             \}
1019         \}
1020     \}
1021 \}
\end{DoxyCode}
\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Need\+Bar\+Retransmission@{Need\+Bar\+Retransmission}}
\index{Need\+Bar\+Retransmission@{Need\+Bar\+Retransmission}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Need\+Bar\+Retransmission(uint8\+\_\+t tid, uint16\+\_\+t seq\+Number, Mac48\+Address recipient)}{NeedBarRetransmission(uint8_t tid, uint16_t seqNumber, Mac48Address recipient)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Block\+Ack\+Manager\+::\+Need\+Bar\+Retransmission (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{tid, }
\item[{uint16\+\_\+t}]{seq\+Number, }
\item[{{\bf Mac48\+Address}}]{recipient}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BlockAckManager_a8be3e6dc77c96e4cbc317302ad79a5ac}{}\label{classns3_1_1BlockAckManager_a8be3e6dc77c96e4cbc317302ad79a5ac}
This function returns true if the lifetime of the packets a B\+AR refers to didn\textquotesingle{}t expire yet else it returns false. If it return false then the B\+AR will be discarded (i.\+e. will not be re-\/transmitted)


\begin{DoxyParams}{Parameters}
{\em tid} & Traffic ID \\
\hline
{\em seq\+Number} & sequence number \\
\hline
{\em recipient} & mac address\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if B\+AR retransmission needed 
\end{DoxyReturn}

\begin{DoxyCode}
861 \{
862   \textcolor{comment}{//The standard says the BAR gets discarded when all MSDUs lifetime expires}
863   \hyperlink{classns3_1_1BlockAckManager_acbd1cf7c5f3487150955c3a4c9d04102}{AgreementsI} it = \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.find (std::make\_pair (recipient, tid));
864   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (it != \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.end ());
865   \hyperlink{classns3_1_1BlockAckManager_a27603e1b5ff9a9f5922b1056c75733e1}{CleanupBuffers} ();
866   \textcolor{keywordflow}{if} ((seqNumber + 63) < it->second.first.GetStartingSequence ())
867     \{
868       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
869     \}
870   \textcolor{keywordflow}{else}
871     \{
872       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
873     \}
874 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 16


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Notify\+Agreement\+Established@{Notify\+Agreement\+Established}}
\index{Notify\+Agreement\+Established@{Notify\+Agreement\+Established}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Notify\+Agreement\+Established(\+Mac48\+Address recipient, uint8\+\_\+t tid, uint16\+\_\+t starting\+Seq)}{NotifyAgreementEstablished(Mac48Address recipient, uint8_t tid, uint16_t startingSeq)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Block\+Ack\+Manager\+::\+Notify\+Agreement\+Established (
\begin{DoxyParamCaption}
\item[{{\bf Mac48\+Address}}]{recipient, }
\item[{uint8\+\_\+t}]{tid, }
\item[{uint16\+\_\+t}]{starting\+Seq}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BlockAckManager_a46a5ec91aff9a426456706443a04f4c9}{}\label{classns3_1_1BlockAckManager_a46a5ec91aff9a426456706443a04f4c9}

\begin{DoxyParams}{Parameters}
{\em recipient} & \hyperlink{classns3_1_1Address}{Address} of peer station involved in block ack mechanism. \\
\hline
{\em tid} & Traffic ID of transmitted packet. \\
\hline
{\em starting\+Seq} & starting sequence field\\
\hline
\end{DoxyParams}
Puts corresponding agreement in established state and updates number of packets and starting sequence field. Invoked typically after a block ack refresh. 
\begin{DoxyCode}
749 \{
750   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << recipient << static\_cast<uint32\_t> (tid) << startingSeq);
751   \hyperlink{classns3_1_1BlockAckManager_acbd1cf7c5f3487150955c3a4c9d04102}{AgreementsI} it = \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.find (std::make\_pair (recipient, tid));
752   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (it != \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.end ());
753 
754   it->second.first.SetState (\hyperlink{classns3_1_1OriginatorBlockAckAgreement_ab33ae8af8c458aca7437a472778e4761a341f78e1e094b88dea42e94b32871067}{OriginatorBlockAckAgreement::ESTABLISHED}
      );
755   it->second.first.SetStartingSequence (startingSeq);
756 \}
\end{DoxyCode}
\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Notify\+Agreement\+Unsuccessful@{Notify\+Agreement\+Unsuccessful}}
\index{Notify\+Agreement\+Unsuccessful@{Notify\+Agreement\+Unsuccessful}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Notify\+Agreement\+Unsuccessful(\+Mac48\+Address recipient, uint8\+\_\+t tid)}{NotifyAgreementUnsuccessful(Mac48Address recipient, uint8_t tid)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Block\+Ack\+Manager\+::\+Notify\+Agreement\+Unsuccessful (
\begin{DoxyParamCaption}
\item[{{\bf Mac48\+Address}}]{recipient, }
\item[{uint8\+\_\+t}]{tid}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BlockAckManager_a1bc61922d4b8fbca906162e1f5a908af}{}\label{classns3_1_1BlockAckManager_a1bc61922d4b8fbca906162e1f5a908af}

\begin{DoxyParams}{Parameters}
{\em recipient} & \hyperlink{classns3_1_1Address}{Address} of peer station involved in block ack mechanism. \\
\hline
{\em tid} & Traffic ID of transmitted packet.\\
\hline
\end{DoxyParams}
Marks an agreement as unsuccessful. This happens if {\itshape recipient} station reject block ack setup by an A\+D\+D\+BA Response frame with a failure status code. For now we assume that every QoS station accepts a block ack setup. 
\begin{DoxyCode}
760 \{
761   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << recipient << static\_cast<uint32\_t> (tid));
762   \hyperlink{classns3_1_1BlockAckManager_acbd1cf7c5f3487150955c3a4c9d04102}{AgreementsI} it = \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.find (std::make\_pair (recipient, tid));
763   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (it != \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.end ());
764   \textcolor{keywordflow}{if} (it != \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.end ())
765     \{
766       it->second.first.SetState (\hyperlink{classns3_1_1OriginatorBlockAckAgreement_ab33ae8af8c458aca7437a472778e4761a87f84c6aa88a34abf61f0be8313319ee}{OriginatorBlockAckAgreement::UNSUCCESSFUL}
      );
767     \}
768 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 17


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Notify\+Got\+Block\+Ack@{Notify\+Got\+Block\+Ack}}
\index{Notify\+Got\+Block\+Ack@{Notify\+Got\+Block\+Ack}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Notify\+Got\+Block\+Ack(const Ctrl\+B\+Ack\+Response\+Header $\ast$block\+Ack, Mac48\+Address recipient, double rx\+Snr, Wifi\+Mode tx\+Mode, double data\+Snr)}{NotifyGotBlockAck(const CtrlBAckResponseHeader *blockAck, Mac48Address recipient, double rxSnr, WifiMode txMode, double dataSnr)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Block\+Ack\+Manager\+::\+Notify\+Got\+Block\+Ack (
\begin{DoxyParamCaption}
\item[{const {\bf Ctrl\+B\+Ack\+Response\+Header} $\ast$}]{block\+Ack, }
\item[{{\bf Mac48\+Address}}]{recipient, }
\item[{double}]{rx\+Snr, }
\item[{{\bf Wifi\+Mode}}]{tx\+Mode, }
\item[{double}]{data\+Snr}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BlockAckManager_a9b24f21a11eb094fa683943b7fc3c747}{}\label{classns3_1_1BlockAckManager_a9b24f21a11eb094fa683943b7fc3c747}

\begin{DoxyParams}{Parameters}
{\em block\+Ack} & The received block ack frame. \\
\hline
{\em recipient} & Sender of block ack frame. \\
\hline
{\em rx\+Snr} & received S\+NR of the block ack frame itself \\
\hline
{\em tx\+Mode} & mode of block ack frame. \\
\hline
{\em data\+Snr} & data S\+NR reported by remote station\\
\hline
\end{DoxyParams}
Invoked upon receipt of a block ack frame. Typically, this function, is called by \hyperlink{classns3_1_1EdcaTxopN}{ns3\+::\+Edca\+TxopN} object. Performs a check on which M\+P\+D\+Us, previously sent with ack policy set to Block Ack, were correctly received by the recipient. An acknowledged M\+P\+DU is removed from the buffer, retransmitted otherwise. 
\begin{DoxyCode}
582 \{
583   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << blockAck << recipient << rxSnr << txMode.GetUniqueName () << 
      dataSnr);
584   uint16\_t sequenceFirstLost = 0;
585   \textcolor{keywordflow}{if} (!blockAck->IsMultiTid ())
586     \{
587       uint8\_t tid = blockAck->GetTidInfo ();
588       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1BlockAckManager_ae13c4678f75ebfda7f63d0521878662b}{ExistsAgreementInState} (recipient, tid, 
      \hyperlink{classns3_1_1OriginatorBlockAckAgreement_ab33ae8af8c458aca7437a472778e4761a341f78e1e094b88dea42e94b32871067}{OriginatorBlockAckAgreement::ESTABLISHED}))
589         \{
590           \textcolor{keywordtype}{bool} foundFirstLost = \textcolor{keyword}{false};
591           uint32\_t nSuccessfulMpdus = 0;
592           uint32\_t nFailedMpdus = 0;
593           \hyperlink{classns3_1_1BlockAckManager_acbd1cf7c5f3487150955c3a4c9d04102}{AgreementsI} it = \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.find (std::make\_pair (recipient, tid));
594           \hyperlink{classns3_1_1BlockAckManager_a2bb94802381e70535e8a7c892fd01d48}{PacketQueueI} queueEnd = it->second.second.end ();
595 
596           \textcolor{keywordflow}{if} (it->second.first.m\_inactivityEvent.IsRunning ())
597             \{
598               \textcolor{comment}{/* Upon reception of a block ack frame, the inactivity timer at the}
599 \textcolor{comment}{                 originator must be reset.}
600 \textcolor{comment}{                 For more details see section 11.5.3 in IEEE802.11e standard */}
601               it->second.first.m\_inactivityEvent.Cancel ();
602               \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} \hyperlink{openflow-switch_8cc_a386d174ae121d1cfa279074b7e209714}{timeout} = \hyperlink{group__timecivil_ga17465a639c8d1464e76538afdd78a9f0}{MicroSeconds} (1024 * it->second.first.GetTimeout ());
603               it->second.first.m\_inactivityEvent = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (timeout,
604                                                                         &
      \hyperlink{classns3_1_1BlockAckManager_a7846b31a39f8e2c3302020e4c66ae31f}{BlockAckManager::InactivityTimeout},
605                                                                         \textcolor{keyword}{this},
606                                                                         recipient, tid);
607             \}
608           \textcolor{keywordflow}{if} (blockAck->IsBasic ())
609             \{
610               \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1BlockAckManager_a2bb94802381e70535e8a7c892fd01d48}{PacketQueueI} queueIt = it->second.second.begin (); queueIt != queueEnd; )
611                 \{
612                   \textcolor{keywordflow}{if} (blockAck->IsFragmentReceived ((*queueIt).hdr.GetSequenceNumber (),
613                                                     (*queueIt).hdr.GetFragmentNumber ()))
614                     \{
615                       nSuccessfulMpdus++;
616                       \hyperlink{classns3_1_1BlockAckManager_aa7fc7ecdb5e0171b0e84bb39554f75e2}{RemoveFromRetryQueue} (recipient, tid, (*queueIt).hdr.
      GetSequenceNumber ());
617                       queueIt = it->second.second.erase (queueIt);
618                     \}
619                   \textcolor{keywordflow}{else}
620                     \{
621                       \textcolor{keywordflow}{if} (!foundFirstLost)
622                         \{
623                           foundFirstLost = \textcolor{keyword}{true};
624                           sequenceFirstLost = (*queueIt).hdr.GetSequenceNumber ();
625                           (*it).second.first.SetStartingSequence (sequenceFirstLost);
626                         \}
627                       nFailedMpdus++;
628                       \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1BlockAckManager_a36a1c566d4039034d22b9afead55c199}{AlreadyExists} ((*queueIt).hdr.GetSequenceNumber (),recipient,tid))
629                         \{
630                           \hyperlink{classns3_1_1BlockAckManager_aa09e2e2b119ed7a054a580971cf950e3}{InsertInRetryQueue} (queueIt);
631                         \}
632                       queueIt++;
633                     \}
634                 \}
635             \}
636           \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (blockAck->IsCompressed ())
637             \{
638               \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1BlockAckManager_a2bb94802381e70535e8a7c892fd01d48}{PacketQueueI} queueIt = it->second.second.begin (); queueIt != queueEnd; )
639                 \{
640                   uint16\_t currentSeq = (*queueIt).hdr.GetSequenceNumber ();
641                   \textcolor{keywordflow}{if} (blockAck->IsPacketReceived (currentSeq))
642                     \{
643                       \textcolor{keywordflow}{while} (queueIt != queueEnd
644                              && (*queueIt).hdr.GetSequenceNumber () == currentSeq)
645                         \{
646                           nSuccessfulMpdus++;
647                           \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1BlockAckManager_ace96f46b7c52c441becc70227b70d070}{m\_txOkCallback}.\hyperlink{classns3_1_1Callback_aa8e27826badbf37f84763f36f70d9b54}{IsNull} ())
648                             \{
649                               \hyperlink{classns3_1_1BlockAckManager_ace96f46b7c52c441becc70227b70d070}{m\_txOkCallback} ((*queueIt).hdr);
650                             \}
651                           \hyperlink{classns3_1_1BlockAckManager_aa7fc7ecdb5e0171b0e84bb39554f75e2}{RemoveFromRetryQueue} (recipient, tid, currentSeq);
652                           queueIt = it->second.second.erase (queueIt);
653                         \}
654                     \}
655                   \textcolor{keywordflow}{else}
656                     \{
657                       \textcolor{keywordflow}{if} (!foundFirstLost)
658                         \{
659                           foundFirstLost = \textcolor{keyword}{true};
660                           sequenceFirstLost = (*queueIt).hdr.GetSequenceNumber ();
661                           (*it).second.first.SetStartingSequence (sequenceFirstLost);
662                         \}
663                       nFailedMpdus++;
664                       \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1BlockAckManager_a58ccfd5da1b7e739b732699ddcc13530}{m\_txFailedCallback}.\hyperlink{classns3_1_1Callback_aa8e27826badbf37f84763f36f70d9b54}{IsNull} ())
665                         \{
666                           \hyperlink{classns3_1_1BlockAckManager_a58ccfd5da1b7e739b732699ddcc13530}{m\_txFailedCallback} ((*queueIt).hdr);
667                         \}
668                       \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1BlockAckManager_a36a1c566d4039034d22b9afead55c199}{AlreadyExists} ((*queueIt).hdr.GetSequenceNumber (),recipient,tid))
669                         \{
670                           \hyperlink{classns3_1_1BlockAckManager_aa09e2e2b119ed7a054a580971cf950e3}{InsertInRetryQueue} (queueIt);
671                         \}
672                       queueIt++;
673                     \}
674                 \}
675             \}
676           \hyperlink{classns3_1_1BlockAckManager_afb809abb11edae6179dc2f5b8c1f8ce5}{m\_stationManager}->\hyperlink{classns3_1_1WifiRemoteStationManager_a9630acb259fe192dfd7606fd459c9cdc}{ReportAmpduTxStatus} (recipient, tid, 
      nSuccessfulMpdus, nFailedMpdus, rxSnr, dataSnr);
677           uint16\_t newSeq = \hyperlink{classns3_1_1BlockAckManager_a3c78348cca01da647d813f90d2463a44}{m\_txMiddle}->
      \hyperlink{classns3_1_1MacTxMiddle_ae25a26b35efc9a8f29f27d1348f8514c}{GetNextSeqNumberByTidAndAddress} (tid, recipient);
678           \textcolor{keywordflow}{if} ((foundFirstLost && !\hyperlink{classns3_1_1BlockAckManager_a20324b49d01312f731087f7f707a596a}{SwitchToBlockAckIfNeeded} (recipient, tid, 
      sequenceFirstLost))
679               || (!foundFirstLost && !\hyperlink{classns3_1_1BlockAckManager_a20324b49d01312f731087f7f707a596a}{SwitchToBlockAckIfNeeded} (recipient, tid, 
      newSeq)))
680             \{
681               it->second.first.CompleteExchange ();
682             \}
683         \}
684     \}
685   \textcolor{keywordflow}{else}
686     \{
687       \textcolor{comment}{//NOT SUPPORTED FOR NOW}
688       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Multi-tid block ack is not supported."});
689     \}
690 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 18




Here is the caller graph for this function\+:
% FIG 19


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Notify\+Mpdu\+Transmission@{Notify\+Mpdu\+Transmission}}
\index{Notify\+Mpdu\+Transmission@{Notify\+Mpdu\+Transmission}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Notify\+Mpdu\+Transmission(\+Mac48\+Address recipient, uint8\+\_\+t tid, uint16\+\_\+t next\+Seq\+Number, Wifi\+Mac\+Header\+::\+Qos\+Ack\+Policy policy)}{NotifyMpduTransmission(Mac48Address recipient, uint8_t tid, uint16_t nextSeqNumber, WifiMacHeader::QosAckPolicy policy)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Block\+Ack\+Manager\+::\+Notify\+Mpdu\+Transmission (
\begin{DoxyParamCaption}
\item[{{\bf Mac48\+Address}}]{recipient, }
\item[{uint8\+\_\+t}]{tid, }
\item[{uint16\+\_\+t}]{next\+Seq\+Number, }
\item[{{\bf Wifi\+Mac\+Header\+::\+Qos\+Ack\+Policy}}]{policy}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BlockAckManager_a24ba0bcf0be39d8927e8c04c7dac0f1a}{}\label{classns3_1_1BlockAckManager_a24ba0bcf0be39d8927e8c04c7dac0f1a}

\begin{DoxyParams}{Parameters}
{\em recipient} & \hyperlink{classns3_1_1Address}{Address} of peer station involved in block ack mechanism. \\
\hline
{\em tid} & Traffic ID of transmitted packet. \\
\hline
{\em next\+Seq\+Number} & Sequence number of the next packet that would be trasmitted by \hyperlink{classns3_1_1EdcaTxopN}{Edca\+TxopN}. \\
\hline
{\em policy} & ack policy of the transmitted packet.\\
\hline
\end{DoxyParams}
This method is typically invoked by \hyperlink{classns3_1_1EdcaTxopN}{ns3\+::\+Edca\+TxopN} object every time that a M\+P\+DU with ack policy subfield in Qos Control field set to Block Ack is transmitted. The {\itshape next\+Seq\+Number} parameter is used to block transmission of packets that are out of bitmap. 
\begin{DoxyCode}
772 \{
773   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << recipient << static\_cast<uint32\_t> (tid) << nextSeqNumber);
774   Ptr<Packet> bar = 0;
775   \hyperlink{classns3_1_1BlockAckManager_acbd1cf7c5f3487150955c3a4c9d04102}{AgreementsI} it = \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.find (std::make\_pair (recipient, tid));
776   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (it != \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.end ());
777 
778   uint16\_t nextSeq;
779   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1BlockAckManager_a324cd181a4aedaff46eed34f92055591}{GetNRetryNeededPackets} (recipient, tid) > 0)
780     \{
781       nextSeq = \hyperlink{classns3_1_1BlockAckManager_a32100b41ee7ee435aabb90a2e4cdd12d}{GetSeqNumOfNextRetryPacket} (recipient, tid);
782     \}
783   \textcolor{keywordflow}{else}
784     \{
785       nextSeq = nextSeqNumber;
786     \}
787   it->second.first.NotifyMpduTransmission (nextSeq);
788   \textcolor{keywordflow}{if} (policy == \hyperlink{classns3_1_1WifiMacHeader_ae3a382482f357972019f5e1b3162adc4a8d2763ea0083f1265fbf7dda6fdcf9fd}{WifiMacHeader::BLOCK\_ACK})
789     \{
790       bar = \hyperlink{classns3_1_1BlockAckManager_a2dd74462281ab81176310ad58a35f2ea}{ScheduleBlockAckReqIfNeeded} (recipient, tid);
791       \textcolor{keywordflow}{if} (bar != 0)
792         \{
793           Bar request (bar, recipient, tid, it->second.first.IsImmediateBlockAck ());
794           \hyperlink{classns3_1_1BlockAckManager_af2339008509896569fe53c035f27c9b4}{m\_bars}.push\_back (request);
795         \}
796     \}
797 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 20


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!operator=@{operator=}}
\index{operator=@{operator=}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{operator=(const Block\+Ack\+Manager \&)}{operator=(const BlockAckManager &)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Block\+Ack\+Manager}\& ns3\+::\+Block\+Ack\+Manager\+::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf Block\+Ack\+Manager} \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BlockAckManager_ae3126b45e928e89144524d3c8226c071}{}\label{classns3_1_1BlockAckManager_ae3126b45e928e89144524d3c8226c071}


assignment operator 

\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Peek\+Next\+Packet@{Peek\+Next\+Packet}}
\index{Peek\+Next\+Packet@{Peek\+Next\+Packet}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Peek\+Next\+Packet(\+Wifi\+Mac\+Header \&hdr)}{PeekNextPacket(WifiMacHeader &hdr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ const {\bf Packet} $>$ ns3\+::\+Block\+Ack\+Manager\+::\+Peek\+Next\+Packet (
\begin{DoxyParamCaption}
\item[{{\bf Wifi\+Mac\+Header} \&}]{hdr}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BlockAckManager_a27160e30a1652c3a2cf4c0fca44f4166}{}\label{classns3_1_1BlockAckManager_a27160e30a1652c3a2cf4c0fca44f4166}

\begin{DoxyParams}{Parameters}
{\em hdr} & 802.\+11 header of returned packet (if exists).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the packet
\end{DoxyReturn}
This methods returns a packet (if exists) indicated as not received in corresponding block ack bitmap. This method doesn\textquotesingle{}t remove the packet from this queue. 
\begin{DoxyCode}
320 \{
321   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << &hdr);
322   Ptr<const Packet> packet = 0;
323   uint8\_t tid;
324   Mac48Address recipient;
325   \hyperlink{classns3_1_1BlockAckManager_a27603e1b5ff9a9f5922b1056c75733e1}{CleanupBuffers} ();
326   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.empty ())
327     \{
328       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Retry buffer size is "} << \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.size ());
329       std::list<PacketQueueI>::iterator it = \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.begin ();
330       \textcolor{keywordflow}{while} (it != \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.end ())
331         \{
332           \textcolor{keywordflow}{if} ((*it)->hdr.IsQosData ())
333             \{
334               tid = (*it)->hdr.GetQosTid ();
335             \}
336           \textcolor{keywordflow}{else}
337             \{
338               \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Packet in blockAck manager retry queue is not Qos Data"});
339             \}
340           recipient = (*it)->hdr.GetAddr1 ();
341           \hyperlink{classns3_1_1BlockAckManager_acbd1cf7c5f3487150955c3a4c9d04102}{AgreementsI} agreement = \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.find (std::make\_pair (recipient, tid)
      );
342           \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (agreement != \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.end ());
343           packet = (*it)->packet->Copy ();
344           hdr = (*it)->hdr;
345           hdr.SetRetry ();
346           \textcolor{keywordflow}{if} (hdr.IsQosData ())
347             \{
348               tid = hdr.GetQosTid ();
349             \}
350           \textcolor{keywordflow}{else}
351             \{
352               \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Packet in blockAck manager retry queue is not Qos Data"});
353             \}
354           recipient = hdr.GetAddr1 ();
355           \textcolor{keywordflow}{if} (!agreement->second.first.IsHtSupported ()
356               && (\hyperlink{classns3_1_1BlockAckManager_ae13c4678f75ebfda7f63d0521878662b}{ExistsAgreementInState} (recipient, tid, 
      \hyperlink{classns3_1_1OriginatorBlockAckAgreement_ab33ae8af8c458aca7437a472778e4761a341f78e1e094b88dea42e94b32871067}{OriginatorBlockAckAgreement::ESTABLISHED})
357                   || \hyperlink{classns3_1_1BlockAckManager_a20324b49d01312f731087f7f707a596a}{SwitchToBlockAckIfNeeded} (recipient, tid, hdr.
      GetSequenceNumber ())))
358             \{
359               hdr.SetQosAckPolicy (\hyperlink{classns3_1_1WifiMacHeader_ae3a382482f357972019f5e1b3162adc4a8d2763ea0083f1265fbf7dda6fdcf9fd}{WifiMacHeader::BLOCK\_ACK});
360             \}
361           \textcolor{keywordflow}{else}
362             \{
363               \textcolor{comment}{/* From section 9.10.3 in IEEE802.11e standard:}
364 \textcolor{comment}{               * In order to improve efficiency, originators using the Block Ack facility}
365 \textcolor{comment}{               * may send MPDU frames with the Ack Policy subfield in QoS control frames}
366 \textcolor{comment}{               * set to Normal Ack if only a few MPDUs are available for transmission.[...]}
367 \textcolor{comment}{               * When there are sufficient number of MPDUs, the originator may switch back to}
368 \textcolor{comment}{               * the use of Block Ack.}
369 \textcolor{comment}{               */}
370               hdr.SetQosAckPolicy (\hyperlink{classns3_1_1WifiMacHeader_ae3a382482f357972019f5e1b3162adc4a9f52b9c6ca65d046ce2be9d70bce28cf}{WifiMacHeader::NORMAL\_ACK});
371             \}
372           \textcolor{keywordflow}{break};
373         \}
374     \}
375   \textcolor{keywordflow}{return} packet;
376 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 21




Here is the caller graph for this function\+:
% FIG 22


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Peek\+Next\+Packet\+By\+Tid\+And\+Address@{Peek\+Next\+Packet\+By\+Tid\+And\+Address}}
\index{Peek\+Next\+Packet\+By\+Tid\+And\+Address@{Peek\+Next\+Packet\+By\+Tid\+And\+Address}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Peek\+Next\+Packet\+By\+Tid\+And\+Address(\+Wifi\+Mac\+Header \&hdr, Mac48\+Address recipient, uint8\+\_\+t tid, Time $\ast$timestamp)}{PeekNextPacketByTidAndAddress(WifiMacHeader &hdr, Mac48Address recipient, uint8_t tid, Time *timestamp)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ const {\bf Packet} $>$ ns3\+::\+Block\+Ack\+Manager\+::\+Peek\+Next\+Packet\+By\+Tid\+And\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Wifi\+Mac\+Header} \&}]{hdr, }
\item[{{\bf Mac48\+Address}}]{recipient, }
\item[{uint8\+\_\+t}]{tid, }
\item[{{\bf Time} $\ast$}]{timestamp}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BlockAckManager_a7a235987d23102bd1e0bf0b73cb671b5}{}\label{classns3_1_1BlockAckManager_a7a235987d23102bd1e0bf0b73cb671b5}
Peek in retransmit queue and get the next packet having address indicated by {\itshape type} equals to {\itshape addr}, and tid equals to {\itshape tid}. This method doesn\textquotesingle{}t remove the packet from this queue.


\begin{DoxyParams}{Parameters}
{\em hdr} & wifi mac header \\
\hline
{\em recipient} & mac address \\
\hline
{\em tid} & Traffic ID \\
\hline
{\em timestamp} & timestamp\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Ptr$<$const Packet$>$ 
\end{DoxyReturn}

\begin{DoxyCode}
380 \{
381   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
382   Ptr<const Packet> packet = 0;
383   \hyperlink{classns3_1_1BlockAckManager_a27603e1b5ff9a9f5922b1056c75733e1}{CleanupBuffers} ();
384   \hyperlink{classns3_1_1BlockAckManager_acbd1cf7c5f3487150955c3a4c9d04102}{AgreementsI} agreement = \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.find (std::make\_pair (recipient, tid));
385   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (agreement != \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.end ());
386   std::list<PacketQueueI>::iterator it = \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.begin ();
387   \textcolor{keywordflow}{for} (; it != \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.end (); it++)
388     \{
389       \textcolor{keywordflow}{if} (!(*it)->hdr.IsQosData ())
390         \{
391           \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Packet in blockAck manager retry queue is not Qos Data"});
392         \}
393       \textcolor{keywordflow}{if} ((*it)->hdr.GetAddr1 () == recipient && (*it)->hdr.GetQosTid () == tid)
394         \{
395           \textcolor{keywordflow}{if} (\hyperlink{group__wifi_ga5cb9ea723837c5a036e622612f2d0bb0}{QosUtilsIsOldPacket} (agreement->second.first.GetStartingSequence (),(*it)
      ->hdr.GetSequenceNumber ()))
396             \{
397               \textcolor{comment}{//standard says the originator should not send a packet with seqnum < winstart}
398               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The Retry packet have sequence number < WinStartO --> Discard "} <<
       (*it)->hdr.GetSequenceNumber () << \textcolor{stringliteral}{" "} << agreement->second.first.GetStartingSequence ());
399               agreement->second.second.erase ((*it));
400               it = \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.erase (it);
401               it--;
402               \textcolor{keywordflow}{continue};
403             \}
404           \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((*it)->hdr.GetSequenceNumber () > (agreement->second.first.GetStartingSequence () + 63) 
      % 4096)
405             \{
406               agreement->second.first.SetStartingSequence ((*it)->hdr.GetSequenceNumber ());
407             \}
408           packet = (*it)->packet->Copy ();
409           hdr = (*it)->hdr;
410           hdr.SetRetry ();
411           *tstamp = (*it)->timestamp;
412           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Retry packet seq = "} << hdr.GetSequenceNumber ());
413           Mac48Address recipient = hdr.GetAddr1 ();
414           \textcolor{keywordflow}{if} (!agreement->second.first.IsHtSupported ()
415               && (\hyperlink{classns3_1_1BlockAckManager_ae13c4678f75ebfda7f63d0521878662b}{ExistsAgreementInState} (recipient, tid, 
      \hyperlink{classns3_1_1OriginatorBlockAckAgreement_ab33ae8af8c458aca7437a472778e4761a341f78e1e094b88dea42e94b32871067}{OriginatorBlockAckAgreement::ESTABLISHED})
416                   || \hyperlink{classns3_1_1BlockAckManager_a20324b49d01312f731087f7f707a596a}{SwitchToBlockAckIfNeeded} (recipient, tid, hdr.
      GetSequenceNumber ())))
417             \{
418               hdr.SetQosAckPolicy (\hyperlink{classns3_1_1WifiMacHeader_ae3a382482f357972019f5e1b3162adc4a8d2763ea0083f1265fbf7dda6fdcf9fd}{WifiMacHeader::BLOCK\_ACK});
419             \}
420           \textcolor{keywordflow}{else}
421             \{
422               \textcolor{comment}{/* From section 9.10.3 in IEEE802.11e standard:}
423 \textcolor{comment}{               * In order to improve efficiency, originators using the Block Ack facility}
424 \textcolor{comment}{               * may send MPDU frames with the Ack Policy subfield in QoS control frames}
425 \textcolor{comment}{               * set to Normal Ack if only a few MPDUs are available for transmission.[...]}
426 \textcolor{comment}{               * When there are sufficient number of MPDUs, the originator may switch back to}
427 \textcolor{comment}{               * the use of Block Ack.}
428 \textcolor{comment}{               */}
429               hdr.SetQosAckPolicy (\hyperlink{classns3_1_1WifiMacHeader_ae3a382482f357972019f5e1b3162adc4a9f52b9c6ca65d046ce2be9d70bce28cf}{WifiMacHeader::NORMAL\_ACK});
430             \}
431           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Peeked one packet from retry buffer size = "} << 
      \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.size () );
432           \textcolor{keywordflow}{return} packet;
433         \}
434     \}
435   \textcolor{keywordflow}{return} packet;
436 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 23




Here is the caller graph for this function\+:
% FIG 24


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Remove\+From\+Retry\+Queue@{Remove\+From\+Retry\+Queue}}
\index{Remove\+From\+Retry\+Queue@{Remove\+From\+Retry\+Queue}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Remove\+From\+Retry\+Queue(\+Mac48\+Address address, uint8\+\_\+t tid, uint16\+\_\+t seq)}{RemoveFromRetryQueue(Mac48Address address, uint8_t tid, uint16_t seq)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Block\+Ack\+Manager\+::\+Remove\+From\+Retry\+Queue (
\begin{DoxyParamCaption}
\item[{{\bf Mac48\+Address}}]{address, }
\item[{uint8\+\_\+t}]{tid, }
\item[{uint16\+\_\+t}]{seq}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BlockAckManager_aa7fc7ecdb5e0171b0e84bb39554f75e2}{}\label{classns3_1_1BlockAckManager_aa7fc7ecdb5e0171b0e84bb39554f75e2}
Remove items from retransmission queue. This method should be called when packets are acknowledged.


\begin{DoxyParams}{Parameters}
{\em address} & recipient mac address of the packet to be removed \\
\hline
{\em tid} & Traffic ID of the packet to be removed \\
\hline
{\em seq} & sequence number of the packet to be removed \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
878 \{
879   \textcolor{comment}{/* remove retry packet iterator if it's present in retry queue */}
880   std::list<PacketQueueI>::iterator it = \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.begin ();
881   \textcolor{keywordflow}{while} (it != \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.end ())
882     \{
883       \textcolor{keywordflow}{if} ((*it)->hdr.GetAddr1 () == address
884           && (*it)->hdr.GetQosTid () == tid
885           && (*it)->hdr.GetSequenceNumber () == seq)
886         \{
887           it = \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.erase (it);
888         \}
889       \textcolor{keywordflow}{else}
890         \{
891           it++;
892         \}
893     \}
894 \}
\end{DoxyCode}
\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Remove\+Packet@{Remove\+Packet}}
\index{Remove\+Packet@{Remove\+Packet}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Remove\+Packet(uint8\+\_\+t tid, Mac48\+Address recipient, uint16\+\_\+t seqnumber)}{RemovePacket(uint8_t tid, Mac48Address recipient, uint16_t seqnumber)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Block\+Ack\+Manager\+::\+Remove\+Packet (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{tid, }
\item[{{\bf Mac48\+Address}}]{recipient, }
\item[{uint16\+\_\+t}]{seqnumber}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BlockAckManager_a182b0fff297640c289affb334a61f544}{}\label{classns3_1_1BlockAckManager_a182b0fff297640c289affb334a61f544}
Remove a packet after you peek in the queue and get it 
\begin{DoxyCode}
440 \{
441 
442   std::list<PacketQueueI>::iterator it = \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.begin ();
443   \textcolor{keywordflow}{for} (; it != \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.end (); it++)
444     \{
445       \textcolor{keywordflow}{if} (!(*it)->hdr.IsQosData ())
446         \{
447           \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Packet in blockAck manager retry queue is not Qos Data"});
448         \}
449       \textcolor{keywordflow}{if} ((*it)->hdr.GetAddr1 () == recipient && (*it)->hdr.GetQosTid () == tid && (*it)->hdr.
      GetSequenceNumber () == seqnumber)
450         \{
451           WifiMacHeader hdr = (*it)->hdr;
452           uint8\_t tid = hdr.GetQosTid ();
453           Mac48Address recipient = hdr.GetAddr1 ();
454 
455           \hyperlink{classns3_1_1BlockAckManager_acbd1cf7c5f3487150955c3a4c9d04102}{AgreementsI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.find (std::make\_pair (recipient, tid));
456           i->second.second.erase ((*it));
457 
458           \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.erase (it);
459           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Removed Packet from retry queue = "} << hdr.GetSequenceNumber () << \textcolor{stringliteral}{" "}
       << (uint16\_t)tid << \textcolor{stringliteral}{" "} << recipient << \textcolor{stringliteral}{" Buffer Size = "} << \hyperlink{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{m\_retryPackets}.size ());
460           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
461         \}
462     \}
463   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
464 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 25




Here is the caller graph for this function\+:
% FIG 26


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Schedule\+Block\+Ack\+Req\+If\+Needed@{Schedule\+Block\+Ack\+Req\+If\+Needed}}
\index{Schedule\+Block\+Ack\+Req\+If\+Needed@{Schedule\+Block\+Ack\+Req\+If\+Needed}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Schedule\+Block\+Ack\+Req\+If\+Needed(\+Mac48\+Address recipient, uint8\+\_\+t tid)}{ScheduleBlockAckReqIfNeeded(Mac48Address recipient, uint8_t tid)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Packet} $>$ ns3\+::\+Block\+Ack\+Manager\+::\+Schedule\+Block\+Ack\+Req\+If\+Needed (
\begin{DoxyParamCaption}
\item[{{\bf Mac48\+Address}}]{recipient, }
\item[{uint8\+\_\+t}]{tid}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BlockAckManager_a2dd74462281ab81176310ad58a35f2ea}{}\label{classns3_1_1BlockAckManager_a2dd74462281ab81176310ad58a35f2ea}

\begin{DoxyParams}{Parameters}
{\em recipient} & \\
\hline
{\em tid} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a packet
\end{DoxyReturn}
Checks if all packets, for which a block ack agreement was established or refreshed, have been transmitted. If yes, adds a pair in m\+\_\+b\+Ack\+Reqs to indicate that at next channel access a block ack request (for established agreement {\itshape recipient},{\itshape tid}) is needed. 
\begin{DoxyCode}
701 \{
702   \textcolor{comment}{/* This method checks if a BlockAckRequest frame should be send to the recipient station.}
703 \textcolor{comment}{     Number of packets under block ack is specified in OriginatorBlockAckAgreement object but sometimes}
704 \textcolor{comment}{     this number could be incorrect. In fact is possible that a block ack agreement exists for n}
705 \textcolor{comment}{     packets but some of these packets are dropped due to MSDU lifetime expiration.}
706 \textcolor{comment}{   */}
707   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << recipient << static\_cast<uint32\_t> (tid));
708   \hyperlink{classns3_1_1BlockAckManager_acbd1cf7c5f3487150955c3a4c9d04102}{AgreementsI} it = \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.find (std::make\_pair (recipient, tid));
709   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (it != \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.end ());
710 
711   \textcolor{keywordflow}{if} ((*it).second.first.IsBlockAckRequestNeeded ()
712       || (\hyperlink{classns3_1_1BlockAckManager_a324cd181a4aedaff46eed34f92055591}{GetNRetryNeededPackets} (recipient, tid) == 0
713           && \hyperlink{classns3_1_1BlockAckManager_a5bc9e0d123696600bbeff7aa37127ec7}{m\_queue}->GetNPacketsByTidAndAddress (tid, 
      \hyperlink{classns3_1_1WifiMacHeader_a17406db48973a8e8fb6d961dd35154fea8ff9765c77ab96f3bbc7385ece3d00bf}{WifiMacHeader::ADDR1}, recipient) == 0))
714     \{
715       OriginatorBlockAckAgreement &agreement = (*it).second.first;
716       agreement.CompleteExchange ();
717 
718       CtrlBAckRequestHeader reqHdr;
719       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1BlockAckManager_aa3a0c2d7132c556a98a6672de7665cb5}{m\_blockAckType} == \hyperlink{namespacens3_a90f436472d19d7d7f37cbf0b8c288ff7a118b16b614e89a911b77a167632f89bf}{BASIC\_BLOCK\_ACK} || 
      \hyperlink{classns3_1_1BlockAckManager_aa3a0c2d7132c556a98a6672de7665cb5}{m\_blockAckType} == \hyperlink{namespacens3_a90f436472d19d7d7f37cbf0b8c288ff7ad325114ff6e0d84c1d4cea5bd810a48c}{COMPRESSED\_BLOCK\_ACK})
720         \{
721           reqHdr.SetType (\hyperlink{classns3_1_1BlockAckManager_aa3a0c2d7132c556a98a6672de7665cb5}{m\_blockAckType});
722           reqHdr.SetTidInfo (agreement.GetTid ());
723           reqHdr.SetStartingSequence (agreement.GetStartingSequence ());
724         \}
725       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1BlockAckManager_aa3a0c2d7132c556a98a6672de7665cb5}{m\_blockAckType} == \hyperlink{namespacens3_a90f436472d19d7d7f37cbf0b8c288ff7a2b0db78cd77aa4769690b7b6aac6f017}{MULTI\_TID\_BLOCK\_ACK})
726         \{
727           \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Multi-tid block ack is not supported."});
728         \}
729       \textcolor{keywordflow}{else}
730         \{
731           \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Invalid block ack type."});
732         \}
733       Ptr<Packet> bar = Create<Packet> ();
734       bar->AddHeader (reqHdr);
735       \textcolor{keywordflow}{return} bar;
736     \}
737   \textcolor{keywordflow}{return} 0;
738 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 27


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Set\+Block\+Ack\+Inactivity\+Callback@{Set\+Block\+Ack\+Inactivity\+Callback}}
\index{Set\+Block\+Ack\+Inactivity\+Callback@{Set\+Block\+Ack\+Inactivity\+Callback}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Set\+Block\+Ack\+Inactivity\+Callback(\+Callback$<$ void, Mac48\+Address, uint8\+\_\+t, bool $>$ callback)}{SetBlockAckInactivityCallback(Callback< void, Mac48Address, uint8_t, bool > callback)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Block\+Ack\+Manager\+::\+Set\+Block\+Ack\+Inactivity\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Callback}$<$ void, {\bf Mac48\+Address}, uint8\+\_\+t, bool $>$}]{callback}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BlockAckManager_aba54a7f80dad49b371ebdc5ffe11d651}{}\label{classns3_1_1BlockAckManager_aba54a7f80dad49b371ebdc5ffe11d651}
Set block ack inactivity callback 
\begin{DoxyParams}{Parameters}
{\em callback} & the block ack inactivity callback function \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
936 \{
937   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << &callback);
938   \hyperlink{classns3_1_1BlockAckManager_aca48203aee618ed997d26c5e77a246a7}{m\_blockAckInactivityTimeout} = callback;
939 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 28


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Set\+Block\+Ack\+Threshold@{Set\+Block\+Ack\+Threshold}}
\index{Set\+Block\+Ack\+Threshold@{Set\+Block\+Ack\+Threshold}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Set\+Block\+Ack\+Threshold(uint8\+\_\+t n\+Packets)}{SetBlockAckThreshold(uint8_t nPackets)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Block\+Ack\+Manager\+::\+Set\+Block\+Ack\+Threshold (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{n\+Packets}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BlockAckManager_a3d6ba0be51a232044d8373ada7f4d0e2}{}\label{classns3_1_1BlockAckManager_a3d6ba0be51a232044d8373ada7f4d0e2}

\begin{DoxyParams}{Parameters}
{\em n\+Packets} & Minimum number of packets for use of block ack.\\
\hline
\end{DoxyParams}
Upon receipt of a block ack frame, if total number of packets (packets in Wifi\+Mac\+Queue and buffered packets) is greater of {\itshape n\+Packets}, they are transmitted using block ack mechanism. 
\begin{DoxyCode}
548 \{
549   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << (uint16\_t)nPackets);
550   \hyperlink{classns3_1_1BlockAckManager_a310943df91ddcf02959cd646a3b9cbce}{m\_blockAckThreshold} = nPackets;
551 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 29


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Set\+Block\+Ack\+Type@{Set\+Block\+Ack\+Type}}
\index{Set\+Block\+Ack\+Type@{Set\+Block\+Ack\+Type}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Set\+Block\+Ack\+Type(\+Block\+Ack\+Type b\+Ack\+Type)}{SetBlockAckType(BlockAckType bAckType)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Block\+Ack\+Manager\+::\+Set\+Block\+Ack\+Type (
\begin{DoxyParamCaption}
\item[{{\bf Block\+Ack\+Type}}]{b\+Ack\+Type}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BlockAckManager_ab281f28839a128021bf1a7369d75d502}{}\label{classns3_1_1BlockAckManager_ab281f28839a128021bf1a7369d75d502}

\begin{DoxyParams}{Parameters}
{\em b\+Ack\+Type} & Type of block ack\\
\hline
\end{DoxyParams}
See \hyperlink{ctrl-headers_8h}{ctrl-\/headers.\+h} for more details. 
\begin{DoxyCode}
694 \{
695   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << bAckType);
696   \hyperlink{classns3_1_1BlockAckManager_aa3a0c2d7132c556a98a6672de7665cb5}{m\_blockAckType} = bAckType;
697 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 30


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Set\+Block\+Destination\+Callback@{Set\+Block\+Destination\+Callback}}
\index{Set\+Block\+Destination\+Callback@{Set\+Block\+Destination\+Callback}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Set\+Block\+Destination\+Callback(\+Callback$<$ void, Mac48\+Address, uint8\+\_\+t $>$ callback)}{SetBlockDestinationCallback(Callback< void, Mac48Address, uint8_t > callback)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Block\+Ack\+Manager\+::\+Set\+Block\+Destination\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Callback}$<$ void, {\bf Mac48\+Address}, uint8\+\_\+t $>$}]{callback}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BlockAckManager_a9ff02e52af689aa218f43e871a43503d}{}\label{classns3_1_1BlockAckManager_a9ff02e52af689aa218f43e871a43503d}
Set block destination callback 
\begin{DoxyParams}{Parameters}
{\em callback} & the block destination callback \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
943 \{
944   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << &callback);
945   \hyperlink{classns3_1_1BlockAckManager_aed8b4d86e877d3e5a2ed869636328867}{m\_blockPackets} = callback;
946 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 31


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Set\+Max\+Packet\+Delay@{Set\+Max\+Packet\+Delay}}
\index{Set\+Max\+Packet\+Delay@{Set\+Max\+Packet\+Delay}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Set\+Max\+Packet\+Delay(\+Time max\+Delay)}{SetMaxPacketDelay(Time maxDelay)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Block\+Ack\+Manager\+::\+Set\+Max\+Packet\+Delay (
\begin{DoxyParamCaption}
\item[{{\bf Time}}]{max\+Delay}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BlockAckManager_abf175ea3603c1ef5cd1edd21a5911da2}{}\label{classns3_1_1BlockAckManager_abf175ea3603c1ef5cd1edd21a5911da2}

\begin{DoxyParams}{Parameters}
{\em max\+Delay} & Max delay for a buffered packet.\\
\hline
\end{DoxyParams}
This method is always called by \hyperlink{namespacens3_a3ca96bcdf02c0e7cacea08ca62ead54c}{ns3\+::\+Wifi\+Mac\+Queue} object and sets max delay equals to \hyperlink{namespacens3}{ns3}\+:Wifi\+Mac\+Queue delay value. 
\begin{DoxyCode}
929 \{
930   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << maxDelay);
931   \hyperlink{classns3_1_1BlockAckManager_a5eabe70b6e25dac515f8ec6c38d45f75}{m\_maxDelay} = maxDelay;
932 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 32


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Set\+Queue@{Set\+Queue}}
\index{Set\+Queue@{Set\+Queue}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Set\+Queue(\+Ptr$<$ Wifi\+Mac\+Queue $>$ queue)}{SetQueue(Ptr< WifiMacQueue > queue)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Block\+Ack\+Manager\+::\+Set\+Queue (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Wifi\+Mac\+Queue} $>$}]{queue}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BlockAckManager_a220aecfc19f84b497b1ee8781641e2a1}{}\label{classns3_1_1BlockAckManager_a220aecfc19f84b497b1ee8781641e2a1}

\begin{DoxyParams}{Parameters}
{\em queue} & The Wifi\+Mac\+Queue object. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
801 \{
802   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << queue);
803   \hyperlink{classns3_1_1BlockAckManager_a5bc9e0d123696600bbeff7aa37127ec7}{m\_queue} = queue;
804 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 33


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Set\+Tx\+Failed\+Callback@{Set\+Tx\+Failed\+Callback}}
\index{Set\+Tx\+Failed\+Callback@{Set\+Tx\+Failed\+Callback}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Set\+Tx\+Failed\+Callback(\+Tx\+Failed callback)}{SetTxFailedCallback(TxFailed callback)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Block\+Ack\+Manager\+::\+Set\+Tx\+Failed\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Tx\+Failed}}]{callback}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BlockAckManager_a0ee71617a29e7e00ab9c62194b4501a7}{}\label{classns3_1_1BlockAckManager_a0ee71617a29e7e00ab9c62194b4501a7}

\begin{DoxyParams}{Parameters}
{\em callback} & the callback to invoke when a packet transmission was completed unsuccessfully. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
990 \{
991   \hyperlink{classns3_1_1BlockAckManager_a58ccfd5da1b7e739b732699ddcc13530}{m\_txFailedCallback} = callback;
992 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 34


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Set\+Tx\+Middle@{Set\+Tx\+Middle}}
\index{Set\+Tx\+Middle@{Set\+Tx\+Middle}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Set\+Tx\+Middle(\+Mac\+Tx\+Middle $\ast$tx\+Middle)}{SetTxMiddle(MacTxMiddle *txMiddle)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Block\+Ack\+Manager\+::\+Set\+Tx\+Middle (
\begin{DoxyParamCaption}
\item[{{\bf Mac\+Tx\+Middle} $\ast$}]{tx\+Middle}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BlockAckManager_a76ee2237b1d65a04f96806fa25d30d24}{}\label{classns3_1_1BlockAckManager_a76ee2237b1d65a04f96806fa25d30d24}
Set the \hyperlink{classns3_1_1MacTxMiddle}{Mac\+Tx\+Middle} 
\begin{DoxyParams}{Parameters}
{\em tx\+Middle} & the \hyperlink{classns3_1_1MacTxMiddle}{Mac\+Tx\+Middle} \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
957 \{
958   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << txMiddle);
959   \hyperlink{classns3_1_1BlockAckManager_a3c78348cca01da647d813f90d2463a44}{m\_txMiddle} = txMiddle;
960 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 35


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Set\+Tx\+Ok\+Callback@{Set\+Tx\+Ok\+Callback}}
\index{Set\+Tx\+Ok\+Callback@{Set\+Tx\+Ok\+Callback}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Set\+Tx\+Ok\+Callback(\+Tx\+Ok callback)}{SetTxOkCallback(TxOk callback)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Block\+Ack\+Manager\+::\+Set\+Tx\+Ok\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Tx\+Ok}}]{callback}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BlockAckManager_a2007df06d972c94c7e2b35b7b0bce555}{}\label{classns3_1_1BlockAckManager_a2007df06d972c94c7e2b35b7b0bce555}

\begin{DoxyParams}{Parameters}
{\em callback} & the callback to invoke when a packet transmission was completed successfully. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
984 \{
985   \hyperlink{classns3_1_1BlockAckManager_ace96f46b7c52c441becc70227b70d070}{m\_txOkCallback} = callback;
986 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 36


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Set\+Unblock\+Destination\+Callback@{Set\+Unblock\+Destination\+Callback}}
\index{Set\+Unblock\+Destination\+Callback@{Set\+Unblock\+Destination\+Callback}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Set\+Unblock\+Destination\+Callback(\+Callback$<$ void, Mac48\+Address, uint8\+\_\+t $>$ callback)}{SetUnblockDestinationCallback(Callback< void, Mac48Address, uint8_t > callback)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Block\+Ack\+Manager\+::\+Set\+Unblock\+Destination\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Callback}$<$ void, {\bf Mac48\+Address}, uint8\+\_\+t $>$}]{callback}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BlockAckManager_a591b2a7853ffdd524a1e952cd44820eb}{}\label{classns3_1_1BlockAckManager_a591b2a7853ffdd524a1e952cd44820eb}
Set unblock destination callback 
\begin{DoxyParams}{Parameters}
{\em callback} & the unblock destination callback \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
950 \{
951   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << &callback);
952   \hyperlink{classns3_1_1BlockAckManager_a1ac5899b37bf2ffee1814cefebe8fe29}{m\_unblockPackets} = callback;
953 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 37


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Set\+Wifi\+Remote\+Station\+Manager@{Set\+Wifi\+Remote\+Station\+Manager}}
\index{Set\+Wifi\+Remote\+Station\+Manager@{Set\+Wifi\+Remote\+Station\+Manager}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Set\+Wifi\+Remote\+Station\+Manager(\+Ptr$<$ Wifi\+Remote\+Station\+Manager $>$ manager)}{SetWifiRemoteStationManager(Ptr< WifiRemoteStationManager > manager)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Block\+Ack\+Manager\+::\+Set\+Wifi\+Remote\+Station\+Manager (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Wifi\+Remote\+Station\+Manager} $>$}]{manager}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BlockAckManager_a7f1b2bae83d50eb0999ed609075571a8}{}\label{classns3_1_1BlockAckManager_a7f1b2bae83d50eb0999ed609075571a8}
Set up \hyperlink{classns3_1_1WifiRemoteStationManager}{Wifi\+Remote\+Station\+Manager} associated with this \hyperlink{classns3_1_1BlockAckManager}{Block\+Ack\+Manager}.


\begin{DoxyParams}{Parameters}
{\em manager} & \hyperlink{classns3_1_1WifiRemoteStationManager}{Wifi\+Remote\+Station\+Manager} associated with this \hyperlink{classns3_1_1BlockAckManager}{Block\+Ack\+Manager} \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
555 \{
556   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << manager);
557   \hyperlink{classns3_1_1BlockAckManager_afb809abb11edae6179dc2f5b8c1f8ce5}{m\_stationManager} = manager;
558 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 38


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Store\+Packet@{Store\+Packet}}
\index{Store\+Packet@{Store\+Packet}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Store\+Packet(\+Ptr$<$ const Packet $>$ packet, const Wifi\+Mac\+Header \&hdr, Time t\+Stamp)}{StorePacket(Ptr< const Packet > packet, const WifiMacHeader &hdr, Time tStamp)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Block\+Ack\+Manager\+::\+Store\+Packet (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{packet, }
\item[{const {\bf Wifi\+Mac\+Header} \&}]{hdr, }
\item[{{\bf Time}}]{t\+Stamp}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BlockAckManager_a0d30c0aa10a79c5cc7b06b19e956c5cc}{}\label{classns3_1_1BlockAckManager_a0d30c0aa10a79c5cc7b06b19e956c5cc}

\begin{DoxyParams}{Parameters}
{\em packet} & \hyperlink{classns3_1_1Packet}{Packet} to store. \\
\hline
{\em hdr} & 802.\+11 header for packet. \\
\hline
{\em t\+Stamp} & time stamp for packet\\
\hline
\end{DoxyParams}
Stores {\itshape packet} for a possible future retransmission. Retransmission occurs if the packet, in a block ack frame, is indicated by recipient as not received. 
\begin{DoxyCode}
203 \{
204   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << hdr << tStamp);
205   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (hdr.IsQosData ());
206 
207   uint8\_t tid = hdr.GetQosTid ();
208   Mac48Address recipient = hdr.GetAddr1 ();
209 
210   Item item (packet, hdr, tStamp);
211   \hyperlink{classns3_1_1BlockAckManager_acbd1cf7c5f3487150955c3a4c9d04102}{AgreementsI} it = \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.find (std::make\_pair (recipient, tid));
212   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (it != \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.end ());
213   \hyperlink{classns3_1_1BlockAckManager_a2bb94802381e70535e8a7c892fd01d48}{PacketQueueI} queueIt = it->second.second.begin ();
214   \textcolor{keywordflow}{for} (; queueIt != it->second.second.end (); )
215     \{
216       \textcolor{keywordflow}{if} (((hdr.GetSequenceNumber () - queueIt->hdr.GetSequenceNumber () + 4096) % 4096) > 2047)
217         \{
218           queueIt = it->second.second.insert (queueIt, item);
219           \textcolor{keywordflow}{break};
220         \}
221       \textcolor{keywordflow}{else}
222         \{
223           queueIt++;
224         \}
225     \}
226   \textcolor{keywordflow}{if} (queueIt == it->second.second.end ())
227     \{
228       it->second.second.push\_back (item);
229     \}
230 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 39




Here is the caller graph for this function\+:
% FIG 40


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Switch\+To\+Block\+Ack\+If\+Needed@{Switch\+To\+Block\+Ack\+If\+Needed}}
\index{Switch\+To\+Block\+Ack\+If\+Needed@{Switch\+To\+Block\+Ack\+If\+Needed}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Switch\+To\+Block\+Ack\+If\+Needed(\+Mac48\+Address recipient, uint8\+\_\+t tid, uint16\+\_\+t starting\+Seq)}{SwitchToBlockAckIfNeeded(Mac48Address recipient, uint8_t tid, uint16_t startingSeq)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Block\+Ack\+Manager\+::\+Switch\+To\+Block\+Ack\+If\+Needed (
\begin{DoxyParamCaption}
\item[{{\bf Mac48\+Address}}]{recipient, }
\item[{uint8\+\_\+t}]{tid, }
\item[{uint16\+\_\+t}]{starting\+Seq}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BlockAckManager_a20324b49d01312f731087f7f707a596a}{}\label{classns3_1_1BlockAckManager_a20324b49d01312f731087f7f707a596a}

\begin{DoxyParams}{Parameters}
{\em recipient} & \\
\hline
{\em tid} & \\
\hline
{\em starting\+Seq} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if there are packets in the queue that could be sent under block A\+CK, false otherwise
\end{DoxyReturn}
Checks if there are in the queue other packets that could be send under block ack. If yes adds these packets in current block ack exchange. However, number of packets exchanged in the current block ack, will not exceed the value of Buffer\+Size in the corresponding \hyperlink{classns3_1_1OriginatorBlockAckAgreement}{Originator\+Block\+Ack\+Agreement} object. 
\begin{DoxyCode}
808 \{
809   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << recipient << (uint16\_t)tid << startingSeq);
810   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (!\hyperlink{classns3_1_1BlockAckManager_ae13c4678f75ebfda7f63d0521878662b}{ExistsAgreementInState} (recipient, tid, 
      \hyperlink{classns3_1_1OriginatorBlockAckAgreement_ab33ae8af8c458aca7437a472778e4761a0f8c3879c3167ef79a0d4c57ac6015ff}{OriginatorBlockAckAgreement::PENDING}));
811   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1BlockAckManager_ae13c4678f75ebfda7f63d0521878662b}{ExistsAgreementInState} (recipient, tid, 
      \hyperlink{classns3_1_1OriginatorBlockAckAgreement_ab33ae8af8c458aca7437a472778e4761a87f84c6aa88a34abf61f0be8313319ee}{OriginatorBlockAckAgreement::UNSUCCESSFUL}) && 
      \hyperlink{classns3_1_1BlockAckManager_a4712688bb7764d576c87fd627d3d3aba}{ExistsAgreement} (recipient, tid))
812     \{
813       uint32\_t packets = \hyperlink{classns3_1_1BlockAckManager_a5bc9e0d123696600bbeff7aa37127ec7}{m\_queue}->GetNPacketsByTidAndAddress (tid, 
      \hyperlink{classns3_1_1WifiMacHeader_a17406db48973a8e8fb6d961dd35154fea8ff9765c77ab96f3bbc7385ece3d00bf}{WifiMacHeader::ADDR1}, recipient) +
814         \hyperlink{classns3_1_1BlockAckManager_af1da67d0de14b53997fbeedaa93f7380}{GetNBufferedPackets} (recipient, tid);
815       \textcolor{keywordflow}{if} (packets >= \hyperlink{classns3_1_1BlockAckManager_a310943df91ddcf02959cd646a3b9cbce}{m\_blockAckThreshold})
816         \{
817           \hyperlink{classns3_1_1BlockAckManager_a46a5ec91aff9a426456706443a04f4c9}{NotifyAgreementEstablished} (recipient, tid, startingSeq);
818           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
819         \}
820     \}
821   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
822 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 41


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Tear\+Down\+Block\+Ack@{Tear\+Down\+Block\+Ack}}
\index{Tear\+Down\+Block\+Ack@{Tear\+Down\+Block\+Ack}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Tear\+Down\+Block\+Ack(\+Mac48\+Address recipient, uint8\+\_\+t tid)}{TearDownBlockAck(Mac48Address recipient, uint8_t tid)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Block\+Ack\+Manager\+::\+Tear\+Down\+Block\+Ack (
\begin{DoxyParamCaption}
\item[{{\bf Mac48\+Address}}]{recipient, }
\item[{uint8\+\_\+t}]{tid}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BlockAckManager_ac18cb8344ca8061c116df54064aee5e4}{}\label{classns3_1_1BlockAckManager_ac18cb8344ca8061c116df54064aee5e4}

\begin{DoxyParams}{Parameters}
{\em recipient} & \hyperlink{classns3_1_1Address}{Address} of station involved in block ack mechanism. \\
\hline
{\em tid} & Traffic ID.\\
\hline
\end{DoxyParams}
This method is invoked by \hyperlink{classns3_1_1EdcaTxopN}{Edca\+TxopN} object upon receipt of a D\+E\+L\+BA frame from recipient. The relative block ack agreement is destroyed. 
\begin{DoxyCode}
826 \{
827   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << recipient << (uint16\_t)tid);
828   \hyperlink{classns3_1_1BlockAckManager_a4f2adf7575098ab82e1d94466cc9d18a}{DestroyAgreement} (recipient, tid);
829 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 42


\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!Update\+Agreement@{Update\+Agreement}}
\index{Update\+Agreement@{Update\+Agreement}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{Update\+Agreement(const Mgt\+Add\+Ba\+Response\+Header $\ast$resp\+Hdr, Mac48\+Address recipient)}{UpdateAgreement(const MgtAddBaResponseHeader *respHdr, Mac48Address recipient)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Block\+Ack\+Manager\+::\+Update\+Agreement (
\begin{DoxyParamCaption}
\item[{const {\bf Mgt\+Add\+Ba\+Response\+Header} $\ast$}]{resp\+Hdr, }
\item[{{\bf Mac48\+Address}}]{recipient}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1BlockAckManager_ac5b719210486783186579641e599d362}{}\label{classns3_1_1BlockAckManager_ac5b719210486783186579641e599d362}

\begin{DoxyParams}{Parameters}
{\em resp\+Hdr} & Relative Add block ack response (action frame). \\
\hline
{\em recipient} & \hyperlink{classns3_1_1Address}{Address} of peer station involved in block ack mechanism.\\
\hline
\end{DoxyParams}
Invoked upon receipt of a A\+D\+D\+BA response frame from {\itshape recipient}. 
\begin{DoxyCode}
170 \{
171   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << respHdr << recipient);
172   uint8\_t tid = respHdr->GetTid ();
173   \hyperlink{classns3_1_1BlockAckManager_acbd1cf7c5f3487150955c3a4c9d04102}{AgreementsI} it = \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.find (std::make\_pair (recipient, tid));
174   \textcolor{keywordflow}{if} (it != \hyperlink{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{m\_agreements}.end ())
175     \{
176       OriginatorBlockAckAgreement& agreement = it->second.first;
177       agreement.SetBufferSize (respHdr->GetBufferSize () + 1);
178       agreement.SetTimeout (respHdr->GetTimeout ());
179       agreement.SetAmsduSupport (respHdr->IsAmsduSupported ());
180       \textcolor{keywordflow}{if} (respHdr->IsImmediateBlockAck ())
181         \{
182           agreement.SetImmediateBlockAck ();
183         \}
184       \textcolor{keywordflow}{else}
185         \{
186           agreement.SetDelayedBlockAck ();
187         \}
188       agreement.SetState (\hyperlink{classns3_1_1OriginatorBlockAckAgreement_ab33ae8af8c458aca7437a472778e4761a341f78e1e094b88dea42e94b32871067}{OriginatorBlockAckAgreement::ESTABLISHED})
      ;
189       \textcolor{keywordflow}{if} (agreement.GetTimeout () != 0)
190         \{
191           \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} \hyperlink{openflow-switch_8cc_a386d174ae121d1cfa279074b7e209714}{timeout} = \hyperlink{group__timecivil_ga17465a639c8d1464e76538afdd78a9f0}{MicroSeconds} (1024 * agreement.GetTimeout ());
192           agreement.m\_inactivityEvent = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (timeout,
193                                                              &
      \hyperlink{classns3_1_1BlockAckManager_a7846b31a39f8e2c3302020e4c66ae31f}{BlockAckManager::InactivityTimeout},
194                                                              \textcolor{keyword}{this},
195                                                              recipient, tid);
196         \}
197     \}
198   \hyperlink{classns3_1_1BlockAckManager_a1ac5899b37bf2ffee1814cefebe8fe29}{m\_unblockPackets} (recipient, tid);
199 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 43




Here is the caller graph for this function\+:
% FIG 44




\subsection{Member Data Documentation}
\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!m\+\_\+address@{m\+\_\+address}}
\index{m\+\_\+address@{m\+\_\+address}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{m\+\_\+address}{m_address}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Mac48\+Address} ns3\+::\+Block\+Ack\+Manager\+::m\+\_\+address\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BlockAckManager_af22b7c479eb2dbd8e1e7a360e807d889}{}\label{classns3_1_1BlockAckManager_af22b7c479eb2dbd8e1e7a360e807d889}


address 

\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!m\+\_\+agreements@{m\+\_\+agreements}}
\index{m\+\_\+agreements@{m\+\_\+agreements}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{m\+\_\+agreements}{m_agreements}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Agreements} ns3\+::\+Block\+Ack\+Manager\+::m\+\_\+agreements\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}{}\label{classns3_1_1BlockAckManager_a952a6b8b29705c83ba6464f7cf7ffe66}
This data structure contains, for each block ack agreement (recipient, tid), a set of packets for which an ack by block ack is requested. Every packet or fragment indicated as correctly received in block ack frame is erased from this data structure. Pushed back in retransmission queue otherwise. \index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!m\+\_\+bars@{m\+\_\+bars}}
\index{m\+\_\+bars@{m\+\_\+bars}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{m\+\_\+bars}{m_bars}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std\+::list}$<${\bf Bar}$>$ ns3\+::\+Block\+Ack\+Manager\+::m\+\_\+bars\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BlockAckManager_af2339008509896569fe53c035f27c9b4}{}\label{classns3_1_1BlockAckManager_af2339008509896569fe53c035f27c9b4}


list of B\+A\+Rs 

\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!m\+\_\+block\+Ack\+Inactivity\+Timeout@{m\+\_\+block\+Ack\+Inactivity\+Timeout}}
\index{m\+\_\+block\+Ack\+Inactivity\+Timeout@{m\+\_\+block\+Ack\+Inactivity\+Timeout}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{m\+\_\+block\+Ack\+Inactivity\+Timeout}{m_blockAckInactivityTimeout}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Callback}$<$void, {\bf Mac48\+Address}, uint8\+\_\+t, bool$>$ ns3\+::\+Block\+Ack\+Manager\+::m\+\_\+block\+Ack\+Inactivity\+Timeout\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BlockAckManager_aca48203aee618ed997d26c5e77a246a7}{}\label{classns3_1_1BlockAckManager_aca48203aee618ed997d26c5e77a246a7}


block ack inactivity timeout callback 

\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!m\+\_\+block\+Ack\+Threshold@{m\+\_\+block\+Ack\+Threshold}}
\index{m\+\_\+block\+Ack\+Threshold@{m\+\_\+block\+Ack\+Threshold}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{m\+\_\+block\+Ack\+Threshold}{m_blockAckThreshold}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::\+Block\+Ack\+Manager\+::m\+\_\+block\+Ack\+Threshold\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BlockAckManager_a310943df91ddcf02959cd646a3b9cbce}{}\label{classns3_1_1BlockAckManager_a310943df91ddcf02959cd646a3b9cbce}


bock ack threshold 

\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!m\+\_\+block\+Ack\+Type@{m\+\_\+block\+Ack\+Type}}
\index{m\+\_\+block\+Ack\+Type@{m\+\_\+block\+Ack\+Type}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{m\+\_\+block\+Ack\+Type}{m_blockAckType}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Block\+Ack\+Type} ns3\+::\+Block\+Ack\+Manager\+::m\+\_\+block\+Ack\+Type\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BlockAckManager_aa3a0c2d7132c556a98a6672de7665cb5}{}\label{classns3_1_1BlockAckManager_aa3a0c2d7132c556a98a6672de7665cb5}


bock ack type 

\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!m\+\_\+block\+Packets@{m\+\_\+block\+Packets}}
\index{m\+\_\+block\+Packets@{m\+\_\+block\+Packets}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{m\+\_\+block\+Packets}{m_blockPackets}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Callback}$<$void, {\bf Mac48\+Address}, uint8\+\_\+t$>$ ns3\+::\+Block\+Ack\+Manager\+::m\+\_\+block\+Packets\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BlockAckManager_aed8b4d86e877d3e5a2ed869636328867}{}\label{classns3_1_1BlockAckManager_aed8b4d86e877d3e5a2ed869636328867}


block packets callback 

\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!m\+\_\+max\+Delay@{m\+\_\+max\+Delay}}
\index{m\+\_\+max\+Delay@{m\+\_\+max\+Delay}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Delay}{m_maxDelay}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Block\+Ack\+Manager\+::m\+\_\+max\+Delay\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BlockAckManager_a5eabe70b6e25dac515f8ec6c38d45f75}{}\label{classns3_1_1BlockAckManager_a5eabe70b6e25dac515f8ec6c38d45f75}


maximum delay 

\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!m\+\_\+queue@{m\+\_\+queue}}
\index{m\+\_\+queue@{m\+\_\+queue}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{m\+\_\+queue}{m_queue}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Wifi\+Mac\+Queue}$>$ ns3\+::\+Block\+Ack\+Manager\+::m\+\_\+queue\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BlockAckManager_a5bc9e0d123696600bbeff7aa37127ec7}{}\label{classns3_1_1BlockAckManager_a5bc9e0d123696600bbeff7aa37127ec7}


queue 

\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!m\+\_\+retry\+Packets@{m\+\_\+retry\+Packets}}
\index{m\+\_\+retry\+Packets@{m\+\_\+retry\+Packets}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{m\+\_\+retry\+Packets}{m_retryPackets}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std\+::list}$<${\bf Packet\+QueueI}$>$ ns3\+::\+Block\+Ack\+Manager\+::m\+\_\+retry\+Packets\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}{}\label{classns3_1_1BlockAckManager_a2851f947dd68945ebc25961cff893ed9}
This list contains all iterators to stored packets that need to be retransmitted. A packet needs retransmission if it\textquotesingle{}s indicated as not correctly received in a block ack frame. \index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!m\+\_\+station\+Manager@{m\+\_\+station\+Manager}}
\index{m\+\_\+station\+Manager@{m\+\_\+station\+Manager}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{m\+\_\+station\+Manager}{m_stationManager}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Wifi\+Remote\+Station\+Manager}$>$ ns3\+::\+Block\+Ack\+Manager\+::m\+\_\+station\+Manager\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BlockAckManager_afb809abb11edae6179dc2f5b8c1f8ce5}{}\label{classns3_1_1BlockAckManager_afb809abb11edae6179dc2f5b8c1f8ce5}


the station manager 

\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!m\+\_\+tx\+Failed\+Callback@{m\+\_\+tx\+Failed\+Callback}}
\index{m\+\_\+tx\+Failed\+Callback@{m\+\_\+tx\+Failed\+Callback}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{m\+\_\+tx\+Failed\+Callback}{m_txFailedCallback}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tx\+Failed} ns3\+::\+Block\+Ack\+Manager\+::m\+\_\+tx\+Failed\+Callback\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BlockAckManager_a58ccfd5da1b7e739b732699ddcc13530}{}\label{classns3_1_1BlockAckManager_a58ccfd5da1b7e739b732699ddcc13530}


transmit failed callback 

\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!m\+\_\+tx\+Middle@{m\+\_\+tx\+Middle}}
\index{m\+\_\+tx\+Middle@{m\+\_\+tx\+Middle}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{m\+\_\+tx\+Middle}{m_txMiddle}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Mac\+Tx\+Middle}$\ast$ ns3\+::\+Block\+Ack\+Manager\+::m\+\_\+tx\+Middle\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BlockAckManager_a3c78348cca01da647d813f90d2463a44}{}\label{classns3_1_1BlockAckManager_a3c78348cca01da647d813f90d2463a44}


the \hyperlink{classns3_1_1MacTxMiddle}{Mac\+Tx\+Middle} 

\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!m\+\_\+tx\+Ok\+Callback@{m\+\_\+tx\+Ok\+Callback}}
\index{m\+\_\+tx\+Ok\+Callback@{m\+\_\+tx\+Ok\+Callback}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{m\+\_\+tx\+Ok\+Callback}{m_txOkCallback}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tx\+Ok} ns3\+::\+Block\+Ack\+Manager\+::m\+\_\+tx\+Ok\+Callback\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BlockAckManager_ace96f46b7c52c441becc70227b70d070}{}\label{classns3_1_1BlockAckManager_ace96f46b7c52c441becc70227b70d070}


transmit ok callback 

\index{ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}!m\+\_\+unblock\+Packets@{m\+\_\+unblock\+Packets}}
\index{m\+\_\+unblock\+Packets@{m\+\_\+unblock\+Packets}!ns3\+::\+Block\+Ack\+Manager@{ns3\+::\+Block\+Ack\+Manager}}
\subsubsection[{\texorpdfstring{m\+\_\+unblock\+Packets}{m_unblockPackets}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Callback}$<$void, {\bf Mac48\+Address}, uint8\+\_\+t$>$ ns3\+::\+Block\+Ack\+Manager\+::m\+\_\+unblock\+Packets\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1BlockAckManager_a1ac5899b37bf2ffee1814cefebe8fe29}{}\label{classns3_1_1BlockAckManager_a1ac5899b37bf2ffee1814cefebe8fe29}


unblock packets callback 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
wifi/model/\hyperlink{block-ack-manager_8h}{block-\/ack-\/manager.\+h}\item 
wifi/model/\hyperlink{block-ack-manager_8cc}{block-\/ack-\/manager.\+cc}\end{DoxyCompactItemize}
