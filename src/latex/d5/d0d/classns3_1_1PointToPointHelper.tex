\hypertarget{classns3_1_1PointToPointHelper}{}\section{ns3\+:\+:Point\+To\+Point\+Helper Class Reference}
\label{classns3_1_1PointToPointHelper}\index{ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}}


Build a set of \hyperlink{classns3_1_1PointToPointNetDevice}{Point\+To\+Point\+Net\+Device} objects.  




{\ttfamily \#include $<$point-\/to-\/point-\/helper.\+h$>$}



Inheritance diagram for ns3\+:\+:Point\+To\+Point\+Helper\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Point\+To\+Point\+Helper\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1PointToPointHelper_a1fe84d31984c0711db0b1516ecb1b579}{Point\+To\+Point\+Helper} ()
\item 
virtual \hyperlink{classns3_1_1PointToPointHelper_aaafd91a8b14a3af52e6d83b4c874462e}{$\sim$\+Point\+To\+Point\+Helper} ()
\item 
void \hyperlink{classns3_1_1PointToPointHelper_a546a5c9ae3c9eab0ea98b25fd41e3c95}{Set\+Queue} (std\+::string \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type}, std\+::string n1=\char`\"{}\char`\"{}, const \hyperlink{classns3_1_1AttributeValue}{Attribute\+Value} \&v1=\hyperlink{classns3_1_1EmptyAttributeValue}{Empty\+Attribute\+Value}(), std\+::string n2=\char`\"{}\char`\"{}, const \hyperlink{classns3_1_1AttributeValue}{Attribute\+Value} \&v2=\hyperlink{classns3_1_1EmptyAttributeValue}{Empty\+Attribute\+Value}(), std\+::string n3=\char`\"{}\char`\"{}, const \hyperlink{classns3_1_1AttributeValue}{Attribute\+Value} \&v3=\hyperlink{classns3_1_1EmptyAttributeValue}{Empty\+Attribute\+Value}(), std\+::string n4=\char`\"{}\char`\"{}, const \hyperlink{classns3_1_1AttributeValue}{Attribute\+Value} \&v4=\hyperlink{classns3_1_1EmptyAttributeValue}{Empty\+Attribute\+Value}())
\item 
void \hyperlink{classns3_1_1PointToPointHelper_a4577f5ab8c387e5528af2e0fbab1152e}{Set\+Device\+Attribute} (std\+::string \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name}, const \hyperlink{classns3_1_1AttributeValue}{Attribute\+Value} \&value)
\item 
void \hyperlink{classns3_1_1PointToPointHelper_a6b5317fd17fb61e5a53f8d66a90b63b9}{Set\+Channel\+Attribute} (std\+::string \hyperlink{generate__test__data__lte__spectrum__model_8m_ab74e6bf80237ddc4109968cedc58c151}{name}, const \hyperlink{classns3_1_1AttributeValue}{Attribute\+Value} \&value)
\item 
\hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} \hyperlink{classns3_1_1PointToPointHelper_ab9162fea3e88722666fed1106df1f9ec}{Install} (\hyperlink{classns3_1_1NodeContainer}{Node\+Container} \hyperlink{mmwave_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c})
\item 
\hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} \hyperlink{classns3_1_1PointToPointHelper_aecfc3e7bc34a5fa9707b26df08ef913a}{Install} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ a, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{lte__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b})
\item 
\hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} \hyperlink{classns3_1_1PointToPointHelper_aacdd0082d28133831bab1484f37b9514}{Install} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ a, std\+::string b\+Name)
\item 
\hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} \hyperlink{classns3_1_1PointToPointHelper_a0074be81c1506a6c366e8162da0eedf0}{Install} (std\+::string a\+Name, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{lte__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b})
\item 
\hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} \hyperlink{classns3_1_1PointToPointHelper_a767d84c3e257d67c7ca54da8e0cacabe}{Install} (std\+::string a\+Node, std\+::string b\+Node)
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1PointToPointHelper_abe3ce49bfc07a9d40cead59b508b9c3e}{Enable\+Pcap\+Internal} (std\+::string prefix, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ nd, bool promiscuous, bool explicit\+Filename)
\begin{DoxyCompactList}\small\item\em Enable pcap output the indicated net device. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1PointToPointHelper_a500491e31095208060544b015d1112d5}{Enable\+Ascii\+Internal} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream, std\+::string prefix, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ nd, bool explicit\+Filename)
\begin{DoxyCompactList}\small\item\em Enable ascii trace output on the indicated net device. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1ObjectFactory}{Object\+Factory} \hyperlink{classns3_1_1PointToPointHelper_a79d2da8ad9d40adc181d4c1b8520890f}{m\+\_\+queue\+Factory}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Queue}{Queue} Factory. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1ObjectFactory}{Object\+Factory} \hyperlink{classns3_1_1PointToPointHelper_a1ba59f6f265fcda8868bd4d5891a1c72}{m\+\_\+channel\+Factory}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Channel}{Channel} Factory. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1ObjectFactory}{Object\+Factory} \hyperlink{classns3_1_1PointToPointHelper_a96abd585304725f9ad2810503f795039}{m\+\_\+remote\+Channel\+Factory}
\begin{DoxyCompactList}\small\item\em Remote \hyperlink{classns3_1_1Channel}{Channel} Factory. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1ObjectFactory}{Object\+Factory} \hyperlink{classns3_1_1PointToPointHelper_ab70d3d643f30b809c90530d494a73eb4}{m\+\_\+device\+Factory}
\begin{DoxyCompactList}\small\item\em Device Factory. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Build a set of \hyperlink{classns3_1_1PointToPointNetDevice}{Point\+To\+Point\+Net\+Device} objects. 

Normally we eschew multiple inheritance, however, the classes Pcap\+User\+Helper\+For\+Device and Ascii\+Trace\+User\+Helper\+For\+Device are \char`\"{}mixins\char`\"{}. 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}!Point\+To\+Point\+Helper@{Point\+To\+Point\+Helper}}
\index{Point\+To\+Point\+Helper@{Point\+To\+Point\+Helper}!ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}}
\subsubsection[{\texorpdfstring{Point\+To\+Point\+Helper()}{PointToPointHelper()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Point\+To\+Point\+Helper\+::\+Point\+To\+Point\+Helper (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PointToPointHelper_a1fe84d31984c0711db0b1516ecb1b579}{}\label{classns3_1_1PointToPointHelper_a1fe84d31984c0711db0b1516ecb1b579}
Create a \hyperlink{classns3_1_1PointToPointHelper}{Point\+To\+Point\+Helper} to make life easier when creating point to point networks. 
\begin{DoxyCode}
42 \{
43   \hyperlink{classns3_1_1PointToPointHelper_a79d2da8ad9d40adc181d4c1b8520890f}{m\_queueFactory}.\hyperlink{classns3_1_1ObjectFactory_a77dcd099064038a1eb7a6b8251229ec3}{SetTypeId} (\textcolor{stringliteral}{"ns3::DropTailQueue<Packet>"});
44   \hyperlink{classns3_1_1PointToPointHelper_ab70d3d643f30b809c90530d494a73eb4}{m\_deviceFactory}.\hyperlink{classns3_1_1ObjectFactory_a77dcd099064038a1eb7a6b8251229ec3}{SetTypeId} (\textcolor{stringliteral}{"ns3::PointToPointNetDevice"});
45   \hyperlink{classns3_1_1PointToPointHelper_a1ba59f6f265fcda8868bd4d5891a1c72}{m\_channelFactory}.\hyperlink{classns3_1_1ObjectFactory_a77dcd099064038a1eb7a6b8251229ec3}{SetTypeId} (\textcolor{stringliteral}{"ns3::PointToPointChannel"});
46   \hyperlink{classns3_1_1PointToPointHelper_a96abd585304725f9ad2810503f795039}{m\_remoteChannelFactory}.\hyperlink{classns3_1_1ObjectFactory_a77dcd099064038a1eb7a6b8251229ec3}{SetTypeId} (\textcolor{stringliteral}{"ns3::PointToPointRemoteChannel"});
47 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}!````~Point\+To\+Point\+Helper@{$\sim$\+Point\+To\+Point\+Helper}}
\index{````~Point\+To\+Point\+Helper@{$\sim$\+Point\+To\+Point\+Helper}!ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}}
\subsubsection[{\texorpdfstring{$\sim$\+Point\+To\+Point\+Helper()}{~PointToPointHelper()}}]{\setlength{\rightskip}{0pt plus 5cm}virtual ns3\+::\+Point\+To\+Point\+Helper\+::$\sim$\+Point\+To\+Point\+Helper (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1PointToPointHelper_aaafd91a8b14a3af52e6d83b4c874462e}{}\label{classns3_1_1PointToPointHelper_aaafd91a8b14a3af52e6d83b4c874462e}

\begin{DoxyCode}
52 \{\}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3




\subsection{Member Function Documentation}
\index{ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}!Enable\+Ascii\+Internal@{Enable\+Ascii\+Internal}}
\index{Enable\+Ascii\+Internal@{Enable\+Ascii\+Internal}!ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}}
\subsubsection[{\texorpdfstring{Enable\+Ascii\+Internal(\+Ptr$<$ Output\+Stream\+Wrapper $>$ stream, std\+::string prefix, Ptr$<$ Net\+Device $>$ nd, bool explicit\+Filename)}{EnableAsciiInternal(Ptr< OutputStreamWrapper > stream, std::string prefix, Ptr< NetDevice > nd, bool explicitFilename)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Point\+To\+Point\+Helper\+::\+Enable\+Ascii\+Internal (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream, }
\item[{std\+::string}]{prefix, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{nd, }
\item[{bool}]{explicit\+Filename}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1PointToPointHelper_a500491e31095208060544b015d1112d5}{}\label{classns3_1_1PointToPointHelper_a500491e31095208060544b015d1112d5}


Enable ascii trace output on the indicated net device. 

Net\+Device-\/specific implementation mechanism for hooking the trace and writing to the trace file.


\begin{DoxyParams}{Parameters}
{\em stream} & The output stream object to use when logging ascii traces. \\
\hline
{\em prefix} & Filename prefix to use for ascii trace files. \\
\hline
{\em nd} & Net device for which you want to enable tracing. \\
\hline
{\em explicit\+Filename} & Treat the prefix as an explicit filename if true \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1AsciiTraceHelperForDevice_ab0eb42de1633994e75f4a4fd44bc79de}{ns3\+::\+Ascii\+Trace\+Helper\+For\+Device}.


\begin{DoxyCode}
116 \{
117   \textcolor{comment}{//}
118   \textcolor{comment}{// All of the ascii enable functions vector through here including the ones}
119   \textcolor{comment}{// that are wandering through all of devices on perhaps all of the nodes in}
120   \textcolor{comment}{// the system.  We can only deal with devices of type PointToPointNetDevice.}
121   \textcolor{comment}{//}
122   Ptr<PointToPointNetDevice> device = nd->GetObject<PointToPointNetDevice> ();
123   \textcolor{keywordflow}{if} (device == 0)
124     \{
125       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"PointToPointHelper::EnableAsciiInternal(): Device "} << device << 
126                    \textcolor{stringliteral}{" not of type ns3::PointToPointNetDevice"});
127       \textcolor{keywordflow}{return};
128     \}
129 
130   \textcolor{comment}{//}
131   \textcolor{comment}{// Our default trace sinks are going to use packet printing, so we have to }
132   \textcolor{comment}{// make sure that is turned on.}
133   \textcolor{comment}{//}
134   \hyperlink{classns3_1_1Packet_ae17c0cd8e63e83df3c9273801e3d5d7f}{Packet::EnablePrinting} ();
135 
136   \textcolor{comment}{//}
137   \textcolor{comment}{// If we are not provided an OutputStreamWrapper, we are expected to create }
138   \textcolor{comment}{// one using the usual trace filename conventions and do a Hook*WithoutContext}
139   \textcolor{comment}{// since there will be one file per context and therefore the context would}
140   \textcolor{comment}{// be redundant.}
141   \textcolor{comment}{//}
142   \textcolor{keywordflow}{if} (stream == 0)
143     \{
144       \textcolor{comment}{//}
145       \textcolor{comment}{// Set up an output stream object to deal with private ofstream copy }
146       \textcolor{comment}{// constructor and lifetime issues.  Let the helper decide the actual}
147       \textcolor{comment}{// name of the file given the prefix.}
148       \textcolor{comment}{//}
149       AsciiTraceHelper asciiTraceHelper;
150 
151       std::string filename;
152       \textcolor{keywordflow}{if} (explicitFilename)
153         \{
154           filename = prefix;
155         \}
156       \textcolor{keywordflow}{else}
157         \{
158           filename = asciiTraceHelper.GetFilenameFromDevice (prefix, device);
159         \}
160 
161       Ptr<OutputStreamWrapper> theStream = asciiTraceHelper.CreateFileStream (filename);
162 
163       \textcolor{comment}{//}
164       \textcolor{comment}{// The MacRx trace source provides our "r" event.}
165       \textcolor{comment}{//}
166       asciiTraceHelper.HookDefaultReceiveSinkWithoutContext<PointToPointNetDevice> (device, \textcolor{stringliteral}{"MacRx"}, 
      theStream);
167 
168       \textcolor{comment}{//}
169       \textcolor{comment}{// The "+", '-', and 'd' events are driven by trace sources actually in the}
170       \textcolor{comment}{// transmit queue.}
171       \textcolor{comment}{//}
172       Ptr<Queue<Packet> > queue = device->GetQueue ();
173       asciiTraceHelper.HookDefaultEnqueueSinkWithoutContext<Queue<Packet> > (queue, \textcolor{stringliteral}{"Enqueue"}, theStream);
174       asciiTraceHelper.HookDefaultDropSinkWithoutContext<Queue<Packet> > (queue, \textcolor{stringliteral}{"Drop"}, theStream);
175       asciiTraceHelper.HookDefaultDequeueSinkWithoutContext<Queue<Packet> > (queue, \textcolor{stringliteral}{"Dequeue"}, theStream);
176 
177       \textcolor{comment}{// PhyRxDrop trace source for "d" event}
178       asciiTraceHelper.HookDefaultDropSinkWithoutContext<PointToPointNetDevice> (device, \textcolor{stringliteral}{"PhyRxDrop"}, 
      theStream);
179 
180       \textcolor{keywordflow}{return};
181     \}
182 
183   \textcolor{comment}{//}
184   \textcolor{comment}{// If we are provided an OutputStreamWrapper, we are expected to use it, and}
185   \textcolor{comment}{// to providd a context.  We are free to come up with our own context if we}
186   \textcolor{comment}{// want, and use the AsciiTraceHelper Hook*WithContext functions, but for }
187   \textcolor{comment}{// compatibility and simplicity, we just use Config::Connect and let it deal}
188   \textcolor{comment}{// with the context.}
189   \textcolor{comment}{//}
190   \textcolor{comment}{// Note that we are going to use the default trace sinks provided by the }
191   \textcolor{comment}{// ascii trace helper.  There is actually no AsciiTraceHelper in sight here,}
192   \textcolor{comment}{// but the default trace sinks are actually publicly available static }
193   \textcolor{comment}{// functions that are always there waiting for just such a case.}
194   \textcolor{comment}{//}
195   uint32\_t nodeid = nd->GetNode ()->GetId ();
196   uint32\_t deviceid = nd->GetIfIndex ();
197   std::ostringstream oss;
198 
199   oss << \textcolor{stringliteral}{"/NodeList/"} << nd->GetNode ()->GetId () << \textcolor{stringliteral}{"/DeviceList/"} << deviceid << \textcolor{stringliteral}{"
      /$ns3::PointToPointNetDevice/MacRx"};
200   \hyperlink{group__config_ga4014f151241cd0939b6cb64409605736}{Config::Connect} (oss.str (), \hyperlink{group__makeboundcallback_ga1725d6362e6065faa0709f7c93f8d770}{MakeBoundCallback} (&
      \hyperlink{classns3_1_1AsciiTraceHelper_a344e3964ea89001f9df29659ac2dd4bf}{AsciiTraceHelper::DefaultReceiveSinkWithContext}, stream));
201 
202   oss.str (\textcolor{stringliteral}{""});
203   oss << \textcolor{stringliteral}{"/NodeList/"} << nodeid << \textcolor{stringliteral}{"/DeviceList/"} << deviceid << \textcolor{stringliteral}{"
      /$ns3::PointToPointNetDevice/TxQueue/Enqueue"};
204   \hyperlink{group__config_ga4014f151241cd0939b6cb64409605736}{Config::Connect} (oss.str (), \hyperlink{group__makeboundcallback_ga1725d6362e6065faa0709f7c93f8d770}{MakeBoundCallback} (&
      \hyperlink{classns3_1_1AsciiTraceHelper_a9b6db67e12e13496f736f9895f211688}{AsciiTraceHelper::DefaultEnqueueSinkWithContext}, stream));
205 
206   oss.str (\textcolor{stringliteral}{""});
207   oss << \textcolor{stringliteral}{"/NodeList/"} << nodeid << \textcolor{stringliteral}{"/DeviceList/"} << deviceid << \textcolor{stringliteral}{"
      /$ns3::PointToPointNetDevice/TxQueue/Dequeue"};
208   \hyperlink{group__config_ga4014f151241cd0939b6cb64409605736}{Config::Connect} (oss.str (), \hyperlink{group__makeboundcallback_ga1725d6362e6065faa0709f7c93f8d770}{MakeBoundCallback} (&
      \hyperlink{classns3_1_1AsciiTraceHelper_ad2f98ee493ff5ce4d775e72bb311242a}{AsciiTraceHelper::DefaultDequeueSinkWithContext}, stream));
209 
210   oss.str (\textcolor{stringliteral}{""});
211   oss << \textcolor{stringliteral}{"/NodeList/"} << nodeid << \textcolor{stringliteral}{"/DeviceList/"} << deviceid << \textcolor{stringliteral}{"/$ns3::PointToPointNetDevice/TxQueue/Drop
      "};
212   \hyperlink{group__config_ga4014f151241cd0939b6cb64409605736}{Config::Connect} (oss.str (), \hyperlink{group__makeboundcallback_ga1725d6362e6065faa0709f7c93f8d770}{MakeBoundCallback} (&
      \hyperlink{classns3_1_1AsciiTraceHelper_a23bfa6926e104f782e1a8c87e54cc7e8}{AsciiTraceHelper::DefaultDropSinkWithContext}, stream));
213 
214   oss.str (\textcolor{stringliteral}{""});
215   oss << \textcolor{stringliteral}{"/NodeList/"} << nodeid << \textcolor{stringliteral}{"/DeviceList/"} << deviceid << \textcolor{stringliteral}{"/$ns3::PointToPointNetDevice/PhyRxDrop"};
216   \hyperlink{group__config_ga4014f151241cd0939b6cb64409605736}{Config::Connect} (oss.str (), \hyperlink{group__makeboundcallback_ga1725d6362e6065faa0709f7c93f8d770}{MakeBoundCallback} (&
      \hyperlink{classns3_1_1AsciiTraceHelper_a23bfa6926e104f782e1a8c87e54cc7e8}{AsciiTraceHelper::DefaultDropSinkWithContext}, stream));
217 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4




Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}!Enable\+Pcap\+Internal@{Enable\+Pcap\+Internal}}
\index{Enable\+Pcap\+Internal@{Enable\+Pcap\+Internal}!ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}}
\subsubsection[{\texorpdfstring{Enable\+Pcap\+Internal(std\+::string prefix, Ptr$<$ Net\+Device $>$ nd, bool promiscuous, bool explicit\+Filename)}{EnablePcapInternal(std::string prefix, Ptr< NetDevice > nd, bool promiscuous, bool explicitFilename)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Point\+To\+Point\+Helper\+::\+Enable\+Pcap\+Internal (
\begin{DoxyParamCaption}
\item[{std\+::string}]{prefix, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{nd, }
\item[{bool}]{promiscuous, }
\item[{bool}]{explicit\+Filename}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1PointToPointHelper_abe3ce49bfc07a9d40cead59b508b9c3e}{}\label{classns3_1_1PointToPointHelper_abe3ce49bfc07a9d40cead59b508b9c3e}


Enable pcap output the indicated net device. 

Net\+Device-\/specific implementation mechanism for hooking the trace and writing to the trace file.


\begin{DoxyParams}{Parameters}
{\em prefix} & Filename prefix to use for pcap files. \\
\hline
{\em nd} & Net device for which you want to enable tracing. \\
\hline
{\em promiscuous} & If true capture all possible packets available at the device. \\
\hline
{\em explicit\+Filename} & Treat the prefix as an explicit filename if true \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1PcapHelperForDevice_aae5c1fa77e45af342b1e3f70bf604e0f}{ns3\+::\+Pcap\+Helper\+For\+Device}.


\begin{DoxyCode}
80 \{
81   \textcolor{comment}{//}
82   \textcolor{comment}{// All of the Pcap enable functions vector through here including the ones}
83   \textcolor{comment}{// that are wandering through all of devices on perhaps all of the nodes in}
84   \textcolor{comment}{// the system.  We can only deal with devices of type PointToPointNetDevice.}
85   \textcolor{comment}{//}
86   Ptr<PointToPointNetDevice> device = nd->GetObject<PointToPointNetDevice> ();
87   \textcolor{keywordflow}{if} (device == 0)
88     \{
89       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"PointToPointHelper::EnablePcapInternal(): Device "} << device << \textcolor{stringliteral}{" not of
       type ns3::PointToPointNetDevice"});
90       \textcolor{keywordflow}{return};
91     \}
92 
93   PcapHelper pcapHelper;
94 
95   std::string filename;
96   \textcolor{keywordflow}{if} (explicitFilename)
97     \{
98       filename = prefix;
99     \}
100   \textcolor{keywordflow}{else}
101     \{
102       filename = pcapHelper.GetFilenameFromDevice (prefix, device);
103     \}
104 
105   Ptr<PcapFileWrapper> file = pcapHelper.CreateFile (filename, std::ios::out, 
106                                                      \hyperlink{classns3_1_1PcapHelper_a2ee4dad28ddd9a1fe636f51835eaa77fa017d791e28f94a37b7a9e5c90bea598c}{PcapHelper::DLT\_PPP});
107   pcapHelper.HookDefaultSink<PointToPointNetDevice> (device, \textcolor{stringliteral}{"PromiscSniffer"}, file);
108 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6




Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}!Install@{Install}}
\index{Install@{Install}!ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}}
\subsubsection[{\texorpdfstring{Install(\+Node\+Container c)}{Install(NodeContainer c)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Net\+Device\+Container} ns3\+::\+Point\+To\+Point\+Helper\+::\+Install (
\begin{DoxyParamCaption}
\item[{{\bf Node\+Container}}]{c}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PointToPointHelper_ab9162fea3e88722666fed1106df1f9ec}{}\label{classns3_1_1PointToPointHelper_ab9162fea3e88722666fed1106df1f9ec}

\begin{DoxyParams}{Parameters}
{\em c} & a set of nodes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} for nodes
\end{DoxyReturn}
This method creates a \hyperlink{classns3_1_1PointToPointChannel}{ns3\+::\+Point\+To\+Point\+Channel} with the attributes configured by \hyperlink{classns3_1_1PointToPointHelper_a6b5317fd17fb61e5a53f8d66a90b63b9}{Point\+To\+Point\+Helper\+::\+Set\+Channel\+Attribute}, then, for each node in the input container, we create a \hyperlink{classns3_1_1PointToPointNetDevice}{ns3\+::\+Point\+To\+Point\+Net\+Device} with the requested attributes, a queue for this \hyperlink{classns3_1_1NetDevice}{ns3\+::\+Net\+Device}, and associate the resulting \hyperlink{classns3_1_1NetDevice}{ns3\+::\+Net\+Device} with the \hyperlink{classns3_1_1Node}{ns3\+::\+Node} and \hyperlink{classns3_1_1PointToPointChannel}{ns3\+::\+Point\+To\+Point\+Channel}. 
\begin{DoxyCode}
221 \{
222   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c}.GetN () == 2);
223   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1PointToPointHelper_ab9162fea3e88722666fed1106df1f9ec}{Install} (\hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c}.Get (0), \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c}.Get (1));
224 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8




Here is the caller graph for this function\+:
% FIG 9


\index{ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}!Install@{Install}}
\index{Install@{Install}!ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}}
\subsubsection[{\texorpdfstring{Install(\+Ptr$<$ Node $>$ a, Ptr$<$ Node $>$ b)}{Install(Ptr< Node > a, Ptr< Node > b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Net\+Device\+Container} ns3\+::\+Point\+To\+Point\+Helper\+::\+Install (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{a, }
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{b}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PointToPointHelper_aecfc3e7bc34a5fa9707b26df08ef913a}{}\label{classns3_1_1PointToPointHelper_aecfc3e7bc34a5fa9707b26df08ef913a}

\begin{DoxyParams}{Parameters}
{\em a} & first node \\
\hline
{\em b} & second node \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} for nodes
\end{DoxyReturn}
Saves you from having to construct a temporary \hyperlink{classns3_1_1NodeContainer}{Node\+Container}. Also, if M\+PI is enabled, for distributed simulations, appropriate remote point-\/to-\/point channels are created. 
\begin{DoxyCode}
228 \{
229   NetDeviceContainer container;
230 
231   Ptr<PointToPointNetDevice> devA = \hyperlink{classns3_1_1PointToPointHelper_ab70d3d643f30b809c90530d494a73eb4}{m\_deviceFactory}.\hyperlink{classns3_1_1ObjectFactory_a18152e93f0a6fe184ed7300cb31e9896}{Create}<PointToPointNetDevice> ();
232   devA->SetAddress (\hyperlink{classns3_1_1Mac48Address_a203b53c035649c0d4881fa1115aa2cdb}{Mac48Address::Allocate} ());
233   a->\hyperlink{classns3_1_1Node_a42ff83ee1d5d1649c770d3f5b62375de}{AddDevice} (devA);
234   Ptr<Queue<Packet> > queueA = \hyperlink{classns3_1_1PointToPointHelper_a79d2da8ad9d40adc181d4c1b8520890f}{m\_queueFactory}.\hyperlink{classns3_1_1ObjectFactory_a18152e93f0a6fe184ed7300cb31e9896}{Create}<Queue<Packet> > ();
235   devA->SetQueue (queueA);
236   Ptr<PointToPointNetDevice> devB = \hyperlink{classns3_1_1PointToPointHelper_ab70d3d643f30b809c90530d494a73eb4}{m\_deviceFactory}.\hyperlink{classns3_1_1ObjectFactory_a18152e93f0a6fe184ed7300cb31e9896}{Create}<PointToPointNetDevice> ();
237   devB->SetAddress (\hyperlink{classns3_1_1Mac48Address_a203b53c035649c0d4881fa1115aa2cdb}{Mac48Address::Allocate} ());
238   b->\hyperlink{classns3_1_1Node_a42ff83ee1d5d1649c770d3f5b62375de}{AddDevice} (devB);
239   Ptr<Queue<Packet> > queueB = \hyperlink{classns3_1_1PointToPointHelper_a79d2da8ad9d40adc181d4c1b8520890f}{m\_queueFactory}.\hyperlink{classns3_1_1ObjectFactory_a18152e93f0a6fe184ed7300cb31e9896}{Create}<Queue<Packet> > ();
240   devB->SetQueue (queueB);
241   \textcolor{comment}{// If MPI is enabled, we need to see if both nodes have the same system id }
242   \textcolor{comment}{// (rank), and the rank is the same as this instance.  If both are true, }
243   \textcolor{comment}{//use a normal p2p channel, otherwise use a remote channel}
244   \textcolor{keywordtype}{bool} useNormalChannel = \textcolor{keyword}{true};
245   Ptr<PointToPointChannel> channel = 0;
246 
247   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1MpiInterface_a5964beea2f60d6110bed18b14012e583}{MpiInterface::IsEnabled} ())
248     \{
249       uint32\_t n1SystemId = a->\hyperlink{classns3_1_1Node_a13740abb36295ad68e551de5b4e328d5}{GetSystemId} ();
250       uint32\_t n2SystemId = b->\hyperlink{classns3_1_1Node_a13740abb36295ad68e551de5b4e328d5}{GetSystemId} ();
251       uint32\_t currSystemId = \hyperlink{classns3_1_1MpiInterface_a7f1f671b55948fb1c8f7eb54f22a9619}{MpiInterface::GetSystemId} ();
252       \textcolor{keywordflow}{if} (n1SystemId != currSystemId || n2SystemId != currSystemId) 
253         \{
254           useNormalChannel = \textcolor{keyword}{false};
255         \}
256     \}
257   \textcolor{keywordflow}{if} (useNormalChannel)
258     \{
259       channel = \hyperlink{classns3_1_1PointToPointHelper_a1ba59f6f265fcda8868bd4d5891a1c72}{m\_channelFactory}.\hyperlink{classns3_1_1ObjectFactory_a18152e93f0a6fe184ed7300cb31e9896}{Create}<PointToPointChannel> ();
260     \}
261   \textcolor{keywordflow}{else}
262     \{
263       channel = \hyperlink{classns3_1_1PointToPointHelper_a96abd585304725f9ad2810503f795039}{m\_remoteChannelFactory}.\hyperlink{classns3_1_1ObjectFactory_a18152e93f0a6fe184ed7300cb31e9896}{Create}<PointToPointRemoteChannel> ();
264       Ptr<MpiReceiver> mpiRecA = CreateObject<MpiReceiver> ();
265       Ptr<MpiReceiver> mpiRecB = CreateObject<MpiReceiver> ();
266       mpiRecA->SetReceiveCallback (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1PointToPointNetDevice_ac7d662e7083e3a522557fcfa502e4b5e}{PointToPointNetDevice::Receive}, devA));
267       mpiRecB->SetReceiveCallback (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1PointToPointNetDevice_ac7d662e7083e3a522557fcfa502e4b5e}{PointToPointNetDevice::Receive}, devB));
268       devA->AggregateObject (mpiRecA);
269       devB->AggregateObject (mpiRecB);
270     \}
271 
272   devA->Attach (channel);
273   devB->Attach (channel);
274   container.Add (devA);
275   container.Add (devB);
276 
277   \textcolor{keywordflow}{return} container;
278 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10


\index{ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}!Install@{Install}}
\index{Install@{Install}!ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}}
\subsubsection[{\texorpdfstring{Install(\+Ptr$<$ Node $>$ a, std\+::string b\+Name)}{Install(Ptr< Node > a, std::string bName)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Net\+Device\+Container} ns3\+::\+Point\+To\+Point\+Helper\+::\+Install (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{a, }
\item[{std\+::string}]{b\+Name}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PointToPointHelper_aacdd0082d28133831bab1484f37b9514}{}\label{classns3_1_1PointToPointHelper_aacdd0082d28133831bab1484f37b9514}

\begin{DoxyParams}{Parameters}
{\em a} & first node \\
\hline
{\em b\+Name} & name of second node \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} for nodes
\end{DoxyReturn}
Saves you from having to construct a temporary \hyperlink{classns3_1_1NodeContainer}{Node\+Container}. 
\begin{DoxyCode}
282 \{
283   Ptr<Node> \hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b} = Names::Find<Node> (bName);
284   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1PointToPointHelper_ab9162fea3e88722666fed1106df1f9ec}{Install} (a, b);
285 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 11


\index{ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}!Install@{Install}}
\index{Install@{Install}!ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}}
\subsubsection[{\texorpdfstring{Install(std\+::string a\+Name, Ptr$<$ Node $>$ b)}{Install(std::string aName, Ptr< Node > b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Net\+Device\+Container} ns3\+::\+Point\+To\+Point\+Helper\+::\+Install (
\begin{DoxyParamCaption}
\item[{std\+::string}]{a\+Name, }
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{b}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PointToPointHelper_a0074be81c1506a6c366e8162da0eedf0}{}\label{classns3_1_1PointToPointHelper_a0074be81c1506a6c366e8162da0eedf0}

\begin{DoxyParams}{Parameters}
{\em a\+Name} & Name of first node \\
\hline
{\em b} & second node \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} for nodes
\end{DoxyReturn}
Saves you from having to construct a temporary \hyperlink{classns3_1_1NodeContainer}{Node\+Container}. 
\begin{DoxyCode}
289 \{
290   Ptr<Node> a = Names::Find<Node> (aName);
291   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1PointToPointHelper_ab9162fea3e88722666fed1106df1f9ec}{Install} (a, b);
292 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12


\index{ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}!Install@{Install}}
\index{Install@{Install}!ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}}
\subsubsection[{\texorpdfstring{Install(std\+::string a\+Node, std\+::string b\+Node)}{Install(std::string aNode, std::string bNode)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Net\+Device\+Container} ns3\+::\+Point\+To\+Point\+Helper\+::\+Install (
\begin{DoxyParamCaption}
\item[{std\+::string}]{a\+Node, }
\item[{std\+::string}]{b\+Node}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PointToPointHelper_a767d84c3e257d67c7ca54da8e0cacabe}{}\label{classns3_1_1PointToPointHelper_a767d84c3e257d67c7ca54da8e0cacabe}

\begin{DoxyParams}{Parameters}
{\em a\+Node} & Name of first node \\
\hline
{\em b\+Node} & Name of second node \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} for nodes
\end{DoxyReturn}
Saves you from having to construct a temporary \hyperlink{classns3_1_1NodeContainer}{Node\+Container}. 
\begin{DoxyCode}
296 \{
297   Ptr<Node> a = Names::Find<Node> (aName);
298   Ptr<Node> \hyperlink{buildings__pathloss_8m_a21ad0bd836b90d08f4cf640b4c298e7c}{b} = Names::Find<Node> (bName);
299   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1PointToPointHelper_ab9162fea3e88722666fed1106df1f9ec}{Install} (a, b);
300 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13


\index{ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}!Set\+Channel\+Attribute@{Set\+Channel\+Attribute}}
\index{Set\+Channel\+Attribute@{Set\+Channel\+Attribute}!ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}}
\subsubsection[{\texorpdfstring{Set\+Channel\+Attribute(std\+::string name, const Attribute\+Value \&value)}{SetChannelAttribute(std::string name, const AttributeValue &value)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Point\+To\+Point\+Helper\+::\+Set\+Channel\+Attribute (
\begin{DoxyParamCaption}
\item[{std\+::string}]{name, }
\item[{const {\bf Attribute\+Value} \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PointToPointHelper_a6b5317fd17fb61e5a53f8d66a90b63b9}{}\label{classns3_1_1PointToPointHelper_a6b5317fd17fb61e5a53f8d66a90b63b9}
Set an attribute value to be propagated to each \hyperlink{classns3_1_1Channel}{Channel} created by the helper.


\begin{DoxyParams}{Parameters}
{\em name} & the name of the attribute to set \\
\hline
{\em value} & the value of the attribute to set\\
\hline
\end{DoxyParams}
Set these attribute on each \hyperlink{classns3_1_1PointToPointChannel}{ns3\+::\+Point\+To\+Point\+Channel} created by \hyperlink{classns3_1_1PointToPointHelper_ab9162fea3e88722666fed1106df1f9ec}{Point\+To\+Point\+Helper\+::\+Install} 
\begin{DoxyCode}
73 \{
74   \hyperlink{classns3_1_1PointToPointHelper_a1ba59f6f265fcda8868bd4d5891a1c72}{m\_channelFactory}.\hyperlink{classns3_1_1ObjectFactory_aef5c0d5019c96bdf01cefd1ff83f4a68}{Set} (n1, v1);
75   \hyperlink{classns3_1_1PointToPointHelper_a96abd585304725f9ad2810503f795039}{m\_remoteChannelFactory}.\hyperlink{classns3_1_1ObjectFactory_aef5c0d5019c96bdf01cefd1ff83f4a68}{Set} (n1, v1);
76 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 14




Here is the caller graph for this function\+:
% FIG 15


\index{ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}!Set\+Device\+Attribute@{Set\+Device\+Attribute}}
\index{Set\+Device\+Attribute@{Set\+Device\+Attribute}!ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}}
\subsubsection[{\texorpdfstring{Set\+Device\+Attribute(std\+::string name, const Attribute\+Value \&value)}{SetDeviceAttribute(std::string name, const AttributeValue &value)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Point\+To\+Point\+Helper\+::\+Set\+Device\+Attribute (
\begin{DoxyParamCaption}
\item[{std\+::string}]{name, }
\item[{const {\bf Attribute\+Value} \&}]{value}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PointToPointHelper_a4577f5ab8c387e5528af2e0fbab1152e}{}\label{classns3_1_1PointToPointHelper_a4577f5ab8c387e5528af2e0fbab1152e}
Set an attribute value to be propagated to each \hyperlink{classns3_1_1NetDevice}{Net\+Device} created by the helper.


\begin{DoxyParams}{Parameters}
{\em name} & the name of the attribute to set \\
\hline
{\em value} & the value of the attribute to set\\
\hline
\end{DoxyParams}
Set these attributes on each \hyperlink{classns3_1_1PointToPointNetDevice}{ns3\+::\+Point\+To\+Point\+Net\+Device} created by \hyperlink{classns3_1_1PointToPointHelper_ab9162fea3e88722666fed1106df1f9ec}{Point\+To\+Point\+Helper\+::\+Install} 
\begin{DoxyCode}
67 \{
68   \hyperlink{classns3_1_1PointToPointHelper_ab70d3d643f30b809c90530d494a73eb4}{m\_deviceFactory}.\hyperlink{classns3_1_1ObjectFactory_aef5c0d5019c96bdf01cefd1ff83f4a68}{Set} (n1, v1);
69 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 16




Here is the caller graph for this function\+:
% FIG 17


\index{ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}!Set\+Queue@{Set\+Queue}}
\index{Set\+Queue@{Set\+Queue}!ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}}
\subsubsection[{\texorpdfstring{Set\+Queue(std\+::string type, std\+::string n1="""", const Attribute\+Value \&v1=\+Empty\+Attribute\+Value(), std\+::string n2="""", const Attribute\+Value \&v2=\+Empty\+Attribute\+Value(), std\+::string n3="""", const Attribute\+Value \&v3=\+Empty\+Attribute\+Value(), std\+::string n4="""", const Attribute\+Value \&v4=\+Empty\+Attribute\+Value())}{SetQueue(std::string type, std::string n1="", const AttributeValue &v1=EmptyAttributeValue(), std::string n2="", const AttributeValue &v2=EmptyAttributeValue(), std::string n3="", const AttributeValue &v3=EmptyAttributeValue(), std::string n4="", const AttributeValue &v4=EmptyAttributeValue())}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Point\+To\+Point\+Helper\+::\+Set\+Queue (
\begin{DoxyParamCaption}
\item[{std\+::string}]{type, }
\item[{std\+::string}]{n1 = {\ttfamily \char`\"{}\char`\"{}}, }
\item[{const {\bf Attribute\+Value} \&}]{v1 = {\ttfamily {\bf Empty\+Attribute\+Value}~()}, }
\item[{std\+::string}]{n2 = {\ttfamily \char`\"{}\char`\"{}}, }
\item[{const {\bf Attribute\+Value} \&}]{v2 = {\ttfamily {\bf Empty\+Attribute\+Value}~()}, }
\item[{std\+::string}]{n3 = {\ttfamily \char`\"{}\char`\"{}}, }
\item[{const {\bf Attribute\+Value} \&}]{v3 = {\ttfamily {\bf Empty\+Attribute\+Value}~()}, }
\item[{std\+::string}]{n4 = {\ttfamily \char`\"{}\char`\"{}}, }
\item[{const {\bf Attribute\+Value} \&}]{v4 = {\ttfamily {\bf Empty\+Attribute\+Value}~()}}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PointToPointHelper_a546a5c9ae3c9eab0ea98b25fd41e3c95}{}\label{classns3_1_1PointToPointHelper_a546a5c9ae3c9eab0ea98b25fd41e3c95}
Each point to point net device must have a queue to pass packets through. This method allows one to set the type of the queue that is automatically created when the device is created and attached to a node.


\begin{DoxyParams}{Parameters}
{\em type} & the type of queue \\
\hline
{\em n1} & the name of the attribute to set on the queue \\
\hline
{\em v1} & the value of the attribute to set on the queue \\
\hline
{\em n2} & the name of the attribute to set on the queue \\
\hline
{\em v2} & the value of the attribute to set on the queue \\
\hline
{\em n3} & the name of the attribute to set on the queue \\
\hline
{\em v3} & the value of the attribute to set on the queue \\
\hline
{\em n4} & the name of the attribute to set on the queue \\
\hline
{\em v4} & the value of the attribute to set on the queue\\
\hline
\end{DoxyParams}
Set the type of queue to create and associated to each \hyperlink{classns3_1_1PointToPointNetDevice}{Point\+To\+Point\+Net\+Device} created through \hyperlink{classns3_1_1PointToPointHelper_ab9162fea3e88722666fed1106df1f9ec}{Point\+To\+Point\+Helper\+::\+Install}. 
\begin{DoxyCode}
55 \{
56   \hyperlink{classns3_1_1QueueBase_a7b85284de63a5642e623f32d096dbcd9}{QueueBase::AppendItemTypeIfNotPresent} (
      \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type}, \textcolor{stringliteral}{"Packet"});
57 
58   \hyperlink{classns3_1_1PointToPointHelper_a79d2da8ad9d40adc181d4c1b8520890f}{m\_queueFactory}.\hyperlink{classns3_1_1ObjectFactory_a77dcd099064038a1eb7a6b8251229ec3}{SetTypeId} (\hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type});
59   \hyperlink{classns3_1_1PointToPointHelper_a79d2da8ad9d40adc181d4c1b8520890f}{m\_queueFactory}.\hyperlink{classns3_1_1ObjectFactory_aef5c0d5019c96bdf01cefd1ff83f4a68}{Set} (n1, v1);
60   \hyperlink{classns3_1_1PointToPointHelper_a79d2da8ad9d40adc181d4c1b8520890f}{m\_queueFactory}.\hyperlink{classns3_1_1ObjectFactory_aef5c0d5019c96bdf01cefd1ff83f4a68}{Set} (n2, v2);
61   \hyperlink{classns3_1_1PointToPointHelper_a79d2da8ad9d40adc181d4c1b8520890f}{m\_queueFactory}.\hyperlink{classns3_1_1ObjectFactory_aef5c0d5019c96bdf01cefd1ff83f4a68}{Set} (n3, v3);
62   \hyperlink{classns3_1_1PointToPointHelper_a79d2da8ad9d40adc181d4c1b8520890f}{m\_queueFactory}.\hyperlink{classns3_1_1ObjectFactory_aef5c0d5019c96bdf01cefd1ff83f4a68}{Set} (n4, v4);
63 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 18




Here is the caller graph for this function\+:
% FIG 19




\subsection{Member Data Documentation}
\index{ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}!m\+\_\+channel\+Factory@{m\+\_\+channel\+Factory}}
\index{m\+\_\+channel\+Factory@{m\+\_\+channel\+Factory}!ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+channel\+Factory}{m_channelFactory}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Object\+Factory} ns3\+::\+Point\+To\+Point\+Helper\+::m\+\_\+channel\+Factory\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PointToPointHelper_a1ba59f6f265fcda8868bd4d5891a1c72}{}\label{classns3_1_1PointToPointHelper_a1ba59f6f265fcda8868bd4d5891a1c72}


\hyperlink{classns3_1_1Channel}{Channel} Factory. 

\index{ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}!m\+\_\+device\+Factory@{m\+\_\+device\+Factory}}
\index{m\+\_\+device\+Factory@{m\+\_\+device\+Factory}!ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+device\+Factory}{m_deviceFactory}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Object\+Factory} ns3\+::\+Point\+To\+Point\+Helper\+::m\+\_\+device\+Factory\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PointToPointHelper_ab70d3d643f30b809c90530d494a73eb4}{}\label{classns3_1_1PointToPointHelper_ab70d3d643f30b809c90530d494a73eb4}


Device Factory. 

\index{ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}!m\+\_\+queue\+Factory@{m\+\_\+queue\+Factory}}
\index{m\+\_\+queue\+Factory@{m\+\_\+queue\+Factory}!ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+queue\+Factory}{m_queueFactory}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Object\+Factory} ns3\+::\+Point\+To\+Point\+Helper\+::m\+\_\+queue\+Factory\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PointToPointHelper_a79d2da8ad9d40adc181d4c1b8520890f}{}\label{classns3_1_1PointToPointHelper_a79d2da8ad9d40adc181d4c1b8520890f}


\hyperlink{classns3_1_1Queue}{Queue} Factory. 

\index{ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}!m\+\_\+remote\+Channel\+Factory@{m\+\_\+remote\+Channel\+Factory}}
\index{m\+\_\+remote\+Channel\+Factory@{m\+\_\+remote\+Channel\+Factory}!ns3\+::\+Point\+To\+Point\+Helper@{ns3\+::\+Point\+To\+Point\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+remote\+Channel\+Factory}{m_remoteChannelFactory}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Object\+Factory} ns3\+::\+Point\+To\+Point\+Helper\+::m\+\_\+remote\+Channel\+Factory\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PointToPointHelper_a96abd585304725f9ad2810503f795039}{}\label{classns3_1_1PointToPointHelper_a96abd585304725f9ad2810503f795039}


Remote \hyperlink{classns3_1_1Channel}{Channel} Factory. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
point-\/to-\/point/helper/\hyperlink{point-to-point-helper_8h}{point-\/to-\/point-\/helper.\+h}\item 
point-\/to-\/point/helper/\hyperlink{point-to-point-helper_8cc}{point-\/to-\/point-\/helper.\+cc}\end{DoxyCompactItemize}
