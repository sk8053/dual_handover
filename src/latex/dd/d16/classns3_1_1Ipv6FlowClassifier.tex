\hypertarget{classns3_1_1Ipv6FlowClassifier}{}\section{ns3\+:\+:Ipv6\+Flow\+Classifier Class Reference}
\label{classns3_1_1Ipv6FlowClassifier}\index{ns3\+::\+Ipv6\+Flow\+Classifier@{ns3\+::\+Ipv6\+Flow\+Classifier}}


{\ttfamily \#include $<$ipv6-\/flow-\/classifier.\+h$>$}



Inheritance diagram for ns3\+:\+:Ipv6\+Flow\+Classifier\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Ipv6\+Flow\+Classifier\+:
% FIG 1
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structns3_1_1Ipv6FlowClassifier_1_1FiveTuple}{Five\+Tuple}
\begin{DoxyCompactList}\small\item\em Structure to classify a packet. \end{DoxyCompactList}\item 
class \hyperlink{classns3_1_1Ipv6FlowClassifier_1_1SortByCount}{Sort\+By\+Count}
\begin{DoxyCompactList}\small\item\em Comparator used to sort the vector of D\+S\+CP values. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ipv6FlowClassifier_a6610840238be8282854d6425bb39b2e3}{Ipv6\+Flow\+Classifier} ()
\item 
bool \hyperlink{classns3_1_1Ipv6FlowClassifier_ac91b39dfc99ca7190e6b0b8e3d37d7a9}{Classify} (const \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} \&ip\+Header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ ip\+Payload, uint32\+\_\+t $\ast$out\+\_\+flow\+Id, uint32\+\_\+t $\ast$out\+\_\+packet\+Id)
\begin{DoxyCompactList}\small\item\em try to classify the packet into flow-\/id and packet-\/id \end{DoxyCompactList}\item 
\hyperlink{structns3_1_1Ipv6FlowClassifier_1_1FiveTuple}{Five\+Tuple} \hyperlink{classns3_1_1Ipv6FlowClassifier_a8d1f460cd4a07e559430d1d7ab9cd9c6}{Find\+Flow} (\hyperlink{group__flow-monitor_ga39a766c4a370cdb9ab8ac85da4b288e9}{Flow\+Id} flow\+Id) const 
\item 
std\+::vector$<$ std\+::pair$<$ \hyperlink{classns3_1_1Ipv6Header_afdc89ed9acd990a7613782323e4c95ee}{Ipv6\+Header\+::\+Dscp\+Type}, uint32\+\_\+t $>$ $>$ \hyperlink{classns3_1_1Ipv6FlowClassifier_aa529a3600f6198f3b5093f590ee4fba4}{Get\+Dscp\+Counts} (\hyperlink{group__flow-monitor_ga39a766c4a370cdb9ab8ac85da4b288e9}{Flow\+Id} flow\+Id) const 
\begin{DoxyCompactList}\small\item\em get the D\+S\+CP values of the packets belonging to the flow with the given Flow\+Id, sorted in decreasing order of number of packets seen with that D\+S\+CP value \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6FlowClassifier_a4ffab8c7d4a16cc9c5b941c9b8550fae}{Serialize\+To\+Xml\+Stream} (std\+::ostream \&os, uint16\+\_\+t indent) const 
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::map$<$ \hyperlink{structns3_1_1Ipv6FlowClassifier_1_1FiveTuple}{Five\+Tuple}, \hyperlink{group__flow-monitor_ga39a766c4a370cdb9ab8ac85da4b288e9}{Flow\+Id} $>$ \hyperlink{classns3_1_1Ipv6FlowClassifier_a2ba466f42f102ab81aed0d5cffde57a1}{m\+\_\+flow\+Map}
\begin{DoxyCompactList}\small\item\em Map to Flows Identifiers to Flow\+Ids. \end{DoxyCompactList}\item 
std\+::map$<$ \hyperlink{group__flow-monitor_ga39a766c4a370cdb9ab8ac85da4b288e9}{Flow\+Id}, \hyperlink{group__flow-monitor_gaa1cb18250e1672975204f1254b8aa2ae}{Flow\+Packet\+Id} $>$ \hyperlink{classns3_1_1Ipv6FlowClassifier_adfa0df24172af71f377bc0b56456e1ae}{m\+\_\+flow\+Pkt\+Id\+Map}
\begin{DoxyCompactList}\small\item\em Map to Flow\+Ids to Flow\+Packet\+Id. \end{DoxyCompactList}\item 
std\+::map$<$ \hyperlink{group__flow-monitor_ga39a766c4a370cdb9ab8ac85da4b288e9}{Flow\+Id}, std\+::map$<$ \hyperlink{classns3_1_1Ipv6Header_afdc89ed9acd990a7613782323e4c95ee}{Ipv6\+Header\+::\+Dscp\+Type}, uint32\+\_\+t $>$ $>$ \hyperlink{classns3_1_1Ipv6FlowClassifier_ae351d1b8e71e5253d34cfb3e7ee3ec2a}{m\+\_\+flow\+Dscp\+Map}
\begin{DoxyCompactList}\small\item\em Map Flow\+Ids to (D\+S\+CP value, packet count) pairs. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Classifies packets by looking at their IP and T\+C\+P/\+U\+DP headers. From these packet headers, a tuple (source-\/ip, destination-\/ip, protocol, source-\/port, destination-\/port) is created, and a unique flow identifier is assigned for each different tuple combination 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Ipv6\+Flow\+Classifier@{ns3\+::\+Ipv6\+Flow\+Classifier}!Ipv6\+Flow\+Classifier@{Ipv6\+Flow\+Classifier}}
\index{Ipv6\+Flow\+Classifier@{Ipv6\+Flow\+Classifier}!ns3\+::\+Ipv6\+Flow\+Classifier@{ns3\+::\+Ipv6\+Flow\+Classifier}}
\subsubsection[{\texorpdfstring{Ipv6\+Flow\+Classifier()}{Ipv6FlowClassifier()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv6\+Flow\+Classifier\+::\+Ipv6\+Flow\+Classifier (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6FlowClassifier_a6610840238be8282854d6425bb39b2e3}{}\label{classns3_1_1Ipv6FlowClassifier_a6610840238be8282854d6425bb39b2e3}

\begin{DoxyCode}
101 \{
102 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Ipv6\+Flow\+Classifier@{ns3\+::\+Ipv6\+Flow\+Classifier}!Classify@{Classify}}
\index{Classify@{Classify}!ns3\+::\+Ipv6\+Flow\+Classifier@{ns3\+::\+Ipv6\+Flow\+Classifier}}
\subsubsection[{\texorpdfstring{Classify(const Ipv6\+Header \&ip\+Header, Ptr$<$ const Packet $>$ ip\+Payload, uint32\+\_\+t $\ast$out\+\_\+flow\+Id, uint32\+\_\+t $\ast$out\+\_\+packet\+Id)}{Classify(const Ipv6Header &ipHeader, Ptr< const Packet > ipPayload, uint32_t *out_flowId, uint32_t *out_packetId)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv6\+Flow\+Classifier\+::\+Classify (
\begin{DoxyParamCaption}
\item[{const {\bf Ipv6\+Header} \&}]{ip\+Header, }
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{ip\+Payload, }
\item[{uint32\+\_\+t $\ast$}]{out\+\_\+flow\+Id, }
\item[{uint32\+\_\+t $\ast$}]{out\+\_\+packet\+Id}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6FlowClassifier_ac91b39dfc99ca7190e6b0b8e3d37d7a9}{}\label{classns3_1_1Ipv6FlowClassifier_ac91b39dfc99ca7190e6b0b8e3d37d7a9}


try to classify the packet into flow-\/id and packet-\/id 

\begin{DoxyWarning}{Warning}
\+: it must be called only once per packet, from Send\+Outgoing\+Logger.
\end{DoxyWarning}
\begin{DoxyReturn}{Returns}
true if the packet was classified, false if not (i.\+e. it does not appear to be part of a flow). 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em ip\+Header} & packet\textquotesingle{}s IP header \\
\hline
{\em ip\+Payload} & packet\textquotesingle{}s IP payload \\
\hline
{\em out\+\_\+flow\+Id} & packet\textquotesingle{}s Flow\+Id \\
\hline
{\em out\+\_\+packet\+Id} & packet\textquotesingle{}s identifier \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
107 \{
108   \textcolor{keywordflow}{if} (ipHeader.GetDestinationAddress ().IsMulticast ())
109     \{
110       \textcolor{comment}{// we are not prepared to handle multicast yet}
111       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
112     \}
113 
114   FiveTuple tuple;
115   tuple.sourceAddress = ipHeader.GetSourceAddress ();
116   tuple.destinationAddress = ipHeader.GetDestinationAddress ();
117   tuple.protocol = ipHeader.GetNextHeader ();
118 
119   \textcolor{keywordflow}{if} ((tuple.protocol != \hyperlink{namespacens3_ae787098cbb0a3e8f6a17d9249e88a77f}{UDP\_PROT\_NUMBER}) && (tuple.protocol != 
      \hyperlink{namespacens3_a203a34fc0e042720ce1a0a754e270646}{TCP\_PROT\_NUMBER}))
120     \{
121       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
122     \}
123 
124   \textcolor{keywordflow}{if} (ipPayload->GetSize () < 4)
125     \{
126       \textcolor{comment}{// the packet doesn't carry enough bytes}
127       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
128     \}
129 
130   \textcolor{comment}{// we rely on the fact that for both TCP and UDP the ports are}
131   \textcolor{comment}{// carried in the first 4 octects.}
132   \textcolor{comment}{// This allows to read the ports even on fragmented packets}
133   \textcolor{comment}{// not carrying a full TCP or UDP header.}
134 
135   uint8\_t \hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data}[4];
136   ipPayload->CopyData (data, 4);
137 
138   uint16\_t srcPort = 0;
139   srcPort |= data[0];
140   srcPort <<= 8;
141   srcPort |= data[1];
142 
143   uint16\_t dstPort = 0;
144   dstPort |= data[2];
145   dstPort <<= 8;
146   dstPort |= data[3];
147 
148   tuple.sourcePort = srcPort;
149   tuple.destinationPort = dstPort;
150 
151   \textcolor{comment}{// try to insert the tuple, but check if it already exists}
152   std::pair<std::map<FiveTuple, FlowId>::iterator, \textcolor{keywordtype}{bool}> insert
153     = \hyperlink{classns3_1_1Ipv6FlowClassifier_a2ba466f42f102ab81aed0d5cffde57a1}{m\_flowMap}.insert (std::pair<FiveTuple, FlowId> (tuple, 0));
154 
155   \textcolor{comment}{// if the insertion succeeded, we need to assign this tuple a new flow identifier}
156   \textcolor{keywordflow}{if} (insert.second)
157     \{
158       \hyperlink{group__flow-monitor_ga39a766c4a370cdb9ab8ac85da4b288e9}{FlowId} newFlowId = \hyperlink{classns3_1_1FlowClassifier_a5469e94282efde8b8212e20995c6cccd}{GetNewFlowId} ();
159       insert.first->second = newFlowId;
160       \hyperlink{classns3_1_1Ipv6FlowClassifier_adfa0df24172af71f377bc0b56456e1ae}{m\_flowPktIdMap}[newFlowId] = 0;
161       \hyperlink{classns3_1_1Ipv6FlowClassifier_ae351d1b8e71e5253d34cfb3e7ee3ec2a}{m\_flowDscpMap}[newFlowId];
162     \}
163   \textcolor{keywordflow}{else}
164     \{
165       \hyperlink{classns3_1_1Ipv6FlowClassifier_adfa0df24172af71f377bc0b56456e1ae}{m\_flowPktIdMap}[insert.first->second] ++;
166     \}
167 
168   \textcolor{comment}{// increment the counter of packets with the same DSCP value}
169   \hyperlink{classns3_1_1Ipv6Header_afdc89ed9acd990a7613782323e4c95ee}{Ipv6Header::DscpType} dscp = ipHeader.GetDscp ();
170   std::pair<std::map<Ipv6Header::DscpType, uint32\_t>::iterator, \textcolor{keywordtype}{bool}> dscpInserter
171     = \hyperlink{classns3_1_1Ipv6FlowClassifier_ae351d1b8e71e5253d34cfb3e7ee3ec2a}{m\_flowDscpMap}[insert.first->second].insert (std::pair<Ipv6Header::DscpType, uint32\_t> (
      dscp, 1));
172 
173   \textcolor{comment}{// if the insertion did not succeed, we need to increment the counter}
174   \textcolor{keywordflow}{if} (!dscpInserter.second)
175     \{
176       \hyperlink{classns3_1_1Ipv6FlowClassifier_ae351d1b8e71e5253d34cfb3e7ee3ec2a}{m\_flowDscpMap}[insert.first->second][dscp] ++;
177     \}
178 
179   *out\_flowId = insert.first->second;
180   *out\_packetId = \hyperlink{classns3_1_1Ipv6FlowClassifier_adfa0df24172af71f377bc0b56456e1ae}{m\_flowPktIdMap}[*out\_flowId];
181 
182   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
183 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Ipv6\+Flow\+Classifier@{ns3\+::\+Ipv6\+Flow\+Classifier}!Find\+Flow@{Find\+Flow}}
\index{Find\+Flow@{Find\+Flow}!ns3\+::\+Ipv6\+Flow\+Classifier@{ns3\+::\+Ipv6\+Flow\+Classifier}}
\subsubsection[{\texorpdfstring{Find\+Flow(\+Flow\+Id flow\+Id) const }{FindFlow(FlowId flowId) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+Flow\+Classifier\+::\+Five\+Tuple} ns3\+::\+Ipv6\+Flow\+Classifier\+::\+Find\+Flow (
\begin{DoxyParamCaption}
\item[{{\bf Flow\+Id}}]{flow\+Id}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv6FlowClassifier_a8d1f460cd4a07e559430d1d7ab9cd9c6}{}\label{classns3_1_1Ipv6FlowClassifier_a8d1f460cd4a07e559430d1d7ab9cd9c6}
Searches for the \hyperlink{structns3_1_1Ipv6FlowClassifier_1_1FiveTuple}{Five\+Tuple} corresponding to the given flow\+Id 
\begin{DoxyParams}{Parameters}
{\em flow\+Id} & the Flow\+Id to search for \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the \hyperlink{structns3_1_1Ipv6FlowClassifier_1_1FiveTuple}{Five\+Tuple} corresponding to flow\+Id 
\end{DoxyReturn}

\begin{DoxyCode}
188 \{
189   \textcolor{keywordflow}{for} (std::map<FiveTuple, FlowId>::const\_iterator
190        iter = \hyperlink{classns3_1_1Ipv6FlowClassifier_a2ba466f42f102ab81aed0d5cffde57a1}{m\_flowMap}.begin (); iter != \hyperlink{classns3_1_1Ipv6FlowClassifier_a2ba466f42f102ab81aed0d5cffde57a1}{m\_flowMap}.end (); iter++)
191     \{
192       \textcolor{keywordflow}{if} (iter->second == flowId)
193         \{
194           \textcolor{keywordflow}{return} iter->first;
195         \}
196     \}
197   \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Could not find the flow with ID "} << flowId);
198   FiveTuple retval = \{ \hyperlink{classns3_1_1Ipv6Address_a63a34bdb1505e05fbdd07d316d0bd7e6}{Ipv6Address::GetZero} (), 
      \hyperlink{classns3_1_1Ipv6Address_a63a34bdb1505e05fbdd07d316d0bd7e6}{Ipv6Address::GetZero} (), 0, 0, 0 \};
199   \textcolor{keywordflow}{return} retval;
200 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::\+Ipv6\+Flow\+Classifier@{ns3\+::\+Ipv6\+Flow\+Classifier}!Get\+Dscp\+Counts@{Get\+Dscp\+Counts}}
\index{Get\+Dscp\+Counts@{Get\+Dscp\+Counts}!ns3\+::\+Ipv6\+Flow\+Classifier@{ns3\+::\+Ipv6\+Flow\+Classifier}}
\subsubsection[{\texorpdfstring{Get\+Dscp\+Counts(\+Flow\+Id flow\+Id) const }{GetDscpCounts(FlowId flowId) const }}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<$ std\+::pair$<$ {\bf Ipv6\+Header\+::\+Dscp\+Type}, uint32\+\_\+t $>$ $>$ ns3\+::\+Ipv6\+Flow\+Classifier\+::\+Get\+Dscp\+Counts (
\begin{DoxyParamCaption}
\item[{{\bf Flow\+Id}}]{flow\+Id}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv6FlowClassifier_aa529a3600f6198f3b5093f590ee4fba4}{}\label{classns3_1_1Ipv6FlowClassifier_aa529a3600f6198f3b5093f590ee4fba4}


get the D\+S\+CP values of the packets belonging to the flow with the given Flow\+Id, sorted in decreasing order of number of packets seen with that D\+S\+CP value 


\begin{DoxyParams}{Parameters}
{\em flow\+Id} & the identifier of the flow of interest \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the vector of D\+S\+CP values 
\end{DoxyReturn}

\begin{DoxyCode}
211 \{
212   std::map<FlowId, std::map<Ipv6Header::DscpType, uint32\_t> >::const\_iterator flow
213     = \hyperlink{classns3_1_1Ipv6FlowClassifier_ae351d1b8e71e5253d34cfb3e7ee3ec2a}{m\_flowDscpMap}.find (flowId);
214 
215   \textcolor{keywordflow}{if} (flow == \hyperlink{classns3_1_1Ipv6FlowClassifier_ae351d1b8e71e5253d34cfb3e7ee3ec2a}{m\_flowDscpMap}.end ())
216     \{
217       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Could not find the flow with ID "} << flowId);
218     \}
219 
220   std::vector<std::pair<Ipv6Header::DscpType, uint32\_t> > v (flow->second.begin (), flow->second.end ());
221   std::sort (v.begin (), v.end (), SortByCount ());
222   \textcolor{keywordflow}{return} v;
223 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+Flow\+Classifier@{ns3\+::\+Ipv6\+Flow\+Classifier}!Serialize\+To\+Xml\+Stream@{Serialize\+To\+Xml\+Stream}}
\index{Serialize\+To\+Xml\+Stream@{Serialize\+To\+Xml\+Stream}!ns3\+::\+Ipv6\+Flow\+Classifier@{ns3\+::\+Ipv6\+Flow\+Classifier}}
\subsubsection[{\texorpdfstring{Serialize\+To\+Xml\+Stream(std\+::ostream \&os, uint16\+\_\+t indent) const }{SerializeToXmlStream(std::ostream &os, uint16_t indent) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Flow\+Classifier\+::\+Serialize\+To\+Xml\+Stream (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os, }
\item[{uint16\+\_\+t}]{indent}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6FlowClassifier_a4ffab8c7d4a16cc9c5b941c9b8550fae}{}\label{classns3_1_1Ipv6FlowClassifier_a4ffab8c7d4a16cc9c5b941c9b8550fae}
Serializes the results to an std\+::ostream in X\+ML format 
\begin{DoxyParams}{Parameters}
{\em os} & the output stream \\
\hline
{\em indent} & number of spaces to use as base indentation level \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1FlowClassifier_aeb06e447fa079fcedc7c9745c23958b3}{ns3\+::\+Flow\+Classifier}.


\begin{DoxyCode}
227 \{
228   \hyperlink{classns3_1_1FlowClassifier_adc5d8694d3c9059b5ac2c664e5897088}{Indent} (os, indent); os << \textcolor{stringliteral}{"<Ipv6FlowClassifier>\(\backslash\)n"};
229 
230   indent += 2;
231   \textcolor{keywordflow}{for} (std::map<FiveTuple, FlowId>::const\_iterator
232        iter = \hyperlink{classns3_1_1Ipv6FlowClassifier_a2ba466f42f102ab81aed0d5cffde57a1}{m\_flowMap}.begin (); iter != \hyperlink{classns3_1_1Ipv6FlowClassifier_a2ba466f42f102ab81aed0d5cffde57a1}{m\_flowMap}.end (); iter++)
233     \{
234       \hyperlink{classns3_1_1FlowClassifier_adc5d8694d3c9059b5ac2c664e5897088}{Indent} (os, indent);
235       os << \textcolor{stringliteral}{"<Flow flowId=\(\backslash\)""} << iter->second << \textcolor{stringliteral}{"\(\backslash\)""}
236          << \textcolor{stringliteral}{" sourceAddress=\(\backslash\)""} << iter->first.sourceAddress << \textcolor{stringliteral}{"\(\backslash\)""}
237          << \textcolor{stringliteral}{" destinationAddress=\(\backslash\)""} << iter->first.destinationAddress << \textcolor{stringliteral}{"\(\backslash\)""}
238          << \textcolor{stringliteral}{" protocol=\(\backslash\)""} << int(iter->first.protocol) << \textcolor{stringliteral}{"\(\backslash\)""}
239          << \textcolor{stringliteral}{" sourcePort=\(\backslash\)""} << iter->first.sourcePort << \textcolor{stringliteral}{"\(\backslash\)""}
240          << \textcolor{stringliteral}{" destinationPort=\(\backslash\)""} << iter->first.destinationPort << \textcolor{stringliteral}{"\(\backslash\)">\(\backslash\)n"};
241 
242       indent += 2;
243       std::map<FlowId, std::map<Ipv6Header::DscpType, uint32\_t> >::const\_iterator flow
244         = \hyperlink{classns3_1_1Ipv6FlowClassifier_ae351d1b8e71e5253d34cfb3e7ee3ec2a}{m\_flowDscpMap}.find (iter->second);
245 
246       \textcolor{keywordflow}{if} (flow != \hyperlink{classns3_1_1Ipv6FlowClassifier_ae351d1b8e71e5253d34cfb3e7ee3ec2a}{m\_flowDscpMap}.end ())
247         \{
248           \textcolor{keywordflow}{for} (std::map<Ipv6Header::DscpType, uint32\_t>::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = flow->second.begin (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != flow->second.end (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
249             \{
250               \hyperlink{classns3_1_1FlowClassifier_adc5d8694d3c9059b5ac2c664e5897088}{Indent} (os, indent);
251               os << \textcolor{stringliteral}{"<Dscp value=\(\backslash\)"0x"} << std::hex << static\_cast<uint32\_t> (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->first) << \textcolor{stringliteral}{"\(\backslash\)""}
252                  << \textcolor{stringliteral}{" packets=\(\backslash\)""} << std::dec << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second << \textcolor{stringliteral}{"\(\backslash\)" />\(\backslash\)n"};
253             \}
254         \}
255 
256       indent -= 2;
257       \hyperlink{classns3_1_1FlowClassifier_adc5d8694d3c9059b5ac2c664e5897088}{Indent} (os, indent); os << \textcolor{stringliteral}{"</Flow>\(\backslash\)n"};
258     \}
259 
260   indent -= 2;
261   \hyperlink{classns3_1_1FlowClassifier_adc5d8694d3c9059b5ac2c664e5897088}{Indent} (os, indent); os << \textcolor{stringliteral}{"</Ipv6FlowClassifier>\(\backslash\)n"};
262 
263 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4




\subsection{Member Data Documentation}
\index{ns3\+::\+Ipv6\+Flow\+Classifier@{ns3\+::\+Ipv6\+Flow\+Classifier}!m\+\_\+flow\+Dscp\+Map@{m\+\_\+flow\+Dscp\+Map}}
\index{m\+\_\+flow\+Dscp\+Map@{m\+\_\+flow\+Dscp\+Map}!ns3\+::\+Ipv6\+Flow\+Classifier@{ns3\+::\+Ipv6\+Flow\+Classifier}}
\subsubsection[{\texorpdfstring{m\+\_\+flow\+Dscp\+Map}{m_flowDscpMap}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<${\bf Flow\+Id}, std\+::map$<${\bf Ipv6\+Header\+::\+Dscp\+Type}, uint32\+\_\+t$>$ $>$ ns3\+::\+Ipv6\+Flow\+Classifier\+::m\+\_\+flow\+Dscp\+Map\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6FlowClassifier_ae351d1b8e71e5253d34cfb3e7ee3ec2a}{}\label{classns3_1_1Ipv6FlowClassifier_ae351d1b8e71e5253d34cfb3e7ee3ec2a}


Map Flow\+Ids to (D\+S\+CP value, packet count) pairs. 

\index{ns3\+::\+Ipv6\+Flow\+Classifier@{ns3\+::\+Ipv6\+Flow\+Classifier}!m\+\_\+flow\+Map@{m\+\_\+flow\+Map}}
\index{m\+\_\+flow\+Map@{m\+\_\+flow\+Map}!ns3\+::\+Ipv6\+Flow\+Classifier@{ns3\+::\+Ipv6\+Flow\+Classifier}}
\subsubsection[{\texorpdfstring{m\+\_\+flow\+Map}{m_flowMap}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<${\bf Five\+Tuple}, {\bf Flow\+Id}$>$ ns3\+::\+Ipv6\+Flow\+Classifier\+::m\+\_\+flow\+Map\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6FlowClassifier_a2ba466f42f102ab81aed0d5cffde57a1}{}\label{classns3_1_1Ipv6FlowClassifier_a2ba466f42f102ab81aed0d5cffde57a1}


Map to Flows Identifiers to Flow\+Ids. 

\index{ns3\+::\+Ipv6\+Flow\+Classifier@{ns3\+::\+Ipv6\+Flow\+Classifier}!m\+\_\+flow\+Pkt\+Id\+Map@{m\+\_\+flow\+Pkt\+Id\+Map}}
\index{m\+\_\+flow\+Pkt\+Id\+Map@{m\+\_\+flow\+Pkt\+Id\+Map}!ns3\+::\+Ipv6\+Flow\+Classifier@{ns3\+::\+Ipv6\+Flow\+Classifier}}
\subsubsection[{\texorpdfstring{m\+\_\+flow\+Pkt\+Id\+Map}{m_flowPktIdMap}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<${\bf Flow\+Id}, {\bf Flow\+Packet\+Id}$>$ ns3\+::\+Ipv6\+Flow\+Classifier\+::m\+\_\+flow\+Pkt\+Id\+Map\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6FlowClassifier_adfa0df24172af71f377bc0b56456e1ae}{}\label{classns3_1_1Ipv6FlowClassifier_adfa0df24172af71f377bc0b56456e1ae}


Map to Flow\+Ids to Flow\+Packet\+Id. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
flow-\/monitor/model/\hyperlink{ipv6-flow-classifier_8h}{ipv6-\/flow-\/classifier.\+h}\item 
flow-\/monitor/model/\hyperlink{ipv6-flow-classifier_8cc}{ipv6-\/flow-\/classifier.\+cc}\end{DoxyCompactItemize}
