\hypertarget{classns3_1_1PacketTagList}{}\section{ns3\+:\+:Packet\+Tag\+List Class Reference}
\label{classns3_1_1PacketTagList}\index{ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}}


List of the packet tags stored in a packet.  




{\ttfamily \#include $<$packet-\/tag-\/list.\+h$>$}



Collaboration diagram for ns3\+:\+:Packet\+Tag\+List\+:
% FIG 0
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structns3_1_1PacketTagList_1_1TagData}{Tag\+Data}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1PacketTagList_a9fb30fea59b079ce7bccdae5fbeb0717}{Packet\+Tag\+List} ()
\item 
\hyperlink{classns3_1_1PacketTagList_a45afac90475e8606e9333a7a0f659d56}{Packet\+Tag\+List} (\hyperlink{classns3_1_1PacketTagList}{Packet\+Tag\+List} const \&o)
\item 
\hyperlink{classns3_1_1PacketTagList}{Packet\+Tag\+List} \& \hyperlink{classns3_1_1PacketTagList_a9f9ad2ae05a714508437cbeca700fe77}{operator=} (\hyperlink{classns3_1_1PacketTagList}{Packet\+Tag\+List} const \&o)
\item 
\hyperlink{classns3_1_1PacketTagList_adcbf1a29541b5e35bf42a16ca604d7ae}{$\sim$\+Packet\+Tag\+List} ()
\item 
void \hyperlink{classns3_1_1PacketTagList_a37f008b6f336f3ac6232d558b93e8a6e}{Add} (\hyperlink{classns3_1_1Tag}{Tag} const \&tag) const 
\item 
bool \hyperlink{classns3_1_1PacketTagList_a043d984c546f67adc273448747784ee3}{Remove} (\hyperlink{classns3_1_1Tag}{Tag} \&tag)
\item 
bool \hyperlink{classns3_1_1PacketTagList_a6a6bc266832b2cead6cf42e3daee1041}{Replace} (\hyperlink{classns3_1_1Tag}{Tag} \&tag)
\item 
bool \hyperlink{classns3_1_1PacketTagList_a49151e3dbbddac7820d2210bbde47c4b}{Peek} (\hyperlink{classns3_1_1Tag}{Tag} \&tag) const 
\item 
void \hyperlink{classns3_1_1PacketTagList_a798eb1d77415704e948194564d0eaa4e}{Remove\+All} (void)
\item 
const struct \hyperlink{structns3_1_1PacketTagList_1_1TagData}{Packet\+Tag\+List\+::\+Tag\+Data} $\ast$ \hyperlink{classns3_1_1PacketTagList_a134ba1f369de24c2a5bea79bbfec16d3}{Head} (void) const 
\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
typedef bool(Packet\+Tag\+List\+::$\ast$ \hyperlink{classns3_1_1PacketTagList_a79166d6e882aec38600fd64dbd4b9841}{C\+O\+W\+Writer}) (\hyperlink{classns3_1_1Tag}{Tag} \&tag, bool pre\+Merge, struct \hyperlink{structns3_1_1PacketTagList_1_1TagData}{Tag\+Data} $\ast$cur, struct \hyperlink{structns3_1_1PacketTagList_1_1TagData}{Tag\+Data} $\ast$$\ast$prev\+Next)
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classns3_1_1PacketTagList_a7d98f0fe590d22f8224d718af0ac9713}{C\+O\+W\+Traverse} (\hyperlink{classns3_1_1Tag}{Tag} \&tag, \hyperlink{classns3_1_1PacketTagList_a79166d6e882aec38600fd64dbd4b9841}{Packet\+Tag\+List\+::\+C\+O\+W\+Writer} Writer)
\item 
bool \hyperlink{classns3_1_1PacketTagList_aceea9c63e697635ba35564610a7150cc}{Remove\+Writer} (\hyperlink{classns3_1_1Tag}{Tag} \&tag, bool pre\+Merge, struct \hyperlink{structns3_1_1PacketTagList_1_1TagData}{Tag\+Data} $\ast$cur, struct \hyperlink{structns3_1_1PacketTagList_1_1TagData}{Tag\+Data} $\ast$$\ast$prev\+Next)
\item 
bool \hyperlink{classns3_1_1PacketTagList_a21cfeb795e3ef3a688d6114272d41c53}{Replace\+Writer} (\hyperlink{classns3_1_1Tag}{Tag} \&tag, bool pre\+Merge, struct \hyperlink{structns3_1_1PacketTagList_1_1TagData}{Tag\+Data} $\ast$cur, struct \hyperlink{structns3_1_1PacketTagList_1_1TagData}{Tag\+Data} $\ast$$\ast$prev\+Next)
\end{DoxyCompactItemize}
\subsection*{Static Private Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{structns3_1_1PacketTagList_1_1TagData}{Tag\+Data} $\ast$ \hyperlink{classns3_1_1PacketTagList_abfab9cfb3a21336e2f7962cc51fcff94}{Create\+Tag\+Data} (size\+\_\+t data\+Size)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structns3_1_1PacketTagList_1_1TagData}{Tag\+Data} $\ast$ \hyperlink{classns3_1_1PacketTagList_a69e3eca2ef2793ab142ecd2b2ede4ead}{m\+\_\+next}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
List of the packet tags stored in a packet. 

This class is mostly private to the \hyperlink{classns3_1_1Packet}{Packet} implementation and users should never have to access it directly. 

\subsection{Member Typedef Documentation}
\index{ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}!C\+O\+W\+Writer@{C\+O\+W\+Writer}}
\index{C\+O\+W\+Writer@{C\+O\+W\+Writer}!ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}}
\subsubsection[{\texorpdfstring{C\+O\+W\+Writer}{COWWriter}}]{\setlength{\rightskip}{0pt plus 5cm}typedef bool(Packet\+Tag\+List\+::$\ast$ ns3\+::\+Packet\+Tag\+List\+::\+C\+O\+W\+Writer) ({\bf Tag} \&tag, bool pre\+Merge, struct {\bf Tag\+Data} $\ast$cur, struct {\bf Tag\+Data} $\ast$$\ast$prev\+Next)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PacketTagList_a79166d6e882aec38600fd64dbd4b9841}{}\label{classns3_1_1PacketTagList_a79166d6e882aec38600fd64dbd4b9841}
Typedef of method function pointer for copy-\/on-\/write operations


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em tag} & The tag type to operate on. \\
\hline
\mbox{\tt in}  & {\em pre\+Merge} & True if \{tag\} was found before the first merge, false otherwise. \\
\hline
\mbox{\tt in}  & {\em cur} & Pointer to the tag. \\
\hline
\mbox{\tt in}  & {\em prev\+Next} & Pointer to the struct \hyperlink{structns3_1_1PacketTagList_1_1TagData_a9c4f438b752b46cdd695a68fca886822}{Tag\+Data.\+next} pointer pointing to \{cur\}. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if operation successful, false otherwise 
\end{DoxyReturn}


\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}!Packet\+Tag\+List@{Packet\+Tag\+List}}
\index{Packet\+Tag\+List@{Packet\+Tag\+List}!ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}}
\subsubsection[{\texorpdfstring{Packet\+Tag\+List()}{PacketTagList()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Packet\+Tag\+List\+::\+Packet\+Tag\+List (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classns3_1_1PacketTagList_a9fb30fea59b079ce7bccdae5fbeb0717}{}\label{classns3_1_1PacketTagList_a9fb30fea59b079ce7bccdae5fbeb0717}
Create a new \hyperlink{classns3_1_1PacketTagList}{Packet\+Tag\+List}. 
\begin{DoxyCode}
296   : \hyperlink{classns3_1_1PacketTagList_a69e3eca2ef2793ab142ecd2b2ede4ead}{m\_next} ()
297 \{
298 \}
\end{DoxyCode}
\index{ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}!Packet\+Tag\+List@{Packet\+Tag\+List}}
\index{Packet\+Tag\+List@{Packet\+Tag\+List}!ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}}
\subsubsection[{\texorpdfstring{Packet\+Tag\+List(\+Packet\+Tag\+List const \&o)}{PacketTagList(PacketTagList const &o)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Packet\+Tag\+List\+::\+Packet\+Tag\+List (
\begin{DoxyParamCaption}
\item[{{\bf Packet\+Tag\+List} const \&}]{o}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classns3_1_1PacketTagList_a45afac90475e8606e9333a7a0f659d56}{}\label{classns3_1_1PacketTagList_a45afac90475e8606e9333a7a0f659d56}
Copy constructor


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em o} & The \hyperlink{classns3_1_1PacketTagList}{Packet\+Tag\+List} to copy.\\
\hline
\end{DoxyParams}
This makes a light-\/weight copy by \hyperlink{classns3_1_1PacketTagList_a798eb1d77415704e948194564d0eaa4e}{Remove\+All}, then pointing to the same \hyperlink{structns3_1_1PacketTagList_1_1TagData}{Tag\+Data} as \{o\}. 
\begin{DoxyCode}
301   : \hyperlink{classns3_1_1PacketTagList_a69e3eca2ef2793ab142ecd2b2ede4ead}{m\_next} (o.m\_next)
302 \{
303   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PacketTagList_a69e3eca2ef2793ab142ecd2b2ede4ead}{m\_next} != 0)
304     \{
305       \hyperlink{classns3_1_1PacketTagList_a69e3eca2ef2793ab142ecd2b2ede4ead}{m\_next}->\hyperlink{structns3_1_1PacketTagList_1_1TagData_a877d4257ceb116e1231c3d7e33131c98}{count}++;
306     \}
307 \}
\end{DoxyCode}
\index{ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}!````~Packet\+Tag\+List@{$\sim$\+Packet\+Tag\+List}}
\index{````~Packet\+Tag\+List@{$\sim$\+Packet\+Tag\+List}!ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}}
\subsubsection[{\texorpdfstring{$\sim$\+Packet\+Tag\+List()}{~PacketTagList()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Packet\+Tag\+List\+::$\sim$\+Packet\+Tag\+List (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classns3_1_1PacketTagList_adcbf1a29541b5e35bf42a16ca604d7ae}{}\label{classns3_1_1PacketTagList_adcbf1a29541b5e35bf42a16ca604d7ae}
Destructor

\hyperlink{classns3_1_1PacketTagList_a798eb1d77415704e948194564d0eaa4e}{Remove\+All}\textquotesingle{}s the tags up to the first merge. 
\begin{DoxyCode}
327 \{
328   \hyperlink{classns3_1_1PacketTagList_a798eb1d77415704e948194564d0eaa4e}{RemoveAll} ();
329 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 1




\subsection{Member Function Documentation}
\index{ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}!Add@{Add}}
\index{Add@{Add}!ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}}
\subsubsection[{\texorpdfstring{Add(\+Tag const \&tag) const }{Add(Tag const &tag) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Packet\+Tag\+List\+::\+Add (
\begin{DoxyParamCaption}
\item[{{\bf Tag} const \&}]{tag}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1PacketTagList_a37f008b6f336f3ac6232d558b93e8a6e}{}\label{classns3_1_1PacketTagList_a37f008b6f336f3ac6232d558b93e8a6e}
Add a tag to the head of this branch.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em tag} & The tag to add \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
261 \{
262   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << tag.GetInstanceTypeId ());
263   \textcolor{comment}{// ensure this id was not yet added}
264   \textcolor{keywordflow}{for} (\textcolor{keyword}{struct} TagData *cur = \hyperlink{classns3_1_1PacketTagList_a69e3eca2ef2793ab142ecd2b2ede4ead}{m\_next}; cur != 0; cur = cur->\hyperlink{structns3_1_1PacketTagList_1_1TagData_a9c4f438b752b46cdd695a68fca886822}{next}) 
265     \{
266       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (cur->tid != tag.GetInstanceTypeId (),
267                      \textcolor{stringliteral}{"Error: cannot add the same kind of tag twice."});
268     \}
269   \textcolor{keyword}{struct }TagData * head = \hyperlink{classns3_1_1PacketTagList_abfab9cfb3a21336e2f7962cc51fcff94}{CreateTagData} (tag.GetSerializedSize ());
270   head->\hyperlink{structns3_1_1PacketTagList_1_1TagData_a877d4257ceb116e1231c3d7e33131c98}{count} = 1;
271   head->next = 0;
272   head->tid = tag.GetInstanceTypeId ();
273   head->next = \hyperlink{classns3_1_1PacketTagList_a69e3eca2ef2793ab142ecd2b2ede4ead}{m\_next};
274   tag.Serialize (TagBuffer (head->data, head->data + head->size));
275 
276   \textcolor{keyword}{const\_cast<}\hyperlink{classns3_1_1PacketTagList_a9fb30fea59b079ce7bccdae5fbeb0717}{PacketTagList} *\textcolor{keyword}{>} (\textcolor{keyword}{this})->\hyperlink{classns3_1_1PacketTagList_a69e3eca2ef2793ab142ecd2b2ede4ead}{m\_next} = head;
277 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2




Here is the caller graph for this function\+:
% FIG 3


\index{ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}!C\+O\+W\+Traverse@{C\+O\+W\+Traverse}}
\index{C\+O\+W\+Traverse@{C\+O\+W\+Traverse}!ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}}
\subsubsection[{\texorpdfstring{C\+O\+W\+Traverse(\+Tag \&tag, Packet\+Tag\+List\+::\+C\+O\+W\+Writer Writer)}{COWTraverse(Tag &tag, PacketTagList::COWWriter Writer)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Packet\+Tag\+List\+::\+C\+O\+W\+Traverse (
\begin{DoxyParamCaption}
\item[{{\bf Tag} \&}]{tag, }
\item[{{\bf Packet\+Tag\+List\+::\+C\+O\+W\+Writer}}]{Writer}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PacketTagList_a7d98f0fe590d22f8224d718af0ac9713}{}\label{classns3_1_1PacketTagList_a7d98f0fe590d22f8224d718af0ac9713}
Traverse the list implementing copy-\/on-\/write, using \{Writer\}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em tag} & The tag type to operate on. \\
\hline
\mbox{\tt in}  & {\em Writer} & The copy-\/on-\/write function to use. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if \{tag\} found, false otherwise. 
\end{DoxyReturn}

\begin{DoxyCode}
56 \{
57   TypeId tid = tag.GetInstanceTypeId ();
58   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << tid);
59   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO}     (\textcolor{stringliteral}{"looking for "} << tid);
60 
61   \textcolor{comment}{// trivial case when list is empty}
62   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PacketTagList_a69e3eca2ef2793ab142ecd2b2ede4ead}{m\_next} == 0)
63     \{
64       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
65     \}
66 
67   \textcolor{keywordtype}{bool} found = \textcolor{keyword}{false};
68 
69   \textcolor{keyword}{struct }TagData ** prevNext = &\hyperlink{classns3_1_1PacketTagList_a69e3eca2ef2793ab142ecd2b2ede4ead}{m\_next}; \textcolor{comment}{// previous node's next pointer}
70   \textcolor{keyword}{struct }TagData  * cur      =  \hyperlink{classns3_1_1PacketTagList_a69e3eca2ef2793ab142ecd2b2ede4ead}{m\_next}; \textcolor{comment}{// cursor to current node}
71   \textcolor{keyword}{struct }TagData  * it = 0;             \textcolor{comment}{// utility}
72 
73   \textcolor{comment}{// Search from the head of the list until we find tid or a merge}
74   \textcolor{keywordflow}{while} (cur != 0)
75     \{
76       \textcolor{keywordflow}{if} (cur->count > 1)
77         \{
78           \textcolor{comment}{// found merge}
79           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"found initial merge before tid"});
80           \textcolor{keywordflow}{break};
81         \}
82       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (cur->tid == tid)
83         \{
84           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"found tid before initial merge, calling writer"});
85           found = (this->*Writer)(tag, \textcolor{keyword}{true}, cur, prevNext);
86           \textcolor{keywordflow}{break};
87         \}
88       \textcolor{keywordflow}{else}
89         \{
90           \textcolor{comment}{// no merge or tid found yet, move on}
91           prevNext = &cur->next;
92           cur      =  cur->next;
93         \}
94     \}  \textcolor{comment}{// while !found && !cow}
95 
96   \textcolor{comment}{// did we find it or run out of tags?}
97   \textcolor{keywordflow}{if} (cur == 0 || found)
98     \{
99       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"returning after header with found: "} << found);
100       \textcolor{keywordflow}{return} found;
101     \}
102 
103   \textcolor{comment}{// From here on out, we have to copy the list}
104   \textcolor{comment}{// until we find tid, then link past it}
105 
106   \textcolor{comment}{// Before we do all that work, let's make sure tid really exists}
107   \textcolor{keywordflow}{for} (it = cur; it != 0; it = it->next)
108     \{
109       \textcolor{keywordflow}{if} (it->tid == tid)
110         \{
111           \textcolor{keywordflow}{break};
112         \}
113     \}
114   \textcolor{keywordflow}{if} (it == 0)
115     \{
116       \textcolor{comment}{// got to end of list without finding tid}
117       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"tid not found after first merge"});
118       \textcolor{keywordflow}{return} found;
119     \}
120 
121   \textcolor{comment}{// At this point cur is a merge, but untested for tid}
122   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (cur != 0);
123   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (cur->count > 1);
124 
125   \textcolor{comment}{/*}
126 \textcolor{comment}{     Walk the remainder of the list, copying, until we find tid}
127 \textcolor{comment}{     As we put a copy of the cur node onto our list,}
128 \textcolor{comment}{     we move the merge point down the list.}
129 \textcolor{comment}{}
130 \textcolor{comment}{     Starting position                  End position}
131 \textcolor{comment}{       T1 is a merge                     T1.count decremented}
132 \textcolor{comment}{                                         T2 is a merge}
133 \textcolor{comment}{                                         T1' is a copy of T1}
134 \textcolor{comment}{}
135 \textcolor{comment}{          other                             other}
136 \textcolor{comment}{               \(\backslash\)                                 \(\backslash\)}
137 \textcolor{comment}{      Prev  ->  T1  ->  T2  -> ...                T1  ->  T2  -> ...}
138 \textcolor{comment}{           /   /                                         /|}
139 \textcolor{comment}{      pNext cur                         Prev  ->  T1' --/ |}
140 \textcolor{comment}{                                                     /    |}
141 \textcolor{comment}{                                                pNext   cur}
142 \textcolor{comment}{}
143 \textcolor{comment}{     When we reach tid, we link past it, decrement count, and we're done.}
144 \textcolor{comment}{  */}
145 
146   \textcolor{comment}{// Should normally check for null cur pointer,}
147   \textcolor{comment}{// but since we know tid exists, we'll skip this test}
148   \textcolor{keywordflow}{while} ( \textcolor{comment}{/* cur && */} cur->tid != tid)
149     \{
150       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (cur != 0);
151       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (cur->count > 1);
152       cur->count--;                       \textcolor{comment}{// unmerge cur}
153       \textcolor{keyword}{struct }TagData * copy = \hyperlink{classns3_1_1PacketTagList_abfab9cfb3a21336e2f7962cc51fcff94}{CreateTagData} (cur->size);
154       copy->tid = cur->tid;
155       copy->count = 1;
156       copy->size = cur->size;
157       memcpy (copy->data, cur->data, copy->size);
158       copy->next = cur->next;             \textcolor{comment}{// merge into tail}
159       copy->next->count++;                \textcolor{comment}{// mark new merge}
160       *prevNext = copy;                   \textcolor{comment}{// point prior list at copy}
161       prevNext = &copy->next;             \textcolor{comment}{// advance}
162       cur      =  copy->next;
163     \}
164   \textcolor{comment}{// Sanity check:}
165   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (cur != 0);                 \textcolor{comment}{// cur should be non-zero}
166   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (cur->tid == tid);          \textcolor{comment}{// cur->tid should be tid}
167   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (cur->count > 1);           \textcolor{comment}{// cur should be a merge}
168 
169   \textcolor{comment}{// link around tid, removing it from our list}
170   found = (this->*Writer)(tag, \textcolor{keyword}{false}, cur, prevNext);
171   \textcolor{keywordflow}{return} found;
172 
173 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4




Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}!Create\+Tag\+Data@{Create\+Tag\+Data}}
\index{Create\+Tag\+Data@{Create\+Tag\+Data}!ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}}
\subsubsection[{\texorpdfstring{Create\+Tag\+Data(size\+\_\+t data\+Size)}{CreateTagData(size_t dataSize)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Packet\+Tag\+List\+::\+Tag\+Data} $\ast$ ns3\+::\+Packet\+Tag\+List\+::\+Create\+Tag\+Data (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{data\+Size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\hypertarget{classns3_1_1PacketTagList_abfab9cfb3a21336e2f7962cc51fcff94}{}\label{classns3_1_1PacketTagList_abfab9cfb3a21336e2f7962cc51fcff94}
Allocate and construct a \hyperlink{structns3_1_1PacketTagList_1_1TagData}{Tag\+Data} struct, sizing the data area large enough to serialize data\+Size bytes from a \hyperlink{classns3_1_1Tag}{Tag}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em data\+Size} & The serialized size of the \hyperlink{classns3_1_1Tag}{Tag}. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The newly constructed \hyperlink{structns3_1_1PacketTagList_1_1TagData}{Tag\+Data} object. 
\end{DoxyReturn}

\begin{DoxyCode}
39 \{
40   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (dataSize
41                  < std::numeric\_limits<decltype(\hyperlink{structns3_1_1PacketTagList_1_1TagData_a6d4ea1a09db8032900e037cfe938866f}{TagData::size})>::
      \hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{max} (),
42                  \textcolor{stringliteral}{"Requested TagData size "} << dataSize
43                  << \textcolor{stringliteral}{" exceeds maximum "}
44                  << std::numeric\_limits<decltype(\hyperlink{structns3_1_1PacketTagList_1_1TagData_a6d4ea1a09db8032900e037cfe938866f}{TagData::size})>::
      \hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{max} () );
45 
46   \textcolor{keywordtype}{void} * \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = std::malloc (\textcolor{keyword}{sizeof} (TagData) + dataSize - 1);
47   \textcolor{comment}{// The matching frees are in RemoveAll and RemoveWriter}
48 
49   TagData * tag = \textcolor{keyword}{new} (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}) TagData;
50   tag->size = dataSize;
51   \textcolor{keywordflow}{return} tag;
52 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}!Head@{Head}}
\index{Head@{Head}!ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}}
\subsubsection[{\texorpdfstring{Head(void) const }{Head(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}const struct {\bf Packet\+Tag\+List\+::\+Tag\+Data} $\ast$ ns3\+::\+Packet\+Tag\+List\+::\+Head (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1PacketTagList_a134ba1f369de24c2a5bea79bbfec16d3}{}\label{classns3_1_1PacketTagList_a134ba1f369de24c2a5bea79bbfec16d3}
\begin{DoxyReturn}{Returns}
pointer to head of tag list 
\end{DoxyReturn}

\begin{DoxyCode}
299 \{
300   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1PacketTagList_a69e3eca2ef2793ab142ecd2b2ede4ead}{m\_next};
301 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}!operator=@{operator=}}
\index{operator=@{operator=}!ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}}
\subsubsection[{\texorpdfstring{operator=(\+Packet\+Tag\+List const \&o)}{operator=(PacketTagList const &o)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Packet\+Tag\+List} \& ns3\+::\+Packet\+Tag\+List\+::operator= (
\begin{DoxyParamCaption}
\item[{{\bf Packet\+Tag\+List} const \&}]{o}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classns3_1_1PacketTagList_a9f9ad2ae05a714508437cbeca700fe77}{}\label{classns3_1_1PacketTagList_a9f9ad2ae05a714508437cbeca700fe77}
Assignment


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em o} & The \hyperlink{classns3_1_1PacketTagList}{Packet\+Tag\+List} to copy. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the copied object
\end{DoxyReturn}
This makes a light-\/weight copy by \hyperlink{classns3_1_1PacketTagList_a798eb1d77415704e948194564d0eaa4e}{Remove\+All}, then pointing to the same \hyperlink{structns3_1_1PacketTagList_1_1TagData}{Tag\+Data} as \{o\}. 
\begin{DoxyCode}
311 \{
312   \textcolor{comment}{// self assignment}
313   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PacketTagList_a69e3eca2ef2793ab142ecd2b2ede4ead}{m\_next} == o.m\_next) 
314     \{
315       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
316     \}
317   \hyperlink{classns3_1_1PacketTagList_a798eb1d77415704e948194564d0eaa4e}{RemoveAll} ();
318   \hyperlink{classns3_1_1PacketTagList_a69e3eca2ef2793ab142ecd2b2ede4ead}{m\_next} = o.m\_next;
319   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1PacketTagList_a69e3eca2ef2793ab142ecd2b2ede4ead}{m\_next} != 0) 
320     \{
321       \hyperlink{classns3_1_1PacketTagList_a69e3eca2ef2793ab142ecd2b2ede4ead}{m\_next}->\hyperlink{structns3_1_1PacketTagList_1_1TagData_a877d4257ceb116e1231c3d7e33131c98}{count}++;
322     \}
323   \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
324 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8


\index{ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}!Peek@{Peek}}
\index{Peek@{Peek}!ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}}
\subsubsection[{\texorpdfstring{Peek(\+Tag \&tag) const }{Peek(Tag &tag) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Packet\+Tag\+List\+::\+Peek (
\begin{DoxyParamCaption}
\item[{{\bf Tag} \&}]{tag}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1PacketTagList_a49151e3dbbddac7820d2210bbde47c4b}{}\label{classns3_1_1PacketTagList_a49151e3dbbddac7820d2210bbde47c4b}
Find a tag and return its value.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em tag} & The tag type to find. If found, \{tag\} is set to the value of the tag found. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if \{tag\} is found, false otherwise. 
\end{DoxyReturn}

\begin{DoxyCode}
281 \{
282   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << tag.GetInstanceTypeId ());
283   TypeId tid = tag.GetInstanceTypeId ();
284   \textcolor{keywordflow}{for} (\textcolor{keyword}{struct} TagData *cur = \hyperlink{classns3_1_1PacketTagList_a69e3eca2ef2793ab142ecd2b2ede4ead}{m\_next}; cur != 0; cur = cur->\hyperlink{structns3_1_1PacketTagList_1_1TagData_a9c4f438b752b46cdd695a68fca886822}{next}) 
285     \{
286       \textcolor{keywordflow}{if} (cur->tid == tid) 
287         \{
288           \textcolor{comment}{/* found tag */}
289           tag.Deserialize (TagBuffer (cur->data, cur->data + cur->size));
290           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
291         \}
292     \}
293   \textcolor{comment}{/* no tag found */}
294   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
295 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9




Here is the caller graph for this function\+:
% FIG 10


\index{ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}!Remove@{Remove}}
\index{Remove@{Remove}!ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}}
\subsubsection[{\texorpdfstring{Remove(\+Tag \&tag)}{Remove(Tag &tag)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Packet\+Tag\+List\+::\+Remove (
\begin{DoxyParamCaption}
\item[{{\bf Tag} \&}]{tag}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PacketTagList_a043d984c546f67adc273448747784ee3}{}\label{classns3_1_1PacketTagList_a043d984c546f67adc273448747784ee3}
Remove (the first instance of) tag from the list.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em tag} & The tag type to remove. If found, \{tag\} is set to the value of the tag found. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if \{tag\} is found, false otherwise. 
\end{DoxyReturn}

\begin{DoxyCode}
177 \{
178   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1PacketTagList_a7d98f0fe590d22f8224d718af0ac9713}{COWTraverse} (tag, &\hyperlink{classns3_1_1PacketTagList_aceea9c63e697635ba35564610a7150cc}{PacketTagList::RemoveWriter});
179 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 11




Here is the caller graph for this function\+:
% FIG 12


\index{ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}!Remove\+All@{Remove\+All}}
\index{Remove\+All@{Remove\+All}!ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}}
\subsubsection[{\texorpdfstring{Remove\+All(void)}{RemoveAll(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Packet\+Tag\+List\+::\+Remove\+All (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classns3_1_1PacketTagList_a798eb1d77415704e948194564d0eaa4e}{}\label{classns3_1_1PacketTagList_a798eb1d77415704e948194564d0eaa4e}
Remove all tags from this list (up to the first merge). 
\begin{DoxyCode}
333 \{
334   \textcolor{keyword}{struct }TagData *prev = 0;
335   \textcolor{keywordflow}{for} (\textcolor{keyword}{struct} TagData *cur = \hyperlink{classns3_1_1PacketTagList_a69e3eca2ef2793ab142ecd2b2ede4ead}{m\_next}; cur != 0; cur = cur->\hyperlink{structns3_1_1PacketTagList_1_1TagData_a9c4f438b752b46cdd695a68fca886822}{next})
336     \{
337       cur->count--;
338       \textcolor{keywordflow}{if} (cur->count > 0) 
339         \{
340           \textcolor{keywordflow}{break};
341         \}
342       \textcolor{keywordflow}{if} (prev != 0) 
343         \{
344           prev->~TagData ();
345           std::free (prev);
346         \}
347       prev = cur;
348     \}
349   \textcolor{keywordflow}{if} (prev != 0) 
350     \{
351       prev->~TagData ();
352       std::free (prev);
353     \}
354   \hyperlink{classns3_1_1PacketTagList_a69e3eca2ef2793ab142ecd2b2ede4ead}{m\_next} = 0;
355 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 13


\index{ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}!Remove\+Writer@{Remove\+Writer}}
\index{Remove\+Writer@{Remove\+Writer}!ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}}
\subsubsection[{\texorpdfstring{Remove\+Writer(\+Tag \&tag, bool pre\+Merge, struct Tag\+Data $\ast$cur, struct Tag\+Data $\ast$$\ast$prev\+Next)}{RemoveWriter(Tag &tag, bool preMerge, struct TagData *cur, struct TagData **prevNext)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Packet\+Tag\+List\+::\+Remove\+Writer (
\begin{DoxyParamCaption}
\item[{{\bf Tag} \&}]{tag, }
\item[{bool}]{pre\+Merge, }
\item[{struct {\bf Tag\+Data} $\ast$}]{cur, }
\item[{struct {\bf Tag\+Data} $\ast$$\ast$}]{prev\+Next}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PacketTagList_aceea9c63e697635ba35564610a7150cc}{}\label{classns3_1_1PacketTagList_aceea9c63e697635ba35564610a7150cc}
Copy-\/on-\/write implementing Remove.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em tag} & The target tag type to remove. \\
\hline
\mbox{\tt in}  & {\em pre\+Merge} & True if \{tag\} was found before the first merge, false otherwise. \\
\hline
\mbox{\tt in}  & {\em cur} & Pointer to the tag. \\
\hline
\mbox{\tt in}  & {\em prev\+Next} & Pointer to the struct \hyperlink{structns3_1_1PacketTagList_1_1TagData_a9c4f438b752b46cdd695a68fca886822}{Tag\+Data.\+next} pointer pointing to \{cur\}. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True, since tag will definitely be removed. 
\end{DoxyReturn}

\begin{DoxyCode}
186 \{
187   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
188 
189   \textcolor{comment}{// found tid}
190   \textcolor{keywordtype}{bool} found = \textcolor{keyword}{true};
191   tag.Deserialize (TagBuffer (cur->data, cur->data + cur->size));
192   *prevNext = cur->next;            \textcolor{comment}{// link around cur}
193 
194   \textcolor{keywordflow}{if} (preMerge)
195     \{
196       \textcolor{comment}{// found tid before first merge, so delete cur}
197       cur->~TagData ();
198       std::free (cur);
199     \}
200   \textcolor{keywordflow}{else}
201     \{
202       \textcolor{comment}{// cur is always a merge at this point}
203       \textcolor{comment}{// unmerge cur, since we linked around it already}
204       cur->count--;
205       \textcolor{keywordflow}{if} (cur->next != 0)
206         \{
207           \textcolor{comment}{// there's a next, so make it a merge}
208           cur->next->count++;
209         \}
210     \}
211   \textcolor{keywordflow}{return} found;
212 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 14




Here is the caller graph for this function\+:
% FIG 15


\index{ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}!Replace@{Replace}}
\index{Replace@{Replace}!ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}}
\subsubsection[{\texorpdfstring{Replace(\+Tag \&tag)}{Replace(Tag &tag)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Packet\+Tag\+List\+::\+Replace (
\begin{DoxyParamCaption}
\item[{{\bf Tag} \&}]{tag}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PacketTagList_a6a6bc266832b2cead6cf42e3daee1041}{}\label{classns3_1_1PacketTagList_a6a6bc266832b2cead6cf42e3daee1041}
Replace the value of a tag.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em tag} & The tag type to replace. To get the old value of the tag, use \hyperlink{classns3_1_1PacketTagList_a49151e3dbbddac7820d2210bbde47c4b}{Peek} first. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if \{tag\} is found, false otherwise. If \{tag\} wasn\textquotesingle{}t found, Add is performed instead (so the list is guaranteed to have the new tag value either way). 
\end{DoxyReturn}

\begin{DoxyCode}
216 \{
217   \textcolor{keywordtype}{bool} found = \hyperlink{classns3_1_1PacketTagList_a7d98f0fe590d22f8224d718af0ac9713}{COWTraverse} (tag, &\hyperlink{classns3_1_1PacketTagList_a21cfeb795e3ef3a688d6114272d41c53}{PacketTagList::ReplaceWriter});
218   \textcolor{keywordflow}{if} (!found)
219     \{
220       \hyperlink{classns3_1_1PacketTagList_a37f008b6f336f3ac6232d558b93e8a6e}{Add} (tag);
221     \}
222   \textcolor{keywordflow}{return} found;
223 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 16




Here is the caller graph for this function\+:
% FIG 17


\index{ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}!Replace\+Writer@{Replace\+Writer}}
\index{Replace\+Writer@{Replace\+Writer}!ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}}
\subsubsection[{\texorpdfstring{Replace\+Writer(\+Tag \&tag, bool pre\+Merge, struct Tag\+Data $\ast$cur, struct Tag\+Data $\ast$$\ast$prev\+Next)}{ReplaceWriter(Tag &tag, bool preMerge, struct TagData *cur, struct TagData **prevNext)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Packet\+Tag\+List\+::\+Replace\+Writer (
\begin{DoxyParamCaption}
\item[{{\bf Tag} \&}]{tag, }
\item[{bool}]{pre\+Merge, }
\item[{struct {\bf Tag\+Data} $\ast$}]{cur, }
\item[{struct {\bf Tag\+Data} $\ast$$\ast$}]{prev\+Next}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PacketTagList_a21cfeb795e3ef3a688d6114272d41c53}{}\label{classns3_1_1PacketTagList_a21cfeb795e3ef3a688d6114272d41c53}
Copy-\/on-\/write implementing Replace


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em tag} & The target tag type to replace \\
\hline
\mbox{\tt in}  & {\em pre\+Merge} & True if \{tag\} was found before the first merge, false otherwise. \\
\hline
\mbox{\tt in}  & {\em cur} & Pointer to the tag \\
\hline
\mbox{\tt in}  & {\em prev\+Next} & Pointer to the struct \hyperlink{structns3_1_1PacketTagList_1_1TagData_a9c4f438b752b46cdd695a68fca886822}{Tag\+Data.\+next} pointer pointing to \{cur\}. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True, since tag value will definitely be replaced. 
\end{DoxyReturn}

\begin{DoxyCode}
230 \{
231   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
232 
233   \textcolor{comment}{// found tid}
234   \textcolor{keywordtype}{bool} found = \textcolor{keyword}{true};
235   \textcolor{keywordflow}{if} (preMerge)
236     \{
237       \textcolor{comment}{// found tid before first merge, so just rewrite}
238       tag.Serialize (TagBuffer (cur->data, cur->data + cur->size));
239     \}
240   \textcolor{keywordflow}{else}
241     \{
242       \textcolor{comment}{// cur is always a merge at this point}
243       \textcolor{comment}{// need to copy, replace, and link past cur}
244       cur->count--;                     \textcolor{comment}{// unmerge cur}
245       \textcolor{keyword}{struct }TagData * copy = \hyperlink{classns3_1_1PacketTagList_abfab9cfb3a21336e2f7962cc51fcff94}{CreateTagData} (tag.GetSerializedSize ());
246       copy->\hyperlink{structns3_1_1PacketTagList_1_1TagData_a5086e334de32e4eee36059907e5d2197}{tid} = tag.GetInstanceTypeId ();
247       copy->count = 1;
248       tag.Serialize (TagBuffer (copy->data, copy->data + copy->size));
249       copy->next = cur->next;           \textcolor{comment}{// merge into tail}
250       \textcolor{keywordflow}{if} (copy->next != 0)
251         \{
252           copy->next->count++;          \textcolor{comment}{// mark new merge}
253         \}
254       *prevNext = copy;                 \textcolor{comment}{// point prior list at copy}
255     \}
256   \textcolor{keywordflow}{return} found;
257 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 18




Here is the caller graph for this function\+:
% FIG 19




\subsection{Member Data Documentation}
\index{ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}!m\+\_\+next@{m\+\_\+next}}
\index{m\+\_\+next@{m\+\_\+next}!ns3\+::\+Packet\+Tag\+List@{ns3\+::\+Packet\+Tag\+List}}
\subsubsection[{\texorpdfstring{m\+\_\+next}{m_next}}]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf Tag\+Data}$\ast$ ns3\+::\+Packet\+Tag\+List\+::m\+\_\+next\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1PacketTagList_a69e3eca2ef2793ab142ecd2b2ede4ead}{}\label{classns3_1_1PacketTagList_a69e3eca2ef2793ab142ecd2b2ede4ead}
Pointer to first \hyperlink{structns3_1_1PacketTagList_1_1TagData}{Tag\+Data} on the list 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
network/model/\hyperlink{packet-tag-list_8h}{packet-\/tag-\/list.\+h}\item 
network/model/\hyperlink{packet-tag-list_8cc}{packet-\/tag-\/list.\+cc}\end{DoxyCompactItemize}
