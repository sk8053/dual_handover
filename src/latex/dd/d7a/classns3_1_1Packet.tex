\hypertarget{classns3_1_1Packet}{}\section{ns3\+:\+:Packet Class Reference}
\label{classns3_1_1Packet}\index{ns3\+::\+Packet@{ns3\+::\+Packet}}


network packets  




{\ttfamily \#include $<$packet.\+h$>$}



Inheritance diagram for ns3\+:\+:Packet\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Packet\+:
% FIG 1
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef void($\ast$ \hyperlink{classns3_1_1Packet_ac142a8ce0c096befb3f37ac21ebe1189}{Traced\+Callback}) (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet)
\item 
typedef void($\ast$ \hyperlink{classns3_1_1Packet_a42d0785b8ad6baeaa09ac86bd2452bad}{Address\+Traced\+Callback}) (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, const \hyperlink{classns3_1_1Address}{Address} \&address)
\item 
typedef void($\ast$ \hyperlink{classns3_1_1Packet_ab6f94bff1c9fa352a6d94ae1a431a750}{Mac48\+Address\+Traced\+Callback}) (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} mac)
\item 
typedef void($\ast$ \hyperlink{classns3_1_1Packet_ae4825786a08d3d0b6d376ac5961b8328}{Size\+Traced\+Callback}) (uint32\+\_\+t old\+Size, uint32\+\_\+t new\+Size)
\item 
typedef void($\ast$ \hyperlink{classns3_1_1Packet_ab8a596ff094dbac36dec56e566f9208d}{Sinr\+Traced\+Callback}) (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, double sinr)
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Packet_ac1a30f8cf28346960cfac4a2c9fa7026}{Packet} ()
\begin{DoxyCompactList}\small\item\em Create an empty packet with a new uid (as returned by get\+Uid). \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Packet_aa8b64449ccabad33e9e61c70e06db166}{Packet} (const \hyperlink{classns3_1_1Packet}{Packet} \&o)
\begin{DoxyCompactList}\small\item\em Copy constructor. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Packet}{Packet} \& \hyperlink{classns3_1_1Packet_a8f7627bc5113f3fa52ad68a20d57aa94}{operator=} (const \hyperlink{classns3_1_1Packet}{Packet} \&o)
\begin{DoxyCompactList}\small\item\em Basic assignment. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Packet_a897aab15901dcf1f05f075db7b8d04b1}{Packet} (uint32\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Create a packet with a zero-\/filled payload. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Packet_ab2d46939241156115411e66aa1a65f09}{Packet} (uint8\+\_\+t const $\ast$buffer, uint32\+\_\+t size, bool magic)
\begin{DoxyCompactList}\small\item\em Create a new packet from the serialized buffer. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Packet_a7f6a0314efee85ac6cf4a64e05450538}{Packet} (uint8\+\_\+t const $\ast$buffer, uint32\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Create a packet with payload filled with the content of this buffer. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{classns3_1_1Packet_a16f6113606b355b2b346e2245fa2a3d0}{Create\+Fragment} (uint32\+\_\+t start, uint32\+\_\+t length) const 
\begin{DoxyCompactList}\small\item\em Create a new packet which contains a fragment of the original packet. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{Get\+Size} (void) const 
\begin{DoxyCompactList}\small\item\em Returns the the size in bytes of the packet (including the zero-\/filled initial payload). \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Packet_a465108c595a0bc592095cbcab1832ed8}{Add\+Header} (const \hyperlink{classns3_1_1Header}{Header} \&header)
\begin{DoxyCompactList}\small\item\em Add header to this packet. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1Packet_a0961eccf975d75f902d40956c93ba63e}{Remove\+Header} (\hyperlink{classns3_1_1Header}{Header} \&header)
\begin{DoxyCompactList}\small\item\em Deserialize and remove the header from the internal buffer. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1Packet_aadc63487bea70945c418f4c3e9b81964}{Peek\+Header} (\hyperlink{classns3_1_1Header}{Header} \&header) const 
\begin{DoxyCompactList}\small\item\em Deserialize but does {\itshape not} remove the header from the internal buffer. s This method invokes \hyperlink{classns3_1_1Header_a78be9400bb66b2a8543606f395ef5396}{Header\+::\+Deserialize}. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Packet_ae26b490c30ae5bc98be5181ec6e06db8}{Add\+Trailer} (const \hyperlink{classns3_1_1Trailer}{Trailer} \&trailer)
\begin{DoxyCompactList}\small\item\em Add trailer to this packet. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1Packet_a2155e042083e9a17ad3b33f9fecb4be4}{Remove\+Trailer} (\hyperlink{classns3_1_1Trailer}{Trailer} \&trailer)
\begin{DoxyCompactList}\small\item\em Remove a deserialized trailer from the internal buffer. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1Packet_ace1fc287b3fc4fc12e72954e35342131}{Peek\+Trailer} (\hyperlink{classns3_1_1Trailer}{Trailer} \&trailer)
\begin{DoxyCompactList}\small\item\em Deserialize but does {\itshape not} remove a trailer from the internal buffer. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Packet_a14ec3d4250b425468764de58f5837b6b}{Add\+At\+End} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet)
\begin{DoxyCompactList}\small\item\em Concatenate the input packet at the end of the current packet. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Packet_ae964f1fcfd496c6c0db1b73f27e78530}{Add\+Padding\+At\+End} (uint32\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Add a zero-\/filled padding to the packet. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Packet_a607de6c1abda2a960e99a3b59fd35d14}{Remove\+At\+End} (uint32\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Remove size bytes from the end of the current packet. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Packet_a78aa207e7921dd2f9f7e0d0b7a1c730a}{Remove\+At\+Start} (uint32\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Remove size bytes from the start of the current packet. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1Packet_a5a6d304b9e0d90733919ffe224b98f0d}{Copy\+Data} (uint8\+\_\+t $\ast$buffer, uint32\+\_\+t size) const 
\begin{DoxyCompactList}\small\item\em Copy the packet contents to a byte buffer. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Packet_a62f6ad90367d0f86db3a5f39589c6897}{Copy\+Data} (std\+::ostream $\ast$os, uint32\+\_\+t size) const 
\begin{DoxyCompactList}\small\item\em Copy the packet contents to an output stream. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} (void) const 
\begin{DoxyCompactList}\small\item\em performs a C\+OW copy of the packet. \end{DoxyCompactList}\item 
uint64\+\_\+t \hyperlink{classns3_1_1Packet_a1f212c825b50e54d94f5b9ae99592e6a}{Get\+Uid} (void) const 
\begin{DoxyCompactList}\small\item\em Returns the packet\textquotesingle{}s Uid. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Packet_aa34058a5cdbf94673531f8c4001ab227}{Print} (std\+::ostream \&os) const 
\begin{DoxyCompactList}\small\item\em Print the packet contents. \end{DoxyCompactList}\item 
std\+::string \hyperlink{classns3_1_1Packet_a2474139f184f81df37f35b99efdc66f1}{To\+String} (void) const 
\begin{DoxyCompactList}\small\item\em Return a string representation of the packet. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1PacketMetadata_1_1ItemIterator}{Packet\+Metadata\+::\+Item\+Iterator} \hyperlink{classns3_1_1Packet_a0951ffaa12e116b03c4888085280501d}{Begin\+Item} (void) const 
\begin{DoxyCompactList}\small\item\em Returns an iterator which points to the first \textquotesingle{}item\textquotesingle{} stored in this buffer. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1Packet_a7416c3bc8c1a9a86c8ade4dfd1d67d2d}{Get\+Serialized\+Size} (void) const 
\begin{DoxyCompactList}\small\item\em Returns number of bytes required for packet serialization. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1Packet_a939e41b065c6f9f77d3f51373baeaf7e}{Serialize} (uint8\+\_\+t $\ast$buffer, uint32\+\_\+t max\+Size) const 
\begin{DoxyCompactList}\small\item\em Serialize a packet, tags, and metadata into a byte buffer. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Packet_ad5997caea8c22757acade2fcb4d7daca}{Add\+Byte\+Tag} (const \hyperlink{classns3_1_1Tag}{Tag} \&tag) const 
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Tag}{Tag} each byte included in this packet with a new byte tag. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1ByteTagIterator}{Byte\+Tag\+Iterator} \hyperlink{classns3_1_1Packet_a3c03f35c267e8534c29bdaa4686e4823}{Get\+Byte\+Tag\+Iterator} (void) const 
\begin{DoxyCompactList}\small\item\em Returns an iterator over the set of byte tags included in this packet. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Packet_a2e1403c2411495827012fe000823c16a}{Find\+First\+Matching\+Byte\+Tag} (\hyperlink{classns3_1_1Tag}{Tag} \&tag) const 
\begin{DoxyCompactList}\small\item\em Finds the first tag matching the parameter \hyperlink{classns3_1_1Tag}{Tag} type. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Packet_a083f54c9db31aeff30551a9e20fcda42}{Remove\+All\+Byte\+Tags} (void)
\begin{DoxyCompactList}\small\item\em Remove all byte tags stored in this packet. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Packet_af3766d81feb51b754cb036526c2f4366}{Print\+Byte\+Tags} (std\+::ostream \&os) const 
\begin{DoxyCompactList}\small\item\em Iterate over the byte tags present in this packet, and invoke the Print method of each tag stored in the packet. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Packet_a7400b8655852f5271c5957250d0141af}{Add\+Packet\+Tag} (const \hyperlink{classns3_1_1Tag}{Tag} \&tag) const 
\begin{DoxyCompactList}\small\item\em Add a packet tag. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Packet_a078fe922d976a417ab25ba2f3c2fd667}{Remove\+Packet\+Tag} (\hyperlink{classns3_1_1Tag}{Tag} \&tag)
\begin{DoxyCompactList}\small\item\em Remove a packet tag. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Packet_afb014ae9f4adddbfc51c64b085bfd405}{Replace\+Packet\+Tag} (\hyperlink{classns3_1_1Tag}{Tag} \&tag)
\begin{DoxyCompactList}\small\item\em Replace the value of a packet tag. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Packet_a1734de11f2ca1e78a7872461a0625168}{Peek\+Packet\+Tag} (\hyperlink{classns3_1_1Tag}{Tag} \&tag) const 
\begin{DoxyCompactList}\small\item\em Search a matching tag and call \hyperlink{classns3_1_1Tag_ae166b7f816bcbdef44dbeb636c9fa712}{Tag\+::\+Deserialize} if it is found. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Packet_a6c7bc5d1067c1d7fbd0fd70289182e8b}{Remove\+All\+Packet\+Tags} (void)
\begin{DoxyCompactList}\small\item\em Remove all packet tags. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Packet_a260fecda6a32bfc24e16a950e7d91559}{Print\+Packet\+Tags} (std\+::ostream \&os) const 
\begin{DoxyCompactList}\small\item\em Print the list of packet tags. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1PacketTagIterator}{Packet\+Tag\+Iterator} \hyperlink{classns3_1_1Packet_a9a06a61555a35fcad20638e6a7dfbeaa}{Get\+Packet\+Tag\+Iterator} (void) const 
\begin{DoxyCompactList}\small\item\em Returns an object which can be used to iterate over the list of packet tags. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Packet_a7e02c5b608a578c845aafd838f155989}{Set\+Nix\+Vector} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NixVector}{Nix\+Vector} $>$ nix\+Vector)
\begin{DoxyCompactList}\small\item\em Set the packet nix-\/vector. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NixVector}{Nix\+Vector} $>$ \hyperlink{classns3_1_1Packet_a3d68d7d2738678185315b59640848819}{Get\+Nix\+Vector} (void) const 
\begin{DoxyCompactList}\small\item\em Get the packet nix-\/vector. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static void \hyperlink{classns3_1_1Packet_ae17c0cd8e63e83df3c9273801e3d5d7f}{Enable\+Printing} (void)
\begin{DoxyCompactList}\small\item\em Enable printing packets metadata. \end{DoxyCompactList}\item 
static void \hyperlink{classns3_1_1Packet_abf6564e3496f2b8852774c98bd839b85}{Enable\+Checking} (void)
\begin{DoxyCompactList}\small\item\em Enable packets metadata checking. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Packet_aac8558f4df4ea72feeaa7556a9cb1708}{Packet} (const \hyperlink{classns3_1_1Buffer}{Buffer} \&buffer, const \hyperlink{classns3_1_1ByteTagList}{Byte\+Tag\+List} \&byte\+Tag\+List, const \hyperlink{classns3_1_1PacketTagList}{Packet\+Tag\+List} \&packet\+Tag\+List, const \hyperlink{classns3_1_1PacketMetadata}{Packet\+Metadata} \&metadata)
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1Packet_a196f5609e8b04efef405cab130612151}{Deserialize} (uint8\+\_\+t const $\ast$buffer, uint32\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Deserializes a packet. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Buffer}{Buffer} \hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\+\_\+buffer}
\begin{DoxyCompactList}\small\item\em the packet buffer (it\textquotesingle{}s actual contents) \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1ByteTagList}{Byte\+Tag\+List} \hyperlink{classns3_1_1Packet_a29e08c3cc4220a80366eea801c00e4ba}{m\+\_\+byte\+Tag\+List}
\begin{DoxyCompactList}\small\item\em the Byte\+Tag list \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1PacketTagList}{Packet\+Tag\+List} \hyperlink{classns3_1_1Packet_a7c91fc548c7cfddf27c176e13bd858ff}{m\+\_\+packet\+Tag\+List}
\begin{DoxyCompactList}\small\item\em the packet\textquotesingle{}s \hyperlink{classns3_1_1Tag}{Tag} list \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1PacketMetadata}{Packet\+Metadata} \hyperlink{classns3_1_1Packet_af3f95fba7966191bd152bcedd5fbcd6b}{m\+\_\+metadata}
\begin{DoxyCompactList}\small\item\em the packet\textquotesingle{}s metadata \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NixVector}{Nix\+Vector} $>$ \hyperlink{classns3_1_1Packet_af6fe17f2fb778ccd84af5c3c950ee4f4}{m\+\_\+nix\+Vector}
\begin{DoxyCompactList}\small\item\em the packet\textquotesingle{}s Nix vector \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Private Attributes}
\begin{DoxyCompactItemize}
\item 
static uint32\+\_\+t \hyperlink{classns3_1_1Packet_a4f707aab2b31689f8d1dadaed31e7c82}{m\+\_\+global\+Uid} = 0
\begin{DoxyCompactList}\small\item\em Global counter of packets Uid. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
network packets 

Each network packet contains a byte buffer, a set of byte tags, a set of packet tags, and metadata.


\begin{DoxyItemize}
\item The byte buffer stores the serialized content of the headers and trailers added to a packet. The serialized representation of these headers is expected to match that of real network packets bit for bit (although nothing forces you to do this) which means that the content of a packet buffer is expected to be that of a real packet.
\item The metadata describes the type of the headers and trailers which were serialized in the byte buffer. The maintenance of metadata is optional and disabled by default. To enable it, you must call \hyperlink{classns3_1_1Packet_ae17c0cd8e63e83df3c9273801e3d5d7f}{Packet\+::\+Enable\+Printing} and this will allow you to get non-\/empty output from \hyperlink{classns3_1_1Packet_aa34058a5cdbf94673531f8c4001ab227}{Packet\+::\+Print}. If you wish to only enable checking of metadata, and do not need any printing capability, you can call \hyperlink{classns3_1_1Packet_abf6564e3496f2b8852774c98bd839b85}{Packet\+::\+Enable\+Checking}\+: its runtime cost is lower than \hyperlink{classns3_1_1Packet_ae17c0cd8e63e83df3c9273801e3d5d7f}{Packet\+::\+Enable\+Printing}.
\item The set of tags contain simulation-\/specific information which cannot be stored in the packet byte buffer because the protocol headers or trailers have no standard-\/conformant field for this information. So-\/called \textquotesingle{}byte\textquotesingle{} tags are used to tag a subset of the bytes in the packet byte buffer while \textquotesingle{}packet\textquotesingle{} tags are used to tag the packet itself. The main difference between these two kinds of tags is what happens when packets are copied, fragmented, and reassembled\+: \textquotesingle{}byte\textquotesingle{} tags follow bytes while \textquotesingle{}packet\textquotesingle{} tags follow packets. Another important difference between these two kinds of tags is that byte tags cannot be removed and are expected to be written once, and read many times, while packet tags are expected to be written once, read many times, and removed exactly once. An example of a \textquotesingle{}byte\textquotesingle{} tag is a \hyperlink{classns3_1_1FlowIdTag}{Flow\+Id\+Tag} which contains a flow id and is set by the application generating traffic. An example of a \textquotesingle{}packet\textquotesingle{} tag is a cross-\/layer qos class id set by an application and processed by a lower-\/level M\+AC layer.
\end{DoxyItemize}

Implementing a new type of \hyperlink{classns3_1_1Header}{Header} or \hyperlink{classns3_1_1Trailer}{Trailer} for a new protocol is pretty easy and is a matter of creating a subclass of the \hyperlink{classns3_1_1Header}{ns3\+::\+Header} or of the \hyperlink{classns3_1_1Trailer}{ns3\+::\+Trailer} base class, and implementing the methods described in their respective A\+PI documentation.

Implementing a new type of \hyperlink{classns3_1_1Tag}{Tag} requires roughly the same amount of work and this work is described in the \hyperlink{classns3_1_1Tag}{ns3\+::\+Tag} A\+PI documentation.

The performance aspects copy-\/on-\/write semantics of the \hyperlink{classns3_1_1Packet}{Packet} A\+PI are discussed in \hyperlink{group__packetperf}{Packet Performance} 

\subsection{Member Typedef Documentation}
\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Address\+Traced\+Callback@{Address\+Traced\+Callback}}
\index{Address\+Traced\+Callback@{Address\+Traced\+Callback}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Address\+Traced\+Callback}{AddressTracedCallback}}]{\setlength{\rightskip}{0pt plus 5cm}typedef void($\ast$  ns3\+::\+Packet\+::\+Address\+Traced\+Callback) ({\bf Ptr}$<$ const {\bf Packet} $>$ packet, const {\bf Address} \&address)}\hypertarget{classns3_1_1Packet_a42d0785b8ad6baeaa09ac86bd2452bad}{}\label{classns3_1_1Packet_a42d0785b8ad6baeaa09ac86bd2452bad}
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback} signature for packet and \hyperlink{classns3_1_1Address}{Address}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em packet} & The packet. \\
\hline
\mbox{\tt in}  & {\em address} & The address. \\
\hline
\end{DoxyParams}
\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Mac48\+Address\+Traced\+Callback@{Mac48\+Address\+Traced\+Callback}}
\index{Mac48\+Address\+Traced\+Callback@{Mac48\+Address\+Traced\+Callback}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Mac48\+Address\+Traced\+Callback}{Mac48AddressTracedCallback}}]{\setlength{\rightskip}{0pt plus 5cm}typedef void($\ast$  ns3\+::\+Packet\+::\+Mac48\+Address\+Traced\+Callback) ({\bf Ptr}$<$ const {\bf Packet} $>$ packet, {\bf Mac48\+Address} mac)}\hypertarget{classns3_1_1Packet_ab6f94bff1c9fa352a6d94ae1a431a750}{}\label{classns3_1_1Packet_ab6f94bff1c9fa352a6d94ae1a431a750}
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback} signature for packet and \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em packet} & The packet. \\
\hline
\mbox{\tt in}  & {\em mac} & The \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address}. \\
\hline
\end{DoxyParams}
\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Sinr\+Traced\+Callback@{Sinr\+Traced\+Callback}}
\index{Sinr\+Traced\+Callback@{Sinr\+Traced\+Callback}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Sinr\+Traced\+Callback}{SinrTracedCallback}}]{\setlength{\rightskip}{0pt plus 5cm}typedef void($\ast$  ns3\+::\+Packet\+::\+Sinr\+Traced\+Callback) ({\bf Ptr}$<$ const {\bf Packet} $>$ packet, double sinr)}\hypertarget{classns3_1_1Packet_ab8a596ff094dbac36dec56e566f9208d}{}\label{classns3_1_1Packet_ab8a596ff094dbac36dec56e566f9208d}
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback} signature for packet and S\+I\+NR.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em packet} & The packet. \\
\hline
\mbox{\tt in}  & {\em sinr} & The received S\+I\+NR. \\
\hline
\end{DoxyParams}
\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Size\+Traced\+Callback@{Size\+Traced\+Callback}}
\index{Size\+Traced\+Callback@{Size\+Traced\+Callback}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Size\+Traced\+Callback}{SizeTracedCallback}}]{\setlength{\rightskip}{0pt plus 5cm}typedef void($\ast$  ns3\+::\+Packet\+::\+Size\+Traced\+Callback) (uint32\+\_\+t old\+Size, uint32\+\_\+t new\+Size)}\hypertarget{classns3_1_1Packet_ae4825786a08d3d0b6d376ac5961b8328}{}\label{classns3_1_1Packet_ae4825786a08d3d0b6d376ac5961b8328}
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback} signature for changes in packet size.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em old\+Size} & The previous packet\textquotesingle{}s size. \\
\hline
\mbox{\tt in}  & {\em new\+Size} & The actual packet\textquotesingle{}s size. \\
\hline
\end{DoxyParams}
\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Traced\+Callback@{Traced\+Callback}}
\index{Traced\+Callback@{Traced\+Callback}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Traced\+Callback}{TracedCallback}}]{\setlength{\rightskip}{0pt plus 5cm}typedef void($\ast$  ns3\+::\+Packet\+::\+Traced\+Callback) ({\bf Ptr}$<$ const {\bf Packet} $>$ packet)}\hypertarget{classns3_1_1Packet_ac142a8ce0c096befb3f37ac21ebe1189}{}\label{classns3_1_1Packet_ac142a8ce0c096befb3f37ac21ebe1189}
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback} signature for \hyperlink{classns3_1_1Ptr}{Ptr$<$\+Packet$>$}


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em packet} & The packet. \\
\hline
\end{DoxyParams}


\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Packet@{Packet}}
\index{Packet@{Packet}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Packet()}{Packet()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Packet\+::\+Packet (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Packet_ac1a30f8cf28346960cfac4a2c9fa7026}{}\label{classns3_1_1Packet_ac1a30f8cf28346960cfac4a2c9fa7026}


Create an empty packet with a new uid (as returned by get\+Uid). 


\begin{DoxyCode}
130   : \hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer} (),
131     \hyperlink{classns3_1_1Packet_a29e08c3cc4220a80366eea801c00e4ba}{m\_byteTagList} (),
132     \hyperlink{classns3_1_1Packet_a7c91fc548c7cfddf27c176e13bd858ff}{m\_packetTagList} (),
133     \textcolor{comment}{/* The upper 32 bits of the packet id in }
134 \textcolor{comment}{     * metadata is for the system id. For non-}
135 \textcolor{comment}{     * distributed simulations, this is simply }
136 \textcolor{comment}{     * zero.  The lower 32 bits are for the }
137 \textcolor{comment}{     * global UID}
138 \textcolor{comment}{     */}
139     \hyperlink{classns3_1_1Packet_af3f95fba7966191bd152bcedd5fbcd6b}{m\_metadata} (static\_cast<uint64\_t> (\hyperlink{classns3_1_1Simulator_ac956436096243081b306fe4d95040d42}{Simulator::GetSystemId} ()) << 32 | 
      \hyperlink{classns3_1_1Packet_a4f707aab2b31689f8d1dadaed31e7c82}{m\_globalUid}, 0),
140     \hyperlink{classns3_1_1Packet_af6fe17f2fb778ccd84af5c3c950ee4f4}{m\_nixVector} (0)
141 \{
142   \hyperlink{classns3_1_1Packet_a4f707aab2b31689f8d1dadaed31e7c82}{m\_globalUid}++;
143 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 2


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Packet@{Packet}}
\index{Packet@{Packet}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Packet(const Packet \&o)}{Packet(const Packet &o)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Packet\+::\+Packet (
\begin{DoxyParamCaption}
\item[{const {\bf Packet} \&}]{o}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Packet_aa8b64449ccabad33e9e61c70e06db166}{}\label{classns3_1_1Packet_aa8b64449ccabad33e9e61c70e06db166}


Copy constructor. 


\begin{DoxyParams}{Parameters}
{\em o} & object to copy \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
146   : \hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer} (o.m\_buffer),
147     \hyperlink{classns3_1_1Packet_a29e08c3cc4220a80366eea801c00e4ba}{m\_byteTagList} (o.m\_byteTagList),
148     \hyperlink{classns3_1_1Packet_a7c91fc548c7cfddf27c176e13bd858ff}{m\_packetTagList} (o.m\_packetTagList),
149     \hyperlink{classns3_1_1Packet_af3f95fba7966191bd152bcedd5fbcd6b}{m\_metadata} (o.m\_metadata)
150 \{
151   o.m\_nixVector ? \hyperlink{classns3_1_1Packet_af6fe17f2fb778ccd84af5c3c950ee4f4}{m\_nixVector} = o.m\_nixVector->Copy ()
152     : \hyperlink{classns3_1_1Packet_af6fe17f2fb778ccd84af5c3c950ee4f4}{m\_nixVector} = 0;
153 \}
\end{DoxyCode}
\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Packet@{Packet}}
\index{Packet@{Packet}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Packet(uint32\+\_\+t size)}{Packet(uint32_t size)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Packet\+::\+Packet (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{size}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Packet_a897aab15901dcf1f05f075db7b8d04b1}{}\label{classns3_1_1Packet_a897aab15901dcf1f05f075db7b8d04b1}


Create a packet with a zero-\/filled payload. 

The memory necessary for the payload is not allocated\+: it will be allocated at any later point if you attempt to fragment this packet or to access the zero-\/filled bytes. The packet is allocated with a new uid (as returned by get\+Uid).


\begin{DoxyParams}{Parameters}
{\em size} & the size of the zero-\/filled payload \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
172   : \hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer} (size),
173     \hyperlink{classns3_1_1Packet_a29e08c3cc4220a80366eea801c00e4ba}{m\_byteTagList} (),
174     \hyperlink{classns3_1_1Packet_a7c91fc548c7cfddf27c176e13bd858ff}{m\_packetTagList} (),
175     \textcolor{comment}{/* The upper 32 bits of the packet id in }
176 \textcolor{comment}{     * metadata is for the system id. For non-}
177 \textcolor{comment}{     * distributed simulations, this is simply }
178 \textcolor{comment}{     * zero.  The lower 32 bits are for the }
179 \textcolor{comment}{     * global UID}
180 \textcolor{comment}{     */}
181     \hyperlink{classns3_1_1Packet_af3f95fba7966191bd152bcedd5fbcd6b}{m\_metadata} (static\_cast<uint64\_t> (\hyperlink{classns3_1_1Simulator_ac956436096243081b306fe4d95040d42}{Simulator::GetSystemId} ()) << 32 | 
      \hyperlink{classns3_1_1Packet_a4f707aab2b31689f8d1dadaed31e7c82}{m\_globalUid}, size),
182     \hyperlink{classns3_1_1Packet_af6fe17f2fb778ccd84af5c3c950ee4f4}{m\_nixVector} (0)
183 \{
184   \hyperlink{classns3_1_1Packet_a4f707aab2b31689f8d1dadaed31e7c82}{m\_globalUid}++;
185 \}
\end{DoxyCode}
\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Packet@{Packet}}
\index{Packet@{Packet}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Packet(uint8\+\_\+t const $\ast$buffer, uint32\+\_\+t size, bool magic)}{Packet(uint8_t const *buffer, uint32_t size, bool magic)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Packet\+::\+Packet (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t const $\ast$}]{buffer, }
\item[{uint32\+\_\+t}]{size, }
\item[{bool}]{magic}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Packet_ab2d46939241156115411e66aa1a65f09}{}\label{classns3_1_1Packet_ab2d46939241156115411e66aa1a65f09}


Create a new packet from the serialized buffer. 

This new packet is identical to the serialized packet contained in the buffer and is magically deserialized for you


\begin{DoxyParams}{Parameters}
{\em buffer} & the serialized packet to be created \\
\hline
{\em size} & the size of the packet for deserialization \\
\hline
{\em magic} & allows packet deserialization; asserts when set to false \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
187   : \hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer} (0, \textcolor{keyword}{false}),
188     \hyperlink{classns3_1_1Packet_a29e08c3cc4220a80366eea801c00e4ba}{m\_byteTagList} (),
189     \hyperlink{classns3_1_1Packet_a7c91fc548c7cfddf27c176e13bd858ff}{m\_packetTagList} (),
190     \hyperlink{classns3_1_1Packet_af3f95fba7966191bd152bcedd5fbcd6b}{m\_metadata} (0,0),
191     \hyperlink{classns3_1_1Packet_af6fe17f2fb778ccd84af5c3c950ee4f4}{m\_nixVector} (0)
192 \{
193   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (magic);
194   \hyperlink{classns3_1_1Packet_a196f5609e8b04efef405cab130612151}{Deserialize} (buffer, size);
195 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Packet@{Packet}}
\index{Packet@{Packet}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Packet(uint8\+\_\+t const $\ast$buffer, uint32\+\_\+t size)}{Packet(uint8_t const *buffer, uint32_t size)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Packet\+::\+Packet (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t const $\ast$}]{buffer, }
\item[{uint32\+\_\+t}]{size}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Packet_a7f6a0314efee85ac6cf4a64e05450538}{}\label{classns3_1_1Packet_a7f6a0314efee85ac6cf4a64e05450538}


Create a packet with payload filled with the content of this buffer. 

The input data is copied\+: the input buffer is untouched.


\begin{DoxyParams}{Parameters}
{\em buffer} & the data to store in the packet. \\
\hline
{\em size} & the size of the input buffer. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
198   : \hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer} (),
199     \hyperlink{classns3_1_1Packet_a29e08c3cc4220a80366eea801c00e4ba}{m\_byteTagList} (),
200     \hyperlink{classns3_1_1Packet_a7c91fc548c7cfddf27c176e13bd858ff}{m\_packetTagList} (),
201     \textcolor{comment}{/* The upper 32 bits of the packet id in }
202 \textcolor{comment}{     * metadata is for the system id. For non-}
203 \textcolor{comment}{     * distributed simulations, this is simply }
204 \textcolor{comment}{     * zero.  The lower 32 bits are for the }
205 \textcolor{comment}{     * global UID}
206 \textcolor{comment}{     */}
207     \hyperlink{classns3_1_1Packet_af3f95fba7966191bd152bcedd5fbcd6b}{m\_metadata} (static\_cast<uint64\_t> (\hyperlink{classns3_1_1Simulator_ac956436096243081b306fe4d95040d42}{Simulator::GetSystemId} ()) << 32 | 
      \hyperlink{classns3_1_1Packet_a4f707aab2b31689f8d1dadaed31e7c82}{m\_globalUid}, size),
208     \hyperlink{classns3_1_1Packet_af6fe17f2fb778ccd84af5c3c950ee4f4}{m\_nixVector} (0)
209 \{
210   \hyperlink{classns3_1_1Packet_a4f707aab2b31689f8d1dadaed31e7c82}{m\_globalUid}++;
211   \hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer}.\hyperlink{classns3_1_1Buffer_a8abd8164c3671d3dadc98fc66fade7b1}{AddAtStart} (size);
212   Buffer::Iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer}.\hyperlink{classns3_1_1Buffer_a893d4bf50df13e730b6cd0fda91b967f}{Begin} ();
213   i.\hyperlink{classns3_1_1Buffer_1_1Iterator_a087b4e6b5d038544c750c741e8932d69}{Write} (buffer, size);
214 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Packet@{Packet}}
\index{Packet@{Packet}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Packet(const Buffer \&buffer, const Byte\+Tag\+List \&byte\+Tag\+List, const Packet\+Tag\+List \&packet\+Tag\+List, const Packet\+Metadata \&metadata)}{Packet(const Buffer &buffer, const ByteTagList &byteTagList, const PacketTagList &packetTagList, const PacketMetadata &metadata)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Packet\+::\+Packet (
\begin{DoxyParamCaption}
\item[{const {\bf Buffer} \&}]{buffer, }
\item[{const {\bf Byte\+Tag\+List} \&}]{byte\+Tag\+List, }
\item[{const {\bf Packet\+Tag\+List} \&}]{packet\+Tag\+List, }
\item[{const {\bf Packet\+Metadata} \&}]{metadata}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Packet_aac8558f4df4ea72feeaa7556a9cb1708}{}\label{classns3_1_1Packet_aac8558f4df4ea72feeaa7556a9cb1708}


Constructor. 


\begin{DoxyParams}{Parameters}
{\em buffer} & the packet buffer \\
\hline
{\em byte\+Tag\+List} & the Byte\+Tag list \\
\hline
{\em packet\+Tag\+List} & the packet\textquotesingle{}s \hyperlink{classns3_1_1Tag}{Tag} list \\
\hline
{\em metadata} & the packet\textquotesingle{}s metadata \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
218   : \hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer} (buffer),
219     \hyperlink{classns3_1_1Packet_a29e08c3cc4220a80366eea801c00e4ba}{m\_byteTagList} (byteTagList),
220     \hyperlink{classns3_1_1Packet_a7c91fc548c7cfddf27c176e13bd858ff}{m\_packetTagList} (packetTagList),
221     \hyperlink{classns3_1_1Packet_af3f95fba7966191bd152bcedd5fbcd6b}{m\_metadata} (metadata),
222     \hyperlink{classns3_1_1Packet_af6fe17f2fb778ccd84af5c3c950ee4f4}{m\_nixVector} (0)
223 \{
224 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Add\+At\+End@{Add\+At\+End}}
\index{Add\+At\+End@{Add\+At\+End}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Add\+At\+End(\+Ptr$<$ const Packet $>$ packet)}{AddAtEnd(Ptr< const Packet > packet)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Packet\+::\+Add\+At\+End (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{packet}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Packet_a14ec3d4250b425468764de58f5837b6b}{}\label{classns3_1_1Packet_a14ec3d4250b425468764de58f5837b6b}


Concatenate the input packet at the end of the current packet. 

This does not alter the uid of either packet.


\begin{DoxyParams}{Parameters}
{\em packet} & packet to concatenate \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
313 \{
314   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << packet->GetSize ());
315   \hyperlink{classns3_1_1Packet_a29e08c3cc4220a80366eea801c00e4ba}{m\_byteTagList}.\hyperlink{classns3_1_1ByteTagList_a0d8aa9cf6aaf856eb08d4f4a01f38446}{AddAtEnd} (\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ());
316   ByteTagList copy = packet->m\_byteTagList;
317   copy.AddAtStart (0);
318   copy.Adjust (\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ());
319   \hyperlink{classns3_1_1Packet_a29e08c3cc4220a80366eea801c00e4ba}{m\_byteTagList}.\hyperlink{classns3_1_1ByteTagList_ac970192e923afc561a304d17af4b8a52}{Add} (copy);
320   \hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer}.\hyperlink{classns3_1_1Buffer_a92dd87809af24fb10696fee9a9cb56cf}{AddAtEnd} (packet->m\_buffer);
321   \hyperlink{classns3_1_1Packet_af3f95fba7966191bd152bcedd5fbcd6b}{m\_metadata}.\hyperlink{classns3_1_1PacketMetadata_af7ceb1a4a7ded625c85dbd477b5fc8b6}{AddAtEnd} (packet->m\_metadata);
322 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5




Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Add\+Byte\+Tag@{Add\+Byte\+Tag}}
\index{Add\+Byte\+Tag@{Add\+Byte\+Tag}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Add\+Byte\+Tag(const Tag \&tag) const }{AddByteTag(const Tag &tag) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Packet\+::\+Add\+Byte\+Tag (
\begin{DoxyParamCaption}
\item[{const {\bf Tag} \&}]{tag}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Packet_ad5997caea8c22757acade2fcb4d7daca}{}\label{classns3_1_1Packet_ad5997caea8c22757acade2fcb4d7daca}


\hyperlink{classns3_1_1Tag}{Tag} each byte included in this packet with a new byte tag. 


\begin{DoxyParams}{Parameters}
{\em tag} & the new tag to add to this packet\\
\hline
\end{DoxyParams}
Note that adding a tag is a const operation which is pretty un-\/intuitive. The rationale is that the content and behavior of a packet is {\itshape not} changed when a tag is added to a packet\+: any code which was not aware of the new tag is going to work just the same if the new tag is added. The real reason why adding a tag was made a const operation is to allow a trace sink which gets a packet to tag the packet, even if the packet is const (and most trace sources should use const packets because it would be totally evil to allow a trace sink to modify the content of a packet). 
\begin{DoxyCode}
782 \{
783   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << tag.GetInstanceTypeId ().GetName () << tag.GetSerializedSize ());
784   ByteTagList *\hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{list} = \textcolor{keyword}{const\_cast<}ByteTagList *\textcolor{keyword}{>} (&\hyperlink{classns3_1_1Packet_a29e08c3cc4220a80366eea801c00e4ba}{m\_byteTagList});
785   TagBuffer buffer = list->Add (tag.GetInstanceTypeId (), tag.GetSerializedSize (), 
786                                 0,
787                                 \hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ());
788   tag.Serialize (buffer);
789 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7




Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Add\+Header@{Add\+Header}}
\index{Add\+Header@{Add\+Header}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Add\+Header(const Header \&header)}{AddHeader(const Header &header)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Packet\+::\+Add\+Header (
\begin{DoxyParamCaption}
\item[{const {\bf Header} \&}]{header}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Packet_a465108c595a0bc592095cbcab1832ed8}{}\label{classns3_1_1Packet_a465108c595a0bc592095cbcab1832ed8}


Add header to this packet. 

This method invokes the \hyperlink{classns3_1_1Header_a6ef0497eabc1b1fb0ad42738eb73f934}{Header\+::\+Get\+Serialized\+Size} and \hyperlink{classns3_1_1Header_afb61f1aac69ff8349a6bfe521fab5404}{Header\+::\+Serialize} methods to reserve space in the buffer and request the header to serialize itself in the packet buffer.


\begin{DoxyParams}{Parameters}
{\em header} & a reference to the header to add to this packet. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
257 \{
258   uint32\_t size = header.GetSerializedSize ();
259   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << header.GetInstanceTypeId ().GetName () << size);
260   \hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer}.\hyperlink{classns3_1_1Buffer_a8abd8164c3671d3dadc98fc66fade7b1}{AddAtStart} (size);
261   \hyperlink{classns3_1_1Packet_a29e08c3cc4220a80366eea801c00e4ba}{m\_byteTagList}.\hyperlink{classns3_1_1ByteTagList_a1fec06d7e6daaf8039cf2a148e4090f2}{Adjust} (size);
262   \hyperlink{classns3_1_1Packet_a29e08c3cc4220a80366eea801c00e4ba}{m\_byteTagList}.\hyperlink{classns3_1_1ByteTagList_acb4563fbe4299c55af41ba7a166b71d5}{AddAtStart} (size);
263   header.Serialize (\hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer}.\hyperlink{classns3_1_1Buffer_a893d4bf50df13e730b6cd0fda91b967f}{Begin} ());
264   \hyperlink{classns3_1_1Packet_af3f95fba7966191bd152bcedd5fbcd6b}{m\_metadata}.\hyperlink{classns3_1_1PacketMetadata_abdce736c4c5f647242f0808c0d2f9249}{AddHeader} (header, size);
265 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Add\+Packet\+Tag@{Add\+Packet\+Tag}}
\index{Add\+Packet\+Tag@{Add\+Packet\+Tag}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Add\+Packet\+Tag(const Tag \&tag) const }{AddPacketTag(const Tag &tag) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Packet\+::\+Add\+Packet\+Tag (
\begin{DoxyParamCaption}
\item[{const {\bf Tag} \&}]{tag}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Packet_a7400b8655852f5271c5957250d0141af}{}\label{classns3_1_1Packet_a7400b8655852f5271c5957250d0141af}


Add a packet tag. 


\begin{DoxyParams}{Parameters}
{\em tag} & the packet tag type to add.\\
\hline
\end{DoxyParams}
Note that this method is const, that is, it does not modify the state of this packet, which is fairly un-\/intuitive. See Add\+Byte\+Tag\char`\"{}()\char`\"{} discussion. 
\begin{DoxyCode}
815 \{
816   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << tag.GetInstanceTypeId ().GetName () << tag.GetSerializedSize ());
817   \hyperlink{classns3_1_1Packet_a7c91fc548c7cfddf27c176e13bd858ff}{m\_packetTagList}.\hyperlink{classns3_1_1PacketTagList_a37f008b6f336f3ac6232d558b93e8a6e}{Add} (tag);
818 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10




Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Add\+Padding\+At\+End@{Add\+Padding\+At\+End}}
\index{Add\+Padding\+At\+End@{Add\+Padding\+At\+End}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Add\+Padding\+At\+End(uint32\+\_\+t size)}{AddPaddingAtEnd(uint32_t size)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Packet\+::\+Add\+Padding\+At\+End (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{size}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Packet_ae964f1fcfd496c6c0db1b73f27e78530}{}\label{classns3_1_1Packet_ae964f1fcfd496c6c0db1b73f27e78530}


Add a zero-\/filled padding to the packet. 


\begin{DoxyParams}{Parameters}
{\em size} & number of padding bytes to add. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
325 \{
326   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << size);
327   \hyperlink{classns3_1_1Packet_a29e08c3cc4220a80366eea801c00e4ba}{m\_byteTagList}.\hyperlink{classns3_1_1ByteTagList_a0d8aa9cf6aaf856eb08d4f4a01f38446}{AddAtEnd} (\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ());
328   \hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer}.\hyperlink{classns3_1_1Buffer_a92dd87809af24fb10696fee9a9cb56cf}{AddAtEnd} (size);
329   \hyperlink{classns3_1_1Packet_af3f95fba7966191bd152bcedd5fbcd6b}{m\_metadata}.\hyperlink{classns3_1_1PacketMetadata_a9398445226b4df97e2d489cf0a431ace}{AddPaddingAtEnd} (size);
330 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12




Here is the caller graph for this function\+:
% FIG 13


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Add\+Trailer@{Add\+Trailer}}
\index{Add\+Trailer@{Add\+Trailer}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Add\+Trailer(const Trailer \&trailer)}{AddTrailer(const Trailer &trailer)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Packet\+::\+Add\+Trailer (
\begin{DoxyParamCaption}
\item[{const {\bf Trailer} \&}]{trailer}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Packet_ae26b490c30ae5bc98be5181ec6e06db8}{}\label{classns3_1_1Packet_ae26b490c30ae5bc98be5181ec6e06db8}


Add trailer to this packet. 

This method invokes the \hyperlink{classns3_1_1Trailer_a6af7be196bad576c3601e267b0637ff7}{Trailer\+::\+Get\+Serialized\+Size} and \hyperlink{classns3_1_1Trailer_a160451b2ded3a615b1ccfa25ab60c2e3}{Trailer\+::\+Serialize} methods to reserve space in the buffer and request the trailer to serialize itself in the packet buffer.


\begin{DoxyParams}{Parameters}
{\em trailer} & a reference to the trailer to add to this packet. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
285 \{
286   uint32\_t size = trailer.GetSerializedSize ();
287   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << trailer.GetInstanceTypeId ().GetName () << size);
288   \hyperlink{classns3_1_1Packet_a29e08c3cc4220a80366eea801c00e4ba}{m\_byteTagList}.\hyperlink{classns3_1_1ByteTagList_a0d8aa9cf6aaf856eb08d4f4a01f38446}{AddAtEnd} (\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ());
289   \hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer}.\hyperlink{classns3_1_1Buffer_a92dd87809af24fb10696fee9a9cb56cf}{AddAtEnd} (size);
290   Buffer::Iterator end = \hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer}.\hyperlink{classns3_1_1Buffer_a52207c7aed7bae89fba2f9e997c82724}{End} ();
291   trailer.Serialize (end);
292   \hyperlink{classns3_1_1Packet_af3f95fba7966191bd152bcedd5fbcd6b}{m\_metadata}.\hyperlink{classns3_1_1PacketMetadata_afd698b5f0ce0e9f498fff8a6915837c5}{AddTrailer} (trailer, size);
293 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 14




Here is the caller graph for this function\+:
% FIG 15


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Begin\+Item@{Begin\+Item}}
\index{Begin\+Item@{Begin\+Item}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Begin\+Item(void) const }{BeginItem(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Packet\+Metadata\+::\+Item\+Iterator} ns3\+::\+Packet\+::\+Begin\+Item (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Packet_a0951ffaa12e116b03c4888085280501d}{}\label{classns3_1_1Packet_a0951ffaa12e116b03c4888085280501d}


Returns an iterator which points to the first \textquotesingle{}item\textquotesingle{} stored in this buffer. 

Note that this iterator will point to an empty array of items if you don\textquotesingle{}t call Enable\+Printing or Enable\+Checking before.

\begin{DoxyReturn}{Returns}
an iterator
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Packet_ae17c0cd8e63e83df3c9273801e3d5d7f}{Enable\+Printing} \hyperlink{classns3_1_1Packet_abf6564e3496f2b8852774c98bd839b85}{Enable\+Checking} 
\end{DoxySeeAlso}

\begin{DoxyCode}
529 \{
530   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Packet_af3f95fba7966191bd152bcedd5fbcd6b}{m\_metadata}.\hyperlink{classns3_1_1PacketMetadata_aa574c0500da92d42d3cb53ae8a9fd0ad}{BeginItem} (\hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer});
531 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 16




Here is the caller graph for this function\+:
% FIG 17


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Copy@{Copy}}
\index{Copy@{Copy}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Copy(void) const }{Copy(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Packet} $>$ ns3\+::\+Packet\+::\+Copy (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{}\label{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}


performs a C\+OW copy of the packet. 

\begin{DoxyReturn}{Returns}
a C\+OW copy of the packet.
\end{DoxyReturn}
The returns packet will behave like an independent copy of the original packet, even though they both share the same datasets internally. 
\begin{DoxyCode}
122 \{
123   \textcolor{comment}{// we need to invoke the copy constructor directly}
124   \textcolor{comment}{// rather than calling Create because the copy constructor}
125   \textcolor{comment}{// is private.}
126   \textcolor{keywordflow}{return} Ptr<Packet> (\textcolor{keyword}{new} \hyperlink{classns3_1_1Packet_ac1a30f8cf28346960cfac4a2c9fa7026}{Packet} (*\textcolor{keyword}{this}), \textcolor{keyword}{false});
127 \}
\end{DoxyCode}
\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Copy\+Data@{Copy\+Data}}
\index{Copy\+Data@{Copy\+Data}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Copy\+Data(uint8\+\_\+t $\ast$buffer, uint32\+\_\+t size) const }{CopyData(uint8_t *buffer, uint32_t size) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Packet\+::\+Copy\+Data (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$}]{buffer, }
\item[{uint32\+\_\+t}]{size}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Packet_a5a6d304b9e0d90733919ffe224b98f0d}{}\label{classns3_1_1Packet_a5a6d304b9e0d90733919ffe224b98f0d}


Copy the packet contents to a byte buffer. 


\begin{DoxyParams}{Parameters}
{\em buffer} & a pointer to a byte buffer where the packet data should be copied. \\
\hline
{\em size} & the size of the byte buffer. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of bytes read from the packet
\end{DoxyReturn}
No more than {\bfseries size} bytes will be copied by this function. 
\begin{DoxyCode}
356 \{
357   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer}.\hyperlink{classns3_1_1Buffer_aec4a3fd349f94e449b4b2d14dd964a4c}{CopyData} (buffer, size);
358 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 18




Here is the caller graph for this function\+:
% FIG 19


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Copy\+Data@{Copy\+Data}}
\index{Copy\+Data@{Copy\+Data}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Copy\+Data(std\+::ostream $\ast$os, uint32\+\_\+t size) const }{CopyData(std::ostream *os, uint32_t size) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Packet\+::\+Copy\+Data (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{os, }
\item[{uint32\+\_\+t}]{size}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Packet_a62f6ad90367d0f86db3a5f39589c6897}{}\label{classns3_1_1Packet_a62f6ad90367d0f86db3a5f39589c6897}


Copy the packet contents to an output stream. 


\begin{DoxyParams}{Parameters}
{\em os} & pointer to output stream in which we want to write the packet data. \\
\hline
{\em size} & the maximum number of bytes we want to write in the output stream. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
362 \{
363   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer}.\hyperlink{classns3_1_1Buffer_aec4a3fd349f94e449b4b2d14dd964a4c}{CopyData} (os, size);
364 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 20


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Create\+Fragment@{Create\+Fragment}}
\index{Create\+Fragment@{Create\+Fragment}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Create\+Fragment(uint32\+\_\+t start, uint32\+\_\+t length) const }{CreateFragment(uint32_t start, uint32_t length) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Packet} $>$ ns3\+::\+Packet\+::\+Create\+Fragment (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{start, }
\item[{uint32\+\_\+t}]{length}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Packet_a16f6113606b355b2b346e2245fa2a3d0}{}\label{classns3_1_1Packet_a16f6113606b355b2b346e2245fa2a3d0}


Create a new packet which contains a fragment of the original packet. 

The returned packet shares the same uid as this packet.


\begin{DoxyParams}{Parameters}
{\em start} & offset from start of packet to start of fragment to create \\
\hline
{\em length} & length of fragment to create \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a fragment of the original packet 
\end{DoxyReturn}

\begin{DoxyCode}
228 \{
229   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{namespacevisualizer_1_1core_a2a35e5d8a34af358b508dac8635754e0}{start} << length);
230   Buffer buffer = \hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer}.\hyperlink{classns3_1_1Buffer_a9285016f38b451c65edb50196ef817f8}{CreateFragment} (\hyperlink{namespacevisualizer_1_1core_a2a35e5d8a34af358b508dac8635754e0}{start}, length);
231   ByteTagList byteTagList = \hyperlink{classns3_1_1Packet_a29e08c3cc4220a80366eea801c00e4ba}{m\_byteTagList};
232   byteTagList.\hyperlink{classns3_1_1ByteTagList_a1fec06d7e6daaf8039cf2a148e4090f2}{Adjust} (-\hyperlink{namespacevisualizer_1_1core_a2a35e5d8a34af358b508dac8635754e0}{start});
233   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer}.\hyperlink{classns3_1_1Buffer_a3047b8f2dad303c6370695122f1884f0}{GetSize} () >= \hyperlink{namespacevisualizer_1_1core_a2a35e5d8a34af358b508dac8635754e0}{start} + length);
234   uint32\_t end = \hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer}.\hyperlink{classns3_1_1Buffer_a3047b8f2dad303c6370695122f1884f0}{GetSize} () - (\hyperlink{namespacevisualizer_1_1core_a2a35e5d8a34af358b508dac8635754e0}{start} + length);
235   PacketMetadata metadata = \hyperlink{classns3_1_1Packet_af3f95fba7966191bd152bcedd5fbcd6b}{m\_metadata}.\hyperlink{classns3_1_1PacketMetadata_a0c4fe43ab63b49432451c37263826d67}{CreateFragment} (
      \hyperlink{namespacevisualizer_1_1core_a2a35e5d8a34af358b508dac8635754e0}{start}, end);
236   \textcolor{comment}{// again, call the constructor directly rather than}
237   \textcolor{comment}{// through Create because it is private.}
238   Ptr<Packet> ret = Ptr<Packet> (\textcolor{keyword}{new} \hyperlink{classns3_1_1Packet_ac1a30f8cf28346960cfac4a2c9fa7026}{Packet} (buffer, byteTagList, 
      \hyperlink{classns3_1_1Packet_a7c91fc548c7cfddf27c176e13bd858ff}{m\_packetTagList}, metadata), \textcolor{keyword}{false});
239   ret->SetNixVector (\hyperlink{classns3_1_1Packet_a3d68d7d2738678185315b59640848819}{GetNixVector} ());
240   \textcolor{keywordflow}{return} ret;
241 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 21




Here is the caller graph for this function\+:
% FIG 22


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Deserialize@{Deserialize}}
\index{Deserialize@{Deserialize}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Deserialize(uint8\+\_\+t const $\ast$buffer, uint32\+\_\+t size)}{Deserialize(uint8_t const *buffer, uint32_t size)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Packet\+::\+Deserialize (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t const $\ast$}]{buffer, }
\item[{uint32\+\_\+t}]{size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Packet_a196f5609e8b04efef405cab130612151}{}\label{classns3_1_1Packet_a196f5609e8b04efef405cab130612151}


Deserializes a packet. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em buffer} & the input buffer. \\
\hline
\mbox{\tt in}  & {\em size} & the buffer size. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of deserialized bytes. 
\end{DoxyReturn}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000147}{Todo}]Deserialize Tags \end{DoxyRefDesc}

\begin{DoxyCode}
700 \{
701   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
702 
703   \textcolor{keyword}{const} uint32\_t* \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }uint32\_t *\textcolor{keyword}{>} (buffer);
704 
705   \textcolor{comment}{// read nix-vector}
706   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (!\hyperlink{classns3_1_1Packet_af6fe17f2fb778ccd84af5c3c950ee4f4}{m\_nixVector});
707   uint32\_t nixSize = *p++;
708 
709   \textcolor{comment}{// if size less than nixSize, the buffer }
710   \textcolor{comment}{// will be overrun, assert}
711   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (size >= nixSize);
712 
713   size -= nixSize;
714 
715   \textcolor{keywordflow}{if} (nixSize > 4)
716     \{
717       Ptr<NixVector> nix = Create<NixVector> ();
718       uint32\_t nixDeserialized = nix->Deserialize (p, nixSize);
719       \textcolor{keywordflow}{if} (!nixDeserialized)
720         \{
721           \textcolor{comment}{// nix-vector not deserialized}
722           \textcolor{comment}{// completely}
723           \textcolor{keywordflow}{return} 0;
724         \}
725       \hyperlink{classns3_1_1Packet_af6fe17f2fb778ccd84af5c3c950ee4f4}{m\_nixVector} = nix;
726       \textcolor{comment}{// increment p by nixSize ensuring}
727       \textcolor{comment}{// 4-byte boundary}
728       p += ((((nixSize - 4) + 3) & (~3)) / 4);
729     \}
730 
731   \textcolor{comment}{// read tags}
733 \textcolor{comment}{}  \textcolor{comment}{//uint32\_t tagsDeserialized = m\_tags.Deserialize (buffer.Begin ());}
734   \textcolor{comment}{//buffer.RemoveAtStart (tagsDeserialized);}
735 
736   \textcolor{comment}{// read metadata}
737   uint32\_t metaSize = *p++;
738 
739   \textcolor{comment}{// if size less than metaSize, the buffer }
740   \textcolor{comment}{// will be overrun, assert}
741   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (size >= metaSize);
742 
743   size -= metaSize;
744 
745   uint32\_t metadataDeserialized = 
746     \hyperlink{classns3_1_1Packet_af3f95fba7966191bd152bcedd5fbcd6b}{m\_metadata}.\hyperlink{classns3_1_1PacketMetadata_a88efb0a5ff0339b9430ded4e3452397d}{Deserialize} (reinterpret\_cast<const uint8\_t *> (p), metaSize);
747   \textcolor{keywordflow}{if} (!metadataDeserialized)
748     \{
749       \textcolor{comment}{// meta-data not deserialized }
750       \textcolor{comment}{// completely}
751       \textcolor{keywordflow}{return} 0;
752     \}
753   \textcolor{comment}{// increment p by metaSize ensuring }
754   \textcolor{comment}{// 4-byte boundary}
755   p += ((((metaSize - 4) + 3) & (~3)) / 4);
756 
757   \textcolor{comment}{// read buffer contents}
758   uint32\_t bufSize = *p++;
759 
760   \textcolor{comment}{// if size less than bufSize, the buffer }
761   \textcolor{comment}{// will be overrun, assert}
762   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (size >= bufSize);
763 
764   size -= bufSize;
765 
766   uint32\_t bufferDeserialized =
767     \hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer}.\hyperlink{classns3_1_1Buffer_add89f12664174aa29c08264af66437ad}{Deserialize} (reinterpret\_cast<const uint8\_t *> (p), bufSize);
768   \textcolor{keywordflow}{if} (!bufferDeserialized)
769     \{
770       \textcolor{comment}{// buffer not deserialized }
771       \textcolor{comment}{// completely}
772       \textcolor{keywordflow}{return} 0;
773     \}
774 
775   \textcolor{comment}{// return zero if did not deserialize the }
776   \textcolor{comment}{// number of expected bytes}
777   \textcolor{keywordflow}{return} (size == 0);
778 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 23




Here is the caller graph for this function\+:
% FIG 24


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Enable\+Checking@{Enable\+Checking}}
\index{Enable\+Checking@{Enable\+Checking}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Enable\+Checking(void)}{EnableChecking(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Packet\+::\+Enable\+Checking (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Packet_abf6564e3496f2b8852774c98bd839b85}{}\label{classns3_1_1Packet_abf6564e3496f2b8852774c98bd839b85}


Enable packets metadata checking. 

The packet metadata is also used to perform extensive sanity checks at runtime when performing operations on a \hyperlink{classns3_1_1Packet}{Packet}. For example, this metadata is used to verify that when you remove a header from a packet, this same header was actually present at the front of the packet. These errors will be detected and will abort the program. 
\begin{DoxyCode}
542 \{
543   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
544   \hyperlink{classns3_1_1PacketMetadata_a5bb19e2208a6a0573cdc79c3959ac6b4}{PacketMetadata::EnableChecking} ();
545 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 25




Here is the caller graph for this function\+:
% FIG 26


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Enable\+Printing@{Enable\+Printing}}
\index{Enable\+Printing@{Enable\+Printing}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Enable\+Printing(void)}{EnablePrinting(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Packet\+::\+Enable\+Printing (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Packet_ae17c0cd8e63e83df3c9273801e3d5d7f}{}\label{classns3_1_1Packet_ae17c0cd8e63e83df3c9273801e3d5d7f}


Enable printing packets metadata. 

By default, packets do not keep around enough metadata to perform the operations requested by the Print methods. If you want to be able the \hyperlink{classns3_1_1Packet_aa34058a5cdbf94673531f8c4001ab227}{Packet\+::\+Print} method, you need to invoke this method at least once during the simulation setup and before any packet is created. 
\begin{DoxyCode}
535 \{
536   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
537   \hyperlink{classns3_1_1PacketMetadata_addee67896039c1a356ee47698b04e953}{PacketMetadata::Enable} ();
538 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 27




Here is the caller graph for this function\+:
% FIG 28


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Find\+First\+Matching\+Byte\+Tag@{Find\+First\+Matching\+Byte\+Tag}}
\index{Find\+First\+Matching\+Byte\+Tag@{Find\+First\+Matching\+Byte\+Tag}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Find\+First\+Matching\+Byte\+Tag(\+Tag \&tag) const }{FindFirstMatchingByteTag(Tag &tag) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Packet\+::\+Find\+First\+Matching\+Byte\+Tag (
\begin{DoxyParamCaption}
\item[{{\bf Tag} \&}]{tag}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Packet_a2e1403c2411495827012fe000823c16a}{}\label{classns3_1_1Packet_a2e1403c2411495827012fe000823c16a}


Finds the first tag matching the parameter \hyperlink{classns3_1_1Tag}{Tag} type. 


\begin{DoxyParams}{Parameters}
{\em tag} & the byte tag type to search in this packet \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the requested tag type was found, false otherwise.
\end{DoxyReturn}
If the requested tag type is found, it is copied in the user\textquotesingle{}s provided tag instance. 
\begin{DoxyCode}
798 \{
799   TypeId tid = tag.GetInstanceTypeId ();
800   ByteTagIterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Packet_a3c03f35c267e8534c29bdaa4686e4823}{GetByteTagIterator} ();
801   \textcolor{keywordflow}{while} (i.HasNext ())
802     \{
803       ByteTagIterator::Item item = i.Next ();
804       \textcolor{keywordflow}{if} (tid == item.GetTypeId ())
805         \{
806           item.GetTag (tag);
807           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
808         \}
809     \}
810   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
811 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 29




Here is the caller graph for this function\+:
% FIG 30


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Get\+Byte\+Tag\+Iterator@{Get\+Byte\+Tag\+Iterator}}
\index{Get\+Byte\+Tag\+Iterator@{Get\+Byte\+Tag\+Iterator}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Get\+Byte\+Tag\+Iterator(void) const }{GetByteTagIterator(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Byte\+Tag\+Iterator} ns3\+::\+Packet\+::\+Get\+Byte\+Tag\+Iterator (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Packet_a3c03f35c267e8534c29bdaa4686e4823}{}\label{classns3_1_1Packet_a3c03f35c267e8534c29bdaa4686e4823}


Returns an iterator over the set of byte tags included in this packet. 

\begin{DoxyReturn}{Returns}
an iterator over the set of byte tags included in this packet. 
\end{DoxyReturn}

\begin{DoxyCode}
792 \{
793   \textcolor{keywordflow}{return} ByteTagIterator (\hyperlink{classns3_1_1Packet_a29e08c3cc4220a80366eea801c00e4ba}{m\_byteTagList}.\hyperlink{classns3_1_1ByteTagList_acee7b77907ef44826712a630443493e7}{Begin} (0, \hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ()));
794 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 31




Here is the caller graph for this function\+:
% FIG 32


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Get\+Nix\+Vector@{Get\+Nix\+Vector}}
\index{Get\+Nix\+Vector@{Get\+Nix\+Vector}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Get\+Nix\+Vector(void) const }{GetNixVector(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Nix\+Vector} $>$ ns3\+::\+Packet\+::\+Get\+Nix\+Vector (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Packet_a3d68d7d2738678185315b59640848819}{}\label{classns3_1_1Packet_a3d68d7d2738678185315b59640848819}


Get the packet nix-\/vector. 

See the comment on Set\+Nix\+Vector

\begin{DoxyReturn}{Returns}
the Nix vector 
\end{DoxyReturn}

\begin{DoxyCode}
251 \{
252   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Packet_af6fe17f2fb778ccd84af5c3c950ee4f4}{m\_nixVector};
253 \} 
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 33


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Get\+Packet\+Tag\+Iterator@{Get\+Packet\+Tag\+Iterator}}
\index{Get\+Packet\+Tag\+Iterator@{Get\+Packet\+Tag\+Iterator}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Get\+Packet\+Tag\+Iterator(void) const }{GetPacketTagIterator(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Packet\+Tag\+Iterator} ns3\+::\+Packet\+::\+Get\+Packet\+Tag\+Iterator (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Packet_a9a06a61555a35fcad20638e6a7dfbeaa}{}\label{classns3_1_1Packet_a9a06a61555a35fcad20638e6a7dfbeaa}


Returns an object which can be used to iterate over the list of packet tags. 

\begin{DoxyReturn}{Returns}
an object which can be used to iterate over the list of packet tags. 
\end{DoxyReturn}

\begin{DoxyCode}
873 \{
874   \textcolor{keywordflow}{return} PacketTagIterator (\hyperlink{classns3_1_1Packet_a7c91fc548c7cfddf27c176e13bd858ff}{m\_packetTagList}.\hyperlink{classns3_1_1PacketTagList_a134ba1f369de24c2a5bea79bbfec16d3}{Head} ());
875 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 34




Here is the caller graph for this function\+:
% FIG 35


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Get\+Serialized\+Size@{Get\+Serialized\+Size}}
\index{Get\+Serialized\+Size@{Get\+Serialized\+Size}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Get\+Serialized\+Size(void) const }{GetSerializedSize(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Packet\+::\+Get\+Serialized\+Size (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Packet_a7416c3bc8c1a9a86c8ade4dfd1d67d2d}{}\label{classns3_1_1Packet_a7416c3bc8c1a9a86c8ade4dfd1d67d2d}


Returns number of bytes required for packet serialization. 

\begin{DoxyReturn}{Returns}
number of bytes required for packet serialization
\end{DoxyReturn}
For packet serialization, the total size is checked in order to determine the size of the buffer required for serialization \begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000145}{Todo}]Serialze Tags size \end{DoxyRefDesc}

\begin{DoxyCode}
548 \{
549   uint32\_t size = 0;
550 
551   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Packet_af6fe17f2fb778ccd84af5c3c950ee4f4}{m\_nixVector})
552     \{
553       \textcolor{comment}{// increment total size by the size of the nix-vector}
554       \textcolor{comment}{// ensuring 4-byte boundary}
555       size += ((\hyperlink{classns3_1_1Packet_af6fe17f2fb778ccd84af5c3c950ee4f4}{m\_nixVector}->GetSerializedSize () + 3) & (~3));
556 
557       \textcolor{comment}{// add 4-bytes for entry of total length of nix-vector}
558       size += 4;
559     \}
560   \textcolor{keywordflow}{else}
561     \{
562       \textcolor{comment}{// if no nix-vector, still have to add 4-bytes}
563       \textcolor{comment}{// to account for the entry of total size for }
564       \textcolor{comment}{// nix-vector in the buffer}
565       size += 4;
566     \}
567 
568   \textcolor{comment}{//Tag size}
570 \textcolor{comment}{}  \textcolor{comment}{//size += m\_tags.GetSerializedSize ();}
571 
572   \textcolor{comment}{// increment total size by size of meta-data }
573   \textcolor{comment}{// ensuring 4-byte boundary}
574   size += ((\hyperlink{classns3_1_1Packet_af3f95fba7966191bd152bcedd5fbcd6b}{m\_metadata}.\hyperlink{classns3_1_1PacketMetadata_a8d399798f5b18fc287a772914bfd9386}{GetSerializedSize} () + 3) & (~3));
575 
576   \textcolor{comment}{// add 4-bytes for entry of total length of meta-data}
577   size += 4;
578 
579   \textcolor{comment}{// increment total size by size of buffer }
580   \textcolor{comment}{// ensuring 4-byte boundary}
581   size += ((\hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer}.\hyperlink{classns3_1_1Buffer_a0d38b182a66558a719a17ab749643c21}{GetSerializedSize} () + 3) & (~3));
582 
583   \textcolor{comment}{// add 4-bytes for entry of total length of buffer }
584   size += 4;
585 
586   \textcolor{keywordflow}{return} size;
587 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 36




Here is the caller graph for this function\+:
% FIG 37


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Get\+Size@{Get\+Size}}
\index{Get\+Size@{Get\+Size}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Get\+Size(void) const }{GetSize(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Packet\+::\+Get\+Size (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{}\label{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}


Returns the the size in bytes of the packet (including the zero-\/filled initial payload). 

\begin{DoxyReturn}{Returns}
the size in bytes of the packet 
\end{DoxyReturn}

\begin{DoxyCode}
793 \{
794   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer}.\hyperlink{classns3_1_1Buffer_a3047b8f2dad303c6370695122f1884f0}{GetSize} ();
795 \}
\end{DoxyCode}
\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Get\+Uid@{Get\+Uid}}
\index{Get\+Uid@{Get\+Uid}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Get\+Uid(void) const }{GetUid(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t ns3\+::\+Packet\+::\+Get\+Uid (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Packet_a1f212c825b50e54d94f5b9ae99592e6a}{}\label{classns3_1_1Packet_a1f212c825b50e54d94f5b9ae99592e6a}


Returns the packet\textquotesingle{}s Uid. 

A packet is allocated a new uid when it is created empty or with zero-\/filled payload.

Note\+: This uid is an internal uid and cannot be counted on to provide an accurate counter of how many \char`\"{}simulated packets\char`\"{} of a particular protocol are in the system. It is not trivial to make this uid into such a counter, because of questions such as what should the uid be when the packet is sent over broadcast media, or when fragmentation occurs. If a user wants to trace actual packet counts, he or she should look at e.\+g. the IP ID field or transport sequence numbers, or other packet or frame counters at other protocol layers.

\begin{DoxyReturn}{Returns}
an integer identifier which uniquely identifies this packet. 
\end{DoxyReturn}

\begin{DoxyCode}
368 \{
369   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Packet_af3f95fba7966191bd152bcedd5fbcd6b}{m\_metadata}.\hyperlink{classns3_1_1PacketMetadata_a08284bf2d5d0690d16a2eee813122ede}{GetUid} ();
370 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 38




Here is the caller graph for this function\+:
% FIG 39


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!operator=@{operator=}}
\index{operator=@{operator=}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{operator=(const Packet \&o)}{operator=(const Packet &o)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Packet} \& ns3\+::\+Packet\+::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf Packet} \&}]{o}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Packet_a8f7627bc5113f3fa52ad68a20d57aa94}{}\label{classns3_1_1Packet_a8f7627bc5113f3fa52ad68a20d57aa94}


Basic assignment. 


\begin{DoxyParams}{Parameters}
{\em o} & object to copy \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the copied object 
\end{DoxyReturn}

\begin{DoxyCode}
157 \{
158   \textcolor{keywordflow}{if} (\textcolor{keyword}{this} == &o)
159     \{
160       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
161     \}
162   \hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer} = o.m\_buffer;
163   \hyperlink{classns3_1_1Packet_a29e08c3cc4220a80366eea801c00e4ba}{m\_byteTagList} = o.m\_byteTagList;
164   \hyperlink{classns3_1_1Packet_a7c91fc548c7cfddf27c176e13bd858ff}{m\_packetTagList} = o.m\_packetTagList;
165   \hyperlink{classns3_1_1Packet_af3f95fba7966191bd152bcedd5fbcd6b}{m\_metadata} = o.m\_metadata;
166   o.m\_nixVector ? \hyperlink{classns3_1_1Packet_af6fe17f2fb778ccd84af5c3c950ee4f4}{m\_nixVector} = o.m\_nixVector->Copy () 
167     : \hyperlink{classns3_1_1Packet_af6fe17f2fb778ccd84af5c3c950ee4f4}{m\_nixVector} = 0;
168   \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
169 \}
\end{DoxyCode}
\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Peek\+Header@{Peek\+Header}}
\index{Peek\+Header@{Peek\+Header}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Peek\+Header(\+Header \&header) const }{PeekHeader(Header &header) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Packet\+::\+Peek\+Header (
\begin{DoxyParamCaption}
\item[{{\bf Header} \&}]{header}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Packet_aadc63487bea70945c418f4c3e9b81964}{}\label{classns3_1_1Packet_aadc63487bea70945c418f4c3e9b81964}


Deserialize but does {\itshape not} remove the header from the internal buffer. s This method invokes \hyperlink{classns3_1_1Header_a78be9400bb66b2a8543606f395ef5396}{Header\+::\+Deserialize}. 


\begin{DoxyParams}{Parameters}
{\em header} & a reference to the header to read from the internal buffer. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of bytes read from the packet. 
\end{DoxyReturn}

\begin{DoxyCode}
278 \{
279   uint32\_t deserialized = header.Deserialize (\hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer}.\hyperlink{classns3_1_1Buffer_a893d4bf50df13e730b6cd0fda91b967f}{Begin} ());
280   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << header.GetInstanceTypeId ().GetName () << deserialized);
281   \textcolor{keywordflow}{return} deserialized;
282 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 40




Here is the caller graph for this function\+:
% FIG 41


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Peek\+Packet\+Tag@{Peek\+Packet\+Tag}}
\index{Peek\+Packet\+Tag@{Peek\+Packet\+Tag}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Peek\+Packet\+Tag(\+Tag \&tag) const }{PeekPacketTag(Tag &tag) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Packet\+::\+Peek\+Packet\+Tag (
\begin{DoxyParamCaption}
\item[{{\bf Tag} \&}]{tag}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Packet_a1734de11f2ca1e78a7872461a0625168}{}\label{classns3_1_1Packet_a1734de11f2ca1e78a7872461a0625168}


Search a matching tag and call \hyperlink{classns3_1_1Tag_ae166b7f816bcbdef44dbeb636c9fa712}{Tag\+::\+Deserialize} if it is found. 


\begin{DoxyParams}{Parameters}
{\em tag} & the tag to search in this packet \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the requested tag is found, false otherwise. 
\end{DoxyReturn}

\begin{DoxyCode}
837 \{
838   \textcolor{keywordtype}{bool} found = \hyperlink{classns3_1_1Packet_a7c91fc548c7cfddf27c176e13bd858ff}{m\_packetTagList}.\hyperlink{classns3_1_1PacketTagList_a49151e3dbbddac7820d2210bbde47c4b}{Peek} (tag);
839   \textcolor{keywordflow}{return} found;
840 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 42




Here is the caller graph for this function\+:
% FIG 43


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Peek\+Trailer@{Peek\+Trailer}}
\index{Peek\+Trailer@{Peek\+Trailer}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Peek\+Trailer(\+Trailer \&trailer)}{PeekTrailer(Trailer &trailer)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Packet\+::\+Peek\+Trailer (
\begin{DoxyParamCaption}
\item[{{\bf Trailer} \&}]{trailer}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Packet_ace1fc287b3fc4fc12e72954e35342131}{}\label{classns3_1_1Packet_ace1fc287b3fc4fc12e72954e35342131}


Deserialize but does {\itshape not} remove a trailer from the internal buffer. 

This method invokes the \hyperlink{classns3_1_1Trailer_aed0f0292faca43ef8676c05d70a664cf}{Trailer\+::\+Deserialize} method.


\begin{DoxyParams}{Parameters}
{\em trailer} & a reference to the trailer to read from the internal buffer. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of bytes read from the end of the packet. 
\end{DoxyReturn}

\begin{DoxyCode}
305 \{
306   uint32\_t deserialized = trailer.Deserialize (\hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer}.\hyperlink{classns3_1_1Buffer_a52207c7aed7bae89fba2f9e997c82724}{End} ());
307   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << trailer.GetInstanceTypeId ().GetName () << deserialized);
308   \textcolor{keywordflow}{return} deserialized;
309 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 44


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Print@{Print}}
\index{Print@{Print}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Print(std\+::ostream \&os) const }{Print(std::ostream &os) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Packet\+::\+Print (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Packet_aa34058a5cdbf94673531f8c4001ab227}{}\label{classns3_1_1Packet_aa34058a5cdbf94673531f8c4001ab227}


Print the packet contents. 


\begin{DoxyParams}{Parameters}
{\em os} & output stream in which the data should be printed.\\
\hline
\end{DoxyParams}
Iterate over the headers and trailers present in this packet, from the first header to the last trailer and invoke, for each of them, the user-\/provided method Header\+::\+Do\+Print or Trailer\+::\+Do\+Print methods. 
\begin{DoxyCode}
412 \{
413   \hyperlink{classns3_1_1PacketMetadata_a32606143b9dd3fe0db01264200e27783}{PacketMetadata::ItemIterator} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Packet_af3f95fba7966191bd152bcedd5fbcd6b}{m\_metadata}.
      \hyperlink{classns3_1_1PacketMetadata_aa574c0500da92d42d3cb53ae8a9fd0ad}{BeginItem} (\hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer});
414   \textcolor{keywordflow}{while} (i.HasNext ())
415     \{
416       PacketMetadata::Item item = i.\hyperlink{classns3_1_1PacketMetadata_1_1ItemIterator_a3d59a1673dca4338f41d3c788ccd3e10}{Next} ();
417       \textcolor{keywordflow}{if} (item.isFragment)
418         \{
419           \textcolor{keywordflow}{switch} (item.type) \{
420             \textcolor{keywordflow}{case} \hyperlink{structns3_1_1PacketMetadata_1_1Item_ab0a06781a8793079afeab58a9a9b3174ac2bc28ee0adb79d428d3f5a11be52f80}{PacketMetadata::Item::PAYLOAD}:
421               os << \textcolor{stringliteral}{"Payload"};
422               \textcolor{keywordflow}{break};
423             \textcolor{keywordflow}{case} \hyperlink{structns3_1_1PacketMetadata_1_1Item_ab0a06781a8793079afeab58a9a9b3174a35a76b7dc57ca42587ecfb5f81f1bcb2}{PacketMetadata::Item::HEADER}:
424             \textcolor{keywordflow}{case} \hyperlink{structns3_1_1PacketMetadata_1_1Item_ab0a06781a8793079afeab58a9a9b3174ab32282a2f84adad5e57549c03179ff45}{PacketMetadata::Item::TRAILER}:
425               os << item.tid.GetName ();
426               \textcolor{keywordflow}{break};
427             \}
428           os << \textcolor{stringliteral}{" Fragment ["} << item.currentTrimedFromStart<<\textcolor{stringliteral}{":"}
429              << (item.currentTrimedFromStart + item.currentSize) << \textcolor{stringliteral}{"]"};
430         \}
431       \textcolor{keywordflow}{else}
432         \{
433           \textcolor{keywordflow}{switch} (item.type) \{
434             \textcolor{keywordflow}{case} \hyperlink{structns3_1_1PacketMetadata_1_1Item_ab0a06781a8793079afeab58a9a9b3174ac2bc28ee0adb79d428d3f5a11be52f80}{PacketMetadata::Item::PAYLOAD}:
435               os << \textcolor{stringliteral}{"Payload (size="} << item.currentSize << \textcolor{stringliteral}{")"};
436               \textcolor{keywordflow}{break};
437             \textcolor{keywordflow}{case} \hyperlink{structns3_1_1PacketMetadata_1_1Item_ab0a06781a8793079afeab58a9a9b3174a35a76b7dc57ca42587ecfb5f81f1bcb2}{PacketMetadata::Item::HEADER}:
438             \textcolor{keywordflow}{case} \hyperlink{structns3_1_1PacketMetadata_1_1Item_ab0a06781a8793079afeab58a9a9b3174ab32282a2f84adad5e57549c03179ff45}{PacketMetadata::Item::TRAILER}:
439               os << item.tid.GetName () << \textcolor{stringliteral}{" ("};
440               \{
441                 \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (item.tid.HasConstructor ());
442                 Callback<ObjectBase *> constructor = item.tid.GetConstructor ();
443                 \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (!constructor.IsNull ());
444                 ObjectBase *instance = constructor ();
445                 \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (instance != 0);
446                 Chunk *chunk = \textcolor{keyword}{dynamic\_cast<}Chunk *\textcolor{keyword}{>} (instance);
447                 \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (chunk != 0);
448                 chunk->Deserialize (item.current);
449                 chunk->Print (os);
450                 \textcolor{keyword}{delete} chunk;
451               \}
452               os << \textcolor{stringliteral}{")"};
453               \textcolor{keywordflow}{break};
454             \}
455         \}
456       \textcolor{keywordflow}{if} (i.HasNext ())
457         \{
458           os << \textcolor{stringliteral}{" "};
459         \}
460     \}
461 \textcolor{preprocessor}{#if 0}
462   \textcolor{comment}{// The code below will work only if headers and trailers}
463   \textcolor{comment}{// define the right attributes which is not the case for}
464   \textcolor{comment}{// now. So, as a temporary measure, we use the }
465   \textcolor{comment}{// headers' and trailers' Print method as shown above.}
466   \hyperlink{classns3_1_1PacketMetadata_a32606143b9dd3fe0db01264200e27783}{PacketMetadata::ItemIterator} i = \hyperlink{classns3_1_1Packet_af3f95fba7966191bd152bcedd5fbcd6b}{m\_metadata}.
      \hyperlink{classns3_1_1PacketMetadata_aa574c0500da92d42d3cb53ae8a9fd0ad}{BeginItem} (\hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer});
467   \textcolor{keywordflow}{while} (i.HasNext ())
468     \{
469       PacketMetadata::Item item = i.\hyperlink{classns3_1_1PacketMetadata_1_1ItemIterator_a3d59a1673dca4338f41d3c788ccd3e10}{Next} ();
470       \textcolor{keywordflow}{if} (item.isFragment)
471         \{
472           \textcolor{keywordflow}{switch} (item.type) \{
473             \textcolor{keywordflow}{case} \hyperlink{structns3_1_1PacketMetadata_1_1Item_ab0a06781a8793079afeab58a9a9b3174ac2bc28ee0adb79d428d3f5a11be52f80}{PacketMetadata::Item::PAYLOAD}:
474               os << \textcolor{stringliteral}{"Payload"};
475               \textcolor{keywordflow}{break};
476             \textcolor{keywordflow}{case} \hyperlink{structns3_1_1PacketMetadata_1_1Item_ab0a06781a8793079afeab58a9a9b3174a35a76b7dc57ca42587ecfb5f81f1bcb2}{PacketMetadata::Item::HEADER}:
477             \textcolor{keywordflow}{case} \hyperlink{structns3_1_1PacketMetadata_1_1Item_ab0a06781a8793079afeab58a9a9b3174ab32282a2f84adad5e57549c03179ff45}{PacketMetadata::Item::TRAILER}:
478               os << item.tid.GetName ();
479               \textcolor{keywordflow}{break};
480             \}
481           os << \textcolor{stringliteral}{" Fragment ["} << item.currentTrimedFromStart<<\textcolor{stringliteral}{":"}
482              << (item.currentTrimedFromStart + item.currentSize) << \textcolor{stringliteral}{"]"};
483         \}
484       \textcolor{keywordflow}{else}
485         \{
486           \textcolor{keywordflow}{switch} (item.type) \{
487             \textcolor{keywordflow}{case} \hyperlink{structns3_1_1PacketMetadata_1_1Item_ab0a06781a8793079afeab58a9a9b3174ac2bc28ee0adb79d428d3f5a11be52f80}{PacketMetadata::Item::PAYLOAD}:
488               os << \textcolor{stringliteral}{"Payload (size="} << item.currentSize << \textcolor{stringliteral}{")"};
489               \textcolor{keywordflow}{break};
490             \textcolor{keywordflow}{case} \hyperlink{structns3_1_1PacketMetadata_1_1Item_ab0a06781a8793079afeab58a9a9b3174a35a76b7dc57ca42587ecfb5f81f1bcb2}{PacketMetadata::Item::HEADER}:
491             \textcolor{keywordflow}{case} \hyperlink{structns3_1_1PacketMetadata_1_1Item_ab0a06781a8793079afeab58a9a9b3174ab32282a2f84adad5e57549c03179ff45}{PacketMetadata::Item::TRAILER}:
492               os << item.tid.GetName () << \textcolor{stringliteral}{"("};
493               \{
494                 \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (item.tid.HasConstructor ());
495                 Callback<ObjectBase *> constructor = item.tid.GetConstructor ();
496                 \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (constructor.IsNull ());
497                 ObjectBase *instance = constructor ();
498                 \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (instance != 0);
499                 Chunk *chunk = \textcolor{keyword}{dynamic\_cast<}Chunk *\textcolor{keyword}{>} (instance);
500                 \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (chunk != 0);
501                 chunk->Deserialize (item.current);
502                 \textcolor{keywordflow}{for} (uint32\_t j = 0; j < item.tid.GetAttributeN (); j++)
503                   \{
504                     std::string attrName = item.tid.GetAttributeName (j);
505                     std::string value;
506                     \textcolor{keywordtype}{bool} ok = chunk->GetAttribute (attrName, value);
507                     \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (ok);
508                     os << attrName << \textcolor{stringliteral}{"="} << value;
509                     \textcolor{keywordflow}{if} ((j + 1) < item.tid.GetAttributeN ())
510                       \{
511                         os << \textcolor{stringliteral}{","};
512                       \}
513                   \}
514               \}
515               os << \textcolor{stringliteral}{")"};
516               \textcolor{keywordflow}{break};
517             \}
518         \}
519       \textcolor{keywordflow}{if} (i.HasNext ())
520         \{
521           os << \textcolor{stringliteral}{" "};
522         \}
523     \}
524 \textcolor{preprocessor}{#endif}
525 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 45




Here is the caller graph for this function\+:
% FIG 46


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Print\+Byte\+Tags@{Print\+Byte\+Tags}}
\index{Print\+Byte\+Tags@{Print\+Byte\+Tags}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Print\+Byte\+Tags(std\+::ostream \&os) const }{PrintByteTags(std::ostream &os) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Packet\+::\+Print\+Byte\+Tags (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Packet_af3766d81feb51b754cb036526c2f4366}{}\label{classns3_1_1Packet_af3766d81feb51b754cb036526c2f4366}


Iterate over the byte tags present in this packet, and invoke the Print method of each tag stored in the packet. 


\begin{DoxyParams}{Parameters}
{\em os} & output stream in which the data should be printed. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
374 \{
375   ByteTagIterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Packet_a3c03f35c267e8534c29bdaa4686e4823}{GetByteTagIterator} ();
376   \textcolor{keywordflow}{while} (i.HasNext ())
377     \{
378       ByteTagIterator::Item item = i.Next ();
379       os << item.GetTypeId ().GetName () << \textcolor{stringliteral}{" ["} << item.GetStart () << \textcolor{stringliteral}{"-"} << item.GetEnd () << \textcolor{stringliteral}{"]"};
380       Callback<ObjectBase *> constructor = item.GetTypeId ().GetConstructor ();
381       \textcolor{keywordflow}{if} (constructor.IsNull ())
382         \{
383           \textcolor{keywordflow}{if} (i.HasNext ())
384             \{
385               os << \textcolor{stringliteral}{" "};
386             \}
387           \textcolor{keywordflow}{continue};
388         \}
389       Tag *tag = \textcolor{keyword}{dynamic\_cast<}Tag *\textcolor{keyword}{>} (constructor ());
390       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (tag != 0);
391       os << \textcolor{stringliteral}{" "};
392       item.GetTag (*tag);
393       tag->Print (os);
394       \textcolor{keywordflow}{if} (i.HasNext ())
395         \{
396           os << \textcolor{stringliteral}{" "};
397         \}
398       \textcolor{keyword}{delete} tag;
399     \}
400 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 47


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Print\+Packet\+Tags@{Print\+Packet\+Tags}}
\index{Print\+Packet\+Tags@{Print\+Packet\+Tags}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Print\+Packet\+Tags(std\+::ostream \&os) const }{PrintPacketTags(std::ostream &os) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Packet\+::\+Print\+Packet\+Tags (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Packet_a260fecda6a32bfc24e16a950e7d91559}{}\label{classns3_1_1Packet_a260fecda6a32bfc24e16a950e7d91559}


Print the list of packet tags. 


\begin{DoxyParams}{Parameters}
{\em os} & the stream on which to print the tags.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Packet_a7400b8655852f5271c5957250d0141af}{Packet\+::\+Add\+Packet\+Tag}, \hyperlink{classns3_1_1Packet_a078fe922d976a417ab25ba2f3c2fd667}{Packet\+::\+Remove\+Packet\+Tag}, \hyperlink{classns3_1_1Packet_a1734de11f2ca1e78a7872461a0625168}{Packet\+::\+Peek\+Packet\+Tag}, \hyperlink{classns3_1_1Packet_a6c7bc5d1067c1d7fbd0fd70289182e8b}{Packet\+::\+Remove\+All\+Packet\+Tags} 
\end{DoxySeeAlso}

\begin{DoxyCode}
850 \{
851   PacketTagIterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Packet_a9a06a61555a35fcad20638e6a7dfbeaa}{GetPacketTagIterator} ();
852   \textcolor{keywordflow}{while} (i.HasNext ())
853     \{
854       PacketTagIterator::Item item = i.Next ();
855       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (item.GetTypeId ().HasConstructor ());
856       Callback<ObjectBase *> constructor = item.GetTypeId ().GetConstructor ();
857       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (!constructor.IsNull ());
858       ObjectBase *instance = constructor ();
859       Tag *tag = \textcolor{keyword}{dynamic\_cast<}Tag *\textcolor{keyword}{>} (instance);
860       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (tag != 0);
861       item.GetTag (*tag);
862       tag->Print (os);
863       \textcolor{keyword}{delete} tag;
864       \textcolor{keywordflow}{if} (i.HasNext ())
865         \{
866           os << \textcolor{stringliteral}{" "};
867         \}
868     \}
869 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 48




Here is the caller graph for this function\+:
% FIG 49


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Remove\+All\+Byte\+Tags@{Remove\+All\+Byte\+Tags}}
\index{Remove\+All\+Byte\+Tags@{Remove\+All\+Byte\+Tags}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Remove\+All\+Byte\+Tags(void)}{RemoveAllByteTags(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Packet\+::\+Remove\+All\+Byte\+Tags (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Packet_a083f54c9db31aeff30551a9e20fcda42}{}\label{classns3_1_1Packet_a083f54c9db31aeff30551a9e20fcda42}


Remove all byte tags stored in this packet. 


\begin{DoxyCode}
349 \{
350   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
351   \hyperlink{classns3_1_1Packet_a29e08c3cc4220a80366eea801c00e4ba}{m\_byteTagList}.\hyperlink{classns3_1_1ByteTagList_a989a5f3c12577fd875e701ea389709cd}{RemoveAll} ();
352 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 50




Here is the caller graph for this function\+:
% FIG 51


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Remove\+All\+Packet\+Tags@{Remove\+All\+Packet\+Tags}}
\index{Remove\+All\+Packet\+Tags@{Remove\+All\+Packet\+Tags}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Remove\+All\+Packet\+Tags(void)}{RemoveAllPacketTags(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Packet\+::\+Remove\+All\+Packet\+Tags (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Packet_a6c7bc5d1067c1d7fbd0fd70289182e8b}{}\label{classns3_1_1Packet_a6c7bc5d1067c1d7fbd0fd70289182e8b}


Remove all packet tags. 


\begin{DoxyCode}
843 \{
844   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
845   \hyperlink{classns3_1_1Packet_a7c91fc548c7cfddf27c176e13bd858ff}{m\_packetTagList}.\hyperlink{classns3_1_1PacketTagList_a798eb1d77415704e948194564d0eaa4e}{RemoveAll} ();
846 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 52




Here is the caller graph for this function\+:
% FIG 53


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Remove\+At\+End@{Remove\+At\+End}}
\index{Remove\+At\+End@{Remove\+At\+End}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Remove\+At\+End(uint32\+\_\+t size)}{RemoveAtEnd(uint32_t size)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Packet\+::\+Remove\+At\+End (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{size}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Packet_a607de6c1abda2a960e99a3b59fd35d14}{}\label{classns3_1_1Packet_a607de6c1abda2a960e99a3b59fd35d14}


Remove size bytes from the end of the current packet. 

It is safe to remove more bytes than are present in the packet.


\begin{DoxyParams}{Parameters}
{\em size} & number of bytes from remove \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
333 \{
334   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << size);
335   \hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer}.\hyperlink{classns3_1_1Buffer_a83b30fd8e1202e778fb471757b800d47}{RemoveAtEnd} (size);
336   \hyperlink{classns3_1_1Packet_af3f95fba7966191bd152bcedd5fbcd6b}{m\_metadata}.\hyperlink{classns3_1_1PacketMetadata_a7c76154f5302bd55a68406f0103d50c6}{RemoveAtEnd} (size);
337 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 54




Here is the caller graph for this function\+:
% FIG 55


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Remove\+At\+Start@{Remove\+At\+Start}}
\index{Remove\+At\+Start@{Remove\+At\+Start}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Remove\+At\+Start(uint32\+\_\+t size)}{RemoveAtStart(uint32_t size)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Packet\+::\+Remove\+At\+Start (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{size}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Packet_a78aa207e7921dd2f9f7e0d0b7a1c730a}{}\label{classns3_1_1Packet_a78aa207e7921dd2f9f7e0d0b7a1c730a}


Remove size bytes from the start of the current packet. 

It is safe to remove more bytes than are present in the packet.


\begin{DoxyParams}{Parameters}
{\em size} & number of bytes from remove \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
340 \{
341   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << size);
342   \hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer}.\hyperlink{classns3_1_1Buffer_adeecbb3e8f518aec6fee0437578ade4b}{RemoveAtStart} (size);
343   \hyperlink{classns3_1_1Packet_a29e08c3cc4220a80366eea801c00e4ba}{m\_byteTagList}.\hyperlink{classns3_1_1ByteTagList_a1fec06d7e6daaf8039cf2a148e4090f2}{Adjust} (-size);
344   \hyperlink{classns3_1_1Packet_af3f95fba7966191bd152bcedd5fbcd6b}{m\_metadata}.\hyperlink{classns3_1_1PacketMetadata_a9a0300e7ae709f269d59b6733e590d56}{RemoveAtStart} (size);
345 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 56




Here is the caller graph for this function\+:
% FIG 57


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Remove\+Header@{Remove\+Header}}
\index{Remove\+Header@{Remove\+Header}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Remove\+Header(\+Header \&header)}{RemoveHeader(Header &header)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Packet\+::\+Remove\+Header (
\begin{DoxyParamCaption}
\item[{{\bf Header} \&}]{header}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Packet_a0961eccf975d75f902d40956c93ba63e}{}\label{classns3_1_1Packet_a0961eccf975d75f902d40956c93ba63e}


Deserialize and remove the header from the internal buffer. 

This method invokes \hyperlink{classns3_1_1Header_a78be9400bb66b2a8543606f395ef5396}{Header\+::\+Deserialize}.


\begin{DoxyParams}{Parameters}
{\em header} & a reference to the header to remove from the internal buffer. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of bytes removed from the packet. 
\end{DoxyReturn}

\begin{DoxyCode}
268 \{
269   uint32\_t deserialized = header.Deserialize (\hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer}.\hyperlink{classns3_1_1Buffer_a893d4bf50df13e730b6cd0fda91b967f}{Begin} ());
270   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << header.GetInstanceTypeId ().GetName () << deserialized);
271   \hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer}.\hyperlink{classns3_1_1Buffer_adeecbb3e8f518aec6fee0437578ade4b}{RemoveAtStart} (deserialized);
272   \hyperlink{classns3_1_1Packet_a29e08c3cc4220a80366eea801c00e4ba}{m\_byteTagList}.\hyperlink{classns3_1_1ByteTagList_a1fec06d7e6daaf8039cf2a148e4090f2}{Adjust} (-deserialized);
273   \hyperlink{classns3_1_1Packet_af3f95fba7966191bd152bcedd5fbcd6b}{m\_metadata}.\hyperlink{classns3_1_1PacketMetadata_afa8a589ec783d4998516d7f39f21242d}{RemoveHeader} (header, deserialized);
274   \textcolor{keywordflow}{return} deserialized;
275 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 58


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Remove\+Packet\+Tag@{Remove\+Packet\+Tag}}
\index{Remove\+Packet\+Tag@{Remove\+Packet\+Tag}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Remove\+Packet\+Tag(\+Tag \&tag)}{RemovePacketTag(Tag &tag)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Packet\+::\+Remove\+Packet\+Tag (
\begin{DoxyParamCaption}
\item[{{\bf Tag} \&}]{tag}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Packet_a078fe922d976a417ab25ba2f3c2fd667}{}\label{classns3_1_1Packet_a078fe922d976a417ab25ba2f3c2fd667}


Remove a packet tag. 


\begin{DoxyParams}{Parameters}
{\em tag} & the packet tag type to remove from this packet. The tag parameter is set to the value of the tag found. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the requested tag is found, false otherwise. 
\end{DoxyReturn}

\begin{DoxyCode}
822 \{
823   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << tag.GetInstanceTypeId ().GetName () << tag.GetSerializedSize ());
824   \textcolor{keywordtype}{bool} found = \hyperlink{classns3_1_1Packet_a7c91fc548c7cfddf27c176e13bd858ff}{m\_packetTagList}.\hyperlink{classns3_1_1PacketTagList_a043d984c546f67adc273448747784ee3}{Remove} (tag);
825   \textcolor{keywordflow}{return} found;
826 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 59




Here is the caller graph for this function\+:
% FIG 60


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Remove\+Trailer@{Remove\+Trailer}}
\index{Remove\+Trailer@{Remove\+Trailer}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Remove\+Trailer(\+Trailer \&trailer)}{RemoveTrailer(Trailer &trailer)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Packet\+::\+Remove\+Trailer (
\begin{DoxyParamCaption}
\item[{{\bf Trailer} \&}]{trailer}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Packet_a2155e042083e9a17ad3b33f9fecb4be4}{}\label{classns3_1_1Packet_a2155e042083e9a17ad3b33f9fecb4be4}


Remove a deserialized trailer from the internal buffer. 

This method invokes the Deserialize method.


\begin{DoxyParams}{Parameters}
{\em trailer} & a reference to the trailer to remove from the internal buffer. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of bytes removed from the end of the packet. 
\end{DoxyReturn}

\begin{DoxyCode}
296 \{
297   uint32\_t deserialized = trailer.Deserialize (\hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer}.\hyperlink{classns3_1_1Buffer_a52207c7aed7bae89fba2f9e997c82724}{End} ());
298   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << trailer.GetInstanceTypeId ().GetName () << deserialized);
299   \hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer}.\hyperlink{classns3_1_1Buffer_a83b30fd8e1202e778fb471757b800d47}{RemoveAtEnd} (deserialized);
300   \hyperlink{classns3_1_1Packet_af3f95fba7966191bd152bcedd5fbcd6b}{m\_metadata}.\hyperlink{classns3_1_1PacketMetadata_a2eaa46d9f7c88a5aef121521b196753c}{RemoveTrailer} (trailer, deserialized);
301   \textcolor{keywordflow}{return} deserialized;
302 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 61




Here is the caller graph for this function\+:
% FIG 62


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Replace\+Packet\+Tag@{Replace\+Packet\+Tag}}
\index{Replace\+Packet\+Tag@{Replace\+Packet\+Tag}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Replace\+Packet\+Tag(\+Tag \&tag)}{ReplacePacketTag(Tag &tag)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Packet\+::\+Replace\+Packet\+Tag (
\begin{DoxyParamCaption}
\item[{{\bf Tag} \&}]{tag}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Packet_afb014ae9f4adddbfc51c64b085bfd405}{}\label{classns3_1_1Packet_afb014ae9f4adddbfc51c64b085bfd405}


Replace the value of a packet tag. 


\begin{DoxyParams}{Parameters}
{\em tag} & the packet tag type to replace. To get the old value of the tag, use Peek\+Packet\+Tag first. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the requested tag is found, false otherwise. If the tag isn\textquotesingle{}t found, Add is performed instead (so the packet is guaranteed to have the new tag value either way). 
\end{DoxyReturn}

\begin{DoxyCode}
829 \{
830   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << tag.GetInstanceTypeId ().GetName () << tag.GetSerializedSize ());
831   \textcolor{keywordtype}{bool} found = \hyperlink{classns3_1_1Packet_a7c91fc548c7cfddf27c176e13bd858ff}{m\_packetTagList}.\hyperlink{classns3_1_1PacketTagList_a6a6bc266832b2cead6cf42e3daee1041}{Replace} (tag);
832   \textcolor{keywordflow}{return} found;
833 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 63




Here is the caller graph for this function\+:
% FIG 64


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Serialize@{Serialize}}
\index{Serialize@{Serialize}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Serialize(uint8\+\_\+t $\ast$buffer, uint32\+\_\+t max\+Size) const }{Serialize(uint8_t *buffer, uint32_t maxSize) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Packet\+::\+Serialize (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$}]{buffer, }
\item[{uint32\+\_\+t}]{max\+Size}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Packet_a939e41b065c6f9f77d3f51373baeaf7e}{}\label{classns3_1_1Packet_a939e41b065c6f9f77d3f51373baeaf7e}


Serialize a packet, tags, and metadata into a byte buffer. 


\begin{DoxyParams}{Parameters}
{\em buffer} & a raw byte buffer to which the packet will be serialized \\
\hline
{\em max\+Size} & the max size of the buffer for bounds checking\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
one if all data were serialized, zero if buffer size was too small. 
\end{DoxyReturn}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000146}{Todo}]Serialize Tags \end{DoxyRefDesc}

\begin{DoxyCode}
591 \{
592   uint32\_t* \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = \textcolor{keyword}{reinterpret\_cast<}uint32\_t *\textcolor{keyword}{>} (buffer);
593   uint32\_t size = 0;
594 
595   \textcolor{comment}{// if nix-vector exists, serialize it}
596   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Packet_af6fe17f2fb778ccd84af5c3c950ee4f4}{m\_nixVector})
597     \{
598       uint32\_t nixSize = \hyperlink{classns3_1_1Packet_af6fe17f2fb778ccd84af5c3c950ee4f4}{m\_nixVector}->GetSerializedSize ();
599       \textcolor{keywordflow}{if} (size + nixSize <= maxSize)
600         \{
601           \textcolor{comment}{// put the total length of nix-vector in the}
602           \textcolor{comment}{// buffer. this includes 4-bytes for total }
603           \textcolor{comment}{// length itself}
604           *p++ = nixSize + 4;
605           size += nixSize;
606 
607           \textcolor{comment}{// serialize the nix-vector}
608           uint32\_t serialized = 
609             \hyperlink{classns3_1_1Packet_af6fe17f2fb778ccd84af5c3c950ee4f4}{m\_nixVector}->Serialize (p, nixSize);
610           \textcolor{keywordflow}{if} (serialized)
611             \{
612               \textcolor{comment}{// increment p by nixSize bytes}
613               \textcolor{comment}{// ensuring 4-byte boundary}
614               p += ((nixSize+3) & (~3)) / 4;
615             \}
616           \textcolor{keywordflow}{else}
617             \{
618               \textcolor{keywordflow}{return} 0;
619             \}
620         \}
621       \textcolor{keywordflow}{else} 
622         \{
623           \textcolor{keywordflow}{return} 0;
624         \}
625     \}
626   \textcolor{keywordflow}{else}
627     \{ 
628       \textcolor{comment}{// no nix vector, set zero length, }
629       \textcolor{comment}{// ie 4-bytes, since it must include }
630       \textcolor{comment}{// length for itself}
631       \textcolor{keywordflow}{if} (size + 4 <= maxSize)
632         \{
633           size += 4;
634           *p++ = 4;
635         \}
636       \textcolor{keywordflow}{else}
637         \{
638           \textcolor{keywordflow}{return} 0;
639         \}
640     \}
641 
642   \textcolor{comment}{// Serialize Tags}
644 \textcolor{comment}{}
645   \textcolor{comment}{// Serialize Metadata}
646   uint32\_t metaSize = \hyperlink{classns3_1_1Packet_af3f95fba7966191bd152bcedd5fbcd6b}{m\_metadata}.\hyperlink{classns3_1_1PacketMetadata_a8d399798f5b18fc287a772914bfd9386}{GetSerializedSize} ();
647   \textcolor{keywordflow}{if} (size + metaSize <= maxSize)
648     \{
649       \textcolor{comment}{// put the total length of metadata in the}
650       \textcolor{comment}{// buffer. this includes 4-bytes for total }
651       \textcolor{comment}{// length itself}
652       *p++ = metaSize + 4;
653       size += metaSize;
654 
655       \textcolor{comment}{// serialize the metadata}
656       uint32\_t serialized = \hyperlink{classns3_1_1Packet_af3f95fba7966191bd152bcedd5fbcd6b}{m\_metadata}.\hyperlink{classns3_1_1PacketMetadata_aae036ce6844106a8a3ce88e0e095a7eb}{Serialize} (reinterpret\_cast<uint8\_t *> (p), 
      metaSize);
657       \textcolor{keywordflow}{if} (serialized)
658         \{
659           \textcolor{comment}{// increment p by metaSize bytes}
660           \textcolor{comment}{// ensuring 4-byte boundary}
661           p += ((metaSize+3) & (~3)) / 4;
662         \}
663       \textcolor{keywordflow}{else}
664         \{
665           \textcolor{keywordflow}{return} 0;
666         \}
667     \}
668   \textcolor{keywordflow}{else}
669     \{
670       \textcolor{keywordflow}{return} 0;
671     \}
672 
673   \textcolor{comment}{// Serialize the packet contents}
674   uint32\_t bufSize = \hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer}.\hyperlink{classns3_1_1Buffer_a0d38b182a66558a719a17ab749643c21}{GetSerializedSize} ();
675   \textcolor{keywordflow}{if} (size + bufSize <= maxSize)
676     \{
677       \textcolor{comment}{// put the total length of the buffer in the}
678       \textcolor{comment}{// buffer. this includes 4-bytes for total }
679       \textcolor{comment}{// length itself}
680       *p++ = bufSize + 4;
681 
682       \textcolor{comment}{// serialize the buffer}
683       uint32\_t serialized = \hyperlink{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{m\_buffer}.\hyperlink{classns3_1_1Buffer_af32e7e0a4e53c5a7e3b4e921ccb07aa8}{Serialize} (reinterpret\_cast<uint8\_t *> (p), bufSize);
684       \textcolor{keywordflow}{if} (!serialized)
685         \{
686           \textcolor{keywordflow}{return} 0;
687         \}
688     \}
689   \textcolor{keywordflow}{else}
690     \{
691       \textcolor{keywordflow}{return} 0;
692     \}
693 
694   \textcolor{comment}{// Serialized successfully}
695   \textcolor{keywordflow}{return} 1;
696 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 65




Here is the caller graph for this function\+:
% FIG 66


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!Set\+Nix\+Vector@{Set\+Nix\+Vector}}
\index{Set\+Nix\+Vector@{Set\+Nix\+Vector}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{Set\+Nix\+Vector(\+Ptr$<$ Nix\+Vector $>$ nix\+Vector)}{SetNixVector(Ptr< NixVector > nixVector)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Packet\+::\+Set\+Nix\+Vector (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Nix\+Vector} $>$}]{nix\+Vector}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Packet_a7e02c5b608a578c845aafd838f155989}{}\label{classns3_1_1Packet_a7e02c5b608a578c845aafd838f155989}


Set the packet nix-\/vector. 

Note\+: This function supports a temporary solution to a specific problem in this generic class, i.\+e. how to associate something specific like nix-\/vector with a packet. This design methodology should {\itshape not} be followed, and is only here as an impetus to fix this general issue.


\begin{DoxyParams}{Parameters}
{\em nix\+Vector} & the nix vector \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
245 \{
246   \hyperlink{classns3_1_1Packet_af6fe17f2fb778ccd84af5c3c950ee4f4}{m\_nixVector} = nixVector;
247 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 67


\index{ns3\+::\+Packet@{ns3\+::\+Packet}!To\+String@{To\+String}}
\index{To\+String@{To\+String}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{To\+String(void) const }{ToString(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string ns3\+::\+Packet\+::\+To\+String (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Packet_a2474139f184f81df37f35b99efdc66f1}{}\label{classns3_1_1Packet_a2474139f184f81df37f35b99efdc66f1}


Return a string representation of the packet. 

An empty string is returned if you haven\textquotesingle{}t called Enable\+Printing ()

\begin{DoxyReturn}{Returns}
String representation 
\end{DoxyReturn}

\begin{DoxyCode}
404 \{
405   std::ostringstream oss;
406   \hyperlink{classns3_1_1Packet_aa34058a5cdbf94673531f8c4001ab227}{Print} (oss);
407   \textcolor{keywordflow}{return} oss.str();
408 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 68




\subsection{Member Data Documentation}
\index{ns3\+::\+Packet@{ns3\+::\+Packet}!m\+\_\+buffer@{m\+\_\+buffer}}
\index{m\+\_\+buffer@{m\+\_\+buffer}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{m\+\_\+buffer}{m_buffer}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Buffer} ns3\+::\+Packet\+::m\+\_\+buffer\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}{}\label{classns3_1_1Packet_a0f17bc9b4177865c9fe48fc927d57996}


the packet buffer (it\textquotesingle{}s actual contents) 

\index{ns3\+::\+Packet@{ns3\+::\+Packet}!m\+\_\+byte\+Tag\+List@{m\+\_\+byte\+Tag\+List}}
\index{m\+\_\+byte\+Tag\+List@{m\+\_\+byte\+Tag\+List}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{m\+\_\+byte\+Tag\+List}{m_byteTagList}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Byte\+Tag\+List} ns3\+::\+Packet\+::m\+\_\+byte\+Tag\+List\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Packet_a29e08c3cc4220a80366eea801c00e4ba}{}\label{classns3_1_1Packet_a29e08c3cc4220a80366eea801c00e4ba}


the Byte\+Tag list 

\index{ns3\+::\+Packet@{ns3\+::\+Packet}!m\+\_\+global\+Uid@{m\+\_\+global\+Uid}}
\index{m\+\_\+global\+Uid@{m\+\_\+global\+Uid}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{m\+\_\+global\+Uid}{m_globalUid}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Packet\+::m\+\_\+global\+Uid = 0\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\hypertarget{classns3_1_1Packet_a4f707aab2b31689f8d1dadaed31e7c82}{}\label{classns3_1_1Packet_a4f707aab2b31689f8d1dadaed31e7c82}


Global counter of packets Uid. 

\index{ns3\+::\+Packet@{ns3\+::\+Packet}!m\+\_\+metadata@{m\+\_\+metadata}}
\index{m\+\_\+metadata@{m\+\_\+metadata}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{m\+\_\+metadata}{m_metadata}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Packet\+Metadata} ns3\+::\+Packet\+::m\+\_\+metadata\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Packet_af3f95fba7966191bd152bcedd5fbcd6b}{}\label{classns3_1_1Packet_af3f95fba7966191bd152bcedd5fbcd6b}


the packet\textquotesingle{}s metadata 

\index{ns3\+::\+Packet@{ns3\+::\+Packet}!m\+\_\+nix\+Vector@{m\+\_\+nix\+Vector}}
\index{m\+\_\+nix\+Vector@{m\+\_\+nix\+Vector}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{m\+\_\+nix\+Vector}{m_nixVector}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Nix\+Vector}$>$ ns3\+::\+Packet\+::m\+\_\+nix\+Vector\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Packet_af6fe17f2fb778ccd84af5c3c950ee4f4}{}\label{classns3_1_1Packet_af6fe17f2fb778ccd84af5c3c950ee4f4}


the packet\textquotesingle{}s Nix vector 

\index{ns3\+::\+Packet@{ns3\+::\+Packet}!m\+\_\+packet\+Tag\+List@{m\+\_\+packet\+Tag\+List}}
\index{m\+\_\+packet\+Tag\+List@{m\+\_\+packet\+Tag\+List}!ns3\+::\+Packet@{ns3\+::\+Packet}}
\subsubsection[{\texorpdfstring{m\+\_\+packet\+Tag\+List}{m_packetTagList}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Packet\+Tag\+List} ns3\+::\+Packet\+::m\+\_\+packet\+Tag\+List\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Packet_a7c91fc548c7cfddf27c176e13bd858ff}{}\label{classns3_1_1Packet_a7c91fc548c7cfddf27c176e13bd858ff}


the packet\textquotesingle{}s \hyperlink{classns3_1_1Tag}{Tag} list 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
network/model/\hyperlink{packet_8h}{packet.\+h}\item 
network/model/\hyperlink{packet_8cc}{packet.\+cc}\end{DoxyCompactItemize}
