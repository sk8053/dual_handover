\hypertarget{classns3_1_1Ipv4NixVectorRouting}{}\section{ns3\+:\+:Ipv4\+Nix\+Vector\+Routing Class Reference}
\label{classns3_1_1Ipv4NixVectorRouting}\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}


{\ttfamily \#include $<$ipv4-\/nix-\/vector-\/routing.\+h$>$}



Inheritance diagram for ns3\+:\+:Ipv4\+Nix\+Vector\+Routing\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Ipv4\+Nix\+Vector\+Routing\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ipv4NixVectorRouting_a0aa865407f4e446e5afb3c83e718e9c7}{Ipv4\+Nix\+Vector\+Routing} ()
\item 
\hyperlink{classns3_1_1Ipv4NixVectorRouting_a3ce17fb8675e93a607b491232471f685}{$\sim$\+Ipv4\+Nix\+Vector\+Routing} ()
\item 
void \hyperlink{classns3_1_1Ipv4NixVectorRouting_a6a038800279f64332101463c5c393cff}{Set\+Node} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node)
\begin{DoxyCompactList}\small\item\em Set the \hyperlink{classns3_1_1Node}{Node} pointer of the node for which this routing protocol is to be placed. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4NixVectorRouting_acbd7460ba116c4b5ff830fb1d60a13ea}{Flush\+Global\+Nix\+Routing\+Cache} (void) const 
\begin{DoxyCompactList}\small\item\em Called when run-\/time link topology change occurs which iterates through the node list and flushes any nix vector caches. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1Ipv4NixVectorRouting_aeebea623bb7d67844520b2c340c4628c}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em The Interface ID of the Global Router interface. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classns3_1_1Ipv4NixVectorRouting_a25fb80fd82a26e8b5e33aa953a026723}{Flush\+Nix\+Cache} (void) const 
\item 
void \hyperlink{classns3_1_1Ipv4NixVectorRouting_a327dbe773d1e4a06f732da45d34e15d7}{Flush\+Ipv4\+Route\+Cache} (void) const 
\item 
void \hyperlink{classns3_1_1Ipv4NixVectorRouting_ac702e006e998efe33f5db76c79618bfc}{Reset\+Total\+Neighbors} (void)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NixVector}{Nix\+Vector} $>$ \hyperlink{classns3_1_1Ipv4NixVectorRouting_ad1f618c1b1264f0d01644b9a68a0bd20}{Get\+Nix\+Vector} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address}, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NixVector}{Nix\+Vector} $>$ \hyperlink{classns3_1_1Ipv4NixVectorRouting_afeecd07d75e1fda9a99d1f914ec331ce}{Get\+Nix\+Vector\+In\+Cache} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address})
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ \hyperlink{classns3_1_1Ipv4NixVectorRouting_a1d352caa92d6d91e6cb94ecc31be4411}{Get\+Ipv4\+Route\+In\+Cache} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address})
\item 
void \hyperlink{classns3_1_1Ipv4NixVectorRouting_a1037f3752d6583eca8cd83c72e0673ea}{Get\+Adjacent\+Net\+Devices} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Channel}{Channel} $>$, \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} \&)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1Ipv4NixVectorRouting_a24d3474ebcb1fc7da5a133dc071cd2df}{Get\+Node\+By\+Ip} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address})
\item 
bool \hyperlink{classns3_1_1Ipv4NixVectorRouting_ac797bda1b70ad4c4aa7e8d5729a50455}{Build\+Nix\+Vector} (const std\+::vector$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ $>$ \&parent\+Vector, uint32\+\_\+t source, uint32\+\_\+t dest, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NixVector}{Nix\+Vector} $>$ nix\+Vector)
\item 
bool \hyperlink{classns3_1_1Ipv4NixVectorRouting_a86ca754bc22b1714ffe7a4b858cda72d}{Build\+Nix\+Vector\+Local} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NixVector}{Nix\+Vector} $>$ nix\+Vector)
\item 
uint32\+\_\+t \hyperlink{classns3_1_1Ipv4NixVectorRouting_ae4d125bd51c2d70084543489f00060b5}{Find\+Total\+Neighbors} (void)
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1BridgeNetDevice}{Bridge\+Net\+Device} $>$ \hyperlink{classns3_1_1Ipv4NixVectorRouting_abf47d63e2dbb8022a042743feeb569c6}{Net\+Device\+Is\+Bridged} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ nd) const 
\item 
uint32\+\_\+t \hyperlink{classns3_1_1Ipv4NixVectorRouting_abbd212141a650d5260455663d59c24c9}{Find\+Net\+Device\+For\+Nix\+Index} (uint32\+\_\+t node\+Index, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \&gateway\+Ip)
\item 
bool \hyperlink{classns3_1_1Ipv4NixVectorRouting_aba4436060833304f21000470702da6d9}{B\+FS} (uint32\+\_\+t number\+Of\+Nodes, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ source, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ dest, std\+::vector$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ $>$ \&parent\+Vector, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ oif)
\item 
void \hyperlink{classns3_1_1Ipv4NixVectorRouting_a56f3712cab7976e071d487eb686c9280}{Do\+Dispose} (void)
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ \hyperlink{classns3_1_1Ipv4NixVectorRouting_ac7bbf06105fc46edc431bdc7be58f3e7}{Route\+Output} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ oif, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket\+::\+Socket\+Errno} \&sockerr)
\begin{DoxyCompactList}\small\item\em Query routing cache for an existing route, for an outbound packet. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1Ipv4NixVectorRouting_a35d3d496fc0f96e1fd0106b353404c0c}{Route\+Input} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ idev, \hyperlink{classns3_1_1Ipv4RoutingProtocol_a3453a85764cbbb1e704da7e919aa5d19}{Unicast\+Forward\+Callback} ucb, \hyperlink{classns3_1_1Ipv4RoutingProtocol_a26e76f7a555462e6c08fceda64a99d58}{Multicast\+Forward\+Callback} mcb, \hyperlink{classns3_1_1Ipv4RoutingProtocol_aa6ffa0159cb143daa3c46d2ba69bb1b9}{Local\+Deliver\+Callback} lcb, \hyperlink{classns3_1_1Ipv4RoutingProtocol_a0348285418c30d5021b08f7a68af21ea}{Error\+Callback} ecb)
\begin{DoxyCompactList}\small\item\em Route an input packet (to be forwarded or locally delivered) \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv4NixVectorRouting_a61f49f7c0ef8115c3d616d99f97052dc}{Notify\+Interface\+Up} (uint32\+\_\+t interface)
\item 
virtual void \hyperlink{classns3_1_1Ipv4NixVectorRouting_a4b9bfdc6d15165db72aa091f11fa899e}{Notify\+Interface\+Down} (uint32\+\_\+t interface)
\item 
virtual void \hyperlink{classns3_1_1Ipv4NixVectorRouting_a045c6307b4b2c6956471073066a48b16}{Notify\+Add\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} address)
\item 
virtual void \hyperlink{classns3_1_1Ipv4NixVectorRouting_a2a58d2c4a51a82a74456c5205ff1204e}{Notify\+Remove\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} address)
\item 
virtual void \hyperlink{classns3_1_1Ipv4NixVectorRouting_aff290a5e6590fb40ef8de74abfeebc74}{Set\+Ipv4} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$ ipv4)
\item 
virtual void \hyperlink{classns3_1_1Ipv4NixVectorRouting_ad9c8c58d1641ddc1b3dc6245f4d30213}{Print\+Routing\+Table} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream, \hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295a}{Time\+::\+Unit} unit=\hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295aade8622b06524a328cd3a59db6ccf76af}{Time\+::S}) const 
\begin{DoxyCompactList}\small\item\em Print the Routing Table entries. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4NixVectorRouting_aeeafd72dfb17da8349627232c9e9984f}{Check\+Cache\+State\+And\+Flush} (void) const 
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{group__nix-vector-routing_gaa552b6157fc91cb632b9007a4cef9bc7}{Nix\+Map\+\_\+t} \hyperlink{classns3_1_1Ipv4NixVectorRouting_a394e830e592aa6ef064be362150219f2}{m\+\_\+nix\+Cache}
\item 
\hyperlink{group__nix-vector-routing_ga0a2084e70cce2de3dcfab5da0ec63bdd}{Ipv4\+Route\+Map\+\_\+t} \hyperlink{classns3_1_1Ipv4NixVectorRouting_aeb85361b66489c60851f72f1493fdee7}{m\+\_\+ipv4\+Route\+Cache}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$ \hyperlink{classns3_1_1Ipv4NixVectorRouting_a215cb71f30d85df9ec7176ca22620519}{m\+\_\+ipv4}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1Ipv4NixVectorRouting_a329265b09f4d85bac6ec9bd0ec2daa92}{m\+\_\+node}
\item 
uint32\+\_\+t \hyperlink{classns3_1_1Ipv4NixVectorRouting_a96620dedcc6c052265c3c53aa14e4f6b}{m\+\_\+total\+Neighbors}
\end{DoxyCompactItemize}
\subsection*{Static Private Attributes}
\begin{DoxyCompactItemize}
\item 
static bool \hyperlink{classns3_1_1Ipv4NixVectorRouting_a7b75edeb473c9fe1595b59d9800c5bab}{g\+\_\+is\+Cache\+Dirty} = \hyperlink{lte__cqi__generation_8m_ab1bef239d413c4da139c4bac92cd657a}{false}
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Nix-\/vector routing protocol 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!Ipv4\+Nix\+Vector\+Routing@{Ipv4\+Nix\+Vector\+Routing}}
\index{Ipv4\+Nix\+Vector\+Routing@{Ipv4\+Nix\+Vector\+Routing}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{Ipv4\+Nix\+Vector\+Routing()}{Ipv4NixVectorRouting()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::\+Ipv4\+Nix\+Vector\+Routing (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4NixVectorRouting_a0aa865407f4e446e5afb3c83e718e9c7}{}\label{classns3_1_1Ipv4NixVectorRouting_a0aa865407f4e446e5afb3c83e718e9c7}

\begin{DoxyCode}
51   : \hyperlink{classns3_1_1Ipv4NixVectorRouting_a96620dedcc6c052265c3c53aa14e4f6b}{m\_totalNeighbors} (0)
52 \{
53   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
54 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!````~Ipv4\+Nix\+Vector\+Routing@{$\sim$\+Ipv4\+Nix\+Vector\+Routing}}
\index{````~Ipv4\+Nix\+Vector\+Routing@{$\sim$\+Ipv4\+Nix\+Vector\+Routing}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{$\sim$\+Ipv4\+Nix\+Vector\+Routing()}{~Ipv4NixVectorRouting()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::$\sim$\+Ipv4\+Nix\+Vector\+Routing (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4NixVectorRouting_a3ce17fb8675e93a607b491232471f685}{}\label{classns3_1_1Ipv4NixVectorRouting_a3ce17fb8675e93a607b491232471f685}

\begin{DoxyCode}
57 \{
58   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
59 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!B\+FS@{B\+FS}}
\index{B\+FS@{B\+FS}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{B\+F\+S(uint32\+\_\+t number\+Of\+Nodes, Ptr$<$ Node $>$ source, Ptr$<$ Node $>$ dest, std\+::vector$<$ Ptr$<$ Node $>$ $>$ \&parent\+Vector, Ptr$<$ Net\+Device $>$ oif)}{BFS(uint32_t numberOfNodes, Ptr< Node > source, Ptr< Node > dest, std::vector< Ptr< Node > > &parentVector, Ptr< NetDevice > oif)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::\+B\+FS (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{number\+Of\+Nodes, }
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{source, }
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{dest, }
\item[{std\+::vector$<$ {\bf Ptr}$<$ {\bf Node} $>$ $>$ \&}]{parent\+Vector, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{oif}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_aba4436060833304f21000470702da6d9}{}\label{classns3_1_1Ipv4NixVectorRouting_aba4436060833304f21000470702da6d9}

\begin{DoxyCode}
777 \{
778   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
779 
780   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Going from Node "} << source->\hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} () << \textcolor{stringliteral}{" to Node "} << dest->
      \hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} ());
781   std::queue< Ptr<Node> > greyNodeList;  \textcolor{comment}{// discovered nodes with unexplored children}
782 
783   \textcolor{comment}{// reset the parent vector}
784   parentVector.clear ();
785   parentVector.reserve (\textcolor{keyword}{sizeof} (Ptr<Node>)*numberOfNodes);
786   parentVector.insert (parentVector.begin (), \textcolor{keyword}{sizeof} (Ptr<Node>)*numberOfNodes, 0); \textcolor{comment}{// initialize to 0}
787 
788   \textcolor{comment}{// Add the source node to the queue, set its parent to itself }
789   greyNodeList.push (source);
790   parentVector.at (source->\hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} ()) = source;
791 
792   \textcolor{comment}{// BFS loop}
793   \textcolor{keywordflow}{while} (greyNodeList.size () != 0)
794     \{
795       Ptr<Node> currNode = greyNodeList.front ();
796       Ptr<Ipv4> ipv4 = currNode->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv4> ();
797  
798       \textcolor{keywordflow}{if} (currNode == dest) 
799         \{
800           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Made it to Node "} << currNode->GetId ());
801           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
802         \}
803 
804       \textcolor{comment}{// if this is the first iteration of the loop and a }
805       \textcolor{comment}{// specific output interface was given, make sure }
806       \textcolor{comment}{// we go this way}
807       \textcolor{keywordflow}{if} (currNode == source && oif)
808         \{
809           \textcolor{comment}{// make sure that we can go this way}
810           \textcolor{keywordflow}{if} (ipv4)
811             \{
812               uint32\_t interfaceIndex = (ipv4)->GetInterfaceForDevice (oif);
813               \textcolor{keywordflow}{if} (!(ipv4->IsUp (interfaceIndex)))
814                 \{
815                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Ipv4Interface is down"});
816                   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
817                 \}
818             \}
819           \textcolor{keywordflow}{if} (!(oif->IsLinkUp ()))
820             \{
821               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Link is down."});
822               \textcolor{keywordflow}{return} \textcolor{keyword}{false};
823             \}
824           Ptr<Channel> channel = oif->GetChannel ();
825           \textcolor{keywordflow}{if} (channel == 0)
826             \{ 
827               \textcolor{keywordflow}{return} \textcolor{keyword}{false};
828             \}
829 
830           \textcolor{comment}{// this function takes in the local net dev, and channnel, and}
831           \textcolor{comment}{// writes to the netDeviceContainer the adjacent net devs}
832           NetDeviceContainer netDeviceContainer;
833           \hyperlink{classns3_1_1Ipv4NixVectorRouting_a1037f3752d6583eca8cd83c72e0673ea}{GetAdjacentNetDevices} (oif, channel, netDeviceContainer);
834 
835           \textcolor{comment}{// Finally we can get the adjacent nodes}
836           \textcolor{comment}{// and scan through them.  We push them}
837           \textcolor{comment}{// to the greyNode queue, if they aren't }
838           \textcolor{comment}{// already there.}
839           \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1NetDeviceContainer_a45709bb572f975569ed985fa89b132f8}{NetDeviceContainer::Iterator} iter = netDeviceContainer.Begin ();
       iter != netDeviceContainer.End (); iter++)
840             \{
841               Ptr<Node> remoteNode = (*iter)->GetNode ();
842 
843               \textcolor{comment}{// check to see if this node has been pushed before}
844               \textcolor{comment}{// by checking to see if it has a parent}
845               \textcolor{comment}{// if it doesn't (null or 0), then set its parent and }
846               \textcolor{comment}{// push to the queue}
847               \textcolor{keywordflow}{if} (parentVector.at (remoteNode->GetId ()) == 0)
848                 \{
849                   parentVector.at (remoteNode->GetId ()) = currNode;
850                   greyNodeList.push (remoteNode);
851                 \}
852             \}
853         \}
854       \textcolor{keywordflow}{else}
855         \{
856           \textcolor{comment}{// Iterate over the current node's adjacent vertices}
857           \textcolor{comment}{// and push them into the queue}
858           \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < (currNode->GetNDevices ()); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
859             \{
860               \textcolor{comment}{// Get a net device from the node}
861               \textcolor{comment}{// as well as the channel, and figure}
862               \textcolor{comment}{// out the adjacent net device}
863               Ptr<NetDevice> localNetDevice = currNode->GetDevice (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
864 
865               \textcolor{comment}{// make sure that we can go this way}
866               \textcolor{keywordflow}{if} (ipv4)
867                 \{
868                   uint32\_t interfaceIndex = (ipv4)->GetInterfaceForDevice (currNode->GetDevice (
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}));
869                   \textcolor{keywordflow}{if} (!(ipv4->IsUp (interfaceIndex)))
870                     \{
871                       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Ipv4Interface is down"});
872                       \textcolor{keywordflow}{continue};
873                     \}
874                 \}
875               \textcolor{keywordflow}{if} (!(localNetDevice->IsLinkUp ()))
876                 \{
877                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Link is down."});
878                   \textcolor{keywordflow}{continue};
879                 \}
880               Ptr<Channel> channel = localNetDevice->GetChannel ();
881               \textcolor{keywordflow}{if} (channel == 0)
882                 \{ 
883                   \textcolor{keywordflow}{continue};
884                 \}
885 
886               \textcolor{comment}{// this function takes in the local net dev, and channnel, and}
887               \textcolor{comment}{// writes to the netDeviceContainer the adjacent net devs}
888               NetDeviceContainer netDeviceContainer;
889               \hyperlink{classns3_1_1Ipv4NixVectorRouting_a1037f3752d6583eca8cd83c72e0673ea}{GetAdjacentNetDevices} (localNetDevice, channel, netDeviceContainer);
890 
891               \textcolor{comment}{// Finally we can get the adjacent nodes}
892               \textcolor{comment}{// and scan through them.  We push them}
893               \textcolor{comment}{// to the greyNode queue, if they aren't }
894               \textcolor{comment}{// already there.}
895               \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1NetDeviceContainer_a45709bb572f975569ed985fa89b132f8}{NetDeviceContainer::Iterator} iter = netDeviceContainer.Begin
       (); iter != netDeviceContainer.End (); iter++)
896                 \{
897                   Ptr<Node> remoteNode = (*iter)->GetNode ();
898 
899                   \textcolor{comment}{// check to see if this node has been pushed before}
900                   \textcolor{comment}{// by checking to see if it has a parent}
901                   \textcolor{comment}{// if it doesn't (null or 0), then set its parent and }
902                   \textcolor{comment}{// push to the queue}
903                   \textcolor{keywordflow}{if} (parentVector.at (remoteNode->GetId ()) == 0)
904                     \{
905                       parentVector.at (remoteNode->GetId ()) = currNode;
906                       greyNodeList.push (remoteNode);
907                     \}
908                 \}
909             \}
910         \}
911 
912       \textcolor{comment}{// Pop off the head grey node.  We have all its children.}
913       \textcolor{comment}{// It is now black.}
914       greyNodeList.pop ();
915     \}
916 
917   \textcolor{comment}{// Didn't find the dest...}
918   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
919 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2




Here is the caller graph for this function\+:
% FIG 3


\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!Build\+Nix\+Vector@{Build\+Nix\+Vector}}
\index{Build\+Nix\+Vector@{Build\+Nix\+Vector}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{Build\+Nix\+Vector(const std\+::vector$<$ Ptr$<$ Node $>$ $>$ \&parent\+Vector, uint32\+\_\+t source, uint32\+\_\+t dest, Ptr$<$ Nix\+Vector $>$ nix\+Vector)}{BuildNixVector(const std::vector< Ptr< Node > > &parentVector, uint32_t source, uint32_t dest, Ptr< NixVector > nixVector)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::\+Build\+Nix\+Vector (
\begin{DoxyParamCaption}
\item[{const std\+::vector$<$ {\bf Ptr}$<$ {\bf Node} $>$ $>$ \&}]{parent\+Vector, }
\item[{uint32\+\_\+t}]{source, }
\item[{uint32\+\_\+t}]{dest, }
\item[{{\bf Ptr}$<$ {\bf Nix\+Vector} $>$}]{nix\+Vector}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_ac797bda1b70ad4c4aa7e8d5729a50455}{}\label{classns3_1_1Ipv4NixVectorRouting_ac797bda1b70ad4c4aa7e8d5729a50455}

\begin{DoxyCode}
234 \{
235   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
236 
237   \textcolor{keywordflow}{if} (source == dest)
238     \{
239       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
240     \}
241 
242   \textcolor{keywordflow}{if} (parentVector.at (dest) == 0)
243     \{
244       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
245     \}
246 
247   Ptr<Node> parentNode = parentVector.at (dest);
248 
249   uint32\_t numberOfDevices = parentNode->GetNDevices ();
250   uint32\_t destId = 0;
251   uint32\_t totalNeighbors = 0;
252 
253   \textcolor{comment}{// scan through the net devices on the parent node}
254   \textcolor{comment}{// and then look at the nodes adjacent to them}
255   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < numberOfDevices; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
256     \{
257       \textcolor{comment}{// Get a net device from the node}
258       \textcolor{comment}{// as well as the channel, and figure}
259       \textcolor{comment}{// out the adjacent net devices}
260       Ptr<NetDevice> localNetDevice = parentNode->GetDevice (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
261       \textcolor{keywordflow}{if} (localNetDevice->IsBridge ())
262         \{
263           \textcolor{keywordflow}{continue};
264         \}
265       Ptr<Channel> channel = localNetDevice->GetChannel ();
266       \textcolor{keywordflow}{if} (channel == 0)
267         \{
268           \textcolor{keywordflow}{continue};
269         \}
270 
271       \textcolor{comment}{// this function takes in the local net dev, and channnel, and}
272       \textcolor{comment}{// writes to the netDeviceContainer the adjacent net devs}
273       NetDeviceContainer netDeviceContainer;
274       \hyperlink{classns3_1_1Ipv4NixVectorRouting_a1037f3752d6583eca8cd83c72e0673ea}{GetAdjacentNetDevices} (localNetDevice, channel, netDeviceContainer);
275 
276       \textcolor{comment}{// Finally we can get the adjacent nodes}
277       \textcolor{comment}{// and scan through them.  If we find the }
278       \textcolor{comment}{// node that matches "dest" then we can add }
279       \textcolor{comment}{// the index  to the nix vector.}
280       \textcolor{comment}{// the index corresponds to the neighbor index}
281       uint32\_t offset = 0;
282       \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1NetDeviceContainer_a45709bb572f975569ed985fa89b132f8}{NetDeviceContainer::Iterator} iter = netDeviceContainer.Begin (); 
      iter != netDeviceContainer.End (); iter++)
283         \{
284           Ptr<Node> remoteNode = (*iter)->GetNode ();
285 
286           \textcolor{keywordflow}{if} (remoteNode->GetId () == dest)
287             \{
288               destId = totalNeighbors + offset;
289             \}
290           offset += 1;
291         \}
292 
293       totalNeighbors += netDeviceContainer.GetN ();
294     \}
295   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Adding Nix: "} << destId << \textcolor{stringliteral}{" with "} 
296                                << nixVector->BitCount (totalNeighbors) << \textcolor{stringliteral}{" bits, for node "} << parentNode
      ->GetId ());
297   nixVector->AddNeighborIndex (destId, nixVector->BitCount (totalNeighbors));
298 
299   \textcolor{comment}{// recurse through parent vector, grabbing the path }
300   \textcolor{comment}{// and building the nix vector}
301   \hyperlink{classns3_1_1Ipv4NixVectorRouting_ac797bda1b70ad4c4aa7e8d5729a50455}{BuildNixVector} (parentVector, source, (parentVector.at (dest))->GetId (), nixVector);
302   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
303 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4




Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!Build\+Nix\+Vector\+Local@{Build\+Nix\+Vector\+Local}}
\index{Build\+Nix\+Vector\+Local@{Build\+Nix\+Vector\+Local}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{Build\+Nix\+Vector\+Local(\+Ptr$<$ Nix\+Vector $>$ nix\+Vector)}{BuildNixVectorLocal(Ptr< NixVector > nixVector)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::\+Build\+Nix\+Vector\+Local (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Nix\+Vector} $>$}]{nix\+Vector}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_a86ca754bc22b1714ffe7a4b858cda72d}{}\label{classns3_1_1Ipv4NixVectorRouting_a86ca754bc22b1714ffe7a4b858cda72d}

\begin{DoxyCode}
207 \{
208   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
209 
210   uint32\_t numberOfDevices = \hyperlink{classns3_1_1Ipv4NixVectorRouting_a329265b09f4d85bac6ec9bd0ec2daa92}{m\_node}->\hyperlink{classns3_1_1Node_a531554d2241ba4fa1cd74e3360be6bce}{GetNDevices} ();
211 
212   \textcolor{comment}{// here we are building a nix vector to }
213   \textcolor{comment}{// ourself, so we need to find the loopback }
214   \textcolor{comment}{// interface and add that to the nix vector}
215   Ipv4Address loopback (\textcolor{stringliteral}{"127.0.0.1"});
216   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < numberOfDevices; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
217     \{
218       uint32\_t interfaceIndex = (\hyperlink{classns3_1_1Ipv4NixVectorRouting_a215cb71f30d85df9ec7176ca22620519}{m\_ipv4})->GetInterfaceForDevice (\hyperlink{classns3_1_1Ipv4NixVectorRouting_a329265b09f4d85bac6ec9bd0ec2daa92}{m\_node}->
      \hyperlink{classns3_1_1Node_a5918dfd24ef632efc9a83a5f6561c76e}{GetDevice} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}));
219       Ipv4InterfaceAddress ifAddr = \hyperlink{classns3_1_1Ipv4NixVectorRouting_a215cb71f30d85df9ec7176ca22620519}{m\_ipv4}->GetAddress (interfaceIndex, 0);
220       \textcolor{keywordflow}{if} (ifAddr.GetLocal () == loopback)
221         \{
222           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Adding loopback to nix."});
223           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Adding Nix: "} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} << \textcolor{stringliteral}{" with "} << nixVector->BitCount (
      numberOfDevices) 
224                                        << \textcolor{stringliteral}{" bits, for node "} << \hyperlink{classns3_1_1Ipv4NixVectorRouting_a329265b09f4d85bac6ec9bd0ec2daa92}{m\_node}->
      \hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} ());
225           nixVector->AddNeighborIndex (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, nixVector->BitCount (numberOfDevices));
226           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
227         \}
228     \}
229   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
230 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6


\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!Check\+Cache\+State\+And\+Flush@{Check\+Cache\+State\+And\+Flush}}
\index{Check\+Cache\+State\+And\+Flush@{Check\+Cache\+State\+And\+Flush}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{Check\+Cache\+State\+And\+Flush(void) const }{CheckCacheStateAndFlush(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::\+Check\+Cache\+State\+And\+Flush (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_aeeafd72dfb17da8349627232c9e9984f}{}\label{classns3_1_1Ipv4NixVectorRouting_aeeafd72dfb17da8349627232c9e9984f}

\begin{DoxyCode}
923 \{
924   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4NixVectorRouting_a7b75edeb473c9fe1595b59d9800c5bab}{g\_isCacheDirty})
925     \{
926       \hyperlink{classns3_1_1Ipv4NixVectorRouting_acbd7460ba116c4b5ff830fb1d60a13ea}{FlushGlobalNixRoutingCache} ();
927       \hyperlink{classns3_1_1Ipv4NixVectorRouting_a7b75edeb473c9fe1595b59d9800c5bab}{g\_isCacheDirty} = \textcolor{keyword}{false};
928     \}
929 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7




Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{Do\+Dispose(void)}{DoDispose(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_a56f3712cab7976e071d487eb686c9280}{}\label{classns3_1_1Ipv4NixVectorRouting_a56f3712cab7976e071d487eb686c9280}
Destructor implementation.

This method is called by \hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose()} or by the \hyperlink{classns3_1_1Object}{Object}\textquotesingle{}s destructor, whichever comes first.

Subclasses are expected to implement their real destruction code in an overriden version of this method and chain up to their parent\textquotesingle{}s implementation once they are done. {\itshape i.\+e}, for simplicity, the destructor of every subclass should be empty and its content should be moved to the associated \hyperlink{classns3_1_1Ipv4NixVectorRouting_a56f3712cab7976e071d487eb686c9280}{Do\+Dispose()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.


\begin{DoxyCode}
73 \{
74   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
75 
76   \hyperlink{classns3_1_1Ipv4NixVectorRouting_a329265b09f4d85bac6ec9bd0ec2daa92}{m\_node} = 0;
77   \hyperlink{classns3_1_1Ipv4NixVectorRouting_a215cb71f30d85df9ec7176ca22620519}{m\_ipv4} = 0;
78 
79   \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{Ipv4RoutingProtocol::DoDispose} ();
80 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9


\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!Find\+Net\+Device\+For\+Nix\+Index@{Find\+Net\+Device\+For\+Nix\+Index}}
\index{Find\+Net\+Device\+For\+Nix\+Index@{Find\+Net\+Device\+For\+Nix\+Index}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{Find\+Net\+Device\+For\+Nix\+Index(uint32\+\_\+t node\+Index, Ipv4\+Address \&gateway\+Ip)}{FindNetDeviceForNixIndex(uint32_t nodeIndex, Ipv4Address &gatewayIp)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::\+Find\+Net\+Device\+For\+Nix\+Index (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{node\+Index, }
\item[{{\bf Ipv4\+Address} \&}]{gateway\+Ip}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_abbd212141a650d5260455663d59c24c9}{}\label{classns3_1_1Ipv4NixVectorRouting_abbd212141a650d5260455663d59c24c9}

\begin{DoxyCode}
446 \{
447   uint32\_t numberOfDevices = \hyperlink{classns3_1_1Ipv4NixVectorRouting_a329265b09f4d85bac6ec9bd0ec2daa92}{m\_node}->\hyperlink{classns3_1_1Node_a531554d2241ba4fa1cd74e3360be6bce}{GetNDevices} ();
448   uint32\_t index = 0;
449   uint32\_t totalNeighbors = 0;
450 
451   \textcolor{comment}{// scan through the net devices on the parent node}
452   \textcolor{comment}{// and then look at the nodes adjacent to them}
453   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < numberOfDevices; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
454     \{
455       \textcolor{comment}{// Get a net device from the node}
456       \textcolor{comment}{// as well as the channel, and figure}
457       \textcolor{comment}{// out the adjacent net devices}
458       Ptr<NetDevice> localNetDevice = \hyperlink{classns3_1_1Ipv4NixVectorRouting_a329265b09f4d85bac6ec9bd0ec2daa92}{m\_node}->\hyperlink{classns3_1_1Node_a5918dfd24ef632efc9a83a5f6561c76e}{GetDevice} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
459       Ptr<Channel> channel = localNetDevice->GetChannel ();
460       \textcolor{keywordflow}{if} (channel == 0)
461         \{
462           \textcolor{keywordflow}{continue};
463         \}
464 
465       \textcolor{comment}{// this function takes in the local net dev, and channnel, and}
466       \textcolor{comment}{// writes to the netDeviceContainer the adjacent net devs}
467       NetDeviceContainer netDeviceContainer;
468       \hyperlink{classns3_1_1Ipv4NixVectorRouting_a1037f3752d6583eca8cd83c72e0673ea}{GetAdjacentNetDevices} (localNetDevice, channel, netDeviceContainer);
469 
470       \textcolor{comment}{// check how many neighbors we have}
471       \textcolor{keywordflow}{if} (nodeIndex < (totalNeighbors + netDeviceContainer.GetN ()))
472         \{
473           \textcolor{comment}{// found the proper net device}
474           index = \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
475           Ptr<NetDevice> gatewayDevice = netDeviceContainer.Get (nodeIndex-totalNeighbors);
476           Ptr<Node> gatewayNode = gatewayDevice->GetNode ();
477           Ptr<Ipv4> ipv4 = gatewayNode->GetObject<Ipv4> ();
478 
479           uint32\_t interfaceIndex = (ipv4)->GetInterfaceForDevice (gatewayDevice);
480           Ipv4InterfaceAddress ifAddr = ipv4->GetAddress (interfaceIndex, 0);
481           gatewayIp = ifAddr.GetLocal ();
482           \textcolor{keywordflow}{break};
483         \}
484       totalNeighbors += netDeviceContainer.GetN ();
485     \}
486 
487   \textcolor{keywordflow}{return} index;
488 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10




Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!Find\+Total\+Neighbors@{Find\+Total\+Neighbors}}
\index{Find\+Total\+Neighbors@{Find\+Total\+Neighbors}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{Find\+Total\+Neighbors(void)}{FindTotalNeighbors(void)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::\+Find\+Total\+Neighbors (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_ae4d125bd51c2d70084543489f00060b5}{}\label{classns3_1_1Ipv4NixVectorRouting_ae4d125bd51c2d70084543489f00060b5}

\begin{DoxyCode}
375 \{
376   uint32\_t numberOfDevices = \hyperlink{classns3_1_1Ipv4NixVectorRouting_a329265b09f4d85bac6ec9bd0ec2daa92}{m\_node}->\hyperlink{classns3_1_1Node_a531554d2241ba4fa1cd74e3360be6bce}{GetNDevices} ();
377   uint32\_t totalNeighbors = 0;
378 
379   \textcolor{comment}{// scan through the net devices on the parent node}
380   \textcolor{comment}{// and then look at the nodes adjacent to them}
381   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < numberOfDevices; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
382     \{
383       \textcolor{comment}{// Get a net device from the node}
384       \textcolor{comment}{// as well as the channel, and figure}
385       \textcolor{comment}{// out the adjacent net devices}
386       Ptr<NetDevice> localNetDevice = \hyperlink{classns3_1_1Ipv4NixVectorRouting_a329265b09f4d85bac6ec9bd0ec2daa92}{m\_node}->\hyperlink{classns3_1_1Node_a5918dfd24ef632efc9a83a5f6561c76e}{GetDevice} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
387       Ptr<Channel> channel = localNetDevice->GetChannel ();
388       \textcolor{keywordflow}{if} (channel == 0)
389         \{
390           \textcolor{keywordflow}{continue};
391         \}
392 
393       \textcolor{comment}{// this function takes in the local net dev, and channnel, and}
394       \textcolor{comment}{// writes to the netDeviceContainer the adjacent net devs}
395       NetDeviceContainer netDeviceContainer;
396       \hyperlink{classns3_1_1Ipv4NixVectorRouting_a1037f3752d6583eca8cd83c72e0673ea}{GetAdjacentNetDevices} (localNetDevice, channel, netDeviceContainer);
397 
398       totalNeighbors += netDeviceContainer.GetN ();
399     \}
400 
401   \textcolor{keywordflow}{return} totalNeighbors;
402 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12




Here is the caller graph for this function\+:
% FIG 13


\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!Flush\+Global\+Nix\+Routing\+Cache@{Flush\+Global\+Nix\+Routing\+Cache}}
\index{Flush\+Global\+Nix\+Routing\+Cache@{Flush\+Global\+Nix\+Routing\+Cache}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{Flush\+Global\+Nix\+Routing\+Cache(void) const }{FlushGlobalNixRoutingCache(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::\+Flush\+Global\+Nix\+Routing\+Cache (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv4NixVectorRouting_acbd7460ba116c4b5ff830fb1d60a13ea}{}\label{classns3_1_1Ipv4NixVectorRouting_acbd7460ba116c4b5ff830fb1d60a13ea}


Called when run-\/time link topology change occurs which iterates through the node list and flushes any nix vector caches. 


\begin{DoxyCode}
93 \{
94   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
95   \hyperlink{classns3_1_1NodeList_a9e2679a94efb4f0066cc21e65440364d}{NodeList::Iterator} listEnd = \hyperlink{classns3_1_1NodeList_a027a558c16e6078e25c7ffc67becb559}{NodeList::End} ();
96   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1NodeList_a9e2679a94efb4f0066cc21e65440364d}{NodeList::Iterator} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1NodeList_a93d2211831f5cb71d1dbb721e2721d7f}{NodeList::Begin} (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != listEnd; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
97     \{
98       Ptr<Node> node = *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
99       Ptr<Ipv4NixVectorRouting> rp = node->GetObject<\hyperlink{classns3_1_1Ipv4NixVectorRouting_a0aa865407f4e446e5afb3c83e718e9c7}{Ipv4NixVectorRouting}> ();
100       \textcolor{keywordflow}{if} (!rp)
101         \{
102           \textcolor{keywordflow}{continue};
103         \}
104       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Flushing Nix caches."});
105       rp->FlushNixCache ();
106       rp->FlushIpv4RouteCache ();
107     \}
108 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 14




Here is the caller graph for this function\+:
% FIG 15


\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!Flush\+Ipv4\+Route\+Cache@{Flush\+Ipv4\+Route\+Cache}}
\index{Flush\+Ipv4\+Route\+Cache@{Flush\+Ipv4\+Route\+Cache}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{Flush\+Ipv4\+Route\+Cache(void) const }{FlushIpv4RouteCache(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::\+Flush\+Ipv4\+Route\+Cache (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_a327dbe773d1e4a06f732da45d34e15d7}{}\label{classns3_1_1Ipv4NixVectorRouting_a327dbe773d1e4a06f732da45d34e15d7}

\begin{DoxyCode}
119 \{
120   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
121   \hyperlink{classns3_1_1Ipv4NixVectorRouting_aeb85361b66489c60851f72f1493fdee7}{m\_ipv4RouteCache}.clear ();
122 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!Flush\+Nix\+Cache@{Flush\+Nix\+Cache}}
\index{Flush\+Nix\+Cache@{Flush\+Nix\+Cache}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{Flush\+Nix\+Cache(void) const }{FlushNixCache(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::\+Flush\+Nix\+Cache (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_a25fb80fd82a26e8b5e33aa953a026723}{}\label{classns3_1_1Ipv4NixVectorRouting_a25fb80fd82a26e8b5e33aa953a026723}

\begin{DoxyCode}
112 \{
113   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
114   \hyperlink{classns3_1_1Ipv4NixVectorRouting_a394e830e592aa6ef064be362150219f2}{m\_nixCache}.clear ();
115 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!Get\+Adjacent\+Net\+Devices@{Get\+Adjacent\+Net\+Devices}}
\index{Get\+Adjacent\+Net\+Devices@{Get\+Adjacent\+Net\+Devices}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Adjacent\+Net\+Devices(\+Ptr$<$ Net\+Device $>$, Ptr$<$ Channel $>$, Net\+Device\+Container \&)}{GetAdjacentNetDevices(Ptr< NetDevice >, Ptr< Channel >, NetDeviceContainer &)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::\+Get\+Adjacent\+Net\+Devices (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{net\+Device, }
\item[{{\bf Ptr}$<$ {\bf Channel} $>$}]{channel, }
\item[{{\bf Net\+Device\+Container} \&}]{net\+Device\+Container}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_a1037f3752d6583eca8cd83c72e0673ea}{}\label{classns3_1_1Ipv4NixVectorRouting_a1037f3752d6583eca8cd83c72e0673ea}

\begin{DoxyCode}
307 \{
308   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
309 
310   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < channel->GetNDevices (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
311     \{
312       Ptr<NetDevice> remoteDevice = channel->GetDevice (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
313       \textcolor{keywordflow}{if} (remoteDevice != netDevice)
314         \{
315           Ptr<BridgeNetDevice> bd = \hyperlink{classns3_1_1Ipv4NixVectorRouting_abf47d63e2dbb8022a042743feeb569c6}{NetDeviceIsBridged} (remoteDevice);
316           \textcolor{comment}{// we have a bridged device, we need to add all }
317           \textcolor{comment}{// bridged devices}
318           \textcolor{keywordflow}{if} (bd)
319             \{
320               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Looking through bridge ports of bridge net device "} << bd);
321               \textcolor{keywordflow}{for} (uint32\_t j = 0; j < bd->GetNBridgePorts (); ++j)
322                 \{
323                   Ptr<NetDevice> ndBridged = bd->GetBridgePort (j);
324                   \textcolor{keywordflow}{if} (ndBridged == remoteDevice)
325                     \{
326                       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"That bridge port is me, don't walk backward"});
327                       \textcolor{keywordflow}{continue};
328                     \}
329                   Ptr<Channel> chBridged = ndBridged->GetChannel ();
330                   \textcolor{keywordflow}{if} (chBridged == 0)
331                     \{
332                       \textcolor{keywordflow}{continue};
333                     \}
334                   \hyperlink{classns3_1_1Ipv4NixVectorRouting_a1037f3752d6583eca8cd83c72e0673ea}{GetAdjacentNetDevices} (ndBridged, chBridged, netDeviceContainer);
335                 \}
336             \}
337           \textcolor{keywordflow}{else}
338             \{
339               netDeviceContainer.Add (channel->GetDevice (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}));
340             \}
341         \}
342     \}
343 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 16




Here is the caller graph for this function\+:
% FIG 17


\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!Get\+Ipv4\+Route\+In\+Cache@{Get\+Ipv4\+Route\+In\+Cache}}
\index{Get\+Ipv4\+Route\+In\+Cache@{Get\+Ipv4\+Route\+In\+Cache}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Ipv4\+Route\+In\+Cache(\+Ipv4\+Address)}{GetIpv4RouteInCache(Ipv4Address)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv4\+Route} $>$ ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::\+Get\+Ipv4\+Route\+In\+Cache (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_a1d352caa92d6d91e6cb94ecc31be4411}{}\label{classns3_1_1Ipv4NixVectorRouting_a1d352caa92d6d91e6cb94ecc31be4411}

\begin{DoxyCode}
189 \{
190   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
191 
192   \hyperlink{classns3_1_1Ipv4NixVectorRouting_aeeafd72dfb17da8349627232c9e9984f}{CheckCacheStateAndFlush} ();
193 
194   Ipv4RouteMap\_t::iterator iter = \hyperlink{classns3_1_1Ipv4NixVectorRouting_aeb85361b66489c60851f72f1493fdee7}{m\_ipv4RouteCache}.find (address);
195   \textcolor{keywordflow}{if} (iter != \hyperlink{classns3_1_1Ipv4NixVectorRouting_aeb85361b66489c60851f72f1493fdee7}{m\_ipv4RouteCache}.end ())
196     \{
197       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Found Ipv4Route in cache."});
198       \textcolor{keywordflow}{return} iter->second;
199     \}
200 
201   \textcolor{comment}{// not in cache}
202   \textcolor{keywordflow}{return} 0;
203 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 18




Here is the caller graph for this function\+:
% FIG 19


\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!Get\+Nix\+Vector@{Get\+Nix\+Vector}}
\index{Get\+Nix\+Vector@{Get\+Nix\+Vector}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Nix\+Vector(\+Ptr$<$ Node $>$, Ipv4\+Address, Ptr$<$ Net\+Device $>$)}{GetNixVector(Ptr< Node >, Ipv4Address, Ptr< NetDevice >)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Nix\+Vector} $>$ ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::\+Get\+Nix\+Vector (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{source, }
\item[{{\bf Ipv4\+Address}}]{dest, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{oif}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_ad1f618c1b1264f0d01644b9a68a0bd20}{}\label{classns3_1_1Ipv4NixVectorRouting_ad1f618c1b1264f0d01644b9a68a0bd20}

\begin{DoxyCode}
126 \{
127   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
128 
129   Ptr<NixVector> nixVector = Create<NixVector> ();
130 
131   \textcolor{comment}{// not in cache, must build the nix vector}
132   \textcolor{comment}{// First, we have to figure out the nodes }
133   \textcolor{comment}{// associated with these IPs}
134   Ptr<Node> destNode = \hyperlink{classns3_1_1Ipv4NixVectorRouting_a24d3474ebcb1fc7da5a133dc071cd2df}{GetNodeByIp} (dest);
135   \textcolor{keywordflow}{if} (destNode == 0)
136     \{
137       \hyperlink{group__logging_ga0261a8db1d4ac5f79417d117634fd455}{NS\_LOG\_ERROR} (\textcolor{stringliteral}{"No routing path exists"});
138       \textcolor{keywordflow}{return} 0;
139     \}
140 
141   \textcolor{comment}{// if source == dest, then we have a special case}
144 \textcolor{comment}{}  \textcolor{keywordflow}{if} (source == destNode)
145     \{
146       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Do not process packets to self"});
147       \textcolor{keywordflow}{return} 0;
148     \}
149   \textcolor{keywordflow}{else}
150     \{
151       \textcolor{comment}{// otherwise proceed as normal }
152       \textcolor{comment}{// and build the nix vector}
153       std::vector< Ptr<Node> > parentVector;
154 
155       \hyperlink{classns3_1_1Ipv4NixVectorRouting_aba4436060833304f21000470702da6d9}{BFS} (\hyperlink{classns3_1_1NodeList_a1d110b1670005895dd5812baab13682a}{NodeList::GetNNodes} (), source, destNode, parentVector, oif);
156 
157       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4NixVectorRouting_ac797bda1b70ad4c4aa7e8d5729a50455}{BuildNixVector} (parentVector, source->\hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} (), destNode->GetId (), nixVector)
      )
158         \{
159           \textcolor{keywordflow}{return} nixVector;
160         \}
161       \textcolor{keywordflow}{else}
162         \{
163           \hyperlink{group__logging_ga0261a8db1d4ac5f79417d117634fd455}{NS\_LOG\_ERROR} (\textcolor{stringliteral}{"No routing path exists"});
164           \textcolor{keywordflow}{return} 0;
165         \}
166     \}
167 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 20




Here is the caller graph for this function\+:
% FIG 21


\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!Get\+Nix\+Vector\+In\+Cache@{Get\+Nix\+Vector\+In\+Cache}}
\index{Get\+Nix\+Vector\+In\+Cache@{Get\+Nix\+Vector\+In\+Cache}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Nix\+Vector\+In\+Cache(\+Ipv4\+Address)}{GetNixVectorInCache(Ipv4Address)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Nix\+Vector} $>$ ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::\+Get\+Nix\+Vector\+In\+Cache (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_afeecd07d75e1fda9a99d1f914ec331ce}{}\label{classns3_1_1Ipv4NixVectorRouting_afeecd07d75e1fda9a99d1f914ec331ce}

\begin{DoxyCode}
171 \{
172   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
173 
174   \hyperlink{classns3_1_1Ipv4NixVectorRouting_aeeafd72dfb17da8349627232c9e9984f}{CheckCacheStateAndFlush} ();
175 
176   NixMap\_t::iterator iter = \hyperlink{classns3_1_1Ipv4NixVectorRouting_a394e830e592aa6ef064be362150219f2}{m\_nixCache}.find (address);
177   \textcolor{keywordflow}{if} (iter != \hyperlink{classns3_1_1Ipv4NixVectorRouting_a394e830e592aa6ef064be362150219f2}{m\_nixCache}.end ())
178     \{
179       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Found Nix-vector in cache."});
180       \textcolor{keywordflow}{return} iter->second;
181     \}
182 
183   \textcolor{comment}{// not in cache}
184   \textcolor{keywordflow}{return} 0;
185 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 22




Here is the caller graph for this function\+:
% FIG 23


\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!Get\+Node\+By\+Ip@{Get\+Node\+By\+Ip}}
\index{Get\+Node\+By\+Ip@{Get\+Node\+By\+Ip}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Node\+By\+Ip(\+Ipv4\+Address)}{GetNodeByIp(Ipv4Address)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Node} $>$ ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::\+Get\+Node\+By\+Ip (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{dest}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_a24d3474ebcb1fc7da5a133dc071cd2df}{}\label{classns3_1_1Ipv4NixVectorRouting_a24d3474ebcb1fc7da5a133dc071cd2df}

\begin{DoxyCode}
347 \{ 
348   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
349 
350   NodeContainer allNodes = \hyperlink{classns3_1_1NodeContainer_a687e8f9ceb74d0ce3b06591c9f44c9ed}{NodeContainer::GetGlobal} ();
351   Ptr<Node> destNode;
352 
353   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1NodeContainer_aa1a9f2d2b09bfef7d066d3974bca2cc4}{NodeContainer::Iterator} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = allNodes.Begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != allNodes.End (); ++
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
354     \{
355       Ptr<Node> node = *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
356       Ptr<Ipv4> ipv4 = node->GetObject<Ipv4> ();
357       \textcolor{keywordflow}{if} (ipv4->GetInterfaceForAddress (dest) != -1)
358         \{
359           destNode = node;
360           \textcolor{keywordflow}{break};
361         \}
362     \}
363 
364   \textcolor{keywordflow}{if} (!destNode)
365     \{
366       \hyperlink{group__logging_ga0261a8db1d4ac5f79417d117634fd455}{NS\_LOG\_ERROR} (\textcolor{stringliteral}{"Couldn't find dest node given the IP"} << dest);
367       \textcolor{keywordflow}{return} 0;
368     \}
369 
370   \textcolor{keywordflow}{return} destNode;
371 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 24




Here is the caller graph for this function\+:
% FIG 25


\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_aeebea623bb7d67844520b2c340c4628c}{}\label{classns3_1_1Ipv4NixVectorRouting_aeebea623bb7d67844520b2c340c4628c}


The Interface ID of the Global Router interface. 

\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Object\+::\+Get\+Object} () 
\end{DoxySeeAlso}

\begin{DoxyCode}
41 \{
42   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::Ipv4NixVectorRouting"})
43     .SetParent<Ipv4RoutingProtocol> ()
44     .SetGroupName (\textcolor{stringliteral}{"NixVectorRouting"})
45     .AddConstructor<\hyperlink{classns3_1_1Ipv4NixVectorRouting_a0aa865407f4e446e5afb3c83e718e9c7}{Ipv4NixVectorRouting}> ()
46   ;
47   \textcolor{keywordflow}{return} tid;
48 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 26


\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!Net\+Device\+Is\+Bridged@{Net\+Device\+Is\+Bridged}}
\index{Net\+Device\+Is\+Bridged@{Net\+Device\+Is\+Bridged}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{Net\+Device\+Is\+Bridged(\+Ptr$<$ Net\+Device $>$ nd) const }{NetDeviceIsBridged(Ptr< NetDevice > nd) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Bridge\+Net\+Device} $>$ ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::\+Net\+Device\+Is\+Bridged (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{nd}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_abf47d63e2dbb8022a042743feeb569c6}{}\label{classns3_1_1Ipv4NixVectorRouting_abf47d63e2dbb8022a042743feeb569c6}

\begin{DoxyCode}
406 \{
407   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (nd);
408 
409   Ptr<Node> node = nd->GetNode ();
410   uint32\_t nDevices = node->GetNDevices ();
411 
412   \textcolor{comment}{//}
413   \textcolor{comment}{// There is no bit on a net device that says it is being bridged, so we have}
414   \textcolor{comment}{// to look for bridges on the node to which the device is attached.  If we}
415   \textcolor{comment}{// find a bridge, we need to look through its bridge ports (the devices it}
416   \textcolor{comment}{// bridges) to see if we find the device in question.}
417   \textcolor{comment}{//}
418   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < nDevices; ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
419     \{
420       Ptr<NetDevice> ndTest = node->GetDevice (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
421       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Examine device "} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} << \textcolor{stringliteral}{" "} << ndTest);
422 
423       \textcolor{keywordflow}{if} (ndTest->IsBridge ())
424         \{
425           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"device "} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} << \textcolor{stringliteral}{" is a bridge net device"});
426           Ptr<BridgeNetDevice> bnd = ndTest->GetObject<BridgeNetDevice> ();
427           \hyperlink{group__fatal_ga0bd3f62c55e7347ff814572f3aaa3864}{NS\_ABORT\_MSG\_UNLESS} (bnd, \textcolor{stringliteral}{"Ipv4NixVectorRouting::NetDeviceIsBridged ():
       GetObject for <BridgeNetDevice> failed"});
428 
429           \textcolor{keywordflow}{for} (uint32\_t j = 0; j < bnd->GetNBridgePorts (); ++j)
430             \{
431               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Examine bridge port "} << j << \textcolor{stringliteral}{" "} << bnd->GetBridgePort (j));
432               \textcolor{keywordflow}{if} (bnd->GetBridgePort (j) == nd)
433                 \{
434                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Net device "} << nd << \textcolor{stringliteral}{" is bridged by "} << bnd);
435                   \textcolor{keywordflow}{return} bnd;
436                 \}
437             \}
438         \}
439     \}
440   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Net device "} << nd << \textcolor{stringliteral}{" is not bridged"});
441   \textcolor{keywordflow}{return} 0;
442 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 27




Here is the caller graph for this function\+:
% FIG 28


\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!Notify\+Add\+Address@{Notify\+Add\+Address}}
\index{Notify\+Add\+Address@{Notify\+Add\+Address}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{Notify\+Add\+Address(uint32\+\_\+t interface, Ipv4\+Interface\+Address address)}{NotifyAddAddress(uint32_t interface, Ipv4InterfaceAddress address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::\+Notify\+Add\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv4\+Interface\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_a045c6307b4b2c6956471073066a48b16}{}\label{classns3_1_1Ipv4NixVectorRouting_a045c6307b4b2c6956471073066a48b16}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
{\em address} & a new address being added to an interface\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified whenever a new address is added to an interface. Typically used to add a \textquotesingle{}network route\textquotesingle{} on an interface. Can be invoked on an up or down interface. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_aef12fcf9cc478536876b0281505d40aa}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
764 \{
765   \hyperlink{classns3_1_1Ipv4NixVectorRouting_a7b75edeb473c9fe1595b59d9800c5bab}{g\_isCacheDirty} = \textcolor{keyword}{true};
766 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!Notify\+Interface\+Down@{Notify\+Interface\+Down}}
\index{Notify\+Interface\+Down@{Notify\+Interface\+Down}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{Notify\+Interface\+Down(uint32\+\_\+t interface)}{NotifyInterfaceDown(uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::\+Notify\+Interface\+Down (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_a4b9bfdc6d15165db72aa091f11fa899e}{}\label{classns3_1_1Ipv4NixVectorRouting_a4b9bfdc6d15165db72aa091f11fa899e}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified of the state change of an interface in a node. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a90f728b73ccb1806e5a4093ff156f607}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
759 \{
760   \hyperlink{classns3_1_1Ipv4NixVectorRouting_a7b75edeb473c9fe1595b59d9800c5bab}{g\_isCacheDirty} = \textcolor{keyword}{true};
761 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!Notify\+Interface\+Up@{Notify\+Interface\+Up}}
\index{Notify\+Interface\+Up@{Notify\+Interface\+Up}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{Notify\+Interface\+Up(uint32\+\_\+t interface)}{NotifyInterfaceUp(uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::\+Notify\+Interface\+Up (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_a61f49f7c0ef8115c3d616d99f97052dc}{}\label{classns3_1_1Ipv4NixVectorRouting_a61f49f7c0ef8115c3d616d99f97052dc}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified of the state change of an interface in a node. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_aabb99ce7a048e75ff4b36fa9af8745e4}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
754 \{
755   \hyperlink{classns3_1_1Ipv4NixVectorRouting_a7b75edeb473c9fe1595b59d9800c5bab}{g\_isCacheDirty} = \textcolor{keyword}{true};
756 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!Notify\+Remove\+Address@{Notify\+Remove\+Address}}
\index{Notify\+Remove\+Address@{Notify\+Remove\+Address}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{Notify\+Remove\+Address(uint32\+\_\+t interface, Ipv4\+Interface\+Address address)}{NotifyRemoveAddress(uint32_t interface, Ipv4InterfaceAddress address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::\+Notify\+Remove\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv4\+Interface\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_a2a58d2c4a51a82a74456c5205ff1204e}{}\label{classns3_1_1Ipv4NixVectorRouting_a2a58d2c4a51a82a74456c5205ff1204e}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
{\em address} & a new address being added to an interface\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified whenever a new address is removed from an interface. Typically used to remove the \textquotesingle{}network route\textquotesingle{} of an interface. Can be invoked on an up or down interface. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a0160e49e509d6699ec837e5485f65cd2}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
769 \{
770   \hyperlink{classns3_1_1Ipv4NixVectorRouting_a7b75edeb473c9fe1595b59d9800c5bab}{g\_isCacheDirty} = \textcolor{keyword}{true};
771 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!Print\+Routing\+Table@{Print\+Routing\+Table}}
\index{Print\+Routing\+Table@{Print\+Routing\+Table}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{Print\+Routing\+Table(\+Ptr$<$ Output\+Stream\+Wrapper $>$ stream, Time\+::\+Unit unit=\+Time\+::\+S) const }{PrintRoutingTable(Ptr< OutputStreamWrapper > stream, Time::Unit unit=Time::S) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::\+Print\+Routing\+Table (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream, }
\item[{{\bf Time\+::\+Unit}}]{unit = {\ttfamily {\bf Time\+::S}}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_ad9c8c58d1641ddc1b3dc6245f4d30213}{}\label{classns3_1_1Ipv4NixVectorRouting_ad9c8c58d1641ddc1b3dc6245f4d30213}


Print the Routing Table entries. 


\begin{DoxyParams}{Parameters}
{\em stream} & The ostream the Routing table is printed to \\
\hline
{\em unit} & The time unit to be used in the report \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a86ad3fc1d17b06b6553a13b03d7e8cb4}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
700 \{
701 
702   \hyperlink{classns3_1_1Ipv4NixVectorRouting_aeeafd72dfb17da8349627232c9e9984f}{CheckCacheStateAndFlush} ();
703 
704   std::ostream* os = stream->\hyperlink{classns3_1_1OutputStreamWrapper_a0cf30a4188ab6fdae2b2ab74db11acc2}{GetStream} ();
705 
706   *os << \textcolor{stringliteral}{"Node: "} << \hyperlink{classns3_1_1Ipv4NixVectorRouting_a215cb71f30d85df9ec7176ca22620519}{m\_ipv4}->GetObject<Node> ()->GetId ()
707       << \textcolor{stringliteral}{", Time: "} << \hyperlink{group__simulator_gac3635e2e87f7ce316c89290ee1b01d0d}{Now}().\hyperlink{classns3_1_1Time_a0bb1110638ce9938248bd07865a328ab}{As} (unit)
708       << \textcolor{stringliteral}{", Local time: "} << GetObject<Node> ()->GetLocalTime ().As (unit)
709       << \textcolor{stringliteral}{", Nix Routing"} << std::endl;
710 
711   *os << \textcolor{stringliteral}{"NixCache:"} << std::endl;
712   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4NixVectorRouting_a394e830e592aa6ef064be362150219f2}{m\_nixCache}.size () > 0)
713     \{
714       *os << \textcolor{stringliteral}{"Destination     NixVector"} << std::endl;
715       \textcolor{keywordflow}{for} (NixMap\_t::const\_iterator it = \hyperlink{classns3_1_1Ipv4NixVectorRouting_a394e830e592aa6ef064be362150219f2}{m\_nixCache}.begin (); it != 
      \hyperlink{classns3_1_1Ipv4NixVectorRouting_a394e830e592aa6ef064be362150219f2}{m\_nixCache}.end (); it++)
716         \{
717           std::ostringstream dest;
718           dest << it->first;
719           *os << std::setiosflags (std::ios::left) << std::setw (16) << dest.str ();
720           *os << *(it->second) << std::endl;
721         \}
722     \}
723   *os << \textcolor{stringliteral}{"Ipv4RouteCache:"} << std::endl;
724   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4NixVectorRouting_aeb85361b66489c60851f72f1493fdee7}{m\_ipv4RouteCache}.size () > 0)
725     \{
726       *os << \textcolor{stringliteral}{"Destination     Gateway         Source            OutputDevice"} << std::endl;
727       \textcolor{keywordflow}{for} (Ipv4RouteMap\_t::const\_iterator it = \hyperlink{classns3_1_1Ipv4NixVectorRouting_aeb85361b66489c60851f72f1493fdee7}{m\_ipv4RouteCache}.begin (); it != 
      \hyperlink{classns3_1_1Ipv4NixVectorRouting_aeb85361b66489c60851f72f1493fdee7}{m\_ipv4RouteCache}.end (); it++)
728         \{
729           std::ostringstream dest, gw, src;
730           dest << it->second->GetDestination ();
731           *os << std::setiosflags (std::ios::left) << std::setw (16) << dest.str ();
732           gw << it->second->GetGateway ();
733           *os << std::setiosflags (std::ios::left) << std::setw (16) << gw.str ();
734           src << it->second->GetSource ();
735           *os << std::setiosflags (std::ios::left) << std::setw (16) << src.str ();
736           *os << \textcolor{stringliteral}{"  "};
737           \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Names_ab9664faf23569aaae64a2d1f65265045}{Names::FindName} (it->second->GetOutputDevice ()) != \textcolor{stringliteral}{""})
738             \{
739               *os << \hyperlink{classns3_1_1Names_ab9664faf23569aaae64a2d1f65265045}{Names::FindName} (it->second->GetOutputDevice ());
740             \}
741           \textcolor{keywordflow}{else}
742             \{
743               *os << it->second->GetOutputDevice ()->GetIfIndex ();
744             \}
745           *os << std::endl;
746         \}
747     \}
748   *os << std::endl;
749 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 29


\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!Reset\+Total\+Neighbors@{Reset\+Total\+Neighbors}}
\index{Reset\+Total\+Neighbors@{Reset\+Total\+Neighbors}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{Reset\+Total\+Neighbors(void)}{ResetTotalNeighbors(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::\+Reset\+Total\+Neighbors (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_ac702e006e998efe33f5db76c79618bfc}{}\label{classns3_1_1Ipv4NixVectorRouting_ac702e006e998efe33f5db76c79618bfc}
\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!Route\+Input@{Route\+Input}}
\index{Route\+Input@{Route\+Input}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{Route\+Input(\+Ptr$<$ const Packet $>$ p, const Ipv4\+Header \&header, Ptr$<$ const Net\+Device $>$ idev, Unicast\+Forward\+Callback ucb, Multicast\+Forward\+Callback mcb, Local\+Deliver\+Callback lcb, Error\+Callback ecb)}{RouteInput(Ptr< const Packet > p, const Ipv4Header &header, Ptr< const NetDevice > idev, UnicastForwardCallback ucb, MulticastForwardCallback mcb, LocalDeliverCallback lcb, ErrorCallback ecb)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::\+Route\+Input (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv4\+Header} \&}]{header, }
\item[{{\bf Ptr}$<$ const {\bf Net\+Device} $>$}]{idev, }
\item[{{\bf Unicast\+Forward\+Callback}}]{ucb, }
\item[{{\bf Multicast\+Forward\+Callback}}]{mcb, }
\item[{{\bf Local\+Deliver\+Callback}}]{lcb, }
\item[{{\bf Error\+Callback}}]{ecb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_a35d3d496fc0f96e1fd0106b353404c0c}{}\label{classns3_1_1Ipv4NixVectorRouting_a35d3d496fc0f96e1fd0106b353404c0c}


Route an input packet (to be forwarded or locally delivered) 

This lookup is used in the forwarding process. The packet is handed over to the \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol}, and will get forwarded onward by one of the callbacks. The Linux equivalent is ip\+\_\+route\+\_\+input(). There are four valid outcomes, and a matching callbacks to handle each.


\begin{DoxyParams}{Parameters}
{\em p} & received packet \\
\hline
{\em header} & input parameter used to form a search key for a route \\
\hline
{\em idev} & Pointer to ingress network device \\
\hline
{\em ucb} & \hyperlink{classns3_1_1Callback}{Callback} for the case in which the packet is to be forwarded as unicast \\
\hline
{\em mcb} & \hyperlink{classns3_1_1Callback}{Callback} for the case in which the packet is to be forwarded as multicast \\
\hline
{\em lcb} & \hyperlink{classns3_1_1Callback}{Callback} for the case in which the packet is to be locally delivered \\
\hline
{\em ecb} & \hyperlink{classns3_1_1Callback}{Callback} to call if there is an error in forwarding \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} takes responsibility for forwarding or delivering the packet, false otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a67e815ff40ebb9f5f4eec4e22e23132e}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
617 \{
618   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
619 
620   \hyperlink{classns3_1_1Ipv4NixVectorRouting_aeeafd72dfb17da8349627232c9e9984f}{CheckCacheStateAndFlush} ();
621 
622   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1Ipv4NixVectorRouting_a215cb71f30d85df9ec7176ca22620519}{m\_ipv4} != 0);
623   \textcolor{comment}{// Check if input device supports IP}
624   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1Ipv4NixVectorRouting_a215cb71f30d85df9ec7176ca22620519}{m\_ipv4}->GetInterfaceForDevice (idev) >= 0);
625   uint32\_t iif = \hyperlink{classns3_1_1Ipv4NixVectorRouting_a215cb71f30d85df9ec7176ca22620519}{m\_ipv4}->GetInterfaceForDevice (idev);
626 
627   \textcolor{comment}{// Local delivery}
628   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4NixVectorRouting_a215cb71f30d85df9ec7176ca22620519}{m\_ipv4}->IsDestinationAddress (header.GetDestination (), iif))
629     \{
630       \textcolor{keywordflow}{if} (!lcb.IsNull ())
631         \{
632           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Local delivery to "} << header.GetDestination ());
633           lcb (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header, iif);
634           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
635         \}
636       \textcolor{keywordflow}{else}
637         \{
638           \textcolor{comment}{// The local delivery callback is null.  This may be a multicast}
639           \textcolor{comment}{// or broadcast packet, so return false so that another}
640           \textcolor{comment}{// multicast routing protocol can handle it.  It should be possible}
641           \textcolor{comment}{// to extend this to explicitly check whether it is a unicast}
642           \textcolor{comment}{// packet, and invoke the error callback if so}
643           \textcolor{keywordflow}{return} \textcolor{keyword}{false};
644         \}
645     \}
646 
647   Ptr<Ipv4Route> rtentry;
648 
649   \textcolor{comment}{// Get the nix-vector from the packet}
650   Ptr<NixVector> nixVector = \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->GetNixVector ();
651 
652   \textcolor{comment}{// If nixVector isn't in packet, something went wrong}
653   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (nixVector);
654 
655   \textcolor{comment}{// Get the interface number that we go out of, by extracting}
656   \textcolor{comment}{// from the nix-vector}
657   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4NixVectorRouting_a96620dedcc6c052265c3c53aa14e4f6b}{m\_totalNeighbors} == 0)
658     \{
659       \hyperlink{classns3_1_1Ipv4NixVectorRouting_a96620dedcc6c052265c3c53aa14e4f6b}{m\_totalNeighbors} = \hyperlink{classns3_1_1Ipv4NixVectorRouting_ae4d125bd51c2d70084543489f00060b5}{FindTotalNeighbors} ();
660     \}
661   uint32\_t numberOfBits = nixVector->BitCount (\hyperlink{classns3_1_1Ipv4NixVectorRouting_a96620dedcc6c052265c3c53aa14e4f6b}{m\_totalNeighbors});
662   uint32\_t nodeIndex = nixVector->ExtractNeighborIndex (numberOfBits);
663 
664   rtentry = \hyperlink{classns3_1_1Ipv4NixVectorRouting_a1d352caa92d6d91e6cb94ecc31be4411}{GetIpv4RouteInCache} (header.GetDestination ());
665   \textcolor{comment}{// not in cache}
666   \textcolor{keywordflow}{if} (!rtentry)
667     \{
668       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Ipv4Route not in cache, build: "});
669       Ipv4Address gatewayIp;
670       uint32\_t index = \hyperlink{classns3_1_1Ipv4NixVectorRouting_abbd212141a650d5260455663d59c24c9}{FindNetDeviceForNixIndex} (nodeIndex, gatewayIp);
671       uint32\_t interfaceIndex = (\hyperlink{classns3_1_1Ipv4NixVectorRouting_a215cb71f30d85df9ec7176ca22620519}{m\_ipv4})->GetInterfaceForDevice (\hyperlink{classns3_1_1Ipv4NixVectorRouting_a329265b09f4d85bac6ec9bd0ec2daa92}{m\_node}->
      \hyperlink{classns3_1_1Node_a5918dfd24ef632efc9a83a5f6561c76e}{GetDevice} (index));
672       Ipv4InterfaceAddress ifAddr = \hyperlink{classns3_1_1Ipv4NixVectorRouting_a215cb71f30d85df9ec7176ca22620519}{m\_ipv4}->GetAddress (interfaceIndex, 0);
673 
674       \textcolor{comment}{// start filling in the Ipv4Route info}
675       rtentry = Create<Ipv4Route> ();
676       rtentry->SetSource (ifAddr.GetLocal ());
677 
678       rtentry->SetGateway (gatewayIp);
679       rtentry->SetDestination (header.GetDestination ());
680       rtentry->SetOutputDevice (\hyperlink{classns3_1_1Ipv4NixVectorRouting_a215cb71f30d85df9ec7176ca22620519}{m\_ipv4}->GetNetDevice (interfaceIndex));
681 
682       \textcolor{comment}{// add rtentry to cache}
683       \hyperlink{classns3_1_1Ipv4NixVectorRouting_aeb85361b66489c60851f72f1493fdee7}{m\_ipv4RouteCache}.insert (Ipv4RouteMap\_t::value\_type (header.GetDestination (), 
      rtentry));
684     \}
685 
686   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"At Node "} << \hyperlink{classns3_1_1Ipv4NixVectorRouting_a329265b09f4d85bac6ec9bd0ec2daa92}{m\_node}->\hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} () << \textcolor{stringliteral}{", Extracting "} << numberOfBits <<
687                 \textcolor{stringliteral}{" bits from Nix-vector: "} << nixVector << \textcolor{stringliteral}{" : "} << *nixVector);
688 
689   \textcolor{comment}{// call the unicast callback}
690   \textcolor{comment}{// local deliver is handled by Ipv4StaticRoutingImpl}
691   \textcolor{comment}{// so this code is never even called if the packet is}
692   \textcolor{comment}{// destined for this node.}
693   ucb (rtentry, \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header);
694 
695   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
696 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 30


\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!Route\+Output@{Route\+Output}}
\index{Route\+Output@{Route\+Output}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{Route\+Output(\+Ptr$<$ Packet $>$ p, const Ipv4\+Header \&header, Ptr$<$ Net\+Device $>$ oif, Socket\+::\+Socket\+Errno \&sockerr)}{RouteOutput(Ptr< Packet > p, const Ipv4Header &header, Ptr< NetDevice > oif, Socket::SocketErrno &sockerr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv4\+Route} $>$ ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::\+Route\+Output (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv4\+Header} \&}]{header, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{oif, }
\item[{{\bf Socket\+::\+Socket\+Errno} \&}]{sockerr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_ac7bbf06105fc46edc431bdc7be58f3e7}{}\label{classns3_1_1Ipv4NixVectorRouting_ac7bbf06105fc46edc431bdc7be58f3e7}


Query routing cache for an existing route, for an outbound packet. 

This lookup is used by transport protocols. It does not cause any packet to be forwarded, and is synchronous. Can be used for multicast or unicast. The Linux equivalent is ip\+\_\+route\+\_\+output()

The header input parameter may have an uninitialized value for the source address, but the destination address should always be properly set by the caller.


\begin{DoxyParams}{Parameters}
{\em p} & packet to be routed. Note that this method may modify the packet. Callers may also pass in a null pointer. \\
\hline
{\em header} & input parameter (used to form key to search for the route) \\
\hline
{\em oif} & Output interface Netdevice. May be zero, or may be bound via socket options to a particular output interface. \\
\hline
{\em sockerr} & Output parameter; socket errno\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a code that indicates what happened in the lookup 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a9c0e9b77772a4974c06ee4577fe60547}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
492 \{
493   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
494   Ptr<Ipv4Route> rtentry;
495   Ptr<NixVector> nixVectorInCache;
496   Ptr<NixVector> nixVectorForPacket;
497 
498   \hyperlink{classns3_1_1Ipv4NixVectorRouting_aeeafd72dfb17da8349627232c9e9984f}{CheckCacheStateAndFlush} ();
499 
500   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Dest IP from header: "} << header.GetDestination ());
501   \textcolor{comment}{// check if cache}
502   nixVectorInCache = \hyperlink{classns3_1_1Ipv4NixVectorRouting_afeecd07d75e1fda9a99d1f914ec331ce}{GetNixVectorInCache} (header.GetDestination ());
503 
504   \textcolor{comment}{// not in cache}
505   \textcolor{keywordflow}{if} (!nixVectorInCache)
506     \{
507       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Nix-vector not in cache, build: "});
508       \textcolor{comment}{// Build the nix-vector, given this node and the}
509       \textcolor{comment}{// dest IP address}
510       nixVectorInCache = \hyperlink{classns3_1_1Ipv4NixVectorRouting_ad1f618c1b1264f0d01644b9a68a0bd20}{GetNixVector} (\hyperlink{classns3_1_1Ipv4NixVectorRouting_a329265b09f4d85bac6ec9bd0ec2daa92}{m\_node}, header.GetDestination (), oif);
511 
512       \textcolor{comment}{// cache it}
513       \hyperlink{classns3_1_1Ipv4NixVectorRouting_a394e830e592aa6ef064be362150219f2}{m\_nixCache}.insert (NixMap\_t::value\_type (header.GetDestination (), nixVectorInCache));
514     \}
515 
516   \textcolor{comment}{// path exists}
517   \textcolor{keywordflow}{if} (nixVectorInCache)
518     \{
519       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Nix-vector contents: "} << *nixVectorInCache);
520 
521       \textcolor{comment}{// create a new nix vector to be used, }
522       \textcolor{comment}{// we want to keep the cached version clean}
523       nixVectorForPacket = Create<NixVector> ();
524       nixVectorForPacket = nixVectorInCache->Copy (); 
525 
526       \textcolor{comment}{// Get the interface number that we go out of, by extracting}
527       \textcolor{comment}{// from the nix-vector}
528       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4NixVectorRouting_a96620dedcc6c052265c3c53aa14e4f6b}{m\_totalNeighbors} == 0)
529         \{
530           \hyperlink{classns3_1_1Ipv4NixVectorRouting_a96620dedcc6c052265c3c53aa14e4f6b}{m\_totalNeighbors} = \hyperlink{classns3_1_1Ipv4NixVectorRouting_ae4d125bd51c2d70084543489f00060b5}{FindTotalNeighbors} ();
531         \}
532 
533       \textcolor{comment}{// Get the interface number that we go out of, by extracting}
534       \textcolor{comment}{// from the nix-vector}
535       uint32\_t numberOfBits = nixVectorForPacket->BitCount (\hyperlink{classns3_1_1Ipv4NixVectorRouting_a96620dedcc6c052265c3c53aa14e4f6b}{m\_totalNeighbors});
536       uint32\_t nodeIndex = nixVectorForPacket->ExtractNeighborIndex (numberOfBits);
537 
538       \textcolor{comment}{// Search here in a cache for this node index }
539       \textcolor{comment}{// and look for a Ipv4Route}
540       rtentry = \hyperlink{classns3_1_1Ipv4NixVectorRouting_a1d352caa92d6d91e6cb94ecc31be4411}{GetIpv4RouteInCache} (header.GetDestination ());
541 
542       \textcolor{keywordflow}{if} (!rtentry || !(rtentry->GetOutputDevice () == oif))
543         \{
544           \textcolor{comment}{// not in cache or a different specified output}
545           \textcolor{comment}{// device is to be used}
546 
547           \textcolor{comment}{// first, make sure we erase existing (incorrect)}
548           \textcolor{comment}{// rtentry from the map}
549           \textcolor{keywordflow}{if} (rtentry)
550             \{
551               \hyperlink{classns3_1_1Ipv4NixVectorRouting_aeb85361b66489c60851f72f1493fdee7}{m\_ipv4RouteCache}.erase (header.GetDestination ());
552             \}
553 
554           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Ipv4Route not in cache, build: "});
555           Ipv4Address gatewayIp;
556           uint32\_t index = \hyperlink{classns3_1_1Ipv4NixVectorRouting_abbd212141a650d5260455663d59c24c9}{FindNetDeviceForNixIndex} (nodeIndex, gatewayIp);
557           int32\_t interfaceIndex = 0;
558 
559           \textcolor{keywordflow}{if} (!oif)
560             \{
561               interfaceIndex = (\hyperlink{classns3_1_1Ipv4NixVectorRouting_a215cb71f30d85df9ec7176ca22620519}{m\_ipv4})->GetInterfaceForDevice (\hyperlink{classns3_1_1Ipv4NixVectorRouting_a329265b09f4d85bac6ec9bd0ec2daa92}{m\_node}->
      \hyperlink{classns3_1_1Node_a5918dfd24ef632efc9a83a5f6561c76e}{GetDevice} (index));
562             \}
563           \textcolor{keywordflow}{else}
564             \{
565               interfaceIndex = (\hyperlink{classns3_1_1Ipv4NixVectorRouting_a215cb71f30d85df9ec7176ca22620519}{m\_ipv4})->GetInterfaceForDevice (oif);
566             \}
567 
568           \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (interfaceIndex != -1, \textcolor{stringliteral}{"Interface index not found for device"});
569 
570           Ipv4InterfaceAddress ifAddr = \hyperlink{classns3_1_1Ipv4NixVectorRouting_a215cb71f30d85df9ec7176ca22620519}{m\_ipv4}->GetAddress (interfaceIndex, 0);
571 
572           \textcolor{comment}{// start filling in the Ipv4Route info}
573           rtentry = Create<Ipv4Route> ();
574           rtentry->SetSource (ifAddr.GetLocal ());
575 
576           rtentry->SetGateway (gatewayIp);
577           rtentry->SetDestination (header.GetDestination ());
578 
579           \textcolor{keywordflow}{if} (!oif)
580             \{
581               rtentry->SetOutputDevice (\hyperlink{classns3_1_1Ipv4NixVectorRouting_a215cb71f30d85df9ec7176ca22620519}{m\_ipv4}->GetNetDevice (interfaceIndex));
582             \}
583           \textcolor{keywordflow}{else}
584             \{
585               rtentry->SetOutputDevice (oif);
586             \}
587 
588           sockerr = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaaa7eb006d73c5ad0117c5591fcb3469f7}{Socket::ERROR\_NOTERROR};
589 
590           \textcolor{comment}{// add rtentry to cache}
591           \hyperlink{classns3_1_1Ipv4NixVectorRouting_aeb85361b66489c60851f72f1493fdee7}{m\_ipv4RouteCache}.insert (Ipv4RouteMap\_t::value\_type (header.GetDestination (), 
      rtentry));
592         \}
593 
594       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Nix-vector contents: "} << *nixVectorInCache << \textcolor{stringliteral}{" : Remaining bits: "} << 
      nixVectorForPacket->GetRemainingBits ());
595 
596       \textcolor{comment}{// Add  nix-vector in the packet class }
597       \textcolor{comment}{// make sure the packet exists first}
598       \textcolor{keywordflow}{if} (p)
599         \{
600           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Adding Nix-vector to packet: "} << *nixVectorForPacket);
601           p->\hyperlink{classns3_1_1Packet_a7e02c5b608a578c845aafd838f155989}{SetNixVector} (nixVectorForPacket);
602         \}
603     \}
604   \textcolor{keywordflow}{else} \textcolor{comment}{// path doesn't exist}
605     \{
606       \hyperlink{group__logging_ga0261a8db1d4ac5f79417d117634fd455}{NS\_LOG\_ERROR} (\textcolor{stringliteral}{"No path to the dest: "} << header.GetDestination ());
607       sockerr = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{Socket::ERROR\_NOROUTETOHOST};
608     \}
609 
610   \textcolor{keywordflow}{return} rtentry;
611 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 31


\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!Set\+Ipv4@{Set\+Ipv4}}
\index{Set\+Ipv4@{Set\+Ipv4}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{Set\+Ipv4(\+Ptr$<$ Ipv4 $>$ ipv4)}{SetIpv4(Ptr< Ipv4 > ipv4)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::\+Set\+Ipv4 (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv4} $>$}]{ipv4}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_aff290a5e6590fb40ef8de74abfeebc74}{}\label{classns3_1_1Ipv4NixVectorRouting_aff290a5e6590fb40ef8de74abfeebc74}

\begin{DoxyParams}{Parameters}
{\em ipv4} & the ipv4 object this routing protocol is being associated with\\
\hline
\end{DoxyParams}
Typically, invoked directly or indirectly from \hyperlink{classns3_1_1Ipv4_a2d165c3bafd4ca580f02a03536db80d3}{ns3\+::\+Ipv4\+::\+Set\+Routing\+Protocol} 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_af3947a05b912ea3f2a1ef0e9777f723e}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
63 \{
64   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (ipv4 != 0);
65   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1Ipv4NixVectorRouting_a215cb71f30d85df9ec7176ca22620519}{m\_ipv4} == 0);
66   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Created Ipv4NixVectorProtocol"});
67 
68   \hyperlink{classns3_1_1Ipv4NixVectorRouting_a215cb71f30d85df9ec7176ca22620519}{m\_ipv4} = ipv4;
69 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!Set\+Node@{Set\+Node}}
\index{Set\+Node@{Set\+Node}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{Set\+Node(\+Ptr$<$ Node $>$ node)}{SetNode(Ptr< Node > node)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::\+Set\+Node (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4NixVectorRouting_a6a038800279f64332101463c5c393cff}{}\label{classns3_1_1Ipv4NixVectorRouting_a6a038800279f64332101463c5c393cff}


Set the \hyperlink{classns3_1_1Node}{Node} pointer of the node for which this routing protocol is to be placed. 


\begin{DoxyParams}{Parameters}
{\em node} & \hyperlink{classns3_1_1Node}{Node} pointer \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
85 \{
86   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
87 
88   \hyperlink{classns3_1_1Ipv4NixVectorRouting_a329265b09f4d85bac6ec9bd0ec2daa92}{m\_node} = node;
89 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!g\+\_\+is\+Cache\+Dirty@{g\+\_\+is\+Cache\+Dirty}}
\index{g\+\_\+is\+Cache\+Dirty@{g\+\_\+is\+Cache\+Dirty}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{g\+\_\+is\+Cache\+Dirty}{g_isCacheDirty}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::g\+\_\+is\+Cache\+Dirty = {\bf false}\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_a7b75edeb473c9fe1595b59d9800c5bab}{}\label{classns3_1_1Ipv4NixVectorRouting_a7b75edeb473c9fe1595b59d9800c5bab}
\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!m\+\_\+ipv4@{m\+\_\+ipv4}}
\index{m\+\_\+ipv4@{m\+\_\+ipv4}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+ipv4}{m_ipv4}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Ipv4}$>$ ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::m\+\_\+ipv4\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_a215cb71f30d85df9ec7176ca22620519}{}\label{classns3_1_1Ipv4NixVectorRouting_a215cb71f30d85df9ec7176ca22620519}
\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!m\+\_\+ipv4\+Route\+Cache@{m\+\_\+ipv4\+Route\+Cache}}
\index{m\+\_\+ipv4\+Route\+Cache@{m\+\_\+ipv4\+Route\+Cache}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+ipv4\+Route\+Cache}{m_ipv4RouteCache}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Route\+Map\+\_\+t} ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::m\+\_\+ipv4\+Route\+Cache\hspace{0.3cm}{\ttfamily [mutable]}, {\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_aeb85361b66489c60851f72f1493fdee7}{}\label{classns3_1_1Ipv4NixVectorRouting_aeb85361b66489c60851f72f1493fdee7}
\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!m\+\_\+nix\+Cache@{m\+\_\+nix\+Cache}}
\index{m\+\_\+nix\+Cache@{m\+\_\+nix\+Cache}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+nix\+Cache}{m_nixCache}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Nix\+Map\+\_\+t} ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::m\+\_\+nix\+Cache\hspace{0.3cm}{\ttfamily [mutable]}, {\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_a394e830e592aa6ef064be362150219f2}{}\label{classns3_1_1Ipv4NixVectorRouting_a394e830e592aa6ef064be362150219f2}
\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!m\+\_\+node@{m\+\_\+node}}
\index{m\+\_\+node@{m\+\_\+node}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+node}{m_node}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Node}$>$ ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::m\+\_\+node\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_a329265b09f4d85bac6ec9bd0ec2daa92}{}\label{classns3_1_1Ipv4NixVectorRouting_a329265b09f4d85bac6ec9bd0ec2daa92}
\index{ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}!m\+\_\+total\+Neighbors@{m\+\_\+total\+Neighbors}}
\index{m\+\_\+total\+Neighbors@{m\+\_\+total\+Neighbors}!ns3\+::\+Ipv4\+Nix\+Vector\+Routing@{ns3\+::\+Ipv4\+Nix\+Vector\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+total\+Neighbors}{m_totalNeighbors}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Ipv4\+Nix\+Vector\+Routing\+::m\+\_\+total\+Neighbors\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4NixVectorRouting_a96620dedcc6c052265c3c53aa14e4f6b}{}\label{classns3_1_1Ipv4NixVectorRouting_a96620dedcc6c052265c3c53aa14e4f6b}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
nix-\/vector-\/routing/model/\hyperlink{ipv4-nix-vector-routing_8h}{ipv4-\/nix-\/vector-\/routing.\+h}\item 
nix-\/vector-\/routing/model/\hyperlink{ipv4-nix-vector-routing_8cc}{ipv4-\/nix-\/vector-\/routing.\+cc}\end{DoxyCompactItemize}
