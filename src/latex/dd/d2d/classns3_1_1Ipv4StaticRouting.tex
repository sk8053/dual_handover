\hypertarget{classns3_1_1Ipv4StaticRouting}{}\section{ns3\+:\+:Ipv4\+Static\+Routing Class Reference}
\label{classns3_1_1Ipv4StaticRouting}\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}


Static routing protocol for IP version 4 stacks.  




{\ttfamily \#include $<$ipv4-\/static-\/routing.\+h$>$}



Inheritance diagram for ns3\+:\+:Ipv4\+Static\+Routing\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Ipv4\+Static\+Routing\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ipv4StaticRouting_ae472733cd2a237a8afa7ce343c116131}{Ipv4\+Static\+Routing} ()
\item 
virtual \hyperlink{classns3_1_1Ipv4StaticRouting_a010d8d8b79d4e66f6e5ab30a169e4097}{$\sim$\+Ipv4\+Static\+Routing} ()
\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ \hyperlink{classns3_1_1Ipv4StaticRouting_a7a8f0d57d249629f1b7d67e6701571e0}{Route\+Output} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ oif, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket\+::\+Socket\+Errno} \&sockerr)
\begin{DoxyCompactList}\small\item\em Query routing cache for an existing route, for an outbound packet. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1Ipv4StaticRouting_a5e01a8326cd334ad887953345632d7c1}{Route\+Input} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ idev, \hyperlink{classns3_1_1Ipv4RoutingProtocol_a3453a85764cbbb1e704da7e919aa5d19}{Unicast\+Forward\+Callback} ucb, \hyperlink{classns3_1_1Ipv4RoutingProtocol_a26e76f7a555462e6c08fceda64a99d58}{Multicast\+Forward\+Callback} mcb, \hyperlink{classns3_1_1Ipv4RoutingProtocol_aa6ffa0159cb143daa3c46d2ba69bb1b9}{Local\+Deliver\+Callback} lcb, \hyperlink{classns3_1_1Ipv4RoutingProtocol_a0348285418c30d5021b08f7a68af21ea}{Error\+Callback} ecb)
\begin{DoxyCompactList}\small\item\em Route an input packet (to be forwarded or locally delivered) \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv4StaticRouting_a2c84913a130adb6dbd2814da95e789fb}{Notify\+Interface\+Up} (uint32\+\_\+t interface)
\item 
virtual void \hyperlink{classns3_1_1Ipv4StaticRouting_a22f00ba2dabe60e0653e278e221aa97b}{Notify\+Interface\+Down} (uint32\+\_\+t interface)
\item 
virtual void \hyperlink{classns3_1_1Ipv4StaticRouting_ad9cd500198ceab0fec83610cd3f2d1e9}{Notify\+Add\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} address)
\item 
virtual void \hyperlink{classns3_1_1Ipv4StaticRouting_ac7ccf0480e1b0f715a93c474de12b195}{Notify\+Remove\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} address)
\item 
virtual void \hyperlink{classns3_1_1Ipv4StaticRouting_a3caec935381a858c42583d2d023d4499}{Set\+Ipv4} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$ ipv4)
\item 
virtual void \hyperlink{classns3_1_1Ipv4StaticRouting_a917ee8a51016e159903df505bf7ded25}{Print\+Routing\+Table} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream, \hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295a}{Time\+::\+Unit} unit=\hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295aade8622b06524a328cd3a59db6ccf76af}{Time\+::S}) const 
\begin{DoxyCompactList}\small\item\em Print the Routing Table entries. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4StaticRouting_a8bf5eaa7ba49fe33c78c70d5560b6c39}{Add\+Network\+Route\+To} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} network, \hyperlink{classns3_1_1Ipv4Mask}{Ipv4\+Mask} network\+Mask, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} next\+Hop, uint32\+\_\+t interface, uint32\+\_\+t metric=0)
\begin{DoxyCompactList}\small\item\em Add a network route to the static routing table. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4StaticRouting_a04e91acd20c34069034677b1b491f30e}{Add\+Network\+Route\+To} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} network, \hyperlink{classns3_1_1Ipv4Mask}{Ipv4\+Mask} network\+Mask, uint32\+\_\+t interface, uint32\+\_\+t metric=0)
\begin{DoxyCompactList}\small\item\em Add a network route to the static routing table. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4StaticRouting_ae96452233179689167e57b49b4339005}{Add\+Host\+Route\+To} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} dest, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} next\+Hop, uint32\+\_\+t interface, uint32\+\_\+t metric=0)
\begin{DoxyCompactList}\small\item\em Add a host route to the static routing table. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4StaticRouting_ac3d02e2f2145ea86eb4d6efca40dfad0}{Add\+Host\+Route\+To} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} dest, uint32\+\_\+t interface, uint32\+\_\+t metric=0)
\begin{DoxyCompactList}\small\item\em Add a host route to the static routing table. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4StaticRouting_aee30fa3246c2b42f122dabdff2725331}{Set\+Default\+Route} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} next\+Hop, uint32\+\_\+t interface, uint32\+\_\+t metric=0)
\begin{DoxyCompactList}\small\item\em Add a default route to the static routing table. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1Ipv4StaticRouting_a074f780e02f4252e8daa59ed70f499ab}{Get\+N\+Routes} (void) const 
\begin{DoxyCompactList}\small\item\em Get the number of individual unicast routes that have been added to the routing table. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} \hyperlink{classns3_1_1Ipv4StaticRouting_a3e3079305b988d61fdd56d9990499a6e}{Get\+Default\+Route} (void)
\begin{DoxyCompactList}\small\item\em Get the default route with lowest metric from the static routing table. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} \hyperlink{classns3_1_1Ipv4StaticRouting_a2bd58c5ceeaff35b32a68826fbec5245}{Get\+Route} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) const 
\begin{DoxyCompactList}\small\item\em Get a route from the static unicast routing table. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1Ipv4StaticRouting_adae3d8690cec2cac5f5c4e2b239feb17}{Get\+Metric} (uint32\+\_\+t index) const 
\begin{DoxyCompactList}\small\item\em Get a metric for route from the static unicast routing table. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4StaticRouting_a2814791ae24de098c228d8ec64278444}{Remove\+Route} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
\begin{DoxyCompactList}\small\item\em Remove a route from the static unicast routing table. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4StaticRouting_a58582a0b87b6705d3c974146a19e25b9}{Add\+Multicast\+Route} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} origin, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} group, uint32\+\_\+t input\+Interface, std\+::vector$<$ uint32\+\_\+t $>$ output\+Interfaces)
\begin{DoxyCompactList}\small\item\em Add a multicast route to the static routing table. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4StaticRouting_a478128042db3170f6419f86f1a9e5ecf}{Set\+Default\+Multicast\+Route} (uint32\+\_\+t output\+Interface)
\begin{DoxyCompactList}\small\item\em Add a default multicast route to the static routing table. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1Ipv4StaticRouting_a12d3044b0fa28e961e7705ae26387bc9}{Get\+N\+Multicast\+Routes} (void) const 
\begin{DoxyCompactList}\small\item\em Get the number of individual multicast routes that have been added to the routing table. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4MulticastRoutingTableEntry}{Ipv4\+Multicast\+Routing\+Table\+Entry} \hyperlink{classns3_1_1Ipv4StaticRouting_ad98dc9192a4fc144074fac4f5b857658}{Get\+Multicast\+Route} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) const 
\begin{DoxyCompactList}\small\item\em Get a route from the static multicast routing table. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Ipv4StaticRouting_afca7bca35c67739be3ee551baaeda4ef}{Remove\+Multicast\+Route} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} origin, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} group, uint32\+\_\+t input\+Interface)
\begin{DoxyCompactList}\small\item\em Remove a route from the static multicast routing table. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv4StaticRouting_a6f530f68b04bcd8bdadec6c41759643c}{Remove\+Multicast\+Route} (uint32\+\_\+t index)
\begin{DoxyCompactList}\small\item\em Remove a route from the static multicast routing table. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1Ipv4StaticRouting_ae81d892774266a25710d1031d0e422eb}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em The interface Id associated with this class. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1Ipv4StaticRouting_a54fac8e7b55b72baaa54d94ed98cf9a1}{Do\+Dispose} (void)
\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ std\+::pair$<$ \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} $\ast$, uint32\+\_\+t $>$ $>$ \hyperlink{classns3_1_1Ipv4StaticRouting_ac3eb49f971bae7619f69b21dffb93078}{Network\+Routes}
\begin{DoxyCompactList}\small\item\em Container for the network routes. \end{DoxyCompactList}\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ std\+::pair$<$ \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} $\ast$, uint32\+\_\+t $>$ $>$\+::const\+\_\+iterator \hyperlink{classns3_1_1Ipv4StaticRouting_ab8f7a067b65c827dd5012d9a99d79d1e}{Network\+Routes\+CI}
\begin{DoxyCompactList}\small\item\em Const Iterator for container for the network routes. \end{DoxyCompactList}\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ std\+::pair$<$ \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} $\ast$, uint32\+\_\+t $>$ $>$\+::iterator \hyperlink{classns3_1_1Ipv4StaticRouting_a3d4f303cbea2117f36f3dd2da3ac59c9}{Network\+RoutesI}
\begin{DoxyCompactList}\small\item\em Iterator for container for the network routes. \end{DoxyCompactList}\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ipv4MulticastRoutingTableEntry}{Ipv4\+Multicast\+Routing\+Table\+Entry} $\ast$ $>$ \hyperlink{classns3_1_1Ipv4StaticRouting_a8ed35ab38cf9627ef4f80b06d3ce6531}{Multicast\+Routes}
\begin{DoxyCompactList}\small\item\em Container for the multicast routes. \end{DoxyCompactList}\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ipv4MulticastRoutingTableEntry}{Ipv4\+Multicast\+Routing\+Table\+Entry} $\ast$ $>$\+::const\+\_\+iterator \hyperlink{classns3_1_1Ipv4StaticRouting_a8edf8cf21421add8ab26b5120797f21f}{Multicast\+Routes\+CI}
\begin{DoxyCompactList}\small\item\em Const Iterator for container for the multicast routes. \end{DoxyCompactList}\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ipv4MulticastRoutingTableEntry}{Ipv4\+Multicast\+Routing\+Table\+Entry} $\ast$ $>$\+::iterator \hyperlink{classns3_1_1Ipv4StaticRouting_ac832d5465e0c8f5dd30c6d024c2a2234}{Multicast\+RoutesI}
\begin{DoxyCompactList}\small\item\em Iterator for container for the multicast routes. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ \hyperlink{classns3_1_1Ipv4StaticRouting_a9ee2a4c5597e9b238369ba3667121852}{Lookup\+Static} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} dest, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ oif=0)
\begin{DoxyCompactList}\small\item\em Lookup in the forwarding table for destination. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4MulticastRoute}{Ipv4\+Multicast\+Route} $>$ \hyperlink{classns3_1_1Ipv4StaticRouting_acc26ca2e9144cec5748e51d07edf7088}{Lookup\+Static} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} origin, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} group, uint32\+\_\+t interface)
\begin{DoxyCompactList}\small\item\em Lookup in the multicast forwarding table for destination. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ipv4StaticRouting_ac3eb49f971bae7619f69b21dffb93078}{Network\+Routes} \hyperlink{classns3_1_1Ipv4StaticRouting_a81e0b111629b14fff2efbf69180a64c1}{m\+\_\+network\+Routes}
\begin{DoxyCompactList}\small\item\em the forwarding table for network. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv4StaticRouting_a8ed35ab38cf9627ef4f80b06d3ce6531}{Multicast\+Routes} \hyperlink{classns3_1_1Ipv4StaticRouting_a5aaf2ee73a6590cc164ac9485d89b538}{m\+\_\+multicast\+Routes}
\begin{DoxyCompactList}\small\item\em the forwarding table for multicast. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$ \hyperlink{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{m\+\_\+ipv4}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Ipv4}{Ipv4} reference. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Static routing protocol for IP version 4 stacks. 

This class provides a basic set of methods for inserting static unicast and multicast routes into the \hyperlink{classns3_1_1Ipv4}{Ipv4} routing system. This particular protocol is designed to be inserted into an \hyperlink{classns3_1_1Ipv4ListRouting}{Ipv4\+List\+Routing} protocol but can be used also as a standalone protocol.

The \hyperlink{classns3_1_1Ipv4StaticRouting}{Ipv4\+Static\+Routing} class inherits from the abstract base class \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} that defines the interface methods that a routing protocol must support.

\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} 

\hyperlink{classns3_1_1Ipv4ListRouting}{Ipv4\+List\+Routing} 

\hyperlink{classns3_1_1Ipv4ListRouting_aac3d4da5db389114e7b980c6136f11a2}{Ipv4\+List\+Routing\+::\+Add\+Routing\+Protocol} 
\end{DoxySeeAlso}


\subsection{Member Typedef Documentation}
\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Multicast\+Routes@{Multicast\+Routes}}
\index{Multicast\+Routes@{Multicast\+Routes}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Multicast\+Routes}{MulticastRoutes}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Ipv4\+Multicast\+Routing\+Table\+Entry} $\ast$$>$ {\bf ns3\+::\+Ipv4\+Static\+Routing\+::\+Multicast\+Routes}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4StaticRouting_a8ed35ab38cf9627ef4f80b06d3ce6531}{}\label{classns3_1_1Ipv4StaticRouting_a8ed35ab38cf9627ef4f80b06d3ce6531}


Container for the multicast routes. 

\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Multicast\+Routes\+CI@{Multicast\+Routes\+CI}}
\index{Multicast\+Routes\+CI@{Multicast\+Routes\+CI}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Multicast\+Routes\+CI}{MulticastRoutesCI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Ipv4\+Multicast\+Routing\+Table\+Entry} $\ast$$>$\+::const\+\_\+iterator {\bf ns3\+::\+Ipv4\+Static\+Routing\+::\+Multicast\+Routes\+CI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4StaticRouting_a8edf8cf21421add8ab26b5120797f21f}{}\label{classns3_1_1Ipv4StaticRouting_a8edf8cf21421add8ab26b5120797f21f}


Const Iterator for container for the multicast routes. 

\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Multicast\+RoutesI@{Multicast\+RoutesI}}
\index{Multicast\+RoutesI@{Multicast\+RoutesI}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Multicast\+RoutesI}{MulticastRoutesI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Ipv4\+Multicast\+Routing\+Table\+Entry} $\ast$$>$\+::iterator {\bf ns3\+::\+Ipv4\+Static\+Routing\+::\+Multicast\+RoutesI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4StaticRouting_ac832d5465e0c8f5dd30c6d024c2a2234}{}\label{classns3_1_1Ipv4StaticRouting_ac832d5465e0c8f5dd30c6d024c2a2234}


Iterator for container for the multicast routes. 

\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Network\+Routes@{Network\+Routes}}
\index{Network\+Routes@{Network\+Routes}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Network\+Routes}{NetworkRoutes}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<$std\+::pair $<${\bf Ipv4\+Routing\+Table\+Entry} $\ast$, uint32\+\_\+t$>$ $>$ {\bf ns3\+::\+Ipv4\+Static\+Routing\+::\+Network\+Routes}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4StaticRouting_ac3eb49f971bae7619f69b21dffb93078}{}\label{classns3_1_1Ipv4StaticRouting_ac3eb49f971bae7619f69b21dffb93078}


Container for the network routes. 

\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Network\+Routes\+CI@{Network\+Routes\+CI}}
\index{Network\+Routes\+CI@{Network\+Routes\+CI}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Network\+Routes\+CI}{NetworkRoutesCI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<$std\+::pair $<${\bf Ipv4\+Routing\+Table\+Entry} $\ast$, uint32\+\_\+t$>$ $>$\+::const\+\_\+iterator {\bf ns3\+::\+Ipv4\+Static\+Routing\+::\+Network\+Routes\+CI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4StaticRouting_ab8f7a067b65c827dd5012d9a99d79d1e}{}\label{classns3_1_1Ipv4StaticRouting_ab8f7a067b65c827dd5012d9a99d79d1e}


Const Iterator for container for the network routes. 

\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Network\+RoutesI@{Network\+RoutesI}}
\index{Network\+RoutesI@{Network\+RoutesI}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Network\+RoutesI}{NetworkRoutesI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<$std\+::pair $<${\bf Ipv4\+Routing\+Table\+Entry} $\ast$, uint32\+\_\+t$>$ $>$\+::iterator {\bf ns3\+::\+Ipv4\+Static\+Routing\+::\+Network\+RoutesI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4StaticRouting_a3d4f303cbea2117f36f3dd2da3ac59c9}{}\label{classns3_1_1Ipv4StaticRouting_a3d4f303cbea2117f36f3dd2da3ac59c9}


Iterator for container for the network routes. 



\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Ipv4\+Static\+Routing@{Ipv4\+Static\+Routing}}
\index{Ipv4\+Static\+Routing@{Ipv4\+Static\+Routing}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Ipv4\+Static\+Routing()}{Ipv4StaticRouting()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv4\+Static\+Routing\+::\+Ipv4\+Static\+Routing (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4StaticRouting_ae472733cd2a237a8afa7ce343c116131}{}\label{classns3_1_1Ipv4StaticRouting_ae472733cd2a237a8afa7ce343c116131}

\begin{DoxyCode}
57   : \hyperlink{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{m\_ipv4} (0)
58 \{
59   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
60 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!````~Ipv4\+Static\+Routing@{$\sim$\+Ipv4\+Static\+Routing}}
\index{````~Ipv4\+Static\+Routing@{$\sim$\+Ipv4\+Static\+Routing}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{$\sim$\+Ipv4\+Static\+Routing()}{~Ipv4StaticRouting()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv4\+Static\+Routing\+::$\sim$\+Ipv4\+Static\+Routing (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4StaticRouting_a010d8d8b79d4e66f6e5ab30a169e4097}{}\label{classns3_1_1Ipv4StaticRouting_a010d8d8b79d4e66f6e5ab30a169e4097}

\begin{DoxyCode}
564 \{
565   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
566 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Add\+Host\+Route\+To@{Add\+Host\+Route\+To}}
\index{Add\+Host\+Route\+To@{Add\+Host\+Route\+To}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Add\+Host\+Route\+To(\+Ipv4\+Address dest, Ipv4\+Address next\+Hop, uint32\+\_\+t interface, uint32\+\_\+t metric=0)}{AddHostRouteTo(Ipv4Address dest, Ipv4Address nextHop, uint32_t interface, uint32_t metric=0)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Static\+Routing\+::\+Add\+Host\+Route\+To (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{dest, }
\item[{{\bf Ipv4\+Address}}]{next\+Hop, }
\item[{uint32\+\_\+t}]{interface, }
\item[{uint32\+\_\+t}]{metric = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4StaticRouting_ae96452233179689167e57b49b4339005}{}\label{classns3_1_1Ipv4StaticRouting_ae96452233179689167e57b49b4339005}


Add a host route to the static routing table. 


\begin{DoxyParams}{Parameters}
{\em dest} & The \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} destination for this route. \\
\hline
{\em next\+Hop} & The \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} of the next hop in the route. \\
\hline
{\em interface} & The network interface index used to send packets to the destination. \\
\hline
{\em metric} & Metric of route in case of multiple routes to same destination\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} 
\end{DoxySeeAlso}

\begin{DoxyCode}
97 \{
98   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << dest << \textcolor{stringliteral}{" "} << nextHop << \textcolor{stringliteral}{" "} << interface << \textcolor{stringliteral}{" "} << metric);
99   \hyperlink{classns3_1_1Ipv4StaticRouting_a8bf5eaa7ba49fe33c78c70d5560b6c39}{AddNetworkRouteTo} (dest, \hyperlink{classns3_1_1Ipv4Mask_af712cbdf28c039025d4aa45fa7e243dd}{Ipv4Mask::GetOnes} (), nextHop, interface, 
      metric);
100 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2




Here is the caller graph for this function\+:
% FIG 3


\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Add\+Host\+Route\+To@{Add\+Host\+Route\+To}}
\index{Add\+Host\+Route\+To@{Add\+Host\+Route\+To}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Add\+Host\+Route\+To(\+Ipv4\+Address dest, uint32\+\_\+t interface, uint32\+\_\+t metric=0)}{AddHostRouteTo(Ipv4Address dest, uint32_t interface, uint32_t metric=0)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Static\+Routing\+::\+Add\+Host\+Route\+To (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{dest, }
\item[{uint32\+\_\+t}]{interface, }
\item[{uint32\+\_\+t}]{metric = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4StaticRouting_ac3d02e2f2145ea86eb4d6efca40dfad0}{}\label{classns3_1_1Ipv4StaticRouting_ac3d02e2f2145ea86eb4d6efca40dfad0}


Add a host route to the static routing table. 


\begin{DoxyParams}{Parameters}
{\em dest} & The \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} destination for this route. \\
\hline
{\em interface} & The network interface index used to send packets to the destination. \\
\hline
{\em metric} & Metric of route in case of multiple routes to same destination\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} 
\end{DoxySeeAlso}

\begin{DoxyCode}
106 \{
107   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << dest << \textcolor{stringliteral}{" "} << interface << \textcolor{stringliteral}{" "} << metric);
108   \hyperlink{classns3_1_1Ipv4StaticRouting_a8bf5eaa7ba49fe33c78c70d5560b6c39}{AddNetworkRouteTo} (dest, \hyperlink{classns3_1_1Ipv4Mask_af712cbdf28c039025d4aa45fa7e243dd}{Ipv4Mask::GetOnes} (), interface, metric);
109 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4


\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Add\+Multicast\+Route@{Add\+Multicast\+Route}}
\index{Add\+Multicast\+Route@{Add\+Multicast\+Route}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Add\+Multicast\+Route(\+Ipv4\+Address origin, Ipv4\+Address group, uint32\+\_\+t input\+Interface, std\+::vector$<$ uint32\+\_\+t $>$ output\+Interfaces)}{AddMulticastRoute(Ipv4Address origin, Ipv4Address group, uint32_t inputInterface, std::vector< uint32_t > outputInterfaces)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Static\+Routing\+::\+Add\+Multicast\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{origin, }
\item[{{\bf Ipv4\+Address}}]{group, }
\item[{uint32\+\_\+t}]{input\+Interface, }
\item[{std\+::vector$<$ uint32\+\_\+t $>$}]{output\+Interfaces}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4StaticRouting_a58582a0b87b6705d3c974146a19e25b9}{}\label{classns3_1_1Ipv4StaticRouting_a58582a0b87b6705d3c974146a19e25b9}


Add a multicast route to the static routing table. 

A multicast route must specify an origin IP address, a multicast group and an input network interface index as conditions and provide a vector of output network interface indices over which packets matching the conditions are sent.

Typically there are two main types of multicast routes\+: routes of the first kind are used during forwarding. All of the conditions must be explicitly provided. The second kind of routes are used to get packets off of a local node. The difference is in the input interface. Routes for forwarding will always have an explicit input interface specified. Routes off of a node will always set the input interface to a wildcard specified by the index Ipv4\+Routing\+Protocol\+::\+I\+N\+T\+E\+R\+F\+A\+C\+E\+\_\+\+A\+NY.

For routes off of a local node wildcards may be used in the origin and multicast group addresses. The wildcard used for Ipv4\+Adresses is that address returned by \hyperlink{classns3_1_1Ipv4Address_a7a39b330c8e701183a411d5779fca1a4}{Ipv4\+Address\+::\+Get\+Any} () -- typically \char`\"{}0.\+0.\+0.\+0\char`\"{}. Usage of a wildcard allows one to specify default behavior to varying degrees.

For example, making the origin address a wildcard, but leaving the multicast group specific allows one (in the case of a node with multiple interfaces) to create different routes using different output interfaces for each multicast group.

If the origin and multicast addresses are made wildcards, you have created essentially a default multicast address that can forward to multiple interfaces. Compare this to the actual default multicast address that is limited to specifying a single output interface for compatibility with existing functionality in other systems.


\begin{DoxyParams}{Parameters}
{\em origin} & The \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} of the origin of packets for this route. May be \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address}\+:Get\+Any for open groups. \\
\hline
{\em group} & The \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} of the multicast group or this route. \\
\hline
{\em input\+Interface} & The input network interface index over which to expect packets destined for this route. May be Ipv4\+Routing\+Protocol\+::\+I\+N\+T\+E\+R\+F\+A\+C\+E\+\_\+\+A\+NY for packets of local origin. \\
\hline
{\em output\+Interfaces} & A vector of network interface indices used to specify how to send packets to the destination(s).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} 
\end{DoxySeeAlso}

\begin{DoxyCode}
125 \{
126   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << origin << \textcolor{stringliteral}{" "} << \hyperlink{namespacevisualizer_1_1higcontainer_aa6ad2b76790275bfce7783429beaa23f}{group} << \textcolor{stringliteral}{" "} << inputInterface << \textcolor{stringliteral}{" "} << &
      outputInterfaces);
127   Ipv4MulticastRoutingTableEntry *route = \textcolor{keyword}{new} Ipv4MulticastRoutingTableEntry ();
128   *route = \hyperlink{classns3_1_1Ipv4MulticastRoutingTableEntry_abe362dd84c42e6a93a7b793f88e8d3fd}{Ipv4MulticastRoutingTableEntry::CreateMulticastRoute}
       (origin, \hyperlink{namespacevisualizer_1_1higcontainer_aa6ad2b76790275bfce7783429beaa23f}{group}, 
129                                                                  inputInterface, outputInterfaces);
130   \hyperlink{classns3_1_1Ipv4StaticRouting_a5aaf2ee73a6590cc164ac9485d89b538}{m\_multicastRoutes}.push\_back (route);
131 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5


\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Add\+Network\+Route\+To@{Add\+Network\+Route\+To}}
\index{Add\+Network\+Route\+To@{Add\+Network\+Route\+To}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Add\+Network\+Route\+To(\+Ipv4\+Address network, Ipv4\+Mask network\+Mask, Ipv4\+Address next\+Hop, uint32\+\_\+t interface, uint32\+\_\+t metric=0)}{AddNetworkRouteTo(Ipv4Address network, Ipv4Mask networkMask, Ipv4Address nextHop, uint32_t interface, uint32_t metric=0)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Static\+Routing\+::\+Add\+Network\+Route\+To (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{network, }
\item[{{\bf Ipv4\+Mask}}]{network\+Mask, }
\item[{{\bf Ipv4\+Address}}]{next\+Hop, }
\item[{uint32\+\_\+t}]{interface, }
\item[{uint32\+\_\+t}]{metric = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4StaticRouting_a8bf5eaa7ba49fe33c78c70d5560b6c39}{}\label{classns3_1_1Ipv4StaticRouting_a8bf5eaa7ba49fe33c78c70d5560b6c39}


Add a network route to the static routing table. 


\begin{DoxyParams}{Parameters}
{\em network} & The \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} network for this route. \\
\hline
{\em network\+Mask} & The \hyperlink{classns3_1_1Ipv4Mask}{Ipv4\+Mask} to extract the network. \\
\hline
{\em next\+Hop} & The next hop in the route to the destination network. \\
\hline
{\em interface} & The network interface index used to send packets to the destination. \\
\hline
{\em metric} & Metric of route in case of multiple routes to same destination\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} 
\end{DoxySeeAlso}

\begin{DoxyCode}
68 \{
69   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << network << \textcolor{stringliteral}{" "} << networkMask << \textcolor{stringliteral}{" "} << nextHop << \textcolor{stringliteral}{" "} << 
      interface << \textcolor{stringliteral}{" "} << metric);
70   Ipv4RoutingTableEntry *route = \textcolor{keyword}{new} Ipv4RoutingTableEntry ();
71   *route = \hyperlink{classns3_1_1Ipv4RoutingTableEntry_abe3447a00495ded05ab095673531947a}{Ipv4RoutingTableEntry::CreateNetworkRouteTo} (network,
72                                                         networkMask,
73                                                         nextHop,
74                                                         interface);
75   \hyperlink{classns3_1_1Ipv4StaticRouting_a81e0b111629b14fff2efbf69180a64c1}{m\_networkRoutes}.push\_back (make\_pair (route,metric));
76 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6




Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Add\+Network\+Route\+To@{Add\+Network\+Route\+To}}
\index{Add\+Network\+Route\+To@{Add\+Network\+Route\+To}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Add\+Network\+Route\+To(\+Ipv4\+Address network, Ipv4\+Mask network\+Mask, uint32\+\_\+t interface, uint32\+\_\+t metric=0)}{AddNetworkRouteTo(Ipv4Address network, Ipv4Mask networkMask, uint32_t interface, uint32_t metric=0)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Static\+Routing\+::\+Add\+Network\+Route\+To (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{network, }
\item[{{\bf Ipv4\+Mask}}]{network\+Mask, }
\item[{uint32\+\_\+t}]{interface, }
\item[{uint32\+\_\+t}]{metric = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4StaticRouting_a04e91acd20c34069034677b1b491f30e}{}\label{classns3_1_1Ipv4StaticRouting_a04e91acd20c34069034677b1b491f30e}


Add a network route to the static routing table. 


\begin{DoxyParams}{Parameters}
{\em network} & The \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} network for this route. \\
\hline
{\em network\+Mask} & The \hyperlink{classns3_1_1Ipv4Mask}{Ipv4\+Mask} to extract the network. \\
\hline
{\em interface} & The network interface index used to send packets to the destination. \\
\hline
{\em metric} & Metric of route in case of multiple routes to same destination\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} 
\end{DoxySeeAlso}

\begin{DoxyCode}
83 \{
84   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << network << \textcolor{stringliteral}{" "} << networkMask << \textcolor{stringliteral}{" "} << interface << \textcolor{stringliteral}{" "} << 
      metric);
85   Ipv4RoutingTableEntry *route = \textcolor{keyword}{new} Ipv4RoutingTableEntry ();
86   *route = \hyperlink{classns3_1_1Ipv4RoutingTableEntry_abe3447a00495ded05ab095673531947a}{Ipv4RoutingTableEntry::CreateNetworkRouteTo} (network,
87                                                         networkMask,
88                                                         interface);
89   \hyperlink{classns3_1_1Ipv4StaticRouting_a81e0b111629b14fff2efbf69180a64c1}{m\_networkRoutes}.push\_back (make\_pair (route,metric));
90 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8


\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Do\+Dispose(void)}{DoDispose(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Static\+Routing\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4StaticRouting_a54fac8e7b55b72baaa54d94ed98cf9a1}{}\label{classns3_1_1Ipv4StaticRouting_a54fac8e7b55b72baaa54d94ed98cf9a1}
Destructor implementation.

This method is called by \hyperlink{classns3_1_1Object_aa90ae598863f6c251cdab3c3722afdaf}{Dispose()} or by the \hyperlink{classns3_1_1Object}{Object}\textquotesingle{}s destructor, whichever comes first.

Subclasses are expected to implement their real destruction code in an overriden version of this method and chain up to their parent\textquotesingle{}s implementation once they are done. {\itshape i.\+e}, for simplicity, the destructor of every subclass should be empty and its content should be moved to the associated \hyperlink{classns3_1_1Ipv4StaticRouting_a54fac8e7b55b72baaa54d94ed98cf9a1}{Do\+Dispose()} method.

It is safe to call \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{Get\+Object()} from within this method. 

Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.


\begin{DoxyCode}
570 \{
571   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
572   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv4StaticRouting_a3d4f303cbea2117f36f3dd2da3ac59c9}{NetworkRoutesI} j = \hyperlink{classns3_1_1Ipv4StaticRouting_a81e0b111629b14fff2efbf69180a64c1}{m\_networkRoutes}.begin (); 
573        j != \hyperlink{classns3_1_1Ipv4StaticRouting_a81e0b111629b14fff2efbf69180a64c1}{m\_networkRoutes}.end (); 
574        j = \hyperlink{classns3_1_1Ipv4StaticRouting_a81e0b111629b14fff2efbf69180a64c1}{m\_networkRoutes}.erase (j)) 
575     \{
576       \textcolor{keyword}{delete} (j->first);
577     \}
578   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv4StaticRouting_ac832d5465e0c8f5dd30c6d024c2a2234}{MulticastRoutesI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Ipv4StaticRouting_a5aaf2ee73a6590cc164ac9485d89b538}{m\_multicastRoutes}.begin (); 
579        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1Ipv4StaticRouting_a5aaf2ee73a6590cc164ac9485d89b538}{m\_multicastRoutes}.end (); 
580        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Ipv4StaticRouting_a5aaf2ee73a6590cc164ac9485d89b538}{m\_multicastRoutes}.erase (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})) 
581     \{
582       \textcolor{keyword}{delete} (*i);
583     \}
584   \hyperlink{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{m\_ipv4} = 0;
585   \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{Ipv4RoutingProtocol::DoDispose} ();
586 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9


\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Get\+Default\+Route@{Get\+Default\+Route}}
\index{Get\+Default\+Route@{Get\+Default\+Route}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Default\+Route(void)}{GetDefaultRoute(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Routing\+Table\+Entry} ns3\+::\+Ipv4\+Static\+Routing\+::\+Get\+Default\+Route (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4StaticRouting_a3e3079305b988d61fdd56d9990499a6e}{}\label{classns3_1_1Ipv4StaticRouting_a3e3079305b988d61fdd56d9990499a6e}


Get the default route with lowest metric from the static routing table. 

\begin{DoxyReturn}{Returns}
If the default route is set, a pointer to that \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} is returned, otherwise an empty routing table entry is returned. If multiple default routes exist, the one with lowest metric is returned.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} 
\end{DoxySeeAlso}

\begin{DoxyCode}
365 \{
366   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
367   \textcolor{comment}{// Basically a repeat of LookupStatic, retained for backward compatibility}
368   Ipv4Address dest (\textcolor{stringliteral}{"0.0.0.0"});
369   uint32\_t shortest\_metric = 0xffffffff;
370   Ipv4RoutingTableEntry *result = 0;
371   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv4StaticRouting_a3d4f303cbea2117f36f3dd2da3ac59c9}{NetworkRoutesI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Ipv4StaticRouting_a81e0b111629b14fff2efbf69180a64c1}{m\_networkRoutes}.begin (); 
372        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1Ipv4StaticRouting_a81e0b111629b14fff2efbf69180a64c1}{m\_networkRoutes}.end (); 
373        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++) 
374     \{
375       Ipv4RoutingTableEntry *j = \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->first;
376       uint32\_t metric = \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second;
377       Ipv4Mask mask = (j)->GetDestNetworkMask ();
378       uint16\_t masklen = mask.GetPrefixLength ();
379       \textcolor{keywordflow}{if} (masklen != 0)
380         \{
381           \textcolor{keywordflow}{continue};
382         \}
383       \textcolor{keywordflow}{if} (metric > shortest\_metric)
384         \{
385           \textcolor{keywordflow}{continue};
386         \}
387       shortest\_metric = metric;
388       result = j;
389     \}
390   \textcolor{keywordflow}{if} (result)
391     \{
392       \textcolor{keywordflow}{return} result;
393     \}
394   \textcolor{keywordflow}{else}
395     \{
396       \textcolor{keywordflow}{return} Ipv4RoutingTableEntry ();
397     \}
398 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10


\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Get\+Metric@{Get\+Metric}}
\index{Get\+Metric@{Get\+Metric}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Metric(uint32\+\_\+t index) const }{GetMetric(uint32_t index) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Ipv4\+Static\+Routing\+::\+Get\+Metric (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{index}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv4StaticRouting_adae3d8690cec2cac5f5c4e2b239feb17}{}\label{classns3_1_1Ipv4StaticRouting_adae3d8690cec2cac5f5c4e2b239feb17}


Get a metric for route from the static unicast routing table. 


\begin{DoxyParams}{Parameters}
{\em index} & The index (into the routing table) of the route to retrieve. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If route is set, the metric is returned. If not, an infinity metric (0xffffffff) is returned 
\end{DoxyReturn}

\begin{DoxyCode}
422 \{
423   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << index);
424   uint32\_t tmp = 0;
425   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv4StaticRouting_ab8f7a067b65c827dd5012d9a99d79d1e}{NetworkRoutesCI} j = \hyperlink{classns3_1_1Ipv4StaticRouting_a81e0b111629b14fff2efbf69180a64c1}{m\_networkRoutes}.begin ();
426        j != \hyperlink{classns3_1_1Ipv4StaticRouting_a81e0b111629b14fff2efbf69180a64c1}{m\_networkRoutes}.end (); 
427        j++) 
428     \{
429       \textcolor{keywordflow}{if} (tmp == index)
430         \{
431           \textcolor{keywordflow}{return} j->second;
432         \}
433       tmp++;
434     \}
435   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\textcolor{keyword}{false});
436   \textcolor{comment}{// quiet compiler.}
437   \textcolor{keywordflow}{return} 0;
438 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Get\+Multicast\+Route@{Get\+Multicast\+Route}}
\index{Get\+Multicast\+Route@{Get\+Multicast\+Route}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Multicast\+Route(uint32\+\_\+t i) const }{GetMulticastRoute(uint32_t i) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Multicast\+Routing\+Table\+Entry} ns3\+::\+Ipv4\+Static\+Routing\+::\+Get\+Multicast\+Route (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv4StaticRouting_ad98dc9192a4fc144074fac4f5b857658}{}\label{classns3_1_1Ipv4StaticRouting_ad98dc9192a4fc144074fac4f5b857658}


Get a route from the static multicast routing table. 

Externally, the multicast static routing table appears simply as a table with n entries.


\begin{DoxyParams}{Parameters}
{\em i} & The index (into the routing table) of the multicast route to retrieve. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If route {\itshape i} is set, a pointer to that \hyperlink{classns3_1_1Ipv4MulticastRoutingTableEntry}{Ipv4\+Multicast\+Routing\+Table\+Entry} is returned, otherwise a zero pointer is returned.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Ipv4MulticastRoutingTableEntry}{Ipv4\+Multicast\+Routing\+Table\+Entry} 

\hyperlink{classns3_1_1Ipv4StaticRouting_a2814791ae24de098c228d8ec64278444}{Ipv4\+Static\+Routing\+::\+Remove\+Route} 
\end{DoxySeeAlso}

\begin{DoxyCode}
158 \{
159   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << index);
160   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (index < \hyperlink{classns3_1_1Ipv4StaticRouting_a5aaf2ee73a6590cc164ac9485d89b538}{m\_multicastRoutes}.size (),
161                  \textcolor{stringliteral}{"Ipv4StaticRouting::GetMulticastRoute ():  Index out of range"});
162 
163   \textcolor{keywordflow}{if} (index < \hyperlink{classns3_1_1Ipv4StaticRouting_a5aaf2ee73a6590cc164ac9485d89b538}{m\_multicastRoutes}.size ())
164     \{
165       uint32\_t tmp = 0;
166       \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv4StaticRouting_a8edf8cf21421add8ab26b5120797f21f}{MulticastRoutesCI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Ipv4StaticRouting_a5aaf2ee73a6590cc164ac9485d89b538}{m\_multicastRoutes}.begin (); 
167            \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1Ipv4StaticRouting_a5aaf2ee73a6590cc164ac9485d89b538}{m\_multicastRoutes}.end (); 
168            \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++) 
169         \{
170           \textcolor{keywordflow}{if} (tmp  == index)
171             \{
172               \textcolor{keywordflow}{return} *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
173             \}
174           tmp++;
175         \}
176     \}
177   \textcolor{keywordflow}{return} 0;
178 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Get\+N\+Multicast\+Routes@{Get\+N\+Multicast\+Routes}}
\index{Get\+N\+Multicast\+Routes@{Get\+N\+Multicast\+Routes}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Get\+N\+Multicast\+Routes(void) const }{GetNMulticastRoutes(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Ipv4\+Static\+Routing\+::\+Get\+N\+Multicast\+Routes (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv4StaticRouting_a12d3044b0fa28e961e7705ae26387bc9}{}\label{classns3_1_1Ipv4StaticRouting_a12d3044b0fa28e961e7705ae26387bc9}


Get the number of individual multicast routes that have been added to the routing table. 

\begin{DoxyWarning}{Warning}
The default multicast route counts as one of the routes. 
\end{DoxyWarning}
\begin{DoxyReturn}{Returns}
number of entries 
\end{DoxyReturn}

\begin{DoxyCode}
151 \{
152   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
153   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv4StaticRouting_a5aaf2ee73a6590cc164ac9485d89b538}{m\_multicastRoutes}.size ();
154 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Get\+N\+Routes@{Get\+N\+Routes}}
\index{Get\+N\+Routes@{Get\+N\+Routes}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Get\+N\+Routes(void) const }{GetNRoutes(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Ipv4\+Static\+Routing\+::\+Get\+N\+Routes (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv4StaticRouting_a074f780e02f4252e8daa59ed70f499ab}{}\label{classns3_1_1Ipv4StaticRouting_a074f780e02f4252e8daa59ed70f499ab}


Get the number of individual unicast routes that have been added to the routing table. 

\begin{DoxyWarning}{Warning}
The default route counts as one of the routes. 
\end{DoxyWarning}
\begin{DoxyReturn}{Returns}
number of entries 
\end{DoxyReturn}

\begin{DoxyCode}
358 \{
359   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
360   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv4StaticRouting_a81e0b111629b14fff2efbf69180a64c1}{m\_networkRoutes}.size ();;
361 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 12


\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Get\+Route@{Get\+Route}}
\index{Get\+Route@{Get\+Route}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Route(uint32\+\_\+t i) const }{GetRoute(uint32_t i) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Routing\+Table\+Entry} ns3\+::\+Ipv4\+Static\+Routing\+::\+Get\+Route (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv4StaticRouting_a2bd58c5ceeaff35b32a68826fbec5245}{}\label{classns3_1_1Ipv4StaticRouting_a2bd58c5ceeaff35b32a68826fbec5245}


Get a route from the static unicast routing table. 

Externally, the unicast static routing table appears simply as a table with n entries.


\begin{DoxyParams}{Parameters}
{\em i} & The index (into the routing table) of the route to retrieve. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If route is set, a pointer to that \hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} is returned, otherwise a zero pointer is returned.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} 

\hyperlink{classns3_1_1Ipv4StaticRouting_a2814791ae24de098c228d8ec64278444}{Ipv4\+Static\+Routing\+::\+Remove\+Route} 
\end{DoxySeeAlso}

\begin{DoxyCode}
402 \{
403   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << index);
404   uint32\_t tmp = 0;
405   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv4StaticRouting_ab8f7a067b65c827dd5012d9a99d79d1e}{NetworkRoutesCI} j = \hyperlink{classns3_1_1Ipv4StaticRouting_a81e0b111629b14fff2efbf69180a64c1}{m\_networkRoutes}.begin (); 
406        j != \hyperlink{classns3_1_1Ipv4StaticRouting_a81e0b111629b14fff2efbf69180a64c1}{m\_networkRoutes}.end (); 
407        j++) 
408     \{
409       \textcolor{keywordflow}{if} (tmp  == index)
410         \{
411           \textcolor{keywordflow}{return} j->first;
412         \}
413       tmp++;
414     \}
415   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\textcolor{keyword}{false});
416   \textcolor{comment}{// quiet compiler.}
417   \textcolor{keywordflow}{return} 0;
418 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 13


\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Ipv4\+Static\+Routing\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv4StaticRouting_ae81d892774266a25710d1031d0e422eb}{}\label{classns3_1_1Ipv4StaticRouting_ae81d892774266a25710d1031d0e422eb}


The interface Id associated with this class. 

\begin{DoxyReturn}{Returns}
type identifier 
\end{DoxyReturn}

\begin{DoxyCode}
47 \{
48   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::Ipv4StaticRouting"})
49     .SetParent<Ipv4RoutingProtocol> ()
50     .SetGroupName (\textcolor{stringliteral}{"Internet"})
51     .AddConstructor<\hyperlink{classns3_1_1Ipv4StaticRouting_ae472733cd2a237a8afa7ce343c116131}{Ipv4StaticRouting}> ()
52   ;
53   \textcolor{keywordflow}{return} tid;
54 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 14


\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Lookup\+Static@{Lookup\+Static}}
\index{Lookup\+Static@{Lookup\+Static}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Lookup\+Static(\+Ipv4\+Address dest, Ptr$<$ Net\+Device $>$ oif=0)}{LookupStatic(Ipv4Address dest, Ptr< NetDevice > oif=0)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv4\+Route} $>$ ns3\+::\+Ipv4\+Static\+Routing\+::\+Lookup\+Static (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{dest, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{oif = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4StaticRouting_a9ee2a4c5597e9b238369ba3667121852}{}\label{classns3_1_1Ipv4StaticRouting_a9ee2a4c5597e9b238369ba3667121852}


Lookup in the forwarding table for destination. 


\begin{DoxyParams}{Parameters}
{\em dest} & destination address \\
\hline
{\em oif} & output interface if any (put 0 otherwise) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} to route the packet to reach dest address 
\end{DoxyReturn}

\begin{DoxyCode}
224 \{
225   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << dest << \textcolor{stringliteral}{" "} << oif);
226   Ptr<Ipv4Route> rtentry = 0;
227   uint16\_t longest\_mask = 0;
228   uint32\_t shortest\_metric = 0xffffffff;
229   \textcolor{comment}{/* when sending on local multicast, there have to be interface specified */}
230   \textcolor{keywordflow}{if} (dest.IsLocalMulticast ())
231     \{
232       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (oif, \textcolor{stringliteral}{"Try to send on link-local multicast address, and no interface index
       is given!"});
233 
234       rtentry = Create<Ipv4Route> ();
235       rtentry->SetDestination (dest);
236       rtentry->SetGateway (\hyperlink{classns3_1_1Ipv4Address_aeeb1c76b35d4ab612fda7bc51e99c5db}{Ipv4Address::GetZero} ());
237       rtentry->SetOutputDevice (oif);
238       rtentry->SetSource (\hyperlink{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{m\_ipv4}->GetAddress (\hyperlink{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{m\_ipv4}->GetInterfaceForDevice (oif), 0).GetLocal 
      ());
239       \textcolor{keywordflow}{return} rtentry;
240     \}
241 
242 
243   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv4StaticRouting_a3d4f303cbea2117f36f3dd2da3ac59c9}{NetworkRoutesI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Ipv4StaticRouting_a81e0b111629b14fff2efbf69180a64c1}{m\_networkRoutes}.begin (); 
244        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1Ipv4StaticRouting_a81e0b111629b14fff2efbf69180a64c1}{m\_networkRoutes}.end (); 
245        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++) 
246     \{
247       Ipv4RoutingTableEntry *j=\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->first;
248       uint32\_t metric =\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}->second;
249       Ipv4Mask mask = (j)->GetDestNetworkMask ();
250       uint16\_t masklen = mask.GetPrefixLength ();
251       Ipv4Address entry = (j)->GetDestNetwork ();
252       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Searching for route to "} << dest << \textcolor{stringliteral}{", checking against route to "} << 
      entry << \textcolor{stringliteral}{"/"} << masklen);
253       \textcolor{keywordflow}{if} (mask.IsMatch (dest, entry)) 
254         \{
255           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Found global network route "} << j << \textcolor{stringliteral}{", mask length "} << masklen << \textcolor{stringliteral}{",
       metric "} << metric);
256           \textcolor{keywordflow}{if} (oif != 0)
257             \{
258               \textcolor{keywordflow}{if} (oif != \hyperlink{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{m\_ipv4}->GetNetDevice (j->GetInterface ()))
259                 \{
260                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Not on requested interface, skipping"});
261                   \textcolor{keywordflow}{continue};
262                 \}
263             \}
264           \textcolor{keywordflow}{if} (masklen < longest\_mask) \textcolor{comment}{// Not interested if got shorter mask}
265             \{
266               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Previous match longer, skipping"});
267               \textcolor{keywordflow}{continue};
268             \}
269           \textcolor{keywordflow}{if} (masklen > longest\_mask) \textcolor{comment}{// Reset metric if longer masklen}
270             \{
271               shortest\_metric = 0xffffffff;
272             \}
273           longest\_mask = masklen;
274           \textcolor{keywordflow}{if} (metric > shortest\_metric)
275             \{
276               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Equal mask length, but previous metric shorter, skipping"});
277               \textcolor{keywordflow}{continue};
278             \}
279           shortest\_metric = metric;
280           Ipv4RoutingTableEntry* route = (j);
281           uint32\_t interfaceIdx = route->GetInterface ();
282           rtentry = Create<Ipv4Route> ();
283           rtentry->SetDestination (route->GetDest ());
284           rtentry->SetSource (\hyperlink{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{m\_ipv4}->SourceAddressSelection (interfaceIdx, route->GetDest ()));
285           rtentry->SetGateway (route->GetGateway ());
286           rtentry->SetOutputDevice (\hyperlink{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{m\_ipv4}->GetNetDevice (interfaceIdx));
287           \textcolor{keywordflow}{if} (masklen == 32)
288             \{
289               \textcolor{keywordflow}{break};
290             \}
291         \}
292     \}
293   \textcolor{keywordflow}{if} (rtentry != 0)
294     \{
295       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Matching route via "} << rtentry->GetGateway () << \textcolor{stringliteral}{" at the end"});
296     \}
297   \textcolor{keywordflow}{else}
298     \{
299       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"No matching route to "} << dest << \textcolor{stringliteral}{" found"});
300     \}
301   \textcolor{keywordflow}{return} rtentry;
302 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 15




Here is the caller graph for this function\+:
% FIG 16


\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Lookup\+Static@{Lookup\+Static}}
\index{Lookup\+Static@{Lookup\+Static}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Lookup\+Static(\+Ipv4\+Address origin, Ipv4\+Address group, uint32\+\_\+t interface)}{LookupStatic(Ipv4Address origin, Ipv4Address group, uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv4\+Multicast\+Route} $>$ ns3\+::\+Ipv4\+Static\+Routing\+::\+Lookup\+Static (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{origin, }
\item[{{\bf Ipv4\+Address}}]{group, }
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4StaticRouting_acc26ca2e9144cec5748e51d07edf7088}{}\label{classns3_1_1Ipv4StaticRouting_acc26ca2e9144cec5748e51d07edf7088}


Lookup in the multicast forwarding table for destination. 


\begin{DoxyParams}{Parameters}
{\em origin} & source address \\
\hline
{\em group} & group multicast address \\
\hline
{\em interface} & interface index \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{classns3_1_1Ipv4MulticastRoute}{Ipv4\+Multicast\+Route} to route the packet to reach dest address 
\end{DoxyReturn}

\begin{DoxyCode}
309 \{
310   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << origin << \textcolor{stringliteral}{" "} << \hyperlink{namespacevisualizer_1_1higcontainer_aa6ad2b76790275bfce7783429beaa23f}{group} << \textcolor{stringliteral}{" "} << interface);
311   Ptr<Ipv4MulticastRoute> mrtentry = 0;
312 
313   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv4StaticRouting_ac832d5465e0c8f5dd30c6d024c2a2234}{MulticastRoutesI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Ipv4StaticRouting_a5aaf2ee73a6590cc164ac9485d89b538}{m\_multicastRoutes}.begin (); 
314        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1Ipv4StaticRouting_a5aaf2ee73a6590cc164ac9485d89b538}{m\_multicastRoutes}.end (); 
315        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++) 
316     \{
317       Ipv4MulticastRoutingTableEntry *route = *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
318 \textcolor{comment}{//}
319 \textcolor{comment}{// We've been passed an origin address, a multicast group address and an }
320 \textcolor{comment}{// interface index.  We have to decide if the current route in the list is}
321 \textcolor{comment}{// a match.}
322 \textcolor{comment}{//}
323 \textcolor{comment}{// The first case is the restrictive case where the origin, group and index}
324 \textcolor{comment}{// matches.}
325 \textcolor{comment}{//}
326       \textcolor{keywordflow}{if} (origin == route->GetOrigin () && \hyperlink{namespacevisualizer_1_1higcontainer_aa6ad2b76790275bfce7783429beaa23f}{group} == route->GetGroup ())
327         \{
328           \textcolor{comment}{// Skipping this case (SSM) for now}
329           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Found multicast source specific route"} << *
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
330         \}
331       \textcolor{keywordflow}{if} (\hyperlink{namespacevisualizer_1_1higcontainer_aa6ad2b76790275bfce7783429beaa23f}{group} == route->GetGroup ())
332         \{
333           \textcolor{keywordflow}{if} (interface == \hyperlink{classns3_1_1Ipv4_a9b05b2610976f8d53da45d95891a0657}{Ipv4::IF\_ANY} || 
334               interface == route->GetInputInterface ())
335             \{
336               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Found multicast route"} << *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
337               mrtentry = Create<Ipv4MulticastRoute> ();
338               mrtentry->SetGroup (route->GetGroup ());
339               mrtentry->SetOrigin (route->GetOrigin ());
340               mrtentry->SetParent (route->GetInputInterface ());
341               \textcolor{keywordflow}{for} (uint32\_t j = 0; j < route->GetNOutputInterfaces (); j++)
342                 \{
343                   \textcolor{keywordflow}{if} (route->GetOutputInterface (j))
344                     \{
345                       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Setting output interface index "} << route->
      GetOutputInterface (j));
346                       mrtentry->SetOutputTtl (route->GetOutputInterface (j), 
      \hyperlink{classns3_1_1Ipv4MulticastRoute_ab7118310b9ac11a437788db9c1250412}{Ipv4MulticastRoute::MAX\_TTL} - 1);
347                     \}
348                 \}
349               \textcolor{keywordflow}{return} mrtentry;
350             \}
351         \}
352     \}
353   \textcolor{keywordflow}{return} mrtentry;
354 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 17


\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Notify\+Add\+Address@{Notify\+Add\+Address}}
\index{Notify\+Add\+Address@{Notify\+Add\+Address}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Notify\+Add\+Address(uint32\+\_\+t interface, Ipv4\+Interface\+Address address)}{NotifyAddAddress(uint32_t interface, Ipv4InterfaceAddress address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Static\+Routing\+::\+Notify\+Add\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv4\+Interface\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4StaticRouting_ad9cd500198ceab0fec83610cd3f2d1e9}{}\label{classns3_1_1Ipv4StaticRouting_ad9cd500198ceab0fec83610cd3f2d1e9}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
{\em address} & a new address being added to an interface\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified whenever a new address is added to an interface. Typically used to add a \textquotesingle{}network route\textquotesingle{} on an interface. Can be invoked on an up or down interface. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_aef12fcf9cc478536876b0281505d40aa}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
628 \{
629   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << interface << \textcolor{stringliteral}{" "} << address.GetLocal ());
630   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{m\_ipv4}->IsUp (interface))
631     \{
632       \textcolor{keywordflow}{return};
633     \}
634 
635   Ipv4Address networkAddress = address.GetLocal ().CombineMask (address.GetMask ());
636   Ipv4Mask networkMask = address.GetMask ();
637   \textcolor{keywordflow}{if} (address.GetLocal () != Ipv4Address () &&
638       address.GetMask () != Ipv4Mask ())
639     \{
640       \hyperlink{classns3_1_1Ipv4StaticRouting_a8bf5eaa7ba49fe33c78c70d5560b6c39}{AddNetworkRouteTo} (networkAddress,
641                          networkMask, interface);
642     \}
643 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 18


\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Notify\+Interface\+Down@{Notify\+Interface\+Down}}
\index{Notify\+Interface\+Down@{Notify\+Interface\+Down}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Notify\+Interface\+Down(uint32\+\_\+t interface)}{NotifyInterfaceDown(uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Static\+Routing\+::\+Notify\+Interface\+Down (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4StaticRouting_a22f00ba2dabe60e0653e278e221aa97b}{}\label{classns3_1_1Ipv4StaticRouting_a22f00ba2dabe60e0653e278e221aa97b}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified of the state change of an interface in a node. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a90f728b73ccb1806e5a4093ff156f607}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
609 \{
610   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
611   \textcolor{comment}{// Remove all static routes that are going through this interface}
612   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv4StaticRouting_a3d4f303cbea2117f36f3dd2da3ac59c9}{NetworkRoutesI} it = \hyperlink{classns3_1_1Ipv4StaticRouting_a81e0b111629b14fff2efbf69180a64c1}{m\_networkRoutes}.begin (); it != 
      \hyperlink{classns3_1_1Ipv4StaticRouting_a81e0b111629b14fff2efbf69180a64c1}{m\_networkRoutes}.end (); )
613     \{
614       \textcolor{keywordflow}{if} (it->first->GetInterface () == \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
615         \{
616           \textcolor{keyword}{delete} it->first;
617           it = \hyperlink{classns3_1_1Ipv4StaticRouting_a81e0b111629b14fff2efbf69180a64c1}{m\_networkRoutes}.erase (it);
618         \}
619       \textcolor{keywordflow}{else}
620         \{
621           it++;
622         \}
623     \}
624 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 19


\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Notify\+Interface\+Up@{Notify\+Interface\+Up}}
\index{Notify\+Interface\+Up@{Notify\+Interface\+Up}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Notify\+Interface\+Up(uint32\+\_\+t interface)}{NotifyInterfaceUp(uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Static\+Routing\+::\+Notify\+Interface\+Up (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4StaticRouting_a2c84913a130adb6dbd2814da95e789fb}{}\label{classns3_1_1Ipv4StaticRouting_a2c84913a130adb6dbd2814da95e789fb}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified of the state change of an interface in a node. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_aabb99ce7a048e75ff4b36fa9af8745e4}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
590 \{
591   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
592   \textcolor{comment}{// If interface address and network mask have been set, add a route}
593   \textcolor{comment}{// to the network of the interface (like e.g. ifconfig does on a}
594   \textcolor{comment}{// Linux box)}
595   \textcolor{keywordflow}{for} (uint32\_t j = 0; j < \hyperlink{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{m\_ipv4}->GetNAddresses (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}); j++)
596     \{
597       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{m\_ipv4}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i},j).GetLocal () != Ipv4Address () &&
598           \hyperlink{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{m\_ipv4}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i},j).GetMask () != Ipv4Mask () &&
599           \hyperlink{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{m\_ipv4}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i},j).GetMask () != \hyperlink{classns3_1_1Ipv4Mask_af712cbdf28c039025d4aa45fa7e243dd}{Ipv4Mask::GetOnes} ())
600         \{
601           \hyperlink{classns3_1_1Ipv4StaticRouting_a8bf5eaa7ba49fe33c78c70d5560b6c39}{AddNetworkRouteTo} (\hyperlink{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{m\_ipv4}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i},j).GetLocal ().CombineMask (
      \hyperlink{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{m\_ipv4}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i},j).GetMask ()),
602                              \hyperlink{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{m\_ipv4}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i},j).GetMask (), \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
603         \}
604     \}
605 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 20




Here is the caller graph for this function\+:
% FIG 21


\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Notify\+Remove\+Address@{Notify\+Remove\+Address}}
\index{Notify\+Remove\+Address@{Notify\+Remove\+Address}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Notify\+Remove\+Address(uint32\+\_\+t interface, Ipv4\+Interface\+Address address)}{NotifyRemoveAddress(uint32_t interface, Ipv4InterfaceAddress address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Static\+Routing\+::\+Notify\+Remove\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv4\+Interface\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4StaticRouting_ac7ccf0480e1b0f715a93c474de12b195}{}\label{classns3_1_1Ipv4StaticRouting_ac7ccf0480e1b0f715a93c474de12b195}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
{\em address} & a new address being added to an interface\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified whenever a new address is removed from an interface. Typically used to remove the \textquotesingle{}network route\textquotesingle{} of an interface. Can be invoked on an up or down interface. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a0160e49e509d6699ec837e5485f65cd2}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
646 \{
647   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << interface << \textcolor{stringliteral}{" "} << address.GetLocal ());
648   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{m\_ipv4}->IsUp (interface))
649     \{
650       \textcolor{keywordflow}{return};
651     \}
652   Ipv4Address networkAddress = address.GetLocal ().CombineMask (address.GetMask ());
653   Ipv4Mask networkMask = address.GetMask ();
654   \textcolor{comment}{// Remove all static routes that are going through this interface}
655   \textcolor{comment}{// which reference this network}
656   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv4StaticRouting_a3d4f303cbea2117f36f3dd2da3ac59c9}{NetworkRoutesI} it = \hyperlink{classns3_1_1Ipv4StaticRouting_a81e0b111629b14fff2efbf69180a64c1}{m\_networkRoutes}.begin (); it != 
      \hyperlink{classns3_1_1Ipv4StaticRouting_a81e0b111629b14fff2efbf69180a64c1}{m\_networkRoutes}.end (); )
657     \{
658       \textcolor{keywordflow}{if} (it->first->GetInterface () == interface
659           && it->first->IsNetwork ()
660           && it->first->GetDestNetwork () == networkAddress
661           && it->first->GetDestNetworkMask () == networkMask)
662         \{
663           \textcolor{keyword}{delete} it->first;
664           it = \hyperlink{classns3_1_1Ipv4StaticRouting_a81e0b111629b14fff2efbf69180a64c1}{m\_networkRoutes}.erase (it);
665         \}
666       \textcolor{keywordflow}{else}
667         \{
668           it++;
669         \}
670     \}
671 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 22


\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Print\+Routing\+Table@{Print\+Routing\+Table}}
\index{Print\+Routing\+Table@{Print\+Routing\+Table}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Print\+Routing\+Table(\+Ptr$<$ Output\+Stream\+Wrapper $>$ stream, Time\+::\+Unit unit=\+Time\+::\+S) const }{PrintRoutingTable(Ptr< OutputStreamWrapper > stream, Time::Unit unit=Time::S) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Static\+Routing\+::\+Print\+Routing\+Table (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream, }
\item[{{\bf Time\+::\+Unit}}]{unit = {\ttfamily {\bf Time\+::S}}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4StaticRouting_a917ee8a51016e159903df505bf7ded25}{}\label{classns3_1_1Ipv4StaticRouting_a917ee8a51016e159903df505bf7ded25}


Print the Routing Table entries. 


\begin{DoxyParams}{Parameters}
{\em stream} & The ostream the Routing table is printed to \\
\hline
{\em unit} & The time unit to be used in the report \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a86ad3fc1d17b06b6553a13b03d7e8cb4}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
694 \{
695   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << stream);
696   std::ostream* os = stream->\hyperlink{classns3_1_1OutputStreamWrapper_a0cf30a4188ab6fdae2b2ab74db11acc2}{GetStream} ();
697 
698   *os << \textcolor{stringliteral}{"Node: "} << \hyperlink{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{m\_ipv4}->GetObject<Node> ()->GetId ()
699       << \textcolor{stringliteral}{", Time: "} << \hyperlink{group__simulator_gac3635e2e87f7ce316c89290ee1b01d0d}{Now}().\hyperlink{classns3_1_1Time_a0bb1110638ce9938248bd07865a328ab}{As} (unit)
700       << \textcolor{stringliteral}{", Local time: "} << GetObject<Node> ()->GetLocalTime ().As (unit)
701       << \textcolor{stringliteral}{", Ipv4StaticRouting table"} << std::endl;
702 
703   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4StaticRouting_a074f780e02f4252e8daa59ed70f499ab}{GetNRoutes} () > 0)
704     \{
705       *os << \textcolor{stringliteral}{"Destination     Gateway         Genmask         Flags Metric Ref    Use Iface"} << std::endl;
706       \textcolor{keywordflow}{for} (uint32\_t j = 0; j < \hyperlink{classns3_1_1Ipv4StaticRouting_a074f780e02f4252e8daa59ed70f499ab}{GetNRoutes} (); j++)
707         \{
708           std::ostringstream dest, gw, mask, flags;
709           Ipv4RoutingTableEntry route = \hyperlink{classns3_1_1Ipv4StaticRouting_a2bd58c5ceeaff35b32a68826fbec5245}{GetRoute} (j);
710           dest << route.GetDest ();
711           *os << std::setiosflags (std::ios::left) << std::setw (16) << dest.str ();
712           gw << route.GetGateway ();
713           *os << std::setiosflags (std::ios::left) << std::setw (16) << gw.str ();
714           mask << route.GetDestNetworkMask ();
715           *os << std::setiosflags (std::ios::left) << std::setw (16) << mask.str ();
716           flags << \textcolor{stringliteral}{"U"};
717           \textcolor{keywordflow}{if} (route.IsHost ())
718             \{
719               flags << \textcolor{stringliteral}{"HS"};
720             \}
721           \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (route.IsGateway ())
722             \{
723               flags << \textcolor{stringliteral}{"GS"};
724             \}
725           *os << std::setiosflags (std::ios::left) << std::setw (6) << flags.str ();
726           *os << std::setiosflags (std::ios::left) << std::setw (7) << \hyperlink{classns3_1_1Ipv4StaticRouting_adae3d8690cec2cac5f5c4e2b239feb17}{GetMetric} (j);
727           \textcolor{comment}{// Ref ct not implemented}
728           *os << \textcolor{stringliteral}{"-"} << \textcolor{stringliteral}{"      "};
729           \textcolor{comment}{// Use not implemented}
730           *os << \textcolor{stringliteral}{"-"} << \textcolor{stringliteral}{"   "};
731           \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Names_ab9664faf23569aaae64a2d1f65265045}{Names::FindName} (\hyperlink{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{m\_ipv4}->GetNetDevice (route.GetInterface ())) != \textcolor{stringliteral}{""})
732             \{
733               *os << \hyperlink{classns3_1_1Names_ab9664faf23569aaae64a2d1f65265045}{Names::FindName} (\hyperlink{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{m\_ipv4}->GetNetDevice (route.GetInterface ()));
734             \}
735           \textcolor{keywordflow}{else}
736             \{
737               *os << route.GetInterface ();
738             \}
739           *os << std::endl;
740         \}
741     \}
742   *os << std::endl;
743 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 23


\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Remove\+Multicast\+Route@{Remove\+Multicast\+Route}}
\index{Remove\+Multicast\+Route@{Remove\+Multicast\+Route}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Remove\+Multicast\+Route(\+Ipv4\+Address origin, Ipv4\+Address group, uint32\+\_\+t input\+Interface)}{RemoveMulticastRoute(Ipv4Address origin, Ipv4Address group, uint32_t inputInterface)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv4\+Static\+Routing\+::\+Remove\+Multicast\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{origin, }
\item[{{\bf Ipv4\+Address}}]{group, }
\item[{uint32\+\_\+t}]{input\+Interface}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4StaticRouting_afca7bca35c67739be3ee551baaeda4ef}{}\label{classns3_1_1Ipv4StaticRouting_afca7bca35c67739be3ee551baaeda4ef}


Remove a route from the static multicast routing table. 

Externally, the multicast static routing table appears simply as a table with n entries. This method causes the multicast routing table to be searched for the first route that matches the parameters and removes it.

Wildcards may be provided to this function, but the wildcards are used to exactly match wildcards in the routes (see Add\+Multicast\+Route). That is, calling Remove\+Multicast\+Route with the origin set to \char`\"{}0.\+0.\+0.\+0\char`\"{} will not remove routes with any address in the origin, but will only remove routes with \char`\"{}0.\+0.\+0.\+0\char`\"{} set as the the origin.


\begin{DoxyParams}{Parameters}
{\em origin} & The IP address specified as the origin of packets for the route. \\
\hline
{\em group} & The IP address specified as the multicast group address of the route. \\
\hline
{\em input\+Interface} & The network interface index specified as the expected input interface for the route. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if a route was found and removed, false otherwise.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Ipv4MulticastRoutingTableEntry}{Ipv4\+Multicast\+Routing\+Table\+Entry} 

\hyperlink{classns3_1_1Ipv4StaticRouting_a58582a0b87b6705d3c974146a19e25b9}{Ipv4\+Static\+Routing\+::\+Add\+Multicast\+Route} 
\end{DoxySeeAlso}

\begin{DoxyCode}
184 \{
185   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << origin << \textcolor{stringliteral}{" "} << \hyperlink{namespacevisualizer_1_1higcontainer_aa6ad2b76790275bfce7783429beaa23f}{group} << \textcolor{stringliteral}{" "} << inputInterface);
186   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv4StaticRouting_ac832d5465e0c8f5dd30c6d024c2a2234}{MulticastRoutesI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Ipv4StaticRouting_a5aaf2ee73a6590cc164ac9485d89b538}{m\_multicastRoutes}.begin (); 
187        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1Ipv4StaticRouting_a5aaf2ee73a6590cc164ac9485d89b538}{m\_multicastRoutes}.end (); 
188        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++) 
189     \{
190       Ipv4MulticastRoutingTableEntry *route = *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
191       \textcolor{keywordflow}{if} (origin == route->GetOrigin () &&
192           \hyperlink{namespacevisualizer_1_1higcontainer_aa6ad2b76790275bfce7783429beaa23f}{group} == route->GetGroup () &&
193           inputInterface == route->GetInputInterface ())
194         \{
195           \textcolor{keyword}{delete} *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
196           \hyperlink{classns3_1_1Ipv4StaticRouting_a5aaf2ee73a6590cc164ac9485d89b538}{m\_multicastRoutes}.erase (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
197           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
198         \}
199     \}
200   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
201 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 24


\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Remove\+Multicast\+Route@{Remove\+Multicast\+Route}}
\index{Remove\+Multicast\+Route@{Remove\+Multicast\+Route}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Remove\+Multicast\+Route(uint32\+\_\+t index)}{RemoveMulticastRoute(uint32_t index)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Static\+Routing\+::\+Remove\+Multicast\+Route (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{index}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4StaticRouting_a6f530f68b04bcd8bdadec6c41759643c}{}\label{classns3_1_1Ipv4StaticRouting_a6f530f68b04bcd8bdadec6c41759643c}


Remove a route from the static multicast routing table. 

Externally, the multicast static routing table appears simply as a table with n entries.


\begin{DoxyParams}{Parameters}
{\em index} & The index (into the multicast routing table) of the route to remove.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} 

\hyperlink{classns3_1_1Ipv4StaticRouting_a2bd58c5ceeaff35b32a68826fbec5245}{Ipv4\+Static\+Routing\+::\+Get\+Route} 

Ipv4\+Static\+Routing\+::\+Add\+Route 
\end{DoxySeeAlso}

\begin{DoxyCode}
205 \{
206   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << index);
207   uint32\_t tmp = 0;
208   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv4StaticRouting_ac832d5465e0c8f5dd30c6d024c2a2234}{MulticastRoutesI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Ipv4StaticRouting_a5aaf2ee73a6590cc164ac9485d89b538}{m\_multicastRoutes}.begin (); 
209        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1Ipv4StaticRouting_a5aaf2ee73a6590cc164ac9485d89b538}{m\_multicastRoutes}.end (); 
210        \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++) 
211     \{
212       \textcolor{keywordflow}{if} (tmp  == index)
213         \{
214           \textcolor{keyword}{delete} *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
215           \hyperlink{classns3_1_1Ipv4StaticRouting_a5aaf2ee73a6590cc164ac9485d89b538}{m\_multicastRoutes}.erase (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
216           \textcolor{keywordflow}{return};
217         \}
218       tmp++;
219     \}
220 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Remove\+Route@{Remove\+Route}}
\index{Remove\+Route@{Remove\+Route}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Remove\+Route(uint32\+\_\+t i)}{RemoveRoute(uint32_t i)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Static\+Routing\+::\+Remove\+Route (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4StaticRouting_a2814791ae24de098c228d8ec64278444}{}\label{classns3_1_1Ipv4StaticRouting_a2814791ae24de098c228d8ec64278444}


Remove a route from the static unicast routing table. 

Externally, the unicast static routing table appears simply as a table with n entries.


\begin{DoxyParams}{Parameters}
{\em i} & The index (into the routing table) of the route to remove.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Ipv4RoutingTableEntry}{Ipv4\+Routing\+Table\+Entry} 

\hyperlink{classns3_1_1Ipv4StaticRouting_a2bd58c5ceeaff35b32a68826fbec5245}{Ipv4\+Static\+Routing\+::\+Get\+Route} 

Ipv4\+Static\+Routing\+::\+Add\+Route 
\end{DoxySeeAlso}

\begin{DoxyCode}
441 \{
442   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << index);
443   uint32\_t tmp = 0;
444   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv4StaticRouting_a3d4f303cbea2117f36f3dd2da3ac59c9}{NetworkRoutesI} j = \hyperlink{classns3_1_1Ipv4StaticRouting_a81e0b111629b14fff2efbf69180a64c1}{m\_networkRoutes}.begin (); 
445        j != \hyperlink{classns3_1_1Ipv4StaticRouting_a81e0b111629b14fff2efbf69180a64c1}{m\_networkRoutes}.end (); 
446        j++) 
447     \{
448       \textcolor{keywordflow}{if} (tmp == index)
449         \{
450           \textcolor{keyword}{delete} j->first;
451           \hyperlink{classns3_1_1Ipv4StaticRouting_a81e0b111629b14fff2efbf69180a64c1}{m\_networkRoutes}.erase (j);
452           \textcolor{keywordflow}{return};
453         \}
454       tmp++;
455     \}
456   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\textcolor{keyword}{false});
457 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Route\+Input@{Route\+Input}}
\index{Route\+Input@{Route\+Input}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Route\+Input(\+Ptr$<$ const Packet $>$ p, const Ipv4\+Header \&header, Ptr$<$ const Net\+Device $>$ idev, Unicast\+Forward\+Callback ucb, Multicast\+Forward\+Callback mcb, Local\+Deliver\+Callback lcb, Error\+Callback ecb)}{RouteInput(Ptr< const Packet > p, const Ipv4Header &header, Ptr< const NetDevice > idev, UnicastForwardCallback ucb, MulticastForwardCallback mcb, LocalDeliverCallback lcb, ErrorCallback ecb)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv4\+Static\+Routing\+::\+Route\+Input (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv4\+Header} \&}]{header, }
\item[{{\bf Ptr}$<$ const {\bf Net\+Device} $>$}]{idev, }
\item[{{\bf Unicast\+Forward\+Callback}}]{ucb, }
\item[{{\bf Multicast\+Forward\+Callback}}]{mcb, }
\item[{{\bf Local\+Deliver\+Callback}}]{lcb, }
\item[{{\bf Error\+Callback}}]{ecb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4StaticRouting_a5e01a8326cd334ad887953345632d7c1}{}\label{classns3_1_1Ipv4StaticRouting_a5e01a8326cd334ad887953345632d7c1}


Route an input packet (to be forwarded or locally delivered) 

This lookup is used in the forwarding process. The packet is handed over to the \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol}, and will get forwarded onward by one of the callbacks. The Linux equivalent is ip\+\_\+route\+\_\+input(). There are four valid outcomes, and a matching callbacks to handle each.


\begin{DoxyParams}{Parameters}
{\em p} & received packet \\
\hline
{\em header} & input parameter used to form a search key for a route \\
\hline
{\em idev} & Pointer to ingress network device \\
\hline
{\em ucb} & \hyperlink{classns3_1_1Callback}{Callback} for the case in which the packet is to be forwarded as unicast \\
\hline
{\em mcb} & \hyperlink{classns3_1_1Callback}{Callback} for the case in which the packet is to be forwarded as multicast \\
\hline
{\em lcb} & \hyperlink{classns3_1_1Callback}{Callback} for the case in which the packet is to be locally delivered \\
\hline
{\em ecb} & \hyperlink{classns3_1_1Callback}{Callback} to call if there is an error in forwarding \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} takes responsibility for forwarding or delivering the packet, false otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a67e815ff40ebb9f5f4eec4e22e23132e}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
493 \{
494   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} << ipHeader << ipHeader.GetSource () << ipHeader.
      GetDestination () << idev << &ucb << &mcb << &lcb << &ecb);
495 
496   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{m\_ipv4} != 0);
497   \textcolor{comment}{// Check if input device supports IP }
498   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{m\_ipv4}->GetInterfaceForDevice (idev) >= 0);
499   uint32\_t iif = \hyperlink{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{m\_ipv4}->GetInterfaceForDevice (idev); 
500 
501   \textcolor{comment}{// Multicast recognition; handle local delivery here}
502 
503   \textcolor{keywordflow}{if} (ipHeader.GetDestination ().IsMulticast ())
504     \{
505       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Multicast destination"});
506       Ptr<Ipv4MulticastRoute> mrtentry =  \hyperlink{classns3_1_1Ipv4StaticRouting_a9ee2a4c5597e9b238369ba3667121852}{LookupStatic} (ipHeader.GetSource (),
507                                                         ipHeader.GetDestination (), 
      \hyperlink{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{m\_ipv4}->GetInterfaceForDevice (idev));
508 
509       \textcolor{keywordflow}{if} (mrtentry)
510         \{
511           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Multicast route found"});
512           mcb (mrtentry, \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, ipHeader); \textcolor{comment}{// multicast forwarding callback}
513           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
514         \}
515       \textcolor{keywordflow}{else}
516         \{
517           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Multicast route not found"});
518           \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \textcolor{comment}{// Let other routing protocols try to handle this}
519         \}
520     \}
521 
522   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{m\_ipv4}->IsDestinationAddress (ipHeader.GetDestination (), iif))
523     \{
524       \textcolor{keywordflow}{if} (!lcb.IsNull ())
525         \{
526           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Local delivery to "} << ipHeader.GetDestination ());
527           lcb (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, ipHeader, iif);
528           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
529         \}
530       \textcolor{keywordflow}{else}
531         \{
532           \textcolor{comment}{// The local delivery callback is null.  This may be a multicast}
533           \textcolor{comment}{// or broadcast packet, so return false so that another}
534           \textcolor{comment}{// multicast routing protocol can handle it.  It should be possible}
535           \textcolor{comment}{// to extend this to explicitly check whether it is a unicast}
536           \textcolor{comment}{// packet, and invoke the error callback if so}
537           \textcolor{keywordflow}{return} \textcolor{keyword}{false};
538         \}
539     \}
540 
541   \textcolor{comment}{// Check if input device supports IP forwarding}
542   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{m\_ipv4}->IsForwarding (iif) == \textcolor{keyword}{false})
543     \{
544       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Forwarding disabled for this interface"});
545       ecb (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, ipHeader, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{Socket::ERROR\_NOROUTETOHOST});
546       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
547     \}
548   \textcolor{comment}{// Next, try to find a route}
549   Ptr<Ipv4Route> rtentry = \hyperlink{classns3_1_1Ipv4StaticRouting_a9ee2a4c5597e9b238369ba3667121852}{LookupStatic} (ipHeader.GetDestination ());
550   \textcolor{keywordflow}{if} (rtentry != 0)
551     \{
552       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Found unicast destination- calling unicast callback"});
553       ucb (rtentry, \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, ipHeader);  \textcolor{comment}{// unicast forwarding callback}
554       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
555     \}
556   \textcolor{keywordflow}{else}
557     \{
558       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Did not find unicast destination- returning false"});
559       \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \textcolor{comment}{// Let other routing protocols try to handle this}
560     \}
561 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 25


\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Route\+Output@{Route\+Output}}
\index{Route\+Output@{Route\+Output}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Route\+Output(\+Ptr$<$ Packet $>$ p, const Ipv4\+Header \&header, Ptr$<$ Net\+Device $>$ oif, Socket\+::\+Socket\+Errno \&sockerr)}{RouteOutput(Ptr< Packet > p, const Ipv4Header &header, Ptr< NetDevice > oif, Socket::SocketErrno &sockerr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv4\+Route} $>$ ns3\+::\+Ipv4\+Static\+Routing\+::\+Route\+Output (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv4\+Header} \&}]{header, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{oif, }
\item[{{\bf Socket\+::\+Socket\+Errno} \&}]{sockerr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4StaticRouting_a7a8f0d57d249629f1b7d67e6701571e0}{}\label{classns3_1_1Ipv4StaticRouting_a7a8f0d57d249629f1b7d67e6701571e0}


Query routing cache for an existing route, for an outbound packet. 

This lookup is used by transport protocols. It does not cause any packet to be forwarded, and is synchronous. Can be used for multicast or unicast. The Linux equivalent is ip\+\_\+route\+\_\+output()

The header input parameter may have an uninitialized value for the source address, but the destination address should always be properly set by the caller.


\begin{DoxyParams}{Parameters}
{\em p} & packet to be routed. Note that this method may modify the packet. Callers may also pass in a null pointer. \\
\hline
{\em header} & input parameter (used to form key to search for the route) \\
\hline
{\em oif} & Output interface Netdevice. May be zero, or may be bound via socket options to a particular output interface. \\
\hline
{\em sockerr} & Output parameter; socket errno\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a code that indicates what happened in the lookup 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a9c0e9b77772a4974c06ee4577fe60547}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
461 \{
462   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << p<< header << oif << sockerr);
463   Ipv4Address destination = header.GetDestination ();
464   Ptr<Ipv4Route> rtentry = 0;
465 
466   \textcolor{comment}{// Multicast goes here}
467   \textcolor{keywordflow}{if} (destination.IsMulticast ())
468     \{
469       \textcolor{comment}{// Note:  Multicast routes for outbound packets are stored in the}
470       \textcolor{comment}{// normal unicast table.  An implication of this is that it is not}
471       \textcolor{comment}{// possible to source multicast datagrams on multiple interfaces.}
472       \textcolor{comment}{// This is a well-known property of sockets implementation on }
473       \textcolor{comment}{// many Unix variants.}
474       \textcolor{comment}{// So, we just log it and fall through to LookupStatic ()}
475       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"RouteOutput()::Multicast destination"});
476     \}
477   rtentry = \hyperlink{classns3_1_1Ipv4StaticRouting_a9ee2a4c5597e9b238369ba3667121852}{LookupStatic} (destination, oif);
478   \textcolor{keywordflow}{if} (rtentry)
479     \{ 
480       sockerr = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaaa7eb006d73c5ad0117c5591fcb3469f7}{Socket::ERROR\_NOTERROR};
481     \}
482   \textcolor{keywordflow}{else}
483     \{ 
484       sockerr = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{Socket::ERROR\_NOROUTETOHOST};
485     \}
486   \textcolor{keywordflow}{return} rtentry;
487 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 26


\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Set\+Default\+Multicast\+Route@{Set\+Default\+Multicast\+Route}}
\index{Set\+Default\+Multicast\+Route@{Set\+Default\+Multicast\+Route}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Set\+Default\+Multicast\+Route(uint32\+\_\+t output\+Interface)}{SetDefaultMulticastRoute(uint32_t outputInterface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Static\+Routing\+::\+Set\+Default\+Multicast\+Route (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{output\+Interface}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4StaticRouting_a478128042db3170f6419f86f1a9e5ecf}{}\label{classns3_1_1Ipv4StaticRouting_a478128042db3170f6419f86f1a9e5ecf}


Add a default multicast route to the static routing table. 

This is the multicast equivalent of the unicast version Set\+Default\+Route. We tell the routing system what to do in the case where a specific route to a destination multicast group is not found. The system forwards packets out the specified interface in the hope that \char`\"{}something out there\char`\"{} knows better how to route the packet. This method is only used in initially sending packets off of a host. The default multicast route is not consulted during forwarding -- exact routes must be specified using Add\+Multicast\+Route for that case.

Since we\textquotesingle{}re basically sending packets to some entity we think may know better what to do, we don\textquotesingle{}t pay attention to \char`\"{}subtleties\char`\"{} like origin address, nor do we worry about forwarding out multiple interfaces. If the default multicast route is set, it is returned as the selected route from Lookup\+Static irrespective of origin or multicast group if another specific route is not found.


\begin{DoxyParams}{Parameters}
{\em output\+Interface} & The network interface index used to specify where to send packets in the case of unknown routes.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} 
\end{DoxySeeAlso}

\begin{DoxyCode}
138 \{
139   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << outputInterface);
140   Ipv4RoutingTableEntry *route = \textcolor{keyword}{new} Ipv4RoutingTableEntry ();
141   Ipv4Address network = Ipv4Address (\textcolor{stringliteral}{"224.0.0.0"});
142   Ipv4Mask networkMask = Ipv4Mask (\textcolor{stringliteral}{"240.0.0.0"});
143   *route = \hyperlink{classns3_1_1Ipv4RoutingTableEntry_abe3447a00495ded05ab095673531947a}{Ipv4RoutingTableEntry::CreateNetworkRouteTo} (network,
144                                                         networkMask,
145                                                         outputInterface);
146   \hyperlink{classns3_1_1Ipv4StaticRouting_a81e0b111629b14fff2efbf69180a64c1}{m\_networkRoutes}.push\_back (make\_pair (route,0));
147 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 27


\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Set\+Default\+Route@{Set\+Default\+Route}}
\index{Set\+Default\+Route@{Set\+Default\+Route}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Set\+Default\+Route(\+Ipv4\+Address next\+Hop, uint32\+\_\+t interface, uint32\+\_\+t metric=0)}{SetDefaultRoute(Ipv4Address nextHop, uint32_t interface, uint32_t metric=0)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Static\+Routing\+::\+Set\+Default\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{next\+Hop, }
\item[{uint32\+\_\+t}]{interface, }
\item[{uint32\+\_\+t}]{metric = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv4StaticRouting_aee30fa3246c2b42f122dabdff2725331}{}\label{classns3_1_1Ipv4StaticRouting_aee30fa3246c2b42f122dabdff2725331}


Add a default route to the static routing table. 

This method tells the routing system what to do in the case where a specific route to a destination is not found. The system forwards packets to the specified node in the hope that it knows better how to route the packet.

If the default route is set, it is returned as the selected route from Lookup\+Static irrespective of destination address if no specific route is found.


\begin{DoxyParams}{Parameters}
{\em next\+Hop} & The \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} to send packets to in the hope that they will be forwarded correctly. \\
\hline
{\em interface} & The network interface index used to send packets. \\
\hline
{\em metric} & Metric of route in case of multiple routes to same destination\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} 

Ipv4\+Static\+Routing\+::\+Lookup 
\end{DoxySeeAlso}

\begin{DoxyCode}
115 \{
116   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << nextHop << \textcolor{stringliteral}{" "} << interface << \textcolor{stringliteral}{" "} << metric);
117   \hyperlink{classns3_1_1Ipv4StaticRouting_a8bf5eaa7ba49fe33c78c70d5560b6c39}{AddNetworkRouteTo} (Ipv4Address (\textcolor{stringliteral}{"0.0.0.0"}), \hyperlink{classns3_1_1Ipv4Mask_ac2dda492011ede8350008d753d278998}{Ipv4Mask::GetZero} (), 
      nextHop, interface, metric);
118 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 28




Here is the caller graph for this function\+:
% FIG 29


\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!Set\+Ipv4@{Set\+Ipv4}}
\index{Set\+Ipv4@{Set\+Ipv4}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Set\+Ipv4(\+Ptr$<$ Ipv4 $>$ ipv4)}{SetIpv4(Ptr< Ipv4 > ipv4)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv4\+Static\+Routing\+::\+Set\+Ipv4 (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv4} $>$}]{ipv4}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv4StaticRouting_a3caec935381a858c42583d2d023d4499}{}\label{classns3_1_1Ipv4StaticRouting_a3caec935381a858c42583d2d023d4499}

\begin{DoxyParams}{Parameters}
{\em ipv4} & the ipv4 object this routing protocol is being associated with\\
\hline
\end{DoxyParams}
Typically, invoked directly or indirectly from \hyperlink{classns3_1_1Ipv4_a2d165c3bafd4ca580f02a03536db80d3}{ns3\+::\+Ipv4\+::\+Set\+Routing\+Protocol} 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_af3947a05b912ea3f2a1ef0e9777f723e}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
675 \{
676   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << ipv4);
677   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{m\_ipv4} == 0 && ipv4 != 0);
678   \hyperlink{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{m\_ipv4} = ipv4;
679   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{m\_ipv4}->GetNInterfaces (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
680     \{
681       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{m\_ipv4}->IsUp (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}))
682         \{
683           \hyperlink{classns3_1_1Ipv4StaticRouting_a2c84913a130adb6dbd2814da95e789fb}{NotifyInterfaceUp} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
684         \}
685       \textcolor{keywordflow}{else}
686         \{
687           \hyperlink{classns3_1_1Ipv4StaticRouting_a22f00ba2dabe60e0653e278e221aa97b}{NotifyInterfaceDown} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
688         \}
689     \}
690 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 30




\subsection{Member Data Documentation}
\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!m\+\_\+ipv4@{m\+\_\+ipv4}}
\index{m\+\_\+ipv4@{m\+\_\+ipv4}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+ipv4}{m_ipv4}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Ipv4}$>$ ns3\+::\+Ipv4\+Static\+Routing\+::m\+\_\+ipv4\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}{}\label{classns3_1_1Ipv4StaticRouting_adc30356be1824ea40ffbd444a5d91b9f}


\hyperlink{classns3_1_1Ipv4}{Ipv4} reference. 

\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!m\+\_\+multicast\+Routes@{m\+\_\+multicast\+Routes}}
\index{m\+\_\+multicast\+Routes@{m\+\_\+multicast\+Routes}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+multicast\+Routes}{m_multicastRoutes}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Multicast\+Routes} ns3\+::\+Ipv4\+Static\+Routing\+::m\+\_\+multicast\+Routes\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4StaticRouting_a5aaf2ee73a6590cc164ac9485d89b538}{}\label{classns3_1_1Ipv4StaticRouting_a5aaf2ee73a6590cc164ac9485d89b538}


the forwarding table for multicast. 

\index{ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}!m\+\_\+network\+Routes@{m\+\_\+network\+Routes}}
\index{m\+\_\+network\+Routes@{m\+\_\+network\+Routes}!ns3\+::\+Ipv4\+Static\+Routing@{ns3\+::\+Ipv4\+Static\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+network\+Routes}{m_networkRoutes}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Network\+Routes} ns3\+::\+Ipv4\+Static\+Routing\+::m\+\_\+network\+Routes\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv4StaticRouting_a81e0b111629b14fff2efbf69180a64c1}{}\label{classns3_1_1Ipv4StaticRouting_a81e0b111629b14fff2efbf69180a64c1}


the forwarding table for network. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/model/\hyperlink{ipv4-static-routing_8h}{ipv4-\/static-\/routing.\+h}\item 
internet/model/\hyperlink{ipv4-static-routing_8cc}{ipv4-\/static-\/routing.\+cc}\end{DoxyCompactItemize}
