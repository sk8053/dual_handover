\hypertarget{classns3_1_1dsr_1_1DsrOptionRreq}{}\section{ns3\+:\+:dsr\+:\+:Dsr\+Option\+Rreq Class Reference}
\label{classns3_1_1dsr_1_1DsrOptionRreq}\index{ns3\+::dsr\+::\+Dsr\+Option\+Rreq@{ns3\+::dsr\+::\+Dsr\+Option\+Rreq}}


Dsr Option Rreq.  




{\ttfamily \#include $<$dsr-\/options.\+h$>$}



Inheritance diagram for ns3\+:\+:dsr\+:\+:Dsr\+Option\+Rreq\+:
% FIG 0


Collaboration diagram for ns3\+:\+:dsr\+:\+:Dsr\+Option\+Rreq\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1dsr_1_1DsrOptionRreq_a4d05ec3c108ae6026cbe7fe35e3b0d97}{Get\+Instance\+Type\+Id} () const 
\begin{DoxyCompactList}\small\item\em Get the instance type ID. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1dsr_1_1DsrOptionRreq_af9205e27cc438263fd04fe5649f97d2b}{Dsr\+Option\+Rreq} ()
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1dsr_1_1DsrOptionRreq_a0db364bc360af5937726d3d5195f19fe}{$\sim$\+Dsr\+Option\+Rreq} ()
\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
virtual uint8\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrOptionRreq_a0e38455ada16db4001aea897b99ee016}{Get\+Option\+Number} () const 
\begin{DoxyCompactList}\small\item\em Get the option number. \end{DoxyCompactList}\item 
virtual uint8\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrOptionRreq_a439e889d11973e48e3674c6e86aaee99}{Process} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ dsrP, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} ipv4\+Address, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} source, \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} const \&ipv4\+Header, uint8\+\_\+t protocol, bool \&is\+Promisc, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} promisc\+Source)
\begin{DoxyCompactList}\small\item\em Process method. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1dsr_1_1DsrOptionRreq_a0fd0038a185e7dae6d2e9e640e542ee6}{Get\+Type\+Id} ()
\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const uint8\+\_\+t \hyperlink{classns3_1_1dsr_1_1DsrOptionRreq_a4f38d14b0638b1e527c4141f1c8795e3}{O\+P\+T\+\_\+\+N\+U\+M\+B\+ER} = 1
\begin{DoxyCompactList}\small\item\em Rreq option number. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1dsr_1_1DsrRouteCache}{dsr\+::\+Dsr\+Route\+Cache} $>$ \hyperlink{classns3_1_1dsr_1_1DsrOptionRreq_a5b3482123ab67e592dc9a5ac7db70c3d}{m\+\_\+route\+Cache}
\begin{DoxyCompactList}\small\item\em The route cache. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$ \hyperlink{classns3_1_1dsr_1_1DsrOptionRreq_a1cdb6d76fdbe652b4bb48e46e7aeb5d2}{m\+\_\+ipv4}
\begin{DoxyCompactList}\small\item\em The ipv4. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Dsr Option Rreq. 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::dsr\+::\+Dsr\+Option\+Rreq@{ns3\+::dsr\+::\+Dsr\+Option\+Rreq}!Dsr\+Option\+Rreq@{Dsr\+Option\+Rreq}}
\index{Dsr\+Option\+Rreq@{Dsr\+Option\+Rreq}!ns3\+::dsr\+::\+Dsr\+Option\+Rreq@{ns3\+::dsr\+::\+Dsr\+Option\+Rreq}}
\subsubsection[{\texorpdfstring{Dsr\+Option\+Rreq()}{DsrOptionRreq()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::dsr\+::\+Dsr\+Option\+Rreq\+::\+Dsr\+Option\+Rreq (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1dsr_1_1DsrOptionRreq_af9205e27cc438263fd04fe5649f97d2b}{}\label{classns3_1_1dsr_1_1DsrOptionRreq_af9205e27cc438263fd04fe5649f97d2b}


Constructor. 


\begin{DoxyCode}
482 \{
483   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
484 \}
\end{DoxyCode}
\index{ns3\+::dsr\+::\+Dsr\+Option\+Rreq@{ns3\+::dsr\+::\+Dsr\+Option\+Rreq}!````~Dsr\+Option\+Rreq@{$\sim$\+Dsr\+Option\+Rreq}}
\index{````~Dsr\+Option\+Rreq@{$\sim$\+Dsr\+Option\+Rreq}!ns3\+::dsr\+::\+Dsr\+Option\+Rreq@{ns3\+::dsr\+::\+Dsr\+Option\+Rreq}}
\subsubsection[{\texorpdfstring{$\sim$\+Dsr\+Option\+Rreq()}{~DsrOptionRreq()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::dsr\+::\+Dsr\+Option\+Rreq\+::$\sim$\+Dsr\+Option\+Rreq (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1dsr_1_1DsrOptionRreq_a0db364bc360af5937726d3d5195f19fe}{}\label{classns3_1_1dsr_1_1DsrOptionRreq_a0db364bc360af5937726d3d5195f19fe}


Destructor. 


\begin{DoxyCode}
487 \{
488   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
489 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::dsr\+::\+Dsr\+Option\+Rreq@{ns3\+::dsr\+::\+Dsr\+Option\+Rreq}!Get\+Instance\+Type\+Id@{Get\+Instance\+Type\+Id}}
\index{Get\+Instance\+Type\+Id@{Get\+Instance\+Type\+Id}!ns3\+::dsr\+::\+Dsr\+Option\+Rreq@{ns3\+::dsr\+::\+Dsr\+Option\+Rreq}}
\subsubsection[{\texorpdfstring{Get\+Instance\+Type\+Id() const }{GetInstanceTypeId() const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::dsr\+::\+Dsr\+Option\+Rreq\+::\+Get\+Instance\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1dsr_1_1DsrOptionRreq_a4d05ec3c108ae6026cbe7fe35e3b0d97}{}\label{classns3_1_1dsr_1_1DsrOptionRreq_a4d05ec3c108ae6026cbe7fe35e3b0d97}


Get the instance type ID. 

\begin{DoxyReturn}{Returns}
instance type ID 
\end{DoxyReturn}


Reimplemented from \hyperlink{classns3_1_1Object_a51e5994fa4b6eae32d719ad69f8fcbf5}{ns3\+::\+Object}.


\begin{DoxyCode}
477 \{
478   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1dsr_1_1DsrOptionRreq_a0fd0038a185e7dae6d2e9e640e542ee6}{GetTypeId} ();
479 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::dsr\+::\+Dsr\+Option\+Rreq@{ns3\+::dsr\+::\+Dsr\+Option\+Rreq}!Get\+Option\+Number@{Get\+Option\+Number}}
\index{Get\+Option\+Number@{Get\+Option\+Number}!ns3\+::dsr\+::\+Dsr\+Option\+Rreq@{ns3\+::dsr\+::\+Dsr\+Option\+Rreq}}
\subsubsection[{\texorpdfstring{Get\+Option\+Number() const }{GetOptionNumber() const }}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::dsr\+::\+Dsr\+Option\+Rreq\+::\+Get\+Option\+Number (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1dsr_1_1DsrOptionRreq_a0e38455ada16db4001aea897b99ee016}{}\label{classns3_1_1dsr_1_1DsrOptionRreq_a0e38455ada16db4001aea897b99ee016}


Get the option number. 

\begin{DoxyReturn}{Returns}
option number 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1dsr_1_1DsrOptions_a31407523e51950f30c95c89602580fc9}{ns3\+::dsr\+::\+Dsr\+Options}.


\begin{DoxyCode}
492 \{
493   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
494 
495   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1dsr_1_1DsrOptionRreq_a4f38d14b0638b1e527c4141f1c8795e3}{OPT\_NUMBER};
496 \}
\end{DoxyCode}
\index{ns3\+::dsr\+::\+Dsr\+Option\+Rreq@{ns3\+::dsr\+::\+Dsr\+Option\+Rreq}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::dsr\+::\+Dsr\+Option\+Rreq@{ns3\+::dsr\+::\+Dsr\+Option\+Rreq}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id()}{GetTypeId()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::dsr\+::\+Dsr\+Option\+Rreq\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1dsr_1_1DsrOptionRreq_a0fd0038a185e7dae6d2e9e640e542ee6}{}\label{classns3_1_1dsr_1_1DsrOptionRreq_a0fd0038a185e7dae6d2e9e640e542ee6}

\begin{DoxyCode}
467 \{
468   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::dsr::DsrOptionRreq"})
469     .SetParent<\hyperlink{classns3_1_1dsr_1_1DsrOptions_a26f9dda6f030963939c59ef1ab2a74c0}{DsrOptions}> ()
470     .SetGroupName (\textcolor{stringliteral}{"Dsr"})
471     .AddConstructor<\hyperlink{classns3_1_1dsr_1_1DsrOptionRreq_af9205e27cc438263fd04fe5649f97d2b}{DsrOptionRreq}> ()
472   ;
473   \textcolor{keywordflow}{return} tid;
474 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::dsr\+::\+Dsr\+Option\+Rreq@{ns3\+::dsr\+::\+Dsr\+Option\+Rreq}!Process@{Process}}
\index{Process@{Process}!ns3\+::dsr\+::\+Dsr\+Option\+Rreq@{ns3\+::dsr\+::\+Dsr\+Option\+Rreq}}
\subsubsection[{\texorpdfstring{Process(\+Ptr$<$ Packet $>$ packet, Ptr$<$ Packet $>$ dsr\+P, Ipv4\+Address ipv4\+Address, Ipv4\+Address source, Ipv4\+Header const \&ipv4\+Header, uint8\+\_\+t protocol, bool \&is\+Promisc, Ipv4\+Address promisc\+Source)}{Process(Ptr< Packet > packet, Ptr< Packet > dsrP, Ipv4Address ipv4Address, Ipv4Address source, Ipv4Header const &ipv4Header, uint8_t protocol, bool &isPromisc, Ipv4Address promiscSource)}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::dsr\+::\+Dsr\+Option\+Rreq\+::\+Process (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{dsrP, }
\item[{{\bf Ipv4\+Address}}]{ipv4\+Address, }
\item[{{\bf Ipv4\+Address}}]{source, }
\item[{{\bf Ipv4\+Header} const \&}]{ipv4\+Header, }
\item[{uint8\+\_\+t}]{protocol, }
\item[{bool \&}]{is\+Promisc, }
\item[{{\bf Ipv4\+Address}}]{promisc\+Source}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1dsr_1_1DsrOptionRreq_a439e889d11973e48e3674c6e86aaee99}{}\label{classns3_1_1dsr_1_1DsrOptionRreq_a439e889d11973e48e3674c6e86aaee99}


Process method. 

Called from \hyperlink{classns3_1_1dsr_1_1DsrRouting_a4908cdae502d8bdca8a244d4420311e6}{Dsr\+Routing\+::\+Receive}. 
\begin{DoxyParams}{Parameters}
{\em packet} & the packet \\
\hline
{\em dsrP} & the clean packet with payload \\
\hline
{\em ipv4\+Address} & the I\+Pv4 address \\
\hline
{\em source} & I\+Pv4 address of the source \\
\hline
{\em ipv4\+Header} & the I\+Pv4 header of packet received \\
\hline
{\em protocol} & the protocol number of the up layer \\
\hline
{\em is\+Promisc} & if the packet must be dropped \\
\hline
{\em promisc\+Source} & I\+Pv4 address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the processed size 
\end{DoxyReturn}
T\+O\+DO has changed the src\+Address to source, should not matter either way, check later

T\+O\+DO !!!!!!!!!!!!!! Think about this part, we just added the route, probability no need to increase stability now?????

push back the intermediate node address from the source to this node

push back the route vector we found in our route cache to destination, including this node\textquotesingle{}s address

Implements \hyperlink{classns3_1_1dsr_1_1DsrOptions_ac34fb87a95464f3ea9d82ad12253a5cc}{ns3\+::dsr\+::\+Dsr\+Options}.


\begin{DoxyCode}
499 \{
500   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << dsrP << ipv4Address << source << ipv4Header << (
      uint32\_t)protocol << isPromisc);
501   \textcolor{comment}{// Fields from IP header}
502   Ipv4Address srcAddress = ipv4Header.GetSource ();
503   \textcolor{comment}{/*}
504 \textcolor{comment}{   * \(\backslash\) when the ip source address is equal to the address of our own, this is request packet originated}
505 \textcolor{comment}{   * \(\backslash\) by the node itself, discard it}
506 \textcolor{comment}{   */}
507   \textcolor{keywordflow}{if} (source == ipv4Address)
508     \{
509       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Discard the packet since it was originated from same source address"});
510       \hyperlink{classns3_1_1dsr_1_1DsrOptions_a176bbc9efb58b6d750c14b9b03c525c4}{m\_dropTrace} (packet); \textcolor{comment}{// call the drop trace to show in the tracing}
511       \textcolor{keywordflow}{return} 0;
512     \}
513   \textcolor{comment}{/*}
514 \textcolor{comment}{   * Get the node associated with the ipv4 address and get several objects from the node and leave for
       further use}
515 \textcolor{comment}{   */}
516   Ptr<Node> node = \hyperlink{classns3_1_1dsr_1_1DsrOptions_a1a91f820f3d754a477a54bad547ca659}{GetNodeWithAddress} (ipv4Address);
517   Ptr<dsr::DsrRouting> dsr = node->GetObject<dsr::DsrRouting> ();
518 
519   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = packet->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} (); \textcolor{comment}{// Note: The packet here doesn't contain the fixed size dsr header}
520   \textcolor{comment}{/*}
521 \textcolor{comment}{   * \(\backslash\)brief Get the number of routers' address field before removing the header}
522 \textcolor{comment}{   * \(\backslash\)peek the packet and get the value}
523 \textcolor{comment}{   */}
524   uint8\_t buf[2];
525   p->\hyperlink{classns3_1_1Packet_a5a6d304b9e0d90733919ffe224b98f0d}{CopyData} (buf, \textcolor{keyword}{sizeof}(buf));
526   uint8\_t numberAddress = (buf[1] - 6) / 4;
527   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The number of Ip addresses "} << (uint32\_t)numberAddress);
528   \textcolor{keywordflow}{if} (numberAddress >= 255)
529     \{
530       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Discard the packet, malformed header since two many ip addresses in route"}
      );
531       \hyperlink{classns3_1_1dsr_1_1DsrOptions_a176bbc9efb58b6d750c14b9b03c525c4}{m\_dropTrace} (packet); \textcolor{comment}{// call the drop trace to show in the tracing}
532       \textcolor{keywordflow}{return} 0;
533     \}
534 
535   \textcolor{comment}{/*}
536 \textcolor{comment}{   * Create the dsr rreq header}
537 \textcolor{comment}{   */}
538   DsrOptionRreqHeader rreq;
539   \textcolor{comment}{/*}
540 \textcolor{comment}{   * Set the number of addresses with the value from peek data and remove the rreq header}
541 \textcolor{comment}{   */}
542   rreq.SetNumberAddress (numberAddress);
543   \textcolor{comment}{// Remove the route request header}
544   p->RemoveHeader (rreq);
545   \textcolor{comment}{// Verify the option length}
546   uint8\_t length = rreq.GetLength ();
547   \textcolor{keywordflow}{if} (length % 2 != 0)
548     \{
549       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Malformed header. Drop!"});
550       \hyperlink{classns3_1_1dsr_1_1DsrOptions_a176bbc9efb58b6d750c14b9b03c525c4}{m\_dropTrace} (packet); \textcolor{comment}{// call drop trace}
551       \textcolor{keywordflow}{return} 0;
552     \}
553   \textcolor{comment}{// Check the rreq id for verifying the request id}
554   uint16\_t requestId = rreq.GetId ();
555   \textcolor{comment}{// The target address is where we want to send the data packets}
556   Ipv4Address targetAddress = rreq.GetTarget ();
557   \textcolor{comment}{// Get the node list and source address from the route request header}
558   std::vector<Ipv4Address> mainVector = rreq.GetNodesAddresses ();
559   std::vector<Ipv4Address> nodeList (mainVector);
560   \textcolor{comment}{// Get the real source address of this request, it will be used when checking if we have received the
       save}
561   \textcolor{comment}{// route request before or not}
562   Ipv4Address sourceAddress = nodeList.front ();
563   \hyperlink{classns3_1_1dsr_1_1DsrOptions_a44ae8e58769880ec9c0150bb28652350}{PrintVector} (nodeList);
564   \textcolor{comment}{/*}
565 \textcolor{comment}{   * Construct the dsr routing header for later use}
566 \textcolor{comment}{   */}
567   DsrRoutingHeader dsrRoutingHeader;
568   dsrRoutingHeader.SetNextHeader (protocol);
569   dsrRoutingHeader.SetMessageType (1);
570   dsrRoutingHeader.SetSourceId (\hyperlink{classns3_1_1dsr_1_1DsrOptions_a7e53a9a0421c607e17866e7dd0dd5440}{GetIDfromIP} (source));
571   dsrRoutingHeader.SetDestId (255);
572 
573   \textcolor{comment}{// check whether we have received this request or not, if not, it will save the request in the table for}
574   \textcolor{comment}{// later use, if not found, return false, and push the newly received source request entry in the cache}
575 
576   \textcolor{comment}{// Get the TTL value, this is used to test if the packet will be forwarded or not}
577   uint8\_t ttl = ipv4Header.GetTtl ();
578   \textcolor{keywordtype}{bool} dupRequest = \textcolor{keyword}{false};  \textcolor{comment}{// initialize the duplicate request check value}
579   \textcolor{keywordflow}{if} (ttl)
580     \{
581       \textcolor{comment}{// if the ttl value is not 0, then this request will be forwarded, then we need to}
582       \textcolor{comment}{// save it in the source entry}
583       dupRequest = dsr->FindSourceEntry (sourceAddress, targetAddress, requestId);
584     \}
585   \textcolor{comment}{/*}
586 \textcolor{comment}{   * Before processing the route request, we need to check two things}
587 \textcolor{comment}{   * 1. if this is the exact same request we have just received, ignore it}
588 \textcolor{comment}{   * 2. if our address is already in the path list, ignore it}
589 \textcolor{comment}{   * 3. otherwise process further}
590 \textcolor{comment}{   */}
591 
592   \textcolor{keywordflow}{if} (dupRequest)
593     \{
594       \textcolor{comment}{// We have received this same route reqeust before, not forwarding it now}
595       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Duplicate request. Drop!"});
596       \hyperlink{classns3_1_1dsr_1_1DsrOptions_a176bbc9efb58b6d750c14b9b03c525c4}{m\_dropTrace} (packet); \textcolor{comment}{// call drop trace}
597       \textcolor{keywordflow}{return} 0;
598     \}
599 
600   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrOptions_a2d973cc79c1a784317f3b03a834a831e}{CheckDuplicates} (ipv4Address, nodeList))
601     \{
602       \textcolor{comment}{/*}
603 \textcolor{comment}{       * if the route contains the node address already, drop the request packet}
604 \textcolor{comment}{       */}
605       \hyperlink{classns3_1_1dsr_1_1DsrOptions_a176bbc9efb58b6d750c14b9b03c525c4}{m\_dropTrace} (packet);    \textcolor{comment}{// call drop trace}
606       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Our node address is already seen in the route, drop the request"});
607       \textcolor{keywordflow}{return} 0;
608     \}
609   \textcolor{keywordflow}{else}
610     \{
611       \textcolor{comment}{// A node ignores all RREQs received from any node in its blacklist}
612       DsrRouteCacheEntry toPrev;
613       \textcolor{keywordtype}{bool} isRouteInCache = dsr->LookupRoute (targetAddress,
614                                               toPrev);
615       \hyperlink{classns3_1_1dsr_1_1DsrRouteCacheEntry_ab834177006bdbfd2e3fa607c2a88cbdf}{DsrRouteCacheEntry::IP\_VECTOR} ip = toPrev.GetVector (); \textcolor{comment}{// The route
       from our own route cache to dst}
616       \hyperlink{classns3_1_1dsr_1_1DsrOptions_a44ae8e58769880ec9c0150bb28652350}{PrintVector} (ip);
617       std::vector<Ipv4Address> saveRoute (nodeList);
618       \hyperlink{classns3_1_1dsr_1_1DsrOptions_a44ae8e58769880ec9c0150bb28652350}{PrintVector} (saveRoute);
619       \textcolor{keywordtype}{bool} areThereDuplicates = \hyperlink{classns3_1_1dsr_1_1DsrOptions_a46fdbfab9423d644ad211c55b32ed74d}{IfDuplicates} (ip,
620                                               saveRoute);
621       \textcolor{comment}{/*}
622 \textcolor{comment}{       *  When the reverse route is created or updated, the following actions on the route are also carried
       out:}
623 \textcolor{comment}{       *  3. the next hop in the routing table becomes the node from which the  RREQ was received}
624 \textcolor{comment}{       *  4. the hop count is copied from the Hop Count in the RREQ message;}
625 \textcolor{comment}{       */}
626 
627       \textcolor{comment}{//  A node generates a RREP if either:}
628       \textcolor{comment}{//  (i)  it is itself the destination,}
629       \textcolor{comment}{/*}
630 \textcolor{comment}{       * The target address equal to our own ip address}
631 \textcolor{comment}{       */}
632       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The target address over here "} << targetAddress << \textcolor{stringliteral}{" and the ip address "} 
      << ipv4Address << \textcolor{stringliteral}{" and the source address "} << mainVector[0]);
633       \textcolor{keywordflow}{if} (targetAddress == ipv4Address)
634         \{
635           Ipv4Address nextHop; \textcolor{comment}{// Declare the next hop address to use}
636           \textcolor{keywordflow}{if} (nodeList.size () == 1)
637             \{
638               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"These two nodes are neighbors"});
639               \hyperlink{classns3_1_1dsr_1_1DsrOptions_a3fe6a72ebaae73724ce63383635b7af8}{m\_finalRoute}.clear ();
641               \hyperlink{classns3_1_1dsr_1_1DsrOptions_a3fe6a72ebaae73724ce63383635b7af8}{m\_finalRoute}.push\_back (source);     \textcolor{comment}{// push back the request originator's
       address}
642               \hyperlink{classns3_1_1dsr_1_1DsrOptions_a3fe6a72ebaae73724ce63383635b7af8}{m\_finalRoute}.push\_back (ipv4Address);    \textcolor{comment}{// push back our own address}
643               nextHop = srcAddress;
644             \}
645           \textcolor{keywordflow}{else}
646             \{
647               std::vector<Ipv4Address> changeRoute (nodeList);
648               changeRoute.push\_back (ipv4Address);    \textcolor{comment}{// push back our own address}
649               \hyperlink{classns3_1_1dsr_1_1DsrOptions_a3fe6a72ebaae73724ce63383635b7af8}{m\_finalRoute}.clear ();              \textcolor{comment}{// get a clear route vector}
650               \textcolor{keywordflow}{for} (std::vector<Ipv4Address>::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = changeRoute.begin (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != changeRoute.end (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
651                 \{
652                   \hyperlink{classns3_1_1dsr_1_1DsrOptions_a3fe6a72ebaae73724ce63383635b7af8}{m\_finalRoute}.push\_back (*\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});  \textcolor{comment}{// Get the full route from source to
       destination}
653                 \}
654               \hyperlink{classns3_1_1dsr_1_1DsrOptions_a44ae8e58769880ec9c0150bb28652350}{PrintVector} (\hyperlink{classns3_1_1dsr_1_1DsrOptions_a3fe6a72ebaae73724ce63383635b7af8}{m\_finalRoute});
655               nextHop = \hyperlink{classns3_1_1dsr_1_1DsrOptions_a9cc1c0bdf1b57f8b2eea4d9070b26a58}{ReverseSearchNextHop} (ipv4Address, 
      \hyperlink{classns3_1_1dsr_1_1DsrOptions_a3fe6a72ebaae73724ce63383635b7af8}{m\_finalRoute}); \textcolor{comment}{// get the next hop}
656             \}
657 
658           DsrOptionRrepHeader rrep;
659           rrep.SetNodesAddress (\hyperlink{classns3_1_1dsr_1_1DsrOptions_a3fe6a72ebaae73724ce63383635b7af8}{m\_finalRoute});     \textcolor{comment}{// Set the node addresses in the route reply
       header}
660           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The nextHop address "} << nextHop);
661           Ipv4Address replyDst = \hyperlink{classns3_1_1dsr_1_1DsrOptions_a3fe6a72ebaae73724ce63383635b7af8}{m\_finalRoute}.front ();
662           \textcolor{comment}{/*}
663 \textcolor{comment}{           * This part add dsr header to the packet and send route reply packet}
664 \textcolor{comment}{           */}
665           DsrRoutingHeader dsrRoutingHeader;
666           dsrRoutingHeader.SetNextHeader (protocol);
667           dsrRoutingHeader.SetMessageType (1);
668           dsrRoutingHeader.SetSourceId (\hyperlink{classns3_1_1dsr_1_1DsrOptions_a7e53a9a0421c607e17866e7dd0dd5440}{GetIDfromIP} (ipv4Address));
669           dsrRoutingHeader.SetDestId (\hyperlink{classns3_1_1dsr_1_1DsrOptions_a7e53a9a0421c607e17866e7dd0dd5440}{GetIDfromIP} (replyDst));
670           \textcolor{comment}{// Set the route for route reply}
671           \hyperlink{classns3_1_1dsr_1_1DsrOptions_af749b76db4626ae64bc37001a5353b99}{SetRoute} (nextHop, ipv4Address);
672 
673           uint8\_t length = rrep.GetLength ();  \textcolor{comment}{// Get the length of the rrep header excluding the type
       header}
674           dsrRoutingHeader.SetPayloadLength (length + 2);
675           dsrRoutingHeader.AddDsrOption (rrep);
676           Ptr<Packet> newPacket = Create<Packet> ();
677           newPacket->AddHeader (dsrRoutingHeader);
678           dsr->ScheduleInitialReply (newPacket, ipv4Address, nextHop, 
      \hyperlink{classns3_1_1dsr_1_1DsrOptions_ae4785209eae1d101cb8bd2d3b392d2ad}{m\_ipv4Route});
679           \textcolor{comment}{/*}
680 \textcolor{comment}{           * Create the route entry to the rreq originator and save it to route cache, also need to reverse
       the route}
681 \textcolor{comment}{           */}
682           \hyperlink{classns3_1_1dsr_1_1DsrOptions_a44ae8e58769880ec9c0150bb28652350}{PrintVector} (\hyperlink{classns3_1_1dsr_1_1DsrOptions_a3fe6a72ebaae73724ce63383635b7af8}{m\_finalRoute});
683           \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrOptions_a49547f030b51a51499c36f9b5802ec3c}{ReverseRoutes} (\hyperlink{classns3_1_1dsr_1_1DsrOptions_a3fe6a72ebaae73724ce63383635b7af8}{m\_finalRoute}))
684             \{
685               \hyperlink{classns3_1_1dsr_1_1DsrOptions_a44ae8e58769880ec9c0150bb28652350}{PrintVector} (\hyperlink{classns3_1_1dsr_1_1DsrOptions_a3fe6a72ebaae73724ce63383635b7af8}{m\_finalRoute});
686               Ipv4Address dst = \hyperlink{classns3_1_1dsr_1_1DsrOptions_a3fe6a72ebaae73724ce63383635b7af8}{m\_finalRoute}.back ();
687               \textcolor{keywordtype}{bool} addRoute = \textcolor{keyword}{false};
688               \textcolor{keywordflow}{if} (numberAddress > 0)
689                 \{
690                   DsrRouteCacheEntry toSource (\textcolor{comment}{/*IP\_VECTOR=*/} \hyperlink{classns3_1_1dsr_1_1DsrOptions_a3fe6a72ebaae73724ce63383635b7af8}{m\_finalRoute}, \textcolor{comment}{/*dst=*/}
691                                                            dst, \textcolor{comment}{/*expire time=*/} 
      \hyperlink{classns3_1_1dsr_1_1DsrOptions_a2d111e83b3c91f18ea49478a35ebb119}{ActiveRouteTimeout});
692                   \textcolor{keywordflow}{if} (dsr->IsLinkCache ())
693                     \{
694                       addRoute = dsr->AddRoute\_Link (\hyperlink{classns3_1_1dsr_1_1DsrOptions_a3fe6a72ebaae73724ce63383635b7af8}{m\_finalRoute}, ipv4Address);
695                     \}
696                   \textcolor{keywordflow}{else}
697                     \{
698                       addRoute = dsr->AddRoute (toSource);
699                     \}
700                 \}
701               \textcolor{keywordflow}{else}
702                 \{
703                   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Abnormal RouteRequest"});
704                   \textcolor{keywordflow}{return} 0;
705                 \}
706 
707               \textcolor{keywordflow}{if} (addRoute)
708                 \{
709                   \textcolor{comment}{/*}
710 \textcolor{comment}{                   * Found a route to the dst, construct the source route option header}
711 \textcolor{comment}{                   */}
712                   DsrOptionSRHeader sourceRoute;
713                   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The route length "} << \hyperlink{classns3_1_1dsr_1_1DsrOptions_a3fe6a72ebaae73724ce63383635b7af8}{m\_finalRoute}.size ());
714                   sourceRoute.SetNodesAddress (\hyperlink{classns3_1_1dsr_1_1DsrOptions_a3fe6a72ebaae73724ce63383635b7af8}{m\_finalRoute});
715 
719                   \textcolor{comment}{// if (dsr->IsLinkCache ())}
720                   \textcolor{comment}{//   \{}
721                   \textcolor{comment}{//     dsr->UseExtends (m\_finalRoute);}
722                   \textcolor{comment}{//   \}}
723                   sourceRoute.SetSegmentsLeft ((\hyperlink{classns3_1_1dsr_1_1DsrOptions_a3fe6a72ebaae73724ce63383635b7af8}{m\_finalRoute}.size () - 2));
724                   \textcolor{comment}{// The salvage value here is 0}
725                   sourceRoute.SetSalvage (0);
726                   Ipv4Address nextHop = \hyperlink{classns3_1_1dsr_1_1DsrOptions_a061c66ba810a71ae227371a45cc30cc0}{SearchNextHop} (ipv4Address, 
      \hyperlink{classns3_1_1dsr_1_1DsrOptions_a3fe6a72ebaae73724ce63383635b7af8}{m\_finalRoute}); \textcolor{comment}{// Get the next hop address}
727                   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The nextHop address "} << nextHop);
728 
729                   \textcolor{keywordflow}{if} (nextHop == \textcolor{stringliteral}{"0.0.0.0"})
730                     \{
731                       dsr->PacketNewRoute (dsrP, ipv4Address, dst, protocol);
732                       \textcolor{keywordflow}{return} 0;
733                     \}
734                   \hyperlink{classns3_1_1dsr_1_1DsrOptions_af749b76db4626ae64bc37001a5353b99}{SetRoute} (nextHop, ipv4Address);
735                   \textcolor{comment}{/*}
736 \textcolor{comment}{                   * Send the data packet from the send buffer}
737 \textcolor{comment}{                   */}
738                   dsr->SendPacketFromBuffer (sourceRoute, nextHop, protocol);
739                   \textcolor{comment}{// Cancel the route request timer for destination after sending the data packet}
740                   dsr->CancelRreqTimer (dst, \textcolor{keyword}{true});
741                 \}
742               \textcolor{keywordflow}{else}
743                 \{
744                   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The route is failed to add in cache"});
745                   \textcolor{keywordflow}{return} 0;
746                 \}
747             \}
748           \textcolor{keywordflow}{else}
749             \{
750               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Unable to reverse route"});
751               \textcolor{keywordflow}{return} 0;
752             \}
753           isPromisc = \textcolor{keyword}{false};
754           \textcolor{keywordflow}{return} rreq.GetSerializedSize ();
755         \}
756 
757       \textcolor{comment}{/*}
758 \textcolor{comment}{       * (ii) or it has an active route to the destination, send reply based on request header and route
       cache,}
759 \textcolor{comment}{       *      need to delay based on a random value from d = H * (h - 1 + r), which can avoid possible
       route}
760 \textcolor{comment}{       *      reply storm. Also, verify if two vectors do not contain duplicates (part of the route to the}
761 \textcolor{comment}{       *      destination from route cache and route collected so far). If so, do not use the route found}
762 \textcolor{comment}{       *      and forward the route request.}
763 \textcolor{comment}{       */}
764       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isRouteInCache && !areThereDuplicates)
765         \{
766               \hyperlink{classns3_1_1dsr_1_1DsrOptions_a3fe6a72ebaae73724ce63383635b7af8}{m\_finalRoute}.clear ();            \textcolor{comment}{// Clear the final route vector}
770 \textcolor{comment}{}              \textcolor{keywordflow}{for} (std::vector<Ipv4Address>::iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = saveRoute.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != saveRoute.end (); ++
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
771                 \{
772                   \hyperlink{classns3_1_1dsr_1_1DsrOptions_a3fe6a72ebaae73724ce63383635b7af8}{m\_finalRoute}.push\_back (*\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
773                 \}
777               \textcolor{keywordflow}{for} (std::vector<Ipv4Address>::iterator j = ip.begin (); j != ip.end (); ++j)
778                 \{
779                   \hyperlink{classns3_1_1dsr_1_1DsrOptions_a3fe6a72ebaae73724ce63383635b7af8}{m\_finalRoute}.push\_back (*j);
780                 \}
781               \textcolor{comment}{/*}
782 \textcolor{comment}{               * Create the route entry to the rreq originator and save it to route cache, also need to
       reverse the route}
783 \textcolor{comment}{               */}
784               \textcolor{keywordtype}{bool} addRoute = \textcolor{keyword}{false};
785               std::vector<Ipv4Address> reverseRoute (\hyperlink{classns3_1_1dsr_1_1DsrOptions_a3fe6a72ebaae73724ce63383635b7af8}{m\_finalRoute});
786 
787               \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1dsr_1_1DsrOptions_a49547f030b51a51499c36f9b5802ec3c}{ReverseRoutes} (reverseRoute))
788                 \{
789                   saveRoute.push\_back (ipv4Address);
790                   \hyperlink{classns3_1_1dsr_1_1DsrOptions_a49547f030b51a51499c36f9b5802ec3c}{ReverseRoutes} (saveRoute);
791                   Ipv4Address dst = saveRoute.back ();
792                   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"This is the route save in route cache"});
793                   \hyperlink{classns3_1_1dsr_1_1DsrOptions_a44ae8e58769880ec9c0150bb28652350}{PrintVector} (saveRoute);
794 
795                   DsrRouteCacheEntry toSource (\textcolor{comment}{/*IP\_VECTOR=*/} saveRoute, \textcolor{comment}{/*dst=*/} dst, \textcolor{comment}{/*expire time=*/} 
      \hyperlink{classns3_1_1dsr_1_1DsrOptions_a2d111e83b3c91f18ea49478a35ebb119}{ActiveRouteTimeout});
796                   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (saveRoute.front () == ipv4Address);
797                   \textcolor{comment}{// Add the route entry in the route cache}
798                   \textcolor{keywordflow}{if} (dsr->IsLinkCache ())
799                     \{
800                       addRoute = dsr->AddRoute\_Link (saveRoute, ipv4Address);
801                     \}
802                   \textcolor{keywordflow}{else}
803                     \{
804                       addRoute = dsr->AddRoute (toSource);
805                     \}
806 
807                   \textcolor{keywordflow}{if} (addRoute)
808                     \{
809                       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"We have added the route and search send buffer for packet
       with destination "} << dst);
810                       \textcolor{comment}{/*}
811 \textcolor{comment}{                       * Found a route the dst, construct the source route option header}
812 \textcolor{comment}{                       */}
813                       DsrOptionSRHeader sourceRoute;
814                       \hyperlink{classns3_1_1dsr_1_1DsrOptions_a44ae8e58769880ec9c0150bb28652350}{PrintVector} (saveRoute);
815 
816                       sourceRoute.SetNodesAddress (saveRoute);
817                       \textcolor{comment}{// if (dsr->IsLinkCache ())}
818                       \textcolor{comment}{//   \{}
819                       \textcolor{comment}{//     dsr->UseExtends (saveRoute);}
820                       \textcolor{comment}{//   \}}
821                       sourceRoute.SetSegmentsLeft ((saveRoute.size () - 2));
822                       uint8\_t salvage = 0;
823                       sourceRoute.SetSalvage (salvage);
824                       Ipv4Address nextHop = \hyperlink{classns3_1_1dsr_1_1DsrOptions_a061c66ba810a71ae227371a45cc30cc0}{SearchNextHop} (ipv4Address, saveRoute); \textcolor{comment}{// Get the
       next hop address}
825                       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The nextHop address "} << nextHop);
826 
827                       \textcolor{keywordflow}{if} (nextHop == \textcolor{stringliteral}{"0.0.0.0"})
828                         \{
829                           dsr->PacketNewRoute (dsrP, ipv4Address, dst, protocol);
830                           \textcolor{keywordflow}{return} 0;
831                         \}
832                       \hyperlink{classns3_1_1dsr_1_1DsrOptions_af749b76db4626ae64bc37001a5353b99}{SetRoute} (nextHop, ipv4Address);
833                       \textcolor{comment}{/*}
834 \textcolor{comment}{                       * Schedule the packet retry}
835 \textcolor{comment}{                       */}
836                       dsr->SendPacketFromBuffer (sourceRoute, nextHop, protocol);
837                       \textcolor{comment}{// Cancel the route request timer for destination}
838                       dsr->CancelRreqTimer (dst, \textcolor{keyword}{true});
839                     \}
840                   \textcolor{keywordflow}{else}
841                     \{
842                       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The route is failed to add in cache"});
843                       \textcolor{keywordflow}{return} 0;
844                     \}
845                 \}
846               \textcolor{keywordflow}{else}
847                 \{
848                   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Unable to reverse the route"});
849                   \textcolor{keywordflow}{return} 0;
850                 \}
851 
852               \textcolor{comment}{/*}
853 \textcolor{comment}{               * Need to first pin down the next hop address before removing duplicates}
854 \textcolor{comment}{               */}
855               Ipv4Address nextHop = \hyperlink{classns3_1_1dsr_1_1DsrOptions_a9cc1c0bdf1b57f8b2eea4d9070b26a58}{ReverseSearchNextHop} (ipv4Address, 
      \hyperlink{classns3_1_1dsr_1_1DsrOptions_a3fe6a72ebaae73724ce63383635b7af8}{m\_finalRoute});
856               \textcolor{comment}{/*}
857 \textcolor{comment}{               * First remove the duplicate ip address to automatically shorten the route, and then
       reversely}
858 \textcolor{comment}{               * search the next hop address}
859 \textcolor{comment}{               */}
860               \textcolor{comment}{// Set the route}
861               \hyperlink{classns3_1_1dsr_1_1DsrOptions_af749b76db4626ae64bc37001a5353b99}{SetRoute} (nextHop, ipv4Address);
862 
863               uint16\_t hops = \hyperlink{classns3_1_1dsr_1_1DsrOptions_a3fe6a72ebaae73724ce63383635b7af8}{m\_finalRoute}.size ();
864               DsrOptionRrepHeader rrep;
865               rrep.SetNodesAddress (\hyperlink{classns3_1_1dsr_1_1DsrOptions_a3fe6a72ebaae73724ce63383635b7af8}{m\_finalRoute});     \textcolor{comment}{// Set the node addresses in the route
       reply header}
866               \textcolor{comment}{// Get the real source of the reply}
867               Ipv4Address realSource = \hyperlink{classns3_1_1dsr_1_1DsrOptions_a3fe6a72ebaae73724ce63383635b7af8}{m\_finalRoute}.back ();
868               \hyperlink{classns3_1_1dsr_1_1DsrOptions_a44ae8e58769880ec9c0150bb28652350}{PrintVector} (\hyperlink{classns3_1_1dsr_1_1DsrOptions_a3fe6a72ebaae73724ce63383635b7af8}{m\_finalRoute});
869               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"This is the full route from "} << realSource << \textcolor{stringliteral}{" to "} << 
      \hyperlink{classns3_1_1dsr_1_1DsrOptions_a3fe6a72ebaae73724ce63383635b7af8}{m\_finalRoute}.front ());
870               \textcolor{comment}{/*}
871 \textcolor{comment}{               * This part add dsr header to the packet and send route reply packet}
872 \textcolor{comment}{               */}
873               DsrRoutingHeader dsrRoutingHeader;
874               dsrRoutingHeader.SetNextHeader (protocol);
875               dsrRoutingHeader.SetMessageType (1);
876               dsrRoutingHeader.SetSourceId (\hyperlink{classns3_1_1dsr_1_1DsrOptions_a7e53a9a0421c607e17866e7dd0dd5440}{GetIDfromIP} (realSource));
877               dsrRoutingHeader.SetDestId (255);
878 
879               uint8\_t length = rrep.GetLength ();  \textcolor{comment}{// Get the length of the rrep header excluding the type
       header}
880               dsrRoutingHeader.SetPayloadLength (length + 2);
881               dsrRoutingHeader.AddDsrOption (rrep);
882               Ptr<Packet> newPacket = Create<Packet> ();
883               newPacket->AddHeader (dsrRoutingHeader);
884               dsr->ScheduleCachedReply (newPacket, ipv4Address, nextHop, 
      \hyperlink{classns3_1_1dsr_1_1DsrOptions_ae4785209eae1d101cb8bd2d3b392d2ad}{m\_ipv4Route}, hops);
885               isPromisc = \textcolor{keyword}{false};
886           \textcolor{keywordflow}{return} rreq.GetSerializedSize ();
887         \}
888       \textcolor{comment}{/*}
889 \textcolor{comment}{       * (iii) no route in any type has been found}
890 \textcolor{comment}{       */}
891       \textcolor{keywordflow}{else}
892         \{
893           mainVector.push\_back (ipv4Address);
894           \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (mainVector.front () == source);
895           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Print out the main vector"});
896           \hyperlink{classns3_1_1dsr_1_1DsrOptions_a44ae8e58769880ec9c0150bb28652350}{PrintVector} (mainVector);
897           rreq.SetNodesAddress (mainVector);
898 
899           Ptr<Packet> errP = p->Copy ();
900           \textcolor{keywordflow}{if} (errP->GetSize ())
901             \{
902               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Error header included"});
903               DsrOptionRerrUnreachHeader rerr;
904               p->RemoveHeader (rerr);
905               Ipv4Address errorSrc = rerr.GetErrorSrc ();
906               Ipv4Address unreachNode = rerr.GetUnreachNode ();
907               Ipv4Address errorDst = rerr.GetErrorDst ();
908 
909               \textcolor{keywordflow}{if} ((errorSrc == srcAddress) && (unreachNode == ipv4Address))
910                 \{
911                   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The error link back to work again"});
912                   uint16\_t length = rreq.GetLength ();
913                   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The RREQ header length "} <<  length);
914                   dsrRoutingHeader.AddDsrOption (rreq);
915                   dsrRoutingHeader.SetPayloadLength (length + 2);
916                 \}
917               \textcolor{keywordflow}{else}
918                 \{
919                   dsr->DeleteAllRoutesIncludeLink (errorSrc, unreachNode, ipv4Address);
920 
921                   DsrOptionRerrUnreachHeader newUnreach;
922                   newUnreach.SetErrorType (1);
923                   newUnreach.SetErrorSrc (errorSrc);
924                   newUnreach.SetUnreachNode (unreachNode);
925                   newUnreach.SetErrorDst (errorDst);
926                   newUnreach.SetSalvage (rerr.GetSalvage ()); \textcolor{comment}{// Set the value about whether to salvage a
       packet or not}
927                   uint16\_t length = rreq.GetLength () + newUnreach.GetLength ();
928                   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The RREQ and newUnreach header length "} <<  length);
929                   dsrRoutingHeader.SetPayloadLength (length + 4);
930                   dsrRoutingHeader.AddDsrOption (rreq);
931                   dsrRoutingHeader.AddDsrOption (newUnreach);
932                 \}
933             \}
934           \textcolor{keywordflow}{else}
935             \{
936               uint16\_t length = rreq.GetLength ();
937               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The RREQ header length "} <<  length);
938               dsrRoutingHeader.AddDsrOption (rreq);
939               dsrRoutingHeader.SetPayloadLength (length + 2);
940             \}
941           \textcolor{comment}{// Get the TTL value}
942           uint8\_t ttl = ipv4Header.GetTtl ();
943           \textcolor{comment}{/*}
944 \textcolor{comment}{          * Decrease the TTL value in the packet tag by one, this tag will go to ip layer 3 send function}
945 \textcolor{comment}{          * and drop packet when TTL value equals to 0}
946 \textcolor{comment}{          */}
947           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"The ttl value here "} << (uint32\_t)ttl);
948           \textcolor{keywordflow}{if} (ttl)
949             \{
950               Ptr<Packet> interP = Create<Packet> ();
951               SocketIpTtlTag tag;
952               tag.SetTtl (ttl - 1);
953               interP->AddPacketTag (tag);
954               interP->AddHeader (dsrRoutingHeader);
955               dsr->ScheduleInterRequest (interP);
956               isPromisc = \textcolor{keyword}{false};
957             \}
958           \textcolor{keywordflow}{return} rreq.GetSerializedSize ();
959         \}
960     \}
961   \textcolor{comment}{//unreachable:  return rreq.GetSerializedSize ();}
962 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4




\subsection{Member Data Documentation}
\index{ns3\+::dsr\+::\+Dsr\+Option\+Rreq@{ns3\+::dsr\+::\+Dsr\+Option\+Rreq}!m\+\_\+ipv4@{m\+\_\+ipv4}}
\index{m\+\_\+ipv4@{m\+\_\+ipv4}!ns3\+::dsr\+::\+Dsr\+Option\+Rreq@{ns3\+::dsr\+::\+Dsr\+Option\+Rreq}}
\subsubsection[{\texorpdfstring{m\+\_\+ipv4}{m_ipv4}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Ipv4}$>$ ns3\+::dsr\+::\+Dsr\+Option\+Rreq\+::m\+\_\+ipv4\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrOptionRreq_a1cdb6d76fdbe652b4bb48e46e7aeb5d2}{}\label{classns3_1_1dsr_1_1DsrOptionRreq_a1cdb6d76fdbe652b4bb48e46e7aeb5d2}


The ipv4. 

\index{ns3\+::dsr\+::\+Dsr\+Option\+Rreq@{ns3\+::dsr\+::\+Dsr\+Option\+Rreq}!m\+\_\+route\+Cache@{m\+\_\+route\+Cache}}
\index{m\+\_\+route\+Cache@{m\+\_\+route\+Cache}!ns3\+::dsr\+::\+Dsr\+Option\+Rreq@{ns3\+::dsr\+::\+Dsr\+Option\+Rreq}}
\subsubsection[{\texorpdfstring{m\+\_\+route\+Cache}{m_routeCache}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf dsr\+::\+Dsr\+Route\+Cache}$>$ ns3\+::dsr\+::\+Dsr\+Option\+Rreq\+::m\+\_\+route\+Cache\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1dsr_1_1DsrOptionRreq_a5b3482123ab67e592dc9a5ac7db70c3d}{}\label{classns3_1_1dsr_1_1DsrOptionRreq_a5b3482123ab67e592dc9a5ac7db70c3d}


The route cache. 

\index{ns3\+::dsr\+::\+Dsr\+Option\+Rreq@{ns3\+::dsr\+::\+Dsr\+Option\+Rreq}!O\+P\+T\+\_\+\+N\+U\+M\+B\+ER@{O\+P\+T\+\_\+\+N\+U\+M\+B\+ER}}
\index{O\+P\+T\+\_\+\+N\+U\+M\+B\+ER@{O\+P\+T\+\_\+\+N\+U\+M\+B\+ER}!ns3\+::dsr\+::\+Dsr\+Option\+Rreq@{ns3\+::dsr\+::\+Dsr\+Option\+Rreq}}
\subsubsection[{\texorpdfstring{O\+P\+T\+\_\+\+N\+U\+M\+B\+ER}{OPT_NUMBER}}]{\setlength{\rightskip}{0pt plus 5cm}const uint8\+\_\+t ns3\+::dsr\+::\+Dsr\+Option\+Rreq\+::\+O\+P\+T\+\_\+\+N\+U\+M\+B\+ER = 1\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1dsr_1_1DsrOptionRreq_a4f38d14b0638b1e527c4141f1c8795e3}{}\label{classns3_1_1dsr_1_1DsrOptionRreq_a4f38d14b0638b1e527c4141f1c8795e3}


Rreq option number. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
dsr/model/\hyperlink{dsr-options_8h}{dsr-\/options.\+h}\item 
dsr/model/\hyperlink{dsr-options_8cc}{dsr-\/options.\+cc}\end{DoxyCompactItemize}
