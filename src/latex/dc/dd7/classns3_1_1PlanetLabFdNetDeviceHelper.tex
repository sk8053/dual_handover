\hypertarget{classns3_1_1PlanetLabFdNetDeviceHelper}{}\section{ns3\+:\+:Planet\+Lab\+Fd\+Net\+Device\+Helper Class Reference}
\label{classns3_1_1PlanetLabFdNetDeviceHelper}\index{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper@{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper}}


build a set of \hyperlink{classns3_1_1FdNetDevice}{Fd\+Net\+Device} objects attached to a virtual T\+AP network interface  




{\ttfamily \#include $<$planetlab-\/fd-\/net-\/device-\/helper.\+h$>$}



Inheritance diagram for ns3\+:\+:Planet\+Lab\+Fd\+Net\+Device\+Helper\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Planet\+Lab\+Fd\+Net\+Device\+Helper\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1PlanetLabFdNetDeviceHelper_aaeb26b47008f773d2e70cb26c52ac836}{Planet\+Lab\+Fd\+Net\+Device\+Helper} ()
\item 
virtual \hyperlink{classns3_1_1PlanetLabFdNetDeviceHelper_ab047fe6de50064611dd7c119bb6ad91d}{$\sim$\+Planet\+Lab\+Fd\+Net\+Device\+Helper} ()
\item 
void \hyperlink{classns3_1_1PlanetLabFdNetDeviceHelper_ac66f980eff8589effa96dc55b8fa7e5d}{Set\+Tap\+Ip\+Address} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} address)
\item 
void \hyperlink{classns3_1_1PlanetLabFdNetDeviceHelper_a5092147c1cf87212697fd91a2c1294c9}{Set\+Tap\+Mask} (\hyperlink{classns3_1_1Ipv4Mask}{Ipv4\+Mask} mask)
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ \hyperlink{classns3_1_1PlanetLabFdNetDeviceHelper_a740ff8b94a42f4175af712baf00c83ab}{Install\+Priv} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node) const 
\item 
virtual void \hyperlink{classns3_1_1PlanetLabFdNetDeviceHelper_acec8004fe1776760866ab8f6ca1b2936}{Set\+File\+Descriptor} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1FdNetDevice}{Fd\+Net\+Device} $>$ device) const 
\item 
virtual int \hyperlink{classns3_1_1PlanetLabFdNetDeviceHelper_ab758ef1ac544c73625dbfd6fa9d48e4f}{Create\+File\+Descriptor} (void) const 
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} \hyperlink{classns3_1_1PlanetLabFdNetDeviceHelper_a85f9999ccfe2efd2cf5431f09d8b6fb5}{m\+\_\+tap\+Ip}
\item 
\hyperlink{classns3_1_1Ipv4Mask}{Ipv4\+Mask} \hyperlink{classns3_1_1PlanetLabFdNetDeviceHelper_a809572f0a890702c0e9843c44bf76fa0}{m\+\_\+tap\+Mask}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
build a set of \hyperlink{classns3_1_1FdNetDevice}{Fd\+Net\+Device} objects attached to a virtual T\+AP network interface 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper@{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper}!Planet\+Lab\+Fd\+Net\+Device\+Helper@{Planet\+Lab\+Fd\+Net\+Device\+Helper}}
\index{Planet\+Lab\+Fd\+Net\+Device\+Helper@{Planet\+Lab\+Fd\+Net\+Device\+Helper}!ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper@{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{Planet\+Lab\+Fd\+Net\+Device\+Helper()}{PlanetLabFdNetDeviceHelper()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PlanetLabFdNetDeviceHelper_aaeb26b47008f773d2e70cb26c52ac836}{}\label{classns3_1_1PlanetLabFdNetDeviceHelper_aaeb26b47008f773d2e70cb26c52ac836}
Construct a \hyperlink{classns3_1_1PlanetLabFdNetDeviceHelper}{Planet\+Lab\+Fd\+Net\+Device\+Helper}. 
\begin{DoxyCode}
68 \{
69   \hyperlink{classns3_1_1PlanetLabFdNetDeviceHelper_a85f9999ccfe2efd2cf5431f09d8b6fb5}{m\_tapIp} = Ipv4Address (\textcolor{stringliteral}{"255.255.255.255"});
70   \hyperlink{classns3_1_1PlanetLabFdNetDeviceHelper_a809572f0a890702c0e9843c44bf76fa0}{m\_tapMask} = Ipv4Mask (\textcolor{stringliteral}{"255.255.255.255"});
71 \}
\end{DoxyCode}
\index{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper@{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper}!````~Planet\+Lab\+Fd\+Net\+Device\+Helper@{$\sim$\+Planet\+Lab\+Fd\+Net\+Device\+Helper}}
\index{````~Planet\+Lab\+Fd\+Net\+Device\+Helper@{$\sim$\+Planet\+Lab\+Fd\+Net\+Device\+Helper}!ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper@{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{$\sim$\+Planet\+Lab\+Fd\+Net\+Device\+Helper()}{~PlanetLabFdNetDeviceHelper()}}]{\setlength{\rightskip}{0pt plus 5cm}virtual ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper\+::$\sim$\+Planet\+Lab\+Fd\+Net\+Device\+Helper (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1PlanetLabFdNetDeviceHelper_ab047fe6de50064611dd7c119bb6ad91d}{}\label{classns3_1_1PlanetLabFdNetDeviceHelper_ab047fe6de50064611dd7c119bb6ad91d}

\begin{DoxyCode}
52   \{
53   \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2




\subsection{Member Function Documentation}
\index{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper@{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper}!Create\+File\+Descriptor@{Create\+File\+Descriptor}}
\index{Create\+File\+Descriptor@{Create\+File\+Descriptor}!ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper@{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{Create\+File\+Descriptor(void) const }{CreateFileDescriptor(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper\+::\+Create\+File\+Descriptor (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1PlanetLabFdNetDeviceHelper_ab758ef1ac544c73625dbfd6fa9d48e4f}{}\label{classns3_1_1PlanetLabFdNetDeviceHelper_ab758ef1ac544c73625dbfd6fa9d48e4f}
Call out to a separate process running as suid root in order to create a T\+AP device and obtain the file descriptor associated to it. 

Reimplemented from \hyperlink{classns3_1_1EmuFdNetDeviceHelper_a64392b0acfeddf0121b251bc7e6e8906}{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper}.


\begin{DoxyCode}
121 \{
122   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
123 
124   \textcolor{comment}{//}
125   \textcolor{comment}{// We're going to fork and exec that program soon, but first we need to have}
126   \textcolor{comment}{// a socket to talk to it with.  So we create a local interprocess (Unix)}
127   \textcolor{comment}{// socket for that purpose.}
128   \textcolor{comment}{//}
129   \textcolor{keywordtype}{int} sock = socket (PF\_UNIX, SOCK\_DGRAM, 0);
130   \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (sock == -1, \textcolor{stringliteral}{"PlanetLabFdNetDeviceHelper::CreateFileDescriptor(): Unix
       socket creation error, errno = "} << strerror (errno));
131 
132   \textcolor{comment}{//}
133   \textcolor{comment}{// Bind to that socket and let the kernel allocate an endpoint}
134   \textcolor{comment}{//}
135   \textcolor{keyword}{struct }sockaddr\_un un;
136   memset (&un, 0, \textcolor{keyword}{sizeof} (un));
137   un.sun\_family = AF\_UNIX;
138   \textcolor{keywordtype}{int} status = bind (sock, (\textcolor{keyword}{struct} sockaddr*)&un, \textcolor{keyword}{sizeof} (sa\_family\_t));
139   \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (status == -1, \textcolor{stringliteral}{"PlanetLabFdNetDeviceHelper::CreateFileDescriptor(): Could
       not bind(): errno = "} << strerror (errno));
140   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Created Unix socket"});
141   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"sun\_family = "} << un.sun\_family);
142   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"sun\_path = "} << un.sun\_path);
143 
144   \textcolor{comment}{//}
145   \textcolor{comment}{// We have a socket here, but we want to get it there -- to the program we're}
146   \textcolor{comment}{// going to exec.  What we'll do is to do a getsockname and then encode the}
147   \textcolor{comment}{// resulting address information as a string, and then send the string to the}
148   \textcolor{comment}{// program as an argument.  So we need to get the sock name.}
149   \textcolor{comment}{//}
150   socklen\_t len = \textcolor{keyword}{sizeof} (un);
151   status = getsockname (sock, (\textcolor{keyword}{struct} sockaddr*)&un, &len);
152   \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (status == -1, \textcolor{stringliteral}{"PlanetLabFdNetDeviceHelper::CreateFileDescriptor(): Could
       not getsockname(): errno = "} << strerror (errno));
153 
154   \textcolor{comment}{//}
155   \textcolor{comment}{// Now encode that socket name (family and path) as a string of hex digits}
156   \textcolor{comment}{//}
157   std::string path = \hyperlink{namespacens3_a97907497171f00140c77ed054e3baad6}{BufferToString} ((uint8\_t *)&un, len);
158   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Encoded Unix socket as \(\backslash\)""} << path << \textcolor{stringliteral}{"\(\backslash\)""});
159 
160   \textcolor{comment}{//}
161   \textcolor{comment}{// Fork and exec the process to create our socket.  If we're us (the parent)}
162   \textcolor{comment}{// we wait for the child (the creator) to complete and read the socket it}
163   \textcolor{comment}{// created and passed back using the ancillary data mechanism.}
164   \textcolor{comment}{//}
165   pid\_t pid = ::fork ();
166   \textcolor{keywordflow}{if} (pid == 0)
167     \{
168       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Child process"});
169 
170       \textcolor{comment}{//}
171       \textcolor{comment}{// build a command line argument from the encoded endpoint string that}
172       \textcolor{comment}{// the socket creation process will use to figure out how to respond to}
173       \textcolor{comment}{// the (now) parent process.  We're going to have to give this program}
174       \textcolor{comment}{// quite a bit of information.}
175       \textcolor{comment}{//}
176       \textcolor{comment}{// -i<IP-address> The IP address to assign to the new tap device;}
177       \textcolor{comment}{// -n<network-prefix> The network prefix to assign to the new tap device;}
178       \textcolor{comment}{// -t Set teh IFF\_TAP flag}
179       \textcolor{comment}{// -p<path> the path to the unix socket described above.}
180       \textcolor{comment}{//}
181       \textcolor{comment}{// Example tap-creator -i1.2.3.1 -n24 -t -pblah}
182       \textcolor{comment}{//}
183 
184       std::ostringstream ossIp;
185       ossIp << \textcolor{stringliteral}{"-i"} << \hyperlink{classns3_1_1PlanetLabFdNetDeviceHelper_a85f9999ccfe2efd2cf5431f09d8b6fb5}{m\_tapIp};
186 
187       std::ostringstream ossPrefix;
188       ossPrefix << \textcolor{stringliteral}{"-n"} << \hyperlink{classns3_1_1PlanetLabFdNetDeviceHelper_a809572f0a890702c0e9843c44bf76fa0}{m\_tapMask}.\hyperlink{classns3_1_1Ipv4Mask_aed6cdc1658a130595f4acf33e33fcebe}{GetPrefixLength} ();
189 
190       std::ostringstream ossMode;
191       ossMode << \textcolor{stringliteral}{"-t"};
192 
193       std::ostringstream ossPath;
194       ossPath << \textcolor{stringliteral}{"-p"} << path;
195 
196       \textcolor{comment}{//}
197       \textcolor{comment}{// Execute the socket creation process image.}
198       \textcolor{comment}{//}
199       status = ::execlp (PLANETLAB\_TAP\_CREATOR,
200                          PLANETLAB\_TAP\_CREATOR,               \textcolor{comment}{// argv[0] (filename)}
201                          ossIp.str ().c\_str (),               \textcolor{comment}{// argv[1] (-i<IP address>)}
202                          ossPrefix.str ().c\_str (),           \textcolor{comment}{// argv[2] (-n<prefix>)}
203                          ossMode.str ().c\_str (),             \textcolor{comment}{// argv[3] (-t <tap>)}
204                          ossPath.str ().c\_str (),             \textcolor{comment}{// argv[4] (-p<path>)}
205                          (\textcolor{keywordtype}{char} *)NULL);
206 
207       \textcolor{comment}{//}
208       \textcolor{comment}{// If the execlp successfully completes, it never returns.  If it returns it failed or the OS is}
209       \textcolor{comment}{// broken.  In either case, we bail.}
210       \textcolor{comment}{//}
211       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"PlanetLabFdNetDeviceHelper::CreateFileDescriptor(): Back from
       execlp(), errno = "} << ::strerror (errno));
212     \}
213   \textcolor{keywordflow}{else}
214     \{
215       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Parent process"});
216       \textcolor{comment}{//}
217       \textcolor{comment}{// We're the process running the emu net device.  We need to wait for the}
218       \textcolor{comment}{// socket creator process to finish its job.}
219       \textcolor{comment}{//}
220       \textcolor{keywordtype}{int} st;
221       pid\_t waited = waitpid (pid, &st, 0);
222       \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (waited == -1, \textcolor{stringliteral}{"PlanetLabFdNetDeviceHelper::CreateFileDescriptor():
       waitpid() fails, errno = "} << strerror (errno));
223       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (pid == waited, \textcolor{stringliteral}{"PlanetLabFdNetDeviceHelper::CreateFileDescriptor(): pid
       mismatch"});
224 
225       \textcolor{comment}{//}
226       \textcolor{comment}{// Check to see if the socket creator exited normally and then take a}
227       \textcolor{comment}{// look at the exit code.  If it bailed, so should we.  If it didn't}
228       \textcolor{comment}{// even exit normally, we bail too.}
229       \textcolor{comment}{//}
230       \textcolor{keywordflow}{if} (WIFEXITED (st))
231         \{
232           \textcolor{keywordtype}{int} exitStatus = WEXITSTATUS (st);
233           \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (exitStatus != 0,
234                            \textcolor{stringliteral}{"PlanetLabFdNetDeviceHelper::CreateFileDescriptor(): socket creator exited
       normally with status "} << exitStatus);
235         \}
236       \textcolor{keywordflow}{else}
237         \{
238           \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"PlanetLabFdNetDeviceHelper::CreateFileDescriptor(): socket creator
       exited abnormally"});
239         \}
240 
241       \textcolor{comment}{//}
242       \textcolor{comment}{// At this point, the socket creator has run successfully and should}
243       \textcolor{comment}{// have created our tap device, initialized it with the information we}
244       \textcolor{comment}{// passed and sent it back to the socket address we provided.  A socket}
245       \textcolor{comment}{// (fd) we can use to talk to this tap device should be waiting on the}
246       \textcolor{comment}{// Unix socket we set up to receive information back from the creator}
247       \textcolor{comment}{// program.  We've got to do a bunch of grunt work to get at it, though.}
248       \textcolor{comment}{//}
249       \textcolor{comment}{// The struct iovec below is part of a scatter-gather list.  It describes a}
250       \textcolor{comment}{// buffer.  In this case, it describes a buffer (an integer) that will}
251       \textcolor{comment}{// get the data that comes back from the socket creator process.  It will}
252       \textcolor{comment}{// be a magic number that we use as a consistency/sanity check.}
253       \textcolor{comment}{//}
254       \textcolor{keyword}{struct }iovec iov;
255       uint32\_t magic;
256       iov.iov\_base = &magic;
257       iov.iov\_len = \textcolor{keyword}{sizeof}(magic);
258 
259       \textcolor{comment}{//}
260       \textcolor{comment}{// The CMSG macros you'll see below are used to create and access control}
261       \textcolor{comment}{// messages (which is another name for ancillary data).  The ancillary}
262       \textcolor{comment}{// data is made up of pairs of struct cmsghdr structures and associated}
263       \textcolor{comment}{// data arrays.}
264       \textcolor{comment}{//}
265       \textcolor{comment}{// First, we're going to allocate a buffer on the stack to receive our}
266       \textcolor{comment}{// data array (that contains the socket).  Sometimes you'll see this called}
267       \textcolor{comment}{// an "ancillary element" but the msghdr uses the control message termimology}
268       \textcolor{comment}{// so we call it "control."}
269       \textcolor{comment}{//}
270       \textcolor{keywordtype}{size\_t} msg\_size = \textcolor{keyword}{sizeof}(int);
271       \textcolor{keywordtype}{char} control[CMSG\_SPACE (msg\_size)];
272 
273       \textcolor{comment}{//}
274       \textcolor{comment}{// There is a msghdr that is used to minimize the number of parameters}
275       \textcolor{comment}{// passed to recvmsg (which we will use to receive our ancillary data).}
276       \textcolor{comment}{// This structure uses terminology corresponding to control messages, so}
277       \textcolor{comment}{// you'll see msg\_control, which is the pointer to the ancillary data and}
278       \textcolor{comment}{// controllen which is the size of the ancillary data array.}
279       \textcolor{comment}{//}
280       \textcolor{comment}{// So, initialize the message header that describes the ancillary/control}
281       \textcolor{comment}{// data we expect to receive and point it to buffer.}
282       \textcolor{comment}{//}
283       \textcolor{keyword}{struct }msghdr msg;
284       msg.msg\_name = 0;
285       msg.msg\_namelen = 0;
286       msg.msg\_iov = &iov;
287       msg.msg\_iovlen = 1;
288       msg.msg\_control = control;
289       msg.msg\_controllen = \textcolor{keyword}{sizeof} (control);
290       msg.msg\_flags = 0;
291 
292       \textcolor{comment}{//}
293       \textcolor{comment}{// Now we can actually receive the interesting bits from the tap}
294       \textcolor{comment}{// creator process.  Lots of pain to get four bytes.}
295       \textcolor{comment}{//}
296       ssize\_t bytesRead = recvmsg (sock, &msg, 0);
297       \hyperlink{group__fatal_ga6653324225bc139e46deea177614ceee}{NS\_ABORT\_MSG\_IF} (bytesRead != \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}), \textcolor{stringliteral}{"
      PlanetLabFdNetDeviceHelper::CreateFileDescriptor(): Wrong byte count from socket creator"});
298 
299       \textcolor{comment}{//}
300       \textcolor{comment}{// There may be a number of message headers/ancillary data arrays coming in.}
301       \textcolor{comment}{// Let's look for the one with a type SCM\_RIGHTS which indicates it's the}
302       \textcolor{comment}{// one we're interested in.}
303       \textcolor{comment}{//}
304       \textcolor{keyword}{struct }cmsghdr *cmsg;
305       \textcolor{keywordflow}{for} (cmsg = CMSG\_FIRSTHDR (&msg); cmsg != NULL; cmsg = CMSG\_NXTHDR (&msg, cmsg))
306         \{
307           \textcolor{keywordflow}{if} (cmsg->cmsg\_level == SOL\_SOCKET
308               && cmsg->cmsg\_type == SCM\_RIGHTS)
309             \{
310               \textcolor{comment}{//}
311               \textcolor{comment}{// This is the type of message we want.  Check to see if the magic}
312               \textcolor{comment}{// number is correct and then pull out the socket we care about if}
313               \textcolor{comment}{// it matches}
314               \textcolor{comment}{//}
315               \textcolor{keywordflow}{if} (magic == \hyperlink{planetlab-fd-net-device-helper_8cc_a15008ade4323f5ef598ad5a66b141e42}{PLANETLAB\_MAGIC})
316                 \{
317                   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Got SCM\_RIGHTS with correct magic "} << magic);
318                   \textcolor{keywordtype}{int} *rawSocket = (\textcolor{keywordtype}{int}*)CMSG\_DATA (cmsg);
319                   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Got the socket from the socket creator = "} << *rawSocket);
320                   \textcolor{keywordflow}{return} *rawSocket;
321                 \}
322               \textcolor{keywordflow}{else}
323                 \{
324                   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Got SCM\_RIGHTS, but with bad magic "} << magic);
325                 \}
326             \}
327         \}
328       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Did not get the raw socket from the socket creator"});
329     \}
330 
331 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3




Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper@{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper}!Install\+Priv@{Install\+Priv}}
\index{Install\+Priv@{Install\+Priv}!ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper@{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{Install\+Priv(\+Ptr$<$ Node $>$ node) const }{InstallPriv(Ptr< Node > node) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Net\+Device} $>$ ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper\+::\+Install\+Priv (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1PlanetLabFdNetDeviceHelper_a740ff8b94a42f4175af712baf00c83ab}{}\label{classns3_1_1PlanetLabFdNetDeviceHelper_a740ff8b94a42f4175af712baf00c83ab}
This method creates an \hyperlink{classns3_1_1FdNetDevice}{ns3\+::\+Fd\+Net\+Device} attached to a virtual T\+AP network interface


\begin{DoxyParams}{Parameters}
{\em node} & The node to install the device in \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A container holding the added net device. 
\end{DoxyReturn}


Reimplemented from \hyperlink{classns3_1_1EmuFdNetDeviceHelper_a80562da33cef1c20d4b03b351fbbc21a}{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper}.


\begin{DoxyCode}
87 \{
88   Ptr<NetDevice> \hyperlink{buildings__pathloss_8m_a9f9b934daed17a4d3613b6886ff4cf4b}{d} = \hyperlink{classns3_1_1FdNetDeviceHelper_adf0e4f64b03f7203f7080b50f412a970}{FdNetDeviceHelper::InstallPriv} (node);
89   Ptr<FdNetDevice> device = d->GetObject<FdNetDevice> ();
90 
91   \textcolor{comment}{//}
92   \textcolor{comment}{// The PlanetLab mechanism to create a TAP device doesn't allow}
93   \textcolor{comment}{// for the moment to set the IFF\_NOPI flag. In consequence, a PI}
94   \textcolor{comment}{// header will be present in the traffic.}
95   \textcolor{comment}{// We need to explicitly set the encapsulation mode to DIXPI,}
96   \textcolor{comment}{// so the FdNetDevice is able to treat correctly the traffic}
97   \textcolor{comment}{// traversing TAP device.}
98   \textcolor{comment}{//}
99   Ptr<FdNetDevice> fdnd = device->GetObject<FdNetDevice> ();
100   fdnd->SetEncapsulationMode (\hyperlink{classns3_1_1FdNetDevice_abdacbf10c181f50998a98e7688016618abbad9c0d0fe0604652f21e33cf4d8798}{FdNetDevice::DIXPI});
101 
102   \hyperlink{classns3_1_1PlanetLabFdNetDeviceHelper_acec8004fe1776760866ab8f6ca1b2936}{SetFileDescriptor} (device);
103   \textcolor{keywordflow}{return} device;
104 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5




Here is the caller graph for this function\+:
% FIG 6


\index{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper@{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper}!Set\+File\+Descriptor@{Set\+File\+Descriptor}}
\index{Set\+File\+Descriptor@{Set\+File\+Descriptor}!ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper@{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{Set\+File\+Descriptor(\+Ptr$<$ Fd\+Net\+Device $>$ device) const }{SetFileDescriptor(Ptr< FdNetDevice > device) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper\+::\+Set\+File\+Descriptor (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Fd\+Net\+Device} $>$}]{device}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1PlanetLabFdNetDeviceHelper_acec8004fe1776760866ab8f6ca1b2936}{}\label{classns3_1_1PlanetLabFdNetDeviceHelper_acec8004fe1776760866ab8f6ca1b2936}
Sets a file descriptor on the File\+Descriptor\+Net\+Device. 

Reimplemented from \hyperlink{classns3_1_1EmuFdNetDeviceHelper_ad48e0e01cd07bd76bdc6bf05ed4fa756}{ns3\+::\+Emu\+Fd\+Net\+Device\+Helper}.


\begin{DoxyCode}
108 \{
109   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Creating TAP device"});
110 
111   \textcolor{comment}{//}
112   \textcolor{comment}{// Call out to a separate process running as suid root in order to create a}
113   \textcolor{comment}{// TAP device.  We do this to avoid having the entire simulation running as root.}
114   \textcolor{comment}{//}
115   \textcolor{keywordtype}{int} \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_a44f21d5190b5a6df8089f54799628d7e}{fd} = \hyperlink{classns3_1_1PlanetLabFdNetDeviceHelper_ab758ef1ac544c73625dbfd6fa9d48e4f}{CreateFileDescriptor} ();
116   device->SetFileDescriptor (fd);
117 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7




Here is the caller graph for this function\+:
% FIG 8


\index{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper@{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper}!Set\+Tap\+Ip\+Address@{Set\+Tap\+Ip\+Address}}
\index{Set\+Tap\+Ip\+Address@{Set\+Tap\+Ip\+Address}!ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper@{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{Set\+Tap\+Ip\+Address(\+Ipv4\+Address address)}{SetTapIpAddress(Ipv4Address address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper\+::\+Set\+Tap\+Ip\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{address}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PlanetLabFdNetDeviceHelper_ac66f980eff8589effa96dc55b8fa7e5d}{}\label{classns3_1_1PlanetLabFdNetDeviceHelper_ac66f980eff8589effa96dc55b8fa7e5d}
Set the device I\+Pv4 address.


\begin{DoxyParams}{Parameters}
{\em address} & The I\+Pv4 address for the T\+AP device. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
75 \{
76   \hyperlink{classns3_1_1PlanetLabFdNetDeviceHelper_a85f9999ccfe2efd2cf5431f09d8b6fb5}{m\_tapIp} = address;
77 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 9


\index{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper@{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper}!Set\+Tap\+Mask@{Set\+Tap\+Mask}}
\index{Set\+Tap\+Mask@{Set\+Tap\+Mask}!ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper@{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{Set\+Tap\+Mask(\+Ipv4\+Mask mask)}{SetTapMask(Ipv4Mask mask)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper\+::\+Set\+Tap\+Mask (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Mask}}]{mask}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1PlanetLabFdNetDeviceHelper_a5092147c1cf87212697fd91a2c1294c9}{}\label{classns3_1_1PlanetLabFdNetDeviceHelper_a5092147c1cf87212697fd91a2c1294c9}
Set the network mask for the T\+AP device.


\begin{DoxyParams}{Parameters}
{\em mask} & The network mask for the T\+AP device. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
81 \{
82   \hyperlink{classns3_1_1PlanetLabFdNetDeviceHelper_a809572f0a890702c0e9843c44bf76fa0}{m\_tapMask} = mask;
83 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 10




\subsection{Member Data Documentation}
\index{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper@{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper}!m\+\_\+tap\+Ip@{m\+\_\+tap\+Ip}}
\index{m\+\_\+tap\+Ip@{m\+\_\+tap\+Ip}!ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper@{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+tap\+Ip}{m_tapIp}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Address} ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper\+::m\+\_\+tap\+Ip\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classns3_1_1PlanetLabFdNetDeviceHelper_a85f9999ccfe2efd2cf5431f09d8b6fb5}{}\label{classns3_1_1PlanetLabFdNetDeviceHelper_a85f9999ccfe2efd2cf5431f09d8b6fb5}
The IP address for the T\+AP device. \index{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper@{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper}!m\+\_\+tap\+Mask@{m\+\_\+tap\+Mask}}
\index{m\+\_\+tap\+Mask@{m\+\_\+tap\+Mask}!ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper@{ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper}}
\subsubsection[{\texorpdfstring{m\+\_\+tap\+Mask}{m_tapMask}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv4\+Mask} ns3\+::\+Planet\+Lab\+Fd\+Net\+Device\+Helper\+::m\+\_\+tap\+Mask\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classns3_1_1PlanetLabFdNetDeviceHelper_a809572f0a890702c0e9843c44bf76fa0}{}\label{classns3_1_1PlanetLabFdNetDeviceHelper_a809572f0a890702c0e9843c44bf76fa0}
The network mask for the T\+AP device. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
fd-\/net-\/device/helper/\hyperlink{planetlab-fd-net-device-helper_8h}{planetlab-\/fd-\/net-\/device-\/helper.\+h}\item 
fd-\/net-\/device/helper/\hyperlink{planetlab-fd-net-device-helper_8cc}{planetlab-\/fd-\/net-\/device-\/helper.\+cc}\end{DoxyCompactItemize}
