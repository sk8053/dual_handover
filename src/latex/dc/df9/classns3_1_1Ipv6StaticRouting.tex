\hypertarget{classns3_1_1Ipv6StaticRouting}{}\section{ns3\+:\+:Ipv6\+Static\+Routing Class Reference}
\label{classns3_1_1Ipv6StaticRouting}\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}


Static routing protocol for IP version 6 stacks.  




{\ttfamily \#include $<$ipv6-\/static-\/routing.\+h$>$}



Inheritance diagram for ns3\+:\+:Ipv6\+Static\+Routing\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Ipv6\+Static\+Routing\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ipv6StaticRouting_a1f9a909686971c59e89905cb46194fee}{Ipv6\+Static\+Routing} ()
\item 
virtual \hyperlink{classns3_1_1Ipv6StaticRouting_a561af2f913a1531c82dde4745f7b2172}{$\sim$\+Ipv6\+Static\+Routing} ()
\item 
void \hyperlink{classns3_1_1Ipv6StaticRouting_a9c09d10eb7d7d67c29bdc05bb620c241}{Add\+Host\+Route\+To} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dest, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} next\+Hop, uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} prefix\+To\+Use=\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address}(\char`\"{}\+::\char`\"{}), uint32\+\_\+t metric=0)
\begin{DoxyCompactList}\small\item\em Add route to host. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6StaticRouting_a108d89b7940a31f2648d9ccff0ec0923}{Add\+Host\+Route\+To} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dest, uint32\+\_\+t interface, uint32\+\_\+t metric=0)
\begin{DoxyCompactList}\small\item\em Add route to host. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6StaticRouting_ac0c0c9d8e3182295c1cdb4a3d612a2d3}{Add\+Network\+Route\+To} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} network, \hyperlink{classns3_1_1Ipv6Prefix}{Ipv6\+Prefix} network\+Prefix, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} next\+Hop, uint32\+\_\+t interface, uint32\+\_\+t metric=0)
\begin{DoxyCompactList}\small\item\em Add route to network. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6StaticRouting_adc37dbd1518eaadfd0c88161a7bb85ae}{Add\+Network\+Route\+To} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} network, \hyperlink{classns3_1_1Ipv6Prefix}{Ipv6\+Prefix} network\+Prefix, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} next\+Hop, uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} prefix\+To\+Use, uint32\+\_\+t metric=0)
\begin{DoxyCompactList}\small\item\em Add route to network. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6StaticRouting_aea001a6aed49ee86bb09833ecaf5bbd7}{Add\+Network\+Route\+To} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} network, \hyperlink{classns3_1_1Ipv6Prefix}{Ipv6\+Prefix} network\+Prefix, uint32\+\_\+t interface, uint32\+\_\+t metric=0)
\begin{DoxyCompactList}\small\item\em Add route to network. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6StaticRouting_af80ab0c9c95ea4bbc004bda7ce1cae06}{Set\+Default\+Route} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} next\+Hop, uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} prefix\+To\+Use=\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address}(\char`\"{}\+::\char`\"{}), uint32\+\_\+t metric=0)
\begin{DoxyCompactList}\small\item\em Set the default route. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1Ipv6StaticRouting_a058db80420adcecf578861ac0baecd87}{Get\+N\+Routes} () const 
\begin{DoxyCompactList}\small\item\em Get the number or entries in the routing table. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6RoutingTableEntry}{Ipv6\+Routing\+Table\+Entry} \hyperlink{classns3_1_1Ipv6StaticRouting_aabac84f4bef43734f7bbf25b2f959705}{Get\+Default\+Route} ()
\begin{DoxyCompactList}\small\item\em Get the default route. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6RoutingTableEntry}{Ipv6\+Routing\+Table\+Entry} \hyperlink{classns3_1_1Ipv6StaticRouting_a3393aa35fbb0d409c78a6cb2d1bce96a}{Get\+Route} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) const 
\begin{DoxyCompactList}\small\item\em Get a specified route. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1Ipv6StaticRouting_adeb439c98a101186987e5780af6b1353}{Get\+Metric} (uint32\+\_\+t index) const 
\begin{DoxyCompactList}\small\item\em Get a metric for route from the static unicast routing table. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6StaticRouting_a212afe37bcc27e9c85c15c9317269cd5}{Remove\+Route} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
\begin{DoxyCompactList}\small\item\em Remove a route from the routing table. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6StaticRouting_a9e1d32b4260bea10088c82bbf5906d06}{Remove\+Route} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} network, \hyperlink{classns3_1_1Ipv6Prefix}{Ipv6\+Prefix} prefix, uint32\+\_\+t if\+Index, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} prefix\+To\+Use)
\begin{DoxyCompactList}\small\item\em Remove a route from the routing table. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6StaticRouting_a9b56c80cc1ee75c691844e0a5b1db4d3}{Add\+Multicast\+Route} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} origin, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} group, uint32\+\_\+t input\+Interface, std\+::vector$<$ uint32\+\_\+t $>$ output\+Interfaces)
\begin{DoxyCompactList}\small\item\em Add a multicast route for a given multicast source and group. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6StaticRouting_ac936677e5f3d35e154d7a1f13dd9b7e0}{Set\+Default\+Multicast\+Route} (uint32\+\_\+t output\+Interface)
\begin{DoxyCompactList}\small\item\em Set the default multicast route. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1Ipv6StaticRouting_aa76cc9a5eabf0ec50ae65eff87817170}{Get\+N\+Multicast\+Routes} () const 
\begin{DoxyCompactList}\small\item\em Get the number of entries in the multicast routing table. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6MulticastRoutingTableEntry}{Ipv6\+Multicast\+Routing\+Table\+Entry} \hyperlink{classns3_1_1Ipv6StaticRouting_a622c079acbc62cb9e1279593d16344d4}{Get\+Multicast\+Route} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) const 
\begin{DoxyCompactList}\small\item\em Get the specified multicast route. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Ipv6StaticRouting_abb22fb02e9e80038383e3d4ae140ac37}{Remove\+Multicast\+Route} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} origin, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} group, uint32\+\_\+t input\+Interface)
\begin{DoxyCompactList}\small\item\em Remove a static multicast route. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6StaticRouting_a4a3cb10ebb513dfe2bbddb8366e61ab0}{Remove\+Multicast\+Route} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
\begin{DoxyCompactList}\small\item\em Remove a multicast route. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Ipv6StaticRouting_a64cae9e90c2a35915bd5dae9ea84728d}{Has\+Network\+Dest} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dest, uint32\+\_\+t interface\+Index)
\begin{DoxyCompactList}\small\item\em If the destination is already present in network destination list. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Route}{Ipv6\+Route} $>$ \hyperlink{classns3_1_1Ipv6StaticRouting_a494b7a870cc1af31ba11611128a067a6}{Route\+Output} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ oif, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket\+::\+Socket\+Errno} \&sockerr)
\begin{DoxyCompactList}\small\item\em Query routing cache for an existing route, for an outbound packet. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1Ipv6StaticRouting_a33810db6250f018b4587dc34a43a80cb}{Route\+Input} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ idev, \hyperlink{classns3_1_1Ipv6RoutingProtocol_a579fd6755ee873009819f7117371fea7}{Unicast\+Forward\+Callback} ucb, \hyperlink{classns3_1_1Ipv6RoutingProtocol_a5f12e04512ce8e5808c3cceff6b8918f}{Multicast\+Forward\+Callback} mcb, \hyperlink{classns3_1_1Ipv6RoutingProtocol_a93f6c06be1e024747e95f4299eba74a6}{Local\+Deliver\+Callback} lcb, \hyperlink{classns3_1_1Ipv6RoutingProtocol_abfdf43594e2ae97e1a4dc340e3a086a5}{Error\+Callback} ecb)
\begin{DoxyCompactList}\small\item\em Route an input packet (to be forwarded or locally delivered) \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6StaticRouting_a9750930029ffe2eaafda77ba77918472}{Notify\+Interface\+Up} (uint32\+\_\+t interface)
\begin{DoxyCompactList}\small\item\em Notify when specified interface goes UP. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6StaticRouting_a1e917452e99ee697b9ffd5acebfc0a02}{Notify\+Interface\+Down} (uint32\+\_\+t interface)
\begin{DoxyCompactList}\small\item\em Notify when specified interface goes D\+O\+WN. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6StaticRouting_ab4f7777b5228f498fa3493c753d50b8f}{Notify\+Add\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv6InterfaceAddress}{Ipv6\+Interface\+Address} address)
\begin{DoxyCompactList}\small\item\em Notify when specified interface add an address. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6StaticRouting_ab100c4857d93e5f0cc980e8024838e68}{Notify\+Remove\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv6InterfaceAddress}{Ipv6\+Interface\+Address} address)
\begin{DoxyCompactList}\small\item\em Notify when specified interface add an address. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6StaticRouting_aaae863ba89a47ad659fb5dc3602c9e24}{Notify\+Add\+Route} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dst, \hyperlink{classns3_1_1Ipv6Prefix}{Ipv6\+Prefix} mask, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} next\+Hop, uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} prefix\+To\+Use=\hyperlink{classns3_1_1Ipv6Address_a63a34bdb1505e05fbdd07d316d0bd7e6}{Ipv6\+Address\+::\+Get\+Zero}())
\begin{DoxyCompactList}\small\item\em Notify a new route. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6StaticRouting_aee1c676f218334e82bbbaf695aa93514}{Notify\+Remove\+Route} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dst, \hyperlink{classns3_1_1Ipv6Prefix}{Ipv6\+Prefix} mask, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} next\+Hop, uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} prefix\+To\+Use=\hyperlink{classns3_1_1Ipv6Address_a63a34bdb1505e05fbdd07d316d0bd7e6}{Ipv6\+Address\+::\+Get\+Zero}())
\begin{DoxyCompactList}\small\item\em Notify route removing. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6StaticRouting_a05569b3f3a6042a7e12a50fe88ee11e7}{Set\+Ipv6} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6}{Ipv6} $>$ ipv6)
\begin{DoxyCompactList}\small\item\em Typically, invoked directly or indirectly from \hyperlink{classns3_1_1Ipv6_aa889d2174527a1df773d65974de83f8f}{ns3\+::\+Ipv6\+::\+Set\+Routing\+Protocol}. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6StaticRouting_a39ea5334065001c093c8165d6a282550}{Print\+Routing\+Table} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream, \hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295a}{Time\+::\+Unit} unit=\hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295aade8622b06524a328cd3a59db6ccf76af}{Time\+::S}) const 
\begin{DoxyCompactList}\small\item\em Print the Routing Table entries. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1Ipv6StaticRouting_a46e2dbc750dbb14442a3ab2873d2fd5d}{Get\+Type\+Id} ()
\begin{DoxyCompactList}\small\item\em The interface Id associated with this class. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1Ipv6StaticRouting_a0ab95912087070c9df2aca8a388076a6}{Do\+Dispose} ()
\begin{DoxyCompactList}\small\item\em Dispose this object. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ std\+::pair$<$ \hyperlink{classns3_1_1Ipv6RoutingTableEntry}{Ipv6\+Routing\+Table\+Entry} $\ast$, uint32\+\_\+t $>$ $>$ \hyperlink{classns3_1_1Ipv6StaticRouting_aa2ac656240490a12d7d3a834a75af7fd}{Network\+Routes}
\begin{DoxyCompactList}\small\item\em Container for the network routes. \end{DoxyCompactList}\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ std\+::pair$<$ \hyperlink{classns3_1_1Ipv6RoutingTableEntry}{Ipv6\+Routing\+Table\+Entry} $\ast$, uint32\+\_\+t $>$ $>$\+::const\+\_\+iterator \hyperlink{classns3_1_1Ipv6StaticRouting_ad3c559fcd440cfe8e3a127f132c03527}{Network\+Routes\+CI}
\begin{DoxyCompactList}\small\item\em Const Iterator for container for the network routes. \end{DoxyCompactList}\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ std\+::pair$<$ \hyperlink{classns3_1_1Ipv6RoutingTableEntry}{Ipv6\+Routing\+Table\+Entry} $\ast$, uint32\+\_\+t $>$ $>$\+::iterator \hyperlink{classns3_1_1Ipv6StaticRouting_aaaf6779ff5a716ce508cac3017f5f769}{Network\+RoutesI}
\begin{DoxyCompactList}\small\item\em Iterator for container for the network routes. \end{DoxyCompactList}\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ipv6MulticastRoutingTableEntry}{Ipv6\+Multicast\+Routing\+Table\+Entry} $\ast$ $>$ \hyperlink{classns3_1_1Ipv6StaticRouting_a02421205cb9361483594fb8bd2286b12}{Multicast\+Routes}
\begin{DoxyCompactList}\small\item\em Container for the multicast routes. \end{DoxyCompactList}\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ipv6MulticastRoutingTableEntry}{Ipv6\+Multicast\+Routing\+Table\+Entry} $\ast$ $>$\+::const\+\_\+iterator \hyperlink{classns3_1_1Ipv6StaticRouting_a92c49caeb07b0d87fc1945a828ba33eb}{Multicast\+Routes\+CI}
\begin{DoxyCompactList}\small\item\em Const Iterator for container for the multicast routes. \end{DoxyCompactList}\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ipv6MulticastRoutingTableEntry}{Ipv6\+Multicast\+Routing\+Table\+Entry} $\ast$ $>$\+::iterator \hyperlink{classns3_1_1Ipv6StaticRouting_aed9967a6ba9f015a1812644f7b2cde1f}{Multicast\+RoutesI}
\begin{DoxyCompactList}\small\item\em Iterator for container for the multicast routes. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Route}{Ipv6\+Route} $>$ \hyperlink{classns3_1_1Ipv6StaticRouting_a53cafb0907cefabca6894c9d4dc6c154}{Lookup\+Static} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dest, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$=0)
\begin{DoxyCompactList}\small\item\em Lookup in the forwarding table for destination. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6MulticastRoute}{Ipv6\+Multicast\+Route} $>$ \hyperlink{classns3_1_1Ipv6StaticRouting_aad420be705ea418cc3c0481e751d9094}{Lookup\+Static} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} origin, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} group, uint32\+\_\+t if\+Index)
\begin{DoxyCompactList}\small\item\em Lookup in the multicast forwarding table for destination. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ipv6StaticRouting_aa2ac656240490a12d7d3a834a75af7fd}{Network\+Routes} \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\+\_\+network\+Routes}
\begin{DoxyCompactList}\small\item\em the forwarding table for network. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6StaticRouting_a02421205cb9361483594fb8bd2286b12}{Multicast\+Routes} \hyperlink{classns3_1_1Ipv6StaticRouting_ab9690b202d45d5567be46567a4f782ac}{m\+\_\+multicast\+Routes}
\begin{DoxyCompactList}\small\item\em the forwarding table for multicast. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6}{Ipv6} $>$ \hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\+\_\+ipv6}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Ipv6}{Ipv6} reference. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Static routing protocol for IP version 6 stacks. 

This class provides a basic set of methods for inserting static unicast and multicast routes into the \hyperlink{classns3_1_1Ipv6}{Ipv6} routing system. This particular protocol is designed to be inserted into an \hyperlink{classns3_1_1Ipv6ListRouting}{Ipv6\+List\+Routing} protocol but can be used also as a standalone protocol.

The \hyperlink{classns3_1_1Ipv6StaticRouting}{Ipv6\+Static\+Routing} class inherits from the abstract base class \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} that defines the interface methods that a routing protocol must support.

\begin{DoxySeeAlso}{See also}
\hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} 

\hyperlink{classns3_1_1Ipv6ListRouting}{Ipv6\+List\+Routing} 

\hyperlink{classns3_1_1Ipv6ListRouting_af2f9faf061ec907349d7287475fe73bc}{Ipv6\+List\+Routing\+::\+Add\+Routing\+Protocol} 
\end{DoxySeeAlso}


\subsection{Member Typedef Documentation}
\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Multicast\+Routes@{Multicast\+Routes}}
\index{Multicast\+Routes@{Multicast\+Routes}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Multicast\+Routes}{MulticastRoutes}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Ipv6\+Multicast\+Routing\+Table\+Entry} $\ast$$>$ {\bf ns3\+::\+Ipv6\+Static\+Routing\+::\+Multicast\+Routes}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6StaticRouting_a02421205cb9361483594fb8bd2286b12}{}\label{classns3_1_1Ipv6StaticRouting_a02421205cb9361483594fb8bd2286b12}


Container for the multicast routes. 

\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Multicast\+Routes\+CI@{Multicast\+Routes\+CI}}
\index{Multicast\+Routes\+CI@{Multicast\+Routes\+CI}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Multicast\+Routes\+CI}{MulticastRoutesCI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Ipv6\+Multicast\+Routing\+Table\+Entry} $\ast$$>$\+::const\+\_\+iterator {\bf ns3\+::\+Ipv6\+Static\+Routing\+::\+Multicast\+Routes\+CI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6StaticRouting_a92c49caeb07b0d87fc1945a828ba33eb}{}\label{classns3_1_1Ipv6StaticRouting_a92c49caeb07b0d87fc1945a828ba33eb}


Const Iterator for container for the multicast routes. 

\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Multicast\+RoutesI@{Multicast\+RoutesI}}
\index{Multicast\+RoutesI@{Multicast\+RoutesI}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Multicast\+RoutesI}{MulticastRoutesI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Ipv6\+Multicast\+Routing\+Table\+Entry} $\ast$$>$\+::iterator {\bf ns3\+::\+Ipv6\+Static\+Routing\+::\+Multicast\+RoutesI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6StaticRouting_aed9967a6ba9f015a1812644f7b2cde1f}{}\label{classns3_1_1Ipv6StaticRouting_aed9967a6ba9f015a1812644f7b2cde1f}


Iterator for container for the multicast routes. 

\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Network\+Routes@{Network\+Routes}}
\index{Network\+Routes@{Network\+Routes}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Network\+Routes}{NetworkRoutes}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<$std\+::pair $<${\bf Ipv6\+Routing\+Table\+Entry} $\ast$, uint32\+\_\+t$>$ $>$ {\bf ns3\+::\+Ipv6\+Static\+Routing\+::\+Network\+Routes}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6StaticRouting_aa2ac656240490a12d7d3a834a75af7fd}{}\label{classns3_1_1Ipv6StaticRouting_aa2ac656240490a12d7d3a834a75af7fd}


Container for the network routes. 

\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Network\+Routes\+CI@{Network\+Routes\+CI}}
\index{Network\+Routes\+CI@{Network\+Routes\+CI}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Network\+Routes\+CI}{NetworkRoutesCI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<$std\+::pair $<${\bf Ipv6\+Routing\+Table\+Entry} $\ast$, uint32\+\_\+t$>$ $>$\+::const\+\_\+iterator {\bf ns3\+::\+Ipv6\+Static\+Routing\+::\+Network\+Routes\+CI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6StaticRouting_ad3c559fcd440cfe8e3a127f132c03527}{}\label{classns3_1_1Ipv6StaticRouting_ad3c559fcd440cfe8e3a127f132c03527}


Const Iterator for container for the network routes. 

\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Network\+RoutesI@{Network\+RoutesI}}
\index{Network\+RoutesI@{Network\+RoutesI}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Network\+RoutesI}{NetworkRoutesI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<$std\+::pair $<${\bf Ipv6\+Routing\+Table\+Entry} $\ast$, uint32\+\_\+t$>$ $>$\+::iterator {\bf ns3\+::\+Ipv6\+Static\+Routing\+::\+Network\+RoutesI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6StaticRouting_aaaf6779ff5a716ce508cac3017f5f769}{}\label{classns3_1_1Ipv6StaticRouting_aaaf6779ff5a716ce508cac3017f5f769}


Iterator for container for the network routes. 



\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Ipv6\+Static\+Routing@{Ipv6\+Static\+Routing}}
\index{Ipv6\+Static\+Routing@{Ipv6\+Static\+Routing}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Ipv6\+Static\+Routing()}{Ipv6StaticRouting()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv6\+Static\+Routing\+::\+Ipv6\+Static\+Routing (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6StaticRouting_a1f9a909686971c59e89905cb46194fee}{}\label{classns3_1_1Ipv6StaticRouting_a1f9a909686971c59e89905cb46194fee}

\begin{DoxyCode}
50   : \hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6} (0)
51 \{
52   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
53 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!````~Ipv6\+Static\+Routing@{$\sim$\+Ipv6\+Static\+Routing}}
\index{````~Ipv6\+Static\+Routing@{$\sim$\+Ipv6\+Static\+Routing}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{$\sim$\+Ipv6\+Static\+Routing()}{~Ipv6StaticRouting()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv6\+Static\+Routing\+::$\sim$\+Ipv6\+Static\+Routing (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6StaticRouting_a561af2f913a1531c82dde4745f7b2172}{}\label{classns3_1_1Ipv6StaticRouting_a561af2f913a1531c82dde4745f7b2172}

\begin{DoxyCode}
56 \{
57   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
58 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Add\+Host\+Route\+To@{Add\+Host\+Route\+To}}
\index{Add\+Host\+Route\+To@{Add\+Host\+Route\+To}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Add\+Host\+Route\+To(\+Ipv6\+Address dest, Ipv6\+Address next\+Hop, uint32\+\_\+t interface, Ipv6\+Address prefix\+To\+Use=\+Ipv6\+Address(""\+::""), uint32\+\_\+t metric=0)}{AddHostRouteTo(Ipv6Address dest, Ipv6Address nextHop, uint32_t interface, Ipv6Address prefixToUse=Ipv6Address("::"), uint32_t metric=0)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Static\+Routing\+::\+Add\+Host\+Route\+To (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{dest, }
\item[{{\bf Ipv6\+Address}}]{next\+Hop, }
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv6\+Address}}]{prefix\+To\+Use = {\ttfamily {\bf Ipv6\+Address}~(\char`\"{}\+:\+:\char`\"{})}, }
\item[{uint32\+\_\+t}]{metric = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6StaticRouting_a9c09d10eb7d7d67c29bdc05bb620c241}{}\label{classns3_1_1Ipv6StaticRouting_a9c09d10eb7d7d67c29bdc05bb620c241}


Add route to host. 


\begin{DoxyParams}{Parameters}
{\em dest} & destination address \\
\hline
{\em next\+Hop} & next hop address to route the packet. \\
\hline
{\em interface} & interface index \\
\hline
{\em prefix\+To\+Use} & prefix that should be used for source address for this destination \\
\hline
{\em metric} & metric of route in case of multiple routes to same destination \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
133 \{
134   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << dst << nextHop << interface << prefixToUse << metric);
135   \textcolor{keywordflow}{if} (nextHop.IsLinkLocal())
136     \{
137       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Ipv6StaticRouting::AddHostRouteTo - Next hop should be link-local"});
138     \}
139 
140   \hyperlink{classns3_1_1Ipv6StaticRouting_ac0c0c9d8e3182295c1cdb4a3d612a2d3}{AddNetworkRouteTo} (dst, \hyperlink{classns3_1_1Ipv6Prefix_aca3fd63a4e0973c7aabeee518d2777f2}{Ipv6Prefix::GetOnes} (), nextHop, interface, 
      prefixToUse, metric);
141 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2




Here is the caller graph for this function\+:
% FIG 3


\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Add\+Host\+Route\+To@{Add\+Host\+Route\+To}}
\index{Add\+Host\+Route\+To@{Add\+Host\+Route\+To}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Add\+Host\+Route\+To(\+Ipv6\+Address dest, uint32\+\_\+t interface, uint32\+\_\+t metric=0)}{AddHostRouteTo(Ipv6Address dest, uint32_t interface, uint32_t metric=0)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Static\+Routing\+::\+Add\+Host\+Route\+To (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{dest, }
\item[{uint32\+\_\+t}]{interface, }
\item[{uint32\+\_\+t}]{metric = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6StaticRouting_a108d89b7940a31f2648d9ccff0ec0923}{}\label{classns3_1_1Ipv6StaticRouting_a108d89b7940a31f2648d9ccff0ec0923}


Add route to host. 


\begin{DoxyParams}{Parameters}
{\em dest} & destination address. \\
\hline
{\em interface} & interface index \\
\hline
{\em metric} & metric of route in case of multiple routes to same destination \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
144 \{
145   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << dst << interface << metric);
146   \hyperlink{classns3_1_1Ipv6StaticRouting_ac0c0c9d8e3182295c1cdb4a3d612a2d3}{AddNetworkRouteTo} (dst, \hyperlink{classns3_1_1Ipv6Prefix_aca3fd63a4e0973c7aabeee518d2777f2}{Ipv6Prefix::GetOnes} (), interface, metric);
147 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4


\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Add\+Multicast\+Route@{Add\+Multicast\+Route}}
\index{Add\+Multicast\+Route@{Add\+Multicast\+Route}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Add\+Multicast\+Route(\+Ipv6\+Address origin, Ipv6\+Address group, uint32\+\_\+t input\+Interface, std\+::vector$<$ uint32\+\_\+t $>$ output\+Interfaces)}{AddMulticastRoute(Ipv6Address origin, Ipv6Address group, uint32_t inputInterface, std::vector< uint32_t > outputInterfaces)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Static\+Routing\+::\+Add\+Multicast\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{origin, }
\item[{{\bf Ipv6\+Address}}]{group, }
\item[{uint32\+\_\+t}]{input\+Interface, }
\item[{std\+::vector$<$ uint32\+\_\+t $>$}]{output\+Interfaces}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6StaticRouting_a9b56c80cc1ee75c691844e0a5b1db4d3}{}\label{classns3_1_1Ipv6StaticRouting_a9b56c80cc1ee75c691844e0a5b1db4d3}


Add a multicast route for a given multicast source and group. 


\begin{DoxyParams}{Parameters}
{\em origin} & I\+Pv6 address of the source \\
\hline
{\em group} & the multicast group address. \\
\hline
{\em input\+Interface} & the interface index \\
\hline
{\em output\+Interfaces} & the list of output interface indices over which the packet should be sent (excluding the input\+Interface). \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
185 \{
186   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << origin << \hyperlink{namespacevisualizer_1_1higcontainer_aa6ad2b76790275bfce7783429beaa23f}{group} << inputInterface);
187   Ipv6MulticastRoutingTableEntry* route = \textcolor{keyword}{new} Ipv6MulticastRoutingTableEntry ();
188   *route = \hyperlink{classns3_1_1Ipv6MulticastRoutingTableEntry_ac82fd8a194e25b1eb30cb1a8c8ce8cff}{Ipv6MulticastRoutingTableEntry::CreateMulticastRoute}
       (origin, \hyperlink{namespacevisualizer_1_1higcontainer_aa6ad2b76790275bfce7783429beaa23f}{group}, inputInterface, outputInterfaces);
189   \hyperlink{classns3_1_1Ipv6StaticRouting_ab9690b202d45d5567be46567a4f782ac}{m\_multicastRoutes}.push\_back (route);
190 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5


\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Add\+Network\+Route\+To@{Add\+Network\+Route\+To}}
\index{Add\+Network\+Route\+To@{Add\+Network\+Route\+To}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Add\+Network\+Route\+To(\+Ipv6\+Address network, Ipv6\+Prefix network\+Prefix, Ipv6\+Address next\+Hop, uint32\+\_\+t interface, uint32\+\_\+t metric=0)}{AddNetworkRouteTo(Ipv6Address network, Ipv6Prefix networkPrefix, Ipv6Address nextHop, uint32_t interface, uint32_t metric=0)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Static\+Routing\+::\+Add\+Network\+Route\+To (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{network, }
\item[{{\bf Ipv6\+Prefix}}]{network\+Prefix, }
\item[{{\bf Ipv6\+Address}}]{next\+Hop, }
\item[{uint32\+\_\+t}]{interface, }
\item[{uint32\+\_\+t}]{metric = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6StaticRouting_ac0c0c9d8e3182295c1cdb4a3d612a2d3}{}\label{classns3_1_1Ipv6StaticRouting_ac0c0c9d8e3182295c1cdb4a3d612a2d3}


Add route to network. 


\begin{DoxyParams}{Parameters}
{\em network} & network address \\
\hline
{\em network\+Prefix} & network prefix$\ast$ \\
\hline
{\em next\+Hop} & next hop address to route the packet \\
\hline
{\em interface} & interface index \\
\hline
{\em metric} & metric of route in case of multiple routes to same destination \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
150 \{
151   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << network << networkPrefix << nextHop << interface << metric);
152   Ipv6RoutingTableEntry* route = \textcolor{keyword}{new} Ipv6RoutingTableEntry ();
153   *route = \hyperlink{classns3_1_1Ipv6RoutingTableEntry_aba706b8378ac6a5ad281f773125175d9}{Ipv6RoutingTableEntry::CreateNetworkRouteTo} (network,
       networkPrefix, nextHop, interface);
154   \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.push\_back (std::make\_pair (route, metric));
155 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6




Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Add\+Network\+Route\+To@{Add\+Network\+Route\+To}}
\index{Add\+Network\+Route\+To@{Add\+Network\+Route\+To}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Add\+Network\+Route\+To(\+Ipv6\+Address network, Ipv6\+Prefix network\+Prefix, Ipv6\+Address next\+Hop, uint32\+\_\+t interface, Ipv6\+Address prefix\+To\+Use, uint32\+\_\+t metric=0)}{AddNetworkRouteTo(Ipv6Address network, Ipv6Prefix networkPrefix, Ipv6Address nextHop, uint32_t interface, Ipv6Address prefixToUse, uint32_t metric=0)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Static\+Routing\+::\+Add\+Network\+Route\+To (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{network, }
\item[{{\bf Ipv6\+Prefix}}]{network\+Prefix, }
\item[{{\bf Ipv6\+Address}}]{next\+Hop, }
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv6\+Address}}]{prefix\+To\+Use, }
\item[{uint32\+\_\+t}]{metric = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6StaticRouting_adc37dbd1518eaadfd0c88161a7bb85ae}{}\label{classns3_1_1Ipv6StaticRouting_adc37dbd1518eaadfd0c88161a7bb85ae}


Add route to network. 


\begin{DoxyParams}{Parameters}
{\em network} & network address \\
\hline
{\em network\+Prefix} & network prefix$\ast$ \\
\hline
{\em next\+Hop} & next hop address to route the packet. \\
\hline
{\em interface} & interface index \\
\hline
{\em prefix\+To\+Use} & prefix that should be used for source address for this destination \\
\hline
{\em metric} & metric of route in case of multiple routes to same destination \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
158 \{
159   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << network << networkPrefix << nextHop << interface << prefixToUse 
      << metric);
160   \textcolor{keywordflow}{if} (nextHop.IsLinkLocal())
161     \{
162       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Ipv6StaticRouting::AddNetworkRouteTo - Next hop should be link-local"});
163     \}
164 
165   Ipv6RoutingTableEntry* route = \textcolor{keyword}{new} Ipv6RoutingTableEntry ();
166   *route = \hyperlink{classns3_1_1Ipv6RoutingTableEntry_aba706b8378ac6a5ad281f773125175d9}{Ipv6RoutingTableEntry::CreateNetworkRouteTo} (network,
       networkPrefix, nextHop, interface, prefixToUse);
167   \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.push\_back (std::make\_pair (route, metric));
168 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8


\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Add\+Network\+Route\+To@{Add\+Network\+Route\+To}}
\index{Add\+Network\+Route\+To@{Add\+Network\+Route\+To}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Add\+Network\+Route\+To(\+Ipv6\+Address network, Ipv6\+Prefix network\+Prefix, uint32\+\_\+t interface, uint32\+\_\+t metric=0)}{AddNetworkRouteTo(Ipv6Address network, Ipv6Prefix networkPrefix, uint32_t interface, uint32_t metric=0)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Static\+Routing\+::\+Add\+Network\+Route\+To (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{network, }
\item[{{\bf Ipv6\+Prefix}}]{network\+Prefix, }
\item[{uint32\+\_\+t}]{interface, }
\item[{uint32\+\_\+t}]{metric = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6StaticRouting_aea001a6aed49ee86bb09833ecaf5bbd7}{}\label{classns3_1_1Ipv6StaticRouting_aea001a6aed49ee86bb09833ecaf5bbd7}


Add route to network. 


\begin{DoxyParams}{Parameters}
{\em network} & network address \\
\hline
{\em network\+Prefix} & network prefix \\
\hline
{\em interface} & interface index \\
\hline
{\em metric} & metric of route in case of multiple routes to same destination \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
171 \{
172   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << network << networkPrefix << interface);
173   Ipv6RoutingTableEntry* route = \textcolor{keyword}{new} Ipv6RoutingTableEntry ();
174   *route = \hyperlink{classns3_1_1Ipv6RoutingTableEntry_aba706b8378ac6a5ad281f773125175d9}{Ipv6RoutingTableEntry::CreateNetworkRouteTo} (network,
       networkPrefix, interface);
175   \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.push\_back (std::make\_pair (route, metric));
176 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9


\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Do\+Dispose()}{DoDispose()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Static\+Routing\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6StaticRouting_a0ab95912087070c9df2aca8a388076a6}{}\label{classns3_1_1Ipv6StaticRouting_a0ab95912087070c9df2aca8a388076a6}


Dispose this object. 



Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.


\begin{DoxyCode}
375 \{
376   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
377 
378   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv6StaticRouting_aaaf6779ff5a716ce508cac3017f5f769}{NetworkRoutesI} j = \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.begin ();  j != 
      \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.end (); j = \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.erase (j))
379     \{
380       \textcolor{keyword}{delete} j->first;
381     \}
382   \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.clear ();
383 
384   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv6StaticRouting_aed9967a6ba9f015a1812644f7b2cde1f}{MulticastRoutesI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Ipv6StaticRouting_ab9690b202d45d5567be46567a4f782ac}{m\_multicastRoutes}.begin (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1Ipv6StaticRouting_ab9690b202d45d5567be46567a4f782ac}{m\_multicastRoutes}.end (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Ipv6StaticRouting_ab9690b202d45d5567be46567a4f782ac}{m\_multicastRoutes}.erase (
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}))
385     \{
386       \textcolor{keyword}{delete} (*i);
387     \}
388   \hyperlink{classns3_1_1Ipv6StaticRouting_ab9690b202d45d5567be46567a4f782ac}{m\_multicastRoutes}.clear ();
389 
390   \hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6} = 0;
391   \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{Ipv6RoutingProtocol::DoDispose} ();
392 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10


\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Get\+Default\+Route@{Get\+Default\+Route}}
\index{Get\+Default\+Route@{Get\+Default\+Route}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Default\+Route()}{GetDefaultRoute()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+Routing\+Table\+Entry} ns3\+::\+Ipv6\+Static\+Routing\+::\+Get\+Default\+Route (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6StaticRouting_aabac84f4bef43734f7bbf25b2f959705}{}\label{classns3_1_1Ipv6StaticRouting_aabac84f4bef43734f7bbf25b2f959705}


Get the default route. 

If multiple default routes exist, the one with lowest metric is returned. \begin{DoxyReturn}{Returns}
default \hyperlink{classns3_1_1Ipv6Route}{Ipv6\+Route} 
\end{DoxyReturn}

\begin{DoxyCode}
449 \{
450   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
451   Ipv6Address dst (\textcolor{stringliteral}{"::"});
452   uint32\_t shortestMetric = 0xffffffff;
453   Ipv6RoutingTableEntry* result = 0;
454 
455   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv6StaticRouting_aaaf6779ff5a716ce508cac3017f5f769}{NetworkRoutesI} it = \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.begin (); it != 
      \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.end (); it++)
456     \{
457       Ipv6RoutingTableEntry* j = it->first;
458       uint32\_t metric = it->second;
459       Ipv6Prefix mask = j->GetDestNetworkPrefix ();
460       uint16\_t maskLen = mask.GetPrefixLength ();
461       Ipv6Address entry = j->GetDestNetwork ();
462 
463       \textcolor{keywordflow}{if} (maskLen)
464         \{
465           \textcolor{keywordflow}{continue};
466         \}
467 
468       \textcolor{keywordflow}{if} (metric > shortestMetric)
469         \{
470           \textcolor{keywordflow}{continue};
471         \}
472       shortestMetric = metric;
473       result = j;
474     \}
475 
476   \textcolor{keywordflow}{if} (result)
477     \{
478       \textcolor{keywordflow}{return} result;
479     \}
480   \textcolor{keywordflow}{else}
481     \{
482       \textcolor{keywordflow}{return} Ipv6RoutingTableEntry ();
483     \}
484 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 11


\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Get\+Metric@{Get\+Metric}}
\index{Get\+Metric@{Get\+Metric}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Metric(uint32\+\_\+t index) const }{GetMetric(uint32_t index) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Ipv6\+Static\+Routing\+::\+Get\+Metric (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{index}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv6StaticRouting_adeb439c98a101186987e5780af6b1353}{}\label{classns3_1_1Ipv6StaticRouting_adeb439c98a101186987e5780af6b1353}


Get a metric for route from the static unicast routing table. 


\begin{DoxyParams}{Parameters}
{\em index} & The index (into the routing table) of the route to retrieve. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If route is set, the metric is returned. If not, an infinity metric (0xffffffff) is returned 
\end{DoxyReturn}

\begin{DoxyCode}
505 \{
506   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
507   uint32\_t tmp = 0;
508 
509   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv6StaticRouting_ad3c559fcd440cfe8e3a127f132c03527}{NetworkRoutesCI} it = \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.begin (); it != 
      \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.end (); it++)
510     \{
511       \textcolor{keywordflow}{if} (tmp == index)
512         \{
513           \textcolor{keywordflow}{return} it->second;
514         \}
515       tmp++;
516     \}
517   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\textcolor{keyword}{false});
518   \textcolor{comment}{// quiet compiler.}
519   \textcolor{keywordflow}{return} 0;
520 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 12


\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Get\+Multicast\+Route@{Get\+Multicast\+Route}}
\index{Get\+Multicast\+Route@{Get\+Multicast\+Route}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Multicast\+Route(uint32\+\_\+t i) const }{GetMulticastRoute(uint32_t i) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+Multicast\+Routing\+Table\+Entry} ns3\+::\+Ipv6\+Static\+Routing\+::\+Get\+Multicast\+Route (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv6StaticRouting_a622c079acbc62cb9e1279593d16344d4}{}\label{classns3_1_1Ipv6StaticRouting_a622c079acbc62cb9e1279593d16344d4}


Get the specified multicast route. 


\begin{DoxyParams}{Parameters}
{\em i} & index \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the route whose index is i 
\end{DoxyReturn}

\begin{DoxyCode}
209 \{
210   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << index);
211   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (index < \hyperlink{classns3_1_1Ipv6StaticRouting_ab9690b202d45d5567be46567a4f782ac}{m\_multicastRoutes}.size (), \textcolor{stringliteral}{"
      Ipv6StaticRouting::GetMulticastRoute () : Index out of range"});
212 
213   \textcolor{keywordflow}{if} (index < \hyperlink{classns3_1_1Ipv6StaticRouting_ab9690b202d45d5567be46567a4f782ac}{m\_multicastRoutes}.size ())
214     \{
215       uint32\_t tmp = 0;
216       \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv6StaticRouting_a92c49caeb07b0d87fc1945a828ba33eb}{MulticastRoutesCI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Ipv6StaticRouting_ab9690b202d45d5567be46567a4f782ac}{m\_multicastRoutes}.begin (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1Ipv6StaticRouting_ab9690b202d45d5567be46567a4f782ac}{m\_multicastRoutes}.end (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
217         \{
218           \textcolor{keywordflow}{if} (tmp  == index)
219             \{
220               \textcolor{keywordflow}{return} *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
221             \}
222           tmp++;
223         \}
224     \}
225   \textcolor{keywordflow}{return} 0;
226 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Get\+N\+Multicast\+Routes@{Get\+N\+Multicast\+Routes}}
\index{Get\+N\+Multicast\+Routes@{Get\+N\+Multicast\+Routes}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Get\+N\+Multicast\+Routes() const }{GetNMulticastRoutes() const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Ipv6\+Static\+Routing\+::\+Get\+N\+Multicast\+Routes (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv6StaticRouting_aa76cc9a5eabf0ec50ae65eff87817170}{}\label{classns3_1_1Ipv6StaticRouting_aa76cc9a5eabf0ec50ae65eff87817170}


Get the number of entries in the multicast routing table. 

\begin{DoxyReturn}{Returns}
number of entries 
\end{DoxyReturn}

\begin{DoxyCode}
203 \{
204   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
205   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv6StaticRouting_ab9690b202d45d5567be46567a4f782ac}{m\_multicastRoutes}.size ();
206 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Get\+N\+Routes@{Get\+N\+Routes}}
\index{Get\+N\+Routes@{Get\+N\+Routes}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Get\+N\+Routes() const }{GetNRoutes() const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Ipv6\+Static\+Routing\+::\+Get\+N\+Routes (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv6StaticRouting_a058db80420adcecf578861ac0baecd87}{}\label{classns3_1_1Ipv6StaticRouting_a058db80420adcecf578861ac0baecd87}


Get the number or entries in the routing table. 

\begin{DoxyReturn}{Returns}
number of entries 
\end{DoxyReturn}

\begin{DoxyCode}
444 \{
445   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.size ();
446 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 13


\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Get\+Route@{Get\+Route}}
\index{Get\+Route@{Get\+Route}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Route(uint32\+\_\+t i) const }{GetRoute(uint32_t i) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+Routing\+Table\+Entry} ns3\+::\+Ipv6\+Static\+Routing\+::\+Get\+Route (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv6StaticRouting_a3393aa35fbb0d409c78a6cb2d1bce96a}{}\label{classns3_1_1Ipv6StaticRouting_a3393aa35fbb0d409c78a6cb2d1bce96a}


Get a specified route. 


\begin{DoxyParams}{Parameters}
{\em i} & index \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the route whose index is i 
\end{DoxyReturn}

\begin{DoxyCode}
487 \{
488   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << index);
489   uint32\_t tmp = 0;
490 
491   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv6StaticRouting_ad3c559fcd440cfe8e3a127f132c03527}{NetworkRoutesCI} it = \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.begin (); it != 
      \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.end (); it++)
492     \{
493       \textcolor{keywordflow}{if} (tmp == index)
494         \{
495           \textcolor{keywordflow}{return} it->first;
496         \}
497       tmp++;
498     \}
499   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\textcolor{keyword}{false});
500   \textcolor{comment}{// quiet compiler.}
501   \textcolor{keywordflow}{return} 0;
502 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 14


\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id()}{GetTypeId()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Ipv6\+Static\+Routing\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv6StaticRouting_a46e2dbc750dbb14442a3ab2873d2fd5d}{}\label{classns3_1_1Ipv6StaticRouting_a46e2dbc750dbb14442a3ab2873d2fd5d}


The interface Id associated with this class. 

\begin{DoxyReturn}{Returns}
type identifier 
\end{DoxyReturn}

\begin{DoxyCode}
40 \{
41   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::Ipv6StaticRouting"})
42     .SetParent<Ipv6RoutingProtocol> ()
43     .SetGroupName (\textcolor{stringliteral}{"Internet"})
44     .AddConstructor<\hyperlink{classns3_1_1Ipv6StaticRouting_a1f9a909686971c59e89905cb46194fee}{Ipv6StaticRouting}> ()
45   ;
46   \textcolor{keywordflow}{return} tid;
47 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 15


\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Has\+Network\+Dest@{Has\+Network\+Dest}}
\index{Has\+Network\+Dest@{Has\+Network\+Dest}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Has\+Network\+Dest(\+Ipv6\+Address dest, uint32\+\_\+t interface\+Index)}{HasNetworkDest(Ipv6Address dest, uint32_t interfaceIndex)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv6\+Static\+Routing\+::\+Has\+Network\+Dest (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{dest, }
\item[{uint32\+\_\+t}]{interface\+Index}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6StaticRouting_a64cae9e90c2a35915bd5dae9ea84728d}{}\label{classns3_1_1Ipv6StaticRouting_a64cae9e90c2a35915bd5dae9ea84728d}


If the destination is already present in network destination list. 


\begin{DoxyParams}{Parameters}
{\em dest} & destination address \\
\hline
{\em interface\+Index} & interface index \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if dest is already in list, false otherwise 
\end{DoxyReturn}

\begin{DoxyCode}
264 \{
265   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << network << interfaceIndex);
266 
267   \textcolor{comment}{/* in the network table */}
268   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv6StaticRouting_aaaf6779ff5a716ce508cac3017f5f769}{NetworkRoutesI} j = \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.begin (); j != 
      \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.end (); j++)
269     \{
270       Ipv6RoutingTableEntry* rtentry = j->first;
271       Ipv6Prefix prefix = rtentry->GetDestNetworkPrefix ();
272       Ipv6Address entry = rtentry->GetDestNetwork ();
273 
274       \textcolor{keywordflow}{if} (prefix.IsMatch (network, entry) && rtentry->GetInterface () == interfaceIndex)
275         \{
276           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
277         \}
278     \}
279 
280   \textcolor{comment}{/* beuh!!! not route at all */}
281   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
282 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 16


\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Lookup\+Static@{Lookup\+Static}}
\index{Lookup\+Static@{Lookup\+Static}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Lookup\+Static(\+Ipv6\+Address dest, Ptr$<$ Net\+Device $>$=0)}{LookupStatic(Ipv6Address dest, Ptr< NetDevice >=0)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv6\+Route} $>$ ns3\+::\+Ipv6\+Static\+Routing\+::\+Lookup\+Static (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{dest, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{interface = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6StaticRouting_a53cafb0907cefabca6894c9d4dc6c154}{}\label{classns3_1_1Ipv6StaticRouting_a53cafb0907cefabca6894c9d4dc6c154}


Lookup in the forwarding table for destination. 


\begin{DoxyParams}{Parameters}
{\em dest} & destination address \\
\hline
{\em interface} & output interface if any (put 0 otherwise) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{classns3_1_1Ipv6Route}{Ipv6\+Route} to route the packet to reach dest address 
\end{DoxyReturn}

\begin{DoxyCode}
285 \{
286   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << dst << interface);
287   Ptr<Ipv6Route> rtentry = 0;
288   uint16\_t longestMask = 0;
289   uint32\_t shortestMetric = 0xffffffff;
290 
291   \textcolor{comment}{/* when sending on link-local multicast, there have to be interface specified */}
292   \textcolor{keywordflow}{if} (dst.IsLinkLocalMulticast ())
293     \{
294       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (interface, \textcolor{stringliteral}{"Try to send on link-local multicast address, and no interface
       index is given!"});
295       rtentry = Create<Ipv6Route> ();
296       rtentry->SetSource (\hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6}->SourceAddressSelection (\hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6}->GetInterfaceForDevice (
      interface), dst));
297       rtentry->SetDestination (dst);
298       rtentry->SetGateway (\hyperlink{classns3_1_1Ipv6Address_a63a34bdb1505e05fbdd07d316d0bd7e6}{Ipv6Address::GetZero} ());
299       rtentry->SetOutputDevice (interface);
300       \textcolor{keywordflow}{return} rtentry;
301     \}
302 
303   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv6StaticRouting_aaaf6779ff5a716ce508cac3017f5f769}{NetworkRoutesI} it = \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.begin (); it != 
      \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.end (); it++)
304     \{
305       Ipv6RoutingTableEntry* j = it->first;
306       uint32\_t metric = it->second;
307       Ipv6Prefix mask = j->GetDestNetworkPrefix ();
308       uint16\_t maskLen = mask.GetPrefixLength ();
309       Ipv6Address entry = j->GetDestNetwork ();
310 
311       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Searching for route to "} << dst << \textcolor{stringliteral}{", mask length "} << maskLen << \textcolor{stringliteral}{",
       metric "} << metric);
312 
313       \textcolor{keywordflow}{if} (mask.IsMatch (dst, entry))
314         \{
315           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Found global network route "} << *j << \textcolor{stringliteral}{", mask length "} << maskLen << \textcolor{stringliteral}{"
      , metric "} << metric);
316 
317           \textcolor{comment}{/* if interface is given, check the route will output on this interface */}
318           \textcolor{keywordflow}{if} (!interface || interface == \hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6}->GetNetDevice (j->GetInterface ()))
319             \{
320               \textcolor{keywordflow}{if} (maskLen < longestMask)
321                 \{
322                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Previous match longer, skipping"});
323                   \textcolor{keywordflow}{continue};
324                 \}
325 
326               \textcolor{keywordflow}{if} (maskLen > longestMask)
327                 \{
328                   shortestMetric = 0xffffffff;
329                 \}
330 
331               longestMask = maskLen;
332               \textcolor{keywordflow}{if} (metric > shortestMetric)
333                 \{
334                   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Equal mask length, but previous metric shorter, skipping"});
335                   \textcolor{keywordflow}{continue};
336                 \}
337 
338               shortestMetric = metric;
339               Ipv6RoutingTableEntry* route = j;
340               uint32\_t interfaceIdx = route->GetInterface ();
341               rtentry = Create<Ipv6Route> ();
342 
343               \textcolor{keywordflow}{if} (route->GetGateway ().IsAny ())
344                 \{
345                   rtentry->SetSource (\hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6}->SourceAddressSelection (interfaceIdx, route->GetDest ()
      ));
346                 \}
347               \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (route->GetDest ().IsAny ()) \textcolor{comment}{/* default route */}
348                 \{
349                   rtentry->SetSource (\hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6}->SourceAddressSelection (interfaceIdx, route->
      GetPrefixToUse ().IsAny () ? dst : route->GetPrefixToUse ()));
350                 \}
351               \textcolor{keywordflow}{else}
352                 \{
353                   rtentry->SetSource (\hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6}->SourceAddressSelection (interfaceIdx, route->GetGateway
       ()));
354                 \}
355 
356               rtentry->SetDestination (route->GetDest ());
357               rtentry->SetGateway (route->GetGateway ());
358               rtentry->SetOutputDevice (\hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6}->GetNetDevice (interfaceIdx));
359               \textcolor{keywordflow}{if} (maskLen == 128)
360                 \{
361                   \textcolor{keywordflow}{break};
362                 \}
363             \}
364         \}
365     \}
366 
367   \textcolor{keywordflow}{if} (rtentry)
368     \{
369       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Matching route via "} << rtentry->GetDestination () << \textcolor{stringliteral}{" (Through "} << 
      rtentry->GetGateway () << \textcolor{stringliteral}{") at the end"});
370     \}
371   \textcolor{keywordflow}{return} rtentry;
372 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 17




Here is the caller graph for this function\+:
% FIG 18


\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Lookup\+Static@{Lookup\+Static}}
\index{Lookup\+Static@{Lookup\+Static}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Lookup\+Static(\+Ipv6\+Address origin, Ipv6\+Address group, uint32\+\_\+t if\+Index)}{LookupStatic(Ipv6Address origin, Ipv6Address group, uint32_t ifIndex)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv6\+Multicast\+Route} $>$ ns3\+::\+Ipv6\+Static\+Routing\+::\+Lookup\+Static (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{origin, }
\item[{{\bf Ipv6\+Address}}]{group, }
\item[{uint32\+\_\+t}]{if\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6StaticRouting_aad420be705ea418cc3c0481e751d9094}{}\label{classns3_1_1Ipv6StaticRouting_aad420be705ea418cc3c0481e751d9094}


Lookup in the multicast forwarding table for destination. 


\begin{DoxyParams}{Parameters}
{\em origin} & source address \\
\hline
{\em group} & group multicast address \\
\hline
{\em if\+Index} & interface index \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{classns3_1_1Ipv6MulticastRoute}{Ipv6\+Multicast\+Route} to route the packet to reach dest address 
\end{DoxyReturn}

\begin{DoxyCode}
395 \{
396   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << origin << \hyperlink{namespacevisualizer_1_1higcontainer_aa6ad2b76790275bfce7783429beaa23f}{group} << interface);
397   Ptr<Ipv6MulticastRoute> mrtentry = 0;
398 
399   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv6StaticRouting_aed9967a6ba9f015a1812644f7b2cde1f}{MulticastRoutesI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Ipv6StaticRouting_ab9690b202d45d5567be46567a4f782ac}{m\_multicastRoutes}.begin (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1Ipv6StaticRouting_ab9690b202d45d5567be46567a4f782ac}{m\_multicastRoutes}.end (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
400     \{
401       Ipv6MulticastRoutingTableEntry* route = *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
402 
403       \textcolor{comment}{/*}
404 \textcolor{comment}{         We've been passed an origin address, a multicast group address and an}
405 \textcolor{comment}{         interface index.  We have to decide if the current route in the list is}
406 \textcolor{comment}{         a match.}
407 \textcolor{comment}{}
408 \textcolor{comment}{         The first case is the restrictive case where the origin, group and index}
409 \textcolor{comment}{         matches.  This picks up exact routes during forwarded and exact routes from}
410 \textcolor{comment}{         the local node (in which case the ifIndex is a wildcard).}
411 \textcolor{comment}{         */}
412 
413       \textcolor{keywordflow}{if} (origin == route->GetOrigin () && \hyperlink{namespacevisualizer_1_1higcontainer_aa6ad2b76790275bfce7783429beaa23f}{group} == route->GetGroup ())
414         \{
415           \textcolor{comment}{/* skipping SSM case */}
416           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Find source specific multicast route"} << *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
417         \}
418 
419       \textcolor{keywordflow}{if} (\hyperlink{namespacevisualizer_1_1higcontainer_aa6ad2b76790275bfce7783429beaa23f}{group} == route->GetGroup ())
420         \{
421           \textcolor{keywordflow}{if} (interface == \hyperlink{classns3_1_1Ipv6_a1e55b17e6e1a4e1b439778543458bbe3}{Ipv6::IF\_ANY} || interface == route->GetInputInterface ())
422             \{
423               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Found multicast route"} << *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
424               mrtentry = Create<Ipv6MulticastRoute> ();
425               mrtentry->SetGroup (route->GetGroup ());
426               mrtentry->SetOrigin (route->GetOrigin ());
427               mrtentry->SetParent (route->GetInputInterface ());
428               \textcolor{keywordflow}{for} (uint32\_t j = 0; j < route->GetNOutputInterfaces (); j++)
429                 \{
430                   \textcolor{keywordflow}{if} (route->GetOutputInterface (j))
431                     \{
432                       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Setting output interface index "} << route->
      GetOutputInterface (j));
433                       mrtentry->SetOutputTtl (route->GetOutputInterface (j), 
      \hyperlink{classns3_1_1Ipv6MulticastRoute_a4e067c261e6c0abbeaaeb050f9b1727b}{Ipv6MulticastRoute::MAX\_TTL} - 1);
434                     \}
435                 \}
436               \textcolor{keywordflow}{return} mrtentry;
437             \}
438         \}
439     \}
440   \textcolor{keywordflow}{return} mrtentry;
441 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 19


\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Notify\+Add\+Address@{Notify\+Add\+Address}}
\index{Notify\+Add\+Address@{Notify\+Add\+Address}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Notify\+Add\+Address(uint32\+\_\+t interface, Ipv6\+Interface\+Address address)}{NotifyAddAddress(uint32_t interface, Ipv6InterfaceAddress address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Static\+Routing\+::\+Notify\+Add\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv6\+Interface\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6StaticRouting_ab4f7777b5228f498fa3493c753d50b8f}{}\label{classns3_1_1Ipv6StaticRouting_ab4f7777b5228f498fa3493c753d50b8f}


Notify when specified interface add an address. 

Protocols are expected to implement this method to be notified whenever a new address is added to an interface. Typically used to add a \textquotesingle{}network route\textquotesingle{} on an interface. Can be invoked on an up or down interface. 
\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
{\em address} & a new address being added to an interface \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6RoutingProtocol_ae8ef31faadbb3ddd1c9a8888c986cb57}{ns3\+::\+Ipv6\+Routing\+Protocol}.


\begin{DoxyCode}
686 \{
687   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6}->IsUp (interface))
688     \{
689       \textcolor{keywordflow}{return};
690     \}
691 
692   Ipv6Address networkAddress = address.GetAddress ().CombinePrefix (address.GetPrefix ());
693   Ipv6Prefix networkMask = address.GetPrefix ();
694 
695   \textcolor{keywordflow}{if} (address.GetAddress () != Ipv6Address () && address.GetPrefix () != Ipv6Prefix ())
696     \{
697       \hyperlink{classns3_1_1Ipv6StaticRouting_ac0c0c9d8e3182295c1cdb4a3d612a2d3}{AddNetworkRouteTo} (networkAddress, networkMask, interface);
698     \}
699 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 20


\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Notify\+Add\+Route@{Notify\+Add\+Route}}
\index{Notify\+Add\+Route@{Notify\+Add\+Route}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Notify\+Add\+Route(\+Ipv6\+Address dst, Ipv6\+Prefix mask, Ipv6\+Address next\+Hop, uint32\+\_\+t interface, Ipv6\+Address prefix\+To\+Use=\+Ipv6\+Address\+::\+Get\+Zero())}{NotifyAddRoute(Ipv6Address dst, Ipv6Prefix mask, Ipv6Address nextHop, uint32_t interface, Ipv6Address prefixToUse=Ipv6Address::GetZero())}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Static\+Routing\+::\+Notify\+Add\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{dst, }
\item[{{\bf Ipv6\+Prefix}}]{mask, }
\item[{{\bf Ipv6\+Address}}]{next\+Hop, }
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv6\+Address}}]{prefix\+To\+Use = {\ttfamily {\bf Ipv6\+Address\+::\+Get\+Zero}()}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6StaticRouting_aaae863ba89a47ad659fb5dc3602c9e24}{}\label{classns3_1_1Ipv6StaticRouting_aaae863ba89a47ad659fb5dc3602c9e24}


Notify a new route. 

Typically this is used to add another route from I\+Pv6 stack (i.\+e. I\+C\+M\+Pv6 redirect case, ...). 
\begin{DoxyParams}{Parameters}
{\em dst} & destination address \\
\hline
{\em mask} & destination mask \\
\hline
{\em next\+Hop} & next\+Hop for this destination \\
\hline
{\em interface} & output interface \\
\hline
{\em prefix\+To\+Use} & prefix to use as source with this route \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6RoutingProtocol_ad5fee223bfdac0b1dde05de7702a87cf}{ns3\+::\+Ipv6\+Routing\+Protocol}.


\begin{DoxyCode}
731 \{
732   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{keyword}{this} << dst << mask << nextHop << interface << prefixToUse);
733   \textcolor{keywordflow}{if} (dst != \hyperlink{classns3_1_1Ipv6Address_a63a34bdb1505e05fbdd07d316d0bd7e6}{Ipv6Address::GetZero} ())
734     \{
735       \hyperlink{classns3_1_1Ipv6StaticRouting_ac0c0c9d8e3182295c1cdb4a3d612a2d3}{AddNetworkRouteTo} (dst, mask, nextHop, interface);
736     \}
737   \textcolor{keywordflow}{else} \textcolor{comment}{/* default route */}
738     \{
739       \textcolor{comment}{/* this case is mainly used by configuring default route following RA processing,}
740 \textcolor{comment}{       * in case of multiple prefix in RA, the first will configured default route}
741 \textcolor{comment}{       */}
742 
743       \textcolor{comment}{/* for the moment, all default route has the same metric}
744 \textcolor{comment}{       * so according to the longest prefix algorithm,}
745 \textcolor{comment}{       * the default route chosen will be the last added}
746 \textcolor{comment}{       */}
747       \hyperlink{classns3_1_1Ipv6StaticRouting_af80ab0c9c95ea4bbc004bda7ce1cae06}{SetDefaultRoute} (nextHop, interface, prefixToUse);
748     \}
749 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 21


\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Notify\+Interface\+Down@{Notify\+Interface\+Down}}
\index{Notify\+Interface\+Down@{Notify\+Interface\+Down}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Notify\+Interface\+Down(uint32\+\_\+t interface)}{NotifyInterfaceDown(uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Static\+Routing\+::\+Notify\+Interface\+Down (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6StaticRouting_a1e917452e99ee697b9ffd5acebfc0a02}{}\label{classns3_1_1Ipv6StaticRouting_a1e917452e99ee697b9ffd5acebfc0a02}


Notify when specified interface goes D\+O\+WN. 

Protocols are expected to implement this method to be notified of the state change of an interface in a node. 
\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6RoutingProtocol_aa9b4c21a3878a1b808c9ac9d26c914bf}{ns3\+::\+Ipv6\+Routing\+Protocol}.


\begin{DoxyCode}
667 \{
668   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
669 
670   \textcolor{comment}{/* remove all static routes that are going through this interface */}
671   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv6StaticRouting_aaaf6779ff5a716ce508cac3017f5f769}{NetworkRoutesI} it = \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.begin (); it != 
      \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.end (); )
672     \{
673       \textcolor{keywordflow}{if} (it->first->GetInterface () == \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
674         \{
675           \textcolor{keyword}{delete} it->first;
676           it = \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.erase (it);
677         \}
678       \textcolor{keywordflow}{else}
679         \{
680           it++;
681         \}
682     \}
683 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 22


\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Notify\+Interface\+Up@{Notify\+Interface\+Up}}
\index{Notify\+Interface\+Up@{Notify\+Interface\+Up}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Notify\+Interface\+Up(uint32\+\_\+t interface)}{NotifyInterfaceUp(uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Static\+Routing\+::\+Notify\+Interface\+Up (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6StaticRouting_a9750930029ffe2eaafda77ba77918472}{}\label{classns3_1_1Ipv6StaticRouting_a9750930029ffe2eaafda77ba77918472}


Notify when specified interface goes UP. 

Protocols are expected to implement this method to be notified of the state change of an interface in a node. 
\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6RoutingProtocol_a024dd60e2deb864565ba5993efc38300}{ns3\+::\+Ipv6\+Routing\+Protocol}.


\begin{DoxyCode}
646 \{
647   \textcolor{keywordflow}{for} (uint32\_t j = 0; j < \hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6}->GetNAddresses (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}); j++)
648     \{
649       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, j).GetAddress () != Ipv6Address ()
650           && \hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, j).GetPrefix () != Ipv6Prefix ())
651         \{
652           \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, j).GetPrefix () == Ipv6Prefix (128))
653             \{
654               \textcolor{comment}{/* host route */}
655               \hyperlink{classns3_1_1Ipv6StaticRouting_a9c09d10eb7d7d67c29bdc05bb620c241}{AddHostRouteTo} (\hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, j).GetAddress (), 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
656             \}
657           \textcolor{keywordflow}{else}
658             \{
659               \hyperlink{classns3_1_1Ipv6StaticRouting_ac0c0c9d8e3182295c1cdb4a3d612a2d3}{AddNetworkRouteTo} (\hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, j).GetAddress ().
      CombinePrefix (\hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, j).GetPrefix ()),
660                                  \hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, j).GetPrefix (), 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
661             \}
662         \}
663     \}
664 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 23




Here is the caller graph for this function\+:
% FIG 24


\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Notify\+Remove\+Address@{Notify\+Remove\+Address}}
\index{Notify\+Remove\+Address@{Notify\+Remove\+Address}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Notify\+Remove\+Address(uint32\+\_\+t interface, Ipv6\+Interface\+Address address)}{NotifyRemoveAddress(uint32_t interface, Ipv6InterfaceAddress address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Static\+Routing\+::\+Notify\+Remove\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv6\+Interface\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6StaticRouting_ab100c4857d93e5f0cc980e8024838e68}{}\label{classns3_1_1Ipv6StaticRouting_ab100c4857d93e5f0cc980e8024838e68}


Notify when specified interface add an address. 

Protocols are expected to implement this method to be notified whenever a new address is removed from an interface. Typically used to remove the \textquotesingle{}network route\textquotesingle{} of an interface. Can be invoked on an up or down interface. 
\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
{\em address} & a new address being added to an interface \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6RoutingProtocol_a878ace2f28ea3b07417fe5751d9ec5fc}{ns3\+::\+Ipv6\+Routing\+Protocol}.


\begin{DoxyCode}
702 \{
703   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6}->IsUp (interface))
704     \{
705       \textcolor{keywordflow}{return};
706     \}
707 
708   Ipv6Address networkAddress = address.GetAddress ().CombinePrefix (address.GetPrefix ());
709   Ipv6Prefix networkMask = address.GetPrefix ();
710 
711   \textcolor{comment}{// Remove all static routes that are going through this interface}
712   \textcolor{comment}{// which reference this network}
713   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv6StaticRouting_aaaf6779ff5a716ce508cac3017f5f769}{NetworkRoutesI} it = \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.begin (); it != 
      \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.end (); )
714     \{
715       \textcolor{keywordflow}{if} (it->first->GetInterface () == interface
716           && it->first->IsNetwork ()
717           && it->first->GetDestNetwork () == networkAddress
718           && it->first->GetDestNetworkPrefix () == networkMask)
719         \{
720           \textcolor{keyword}{delete} it->first;
721           it = \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.erase (it);
722         \}
723       \textcolor{keywordflow}{else}
724         \{
725           it++;
726         \}
727     \}
728 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 25


\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Notify\+Remove\+Route@{Notify\+Remove\+Route}}
\index{Notify\+Remove\+Route@{Notify\+Remove\+Route}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Notify\+Remove\+Route(\+Ipv6\+Address dst, Ipv6\+Prefix mask, Ipv6\+Address next\+Hop, uint32\+\_\+t interface, Ipv6\+Address prefix\+To\+Use=\+Ipv6\+Address\+::\+Get\+Zero())}{NotifyRemoveRoute(Ipv6Address dst, Ipv6Prefix mask, Ipv6Address nextHop, uint32_t interface, Ipv6Address prefixToUse=Ipv6Address::GetZero())}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Static\+Routing\+::\+Notify\+Remove\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{dst, }
\item[{{\bf Ipv6\+Prefix}}]{mask, }
\item[{{\bf Ipv6\+Address}}]{next\+Hop, }
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv6\+Address}}]{prefix\+To\+Use = {\ttfamily {\bf Ipv6\+Address\+::\+Get\+Zero}()}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6StaticRouting_aee1c676f218334e82bbbaf695aa93514}{}\label{classns3_1_1Ipv6StaticRouting_aee1c676f218334e82bbbaf695aa93514}


Notify route removing. 


\begin{DoxyParams}{Parameters}
{\em dst} & destination address \\
\hline
{\em mask} & destination mask \\
\hline
{\em next\+Hop} & next\+Hop for this destination \\
\hline
{\em interface} & output interface \\
\hline
{\em prefix\+To\+Use} & prefix to use as source with this route \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6RoutingProtocol_afcd129c7be3b0fb78012fa68025bf553}{ns3\+::\+Ipv6\+Routing\+Protocol}.


\begin{DoxyCode}
752 \{
753   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << dst << mask << nextHop << interface);
754   \textcolor{keywordflow}{if} (dst != \hyperlink{classns3_1_1Ipv6Address_a63a34bdb1505e05fbdd07d316d0bd7e6}{Ipv6Address::GetZero} ())
755     \{
756       \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv6StaticRouting_aaaf6779ff5a716ce508cac3017f5f769}{NetworkRoutesI} j = \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.begin (); j != 
      \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.end ();)
757         \{
758           Ipv6RoutingTableEntry* rtentry = j->first;
759           Ipv6Prefix prefix = rtentry->GetDestNetworkPrefix ();
760           Ipv6Address entry = rtentry->GetDestNetwork ();
761 
762           \textcolor{keywordflow}{if} (dst == entry && prefix == mask && rtentry->GetInterface () == interface)
763             \{
764               \textcolor{keyword}{delete} j->first;
765               j = \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.erase (j);
766             \}
767           \textcolor{keywordflow}{else}
768             \{
769               ++j;
770             \}
771         \}
772     \}
773   \textcolor{keywordflow}{else}
774     \{
775       \textcolor{comment}{/* default route case */}
776       \hyperlink{classns3_1_1Ipv6StaticRouting_a212afe37bcc27e9c85c15c9317269cd5}{RemoveRoute} (dst, mask, interface, prefixToUse);
777     \}
778 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 26


\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Print\+Routing\+Table@{Print\+Routing\+Table}}
\index{Print\+Routing\+Table@{Print\+Routing\+Table}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Print\+Routing\+Table(\+Ptr$<$ Output\+Stream\+Wrapper $>$ stream, Time\+::\+Unit unit=\+Time\+::\+S) const }{PrintRoutingTable(Ptr< OutputStreamWrapper > stream, Time::Unit unit=Time::S) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Static\+Routing\+::\+Print\+Routing\+Table (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream, }
\item[{{\bf Time\+::\+Unit}}]{unit = {\ttfamily {\bf Time\+::S}}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6StaticRouting_a39ea5334065001c093c8165d6a282550}{}\label{classns3_1_1Ipv6StaticRouting_a39ea5334065001c093c8165d6a282550}


Print the Routing Table entries. 


\begin{DoxyParams}{Parameters}
{\em stream} & The ostream the Routing table is printed to \\
\hline
{\em unit} & The time unit to be used in the report \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6RoutingProtocol_a2d5f8412f903a1365a1e84c06ad3da43}{ns3\+::\+Ipv6\+Routing\+Protocol}.


\begin{DoxyCode}
83 \{
84   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << stream);
85   std::ostream* os = stream->\hyperlink{classns3_1_1OutputStreamWrapper_a0cf30a4188ab6fdae2b2ab74db11acc2}{GetStream} ();
86 
87   *os << \textcolor{stringliteral}{"Node: "} << \hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6}->GetObject<Node> ()->GetId ()
88       << \textcolor{stringliteral}{", Time: "} << \hyperlink{group__simulator_gac3635e2e87f7ce316c89290ee1b01d0d}{Now}().\hyperlink{classns3_1_1Time_a0bb1110638ce9938248bd07865a328ab}{As} (unit)
89       << \textcolor{stringliteral}{", Local time: "} << GetObject<Node> ()->GetLocalTime ().As (unit)
90       << \textcolor{stringliteral}{", Ipv6StaticRouting table"} << std::endl;
91 
92   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6StaticRouting_a058db80420adcecf578861ac0baecd87}{GetNRoutes} () > 0)
93     \{
94       *os << \textcolor{stringliteral}{"Destination                    Next Hop                   Flag Met Ref Use If"} << std::endl;
95       \textcolor{keywordflow}{for} (uint32\_t j = 0; j < \hyperlink{classns3_1_1Ipv6StaticRouting_a058db80420adcecf578861ac0baecd87}{GetNRoutes} (); j++)
96         \{
97           std::ostringstream dest, gw, mask, flags;
98           Ipv6RoutingTableEntry route = \hyperlink{classns3_1_1Ipv6StaticRouting_a3393aa35fbb0d409c78a6cb2d1bce96a}{GetRoute} (j);
99           dest << route.GetDest () << \textcolor{stringliteral}{"/"} << int(route.GetDestNetworkPrefix ().GetPrefixLength ());
100           *os << std::setiosflags (std::ios::left) << std::setw (31) << dest.str ();
101           gw << route.GetGateway ();
102           *os << std::setiosflags (std::ios::left) << std::setw (27) << gw.str ();
103           flags << \textcolor{stringliteral}{"U"};
104           \textcolor{keywordflow}{if} (route.IsHost ())
105             \{
106               flags << \textcolor{stringliteral}{"H"};
107             \}
108           \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (route.IsGateway ())
109             \{
110               flags << \textcolor{stringliteral}{"G"};
111             \}
112           *os << std::setiosflags (std::ios::left) << std::setw (5) << flags.str ();
113           *os << std::setiosflags (std::ios::left) << std::setw (4) << \hyperlink{classns3_1_1Ipv6StaticRouting_adeb439c98a101186987e5780af6b1353}{GetMetric} (j);
114           \textcolor{comment}{// Ref ct not implemented}
115           *os << \textcolor{stringliteral}{"-"} << \textcolor{stringliteral}{"   "};
116           \textcolor{comment}{// Use not implemented}
117           *os << \textcolor{stringliteral}{"-"} << \textcolor{stringliteral}{"   "};
118           \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Names_ab9664faf23569aaae64a2d1f65265045}{Names::FindName} (\hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6}->GetNetDevice (route.GetInterface ())) != \textcolor{stringliteral}{""})
119             \{
120               *os << \hyperlink{classns3_1_1Names_ab9664faf23569aaae64a2d1f65265045}{Names::FindName} (\hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6}->GetNetDevice (route.GetInterface ()));
121             \}
122           \textcolor{keywordflow}{else}
123             \{
124               *os << route.GetInterface ();
125             \}
126           *os << std::endl;
127         \}
128     \}
129   *os << std::endl;
130 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 27


\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Remove\+Multicast\+Route@{Remove\+Multicast\+Route}}
\index{Remove\+Multicast\+Route@{Remove\+Multicast\+Route}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Remove\+Multicast\+Route(\+Ipv6\+Address origin, Ipv6\+Address group, uint32\+\_\+t input\+Interface)}{RemoveMulticastRoute(Ipv6Address origin, Ipv6Address group, uint32_t inputInterface)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv6\+Static\+Routing\+::\+Remove\+Multicast\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{origin, }
\item[{{\bf Ipv6\+Address}}]{group, }
\item[{uint32\+\_\+t}]{input\+Interface}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6StaticRouting_abb22fb02e9e80038383e3d4ae140ac37}{}\label{classns3_1_1Ipv6StaticRouting_abb22fb02e9e80038383e3d4ae140ac37}


Remove a static multicast route. 


\begin{DoxyParams}{Parameters}
{\em origin} & I\+Pv6 address of the source \\
\hline
{\em group} & the multicast group address. \\
\hline
{\em input\+Interface} & the input interface index \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success 
\end{DoxyReturn}

\begin{DoxyCode}
229 \{
230   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << origin << \hyperlink{namespacevisualizer_1_1higcontainer_aa6ad2b76790275bfce7783429beaa23f}{group} << inputInterface);
231   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv6StaticRouting_aed9967a6ba9f015a1812644f7b2cde1f}{MulticastRoutesI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Ipv6StaticRouting_ab9690b202d45d5567be46567a4f782ac}{m\_multicastRoutes}.begin (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1Ipv6StaticRouting_ab9690b202d45d5567be46567a4f782ac}{m\_multicastRoutes}.end (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
232     \{
233       Ipv6MulticastRoutingTableEntry *route = *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
234       \textcolor{keywordflow}{if} (origin == route->GetOrigin ()
235           && \hyperlink{namespacevisualizer_1_1higcontainer_aa6ad2b76790275bfce7783429beaa23f}{group} == route->GetGroup ()
236           && inputInterface == route->GetInputInterface ())
237         \{
238           \textcolor{keyword}{delete} *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
239           \hyperlink{classns3_1_1Ipv6StaticRouting_ab9690b202d45d5567be46567a4f782ac}{m\_multicastRoutes}.erase (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
240           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
241         \}
242     \}
243   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
244 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 28


\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Remove\+Multicast\+Route@{Remove\+Multicast\+Route}}
\index{Remove\+Multicast\+Route@{Remove\+Multicast\+Route}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Remove\+Multicast\+Route(uint32\+\_\+t i)}{RemoveMulticastRoute(uint32_t i)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Static\+Routing\+::\+Remove\+Multicast\+Route (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6StaticRouting_a4a3cb10ebb513dfe2bbddb8366e61ab0}{}\label{classns3_1_1Ipv6StaticRouting_a4a3cb10ebb513dfe2bbddb8366e61ab0}


Remove a multicast route. 


\begin{DoxyParams}{Parameters}
{\em i} & index of route to remove \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
247 \{
248   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << index);
249   uint32\_t tmp = 0;
250 
251   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv6StaticRouting_aed9967a6ba9f015a1812644f7b2cde1f}{MulticastRoutesI} \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Ipv6StaticRouting_ab9690b202d45d5567be46567a4f782ac}{m\_multicastRoutes}.begin (); 
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != \hyperlink{classns3_1_1Ipv6StaticRouting_ab9690b202d45d5567be46567a4f782ac}{m\_multicastRoutes}.end (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
252     \{
253       \textcolor{keywordflow}{if} (tmp == index)
254         \{
255           \textcolor{keyword}{delete} *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
256           \hyperlink{classns3_1_1Ipv6StaticRouting_ab9690b202d45d5567be46567a4f782ac}{m\_multicastRoutes}.erase (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
257           \textcolor{keywordflow}{return};
258         \}
259       tmp++;
260     \}
261 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Remove\+Route@{Remove\+Route}}
\index{Remove\+Route@{Remove\+Route}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Remove\+Route(uint32\+\_\+t i)}{RemoveRoute(uint32_t i)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Static\+Routing\+::\+Remove\+Route (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6StaticRouting_a212afe37bcc27e9c85c15c9317269cd5}{}\label{classns3_1_1Ipv6StaticRouting_a212afe37bcc27e9c85c15c9317269cd5}


Remove a route from the routing table. 


\begin{DoxyParams}{Parameters}
{\em i} & index \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
523 \{
524   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << index);
525   uint32\_t tmp = 0;
526 
527   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv6StaticRouting_aaaf6779ff5a716ce508cac3017f5f769}{NetworkRoutesI} it = \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.begin (); it != 
      \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.end (); it++)
528     \{
529       \textcolor{keywordflow}{if} (tmp == index)
530         \{
531           \textcolor{keyword}{delete} it->first;
532           \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.erase (it);
533           \textcolor{keywordflow}{return};
534         \}
535       tmp++;
536     \}
537   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\textcolor{keyword}{false});
538 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 29


\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Remove\+Route@{Remove\+Route}}
\index{Remove\+Route@{Remove\+Route}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Remove\+Route(\+Ipv6\+Address network, Ipv6\+Prefix prefix, uint32\+\_\+t if\+Index, Ipv6\+Address prefix\+To\+Use)}{RemoveRoute(Ipv6Address network, Ipv6Prefix prefix, uint32_t ifIndex, Ipv6Address prefixToUse)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Static\+Routing\+::\+Remove\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{network, }
\item[{{\bf Ipv6\+Prefix}}]{prefix, }
\item[{uint32\+\_\+t}]{if\+Index, }
\item[{{\bf Ipv6\+Address}}]{prefix\+To\+Use}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6StaticRouting_a9e1d32b4260bea10088c82bbf5906d06}{}\label{classns3_1_1Ipv6StaticRouting_a9e1d32b4260bea10088c82bbf5906d06}


Remove a route from the routing table. 


\begin{DoxyParams}{Parameters}
{\em network} & I\+Pv6 network \\
\hline
{\em prefix} & I\+Pv6 prefix \\
\hline
{\em if\+Index} & interface index \\
\hline
{\em prefix\+To\+Use} & I\+Pv6 prefix to use with this route (multihoming) \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
541 \{
542   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << network << prefix << ifIndex);
543 
544   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv6StaticRouting_aaaf6779ff5a716ce508cac3017f5f769}{NetworkRoutesI} it = \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.begin (); it != 
      \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.end (); it++)
545     \{
546       Ipv6RoutingTableEntry* rtentry = it->first;
547       \textcolor{keywordflow}{if} (network == rtentry->GetDest () && rtentry->GetInterface () == ifIndex
548           && rtentry->GetPrefixToUse () == prefixToUse)
549         \{
550           \textcolor{keyword}{delete} it->first;
551           \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.erase (it);
552           \textcolor{keywordflow}{return};
553         \}
554     \}
555 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 30


\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Route\+Input@{Route\+Input}}
\index{Route\+Input@{Route\+Input}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Route\+Input(\+Ptr$<$ const Packet $>$ p, const Ipv6\+Header \&header, Ptr$<$ const Net\+Device $>$ idev, Unicast\+Forward\+Callback ucb, Multicast\+Forward\+Callback mcb, Local\+Deliver\+Callback lcb, Error\+Callback ecb)}{RouteInput(Ptr< const Packet > p, const Ipv6Header &header, Ptr< const NetDevice > idev, UnicastForwardCallback ucb, MulticastForwardCallback mcb, LocalDeliverCallback lcb, ErrorCallback ecb)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv6\+Static\+Routing\+::\+Route\+Input (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv6\+Header} \&}]{header, }
\item[{{\bf Ptr}$<$ const {\bf Net\+Device} $>$}]{idev, }
\item[{{\bf Unicast\+Forward\+Callback}}]{ucb, }
\item[{{\bf Multicast\+Forward\+Callback}}]{mcb, }
\item[{{\bf Local\+Deliver\+Callback}}]{lcb, }
\item[{{\bf Error\+Callback}}]{ecb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6StaticRouting_a33810db6250f018b4587dc34a43a80cb}{}\label{classns3_1_1Ipv6StaticRouting_a33810db6250f018b4587dc34a43a80cb}


Route an input packet (to be forwarded or locally delivered) 

This lookup is used in the forwarding process. The packet is handed over to the \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol}, and will get forwarded onward by one of the callbacks. The Linux equivalent is ip\+\_\+route\+\_\+input (). There are four valid outcomes, and a matching callbacks to handle each.


\begin{DoxyParams}{Parameters}
{\em p} & received packet \\
\hline
{\em header} & input parameter used to form a search key for a route \\
\hline
{\em idev} & Pointer to ingress network device \\
\hline
{\em ucb} & \hyperlink{classns3_1_1Callback}{Callback} for the case in which the packet is to be forwarded as unicast \\
\hline
{\em mcb} & \hyperlink{classns3_1_1Callback}{Callback} for the case in which the packet is to be forwarded as multicast \\
\hline
{\em lcb} & \hyperlink{classns3_1_1Callback}{Callback} for the case in which the packet is to be locally delivered \\
\hline
{\em ecb} & \hyperlink{classns3_1_1Callback}{Callback} to call if there is an error in forwarding \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} takes responsibility for forwarding or delivering the packet, false otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv6RoutingProtocol_a73c66cddf196bf84090305f8d64df33b}{ns3\+::\+Ipv6\+Routing\+Protocol}.


\begin{DoxyCode}
589 \{
590   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} << header << header.GetSourceAddress () << header.
      GetDestinationAddress () << idev);
591   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6} != 0);
592   \textcolor{comment}{// Check if input device supports IP}
593   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6}->GetInterfaceForDevice (idev) >= 0);
594   uint32\_t iif = \hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6}->GetInterfaceForDevice (idev);
595   Ipv6Address dst = header.GetDestinationAddress ();
596 
597   \textcolor{comment}{// Multicast recognition; handle local delivery here}
598   \textcolor{keywordflow}{if} (dst.IsMulticast ())
599     \{
600       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Multicast destination"});
601       Ptr<Ipv6MulticastRoute> mrtentry = \hyperlink{classns3_1_1Ipv6StaticRouting_a53cafb0907cefabca6894c9d4dc6c154}{LookupStatic} (header.GetSourceAddress (),
602                                                        header.GetDestinationAddress (), 
      \hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6}->GetInterfaceForDevice (idev));
603 
604       \textcolor{comment}{// \(\backslash\)todo check if we want to forward up the packet}
605       \textcolor{keywordflow}{if} (mrtentry)
606         \{
607           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Multicast route found"});
608           mcb (idev, mrtentry, \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header); \textcolor{comment}{// multicast forwarding callback}
609           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
610         \}
611       \textcolor{keywordflow}{else}
612         \{
613           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Multicast route not found"});
614           \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \textcolor{comment}{// Let other routing protocols try to handle this}
615         \}
616     \}
617 
618   \textcolor{comment}{// Check if input device supports IP forwarding}
619   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6}->IsForwarding (iif) == \textcolor{keyword}{false})
620     \{
621       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Forwarding disabled for this interface"});
622       \textcolor{keywordflow}{if} (!ecb.IsNull ())
623         \{
624           ecb (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{Socket::ERROR\_NOROUTETOHOST});
625         \}
626       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
627     \}
628   \textcolor{comment}{// Next, try to find a route}
629   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Unicast destination"});
630   Ptr<Ipv6Route> rtentry = \hyperlink{classns3_1_1Ipv6StaticRouting_a53cafb0907cefabca6894c9d4dc6c154}{LookupStatic} (header.GetDestinationAddress ());
631 
632   \textcolor{keywordflow}{if} (rtentry != 0)
633     \{
634       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Found unicast destination- calling unicast callback"});
635       ucb (idev, rtentry, \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header);  \textcolor{comment}{// unicast forwarding callback}
636       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
637     \}
638   \textcolor{keywordflow}{else}
639     \{
640       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Did not find unicast destination- returning false"});
641       \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \textcolor{comment}{// Let other routing protocols try to handle this}
642     \}
643 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 31


\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Route\+Output@{Route\+Output}}
\index{Route\+Output@{Route\+Output}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Route\+Output(\+Ptr$<$ Packet $>$ p, const Ipv6\+Header \&header, Ptr$<$ Net\+Device $>$ oif, Socket\+::\+Socket\+Errno \&sockerr)}{RouteOutput(Ptr< Packet > p, const Ipv6Header &header, Ptr< NetDevice > oif, Socket::SocketErrno &sockerr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv6\+Route} $>$ ns3\+::\+Ipv6\+Static\+Routing\+::\+Route\+Output (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv6\+Header} \&}]{header, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{oif, }
\item[{{\bf Socket\+::\+Socket\+Errno} \&}]{sockerr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6StaticRouting_a494b7a870cc1af31ba11611128a067a6}{}\label{classns3_1_1Ipv6StaticRouting_a494b7a870cc1af31ba11611128a067a6}


Query routing cache for an existing route, for an outbound packet. 

This lookup is used by transport protocols. It does not cause any packet to be forwarded, and is synchronous. Can be used for multicast or unicast. The Linux equivalent is ip\+\_\+route\+\_\+output ()


\begin{DoxyParams}{Parameters}
{\em p} & packet to be routed. Note that this method may modify the packet. Callers may also pass in a null pointer. \\
\hline
{\em header} & input parameter (used to form key to search for the route) \\
\hline
{\em oif} & Output interface device. May be zero, or may be bound via socket options to a particular output interface. \\
\hline
{\em sockerr} & Output parameter; socket errno\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a code that indicates what happened in the lookup 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv6RoutingProtocol_a92e79a0364ad272392ee635ffe50644d}{ns3\+::\+Ipv6\+Routing\+Protocol}.


\begin{DoxyCode}
558 \{
559   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << header << oif);
560   Ipv6Address destination = header.GetDestinationAddress ();
561   Ptr<Ipv6Route> rtentry = 0;
562 
563   \textcolor{keywordflow}{if} (destination.IsMulticast ())
564     \{
565       \textcolor{comment}{// Note:  Multicast routes for outbound packets are stored in the}
566       \textcolor{comment}{// normal unicast table.  An implication of this is that it is not}
567       \textcolor{comment}{// possible to source multicast datagrams on multiple interfaces.}
568       \textcolor{comment}{// This is a well-known property of sockets implementation on}
569       \textcolor{comment}{// many Unix variants.}
570       \textcolor{comment}{// So, we just log it and fall through to LookupStatic ()}
571       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"RouteOutput ()::Multicast destination"});
572     \}
573 
574   rtentry = \hyperlink{classns3_1_1Ipv6StaticRouting_a53cafb0907cefabca6894c9d4dc6c154}{LookupStatic} (destination, oif);
575   \textcolor{keywordflow}{if} (rtentry)
576     \{
577       sockerr = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaaa7eb006d73c5ad0117c5591fcb3469f7}{Socket::ERROR\_NOTERROR};
578     \}
579   \textcolor{keywordflow}{else}
580     \{
581       sockerr = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{Socket::ERROR\_NOROUTETOHOST};
582     \}
583   \textcolor{keywordflow}{return} rtentry;
584 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 32


\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Set\+Default\+Multicast\+Route@{Set\+Default\+Multicast\+Route}}
\index{Set\+Default\+Multicast\+Route@{Set\+Default\+Multicast\+Route}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Set\+Default\+Multicast\+Route(uint32\+\_\+t output\+Interface)}{SetDefaultMulticastRoute(uint32_t outputInterface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Static\+Routing\+::\+Set\+Default\+Multicast\+Route (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{output\+Interface}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6StaticRouting_ac936677e5f3d35e154d7a1f13dd9b7e0}{}\label{classns3_1_1Ipv6StaticRouting_ac936677e5f3d35e154d7a1f13dd9b7e0}


Set the default multicast route. 


\begin{DoxyParams}{Parameters}
{\em output\+Interface} & default output interface \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
193 \{
194   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << outputInterface);
195   Ipv6RoutingTableEntry *route = \textcolor{keyword}{new} Ipv6RoutingTableEntry ();
196   Ipv6Address network = Ipv6Address (\textcolor{stringliteral}{"ff00::"}); \textcolor{comment}{/* RFC 3513 */}
197   Ipv6Prefix networkMask = Ipv6Prefix (8);
198   *route = \hyperlink{classns3_1_1Ipv6RoutingTableEntry_aba706b8378ac6a5ad281f773125175d9}{Ipv6RoutingTableEntry::CreateNetworkRouteTo} (network,
       networkMask, outputInterface);
199   \hyperlink{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{m\_networkRoutes}.push\_back (std::make\_pair (route, 0));
200 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 33


\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Set\+Default\+Route@{Set\+Default\+Route}}
\index{Set\+Default\+Route@{Set\+Default\+Route}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Set\+Default\+Route(\+Ipv6\+Address next\+Hop, uint32\+\_\+t interface, Ipv6\+Address prefix\+To\+Use=\+Ipv6\+Address(""\+::""), uint32\+\_\+t metric=0)}{SetDefaultRoute(Ipv6Address nextHop, uint32_t interface, Ipv6Address prefixToUse=Ipv6Address("::"), uint32_t metric=0)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Static\+Routing\+::\+Set\+Default\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{next\+Hop, }
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv6\+Address}}]{prefix\+To\+Use = {\ttfamily {\bf Ipv6\+Address}~(\char`\"{}\+:\+:\char`\"{})}, }
\item[{uint32\+\_\+t}]{metric = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6StaticRouting_af80ab0c9c95ea4bbc004bda7ce1cae06}{}\label{classns3_1_1Ipv6StaticRouting_af80ab0c9c95ea4bbc004bda7ce1cae06}


Set the default route. 


\begin{DoxyParams}{Parameters}
{\em next\+Hop} & next hop address to route the packet \\
\hline
{\em interface} & interface index \\
\hline
{\em prefix\+To\+Use} & prefix to use (i.\+e for multihoming) \\
\hline
{\em metric} & metric of route in case of multiple routes to same destination \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
179 \{
180   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << nextHop << interface << prefixToUse);
181   \hyperlink{classns3_1_1Ipv6StaticRouting_ac0c0c9d8e3182295c1cdb4a3d612a2d3}{AddNetworkRouteTo} (Ipv6Address (\textcolor{stringliteral}{"::"}), \hyperlink{classns3_1_1Ipv6Prefix_ab32d2dbadcd8fa048ff296cb0a0e34ff}{Ipv6Prefix::GetZero} (), 
      nextHop, interface, prefixToUse, metric);
182 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 34




Here is the caller graph for this function\+:
% FIG 35


\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!Set\+Ipv6@{Set\+Ipv6}}
\index{Set\+Ipv6@{Set\+Ipv6}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{Set\+Ipv6(\+Ptr$<$ Ipv6 $>$ ipv6)}{SetIpv6(Ptr< Ipv6 > ipv6)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Static\+Routing\+::\+Set\+Ipv6 (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv6} $>$}]{ipv6}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6StaticRouting_a05569b3f3a6042a7e12a50fe88ee11e7}{}\label{classns3_1_1Ipv6StaticRouting_a05569b3f3a6042a7e12a50fe88ee11e7}


Typically, invoked directly or indirectly from \hyperlink{classns3_1_1Ipv6_aa889d2174527a1df773d65974de83f8f}{ns3\+::\+Ipv6\+::\+Set\+Routing\+Protocol}. 


\begin{DoxyParams}{Parameters}
{\em ipv6} & the ipv6 object this routing protocol is being associated with \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6RoutingProtocol_ab97e8194b12a2db1d1374fc881974903}{ns3\+::\+Ipv6\+Routing\+Protocol}.


\begin{DoxyCode}
61 \{
62   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << ipv6);
63   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6} == 0 && ipv6 != 0);
64   uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0;
65   \hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6} = ipv6;
66 
67   \textcolor{keywordflow}{for} (i = 0; i < \hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6}->GetNInterfaces (); i++)
68     \{
69       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{m\_ipv6}->IsUp (i))
70         \{
71           \hyperlink{classns3_1_1Ipv6StaticRouting_a9750930029ffe2eaafda77ba77918472}{NotifyInterfaceUp} (i);
72         \}
73       \textcolor{keywordflow}{else}
74         \{
75           \hyperlink{classns3_1_1Ipv6StaticRouting_a1e917452e99ee697b9ffd5acebfc0a02}{NotifyInterfaceDown} (i);
76         \}
77     \}
78 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 36




\subsection{Member Data Documentation}
\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!m\+\_\+ipv6@{m\+\_\+ipv6}}
\index{m\+\_\+ipv6@{m\+\_\+ipv6}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+ipv6}{m_ipv6}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Ipv6}$>$ ns3\+::\+Ipv6\+Static\+Routing\+::m\+\_\+ipv6\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}{}\label{classns3_1_1Ipv6StaticRouting_aeb0293ac3549a6ca0ba7674d35646fc8}


\hyperlink{classns3_1_1Ipv6}{Ipv6} reference. 

\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!m\+\_\+multicast\+Routes@{m\+\_\+multicast\+Routes}}
\index{m\+\_\+multicast\+Routes@{m\+\_\+multicast\+Routes}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+multicast\+Routes}{m_multicastRoutes}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Multicast\+Routes} ns3\+::\+Ipv6\+Static\+Routing\+::m\+\_\+multicast\+Routes\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6StaticRouting_ab9690b202d45d5567be46567a4f782ac}{}\label{classns3_1_1Ipv6StaticRouting_ab9690b202d45d5567be46567a4f782ac}


the forwarding table for multicast. 

\index{ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}!m\+\_\+network\+Routes@{m\+\_\+network\+Routes}}
\index{m\+\_\+network\+Routes@{m\+\_\+network\+Routes}!ns3\+::\+Ipv6\+Static\+Routing@{ns3\+::\+Ipv6\+Static\+Routing}}
\subsubsection[{\texorpdfstring{m\+\_\+network\+Routes}{m_networkRoutes}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Network\+Routes} ns3\+::\+Ipv6\+Static\+Routing\+::m\+\_\+network\+Routes\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}{}\label{classns3_1_1Ipv6StaticRouting_ac6d146555b173ef5ca8028ab981f8ab6}


the forwarding table for network. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/model/\hyperlink{ipv6-static-routing_8h}{ipv6-\/static-\/routing.\+h}\item 
internet/model/\hyperlink{ipv6-static-routing_8cc}{ipv6-\/static-\/routing.\+cc}\end{DoxyCompactItemize}
