\hypertarget{classns3_1_1Ipv6AddressHelper}{}\section{ns3\+:\+:Ipv6\+Address\+Helper Class Reference}
\label{classns3_1_1Ipv6AddressHelper}\index{ns3\+::\+Ipv6\+Address\+Helper@{ns3\+::\+Ipv6\+Address\+Helper}}


Helper class to auto-\/assign global I\+Pv6 unicast addresses.  




{\ttfamily \#include $<$ipv6-\/address-\/helper.\+h$>$}



Collaboration diagram for ns3\+:\+:Ipv6\+Address\+Helper\+:
% FIG 0
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ipv6AddressHelper_ab79957dab80a7bb1f0e294832c1d2e0e}{Ipv6\+Address\+Helper} ()
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6AddressHelper_aa1e2f0d4055cd9be0573e54f3526bc43}{Ipv6\+Address\+Helper} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} network, \hyperlink{classns3_1_1Ipv6Prefix}{Ipv6\+Prefix} prefix, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} base=\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address}(\char`\"{}\+::1\char`\"{}))
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6AddressHelper_a13467412e9da6263395c09460681c0f1}{Set\+Base} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} network, \hyperlink{classns3_1_1Ipv6Prefix}{Ipv6\+Prefix} prefix, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} base=\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address}(\char`\"{}\+::1\char`\"{}))
\begin{DoxyCompactList}\small\item\em Set the base network number, network prefix, and base interface ID. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6AddressHelper_a7c9da1dcff52973a901dcb5c69b8c026}{New\+Network} (void)
\begin{DoxyCompactList}\small\item\em Allocate a new network. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} \hyperlink{classns3_1_1Ipv6AddressHelper_a0f9499d21947758623cf17615e3dbc84}{New\+Address} (\hyperlink{classns3_1_1Address}{Address} addr)
\begin{DoxyCompactList}\small\item\em Allocate a new \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address}. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} \hyperlink{classns3_1_1Ipv6AddressHelper_a5f3df4b8e9d41e4241f2334381c2c883}{New\+Address} (void)
\begin{DoxyCompactList}\small\item\em Allocate a new \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} with interface ID equal to the next one in the underlying generator. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6InterfaceContainer}{Ipv6\+Interface\+Container} \hyperlink{classns3_1_1Ipv6AddressHelper_aad4685588aea1757beaf881bc4157912}{Assign} (const \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} \&\hyperlink{mmwave_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c})
\begin{DoxyCompactList}\small\item\em Allocate an \hyperlink{classns3_1_1Ipv6InterfaceContainer}{Ipv6\+Interface\+Container} with auto-\/assigned addresses. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6InterfaceContainer}{Ipv6\+Interface\+Container} \hyperlink{classns3_1_1Ipv6AddressHelper_affe0fdb270fe27b8cf71ce87141c9ba8}{Assign} (const \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} \&\hyperlink{mmwave_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c}, std\+::vector$<$ bool $>$ with\+Configuration)
\begin{DoxyCompactList}\small\item\em Allocate an \hyperlink{classns3_1_1Ipv6InterfaceContainer}{Ipv6\+Interface\+Container}, and control whether the interfaces have addresses auto-\/assigned to them. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6InterfaceContainer}{Ipv6\+Interface\+Container} \hyperlink{classns3_1_1Ipv6AddressHelper_a11d807b801198006c7be96bac61d44ac}{Assign\+Without\+Address} (const \hyperlink{classns3_1_1NetDeviceContainer}{Net\+Device\+Container} \&\hyperlink{mmwave_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c})
\begin{DoxyCompactList}\small\item\em Allocate an \hyperlink{classns3_1_1Ipv6InterfaceContainer}{Ipv6\+Interface\+Container} but do not assign any I\+Pv6 addresses. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Helper class to auto-\/assign global I\+Pv6 unicast addresses. 

Assign global unicast I\+Pv6 addresses based on \{4291\} definition.

$\vert$ n bits $\vert$ 64-\/n bits $\vert$ 64 bits $\vert$ +-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/---+-\/-\/-\/-\/-\/-\/-\/-\/---+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/---+ $\vert$ global routing prefix $\vert$ subnet ID $\vert$ interface ID $\vert$ +-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/---+-\/-\/-\/-\/-\/-\/-\/-\/---+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/---+ $<$-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/---network-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/---$>$

11111111111111111111111111000000000000 $<$---prefix of length n---$>$

This class handles the following quantities. 1) The \char`\"{}network\char`\"{} which covers the 64 bit union of the global routing prefix and the subnet ID 2) the \char`\"{}prefix\char`\"{} length \char`\"{}n\char`\"{} which demarcates the global routing prefix and the subnet ID 3) the \char`\"{}base\char`\"{} which is the initial 64-\/bit interface ID.

The names \char`\"{}network\char`\"{}, \char`\"{}prefix\char`\"{} and \char`\"{}base\char`\"{} are chosen to be consistent with a similar address helper for I\+Pv4.

This helper class allows users to set or reset the network and interface components, and call \char`\"{}\+New\+Address ()\char`\"{} to sequentially increment the interface ID, and call \char`\"{}\+New\+Network ()\char`\"{} to allocate a new subnet (until the subnet ID quantity rolls over). A call to New\+Network () that causes the subnet ID to roll over will trigger an assertion.

By default, the prefix is 32 bits and the network is \textquotesingle{}2001\+:db8\+:\+:/32\textquotesingle{} (\{5156\} section 2.\+6 Documentation prefix). The prefix may range from length 0 to 64, with the value 64 having a special meaning that no subnet ID boundary is enforced (equivalent to value 0).

There are two variants of interface ID supported (\{4291\}, Sec. 2.\+5.\+1) The default is a \char`\"{}local\char`\"{} scope, but a \char`\"{}universal\char`\"{} scoped ID may be formed by calling \char`\"{}\+New\+Address (\+Address addr)\char`\"{} with a 48-\/bit M\+AC address. If this method is called, the addressed returned will include a modified E\+U\+I-\/64-\/format identifier created from the M\+AC address as specified in \{4291\}.

B\+E\+W\+A\+RE\+: the underlying implementation acts as a \hyperlink{classns3_1_1Singleton}{Singleton}. In other terms, two different instances of \hyperlink{classns3_1_1Ipv6AddressHelper}{Ipv6\+Address\+Helper} will pick I\+Pv6 numbers from the same pool. Changing the network in one of them will also change the network in the other instances. 

\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Ipv6\+Address\+Helper@{ns3\+::\+Ipv6\+Address\+Helper}!Ipv6\+Address\+Helper@{Ipv6\+Address\+Helper}}
\index{Ipv6\+Address\+Helper@{Ipv6\+Address\+Helper}!ns3\+::\+Ipv6\+Address\+Helper@{ns3\+::\+Ipv6\+Address\+Helper}}
\subsubsection[{\texorpdfstring{Ipv6\+Address\+Helper()}{Ipv6AddressHelper()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv6\+Address\+Helper\+::\+Ipv6\+Address\+Helper (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6AddressHelper_ab79957dab80a7bb1f0e294832c1d2e0e}{}\label{classns3_1_1Ipv6AddressHelper_ab79957dab80a7bb1f0e294832c1d2e0e}


Constructor. 


\begin{DoxyCode}
43 \{
44   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
45   \hyperlink{classns3_1_1Ipv6AddressGenerator_a010449feb2e0aa103dd93abb44b6f423}{Ipv6AddressGenerator::Init} (Ipv6Address (\textcolor{stringliteral}{"2001:db8::"}), Ipv6Prefix (64));
46 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 1


\index{ns3\+::\+Ipv6\+Address\+Helper@{ns3\+::\+Ipv6\+Address\+Helper}!Ipv6\+Address\+Helper@{Ipv6\+Address\+Helper}}
\index{Ipv6\+Address\+Helper@{Ipv6\+Address\+Helper}!ns3\+::\+Ipv6\+Address\+Helper@{ns3\+::\+Ipv6\+Address\+Helper}}
\subsubsection[{\texorpdfstring{Ipv6\+Address\+Helper(\+Ipv6\+Address network, Ipv6\+Prefix prefix, Ipv6\+Address base=\+Ipv6\+Address(""\+::1""))}{Ipv6AddressHelper(Ipv6Address network, Ipv6Prefix prefix, Ipv6Address base=Ipv6Address("::1"))}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv6\+Address\+Helper\+::\+Ipv6\+Address\+Helper (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{network, }
\item[{{\bf Ipv6\+Prefix}}]{prefix, }
\item[{{\bf Ipv6\+Address}}]{base = {\ttfamily {\bf Ipv6\+Address}~(\char`\"{}\+:\+:1\char`\"{})}}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6AddressHelper_aa1e2f0d4055cd9be0573e54f3526bc43}{}\label{classns3_1_1Ipv6AddressHelper_aa1e2f0d4055cd9be0573e54f3526bc43}


Constructor. 


\begin{DoxyParams}{Parameters}
{\em network} & The I\+Pv6 network \\
\hline
{\em prefix} & The prefix \\
\hline
{\em base} & The base interface ID \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
50 \{
51   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << network << prefix << base);
52   \hyperlink{classns3_1_1Ipv6AddressGenerator_a010449feb2e0aa103dd93abb44b6f423}{Ipv6AddressGenerator::Init} (network, prefix, base);
53 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2




\subsection{Member Function Documentation}
\index{ns3\+::\+Ipv6\+Address\+Helper@{ns3\+::\+Ipv6\+Address\+Helper}!Assign@{Assign}}
\index{Assign@{Assign}!ns3\+::\+Ipv6\+Address\+Helper@{ns3\+::\+Ipv6\+Address\+Helper}}
\subsubsection[{\texorpdfstring{Assign(const Net\+Device\+Container \&c)}{Assign(const NetDeviceContainer &c)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+Interface\+Container} ns3\+::\+Ipv6\+Address\+Helper\+::\+Assign (
\begin{DoxyParamCaption}
\item[{const {\bf Net\+Device\+Container} \&}]{c}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6AddressHelper_aad4685588aea1757beaf881bc4157912}{}\label{classns3_1_1Ipv6AddressHelper_aad4685588aea1757beaf881bc4157912}


Allocate an \hyperlink{classns3_1_1Ipv6InterfaceContainer}{Ipv6\+Interface\+Container} with auto-\/assigned addresses. 


\begin{DoxyParams}{Parameters}
{\em c} & netdevice container \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
newly created \hyperlink{classns3_1_1Ipv6InterfaceContainer}{Ipv6\+Interface\+Container} 
\end{DoxyReturn}

\begin{DoxyCode}
117 \{
118   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
119   Ipv6InterfaceContainer retval;
120 
121   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c}.GetN (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) 
122     \{
123       Ptr<NetDevice> device = \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c}.Get (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
124 
125       Ptr<Node> node = device->GetNode ();
126       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (node, \textcolor{stringliteral}{"Ipv6AddressHelper::Allocate (): Bad node"});
127 
128       Ptr<Ipv6> ipv6 = node->GetObject<Ipv6> ();
129       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (ipv6, \textcolor{stringliteral}{"Ipv6AddressHelper::Allocate (): Bad ipv6"});
130       int32\_t ifIndex = 0;
131 
132       ifIndex = ipv6->GetInterfaceForDevice (device);
133       \textcolor{keywordflow}{if} (ifIndex == -1)
134         \{
135           ifIndex = ipv6->AddInterface (device);
136         \}
137       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (ifIndex >= 0, \textcolor{stringliteral}{"Ipv6AddressHelper::Allocate (): "}
138                      \textcolor{stringliteral}{"Interface index not found"});
139 
140       Ipv6InterfaceAddress ipv6Addr = Ipv6InterfaceAddress (\hyperlink{classns3_1_1Ipv6AddressHelper_a5f3df4b8e9d41e4241f2334381c2c883}{NewAddress} (device->GetAddress ()), 
      Ipv6Prefix (64));
141       ipv6->SetMetric (ifIndex, 1);
142       ipv6->AddAddress (ifIndex, ipv6Addr);
143       ipv6->SetUp (ifIndex);
144 
145       retval.Add (ipv6, ifIndex);
146 
147       \textcolor{comment}{// Install the default traffic control configuration if the traffic}
148       \textcolor{comment}{// control layer has been aggregated, if this is not}
149       \textcolor{comment}{// a loopback interface, and there is no queue disc installed already}
150       Ptr<TrafficControlLayer> tc = node->GetObject<TrafficControlLayer> ();
151       \textcolor{keywordflow}{if} (tc && DynamicCast<LoopbackNetDevice> (device) == 0 && tc->GetRootQueueDiscOnDevice (device) == 0)
152         \{
153           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Installing default traffic control configuration"});
154           TrafficControlHelper tcHelper = \hyperlink{classns3_1_1TrafficControlHelper_afa16cd2a1209beb1c18fa5e8153ba8b8}{TrafficControlHelper::Default} ();
155           tcHelper.Install (device);
156         \}
157     \}
158   \textcolor{keywordflow}{return} retval;
159 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3




Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::\+Ipv6\+Address\+Helper@{ns3\+::\+Ipv6\+Address\+Helper}!Assign@{Assign}}
\index{Assign@{Assign}!ns3\+::\+Ipv6\+Address\+Helper@{ns3\+::\+Ipv6\+Address\+Helper}}
\subsubsection[{\texorpdfstring{Assign(const Net\+Device\+Container \&c, std\+::vector$<$ bool $>$ with\+Configuration)}{Assign(const NetDeviceContainer &c, std::vector< bool > withConfiguration)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+Interface\+Container} ns3\+::\+Ipv6\+Address\+Helper\+::\+Assign (
\begin{DoxyParamCaption}
\item[{const {\bf Net\+Device\+Container} \&}]{c, }
\item[{std\+::vector$<$ bool $>$}]{with\+Configuration}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6AddressHelper_affe0fdb270fe27b8cf71ce87141c9ba8}{}\label{classns3_1_1Ipv6AddressHelper_affe0fdb270fe27b8cf71ce87141c9ba8}


Allocate an \hyperlink{classns3_1_1Ipv6InterfaceContainer}{Ipv6\+Interface\+Container}, and control whether the interfaces have addresses auto-\/assigned to them. 


\begin{DoxyParams}{Parameters}
{\em c} & netdevice container \\
\hline
{\em with\+Configuration} & a vector of values for which, for a given device, true \+: interface automatically addressed, false \+: no automatic address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
newly created \hyperlink{classns3_1_1Ipv6InterfaceContainer}{Ipv6\+Interface\+Container} 
\end{DoxyReturn}

\begin{DoxyCode}
162 \{
163   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
164   Ipv6InterfaceContainer retval;
165   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c}.GetN (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) 
166     \{
167       Ptr<NetDevice> device = \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c}.Get (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
168 
169       Ptr<Node> node = device->GetNode ();
170       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (node, \textcolor{stringliteral}{"Ipv6AddressHelper::Allocate (): Bad node"});
171 
172       Ptr<Ipv6> ipv6 = node->GetObject<Ipv6> ();
173       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (ipv6, \textcolor{stringliteral}{"Ipv6AddressHelper::Allocate (): Bad ipv6"});
174 
175       int32\_t ifIndex = ipv6->GetInterfaceForDevice (device);
176       \textcolor{keywordflow}{if} (ifIndex == -1)
177         \{
178           ifIndex = ipv6->AddInterface (device);
179         \}
180       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (ifIndex >= 0, \textcolor{stringliteral}{"Ipv6AddressHelper::Allocate (): "}
181                      \textcolor{stringliteral}{"Interface index not found"});
182 
183       ipv6->SetMetric (ifIndex, 1);
184 
185       \textcolor{keywordflow}{if} (withConfiguration.at (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}))
186         \{
187           Ipv6InterfaceAddress ipv6Addr = Ipv6InterfaceAddress (\hyperlink{classns3_1_1Ipv6AddressHelper_a5f3df4b8e9d41e4241f2334381c2c883}{NewAddress} (device->GetAddress ()
      ), Ipv6Prefix (64));
188           ipv6->AddAddress (ifIndex, ipv6Addr);
189         \}
190 
191       ipv6->SetUp (ifIndex);
192       retval.Add (ipv6, ifIndex);
193 
194       \textcolor{comment}{// Install the default traffic control configuration if the traffic}
195       \textcolor{comment}{// control layer has been aggregated, if this is not}
196       \textcolor{comment}{// a loopback interface, and there is no queue disc installed already}
197       Ptr<TrafficControlLayer> tc = node->GetObject<TrafficControlLayer> ();
198       \textcolor{keywordflow}{if} (tc && DynamicCast<LoopbackNetDevice> (device) == 0 && tc->GetRootQueueDiscOnDevice (device) == 0)
199         \{
200           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Installing default traffic control configuration"});
201           TrafficControlHelper tcHelper = \hyperlink{classns3_1_1TrafficControlHelper_afa16cd2a1209beb1c18fa5e8153ba8b8}{TrafficControlHelper::Default} ();
202           tcHelper.Install (device);
203         \}
204     \}
205   \textcolor{keywordflow}{return} retval;
206 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5


\index{ns3\+::\+Ipv6\+Address\+Helper@{ns3\+::\+Ipv6\+Address\+Helper}!Assign\+Without\+Address@{Assign\+Without\+Address}}
\index{Assign\+Without\+Address@{Assign\+Without\+Address}!ns3\+::\+Ipv6\+Address\+Helper@{ns3\+::\+Ipv6\+Address\+Helper}}
\subsubsection[{\texorpdfstring{Assign\+Without\+Address(const Net\+Device\+Container \&c)}{AssignWithoutAddress(const NetDeviceContainer &c)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+Interface\+Container} ns3\+::\+Ipv6\+Address\+Helper\+::\+Assign\+Without\+Address (
\begin{DoxyParamCaption}
\item[{const {\bf Net\+Device\+Container} \&}]{c}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6AddressHelper_a11d807b801198006c7be96bac61d44ac}{}\label{classns3_1_1Ipv6AddressHelper_a11d807b801198006c7be96bac61d44ac}


Allocate an \hyperlink{classns3_1_1Ipv6InterfaceContainer}{Ipv6\+Interface\+Container} but do not assign any I\+Pv6 addresses. 

This method is used when I\+Pv6 address assignment may occur later (such as dynamic address assignment)

Equivalent to Assign\+Without\+Address (c, std\+::vector$<$bool$>$ of false);


\begin{DoxyParams}{Parameters}
{\em c} & netdevice container \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
newly created \hyperlink{classns3_1_1Ipv6InterfaceContainer}{Ipv6\+Interface\+Container} 
\end{DoxyReturn}

\begin{DoxyCode}
210 \{
211   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
212   std::vector<bool> withConfiguration;
213   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c}.GetN (); ++\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) 
214     \{
215       withConfiguration.push\_back (\textcolor{keyword}{false});
216     \}
217   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv6AddressHelper_aad4685588aea1757beaf881bc4157912}{Assign} (\hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_ae0323a9039add2978bf5b49550572c7c}{c}, withConfiguration);
218 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6




Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Ipv6\+Address\+Helper@{ns3\+::\+Ipv6\+Address\+Helper}!New\+Address@{New\+Address}}
\index{New\+Address@{New\+Address}!ns3\+::\+Ipv6\+Address\+Helper@{ns3\+::\+Ipv6\+Address\+Helper}}
\subsubsection[{\texorpdfstring{New\+Address(\+Address addr)}{NewAddress(Address addr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+Address} ns3\+::\+Ipv6\+Address\+Helper\+::\+New\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Address}}]{addr}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6AddressHelper_a0f9499d21947758623cf17615e3dbc84}{}\label{classns3_1_1Ipv6AddressHelper_a0f9499d21947758623cf17615e3dbc84}


Allocate a new \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address}. 

If a \hyperlink{classns3_1_1Mac48Address}{Mac48\+Address} is passed in, an \hyperlink{classns3_1_1Ipv6}{Ipv6} autoconfigured address according to the current subnet prefix is returned. If something other than Mac48 address is passed in, the program will terminate.


\begin{DoxyParams}{Parameters}
{\em addr} & address used to generate the interface ID of the I\+Pv6 address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
newly created \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} 
\end{DoxyReturn}

\begin{DoxyCode}
66 \{
67   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << addr);
68   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Mac64Address_a50014d1350f72b89857f0262be927073}{Mac64Address::IsMatchingType} (addr))
69     \{
70       Ipv6Address network = \hyperlink{classns3_1_1Ipv6AddressGenerator_a3d153f59d37c8012186db6a18db5681c}{Ipv6AddressGenerator::GetNetwork} (Ipv6Prefix (6
      4));
71       Ipv6Address address = \hyperlink{classns3_1_1Ipv6Address_a74e6a79f61e9edd0ebdbafb4db88dc35}{Ipv6Address::MakeAutoconfiguredAddress} (
      \hyperlink{classns3_1_1Mac64Address_a9d73aef28cf6b6edf423b418ce014b10}{Mac64Address::ConvertFrom} (addr), network);
72       \hyperlink{classns3_1_1Ipv6AddressGenerator_a906de97d82d4e6898eb8d019bc81077f}{Ipv6AddressGenerator::AddAllocated} (address);
73       \textcolor{keywordflow}{return} address;
74     \}
75   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Mac48Address_a55cc1e3c6aa63fd1a4f8f7d9be4ae182}{Mac48Address::IsMatchingType} (addr))
76     \{
77       Ipv6Address network = \hyperlink{classns3_1_1Ipv6AddressGenerator_a3d153f59d37c8012186db6a18db5681c}{Ipv6AddressGenerator::GetNetwork} (Ipv6Prefix (6
      4));
78       Ipv6Address address = \hyperlink{classns3_1_1Ipv6Address_a74e6a79f61e9edd0ebdbafb4db88dc35}{Ipv6Address::MakeAutoconfiguredAddress} (
      \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (addr), network);
79       \hyperlink{classns3_1_1Ipv6AddressGenerator_a906de97d82d4e6898eb8d019bc81077f}{Ipv6AddressGenerator::AddAllocated} (address);
80       \textcolor{keywordflow}{return} address;
81     \}
82   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Mac16Address_a2d7aa9e24afc8e02a25ab449b0b99b1f}{Mac16Address::IsMatchingType} (addr))
83     \{
84       Ipv6Address network = \hyperlink{classns3_1_1Ipv6AddressGenerator_a3d153f59d37c8012186db6a18db5681c}{Ipv6AddressGenerator::GetNetwork} (Ipv6Prefix (6
      4));
85       Ipv6Address address = \hyperlink{classns3_1_1Ipv6Address_a74e6a79f61e9edd0ebdbafb4db88dc35}{Ipv6Address::MakeAutoconfiguredAddress} (
      \hyperlink{classns3_1_1Mac16Address_a6822cde696a7be24782dc8e1de2f1449}{Mac16Address::ConvertFrom} (addr), network);
86       \hyperlink{classns3_1_1Ipv6AddressGenerator_a906de97d82d4e6898eb8d019bc81077f}{Ipv6AddressGenerator::AddAllocated} (address);
87       \textcolor{keywordflow}{return} address;
88     \}
89   \textcolor{keywordflow}{else}
90     \{
91       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Did not pass in a valid Mac Address (16, 48 or 64 bits)"});
92     \}
93   \textcolor{comment}{/* never reached */}
94   \textcolor{keywordflow}{return} Ipv6Address (\textcolor{stringliteral}{"::"});
95 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8




Here is the caller graph for this function\+:
% FIG 9


\index{ns3\+::\+Ipv6\+Address\+Helper@{ns3\+::\+Ipv6\+Address\+Helper}!New\+Address@{New\+Address}}
\index{New\+Address@{New\+Address}!ns3\+::\+Ipv6\+Address\+Helper@{ns3\+::\+Ipv6\+Address\+Helper}}
\subsubsection[{\texorpdfstring{New\+Address(void)}{NewAddress(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+Address} ns3\+::\+Ipv6\+Address\+Helper\+::\+New\+Address (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6AddressHelper_a5f3df4b8e9d41e4241f2334381c2c883}{}\label{classns3_1_1Ipv6AddressHelper_a5f3df4b8e9d41e4241f2334381c2c883}


Allocate a new \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} with interface ID equal to the next one in the underlying generator. 

\begin{DoxyReturn}{Returns}
newly created \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} 
\end{DoxyReturn}

\begin{DoxyCode}
98 \{
99   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
100 \textcolor{comment}{//}
101 \textcolor{comment}{// The way this is expected to be used is that an address and network number}
102 \textcolor{comment}{// are initialized, and then NewAddress() is called repeatedly to allocate and}
103 \textcolor{comment}{// get new addresses on a given subnet.  The client will expect that the first}
104 \textcolor{comment}{// address she gets back is the one she used to initialize the generator with.}
105 \textcolor{comment}{// This implies that this operation is a post-increment.}
106 \textcolor{comment}{//}
107   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv6AddressGenerator_a1d470e21bf48dd0dc39fb3c12414218e}{Ipv6AddressGenerator::NextAddress} (Ipv6Prefix (64));
108 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10




Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::\+Ipv6\+Address\+Helper@{ns3\+::\+Ipv6\+Address\+Helper}!New\+Network@{New\+Network}}
\index{New\+Network@{New\+Network}!ns3\+::\+Ipv6\+Address\+Helper@{ns3\+::\+Ipv6\+Address\+Helper}}
\subsubsection[{\texorpdfstring{New\+Network(void)}{NewNetwork(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Address\+Helper\+::\+New\+Network (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6AddressHelper_a7c9da1dcff52973a901dcb5c69b8c026}{}\label{classns3_1_1Ipv6AddressHelper_a7c9da1dcff52973a901dcb5c69b8c026}


Allocate a new network. 

This method will cause the subnet prefix to increment, for future network I\+Ds, and resets the interface ID to the previously used base. 
\begin{DoxyCode}
111 \{
112   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
113   \hyperlink{classns3_1_1Ipv6AddressGenerator_ad3d156d50f45026dd896e121ae04d24b}{Ipv6AddressGenerator::NextNetwork} (Ipv6Prefix (64));
114 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12




Here is the caller graph for this function\+:
% FIG 13


\index{ns3\+::\+Ipv6\+Address\+Helper@{ns3\+::\+Ipv6\+Address\+Helper}!Set\+Base@{Set\+Base}}
\index{Set\+Base@{Set\+Base}!ns3\+::\+Ipv6\+Address\+Helper@{ns3\+::\+Ipv6\+Address\+Helper}}
\subsubsection[{\texorpdfstring{Set\+Base(\+Ipv6\+Address network, Ipv6\+Prefix prefix, Ipv6\+Address base=\+Ipv6\+Address(""\+::1""))}{SetBase(Ipv6Address network, Ipv6Prefix prefix, Ipv6Address base=Ipv6Address("::1"))}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+Address\+Helper\+::\+Set\+Base (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{network, }
\item[{{\bf Ipv6\+Prefix}}]{prefix, }
\item[{{\bf Ipv6\+Address}}]{base = {\ttfamily {\bf Ipv6\+Address}~(\char`\"{}\+:\+:1\char`\"{})}}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6AddressHelper_a13467412e9da6263395c09460681c0f1}{}\label{classns3_1_1Ipv6AddressHelper_a13467412e9da6263395c09460681c0f1}


Set the base network number, network prefix, and base interface ID. 


\begin{DoxyParams}{Parameters}
{\em network} & The I\+Pv6 network \\
\hline
{\em prefix} & The prefix \\
\hline
{\em base} & The base interface ID \\
\hline
\end{DoxyParams}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000035}{Todo}]for now we do not enforce the prefix because the underlying \hyperlink{classns3_1_1Ipv6AddressGenerator}{Ipv6\+Address\+Generator} does not handle prefixes well that are not 64 bits \end{DoxyRefDesc}

\begin{DoxyCode}
57 \{
58   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << network << prefix << base);
61   \hyperlink{classns3_1_1Ipv6AddressGenerator_a010449feb2e0aa103dd93abb44b6f423}{Ipv6AddressGenerator::Init} (network, Ipv6Prefix (64), base);
62 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 14




Here is the caller graph for this function\+:
% FIG 15




The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/helper/\hyperlink{ipv6-address-helper_8h}{ipv6-\/address-\/helper.\+h}\item 
internet/helper/\hyperlink{ipv6-address-helper_8cc}{ipv6-\/address-\/helper.\+cc}\end{DoxyCompactItemize}
