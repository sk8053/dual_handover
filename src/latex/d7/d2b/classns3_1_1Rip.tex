\hypertarget{classns3_1_1Rip}{}\section{ns3\+:\+:Rip Class Reference}
\label{classns3_1_1Rip}\index{ns3\+::\+Rip@{ns3\+::\+Rip}}


R\+IP Routing Protocol, defined in \{2453\}.  




{\ttfamily \#include $<$rip.\+h$>$}



Inheritance diagram for ns3\+:\+:Rip\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Rip\+:
% FIG 1
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classns3_1_1Rip_aa65e80d926399a90bc81b30dfc9404a4}{Split\+Horizon\+Type\+\_\+e} \{ \hyperlink{classns3_1_1Rip_aa65e80d926399a90bc81b30dfc9404a4a7444cea8e684dd1431a925f01eedfd03}{N\+O\+\_\+\+S\+P\+L\+I\+T\+\_\+\+H\+O\+R\+I\+Z\+ON}, 
\hyperlink{classns3_1_1Rip_aa65e80d926399a90bc81b30dfc9404a4a37e78b48a284b4248a999e281e8ea5f9}{S\+P\+L\+I\+T\+\_\+\+H\+O\+R\+I\+Z\+ON}, 
\hyperlink{classns3_1_1Rip_aa65e80d926399a90bc81b30dfc9404a4ad6573915007f19810b223a280519eb86}{P\+O\+I\+S\+O\+N\+\_\+\+R\+E\+V\+E\+R\+SE}
 \}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Rip_a2593bb8e6e858298059ac53ee265fe21}{Rip} ()
\item 
virtual \hyperlink{classns3_1_1Rip_a2f5e5b0f019eddaf2e38b64722552415}{$\sim$\+Rip} ()
\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ \hyperlink{classns3_1_1Rip_a56d1be040d276f54ea04d5adf7c9fce6}{Route\+Output} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ oif, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket\+::\+Socket\+Errno} \&sockerr)
\begin{DoxyCompactList}\small\item\em Query routing cache for an existing route, for an outbound packet. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Rip_a4575903d3368ff77e2cc0e97c75fc8f9}{Route\+Input} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ idev, \hyperlink{classns3_1_1Ipv4RoutingProtocol_a3453a85764cbbb1e704da7e919aa5d19}{Unicast\+Forward\+Callback} ucb, \hyperlink{classns3_1_1Ipv4RoutingProtocol_a26e76f7a555462e6c08fceda64a99d58}{Multicast\+Forward\+Callback} mcb, \hyperlink{classns3_1_1Ipv4RoutingProtocol_aa6ffa0159cb143daa3c46d2ba69bb1b9}{Local\+Deliver\+Callback} lcb, \hyperlink{classns3_1_1Ipv4RoutingProtocol_a0348285418c30d5021b08f7a68af21ea}{Error\+Callback} ecb)
\begin{DoxyCompactList}\small\item\em Route an input packet (to be forwarded or locally delivered) \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Rip_a4c9095a4429399f342eb1bce3f20df59}{Notify\+Interface\+Up} (uint32\+\_\+t interface)
\item 
virtual void \hyperlink{classns3_1_1Rip_a10fb1463467f08556e7a3e75c98447bc}{Notify\+Interface\+Down} (uint32\+\_\+t interface)
\item 
virtual void \hyperlink{classns3_1_1Rip_a9ef274a74f46abf3c118d935d33f02fe}{Notify\+Add\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} address)
\item 
virtual void \hyperlink{classns3_1_1Rip_a63c4ba062a5805aef7887d7dca5d1ff9}{Notify\+Remove\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv4InterfaceAddress}{Ipv4\+Interface\+Address} address)
\item 
virtual void \hyperlink{classns3_1_1Rip_abe2906af2196cf9fac033e6ccfde0423}{Set\+Ipv4} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$ ipv4)
\item 
virtual void \hyperlink{classns3_1_1Rip_ab1ac007cf3e796e4e7bc815c942a6ff5}{Print\+Routing\+Table} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1OutputStreamWrapper}{Output\+Stream\+Wrapper} $>$ stream, \hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295a}{Time\+::\+Unit} unit=\hyperlink{classns3_1_1Time_a87a7f4d29c68b047a72d291ad660295aade8622b06524a328cd3a59db6ccf76af}{Time\+::S}) const 
\begin{DoxyCompactList}\small\item\em Print the Routing Table entries. \end{DoxyCompactList}\item 
int64\+\_\+t \hyperlink{classns3_1_1Rip_a5fee03b012b2652b79e49b5f7fa3a0a9}{Assign\+Streams} (int64\+\_\+t stream)
\item 
std\+::set$<$ uint32\+\_\+t $>$ \hyperlink{classns3_1_1Rip_ac934d4c30c1fe7a5076cc25308bd7eb1}{Get\+Interface\+Exclusions} () const 
\begin{DoxyCompactList}\small\item\em Get the set of interface excluded from the protocol. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Rip_ae564ba0b6bc1cc0b1d678166ffe1ae71}{Set\+Interface\+Exclusions} (std\+::set$<$ uint32\+\_\+t $>$ exceptions)
\begin{DoxyCompactList}\small\item\em Set the set of interface excluded from the protocol. \end{DoxyCompactList}\item 
uint8\+\_\+t \hyperlink{classns3_1_1Rip_a6bff4d6e94d4ca9e3f276df0fb538b8f}{Get\+Interface\+Metric} (uint32\+\_\+t interface) const 
\begin{DoxyCompactList}\small\item\em Get the metric for an interface. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Rip_a068a04a9653f7b9295350aba52dc58a0}{Set\+Interface\+Metric} (uint32\+\_\+t interface, uint8\+\_\+t metric)
\begin{DoxyCompactList}\small\item\em Set the metric for an interface. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Rip_ae57b91bb372f7ab60d5519f32750af95}{Add\+Default\+Route\+To} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} next\+Hop, uint32\+\_\+t interface)
\begin{DoxyCompactList}\small\item\em Add a default route to the router through the next\+Hop located on interface. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1Rip_ace3389e07c4181ca5bc9c2ca5a4bab24}{Get\+Type\+Id} (void)
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1Rip_a4b7ea6fdc9d480f3ed80c3daeb946818}{Do\+Dispose} ()
\begin{DoxyCompactList}\small\item\em Dispose this object. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Rip_a622ec450ec78945f81986b64ce3dcbed}{Do\+Initialize} ()
\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ std\+::pair$<$ \hyperlink{classns3_1_1RipRoutingTableEntry}{Rip\+Routing\+Table\+Entry} $\ast$, \hyperlink{classns3_1_1EventId}{Event\+Id} $>$ $>$ \hyperlink{classns3_1_1Rip_a7108837a80349ce23ac60d043ac81d58}{Routes}
\begin{DoxyCompactList}\small\item\em Container for the network routes -\/ pair \hyperlink{classns3_1_1RipRoutingTableEntry}{Rip\+Routing\+Table\+Entry} $\ast$, \hyperlink{classns3_1_1EventId}{Event\+Id} (update event) \end{DoxyCompactList}\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ std\+::pair$<$ \hyperlink{classns3_1_1RipRoutingTableEntry}{Rip\+Routing\+Table\+Entry} $\ast$, \hyperlink{classns3_1_1EventId}{Event\+Id} $>$ $>$\+::const\+\_\+iterator \hyperlink{classns3_1_1Rip_a20080eb47fbc0ac67e3eba1c61cbafcb}{Routes\+CI}
\begin{DoxyCompactList}\small\item\em Const Iterator for container for the network routes. \end{DoxyCompactList}\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ std\+::pair$<$ \hyperlink{classns3_1_1RipRoutingTableEntry}{Rip\+Routing\+Table\+Entry} $\ast$, \hyperlink{classns3_1_1EventId}{Event\+Id} $>$ $>$\+::iterator \hyperlink{classns3_1_1Rip_a8819af4dd44f270b6b19be755b39bce8}{RoutesI}
\begin{DoxyCompactList}\small\item\em Iterator for container for the network routes. \end{DoxyCompactList}\item 
typedef std\+::map$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$, uint32\+\_\+t $>$ \hyperlink{classns3_1_1Rip_afc81050735dfff6d48facd8284f0954f}{Socket\+List}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Socket}{Socket} list type. \end{DoxyCompactList}\item 
typedef std\+::map$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$, uint32\+\_\+t $>$\+::iterator \hyperlink{classns3_1_1Rip_a0395b3977eeeb90190ccfa5758a3957f}{Socket\+ListI}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Socket}{Socket} list type iterator. \end{DoxyCompactList}\item 
typedef std\+::map$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$, uint32\+\_\+t $>$\+::const\+\_\+iterator \hyperlink{classns3_1_1Rip_a685ab5baf3f942d84aba0c3d4784035f}{Socket\+List\+CI}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Socket}{Socket} list type const iterator. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classns3_1_1Rip_a49acadfb3b533118276481a0d231406e}{Receive} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$ socket)
\begin{DoxyCompactList}\small\item\em Receive R\+IP packets. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Rip_a4094ed6c40c666f7567245eef2376fe9}{Handle\+Requests} (\hyperlink{classns3_1_1RipHeader}{Rip\+Header} hdr, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} sender\+Address, uint16\+\_\+t sender\+Port, uint32\+\_\+t incoming\+Interface, uint8\+\_\+t hop\+Limit)
\begin{DoxyCompactList}\small\item\em Handle R\+IP requests. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Rip_afb817ee04f919351a35b466ea6d75c56}{Handle\+Responses} (\hyperlink{classns3_1_1RipHeader}{Rip\+Header} hdr, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} sender\+Address, uint32\+\_\+t incoming\+Interface, uint8\+\_\+t hop\+Limit)
\begin{DoxyCompactList}\small\item\em Handle R\+IP responses. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} $>$ \hyperlink{classns3_1_1Rip_a50d486fb2eee757bb9f9d528d3828dab}{Lookup} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} dest, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$=0)
\begin{DoxyCompactList}\small\item\em Lookup in the forwarding table for destination. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Rip_a78791b61a720345a6d23e0d61e29002c}{Recv\+Unicast\+Rip} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$ socket)
\item 
void \hyperlink{classns3_1_1Rip_a4af37761c5e40fe5a5ddc0e61595d76d}{Recv\+Multicast\+Rip} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$ socket)
\item 
void \hyperlink{classns3_1_1Rip_a8aa9415f65e5fb8abaa6af5c93446231}{Add\+Network\+Route\+To} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} network, \hyperlink{classns3_1_1Ipv4Mask}{Ipv4\+Mask} network\+Prefix, \hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} next\+Hop, uint32\+\_\+t interface)
\begin{DoxyCompactList}\small\item\em Add route to network. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Rip_af107d4ee9156d769b699ba6939806025}{Add\+Network\+Route\+To} (\hyperlink{classns3_1_1Ipv4Address}{Ipv4\+Address} network, \hyperlink{classns3_1_1Ipv4Mask}{Ipv4\+Mask} network\+Prefix, uint32\+\_\+t interface)
\begin{DoxyCompactList}\small\item\em Add route to network. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Rip_a106f73869862c38c070faec379542e05}{Do\+Send\+Route\+Update} (bool periodic)
\begin{DoxyCompactList}\small\item\em Send Routing Updates on all interfaces. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Rip_a84c90e335d9b833b26f1a8e8e7fc2243}{Send\+Route\+Request} ()
\begin{DoxyCompactList}\small\item\em Send Routing Request on all interfaces. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Rip_aee5d3efe6b4dbcd128018f49b981fd7c}{Send\+Triggered\+Route\+Update} ()
\begin{DoxyCompactList}\small\item\em Send Triggered Routing Updates on all interfaces. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Rip_aea59ff20475f09e1783bc37d5a8531c0}{Send\+Unsolicited\+Route\+Update} (void)
\begin{DoxyCompactList}\small\item\em Send Unsolicited Routing Updates on all interfaces. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Rip_a48b295877e349360bf978c250ae59083}{Invalidate\+Route} (\hyperlink{classns3_1_1RipRoutingTableEntry}{Rip\+Routing\+Table\+Entry} $\ast$route)
\begin{DoxyCompactList}\small\item\em Invalidate a route. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Rip_a4613413ac628e8313c26d5ea6ed99761}{Delete\+Route} (\hyperlink{classns3_1_1RipRoutingTableEntry}{Rip\+Routing\+Table\+Entry} $\ast$route)
\begin{DoxyCompactList}\small\item\em Delete a route. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Rip_a7108837a80349ce23ac60d043ac81d58}{Routes} \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\+\_\+routes}
\begin{DoxyCompactList}\small\item\em the forwarding table for network. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4}{Ipv4} $>$ \hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\+\_\+ipv4}
\begin{DoxyCompactList}\small\item\em I\+Pv4 reference. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1Rip_a26dfd4f6ce345b6259733027a77fbcc9}{m\+\_\+startup\+Delay}
\begin{DoxyCompactList}\small\item\em Random delay before protocol startup. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1Rip_a9345ff42e947fb0edb2382d6c4f50bd0}{m\+\_\+min\+Triggered\+Update\+Delay}
\begin{DoxyCompactList}\small\item\em Min cooldown delay after a Triggered Update. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1Rip_aed7be1d33584f7d7f8b2ca68bfbf3a06}{m\+\_\+max\+Triggered\+Update\+Delay}
\begin{DoxyCompactList}\small\item\em Max cooldown delay after a Triggered Update. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1Rip_aabc5098465aa38f416c5daa7561d3ea0}{m\+\_\+unsolicited\+Update}
\begin{DoxyCompactList}\small\item\em time between two Unsolicited Routing Updates \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1Rip_a8a684a47271e0e382dd5f485a8a5545b}{m\+\_\+timeout\+Delay}
\begin{DoxyCompactList}\small\item\em Delay before invalidating a route. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1Rip_ad317e92ae9d78b20642be47df4e8d866}{m\+\_\+garbage\+Collection\+Delay}
\begin{DoxyCompactList}\small\item\em Delay before deleting an I\+N\+V\+A\+L\+ID route. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Rip_afc81050735dfff6d48facd8284f0954f}{Socket\+List} \hyperlink{classns3_1_1Rip_a58b5f6ebcee2ed04249fd025abfa61cb}{m\+\_\+send\+Socket\+List}
\begin{DoxyCompactList}\small\item\em list of sockets for sending (socket, interface index) \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$ \hyperlink{classns3_1_1Rip_a6c5dc1b74475e3caa0782f37b722be6b}{m\+\_\+recv\+Socket}
\begin{DoxyCompactList}\small\item\em receive socket \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1EventId}{Event\+Id} \hyperlink{classns3_1_1Rip_a52794ab079ab76322bedc46a8ea99d0a}{m\+\_\+next\+Unsolicited\+Update}
\begin{DoxyCompactList}\small\item\em Next Unsolicited Update event. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1EventId}{Event\+Id} \hyperlink{classns3_1_1Rip_a66c28747adb18044611ceab7fbba57a8}{m\+\_\+next\+Triggered\+Update}
\begin{DoxyCompactList}\small\item\em Next Triggered Update event. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1UniformRandomVariable}{Uniform\+Random\+Variable} $>$ \hyperlink{classns3_1_1Rip_aff68d9a9e912bc0a99201bee4d93e636}{m\+\_\+rng}
\begin{DoxyCompactList}\small\item\em Rng stream. \end{DoxyCompactList}\item 
std\+::set$<$ uint32\+\_\+t $>$ \hyperlink{classns3_1_1Rip_a30e2c00645f24a3b29be981f5d592773}{m\+\_\+interface\+Exclusions}
\begin{DoxyCompactList}\small\item\em Set of excluded interfaces. \end{DoxyCompactList}\item 
std\+::map$<$ uint32\+\_\+t, uint8\+\_\+t $>$ \hyperlink{classns3_1_1Rip_a297aac5454b10e21644490335f72364a}{m\+\_\+interface\+Metrics}
\begin{DoxyCompactList}\small\item\em Map of interface metrics. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Rip_aa65e80d926399a90bc81b30dfc9404a4}{Split\+Horizon\+Type\+\_\+e} \hyperlink{classns3_1_1Rip_a2053001529a46356e1f612dfde6b4faf}{m\+\_\+split\+Horizon\+Strategy}
\begin{DoxyCompactList}\small\item\em Split Horizon strategy. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Rip_adb494e48f6b5e4e42bf47a8ad3a25485}{m\+\_\+initialized}
\begin{DoxyCompactList}\small\item\em flag to allow socket\textquotesingle{}s late-\/creation. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1Rip_a3f37d4c5176e380482edf0be82d2fc18}{m\+\_\+link\+Down}
\begin{DoxyCompactList}\small\item\em Link down value. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
R\+IP Routing Protocol, defined in \{2453\}. 

\subsection{Member Typedef Documentation}
\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Routes@{Routes}}
\index{Routes@{Routes}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Routes}{Routes}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<$std\+::pair $<${\bf Rip\+Routing\+Table\+Entry} $\ast$, {\bf Event\+Id}$>$ $>$ {\bf ns3\+::\+Rip\+::\+Routes}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_a7108837a80349ce23ac60d043ac81d58}{}\label{classns3_1_1Rip_a7108837a80349ce23ac60d043ac81d58}


Container for the network routes -\/ pair \hyperlink{classns3_1_1RipRoutingTableEntry}{Rip\+Routing\+Table\+Entry} $\ast$, \hyperlink{classns3_1_1EventId}{Event\+Id} (update event) 

\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Routes\+CI@{Routes\+CI}}
\index{Routes\+CI@{Routes\+CI}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Routes\+CI}{RoutesCI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<$std\+::pair $<${\bf Rip\+Routing\+Table\+Entry} $\ast$, {\bf Event\+Id}$>$ $>$\+::const\+\_\+iterator {\bf ns3\+::\+Rip\+::\+Routes\+CI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_a20080eb47fbc0ac67e3eba1c61cbafcb}{}\label{classns3_1_1Rip_a20080eb47fbc0ac67e3eba1c61cbafcb}


Const Iterator for container for the network routes. 

\index{ns3\+::\+Rip@{ns3\+::\+Rip}!RoutesI@{RoutesI}}
\index{RoutesI@{RoutesI}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{RoutesI}{RoutesI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<$std\+::pair $<${\bf Rip\+Routing\+Table\+Entry} $\ast$, {\bf Event\+Id}$>$ $>$\+::iterator {\bf ns3\+::\+Rip\+::\+RoutesI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_a8819af4dd44f270b6b19be755b39bce8}{}\label{classns3_1_1Rip_a8819af4dd44f270b6b19be755b39bce8}


Iterator for container for the network routes. 

\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Socket\+List@{Socket\+List}}
\index{Socket\+List@{Socket\+List}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Socket\+List}{SocketList}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::map$<$ {\bf Ptr}$<${\bf Socket}$>$, uint32\+\_\+t$>$ {\bf ns3\+::\+Rip\+::\+Socket\+List}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_afc81050735dfff6d48facd8284f0954f}{}\label{classns3_1_1Rip_afc81050735dfff6d48facd8284f0954f}


\hyperlink{classns3_1_1Socket}{Socket} list type. 

\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Socket\+List\+CI@{Socket\+List\+CI}}
\index{Socket\+List\+CI@{Socket\+List\+CI}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Socket\+List\+CI}{SocketListCI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::map$<${\bf Ptr}$<${\bf Socket}$>$, uint32\+\_\+t$>$\+::const\+\_\+iterator {\bf ns3\+::\+Rip\+::\+Socket\+List\+CI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_a685ab5baf3f942d84aba0c3d4784035f}{}\label{classns3_1_1Rip_a685ab5baf3f942d84aba0c3d4784035f}


\hyperlink{classns3_1_1Socket}{Socket} list type const iterator. 

\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Socket\+ListI@{Socket\+ListI}}
\index{Socket\+ListI@{Socket\+ListI}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Socket\+ListI}{SocketListI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::map$<${\bf Ptr}$<${\bf Socket}$>$, uint32\+\_\+t$>$\+::iterator {\bf ns3\+::\+Rip\+::\+Socket\+ListI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_a0395b3977eeeb90190ccfa5758a3957f}{}\label{classns3_1_1Rip_a0395b3977eeeb90190ccfa5758a3957f}


\hyperlink{classns3_1_1Socket}{Socket} list type iterator. 



\subsection{Member Enumeration Documentation}
\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Split\+Horizon\+Type\+\_\+e@{Split\+Horizon\+Type\+\_\+e}}
\index{Split\+Horizon\+Type\+\_\+e@{Split\+Horizon\+Type\+\_\+e}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Split\+Horizon\+Type\+\_\+e}{SplitHorizonType_e}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf ns3\+::\+Rip\+::\+Split\+Horizon\+Type\+\_\+e}}\hypertarget{classns3_1_1Rip_aa65e80d926399a90bc81b30dfc9404a4}{}\label{classns3_1_1Rip_aa65e80d926399a90bc81b30dfc9404a4}
Split Horizon strategy type. See \{2453\}. \begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{N\+O\+\_\+\+S\+P\+L\+I\+T\+\_\+\+H\+O\+R\+I\+Z\+ON@{N\+O\+\_\+\+S\+P\+L\+I\+T\+\_\+\+H\+O\+R\+I\+Z\+ON}!ns3\+::\+Rip@{ns3\+::\+Rip}}\index{ns3\+::\+Rip@{ns3\+::\+Rip}!N\+O\+\_\+\+S\+P\+L\+I\+T\+\_\+\+H\+O\+R\+I\+Z\+ON@{N\+O\+\_\+\+S\+P\+L\+I\+T\+\_\+\+H\+O\+R\+I\+Z\+ON}}\item[{\em 
N\+O\+\_\+\+S\+P\+L\+I\+T\+\_\+\+H\+O\+R\+I\+Z\+ON\hypertarget{classns3_1_1Rip_aa65e80d926399a90bc81b30dfc9404a4a7444cea8e684dd1431a925f01eedfd03}{}\label{classns3_1_1Rip_aa65e80d926399a90bc81b30dfc9404a4a7444cea8e684dd1431a925f01eedfd03}
}]No Split Horizon. \index{S\+P\+L\+I\+T\+\_\+\+H\+O\+R\+I\+Z\+ON@{S\+P\+L\+I\+T\+\_\+\+H\+O\+R\+I\+Z\+ON}!ns3\+::\+Rip@{ns3\+::\+Rip}}\index{ns3\+::\+Rip@{ns3\+::\+Rip}!S\+P\+L\+I\+T\+\_\+\+H\+O\+R\+I\+Z\+ON@{S\+P\+L\+I\+T\+\_\+\+H\+O\+R\+I\+Z\+ON}}\item[{\em 
S\+P\+L\+I\+T\+\_\+\+H\+O\+R\+I\+Z\+ON\hypertarget{classns3_1_1Rip_aa65e80d926399a90bc81b30dfc9404a4a37e78b48a284b4248a999e281e8ea5f9}{}\label{classns3_1_1Rip_aa65e80d926399a90bc81b30dfc9404a4a37e78b48a284b4248a999e281e8ea5f9}
}]Split Horizon. \index{P\+O\+I\+S\+O\+N\+\_\+\+R\+E\+V\+E\+R\+SE@{P\+O\+I\+S\+O\+N\+\_\+\+R\+E\+V\+E\+R\+SE}!ns3\+::\+Rip@{ns3\+::\+Rip}}\index{ns3\+::\+Rip@{ns3\+::\+Rip}!P\+O\+I\+S\+O\+N\+\_\+\+R\+E\+V\+E\+R\+SE@{P\+O\+I\+S\+O\+N\+\_\+\+R\+E\+V\+E\+R\+SE}}\item[{\em 
P\+O\+I\+S\+O\+N\+\_\+\+R\+E\+V\+E\+R\+SE\hypertarget{classns3_1_1Rip_aa65e80d926399a90bc81b30dfc9404a4ad6573915007f19810b223a280519eb86}{}\label{classns3_1_1Rip_aa65e80d926399a90bc81b30dfc9404a4ad6573915007f19810b223a280519eb86}
}]Poison Reverse Split Horizon. \end{description}
\end{Desc}

\begin{DoxyCode}
202                           \{
203     \hyperlink{classns3_1_1Rip_aa65e80d926399a90bc81b30dfc9404a4a7444cea8e684dd1431a925f01eedfd03}{NO\_SPLIT\_HORIZON},
204     \hyperlink{classns3_1_1Rip_aa65e80d926399a90bc81b30dfc9404a4a37e78b48a284b4248a999e281e8ea5f9}{SPLIT\_HORIZON},   
205     \hyperlink{classns3_1_1Rip_aa65e80d926399a90bc81b30dfc9404a4ad6573915007f19810b223a280519eb86}{POISON\_REVERSE},  
206   \};
\end{DoxyCode}


\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Rip@{Rip}}
\index{Rip@{Rip}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Rip()}{Rip()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Rip\+::\+Rip (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Rip_a2593bb8e6e858298059ac53ee265fe21}{}\label{classns3_1_1Rip_a2593bb8e6e858298059ac53ee265fe21}

\begin{DoxyCode}
48   : \hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4} (0), \hyperlink{classns3_1_1Rip_a2053001529a46356e1f612dfde6b4faf}{m\_splitHorizonStrategy} (
      \hyperlink{classns3_1_1Rip_aa65e80d926399a90bc81b30dfc9404a4ad6573915007f19810b223a280519eb86}{Rip::POISON\_REVERSE}), \hyperlink{classns3_1_1Rip_adb494e48f6b5e4e42bf47a8ad3a25485}{m\_initialized} (\textcolor{keyword}{false})
49 \{
50   \hyperlink{classns3_1_1Rip_aff68d9a9e912bc0a99201bee4d93e636}{m\_rng} = CreateObject<UniformRandomVariable> ();
51 \}
\end{DoxyCode}
\index{ns3\+::\+Rip@{ns3\+::\+Rip}!````~Rip@{$\sim$\+Rip}}
\index{````~Rip@{$\sim$\+Rip}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{$\sim$\+Rip()}{~Rip()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Rip\+::$\sim$\+Rip (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Rip_a2f5e5b0f019eddaf2e38b64722552415}{}\label{classns3_1_1Rip_a2f5e5b0f019eddaf2e38b64722552415}

\begin{DoxyCode}
54 \{
55 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Add\+Default\+Route\+To@{Add\+Default\+Route\+To}}
\index{Add\+Default\+Route\+To@{Add\+Default\+Route\+To}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Add\+Default\+Route\+To(\+Ipv4\+Address next\+Hop, uint32\+\_\+t interface)}{AddDefaultRouteTo(Ipv4Address nextHop, uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+::\+Add\+Default\+Route\+To (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{next\+Hop, }
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Rip_ae57b91bb372f7ab60d5519f32750af95}{}\label{classns3_1_1Rip_ae57b91bb372f7ab60d5519f32750af95}


Add a default route to the router through the next\+Hop located on interface. 

The default route is usually installed manually, or it is the result of some \char`\"{}other\char`\"{} routing protocol (e.\+g., B\+GP).


\begin{DoxyParams}{Parameters}
{\em next\+Hop} & the next hop \\
\hline
{\em interface} & the interface \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1270 \{
1271   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << interface);
1272 
1273   \hyperlink{classns3_1_1Rip_a8aa9415f65e5fb8abaa6af5c93446231}{AddNetworkRouteTo} (Ipv4Address (\textcolor{stringliteral}{"0.0.0.0"}), \hyperlink{classns3_1_1Ipv4Mask_ac2dda492011ede8350008d753d278998}{Ipv4Mask::GetZero} (), 
      nextHop, interface);
1274 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Add\+Network\+Route\+To@{Add\+Network\+Route\+To}}
\index{Add\+Network\+Route\+To@{Add\+Network\+Route\+To}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Add\+Network\+Route\+To(\+Ipv4\+Address network, Ipv4\+Mask network\+Prefix, Ipv4\+Address next\+Hop, uint32\+\_\+t interface)}{AddNetworkRouteTo(Ipv4Address network, Ipv4Mask networkPrefix, Ipv4Address nextHop, uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+::\+Add\+Network\+Route\+To (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{network, }
\item[{{\bf Ipv4\+Mask}}]{network\+Prefix, }
\item[{{\bf Ipv4\+Address}}]{next\+Hop, }
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_a8aa9415f65e5fb8abaa6af5c93446231}{}\label{classns3_1_1Rip_a8aa9415f65e5fb8abaa6af5c93446231}


Add route to network. 


\begin{DoxyParams}{Parameters}
{\em network} & network address \\
\hline
{\em network\+Prefix} & network prefix \\
\hline
{\em next\+Hop} & next hop address to route the packet. \\
\hline
{\em interface} & interface index \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
648 \{
649   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << network << networkPrefix << nextHop << interface);
650 
651   RipRoutingTableEntry* route = \textcolor{keyword}{new} RipRoutingTableEntry (network, networkPrefix, nextHop, interface);
652   route->SetRouteMetric (1);
653   route->SetRouteStatus (\hyperlink{classns3_1_1RipRoutingTableEntry_a4326145be5c3027f2ddf9eb80b6127a4ac29e62da26c18bf4b9caa5224cfee895}{RipRoutingTableEntry::RIP\_VALID});
654   route->SetRouteChanged (\textcolor{keyword}{true});
655 
656   \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.push\_back (std::make\_pair (route, EventId ()));
657 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3




Here is the caller graph for this function\+:
% FIG 4


\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Add\+Network\+Route\+To@{Add\+Network\+Route\+To}}
\index{Add\+Network\+Route\+To@{Add\+Network\+Route\+To}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Add\+Network\+Route\+To(\+Ipv4\+Address network, Ipv4\+Mask network\+Prefix, uint32\+\_\+t interface)}{AddNetworkRouteTo(Ipv4Address network, Ipv4Mask networkPrefix, uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+::\+Add\+Network\+Route\+To (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{network, }
\item[{{\bf Ipv4\+Mask}}]{network\+Prefix, }
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_af107d4ee9156d769b699ba6939806025}{}\label{classns3_1_1Rip_af107d4ee9156d769b699ba6939806025}


Add route to network. 


\begin{DoxyParams}{Parameters}
{\em network} & network address \\
\hline
{\em network\+Prefix} & network prefix \\
\hline
{\em interface} & interface index \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
660 \{
661   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << network << networkPrefix << interface);
662 
663   RipRoutingTableEntry* route = \textcolor{keyword}{new} RipRoutingTableEntry (network, networkPrefix, interface);
664   route->SetRouteMetric (1);
665   route->SetRouteStatus (\hyperlink{classns3_1_1RipRoutingTableEntry_a4326145be5c3027f2ddf9eb80b6127a4ac29e62da26c18bf4b9caa5224cfee895}{RipRoutingTableEntry::RIP\_VALID});
666   route->SetRouteChanged (\textcolor{keyword}{true});
667 
668   \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.push\_back (std::make\_pair (route, EventId ()));
669 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 5


\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Assign\+Streams@{Assign\+Streams}}
\index{Assign\+Streams@{Assign\+Streams}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Assign\+Streams(int64\+\_\+t stream)}{AssignStreams(int64_t stream)}}]{\setlength{\rightskip}{0pt plus 5cm}int64\+\_\+t ns3\+::\+Rip\+::\+Assign\+Streams (
\begin{DoxyParamCaption}
\item[{int64\+\_\+t}]{stream}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Rip_a5fee03b012b2652b79e49b5f7fa3a0a9}{}\label{classns3_1_1Rip_a5fee03b012b2652b79e49b5f7fa3a0a9}
Assign a fixed random variable stream number to the random variables used by this model. Return the number of streams (possibly zero) that have been assigned.


\begin{DoxyParams}{Parameters}
{\em stream} & first stream index to use \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of stream indices assigned by this model 
\end{DoxyReturn}

\begin{DoxyCode}
103 \{
104   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << stream);
105 
106   \hyperlink{classns3_1_1Rip_aff68d9a9e912bc0a99201bee4d93e636}{m\_rng}->\hyperlink{classns3_1_1RandomVariableStream_add11aaf975607746b7e271d300659a94}{SetStream} (stream);
107   \textcolor{keywordflow}{return} 1;
108 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6


\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Delete\+Route@{Delete\+Route}}
\index{Delete\+Route@{Delete\+Route}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Delete\+Route(\+Rip\+Routing\+Table\+Entry $\ast$route)}{DeleteRoute(RipRoutingTableEntry *route)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+::\+Delete\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Rip\+Routing\+Table\+Entry} $\ast$}]{route}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_a4613413ac628e8313c26d5ea6ed99761}{}\label{classns3_1_1Rip_a4613413ac628e8313c26d5ea6ed99761}


Delete a route. 


\begin{DoxyParams}{Parameters}
{\em route} & the route to be removed \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
694 \{
695   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << *route);
696 
697   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Rip_a8819af4dd44f270b6b19be755b39bce8}{RoutesI} it = \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.begin (); it != \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.end (); it++)
698     \{
699       \textcolor{keywordflow}{if} (it->first == route)
700         \{
701           \textcolor{keyword}{delete} route;
702           \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.erase (it);
703           \textcolor{keywordflow}{return};
704         \}
705     \}
706   \hyperlink{group__fatal_ga51ac4699be799d772ae7258d1ef6af21}{NS\_ABORT\_MSG} (\textcolor{stringliteral}{"RIP::DeleteRoute - cannot find the route to delete"});
707 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Do\+Dispose()}{DoDispose()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Rip_a4b7ea6fdc9d480f3ed80c3daeb946818}{}\label{classns3_1_1Rip_a4b7ea6fdc9d480f3ed80c3daeb946818}


Dispose this object. 



Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.


\begin{DoxyCode}
544 \{
545   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
546 
547   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Rip_a8819af4dd44f270b6b19be755b39bce8}{RoutesI} j = \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.begin ();  j != \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.end (); j = 
      \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.erase (j))
548     \{
549       \textcolor{keyword}{delete} j->first;
550     \}
551   \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.clear ();
552 
553   \hyperlink{classns3_1_1Rip_a66c28747adb18044611ceab7fbba57a8}{m\_nextTriggeredUpdate}.\hyperlink{classns3_1_1EventId_a993ae94e48e014e1afd47edb16db7a11}{Cancel} ();
554   \hyperlink{classns3_1_1Rip_a52794ab079ab76322bedc46a8ea99d0a}{m\_nextUnsolicitedUpdate}.\hyperlink{classns3_1_1EventId_a993ae94e48e014e1afd47edb16db7a11}{Cancel} ();
555   \hyperlink{classns3_1_1Rip_a66c28747adb18044611ceab7fbba57a8}{m\_nextTriggeredUpdate} = EventId ();
556   \hyperlink{classns3_1_1Rip_a52794ab079ab76322bedc46a8ea99d0a}{m\_nextUnsolicitedUpdate} = EventId ();
557 
558   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Rip_a0395b3977eeeb90190ccfa5758a3957f}{SocketListI} iter = \hyperlink{classns3_1_1Rip_a58b5f6ebcee2ed04249fd025abfa61cb}{m\_sendSocketList}.begin (); iter != 
      \hyperlink{classns3_1_1Rip_a58b5f6ebcee2ed04249fd025abfa61cb}{m\_sendSocketList}.end (); iter++ )
559     \{
560       iter->first->Close ();
561     \}
562   \hyperlink{classns3_1_1Rip_a58b5f6ebcee2ed04249fd025abfa61cb}{m\_sendSocketList}.clear ();
563 
564   \hyperlink{classns3_1_1Rip_a6c5dc1b74475e3caa0782f37b722be6b}{m\_recvSocket}->\hyperlink{classns3_1_1Socket_abdac6e2498c5aa2963ef361d4200ddf3}{Close} ();
565   \hyperlink{classns3_1_1Rip_a6c5dc1b74475e3caa0782f37b722be6b}{m\_recvSocket} = 0;
566 
567   \hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4} = 0;
568 
569   \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{Ipv4RoutingProtocol::DoDispose} ();
570 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8


\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Do\+Initialize@{Do\+Initialize}}
\index{Do\+Initialize@{Do\+Initialize}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Do\+Initialize()}{DoInitialize()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+::\+Do\+Initialize (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Rip_a622ec450ec78945f81986b64ce3dcbed}{}\label{classns3_1_1Rip_a622ec450ec78945f81986b64ce3dcbed}
Start protocol operation 

Reimplemented from \hyperlink{classns3_1_1Object_af8482a521433409fb5c7f749398c9dbe}{ns3\+::\+Object}.


\begin{DoxyCode}
111 \{
112   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
113 
114   \textcolor{keywordtype}{bool} addedGlobal = \textcolor{keyword}{false};
115 
116   \hyperlink{classns3_1_1Rip_adb494e48f6b5e4e42bf47a8ad3a25485}{m\_initialized} = \textcolor{keyword}{true};
117 
118   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_a7964e6aa8f61a9d28973c8267a606ad8}{delay} = \hyperlink{classns3_1_1Rip_aabc5098465aa38f416c5daa7561d3ea0}{m\_unsolicitedUpdate} + \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (
      \hyperlink{classns3_1_1Rip_aff68d9a9e912bc0a99201bee4d93e636}{m\_rng}->\hyperlink{classns3_1_1UniformRandomVariable_a03822d8c86ac51e9aa83bbc73041386b}{GetValue} (0, 0.5*\hyperlink{classns3_1_1Rip_aabc5098465aa38f416c5daa7561d3ea0}{m\_unsolicitedUpdate}.
      \hyperlink{classns3_1_1Time_a8f20d5c3b0902d7b4320982f340b57c8}{GetSeconds} ()) );
119   \hyperlink{classns3_1_1Rip_a52794ab079ab76322bedc46a8ea99d0a}{m\_nextUnsolicitedUpdate} = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (delay, &
      \hyperlink{classns3_1_1Rip_aea59ff20475f09e1783bc37d5a8531c0}{Rip::SendUnsolicitedRouteUpdate}, \textcolor{keyword}{this});
120 
121 
122   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0 ; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->GetNInterfaces (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
123     \{
124       Ptr<LoopbackNetDevice> \hyperlink{namespacevisualizer_1_1higcontainer_ac48d36b2f857bd4ef93244235f447292}{check} = DynamicCast<LoopbackNetDevice> (\hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->GetNetDevice (
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}));
125       \textcolor{keywordflow}{if} (check)
126         \{
127           \textcolor{keywordflow}{continue};
128         \}
129 
130       \textcolor{keywordtype}{bool} activeInterface = \textcolor{keyword}{false};
131       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Rip_a30e2c00645f24a3b29be981f5d592773}{m\_interfaceExclusions}.find (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) == 
      \hyperlink{classns3_1_1Rip_a30e2c00645f24a3b29be981f5d592773}{m\_interfaceExclusions}.end ())
132         \{
133           activeInterface = \textcolor{keyword}{true};
134           \hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->SetForwarding (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, \textcolor{keyword}{true});
135         \}
136 
137       \textcolor{keywordflow}{for} (uint32\_t j = 0; j < \hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->GetNAddresses (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}); j++)
138         \{
139           Ipv4InterfaceAddress address = \hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, j);
140           \textcolor{keywordflow}{if} (address.GetScope() != \hyperlink{classns3_1_1Ipv4InterfaceAddress_a329cea433e74f717c26c9e51c4fcd3d8a7276e171c0232cceba24502099750890}{Ipv4InterfaceAddress::HOST} && activeInterface
       == \textcolor{keyword}{true})
141             \{
142               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"RIP: adding socket to "} << address.GetLocal ());
143               TypeId tid = \hyperlink{classns3_1_1TypeId_a119cf99c20931fdc294602cd360b180e}{TypeId::LookupByName} (\textcolor{stringliteral}{"ns3::UdpSocketFactory"});
144               Ptr<Node> theNode = GetObject<Node> ();
145               Ptr<Socket> socket = \hyperlink{classns3_1_1Socket_ad448a62bb50ad3dbac59c879a885a8d2}{Socket::CreateSocket} (theNode, tid);
146               InetSocketAddress local = InetSocketAddress (address.GetLocal (), 
      \hyperlink{rip_8cc_a6af26a435808c34ee4f8876792a5682a}{RIP\_PORT});
147               \textcolor{keywordtype}{int} ret = socket->Bind (local);
148               \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (ret == 0, \textcolor{stringliteral}{"Bind unsuccessful"});
149               socket->BindToNetDevice (\hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->GetNetDevice (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}));
150               socket->SetIpRecvTtl (\textcolor{keyword}{true});
151               \hyperlink{classns3_1_1Rip_a58b5f6ebcee2ed04249fd025abfa61cb}{m\_sendSocketList}[socket] = \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
152             \}
153           \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, j).GetScope() == 
      \hyperlink{classns3_1_1Ipv4InterfaceAddress_a329cea433e74f717c26c9e51c4fcd3d8ae144856017bcfb529872c91204d462b2}{Ipv4InterfaceAddress::GLOBAL})
154             \{
155               addedGlobal = \textcolor{keyword}{true};
156             \}
157         \}
158     \}
159 
160   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1Rip_a6c5dc1b74475e3caa0782f37b722be6b}{m\_recvSocket})
161     \{
162       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"RIP: adding receiving socket"});
163       TypeId tid = \hyperlink{classns3_1_1TypeId_a119cf99c20931fdc294602cd360b180e}{TypeId::LookupByName} (\textcolor{stringliteral}{"ns3::UdpSocketFactory"});
164       Ptr<Node> theNode = GetObject<Node> ();
165       \hyperlink{classns3_1_1Rip_a6c5dc1b74475e3caa0782f37b722be6b}{m\_recvSocket} = \hyperlink{classns3_1_1Socket_ad448a62bb50ad3dbac59c879a885a8d2}{Socket::CreateSocket} (theNode, tid);
166       InetSocketAddress local = InetSocketAddress (\hyperlink{rip_8cc_a4088e07a51c9aabba6666b6c1e85f704}{RIP\_ALL\_NODE}, 
      \hyperlink{rip_8cc_a6af26a435808c34ee4f8876792a5682a}{RIP\_PORT});
167       m\_recvSocket->Bind (local);
168       m\_recvSocket->SetRecvCallback (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&\hyperlink{classns3_1_1Rip_a49acadfb3b533118276481a0d231406e}{Rip::Receive}, \textcolor{keyword}{this}));
169       m\_recvSocket->SetIpRecvTtl (\textcolor{keyword}{true});
170       m\_recvSocket->SetRecvPktInfo (\textcolor{keyword}{true});
171     \}
172 
173 
174   \textcolor{keywordflow}{if} (addedGlobal)
175     \{
176       \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} delay = \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (\hyperlink{classns3_1_1Rip_aff68d9a9e912bc0a99201bee4d93e636}{m\_rng}->\hyperlink{classns3_1_1UniformRandomVariable_a03822d8c86ac51e9aa83bbc73041386b}{GetValue} (
      \hyperlink{classns3_1_1Rip_a9345ff42e947fb0edb2382d6c4f50bd0}{m\_minTriggeredUpdateDelay}.\hyperlink{classns3_1_1Time_a8f20d5c3b0902d7b4320982f340b57c8}{GetSeconds} (), 
      \hyperlink{classns3_1_1Rip_aed7be1d33584f7d7f8b2ca68bfbf3a06}{m\_maxTriggeredUpdateDelay}.\hyperlink{classns3_1_1Time_a8f20d5c3b0902d7b4320982f340b57c8}{GetSeconds} ()));
177       \hyperlink{classns3_1_1Rip_a66c28747adb18044611ceab7fbba57a8}{m\_nextTriggeredUpdate} = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (delay, &
      \hyperlink{classns3_1_1Rip_a106f73869862c38c070faec379542e05}{Rip::DoSendRouteUpdate}, \textcolor{keyword}{this}, \textcolor{keyword}{false});
178     \}
179 
180   delay = \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (\hyperlink{classns3_1_1Rip_aff68d9a9e912bc0a99201bee4d93e636}{m\_rng}->\hyperlink{classns3_1_1UniformRandomVariable_a03822d8c86ac51e9aa83bbc73041386b}{GetValue} (0.01, \hyperlink{classns3_1_1Rip_a26dfd4f6ce345b6259733027a77fbcc9}{m\_startupDelay}.
      \hyperlink{classns3_1_1Time_a8f20d5c3b0902d7b4320982f340b57c8}{GetSeconds} ()));
181   \hyperlink{classns3_1_1Rip_a66c28747adb18044611ceab7fbba57a8}{m\_nextTriggeredUpdate} = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (delay, &
      \hyperlink{classns3_1_1Rip_a84c90e335d9b833b26f1a8e8e7fc2243}{Rip::SendRouteRequest}, \textcolor{keyword}{this});
182 
183   \hyperlink{classns3_1_1Object_af8482a521433409fb5c7f749398c9dbe}{Ipv4RoutingProtocol::DoInitialize} ();
184 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 9


\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Do\+Send\+Route\+Update@{Do\+Send\+Route\+Update}}
\index{Do\+Send\+Route\+Update@{Do\+Send\+Route\+Update}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Do\+Send\+Route\+Update(bool periodic)}{DoSendRouteUpdate(bool periodic)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+::\+Do\+Send\+Route\+Update (
\begin{DoxyParamCaption}
\item[{bool}]{periodic}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_a106f73869862c38c070faec379542e05}{}\label{classns3_1_1Rip_a106f73869862c38c070faec379542e05}


Send Routing Updates on all interfaces. 


\begin{DoxyParams}{Parameters}
{\em periodic} & true for periodic update, else triggered. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1067 \{
1068   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << (periodic ? \textcolor{stringliteral}{" periodic"} : \textcolor{stringliteral}{" triggered"}));
1069 
1070   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Rip_a0395b3977eeeb90190ccfa5758a3957f}{SocketListI} iter = \hyperlink{classns3_1_1Rip_a58b5f6ebcee2ed04249fd025abfa61cb}{m\_sendSocketList}.begin (); iter != 
      \hyperlink{classns3_1_1Rip_a58b5f6ebcee2ed04249fd025abfa61cb}{m\_sendSocketList}.end (); iter++ )
1071     \{
1072       uint32\_t \textcolor{keyword}{interface }= iter->second;
1073 
1074       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Rip_a30e2c00645f24a3b29be981f5d592773}{m\_interfaceExclusions}.find (interface) == 
      \hyperlink{classns3_1_1Rip_a30e2c00645f24a3b29be981f5d592773}{m\_interfaceExclusions}.end ())
1075         \{
1076           uint16\_t mtu = \hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->GetMtu (interface);
1077           uint16\_t maxRte = (mtu - Ipv4Header ().GetSerializedSize () - UdpHeader ().GetSerializedSize () -
       RipHeader ().GetSerializedSize ()) / RipRte ().GetSerializedSize ();
1078 
1079           Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = Create<Packet> ();
1080           SocketIpTtlTag tag;
1081           tag.SetTtl (1);
1082           p->AddPacketTag (tag);
1083 
1084           RipHeader hdr;
1085           hdr.SetCommand (\hyperlink{classns3_1_1RipHeader_a8c6ce779ee35c8b65446aaa202a6e789a9f13028e2d4a57da73f592702d7b17c7}{RipHeader::RESPONSE});
1086 
1087           \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Rip_a8819af4dd44f270b6b19be755b39bce8}{RoutesI} rtIter = \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.begin (); rtIter != 
      \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.end (); rtIter++)
1088             \{
1089               \textcolor{keywordtype}{bool} splitHorizoning = (rtIter->first->GetInterface () == interface);
1090               Ipv4InterfaceAddress rtDestAddr = Ipv4InterfaceAddress(rtIter->first->GetDestNetwork (), 
      rtIter->first->GetDestNetworkMask ());
1091 
1092               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"Processing RT "} << rtDestAddr << \textcolor{stringliteral}{" "} << \textcolor{keywordtype}{int}(rtIter->first->
      IsRouteChanged ()));
1093 
1094               \textcolor{keywordtype}{bool} isGlobal = (rtDestAddr.GetScope () == 
      \hyperlink{classns3_1_1Ipv4InterfaceAddress_a329cea433e74f717c26c9e51c4fcd3d8ae144856017bcfb529872c91204d462b2}{Ipv4InterfaceAddress::GLOBAL});
1095               \textcolor{keywordtype}{bool} isDefaultRoute = ((rtIter->first->GetDestNetwork () == 
      \hyperlink{classns3_1_1Ipv4Address_a7a39b330c8e701183a411d5779fca1a4}{Ipv4Address::GetAny} ()) &&
1096                   (rtIter->first->GetDestNetworkMask () == \hyperlink{classns3_1_1Ipv4Mask_ac2dda492011ede8350008d753d278998}{Ipv4Mask::GetZero} ()) &&
1097                   (rtIter->first->GetInterface () != interface));
1098 
1099               \textcolor{keywordtype}{bool} sameNetwork = \textcolor{keyword}{false};
1100               \textcolor{keywordflow}{for} (uint32\_t index = 0; index < \hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->GetNAddresses (interface); index++)
1101                 \{
1102                   Ipv4InterfaceAddress addr = \hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->GetAddress (interface, index);
1103                   \textcolor{keywordflow}{if} (addr.GetLocal ().CombineMask (addr.GetMask ()) == rtIter->first->GetDestNetwork ())
1104                     \{
1105                       sameNetwork = \textcolor{keyword}{true};
1106                     \}
1107                 \}
1108 
1109               \textcolor{keywordflow}{if} ((isGlobal || isDefaultRoute) &&
1110                   (periodic || rtIter->first->IsRouteChanged ()) &&
1111                   !sameNetwork)
1112                 \{
1113                   RipRte rte;
1114                   rte.SetPrefix (rtIter->first->GetDestNetwork ());
1115                   rte.SetSubnetMask (rtIter->first->GetDestNetworkMask ());
1116                   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Rip_a2053001529a46356e1f612dfde6b4faf}{m\_splitHorizonStrategy} == 
      \hyperlink{classns3_1_1Rip_aa65e80d926399a90bc81b30dfc9404a4ad6573915007f19810b223a280519eb86}{POISON\_REVERSE} && splitHorizoning)
1117                     \{
1118                       rte.SetRouteMetric (\hyperlink{classns3_1_1Rip_a3f37d4c5176e380482edf0be82d2fc18}{m\_linkDown});
1119                     \}
1120                   \textcolor{keywordflow}{else}
1121                     \{
1122                       rte.SetRouteMetric (rtIter->first->GetRouteMetric ());
1123                     \}
1124                   rte.SetRouteTag (rtIter->first->GetRouteTag ());
1125                   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Rip_a2053001529a46356e1f612dfde6b4faf}{m\_splitHorizonStrategy} == 
      \hyperlink{classns3_1_1Rip_aa65e80d926399a90bc81b30dfc9404a4a37e78b48a284b4248a999e281e8ea5f9}{SPLIT\_HORIZON} && !splitHorizoning)
1126                     \{
1127                       hdr.AddRte (rte);
1128                     \}
1129                   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Rip_a2053001529a46356e1f612dfde6b4faf}{m\_splitHorizonStrategy} != 
      \hyperlink{classns3_1_1Rip_aa65e80d926399a90bc81b30dfc9404a4a37e78b48a284b4248a999e281e8ea5f9}{SPLIT\_HORIZON})
1130                     \{
1131                       hdr.AddRte (rte);
1132                     \}
1133                 \}
1134               \textcolor{keywordflow}{if} (hdr.GetRteNumber () == maxRte)
1135                 \{
1136                   p->AddHeader (hdr);
1137                   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"SendTo: "} << *p);
1138                   iter->first->SendTo (p, 0, InetSocketAddress (\hyperlink{rip_8cc_a4088e07a51c9aabba6666b6c1e85f704}{RIP\_ALL\_NODE}, 
      \hyperlink{rip_8cc_a6af26a435808c34ee4f8876792a5682a}{RIP\_PORT}));
1139                   p->RemoveHeader (hdr);
1140                   hdr.ClearRtes ();
1141                 \}
1142             \}
1143           \textcolor{keywordflow}{if} (hdr.GetRteNumber () > 0)
1144             \{
1145               p->AddHeader (hdr);
1146               \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"SendTo: "} << *p);
1147               iter->first->SendTo (p, 0, InetSocketAddress (\hyperlink{rip_8cc_a4088e07a51c9aabba6666b6c1e85f704}{RIP\_ALL\_NODE}, 
      \hyperlink{rip_8cc_a6af26a435808c34ee4f8876792a5682a}{RIP\_PORT}));
1148             \}
1149         \}
1150     \}
1151   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Rip_a8819af4dd44f270b6b19be755b39bce8}{RoutesI} rtIter = \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.begin (); rtIter != \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.end (); rtIter++)
1152     \{
1153       rtIter->first->SetRouteChanged (\textcolor{keyword}{false});
1154     \}
1155 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10




Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Get\+Interface\+Exclusions@{Get\+Interface\+Exclusions}}
\index{Get\+Interface\+Exclusions@{Get\+Interface\+Exclusions}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Get\+Interface\+Exclusions() const }{GetInterfaceExclusions() const }}]{\setlength{\rightskip}{0pt plus 5cm}std\+::set$<$ uint32\+\_\+t $>$ ns3\+::\+Rip\+::\+Get\+Interface\+Exclusions (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Rip_ac934d4c30c1fe7a5076cc25308bd7eb1}{}\label{classns3_1_1Rip_ac934d4c30c1fe7a5076cc25308bd7eb1}


Get the set of interface excluded from the protocol. 

\begin{DoxyReturn}{Returns}
the set of excluded interfaces 
\end{DoxyReturn}

\begin{DoxyCode}
1203 \{
1204   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Rip_a30e2c00645f24a3b29be981f5d592773}{m\_interfaceExclusions};
1205 \}
\end{DoxyCode}
\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Get\+Interface\+Metric@{Get\+Interface\+Metric}}
\index{Get\+Interface\+Metric@{Get\+Interface\+Metric}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Get\+Interface\+Metric(uint32\+\_\+t interface) const }{GetInterfaceMetric(uint32_t interface) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::\+Rip\+::\+Get\+Interface\+Metric (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Rip_a6bff4d6e94d4ca9e3f276df0fb538b8f}{}\label{classns3_1_1Rip_a6bff4d6e94d4ca9e3f276df0fb538b8f}


Get the metric for an interface. 


\begin{DoxyParams}{Parameters}
{\em interface} & the interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the interface metric 
\end{DoxyReturn}

\begin{DoxyCode}
1215 \{
1216   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << interface);
1217 
1218   std::map<uint32\_t, uint8\_t>::const\_iterator iter = \hyperlink{classns3_1_1Rip_a297aac5454b10e21644490335f72364a}{m\_interfaceMetrics}.find (interface);
1219   \textcolor{keywordflow}{if} (iter != \hyperlink{classns3_1_1Rip_a297aac5454b10e21644490335f72364a}{m\_interfaceMetrics}.end ())
1220     \{
1221       \textcolor{keywordflow}{return} iter->second;
1222     \}
1223   \textcolor{keywordflow}{return} 1;
1224 \}
\end{DoxyCode}
\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id(void)}{GetTypeId(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Rip\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Rip_ace3389e07c4181ca5bc9c2ca5a4bab24}{}\label{classns3_1_1Rip_ace3389e07c4181ca5bc9c2ca5a4bab24}


Get the type ID. 

\begin{DoxyReturn}{Returns}
type ID 
\end{DoxyReturn}

\begin{DoxyCode}
59 \{
60   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::Rip"})
61     .SetParent<Ipv4RoutingProtocol> ()
62     .SetGroupName (\textcolor{stringliteral}{"Internet"})
63     .AddConstructor<\hyperlink{classns3_1_1Rip_a2593bb8e6e858298059ac53ee265fe21}{Rip}> ()
64     .AddAttribute (\textcolor{stringliteral}{"UnsolicitedRoutingUpdate"}, \textcolor{stringliteral}{"The time between two Unsolicited Routing Updates."},
65                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds}(30)),
66                    MakeTimeAccessor (&\hyperlink{classns3_1_1Rip_aabc5098465aa38f416c5daa7561d3ea0}{Rip::m\_unsolicitedUpdate}),
67                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
68     .AddAttribute (\textcolor{stringliteral}{"StartupDelay"}, \textcolor{stringliteral}{"Maximum random delay for protocol startup (send route requests)."},
69                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds}(1)),
70                    MakeTimeAccessor (&\hyperlink{classns3_1_1Rip_a26dfd4f6ce345b6259733027a77fbcc9}{Rip::m\_startupDelay}),
71                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
72     .AddAttribute (\textcolor{stringliteral}{"TimeoutDelay"}, \textcolor{stringliteral}{"The delay to invalidate a route."},
73                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds}(180)),
74                    MakeTimeAccessor (&\hyperlink{classns3_1_1Rip_a8a684a47271e0e382dd5f485a8a5545b}{Rip::m\_timeoutDelay}),
75                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
76     .AddAttribute (\textcolor{stringliteral}{"GarbageCollectionDelay"}, \textcolor{stringliteral}{"The delay to delete an expired route."},
77                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds}(120)),
78                    MakeTimeAccessor (&\hyperlink{classns3_1_1Rip_ad317e92ae9d78b20642be47df4e8d866}{Rip::m\_garbageCollectionDelay}),
79                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
80     .AddAttribute (\textcolor{stringliteral}{"MinTriggeredCooldown"}, \textcolor{stringliteral}{"Min cooldown delay after a Triggered Update."},
81                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds}(1)),
82                    MakeTimeAccessor (&\hyperlink{classns3_1_1Rip_a9345ff42e947fb0edb2382d6c4f50bd0}{Rip::m\_minTriggeredUpdateDelay}),
83                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
84     .AddAttribute (\textcolor{stringliteral}{"MaxTriggeredCooldown"}, \textcolor{stringliteral}{"Max cooldown delay after a Triggered Update."},
85                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds}(5)),
86                    MakeTimeAccessor (&\hyperlink{classns3_1_1Rip_aed7be1d33584f7d7f8b2ca68bfbf3a06}{Rip::m\_maxTriggeredUpdateDelay}),
87                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
88     .AddAttribute (\textcolor{stringliteral}{"SplitHorizon"}, \textcolor{stringliteral}{"Split Horizon strategy."},
89                    EnumValue (\hyperlink{classns3_1_1Rip_aa65e80d926399a90bc81b30dfc9404a4ad6573915007f19810b223a280519eb86}{Rip::POISON\_REVERSE}),
90                    \hyperlink{namespacens3_af5050739867ce63896dec011e332c8ec}{MakeEnumAccessor} (&
      \hyperlink{classns3_1_1Rip_a2053001529a46356e1f612dfde6b4faf}{Rip::m\_splitHorizonStrategy}),
91                    \hyperlink{namespacens3_a48832781a2b521d3d0091e05ece30615}{MakeEnumChecker} (\hyperlink{classns3_1_1Rip_aa65e80d926399a90bc81b30dfc9404a4a7444cea8e684dd1431a925f01eedfd03}{Rip::NO\_SPLIT\_HORIZON}, \textcolor{stringliteral}{"
      NoSplitHorizon"},
92                                     \hyperlink{classns3_1_1Rip_aa65e80d926399a90bc81b30dfc9404a4a37e78b48a284b4248a999e281e8ea5f9}{Rip::SPLIT\_HORIZON}, \textcolor{stringliteral}{"SplitHorizon"},
93                                     \hyperlink{classns3_1_1Rip_aa65e80d926399a90bc81b30dfc9404a4ad6573915007f19810b223a280519eb86}{Rip::POISON\_REVERSE}, \textcolor{stringliteral}{"PoisonReverse"}))
94     .AddAttribute (\textcolor{stringliteral}{"LinkDownValue"}, \textcolor{stringliteral}{"Value for link down in count to infinity."},
95                    UintegerValue (16),
96                    MakeUintegerAccessor (&\hyperlink{classns3_1_1Rip_a3f37d4c5176e380482edf0be82d2fc18}{Rip::m\_linkDown}),
97                    MakeUintegerChecker<uint32\_t> ())
98     ;
99   \textcolor{keywordflow}{return} tid;
100 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12


\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Handle\+Requests@{Handle\+Requests}}
\index{Handle\+Requests@{Handle\+Requests}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Handle\+Requests(\+Rip\+Header hdr, Ipv4\+Address sender\+Address, uint16\+\_\+t sender\+Port, uint32\+\_\+t incoming\+Interface, uint8\+\_\+t hop\+Limit)}{HandleRequests(RipHeader hdr, Ipv4Address senderAddress, uint16_t senderPort, uint32_t incomingInterface, uint8_t hopLimit)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+::\+Handle\+Requests (
\begin{DoxyParamCaption}
\item[{{\bf Rip\+Header}}]{hdr, }
\item[{{\bf Ipv4\+Address}}]{sender\+Address, }
\item[{uint16\+\_\+t}]{sender\+Port, }
\item[{uint32\+\_\+t}]{incoming\+Interface, }
\item[{uint8\+\_\+t}]{hop\+Limit}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_a4094ed6c40c666f7567245eef2376fe9}{}\label{classns3_1_1Rip_a4094ed6c40c666f7567245eef2376fe9}


Handle R\+IP requests. 


\begin{DoxyParams}{Parameters}
{\em hdr} & message header (including R\+T\+Es) \\
\hline
{\em sender\+Address} & sender address \\
\hline
{\em sender\+Port} & sender port \\
\hline
{\em incoming\+Interface} & incoming interface \\
\hline
{\em hop\+Limit} & packet\textquotesingle{}s hop limit \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
765 \{
766   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << senderAddress << \textcolor{keywordtype}{int} (senderPort) << incomingInterface << \textcolor{keywordtype}{int} (
      hopLimit) << requestHdr);
767 
768   std::list<RipRte> rtes = requestHdr.GetRteList ();
769 
770   \textcolor{keywordflow}{if} (rtes.empty ())
771     \{
772       \textcolor{keywordflow}{return};
773     \}
774 
775   \textcolor{comment}{// check if it's a request for the full table from a neighbor}
776   \textcolor{keywordflow}{if} (rtes.size () == 1)
777     \{
778       \textcolor{keywordflow}{if} (rtes.begin ()->GetPrefix () == \hyperlink{classns3_1_1Ipv4Address_a7a39b330c8e701183a411d5779fca1a4}{Ipv4Address::GetAny} () &&
779           rtes.begin ()->GetSubnetMask ().GetPrefixLength () == 0 &&
780           rtes.begin ()->GetRouteMetric () == \hyperlink{classns3_1_1Rip_a3f37d4c5176e380482edf0be82d2fc18}{m\_linkDown})
781         \{
782           \textcolor{comment}{// Output whole thing. Use Split Horizon}
783           \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Rip_a30e2c00645f24a3b29be981f5d592773}{m\_interfaceExclusions}.find (incomingInterface) == 
      \hyperlink{classns3_1_1Rip_a30e2c00645f24a3b29be981f5d592773}{m\_interfaceExclusions}.end ())
784             \{
785               \textcolor{comment}{// we use one of the sending sockets, as they're bound to the right interface}
786               \textcolor{comment}{// and the local address might be used on different interfaces.}
787               Ptr<Socket> sendingSoket;
788               \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Rip_a0395b3977eeeb90190ccfa5758a3957f}{SocketListI} iter = \hyperlink{classns3_1_1Rip_a58b5f6ebcee2ed04249fd025abfa61cb}{m\_sendSocketList}.begin (); iter != 
      \hyperlink{classns3_1_1Rip_a58b5f6ebcee2ed04249fd025abfa61cb}{m\_sendSocketList}.end (); iter++ )
789                 \{
790                   \textcolor{keywordflow}{if} (iter->second == incomingInterface)
791                     \{
792                       sendingSoket = iter->first;
793                     \}
794                 \}
795               \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (sendingSoket, \textcolor{stringliteral}{"HandleRequest - Impossible to find a socket to
       send the reply"});
796 
797               uint16\_t mtu = \hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->GetMtu (incomingInterface);
798               uint16\_t maxRte = (mtu - Ipv4Header ().GetSerializedSize () - UdpHeader ().GetSerializedSize 
      () - RipHeader ().GetSerializedSize ()) / RipRte ().GetSerializedSize ();
799 
800               Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = Create<Packet> ();
801               SocketIpTtlTag tag;
802               p->RemovePacketTag (tag);
803               \textcolor{keywordflow}{if} (senderAddress == Ipv4Address(\hyperlink{rip_8cc_a4088e07a51c9aabba6666b6c1e85f704}{RIP\_ALL\_NODE}))
804                 \{
805                   tag.SetTtl (1);
806                 \}
807               \textcolor{keywordflow}{else}
808                 \{
809                   tag.SetTtl (255);
810                 \}
811               p->AddPacketTag (tag);
812 
813               RipHeader hdr;
814               hdr.SetCommand (\hyperlink{classns3_1_1RipHeader_a8c6ce779ee35c8b65446aaa202a6e789a9f13028e2d4a57da73f592702d7b17c7}{RipHeader::RESPONSE});
815 
816               \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Rip_a8819af4dd44f270b6b19be755b39bce8}{RoutesI} rtIter = \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.begin (); rtIter != 
      \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.end (); rtIter++)
817                 \{
818                   \textcolor{keywordtype}{bool} splitHorizoning = (rtIter->first->GetInterface () == incomingInterface);
819 
820                   Ipv4InterfaceAddress rtDestAddr = Ipv4InterfaceAddress(rtIter->first->GetDestNetwork (), 
      rtIter->first->GetDestNetworkMask ());
821 
822                   \textcolor{keywordtype}{bool} isGlobal = (rtDestAddr.GetScope () == 
      \hyperlink{classns3_1_1Ipv4InterfaceAddress_a329cea433e74f717c26c9e51c4fcd3d8ae144856017bcfb529872c91204d462b2}{Ipv4InterfaceAddress::GLOBAL});
823                   \textcolor{keywordtype}{bool} isDefaultRoute = ((rtIter->first->GetDestNetwork () == 
      \hyperlink{classns3_1_1Ipv4Address_a7a39b330c8e701183a411d5779fca1a4}{Ipv4Address::GetAny} ()) &&
824                       (rtIter->first->GetDestNetworkMask () == \hyperlink{classns3_1_1Ipv4Mask_ac2dda492011ede8350008d753d278998}{Ipv4Mask::GetZero} ()) &&
825                       (rtIter->first->GetInterface () != incomingInterface));
826 
827                   \textcolor{keywordflow}{if} ((isGlobal || isDefaultRoute) &&
828                       (rtIter->first->GetRouteStatus () == 
      \hyperlink{classns3_1_1RipRoutingTableEntry_a4326145be5c3027f2ddf9eb80b6127a4ac29e62da26c18bf4b9caa5224cfee895}{RipRoutingTableEntry::RIP\_VALID}) )
829                     \{
830                       RipRte rte;
831                       rte.SetPrefix (rtIter->first->GetDestNetwork ());
832                       rte.SetSubnetMask (rtIter->first->GetDestNetworkMask ());
833                       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Rip_a2053001529a46356e1f612dfde6b4faf}{m\_splitHorizonStrategy} == 
      \hyperlink{classns3_1_1Rip_aa65e80d926399a90bc81b30dfc9404a4ad6573915007f19810b223a280519eb86}{POISON\_REVERSE} && splitHorizoning)
834                         \{
835                           rte.SetRouteMetric (\hyperlink{classns3_1_1Rip_a3f37d4c5176e380482edf0be82d2fc18}{m\_linkDown});
836                         \}
837                       \textcolor{keywordflow}{else}
838                         \{
839                           rte.SetRouteMetric (rtIter->first->GetRouteMetric ());
840                         \}
841                       rte.SetRouteTag (rtIter->first->GetRouteTag ());
842                       \textcolor{keywordflow}{if} ((\hyperlink{classns3_1_1Rip_a2053001529a46356e1f612dfde6b4faf}{m\_splitHorizonStrategy} != 
      \hyperlink{classns3_1_1Rip_aa65e80d926399a90bc81b30dfc9404a4a37e78b48a284b4248a999e281e8ea5f9}{SPLIT\_HORIZON}) ||
843                           (\hyperlink{classns3_1_1Rip_a2053001529a46356e1f612dfde6b4faf}{m\_splitHorizonStrategy} == 
      \hyperlink{classns3_1_1Rip_aa65e80d926399a90bc81b30dfc9404a4a37e78b48a284b4248a999e281e8ea5f9}{SPLIT\_HORIZON} && !splitHorizoning))
844                         \{
845                           hdr.AddRte (rte);
846                         \}
847                     \}
848                   \textcolor{keywordflow}{if} (hdr.GetRteNumber () == maxRte)
849                     \{
850                       p->AddHeader (hdr);
851                       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"SendTo: "} << *p);
852                       sendingSoket->SendTo (p, 0, InetSocketAddress (senderAddress, 
      \hyperlink{rip_8cc_a6af26a435808c34ee4f8876792a5682a}{RIP\_PORT}));
853                       p->RemoveHeader (hdr);
854                       hdr.ClearRtes ();
855                     \}
856                 \}
857               \textcolor{keywordflow}{if} (hdr.GetRteNumber () > 0)
858                 \{
859                   p->AddHeader (hdr);
860                   \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"SendTo: "} << *p);
861                   sendingSoket->SendTo (p, 0, InetSocketAddress (senderAddress, 
      \hyperlink{rip_8cc_a6af26a435808c34ee4f8876792a5682a}{RIP\_PORT}));
862                 \}
863             \}
864         \}
865     \}
866   \textcolor{keywordflow}{else}
867     \{
868       \textcolor{comment}{// note: we got the request as a single packet, so no check is necessary for MTU limit}
869 
870       Ptr<Packet> p = Create<Packet> ();
871       SocketIpTtlTag tag;
872       p->RemovePacketTag (tag);
873       \textcolor{keywordflow}{if} (senderAddress == Ipv4Address(\hyperlink{rip_8cc_a4088e07a51c9aabba6666b6c1e85f704}{RIP\_ALL\_NODE}))
874         \{
875           tag.SetTtl (1);
876         \}
877       \textcolor{keywordflow}{else}
878         \{
879           tag.SetTtl (255);
880         \}
881       p->AddPacketTag (tag);
882 
883       RipHeader hdr;
884       hdr.SetCommand (\hyperlink{classns3_1_1RipHeader_a8c6ce779ee35c8b65446aaa202a6e789a9f13028e2d4a57da73f592702d7b17c7}{RipHeader::RESPONSE});
885 
886       \textcolor{keywordflow}{for} (std::list<RipRte>::iterator iter = rtes.begin ();
887           iter != rtes.end (); iter++)
888         \{
889           \textcolor{keywordtype}{bool} found = \textcolor{keyword}{false};
890           \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Rip_a8819af4dd44f270b6b19be755b39bce8}{RoutesI} rtIter = \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.begin (); rtIter != 
      \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.end (); rtIter++)
891             \{
892 
893               Ipv4InterfaceAddress rtDestAddr = Ipv4InterfaceAddress (rtIter->first->GetDestNetwork (), 
      rtIter->first->GetDestNetworkMask ());
894               \textcolor{keywordflow}{if} ((rtDestAddr.GetScope () == \hyperlink{classns3_1_1Ipv4InterfaceAddress_a329cea433e74f717c26c9e51c4fcd3d8ae144856017bcfb529872c91204d462b2}{Ipv4InterfaceAddress::GLOBAL}) &&
895                   (rtIter->first->GetRouteStatus () == 
      \hyperlink{classns3_1_1RipRoutingTableEntry_a4326145be5c3027f2ddf9eb80b6127a4ac29e62da26c18bf4b9caa5224cfee895}{RipRoutingTableEntry::RIP\_VALID}))
896                 \{
897                   Ipv4Address requestedAddress = iter->GetPrefix ();
898                   requestedAddress.CombineMask (iter->GetSubnetMask ());
899                   Ipv4Address rtAddress = rtIter->first->GetDestNetwork ();
900                   rtAddress.CombineMask (rtIter->first->GetDestNetworkMask ());
901 
902                   \textcolor{keywordflow}{if} (requestedAddress == rtAddress)
903                     \{
904                       iter->SetRouteMetric (rtIter->first->GetRouteMetric ());
905                       iter->SetRouteTag (rtIter->first->GetRouteTag ());
906                       hdr.AddRte (*iter);
907                       found = \textcolor{keyword}{true};
908                       \textcolor{keywordflow}{break};
909                     \}
910                 \}
911             \}
912           \textcolor{keywordflow}{if} (!found)
913             \{
914               iter->SetRouteMetric (\hyperlink{classns3_1_1Rip_a3f37d4c5176e380482edf0be82d2fc18}{m\_linkDown});
915               iter->SetRouteTag (0);
916               hdr.AddRte (*iter);
917             \}
918         \}
919       p->AddHeader (hdr);
920       \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"SendTo: "} << *p);
921       \hyperlink{classns3_1_1Rip_a6c5dc1b74475e3caa0782f37b722be6b}{m\_recvSocket}->\hyperlink{classns3_1_1Socket_af898fce6a58e0dbba23c1c6de1d4220e}{SendTo} (p, 0, InetSocketAddress (senderAddress, senderPort));
922     \}
923 
924 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13




Here is the caller graph for this function\+:
% FIG 14


\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Handle\+Responses@{Handle\+Responses}}
\index{Handle\+Responses@{Handle\+Responses}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Handle\+Responses(\+Rip\+Header hdr, Ipv4\+Address sender\+Address, uint32\+\_\+t incoming\+Interface, uint8\+\_\+t hop\+Limit)}{HandleResponses(RipHeader hdr, Ipv4Address senderAddress, uint32_t incomingInterface, uint8_t hopLimit)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+::\+Handle\+Responses (
\begin{DoxyParamCaption}
\item[{{\bf Rip\+Header}}]{hdr, }
\item[{{\bf Ipv4\+Address}}]{sender\+Address, }
\item[{uint32\+\_\+t}]{incoming\+Interface, }
\item[{uint8\+\_\+t}]{hop\+Limit}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_afb817ee04f919351a35b466ea6d75c56}{}\label{classns3_1_1Rip_afb817ee04f919351a35b466ea6d75c56}


Handle R\+IP responses. 


\begin{DoxyParams}{Parameters}
{\em hdr} & message header (including R\+T\+Es) \\
\hline
{\em sender\+Address} & sender address \\
\hline
{\em incoming\+Interface} & incoming interface \\
\hline
{\em hop\+Limit} & packet\textquotesingle{}s hop limit \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
927 \{
928   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << senderAddress << incomingInterface << \textcolor{keywordtype}{int} (hopLimit) << hdr);
929 
930   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Rip_a30e2c00645f24a3b29be981f5d592773}{m\_interfaceExclusions}.find (incomingInterface) != 
      \hyperlink{classns3_1_1Rip_a30e2c00645f24a3b29be981f5d592773}{m\_interfaceExclusions}.end ())
931     \{
932       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Ignoring an update message from an excluded interface: "} << 
      incomingInterface);
933       \textcolor{keywordflow}{return};
934     \}
935 
936   std::list<RipRte> rtes = hdr.GetRteList ();
937 
938   \textcolor{comment}{// validate the RTEs before processing}
939   \textcolor{keywordflow}{for} (std::list<RipRte>::iterator iter = rtes.begin ();
940       iter != rtes.end (); iter++)
941     \{
942       \textcolor{keywordflow}{if} (iter->GetRouteMetric () == 0 || iter->GetRouteMetric () > \hyperlink{classns3_1_1Rip_a3f37d4c5176e380482edf0be82d2fc18}{m\_linkDown})
943         \{
944           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Ignoring an update message with malformed metric: "} << \textcolor{keywordtype}{int} (iter->
      GetRouteMetric ()));
945           \textcolor{keywordflow}{return};
946         \}
947       \textcolor{keywordflow}{if} (iter->GetPrefix ().IsLocalhost () ||
948           iter->GetPrefix ().IsBroadcast () ||
949           iter->GetPrefix ().IsMulticast ())
950         \{
951           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Ignoring an update message with wrong prefixes: "} << iter->GetPrefix (
      ));
952           \textcolor{keywordflow}{return};
953         \}
954     \}
955 
956   \textcolor{keywordtype}{bool} changed = \textcolor{keyword}{false};
957 
958   \textcolor{keywordflow}{for} (std::list<RipRte>::iterator iter = rtes.begin ();
959       iter != rtes.end (); iter++)
960     \{
961       Ipv4Mask rtePrefixMask = iter->GetSubnetMask ();
962       Ipv4Address rteAddr = iter->GetPrefix ().CombineMask (rtePrefixMask);
963 
964       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Processing RTE "} << *iter);
965 
966       uint32\_t interfaceMetric = 1;
967       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Rip_a297aac5454b10e21644490335f72364a}{m\_interfaceMetrics}.find (incomingInterface) != 
      \hyperlink{classns3_1_1Rip_a297aac5454b10e21644490335f72364a}{m\_interfaceMetrics}.end ())
968         \{
969           interfaceMetric = \hyperlink{classns3_1_1Rip_a297aac5454b10e21644490335f72364a}{m\_interfaceMetrics}[incomingInterface];
970         \}
971       uint64\_t rteMetric = iter->GetRouteMetric () + interfaceMetric;
972       \textcolor{keywordflow}{if} (rteMetric > \hyperlink{classns3_1_1Rip_a3f37d4c5176e380482edf0be82d2fc18}{m\_linkDown})
973         \{
974           rteMetric = \hyperlink{classns3_1_1Rip_a3f37d4c5176e380482edf0be82d2fc18}{m\_linkDown};
975         \}
976 
977       \hyperlink{classns3_1_1Rip_a8819af4dd44f270b6b19be755b39bce8}{RoutesI} it;
978       \textcolor{keywordtype}{bool} found = \textcolor{keyword}{false};
979       \textcolor{keywordflow}{for} (it = \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.begin (); it != \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.end (); it++)
980         \{
981           \textcolor{keywordflow}{if} (it->first->GetDestNetwork () == rteAddr &&
982               it->first->GetDestNetworkMask () == rtePrefixMask)
983             \{
984               found = \textcolor{keyword}{true};
985               \textcolor{keywordflow}{if} (rteMetric < it->first->GetRouteMetric ())
986                 \{
987                   \textcolor{keywordflow}{if} (senderAddress != it->first->GetGateway ())
988                     \{
989                       RipRoutingTableEntry* route = \textcolor{keyword}{new} RipRoutingTableEntry (rteAddr, rtePrefixMask, 
      senderAddress, incomingInterface);
990                       \textcolor{keyword}{delete} it->first;
991                       it->first = route;
992                     \}
993                   it->first->SetRouteMetric (rteMetric);
994                   it->first->SetRouteStatus (\hyperlink{classns3_1_1RipRoutingTableEntry_a4326145be5c3027f2ddf9eb80b6127a4ac29e62da26c18bf4b9caa5224cfee895}{RipRoutingTableEntry::RIP\_VALID}
      );
995                   it->first->SetRouteTag (iter->GetRouteTag ());
996                   it->first->SetRouteChanged (\textcolor{keyword}{true});
997                   it->second.Cancel ();
998                   it->second = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (
      \hyperlink{classns3_1_1Rip_a8a684a47271e0e382dd5f485a8a5545b}{m\_timeoutDelay}, &\hyperlink{classns3_1_1Rip_a48b295877e349360bf978c250ae59083}{Rip::InvalidateRoute}, \textcolor{keyword}{this}, it->first);
999                   changed = \textcolor{keyword}{true};
1000                 \}
1001               \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (rteMetric == it->first->GetRouteMetric ())
1002                 \{
1003                   \textcolor{keywordflow}{if} (senderAddress == it->first->GetGateway ())
1004                     \{
1005                       it->second.Cancel ();
1006                       it->second = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (
      \hyperlink{classns3_1_1Rip_a8a684a47271e0e382dd5f485a8a5545b}{m\_timeoutDelay}, &\hyperlink{classns3_1_1Rip_a48b295877e349360bf978c250ae59083}{Rip::InvalidateRoute}, \textcolor{keyword}{this}, it->first);
1007                     \}
1008                   \textcolor{keywordflow}{else}
1009                     \{
1010                       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Simulator_af2c7b4285454aa5062bd2df2bb7a7ab9}{Simulator::GetDelayLeft} (it->second) < 
      \hyperlink{classns3_1_1Rip_a8a684a47271e0e382dd5f485a8a5545b}{m\_timeoutDelay}/2)
1011                         \{
1012                           RipRoutingTableEntry* route = \textcolor{keyword}{new} RipRoutingTableEntry (rteAddr, rtePrefixMask, 
      senderAddress, incomingInterface);
1013                           route->SetRouteMetric (rteMetric);
1014                           route->SetRouteStatus (\hyperlink{classns3_1_1RipRoutingTableEntry_a4326145be5c3027f2ddf9eb80b6127a4ac29e62da26c18bf4b9caa5224cfee895}{RipRoutingTableEntry::RIP\_VALID}
      );
1015                           route->SetRouteTag (iter->GetRouteTag ());
1016                           route->SetRouteChanged (\textcolor{keyword}{true});
1017                           \textcolor{keyword}{delete} it->first;
1018                           it->first = route;
1019                           it->second.Cancel ();
1020                           it->second = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (
      \hyperlink{classns3_1_1Rip_a8a684a47271e0e382dd5f485a8a5545b}{m\_timeoutDelay}, &\hyperlink{classns3_1_1Rip_a48b295877e349360bf978c250ae59083}{Rip::InvalidateRoute}, \textcolor{keyword}{this}, route);
1021                           changed = \textcolor{keyword}{true};
1022                         \}
1023                     \}
1024                 \}
1025               \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (rteMetric > it->first->GetRouteMetric () && senderAddress == it->first->GetGateway (
      ))
1026                 \{
1027                   it->second.Cancel ();
1028                   \textcolor{keywordflow}{if} (rteMetric < \hyperlink{classns3_1_1Rip_a3f37d4c5176e380482edf0be82d2fc18}{m\_linkDown})
1029                     \{
1030                       it->first->SetRouteMetric (rteMetric);
1031                       it->first->SetRouteStatus (\hyperlink{classns3_1_1RipRoutingTableEntry_a4326145be5c3027f2ddf9eb80b6127a4ac29e62da26c18bf4b9caa5224cfee895}{RipRoutingTableEntry::RIP\_VALID}
      );
1032                       it->first->SetRouteTag (iter->GetRouteTag ());
1033                       it->first->SetRouteChanged (\textcolor{keyword}{true});
1034                       it->second.Cancel ();
1035                       it->second = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (
      \hyperlink{classns3_1_1Rip_a8a684a47271e0e382dd5f485a8a5545b}{m\_timeoutDelay}, &\hyperlink{classns3_1_1Rip_a48b295877e349360bf978c250ae59083}{Rip::InvalidateRoute}, \textcolor{keyword}{this}, it->first);
1036                     \}
1037                   \textcolor{keywordflow}{else}
1038                     \{
1039                       \hyperlink{classns3_1_1Rip_a48b295877e349360bf978c250ae59083}{InvalidateRoute} (it->first);
1040                     \}
1041                   changed = \textcolor{keyword}{true};
1042                 \}
1043             \}
1044         \}
1045       \textcolor{keywordflow}{if} (!found && rteMetric != \hyperlink{classns3_1_1Rip_a3f37d4c5176e380482edf0be82d2fc18}{m\_linkDown})
1046         \{
1047           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Received a RTE with new route, adding."});
1048 
1049           RipRoutingTableEntry* route = \textcolor{keyword}{new} RipRoutingTableEntry (rteAddr, rtePrefixMask, senderAddress, 
      incomingInterface);
1050           route->SetRouteMetric (rteMetric);
1051           route->SetRouteStatus (\hyperlink{classns3_1_1RipRoutingTableEntry_a4326145be5c3027f2ddf9eb80b6127a4ac29e62da26c18bf4b9caa5224cfee895}{RipRoutingTableEntry::RIP\_VALID});
1052           route->SetRouteChanged (\textcolor{keyword}{true});
1053           \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.push\_front (std::make\_pair (route, EventId ()));
1054           EventId invalidateEvent = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (
      \hyperlink{classns3_1_1Rip_a8a684a47271e0e382dd5f485a8a5545b}{m\_timeoutDelay}, &\hyperlink{classns3_1_1Rip_a48b295877e349360bf978c250ae59083}{Rip::InvalidateRoute}, \textcolor{keyword}{this}, route);
1055           (\hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.begin ())->second = invalidateEvent;
1056           changed = \textcolor{keyword}{true};
1057         \}
1058     \}
1059 
1060   \textcolor{keywordflow}{if} (changed)
1061     \{
1062       \hyperlink{classns3_1_1Rip_aee5d3efe6b4dbcd128018f49b981fd7c}{SendTriggeredRouteUpdate} ();
1063     \}
1064 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 15




Here is the caller graph for this function\+:
% FIG 16


\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Invalidate\+Route@{Invalidate\+Route}}
\index{Invalidate\+Route@{Invalidate\+Route}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Invalidate\+Route(\+Rip\+Routing\+Table\+Entry $\ast$route)}{InvalidateRoute(RipRoutingTableEntry *route)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+::\+Invalidate\+Route (
\begin{DoxyParamCaption}
\item[{{\bf Rip\+Routing\+Table\+Entry} $\ast$}]{route}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_a48b295877e349360bf978c250ae59083}{}\label{classns3_1_1Rip_a48b295877e349360bf978c250ae59083}


Invalidate a route. 


\begin{DoxyParams}{Parameters}
{\em route} & the route to be removed \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
672 \{
673   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << *route);
674 
675   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Rip_a8819af4dd44f270b6b19be755b39bce8}{RoutesI} it = \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.begin (); it != \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.end (); it++)
676     \{
677       \textcolor{keywordflow}{if} (it->first == route)
678         \{
679           route->SetRouteStatus (\hyperlink{classns3_1_1RipRoutingTableEntry_a4326145be5c3027f2ddf9eb80b6127a4a96a2866435ab2919ee08c3291c1411ba}{RipRoutingTableEntry::RIP\_INVALID});
680           route->SetRouteMetric (\hyperlink{classns3_1_1Rip_a3f37d4c5176e380482edf0be82d2fc18}{m\_linkDown});
681           route->SetRouteChanged (\textcolor{keyword}{true});
682           \textcolor{keywordflow}{if} (it->second.IsRunning ())
683             \{
684               it->second.Cancel ();
685             \}
686           it->second = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (
      \hyperlink{classns3_1_1Rip_ad317e92ae9d78b20642be47df4e8d866}{m\_garbageCollectionDelay}, &\hyperlink{classns3_1_1Rip_a4613413ac628e8313c26d5ea6ed99761}{Rip::DeleteRoute}, \textcolor{keyword}{this}, route);
687           \textcolor{keywordflow}{return};
688         \}
689     \}
690   \hyperlink{group__fatal_ga51ac4699be799d772ae7258d1ef6af21}{NS\_ABORT\_MSG} (\textcolor{stringliteral}{"RIP::InvalidateRoute - cannot find the route to update"});
691 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 17




Here is the caller graph for this function\+:
% FIG 18


\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Lookup@{Lookup}}
\index{Lookup@{Lookup}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Lookup(\+Ipv4\+Address dest, Ptr$<$ Net\+Device $>$=0)}{Lookup(Ipv4Address dest, Ptr< NetDevice >=0)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv4\+Route} $>$ ns3\+::\+Rip\+::\+Lookup (
\begin{DoxyParamCaption}
\item[{{\bf Ipv4\+Address}}]{dest, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{interface = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_a50d486fb2eee757bb9f9d528d3828dab}{}\label{classns3_1_1Rip_a50d486fb2eee757bb9f9d528d3828dab}


Lookup in the forwarding table for destination. 


\begin{DoxyParams}{Parameters}
{\em dest} & destination address \\
\hline
{\em interface} & output interface if any (put 0 otherwise) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{classns3_1_1Ipv4Route}{Ipv4\+Route} to route the packet to reach dest address 
\end{DoxyReturn}

\begin{DoxyCode}
574 \{
575   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << dst << interface);
576 
577   Ptr<Ipv4Route> rtentry = 0;
578   uint16\_t longestMask = 0;
579 
580   \textcolor{comment}{/* when sending on local multicast, there have to be interface specified */}
581   \textcolor{keywordflow}{if} (dst.IsLocalMulticast ())
582     \{
583       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (interface, \textcolor{stringliteral}{"Try to send on local multicast address, and no interface
       index is given!"});
584       rtentry = Create<Ipv4Route> ();
585       rtentry->SetSource (\hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->SourceAddressSelection (\hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->GetInterfaceForDevice (
      interface), dst));
586       rtentry->SetDestination (dst);
587       rtentry->SetGateway (\hyperlink{classns3_1_1Ipv4Address_aeeb1c76b35d4ab612fda7bc51e99c5db}{Ipv4Address::GetZero} ());
588       rtentry->SetOutputDevice (interface);
589       \textcolor{keywordflow}{return} rtentry;
590     \}
591 
592   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Rip_a8819af4dd44f270b6b19be755b39bce8}{RoutesI} it = \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.begin (); it != \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.end (); it++)
593     \{
594       RipRoutingTableEntry* j = it->first;
595 
596       \textcolor{keywordflow}{if} (j->GetRouteStatus () == \hyperlink{classns3_1_1RipRoutingTableEntry_a4326145be5c3027f2ddf9eb80b6127a4ac29e62da26c18bf4b9caa5224cfee895}{RipRoutingTableEntry::RIP\_VALID})
597         \{
598           Ipv4Mask mask = j->GetDestNetworkMask ();
599           uint16\_t maskLen = mask.GetPrefixLength ();
600           Ipv4Address entry = j->GetDestNetwork ();
601 
602           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Searching for route to "} << dst << \textcolor{stringliteral}{", mask length "} << maskLen);
603 
604           \textcolor{keywordflow}{if} (mask.IsMatch (dst, entry))
605             \{
606               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Found global network route "} << j << \textcolor{stringliteral}{", mask length "} << maskLen);
607 
608               \textcolor{comment}{/* if interface is given, check the route will output on this interface */}
609               \textcolor{keywordflow}{if} (!interface || interface == \hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->GetNetDevice (j->GetInterface ()))
610                 \{
611                   \textcolor{keywordflow}{if} (maskLen < longestMask)
612                     \{
613                       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Previous match longer, skipping"});
614                       \textcolor{keywordflow}{continue};
615                     \}
616 
617                   longestMask = maskLen;
618 
619                   Ipv4RoutingTableEntry* route = j;
620                   uint32\_t interfaceIdx = route->GetInterface ();
621                   rtentry = Create<Ipv4Route> ();
622 
623                   \textcolor{keywordflow}{if} (route->GetDest ().IsAny ()) \textcolor{comment}{/* default route */}
624                     \{
625                       rtentry->SetSource (\hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->SourceAddressSelection (interfaceIdx, route->
      GetGateway ()));
626                     \}
627                   \textcolor{keywordflow}{else}
628                     \{
629                       rtentry->SetSource (\hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->SourceAddressSelection (interfaceIdx, route->
      GetDest ()));
630                     \}
631 
632                   rtentry->SetDestination (route->GetDest ());
633                   rtentry->SetGateway (route->GetGateway ());
634                   rtentry->SetOutputDevice (\hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->GetNetDevice (interfaceIdx));
635                 \}
636             \}
637         \}
638     \}
639 
640   \textcolor{keywordflow}{if} (rtentry)
641     \{
642       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Matching route via "} << rtentry->GetDestination () << \textcolor{stringliteral}{" (through "} << 
      rtentry->GetGateway () << \textcolor{stringliteral}{") at the end"});
643     \}
644   \textcolor{keywordflow}{return} rtentry;
645 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 19




Here is the caller graph for this function\+:
% FIG 20


\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Notify\+Add\+Address@{Notify\+Add\+Address}}
\index{Notify\+Add\+Address@{Notify\+Add\+Address}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Notify\+Add\+Address(uint32\+\_\+t interface, Ipv4\+Interface\+Address address)}{NotifyAddAddress(uint32_t interface, Ipv4InterfaceAddress address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+::\+Notify\+Add\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv4\+Interface\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Rip_a9ef274a74f46abf3c118d935d33f02fe}{}\label{classns3_1_1Rip_a9ef274a74f46abf3c118d935d33f02fe}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
{\em address} & a new address being added to an interface\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified whenever a new address is added to an interface. Typically used to add a \textquotesingle{}network route\textquotesingle{} on an interface. Can be invoked on an up or down interface. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_aef12fcf9cc478536876b0281505d40aa}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
403 \{
404   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << interface << address);
405 
406   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->IsUp (interface))
407     \{
408       \textcolor{keywordflow}{return};
409     \}
410 
411   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Rip_a30e2c00645f24a3b29be981f5d592773}{m\_interfaceExclusions}.find (interface) != 
      \hyperlink{classns3_1_1Rip_a30e2c00645f24a3b29be981f5d592773}{m\_interfaceExclusions}.end ())
412     \{
413       \textcolor{keywordflow}{return};
414     \}
415 
416   Ipv4Address networkAddress = address.GetLocal ().CombineMask (address.GetMask ());
417   Ipv4Mask networkMask = address.GetMask ();
418 
419   \textcolor{keywordflow}{if} (address.GetScope () == \hyperlink{classns3_1_1Ipv4InterfaceAddress_a329cea433e74f717c26c9e51c4fcd3d8ae144856017bcfb529872c91204d462b2}{Ipv4InterfaceAddress::GLOBAL})
420     \{
421       \hyperlink{classns3_1_1Rip_a8aa9415f65e5fb8abaa6af5c93446231}{AddNetworkRouteTo} (networkAddress, networkMask, interface);
422     \}
423 
424   \hyperlink{classns3_1_1Rip_aee5d3efe6b4dbcd128018f49b981fd7c}{SendTriggeredRouteUpdate} ();
425 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 21


\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Notify\+Interface\+Down@{Notify\+Interface\+Down}}
\index{Notify\+Interface\+Down@{Notify\+Interface\+Down}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Notify\+Interface\+Down(uint32\+\_\+t interface)}{NotifyInterfaceDown(uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+::\+Notify\+Interface\+Down (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Rip_a10fb1463467f08556e7a3e75c98447bc}{}\label{classns3_1_1Rip_a10fb1463467f08556e7a3e75c98447bc}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified of the state change of an interface in a node. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a90f728b73ccb1806e5a4093ff156f607}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
372 \{
373   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << interface);
374 
375   \textcolor{comment}{/* remove all routes that are going through this interface */}
376   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Rip_a8819af4dd44f270b6b19be755b39bce8}{RoutesI} it = \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.begin (); it != \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.end (); it++)
377     \{
378       \textcolor{keywordflow}{if} (it->first->GetInterface () == interface)
379         \{
380           \hyperlink{classns3_1_1Rip_a48b295877e349360bf978c250ae59083}{InvalidateRoute} (it->first);
381         \}
382     \}
383 
384   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Rip_a0395b3977eeeb90190ccfa5758a3957f}{SocketListI} iter = \hyperlink{classns3_1_1Rip_a58b5f6ebcee2ed04249fd025abfa61cb}{m\_sendSocketList}.begin (); iter != 
      \hyperlink{classns3_1_1Rip_a58b5f6ebcee2ed04249fd025abfa61cb}{m\_sendSocketList}.end (); iter++ )
385     \{
386       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Checking socket for interface "} << interface);
387       \textcolor{keywordflow}{if} (iter->second == interface)
388         \{
389           \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Removed socket for interface "} << interface);
390           iter->first->Close ();
391           \hyperlink{classns3_1_1Rip_a58b5f6ebcee2ed04249fd025abfa61cb}{m\_sendSocketList}.erase (iter);
392           \textcolor{keywordflow}{break};
393         \}
394     \}
395 
396   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Rip_a30e2c00645f24a3b29be981f5d592773}{m\_interfaceExclusions}.find (interface) == 
      \hyperlink{classns3_1_1Rip_a30e2c00645f24a3b29be981f5d592773}{m\_interfaceExclusions}.end ())
397     \{
398       \hyperlink{classns3_1_1Rip_aee5d3efe6b4dbcd128018f49b981fd7c}{SendTriggeredRouteUpdate} ();
399     \}
400 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 22




Here is the caller graph for this function\+:
% FIG 23


\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Notify\+Interface\+Up@{Notify\+Interface\+Up}}
\index{Notify\+Interface\+Up@{Notify\+Interface\+Up}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Notify\+Interface\+Up(uint32\+\_\+t interface)}{NotifyInterfaceUp(uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+::\+Notify\+Interface\+Up (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Rip_a4c9095a4429399f342eb1bce3f20df59}{}\label{classns3_1_1Rip_a4c9095a4429399f342eb1bce3f20df59}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified of the state change of an interface in a node. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_aabb99ce7a048e75ff4b36fa9af8745e4}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
291 \{
292   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
293 
294   Ptr<LoopbackNetDevice> \hyperlink{namespacevisualizer_1_1higcontainer_ac48d36b2f857bd4ef93244235f447292}{check} = DynamicCast<LoopbackNetDevice> (\hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->GetNetDevice (
      \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}));
295   \textcolor{keywordflow}{if} (check)
296     \{
297       \textcolor{keywordflow}{return};
298     \}
299 
300   \textcolor{keywordflow}{for} (uint32\_t j = 0; j < \hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->GetNAddresses (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}); j++)
301     \{
302       Ipv4InterfaceAddress address = \hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, j);
303       Ipv4Mask networkMask = address.GetMask ();
304       Ipv4Address networkAddress = address.GetLocal ().CombineMask (networkMask);
305 
306       \textcolor{keywordflow}{if} (address.GetScope () == \hyperlink{classns3_1_1Ipv4InterfaceAddress_a329cea433e74f717c26c9e51c4fcd3d8ae144856017bcfb529872c91204d462b2}{Ipv4InterfaceAddress::GLOBAL})
307         \{
308           \hyperlink{classns3_1_1Rip_a8aa9415f65e5fb8abaa6af5c93446231}{AddNetworkRouteTo} (networkAddress, networkMask, \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
309         \}
310     \}
311 
312   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1Rip_adb494e48f6b5e4e42bf47a8ad3a25485}{m\_initialized})
313     \{
314       \textcolor{keywordflow}{return};
315     \}
316 
317 
318   \textcolor{keywordtype}{bool} sendSocketFound = \textcolor{keyword}{false};
319   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Rip_a0395b3977eeeb90190ccfa5758a3957f}{SocketListI} iter = \hyperlink{classns3_1_1Rip_a58b5f6ebcee2ed04249fd025abfa61cb}{m\_sendSocketList}.begin (); iter != 
      \hyperlink{classns3_1_1Rip_a58b5f6ebcee2ed04249fd025abfa61cb}{m\_sendSocketList}.end (); iter++ )
320     \{
321       \textcolor{keywordflow}{if} (iter->second == \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
322         \{
323           sendSocketFound = \textcolor{keyword}{true};
324           \textcolor{keywordflow}{break};
325         \}
326     \}
327 
328   \textcolor{keywordtype}{bool} activeInterface = \textcolor{keyword}{false};
329   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Rip_a30e2c00645f24a3b29be981f5d592773}{m\_interfaceExclusions}.find (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) == 
      \hyperlink{classns3_1_1Rip_a30e2c00645f24a3b29be981f5d592773}{m\_interfaceExclusions}.end ())
330     \{
331       activeInterface = \textcolor{keyword}{true};
332       \hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->SetForwarding (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, \textcolor{keyword}{true});
333     \}
334 
335   \textcolor{keywordflow}{for} (uint32\_t j = 0; j < \hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->GetNAddresses (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}); j++)
336     \{
337       Ipv4InterfaceAddress address = \hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->GetAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, j);
338 
339       \textcolor{keywordflow}{if} (address.GetScope() != \hyperlink{classns3_1_1Ipv4InterfaceAddress_a329cea433e74f717c26c9e51c4fcd3d8a7276e171c0232cceba24502099750890}{Ipv4InterfaceAddress::HOST} && sendSocketFound == \textcolor{keyword}{
      false} && activeInterface == \textcolor{keyword}{true})
340         \{
341           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"RIP: adding sending socket to "} << address.GetLocal ());
342           TypeId tid = \hyperlink{classns3_1_1TypeId_a119cf99c20931fdc294602cd360b180e}{TypeId::LookupByName} (\textcolor{stringliteral}{"ns3::UdpSocketFactory"});
343           Ptr<Node> theNode = GetObject<Node> ();
344           Ptr<Socket> socket = \hyperlink{classns3_1_1Socket_ad448a62bb50ad3dbac59c879a885a8d2}{Socket::CreateSocket} (theNode, tid);
345           InetSocketAddress local = InetSocketAddress (address.GetLocal (), 
      \hyperlink{rip_8cc_a6af26a435808c34ee4f8876792a5682a}{RIP\_PORT});
346           socket->Bind (local);
347           socket->BindToNetDevice (\hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->GetNetDevice (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}));
348           socket->SetIpRecvTtl (\textcolor{keyword}{true});
349           \hyperlink{classns3_1_1Rip_a58b5f6ebcee2ed04249fd025abfa61cb}{m\_sendSocketList}[socket] = \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
350         \}
351       \textcolor{keywordflow}{if} (address.GetScope () == \hyperlink{classns3_1_1Ipv4InterfaceAddress_a329cea433e74f717c26c9e51c4fcd3d8ae144856017bcfb529872c91204d462b2}{Ipv4InterfaceAddress::GLOBAL})
352         \{
353           \hyperlink{classns3_1_1Rip_aee5d3efe6b4dbcd128018f49b981fd7c}{SendTriggeredRouteUpdate} ();
354         \}
355     \}
356 
357   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1Rip_a6c5dc1b74475e3caa0782f37b722be6b}{m\_recvSocket})
358     \{
359       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"RIP: adding receiving socket"});
360       TypeId tid = \hyperlink{classns3_1_1TypeId_a119cf99c20931fdc294602cd360b180e}{TypeId::LookupByName} (\textcolor{stringliteral}{"ns3::UdpSocketFactory"});
361       Ptr<Node> theNode = GetObject<Node> ();
362       \hyperlink{classns3_1_1Rip_a6c5dc1b74475e3caa0782f37b722be6b}{m\_recvSocket} = \hyperlink{classns3_1_1Socket_ad448a62bb50ad3dbac59c879a885a8d2}{Socket::CreateSocket} (theNode, tid);
363       InetSocketAddress local = InetSocketAddress (\hyperlink{rip_8cc_a4088e07a51c9aabba6666b6c1e85f704}{RIP\_ALL\_NODE}, 
      \hyperlink{rip_8cc_a6af26a435808c34ee4f8876792a5682a}{RIP\_PORT});
364       m\_recvSocket->Bind (local);
365       m\_recvSocket->SetRecvCallback (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&\hyperlink{classns3_1_1Rip_a49acadfb3b533118276481a0d231406e}{Rip::Receive}, \textcolor{keyword}{this}));
366       m\_recvSocket->SetIpRecvTtl (\textcolor{keyword}{true});
367       m\_recvSocket->SetRecvPktInfo (\textcolor{keyword}{true});
368     \}
369 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 24




Here is the caller graph for this function\+:
% FIG 25


\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Notify\+Remove\+Address@{Notify\+Remove\+Address}}
\index{Notify\+Remove\+Address@{Notify\+Remove\+Address}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Notify\+Remove\+Address(uint32\+\_\+t interface, Ipv4\+Interface\+Address address)}{NotifyRemoveAddress(uint32_t interface, Ipv4InterfaceAddress address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+::\+Notify\+Remove\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv4\+Interface\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Rip_a63c4ba062a5805aef7887d7dca5d1ff9}{}\label{classns3_1_1Rip_a63c4ba062a5805aef7887d7dca5d1ff9}

\begin{DoxyParams}{Parameters}
{\em interface} & the index of the interface we are being notified about \\
\hline
{\em address} & a new address being added to an interface\\
\hline
\end{DoxyParams}
Protocols are expected to implement this method to be notified whenever a new address is removed from an interface. Typically used to remove the \textquotesingle{}network route\textquotesingle{} of an interface. Can be invoked on an up or down interface. 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a0160e49e509d6699ec837e5485f65cd2}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
428 \{
429   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << interface << address);
430 
431   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->IsUp (interface))
432     \{
433       \textcolor{keywordflow}{return};
434     \}
435 
436   \textcolor{keywordflow}{if} (address.GetScope() != \hyperlink{classns3_1_1Ipv4InterfaceAddress_a329cea433e74f717c26c9e51c4fcd3d8ae144856017bcfb529872c91204d462b2}{Ipv4InterfaceAddress::GLOBAL})
437     \{
438       \textcolor{keywordflow}{return};
439     \}
440 
441   Ipv4Address networkAddress = address.GetLocal ().CombineMask (address.GetMask ());
442   Ipv4Mask networkMask = address.GetMask ();
443 
444   \textcolor{comment}{// Remove all routes that are going through this interface}
445   \textcolor{comment}{// which reference this network}
446   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Rip_a8819af4dd44f270b6b19be755b39bce8}{RoutesI} it = \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.begin (); it != \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.end (); it++)
447     \{
448       \textcolor{keywordflow}{if} (it->first->GetInterface () == interface
449           && it->first->IsNetwork ()
450           && it->first->GetDestNetwork () == networkAddress
451           && it->first->GetDestNetworkMask () == networkMask)
452         \{
453           \hyperlink{classns3_1_1Rip_a48b295877e349360bf978c250ae59083}{InvalidateRoute} (it->first);
454         \}
455     \}
456 
457   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Rip_a30e2c00645f24a3b29be981f5d592773}{m\_interfaceExclusions}.find (interface) == 
      \hyperlink{classns3_1_1Rip_a30e2c00645f24a3b29be981f5d592773}{m\_interfaceExclusions}.end ())
458     \{
459       \hyperlink{classns3_1_1Rip_aee5d3efe6b4dbcd128018f49b981fd7c}{SendTriggeredRouteUpdate} ();
460     \}
461 
462 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 26


\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Print\+Routing\+Table@{Print\+Routing\+Table}}
\index{Print\+Routing\+Table@{Print\+Routing\+Table}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Print\+Routing\+Table(\+Ptr$<$ Output\+Stream\+Wrapper $>$ stream, Time\+::\+Unit unit=\+Time\+::\+S) const }{PrintRoutingTable(Ptr< OutputStreamWrapper > stream, Time::Unit unit=Time::S) const }}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+::\+Print\+Routing\+Table (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Output\+Stream\+Wrapper} $>$}]{stream, }
\item[{{\bf Time\+::\+Unit}}]{unit = {\ttfamily {\bf Time\+::S}}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Rip_ab1ac007cf3e796e4e7bc815c942a6ff5}{}\label{classns3_1_1Rip_ab1ac007cf3e796e4e7bc815c942a6ff5}


Print the Routing Table entries. 


\begin{DoxyParams}{Parameters}
{\em stream} & The ostream the Routing table is printed to \\
\hline
{\em unit} & The time unit to be used in the report \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a86ad3fc1d17b06b6553a13b03d7e8cb4}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
486 \{
487   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << stream);
488 
489   std::ostream* os = stream->\hyperlink{classns3_1_1OutputStreamWrapper_a0cf30a4188ab6fdae2b2ab74db11acc2}{GetStream} ();
490 
491   *os << \textcolor{stringliteral}{"Node: "} << \hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->GetObject<Node> ()->GetId ()
492       << \textcolor{stringliteral}{", Time: "} << \hyperlink{group__simulator_gac3635e2e87f7ce316c89290ee1b01d0d}{Now}().\hyperlink{classns3_1_1Time_a0bb1110638ce9938248bd07865a328ab}{As} (unit)
493       << \textcolor{stringliteral}{", Local time: "} << GetObject<Node> ()->GetLocalTime ().As (unit)
494       << \textcolor{stringliteral}{", IPv4 RIP table"} << std::endl;
495 
496   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.empty ())
497     \{
498       *os << \textcolor{stringliteral}{"Destination     Gateway         Genmask         Flags Metric Ref    Use Iface"} << std::endl;
499       \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Rip_a20080eb47fbc0ac67e3eba1c61cbafcb}{RoutesCI} it = \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.begin (); it != \hyperlink{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{m\_routes}.end (); it++)
500         \{
501           RipRoutingTableEntry* route = it->first;
502           \hyperlink{classns3_1_1RipRoutingTableEntry_a4326145be5c3027f2ddf9eb80b6127a4}{RipRoutingTableEntry::Status\_e} status = route->GetRouteStatus();
503 
504           \textcolor{keywordflow}{if} (status == \hyperlink{classns3_1_1RipRoutingTableEntry_a4326145be5c3027f2ddf9eb80b6127a4ac29e62da26c18bf4b9caa5224cfee895}{RipRoutingTableEntry::RIP\_VALID})
505             \{
506               std::ostringstream dest, gw, mask, flags;
507               dest << route->GetDest ();
508               *os << std::setiosflags (std::ios::left) << std::setw (16) << dest.str ();
509               gw << route->GetGateway ();
510               *os << std::setiosflags (std::ios::left) << std::setw (16) << gw.str ();
511               mask << route->GetDestNetworkMask ();
512               *os << std::setiosflags (std::ios::left) << std::setw (16) << mask.str ();
513               flags << \textcolor{stringliteral}{"U"};
514               \textcolor{keywordflow}{if} (route->IsHost ())
515                 \{
516                   flags << \textcolor{stringliteral}{"HS"};
517                 \}
518               \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (route->IsGateway ())
519                 \{
520                   flags << \textcolor{stringliteral}{"GS"};
521                 \}
522               *os << std::setiosflags (std::ios::left) << std::setw (6) << flags.str ();
523               *os << std::setiosflags (std::ios::left) << std::setw (7) << int(route->GetRouteMetric ());
524               \textcolor{comment}{// Ref ct not implemented}
525               *os << \textcolor{stringliteral}{"-"} << \textcolor{stringliteral}{"      "};
526               \textcolor{comment}{// Use not implemented}
527               *os << \textcolor{stringliteral}{"-"} << \textcolor{stringliteral}{"   "};
528               \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Names_ab9664faf23569aaae64a2d1f65265045}{Names::FindName} (\hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->GetNetDevice (route->GetInterface ())) != \textcolor{stringliteral}{"
      "})
529                 \{
530                   *os << \hyperlink{classns3_1_1Names_ab9664faf23569aaae64a2d1f65265045}{Names::FindName} (\hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->GetNetDevice (route->GetInterface ()
      ));
531                 \}
532               \textcolor{keywordflow}{else}
533                 \{
534                   *os << route->GetInterface ();
535                 \}
536               *os << std::endl;
537             \}
538         \}
539     \}
540   *os << std::endl;
541 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 27


\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Receive@{Receive}}
\index{Receive@{Receive}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Receive(\+Ptr$<$ Socket $>$ socket)}{Receive(Ptr< Socket > socket)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+::\+Receive (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Socket} $>$}]{socket}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_a49acadfb3b533118276481a0d231406e}{}\label{classns3_1_1Rip_a49acadfb3b533118276481a0d231406e}


Receive R\+IP packets. 


\begin{DoxyParams}{Parameters}
{\em socket} & the socket the packet was received to. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
711 \{
712   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << socket);
713 
714   Address sender;
715   Ptr<Packet> packet = socket->\hyperlink{classns3_1_1Socket_af22378d7af9a2745a9eada20210da215}{RecvFrom} (sender);
716   InetSocketAddress senderAddr = \hyperlink{classns3_1_1InetSocketAddress_ade776b1109e7b9a7be0b22ced49931e3}{InetSocketAddress::ConvertFrom} (sender);
717   \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Received "} << *packet << \textcolor{stringliteral}{" from "} << senderAddr);
718 
719   Ipv4Address senderAddress = senderAddr.GetIpv4 ();
720   uint16\_t senderPort = senderAddr.GetPort ();
721 
722   Ipv4PacketInfoTag interfaceInfo;
723   \textcolor{keywordflow}{if} (!packet->RemovePacketTag (interfaceInfo))
724     \{
725       \hyperlink{group__fatal_ga51ac4699be799d772ae7258d1ef6af21}{NS\_ABORT\_MSG} (\textcolor{stringliteral}{"No incoming interface on RIP message, aborting."});
726     \}
727   uint32\_t incomingIf = interfaceInfo.GetRecvIf ();
728   Ptr<Node> node = this->GetObject<Node> ();
729   Ptr<NetDevice> dev = node->GetDevice (incomingIf);
730   uint32\_t ipInterfaceIndex = \hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->GetInterfaceForDevice (dev);
731 
732   SocketIpTtlTag hoplimitTag;
733   \textcolor{keywordflow}{if} (!packet->RemovePacketTag (hoplimitTag))
734     \{
735       \hyperlink{group__fatal_ga51ac4699be799d772ae7258d1ef6af21}{NS\_ABORT\_MSG} (\textcolor{stringliteral}{"No incoming Hop Count on RIP message, aborting."});
736     \}
737   uint8\_t hopLimit = hoplimitTag.GetTtl ();
738 
739   int32\_t interfaceForAddress = \hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->GetInterfaceForAddress (senderAddress);
740   \textcolor{keywordflow}{if} (interfaceForAddress != -1)
741     \{
742       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Ignoring a packet sent by myself."});
743       \textcolor{keywordflow}{return};
744     \}
745 
746   RipHeader hdr;
747   packet->RemoveHeader (hdr);
748 
749   \textcolor{keywordflow}{if} (hdr.GetCommand () == \hyperlink{classns3_1_1RipHeader_a8c6ce779ee35c8b65446aaa202a6e789a9f13028e2d4a57da73f592702d7b17c7}{RipHeader::RESPONSE})
750     \{
751       \hyperlink{classns3_1_1Rip_afb817ee04f919351a35b466ea6d75c56}{HandleResponses} (hdr, senderAddress, ipInterfaceIndex, hopLimit);
752     \}
753   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (hdr.GetCommand () == \hyperlink{classns3_1_1RipHeader_a8c6ce779ee35c8b65446aaa202a6e789aeebbe2c504f996111c13da75ec0212d2}{RipHeader::REQUEST})
754     \{
755       \hyperlink{classns3_1_1Rip_a4094ed6c40c666f7567245eef2376fe9}{HandleRequests} (hdr, senderAddress, senderPort, ipInterfaceIndex, hopLimit);
756     \}
757   \textcolor{keywordflow}{else}
758     \{
759       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Ignoring message with unknown command: "} << \textcolor{keywordtype}{int} (hdr.GetCommand ()));
760     \}
761   \textcolor{keywordflow}{return};
762 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 28




Here is the caller graph for this function\+:
% FIG 29


\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Recv\+Multicast\+Rip@{Recv\+Multicast\+Rip}}
\index{Recv\+Multicast\+Rip@{Recv\+Multicast\+Rip}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Recv\+Multicast\+Rip(\+Ptr$<$ Socket $>$ socket)}{RecvMulticastRip(Ptr< Socket > socket)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+::\+Recv\+Multicast\+Rip (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Socket} $>$}]{socket}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_a4af37761c5e40fe5a5ddc0e61595d76d}{}\label{classns3_1_1Rip_a4af37761c5e40fe5a5ddc0e61595d76d}
Receive and process multicast packet 
\begin{DoxyParams}{Parameters}
{\em socket} & socket where packet is arrived \\
\hline
\end{DoxyParams}
\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Recv\+Unicast\+Rip@{Recv\+Unicast\+Rip}}
\index{Recv\+Unicast\+Rip@{Recv\+Unicast\+Rip}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Recv\+Unicast\+Rip(\+Ptr$<$ Socket $>$ socket)}{RecvUnicastRip(Ptr< Socket > socket)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+::\+Recv\+Unicast\+Rip (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Socket} $>$}]{socket}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_a78791b61a720345a6d23e0d61e29002c}{}\label{classns3_1_1Rip_a78791b61a720345a6d23e0d61e29002c}
Receive and process unicast packet 
\begin{DoxyParams}{Parameters}
{\em socket} & socket where packet is arrived \\
\hline
\end{DoxyParams}
\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Route\+Input@{Route\+Input}}
\index{Route\+Input@{Route\+Input}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Route\+Input(\+Ptr$<$ const Packet $>$ p, const Ipv4\+Header \&header, Ptr$<$ const Net\+Device $>$ idev, Unicast\+Forward\+Callback ucb, Multicast\+Forward\+Callback mcb, Local\+Deliver\+Callback lcb, Error\+Callback ecb)}{RouteInput(Ptr< const Packet > p, const Ipv4Header &header, Ptr< const NetDevice > idev, UnicastForwardCallback ucb, MulticastForwardCallback mcb, LocalDeliverCallback lcb, ErrorCallback ecb)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Rip\+::\+Route\+Input (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv4\+Header} \&}]{header, }
\item[{{\bf Ptr}$<$ const {\bf Net\+Device} $>$}]{idev, }
\item[{{\bf Unicast\+Forward\+Callback}}]{ucb, }
\item[{{\bf Multicast\+Forward\+Callback}}]{mcb, }
\item[{{\bf Local\+Deliver\+Callback}}]{lcb, }
\item[{{\bf Error\+Callback}}]{ecb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Rip_a4575903d3368ff77e2cc0e97c75fc8f9}{}\label{classns3_1_1Rip_a4575903d3368ff77e2cc0e97c75fc8f9}


Route an input packet (to be forwarded or locally delivered) 

This lookup is used in the forwarding process. The packet is handed over to the \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol}, and will get forwarded onward by one of the callbacks. The Linux equivalent is ip\+\_\+route\+\_\+input(). There are four valid outcomes, and a matching callbacks to handle each.


\begin{DoxyParams}{Parameters}
{\em p} & received packet \\
\hline
{\em header} & input parameter used to form a search key for a route \\
\hline
{\em idev} & Pointer to ingress network device \\
\hline
{\em ucb} & \hyperlink{classns3_1_1Callback}{Callback} for the case in which the packet is to be forwarded as unicast \\
\hline
{\em mcb} & \hyperlink{classns3_1_1Callback}{Callback} for the case in which the packet is to be forwarded as multicast \\
\hline
{\em lcb} & \hyperlink{classns3_1_1Callback}{Callback} for the case in which the packet is to be locally delivered \\
\hline
{\em ecb} & \hyperlink{classns3_1_1Callback}{Callback} to call if there is an error in forwarding \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the \hyperlink{classns3_1_1Ipv4RoutingProtocol}{Ipv4\+Routing\+Protocol} takes responsibility for forwarding or delivering the packet, false otherwise 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a67e815ff40ebb9f5f4eec4e22e23132e}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
219 \{
220   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} << header << header.GetSource () << header.GetDestination () <
      < idev);
221 
222   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4} != 0);
223   \textcolor{comment}{// Check if input device supports IP}
224   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->GetInterfaceForDevice (idev) >= 0);
225   uint32\_t iif = \hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->GetInterfaceForDevice (idev);
226   Ipv4Address dst = header.GetDestination ();
227 
228     \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->IsDestinationAddress (header.GetDestination (), iif))
229     \{
230       \textcolor{keywordflow}{if} (!lcb.IsNull ())
231         \{
232           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Local delivery to "} << header.GetDestination ());
233           lcb (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header, iif);
234           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
235         \}
236       \textcolor{keywordflow}{else}
237         \{
238           \textcolor{comment}{// The local delivery callback is null.  This may be a multicast}
239           \textcolor{comment}{// or broadcast packet, so return false so that another}
240           \textcolor{comment}{// multicast routing protocol can handle it.  It should be possible}
241           \textcolor{comment}{// to extend this to explicitly check whether it is a unicast}
242           \textcolor{comment}{// packet, and invoke the error callback if so}
243           \textcolor{keywordflow}{return} \textcolor{keyword}{false};
244         \}
245     \}
246 
247     \textcolor{keywordflow}{if} (dst.IsMulticast ())
248       \{
249         \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Multicast route not supported by RIP"});
250         \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \textcolor{comment}{// Let other routing protocols try to handle this}
251       \}
252 
253   \textcolor{keywordflow}{if} (header.GetDestination ().IsBroadcast ())
254     \{
255       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Dropping packet not for me and with dst Broadcast"});
256       \textcolor{keywordflow}{if} (!ecb.IsNull ())
257         \{
258           ecb (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{Socket::ERROR\_NOROUTETOHOST});
259         \}
260       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
261     \}
262 
263   \textcolor{comment}{// Check if input device supports IP forwarding}
264   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->IsForwarding (iif) == \textcolor{keyword}{false})
265     \{
266       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Forwarding disabled for this interface"});
267       \textcolor{keywordflow}{if} (!ecb.IsNull ())
268         \{
269           ecb (\hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{Socket::ERROR\_NOROUTETOHOST});
270         \}
271       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
272     \}
273   \textcolor{comment}{// Next, try to find a route}
274   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Unicast destination"});
275   Ptr<Ipv4Route> rtentry = \hyperlink{classns3_1_1Rip_a50d486fb2eee757bb9f9d528d3828dab}{Lookup} (header.GetDestination ());
276 
277   \textcolor{keywordflow}{if} (rtentry != 0)
278     \{
279       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Found unicast destination - calling unicast callback"});
280       ucb (rtentry, \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, header);  \textcolor{comment}{// unicast forwarding callback}
281       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
282     \}
283   \textcolor{keywordflow}{else}
284     \{
285       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Did not find unicast destination - returning false"});
286       \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \textcolor{comment}{// Let other routing protocols try to handle this}
287     \}
288 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 30


\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Route\+Output@{Route\+Output}}
\index{Route\+Output@{Route\+Output}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Route\+Output(\+Ptr$<$ Packet $>$ p, const Ipv4\+Header \&header, Ptr$<$ Net\+Device $>$ oif, Socket\+::\+Socket\+Errno \&sockerr)}{RouteOutput(Ptr< Packet > p, const Ipv4Header &header, Ptr< NetDevice > oif, Socket::SocketErrno &sockerr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv4\+Route} $>$ ns3\+::\+Rip\+::\+Route\+Output (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv4\+Header} \&}]{header, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{oif, }
\item[{{\bf Socket\+::\+Socket\+Errno} \&}]{sockerr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Rip_a56d1be040d276f54ea04d5adf7c9fce6}{}\label{classns3_1_1Rip_a56d1be040d276f54ea04d5adf7c9fce6}


Query routing cache for an existing route, for an outbound packet. 

This lookup is used by transport protocols. It does not cause any packet to be forwarded, and is synchronous. Can be used for multicast or unicast. The Linux equivalent is ip\+\_\+route\+\_\+output()

The header input parameter may have an uninitialized value for the source address, but the destination address should always be properly set by the caller.


\begin{DoxyParams}{Parameters}
{\em p} & packet to be routed. Note that this method may modify the packet. Callers may also pass in a null pointer. \\
\hline
{\em header} & input parameter (used to form key to search for the route) \\
\hline
{\em oif} & Output interface Netdevice. May be zero, or may be bound via socket options to a particular output interface. \\
\hline
{\em sockerr} & Output parameter; socket errno\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a code that indicates what happened in the lookup 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_a9c0e9b77772a4974c06ee4577fe60547}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
187 \{
188   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << header << oif);
189 
190   Ipv4Address destination = header.GetDestination ();
191   Ptr<Ipv4Route> rtentry = 0;
192 
193   \textcolor{keywordflow}{if} (destination.IsMulticast ())
194     \{
195       \textcolor{comment}{// Note:  Multicast routes for outbound packets are stored in the}
196       \textcolor{comment}{// normal unicast table.  An implication of this is that it is not}
197       \textcolor{comment}{// possible to source multicast datagrams on multiple interfaces.}
198       \textcolor{comment}{// This is a well-known property of sockets implementation on}
199       \textcolor{comment}{// many Unix variants.}
200       \textcolor{comment}{// So, we just log it and fall through to LookupStatic ()}
201       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"RouteOutput (): Multicast destination"});
202     \}
203 
204   rtentry = \hyperlink{classns3_1_1Rip_a50d486fb2eee757bb9f9d528d3828dab}{Lookup} (destination, oif);
205   \textcolor{keywordflow}{if} (rtentry)
206     \{
207       sockerr = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaaa7eb006d73c5ad0117c5591fcb3469f7}{Socket::ERROR\_NOTERROR};
208     \}
209   \textcolor{keywordflow}{else}
210     \{
211       sockerr = \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6ccaa0f8ecb5a4ddbce3bade35fa12c3d49e8}{Socket::ERROR\_NOROUTETOHOST};
212     \}
213   \textcolor{keywordflow}{return} rtentry;
214 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 31


\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Send\+Route\+Request@{Send\+Route\+Request}}
\index{Send\+Route\+Request@{Send\+Route\+Request}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Send\+Route\+Request()}{SendRouteRequest()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+::\+Send\+Route\+Request (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_a84c90e335d9b833b26f1a8e8e7fc2243}{}\label{classns3_1_1Rip_a84c90e335d9b833b26f1a8e8e7fc2243}


Send Routing Request on all interfaces. 


\begin{DoxyCode}
1237 \{
1238   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1239 
1240   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = Create<Packet> ();
1241   SocketIpTtlTag tag;
1242   p->RemovePacketTag (tag);
1243   tag.SetTtl (1);
1244   p->AddPacketTag (tag);
1245 
1246   RipHeader hdr;
1247   hdr.SetCommand (\hyperlink{classns3_1_1RipHeader_a8c6ce779ee35c8b65446aaa202a6e789aeebbe2c504f996111c13da75ec0212d2}{RipHeader::REQUEST});
1248 
1249   RipRte rte;
1250   rte.SetPrefix (\hyperlink{classns3_1_1Ipv4Address_a7a39b330c8e701183a411d5779fca1a4}{Ipv4Address::GetAny} ());
1251   rte.SetSubnetMask (\hyperlink{classns3_1_1Ipv4Mask_ac2dda492011ede8350008d753d278998}{Ipv4Mask::GetZero} ());
1252   rte.SetRouteMetric (\hyperlink{classns3_1_1Rip_a3f37d4c5176e380482edf0be82d2fc18}{m\_linkDown});
1253 
1254   hdr.AddRte (rte);
1255   p->AddHeader (hdr);
1256 
1257   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Rip_a0395b3977eeeb90190ccfa5758a3957f}{SocketListI} iter = \hyperlink{classns3_1_1Rip_a58b5f6ebcee2ed04249fd025abfa61cb}{m\_sendSocketList}.begin (); iter != 
      \hyperlink{classns3_1_1Rip_a58b5f6ebcee2ed04249fd025abfa61cb}{m\_sendSocketList}.end (); iter++ )
1258     \{
1259       uint32\_t \textcolor{keyword}{interface }= iter->second;
1260 
1261       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Rip_a30e2c00645f24a3b29be981f5d592773}{m\_interfaceExclusions}.find (interface) == 
      \hyperlink{classns3_1_1Rip_a30e2c00645f24a3b29be981f5d592773}{m\_interfaceExclusions}.end ())
1262         \{
1263           \hyperlink{group__logging_ga413f1886406d49f59a6a0a89b77b4d0a}{NS\_LOG\_DEBUG} (\textcolor{stringliteral}{"SendTo: "} << *p);
1264           iter->first->SendTo (p, 0, InetSocketAddress (\hyperlink{rip_8cc_a4088e07a51c9aabba6666b6c1e85f704}{RIP\_ALL\_NODE}, 
      \hyperlink{rip_8cc_a6af26a435808c34ee4f8876792a5682a}{RIP\_PORT}));
1265         \}
1266     \}
1267 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 32




Here is the caller graph for this function\+:
% FIG 33


\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Send\+Triggered\+Route\+Update@{Send\+Triggered\+Route\+Update}}
\index{Send\+Triggered\+Route\+Update@{Send\+Triggered\+Route\+Update}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Send\+Triggered\+Route\+Update()}{SendTriggeredRouteUpdate()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+::\+Send\+Triggered\+Route\+Update (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_aee5d3efe6b4dbcd128018f49b981fd7c}{}\label{classns3_1_1Rip_aee5d3efe6b4dbcd128018f49b981fd7c}


Send Triggered Routing Updates on all interfaces. 


\begin{DoxyCode}
1158 \{
1159   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1160 
1161   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Rip_a66c28747adb18044611ceab7fbba57a8}{m\_nextTriggeredUpdate}.\hyperlink{classns3_1_1EventId_aabf8476d1a080c199ea0c6aa9ccea372}{IsRunning}())
1162     \{
1163       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Skipping Triggered Update due to cooldown"});
1164       \textcolor{keywordflow}{return};
1165     \}
1166 
1167   \textcolor{comment}{// DoSendRouteUpdate (false);}
1168 
1169   \textcolor{comment}{// note: The RFC states:}
1170   \textcolor{comment}{//     After a triggered}
1171   \textcolor{comment}{//     update is sent, a timer should be set for a random interval between 1}
1172   \textcolor{comment}{//     and 5 seconds.  If other changes that would trigger updates occur}
1173   \textcolor{comment}{//     before the timer expires, a single update is triggered when the timer}
1174   \textcolor{comment}{//     expires.  The timer is then reset to another random value between 1}
1175   \textcolor{comment}{//     and 5 seconds.  Triggered updates may be suppressed if a regular}
1176   \textcolor{comment}{//     update is due by the time the triggered update would be sent.}
1177   \textcolor{comment}{// Here we rely on this:}
1178   \textcolor{comment}{// When an update occurs (either Triggered or Periodic) the "IsChanged ()"}
1179   \textcolor{comment}{// route field will be cleared.}
1180   \textcolor{comment}{// Hence, the following Triggered Update will be fired, but will not send}
1181   \textcolor{comment}{// any route update.}
1182 
1183   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_a7964e6aa8f61a9d28973c8267a606ad8}{delay} = \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (\hyperlink{classns3_1_1Rip_aff68d9a9e912bc0a99201bee4d93e636}{m\_rng}->\hyperlink{classns3_1_1UniformRandomVariable_a03822d8c86ac51e9aa83bbc73041386b}{GetValue} (
      \hyperlink{classns3_1_1Rip_a9345ff42e947fb0edb2382d6c4f50bd0}{m\_minTriggeredUpdateDelay}.\hyperlink{classns3_1_1Time_a8f20d5c3b0902d7b4320982f340b57c8}{GetSeconds} (), 
      \hyperlink{classns3_1_1Rip_aed7be1d33584f7d7f8b2ca68bfbf3a06}{m\_maxTriggeredUpdateDelay}.\hyperlink{classns3_1_1Time_a8f20d5c3b0902d7b4320982f340b57c8}{GetSeconds} ()));
1184   \hyperlink{classns3_1_1Rip_a66c28747adb18044611ceab7fbba57a8}{m\_nextTriggeredUpdate} = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (delay, &
      \hyperlink{classns3_1_1Rip_a106f73869862c38c070faec379542e05}{Rip::DoSendRouteUpdate}, \textcolor{keyword}{this}, \textcolor{keyword}{false});
1185 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 34




Here is the caller graph for this function\+:
% FIG 35


\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Send\+Unsolicited\+Route\+Update@{Send\+Unsolicited\+Route\+Update}}
\index{Send\+Unsolicited\+Route\+Update@{Send\+Unsolicited\+Route\+Update}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Send\+Unsolicited\+Route\+Update(void)}{SendUnsolicitedRouteUpdate(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+::\+Send\+Unsolicited\+Route\+Update (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_aea59ff20475f09e1783bc37d5a8531c0}{}\label{classns3_1_1Rip_aea59ff20475f09e1783bc37d5a8531c0}


Send Unsolicited Routing Updates on all interfaces. 


\begin{DoxyCode}
1188 \{
1189   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1190 
1191   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Rip_a66c28747adb18044611ceab7fbba57a8}{m\_nextTriggeredUpdate}.\hyperlink{classns3_1_1EventId_aabf8476d1a080c199ea0c6aa9ccea372}{IsRunning}())
1192     \{
1193       \hyperlink{classns3_1_1Rip_a66c28747adb18044611ceab7fbba57a8}{m\_nextTriggeredUpdate}.\hyperlink{classns3_1_1EventId_a993ae94e48e014e1afd47edb16db7a11}{Cancel} ();
1194     \}
1195 
1196   \hyperlink{classns3_1_1Rip_a106f73869862c38c070faec379542e05}{DoSendRouteUpdate} (\textcolor{keyword}{true});
1197 
1198   \hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} \hyperlink{lte_2model_2fading-traces_2fading__trace__generator_8m_a7964e6aa8f61a9d28973c8267a606ad8}{delay} = \hyperlink{classns3_1_1Rip_aabc5098465aa38f416c5daa7561d3ea0}{m\_unsolicitedUpdate} + \hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (
      \hyperlink{classns3_1_1Rip_aff68d9a9e912bc0a99201bee4d93e636}{m\_rng}->\hyperlink{classns3_1_1UniformRandomVariable_a03822d8c86ac51e9aa83bbc73041386b}{GetValue} (0, 0.5*\hyperlink{classns3_1_1Rip_aabc5098465aa38f416c5daa7561d3ea0}{m\_unsolicitedUpdate}.
      \hyperlink{classns3_1_1Time_a8f20d5c3b0902d7b4320982f340b57c8}{GetSeconds} ()) );
1199   \hyperlink{classns3_1_1Rip_a52794ab079ab76322bedc46a8ea99d0a}{m\_nextUnsolicitedUpdate} = \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (delay, &
      \hyperlink{classns3_1_1Rip_aea59ff20475f09e1783bc37d5a8531c0}{Rip::SendUnsolicitedRouteUpdate}, \textcolor{keyword}{this});
1200 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 36




Here is the caller graph for this function\+:
% FIG 37


\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Set\+Interface\+Exclusions@{Set\+Interface\+Exclusions}}
\index{Set\+Interface\+Exclusions@{Set\+Interface\+Exclusions}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Set\+Interface\+Exclusions(std\+::set$<$ uint32\+\_\+t $>$ exceptions)}{SetInterfaceExclusions(std::set< uint32_t > exceptions)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+::\+Set\+Interface\+Exclusions (
\begin{DoxyParamCaption}
\item[{std\+::set$<$ uint32\+\_\+t $>$}]{exceptions}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Rip_ae564ba0b6bc1cc0b1d678166ffe1ae71}{}\label{classns3_1_1Rip_ae564ba0b6bc1cc0b1d678166ffe1ae71}


Set the set of interface excluded from the protocol. 


\begin{DoxyParams}{Parameters}
{\em exceptions} & the set of excluded interfaces \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1208 \{
1209   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1210 
1211   \hyperlink{classns3_1_1Rip_a30e2c00645f24a3b29be981f5d592773}{m\_interfaceExclusions} = exceptions;
1212 \}
\end{DoxyCode}
\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Set\+Interface\+Metric@{Set\+Interface\+Metric}}
\index{Set\+Interface\+Metric@{Set\+Interface\+Metric}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Set\+Interface\+Metric(uint32\+\_\+t interface, uint8\+\_\+t metric)}{SetInterfaceMetric(uint32_t interface, uint8_t metric)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+::\+Set\+Interface\+Metric (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{uint8\+\_\+t}]{metric}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Rip_a068a04a9653f7b9295350aba52dc58a0}{}\label{classns3_1_1Rip_a068a04a9653f7b9295350aba52dc58a0}


Set the metric for an interface. 


\begin{DoxyParams}{Parameters}
{\em interface} & the interface \\
\hline
{\em metric} & the interface metric \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1227 \{
1228   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << interface << \textcolor{keywordtype}{int} (metric));
1229 
1230   \textcolor{keywordflow}{if} (metric < \hyperlink{classns3_1_1Rip_a3f37d4c5176e380482edf0be82d2fc18}{m\_linkDown})
1231     \{
1232       \hyperlink{classns3_1_1Rip_a297aac5454b10e21644490335f72364a}{m\_interfaceMetrics}[interface] = metric;
1233     \}
1234 \}
\end{DoxyCode}
\index{ns3\+::\+Rip@{ns3\+::\+Rip}!Set\+Ipv4@{Set\+Ipv4}}
\index{Set\+Ipv4@{Set\+Ipv4}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{Set\+Ipv4(\+Ptr$<$ Ipv4 $>$ ipv4)}{SetIpv4(Ptr< Ipv4 > ipv4)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Rip\+::\+Set\+Ipv4 (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv4} $>$}]{ipv4}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Rip_abe2906af2196cf9fac033e6ccfde0423}{}\label{classns3_1_1Rip_abe2906af2196cf9fac033e6ccfde0423}

\begin{DoxyParams}{Parameters}
{\em ipv4} & the ipv4 object this routing protocol is being associated with\\
\hline
\end{DoxyParams}
Typically, invoked directly or indirectly from \hyperlink{classns3_1_1Ipv4_a2d165c3bafd4ca580f02a03536db80d3}{ns3\+::\+Ipv4\+::\+Set\+Routing\+Protocol} 

Implements \hyperlink{classns3_1_1Ipv4RoutingProtocol_af3947a05b912ea3f2a1ef0e9777f723e}{ns3\+::\+Ipv4\+Routing\+Protocol}.


\begin{DoxyCode}
465 \{
466   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << ipv4);
467 
468   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4} == 0 && ipv4 != 0);
469   uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0;
470   \hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4} = ipv4;
471 
472   \textcolor{keywordflow}{for} (i = 0; i < \hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->GetNInterfaces (); i++)
473     \{
474       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{m\_ipv4}->IsUp (i))
475         \{
476           \hyperlink{classns3_1_1Rip_a4c9095a4429399f342eb1bce3f20df59}{NotifyInterfaceUp} (i);
477         \}
478       \textcolor{keywordflow}{else}
479         \{
480           \hyperlink{classns3_1_1Rip_a10fb1463467f08556e7a3e75c98447bc}{NotifyInterfaceDown} (i);
481         \}
482     \}
483 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 38




\subsection{Member Data Documentation}
\index{ns3\+::\+Rip@{ns3\+::\+Rip}!m\+\_\+garbage\+Collection\+Delay@{m\+\_\+garbage\+Collection\+Delay}}
\index{m\+\_\+garbage\+Collection\+Delay@{m\+\_\+garbage\+Collection\+Delay}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{m\+\_\+garbage\+Collection\+Delay}{m_garbageCollectionDelay}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Rip\+::m\+\_\+garbage\+Collection\+Delay\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_ad317e92ae9d78b20642be47df4e8d866}{}\label{classns3_1_1Rip_ad317e92ae9d78b20642be47df4e8d866}


Delay before deleting an I\+N\+V\+A\+L\+ID route. 

\index{ns3\+::\+Rip@{ns3\+::\+Rip}!m\+\_\+initialized@{m\+\_\+initialized}}
\index{m\+\_\+initialized@{m\+\_\+initialized}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{m\+\_\+initialized}{m_initialized}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Rip\+::m\+\_\+initialized\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_adb494e48f6b5e4e42bf47a8ad3a25485}{}\label{classns3_1_1Rip_adb494e48f6b5e4e42bf47a8ad3a25485}


flag to allow socket\textquotesingle{}s late-\/creation. 

\index{ns3\+::\+Rip@{ns3\+::\+Rip}!m\+\_\+interface\+Exclusions@{m\+\_\+interface\+Exclusions}}
\index{m\+\_\+interface\+Exclusions@{m\+\_\+interface\+Exclusions}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{m\+\_\+interface\+Exclusions}{m_interfaceExclusions}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::set$<$uint32\+\_\+t$>$ ns3\+::\+Rip\+::m\+\_\+interface\+Exclusions\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_a30e2c00645f24a3b29be981f5d592773}{}\label{classns3_1_1Rip_a30e2c00645f24a3b29be981f5d592773}


Set of excluded interfaces. 

\index{ns3\+::\+Rip@{ns3\+::\+Rip}!m\+\_\+interface\+Metrics@{m\+\_\+interface\+Metrics}}
\index{m\+\_\+interface\+Metrics@{m\+\_\+interface\+Metrics}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{m\+\_\+interface\+Metrics}{m_interfaceMetrics}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<$uint32\+\_\+t, uint8\+\_\+t$>$ ns3\+::\+Rip\+::m\+\_\+interface\+Metrics\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_a297aac5454b10e21644490335f72364a}{}\label{classns3_1_1Rip_a297aac5454b10e21644490335f72364a}


Map of interface metrics. 

\index{ns3\+::\+Rip@{ns3\+::\+Rip}!m\+\_\+ipv4@{m\+\_\+ipv4}}
\index{m\+\_\+ipv4@{m\+\_\+ipv4}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{m\+\_\+ipv4}{m_ipv4}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Ipv4}$>$ ns3\+::\+Rip\+::m\+\_\+ipv4\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}{}\label{classns3_1_1Rip_a6e2c0e74d2fa8643d223db26621dd7f1}


I\+Pv4 reference. 

\index{ns3\+::\+Rip@{ns3\+::\+Rip}!m\+\_\+link\+Down@{m\+\_\+link\+Down}}
\index{m\+\_\+link\+Down@{m\+\_\+link\+Down}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{m\+\_\+link\+Down}{m_linkDown}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Rip\+::m\+\_\+link\+Down\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_a3f37d4c5176e380482edf0be82d2fc18}{}\label{classns3_1_1Rip_a3f37d4c5176e380482edf0be82d2fc18}


Link down value. 

\index{ns3\+::\+Rip@{ns3\+::\+Rip}!m\+\_\+max\+Triggered\+Update\+Delay@{m\+\_\+max\+Triggered\+Update\+Delay}}
\index{m\+\_\+max\+Triggered\+Update\+Delay@{m\+\_\+max\+Triggered\+Update\+Delay}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Triggered\+Update\+Delay}{m_maxTriggeredUpdateDelay}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Rip\+::m\+\_\+max\+Triggered\+Update\+Delay\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_aed7be1d33584f7d7f8b2ca68bfbf3a06}{}\label{classns3_1_1Rip_aed7be1d33584f7d7f8b2ca68bfbf3a06}


Max cooldown delay after a Triggered Update. 

\index{ns3\+::\+Rip@{ns3\+::\+Rip}!m\+\_\+min\+Triggered\+Update\+Delay@{m\+\_\+min\+Triggered\+Update\+Delay}}
\index{m\+\_\+min\+Triggered\+Update\+Delay@{m\+\_\+min\+Triggered\+Update\+Delay}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{m\+\_\+min\+Triggered\+Update\+Delay}{m_minTriggeredUpdateDelay}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Rip\+::m\+\_\+min\+Triggered\+Update\+Delay\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_a9345ff42e947fb0edb2382d6c4f50bd0}{}\label{classns3_1_1Rip_a9345ff42e947fb0edb2382d6c4f50bd0}


Min cooldown delay after a Triggered Update. 

\index{ns3\+::\+Rip@{ns3\+::\+Rip}!m\+\_\+next\+Triggered\+Update@{m\+\_\+next\+Triggered\+Update}}
\index{m\+\_\+next\+Triggered\+Update@{m\+\_\+next\+Triggered\+Update}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{m\+\_\+next\+Triggered\+Update}{m_nextTriggeredUpdate}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Event\+Id} ns3\+::\+Rip\+::m\+\_\+next\+Triggered\+Update\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_a66c28747adb18044611ceab7fbba57a8}{}\label{classns3_1_1Rip_a66c28747adb18044611ceab7fbba57a8}


Next Triggered Update event. 

\index{ns3\+::\+Rip@{ns3\+::\+Rip}!m\+\_\+next\+Unsolicited\+Update@{m\+\_\+next\+Unsolicited\+Update}}
\index{m\+\_\+next\+Unsolicited\+Update@{m\+\_\+next\+Unsolicited\+Update}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{m\+\_\+next\+Unsolicited\+Update}{m_nextUnsolicitedUpdate}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Event\+Id} ns3\+::\+Rip\+::m\+\_\+next\+Unsolicited\+Update\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_a52794ab079ab76322bedc46a8ea99d0a}{}\label{classns3_1_1Rip_a52794ab079ab76322bedc46a8ea99d0a}


Next Unsolicited Update event. 

\index{ns3\+::\+Rip@{ns3\+::\+Rip}!m\+\_\+recv\+Socket@{m\+\_\+recv\+Socket}}
\index{m\+\_\+recv\+Socket@{m\+\_\+recv\+Socket}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{m\+\_\+recv\+Socket}{m_recvSocket}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Socket}$>$ ns3\+::\+Rip\+::m\+\_\+recv\+Socket\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_a6c5dc1b74475e3caa0782f37b722be6b}{}\label{classns3_1_1Rip_a6c5dc1b74475e3caa0782f37b722be6b}


receive socket 

\index{ns3\+::\+Rip@{ns3\+::\+Rip}!m\+\_\+rng@{m\+\_\+rng}}
\index{m\+\_\+rng@{m\+\_\+rng}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{m\+\_\+rng}{m_rng}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Uniform\+Random\+Variable}$>$ ns3\+::\+Rip\+::m\+\_\+rng\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_aff68d9a9e912bc0a99201bee4d93e636}{}\label{classns3_1_1Rip_aff68d9a9e912bc0a99201bee4d93e636}


Rng stream. 

\index{ns3\+::\+Rip@{ns3\+::\+Rip}!m\+\_\+routes@{m\+\_\+routes}}
\index{m\+\_\+routes@{m\+\_\+routes}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{m\+\_\+routes}{m_routes}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Routes} ns3\+::\+Rip\+::m\+\_\+routes\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}{}\label{classns3_1_1Rip_aea6c918ae311cd88fb2bfb714d6f9c30}


the forwarding table for network. 

\index{ns3\+::\+Rip@{ns3\+::\+Rip}!m\+\_\+send\+Socket\+List@{m\+\_\+send\+Socket\+List}}
\index{m\+\_\+send\+Socket\+List@{m\+\_\+send\+Socket\+List}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{m\+\_\+send\+Socket\+List}{m_sendSocketList}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Socket\+List} ns3\+::\+Rip\+::m\+\_\+send\+Socket\+List\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_a58b5f6ebcee2ed04249fd025abfa61cb}{}\label{classns3_1_1Rip_a58b5f6ebcee2ed04249fd025abfa61cb}


list of sockets for sending (socket, interface index) 

\index{ns3\+::\+Rip@{ns3\+::\+Rip}!m\+\_\+split\+Horizon\+Strategy@{m\+\_\+split\+Horizon\+Strategy}}
\index{m\+\_\+split\+Horizon\+Strategy@{m\+\_\+split\+Horizon\+Strategy}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{m\+\_\+split\+Horizon\+Strategy}{m_splitHorizonStrategy}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Split\+Horizon\+Type\+\_\+e} ns3\+::\+Rip\+::m\+\_\+split\+Horizon\+Strategy\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_a2053001529a46356e1f612dfde6b4faf}{}\label{classns3_1_1Rip_a2053001529a46356e1f612dfde6b4faf}


Split Horizon strategy. 

\index{ns3\+::\+Rip@{ns3\+::\+Rip}!m\+\_\+startup\+Delay@{m\+\_\+startup\+Delay}}
\index{m\+\_\+startup\+Delay@{m\+\_\+startup\+Delay}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{m\+\_\+startup\+Delay}{m_startupDelay}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Rip\+::m\+\_\+startup\+Delay\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_a26dfd4f6ce345b6259733027a77fbcc9}{}\label{classns3_1_1Rip_a26dfd4f6ce345b6259733027a77fbcc9}


Random delay before protocol startup. 

\index{ns3\+::\+Rip@{ns3\+::\+Rip}!m\+\_\+timeout\+Delay@{m\+\_\+timeout\+Delay}}
\index{m\+\_\+timeout\+Delay@{m\+\_\+timeout\+Delay}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{m\+\_\+timeout\+Delay}{m_timeoutDelay}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Rip\+::m\+\_\+timeout\+Delay\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_a8a684a47271e0e382dd5f485a8a5545b}{}\label{classns3_1_1Rip_a8a684a47271e0e382dd5f485a8a5545b}


Delay before invalidating a route. 

\index{ns3\+::\+Rip@{ns3\+::\+Rip}!m\+\_\+unsolicited\+Update@{m\+\_\+unsolicited\+Update}}
\index{m\+\_\+unsolicited\+Update@{m\+\_\+unsolicited\+Update}!ns3\+::\+Rip@{ns3\+::\+Rip}}
\subsubsection[{\texorpdfstring{m\+\_\+unsolicited\+Update}{m_unsolicitedUpdate}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Rip\+::m\+\_\+unsolicited\+Update\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Rip_aabc5098465aa38f416c5daa7561d3ea0}{}\label{classns3_1_1Rip_aabc5098465aa38f416c5daa7561d3ea0}


time between two Unsolicited Routing Updates 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/model/\hyperlink{rip_8h}{rip.\+h}\item 
internet/model/\hyperlink{rip_8cc}{rip.\+cc}\end{DoxyCompactItemize}
