digraph "ns3::ReciprocalDivide"
{
  edge [fontname="Helvetica",fontsize="10",labelfontname="Helvetica",labelfontsize="10"];
  node [fontname="Helvetica",fontsize="10",shape=record];
  rankdir="LR";
  Node1 [label="ns3::ReciprocalDivide",height=0.2,width=0.4,color="black", fillcolor="grey75", style="filled", fontcolor="black"];
  Node1 -> Node2 [dir="back",color="midnightblue",fontsize="10",style="solid"];
  Node2 [label="ns3::CoDelQueueDisc\l::ControlLaw",height=0.2,width=0.4,color="black", fillcolor="white", style="filled",URL="$de/d17/classns3_1_1CoDelQueueDisc.html#adff5ff4ecef4f9bbe51cde7ab0642af3",tooltip="Determine the time for next drop CoDel control law is t + m_interval/sqrt(m_count). Here, we use m_recInvSqrt calculated by Newton&#39;s method in NewtonStep() to avoid both sqrt() and divide operations. "];
  Node2 -> Node3 [dir="back",color="midnightblue",fontsize="10",style="solid"];
  Node3 [label="ns3::CoDelQueueDisc\l::DoDequeue",height=0.2,width=0.4,color="black", fillcolor="white", style="filled",URL="$de/d17/classns3_1_1CoDelQueueDisc.html#a6128cb8655b87b67f04424c68058e751",tooltip="Remove a packet from queue based on the current state If we are in dropping state, check if we could leave the dropping state or if we should perform next drop If we are not currently in dropping state, check if we need to enter the state and drop the first packet. "];
  Node2 -> Node4 [dir="back",color="midnightblue",fontsize="10",style="solid"];
  Node4 [label="CoDelQueueDiscControlLaw\lTest::DoRun",height=0.2,width=0.4,color="black", fillcolor="white", style="filled",URL="$dc/d0b/classCoDelQueueDiscControlLawTest.html#a9c38e39f5749875e5a0898aedbd4f2b3",tooltip="Implementation to actually run this TestCase. "];
}
