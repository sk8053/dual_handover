\hypertarget{classns3_1_1Icmpv6L4Protocol}{}\section{ns3\+:\+:Icmpv6\+L4\+Protocol Class Reference}
\label{classns3_1_1Icmpv6L4Protocol}\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}


An implementation of the I\+C\+M\+Pv6 protocol.  




{\ttfamily \#include $<$icmpv6-\/l4-\/protocol.\+h$>$}



Inheritance diagram for ns3\+:\+:Icmpv6\+L4\+Protocol\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Icmpv6\+L4\+Protocol\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
uint8\+\_\+t \hyperlink{classns3_1_1Icmpv6L4Protocol_abb4118285596e2a14fd32270b34025da}{Get\+Max\+Multicast\+Solicit} () const 
\begin{DoxyCompactList}\small\item\em Neighbor Discovery node constants\+: max multicast solicitations. \end{DoxyCompactList}\item 
uint8\+\_\+t \hyperlink{classns3_1_1Icmpv6L4Protocol_a6e9aed5e1a7770899a458b65f00ef62f}{Get\+Max\+Unicast\+Solicit} () const 
\begin{DoxyCompactList}\small\item\em Neighbor Discovery node constants\+: max unicast solicitations. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1Icmpv6L4Protocol_a5fb975cf28febe9997ee704d89bdd9fb}{Get\+Reachable\+Time} () const 
\begin{DoxyCompactList}\small\item\em Neighbor Discovery node constants\+: reachable time. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1Icmpv6L4Protocol_ad756130c71199a72cf34336fea7f4541}{Get\+Retransmission\+Time} () const 
\begin{DoxyCompactList}\small\item\em Neighbor Discovery node constants\+: retransmission timer. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1Icmpv6L4Protocol_af9f99267d950310856adcde5a37da210}{Get\+Delay\+First\+Probe} () const 
\begin{DoxyCompactList}\small\item\em Neighbor Discovery node constants \+: delay for the first probe. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Icmpv6L4Protocol_accdeaa226eb8d84ef23a96e60881f3de}{Icmpv6\+L4\+Protocol} ()
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Icmpv6L4Protocol_aad392a1007a7d6b775654c9829389b26}{$\sim$\+Icmpv6\+L4\+Protocol} ()
\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Icmpv6L4Protocol_af6108107ea3ca1dee9495671183bd31f}{Set\+Node} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node)
\begin{DoxyCompactList}\small\item\em Set the node. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Icmpv6L4Protocol_a5b150b21ea7d5337ec2021092fcf972b}{Notify\+New\+Aggregate} ()
\begin{DoxyCompactList}\small\item\em This method is called by Add\+Agregate and completes the aggregation by setting the node in the I\+C\+M\+Pv6 stack and adding I\+C\+M\+Pv6 factory to I\+Pv6 stack connected to the node. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1Icmpv6L4Protocol_ae84d887e897f60fb4fb41f3f93989825}{Get\+Protocol\+Number} () const 
\begin{DoxyCompactList}\small\item\em Get the protocol number. \end{DoxyCompactList}\item 
virtual int \hyperlink{classns3_1_1Icmpv6L4Protocol_a3ea4485be0a45707fd5e72363c737df2}{Get\+Version} () const 
\begin{DoxyCompactList}\small\item\em Get the version of the protocol. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Icmpv6L4Protocol_aca22b3999b518531f807d822060a06a8}{Send\+Message} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} src, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dst, uint8\+\_\+t ttl)
\begin{DoxyCompactList}\small\item\em Send a packet via I\+C\+M\+Pv6, note that packet already contains I\+C\+M\+Pv6 header. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Icmpv6L4Protocol_a3c4b85301ce19b8b2791402972553127}{Delayed\+Send\+Message} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} src, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dst, uint8\+\_\+t ttl)
\begin{DoxyCompactList}\small\item\em Helper function used during delayed solicitation. Calls Send\+Message internally. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Icmpv6L4Protocol_a62a9a177dd81ee6d5323e50b0954ed70}{Send\+Message} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dst, \hyperlink{classns3_1_1Icmpv6Header}{Icmpv6\+Header} \&icmpv6\+Hdr, uint8\+\_\+t ttl)
\begin{DoxyCompactList}\small\item\em Send a packet via I\+C\+M\+Pv6. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Icmpv6L4Protocol_a926ea8e638e30cee8c3c17d4141f3f58}{Do\+D\+AD} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} target, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Interface}{Ipv6\+Interface} $>$ interface)
\begin{DoxyCompactList}\small\item\em Do the Duplication \hyperlink{classns3_1_1Address}{Address} Detection (D\+AD). It consists in sending a NS with our I\+Pv6 as target. If we received a NA with matched target address, we could not use the address, else the address pass from T\+E\+N\+T\+A\+T\+I\+VE to P\+E\+R\+M\+A\+N\+E\+NT. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Icmpv6L4Protocol_ae4324a775e75486fad5de41ec3030a0c}{Send\+NA} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} src, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dst, \hyperlink{classns3_1_1Address}{Address} $\ast$hardware\+Address, uint8\+\_\+t flags)
\begin{DoxyCompactList}\small\item\em Send a Neighbor Adverstisement. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Icmpv6L4Protocol_ad7408b6e4b818a857783a4ec373f2a66}{Send\+Echo\+Reply} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} src, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dst, uint16\+\_\+t id, uint16\+\_\+t seq, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data})
\begin{DoxyCompactList}\small\item\em Send a Echo Reply. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Icmpv6L4Protocol_aacd8a4ff185f48e74f4c4b8dc0da4398}{Send\+NS} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} src, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dst, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} target, \hyperlink{classns3_1_1Address}{Address} hardware\+Address)
\begin{DoxyCompactList}\small\item\em Send a Neighbor Solicitation. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Icmpv6L4Protocol_aa54ff6a5f2486f62dc15aa657dd947a0}{Send\+Error\+Destination\+Unreachable} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ malformed\+Packet, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dst, uint8\+\_\+t code)
\begin{DoxyCompactList}\small\item\em Send an error Destination Unreachable. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Icmpv6L4Protocol_a103bf3fdf3212b7fdd351d89adac59d7}{Send\+Error\+Too\+Big} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ malformed\+Packet, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dst, uint32\+\_\+t mtu)
\begin{DoxyCompactList}\small\item\em Send an error Too Big. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Icmpv6L4Protocol_a0912f3bc9bfb032dafe0c295e2dcb047}{Send\+Error\+Time\+Exceeded} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ malformed\+Packet, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dst, uint8\+\_\+t code)
\begin{DoxyCompactList}\small\item\em Send an error \hyperlink{classns3_1_1Time}{Time} Exceeded. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Icmpv6L4Protocol_a5ab4894cdec7b35c4c43f0ee82d61aa6}{Send\+Error\+Parameter\+Error} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ malformed\+Packet, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dst, uint8\+\_\+t code, uint32\+\_\+t ptr)
\begin{DoxyCompactList}\small\item\em Send an error Parameter Error. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Icmpv6L4Protocol_a775f19603b15e25f287f54096a3f26cb}{Send\+Redirection} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ redirected\+Packet, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} src, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dst, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} redir\+Target, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} redir\+Destination, \hyperlink{classns3_1_1Address}{Address} redir\+Hardware\+Target)
\begin{DoxyCompactList}\small\item\em Send an I\+C\+M\+Pv6 Redirection. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1NdiscCache_a29c07f4c9da0e923f442f6440666240e}{Ndisc\+Cache\+::\+Ipv6\+Payload\+Header\+Pair} \hyperlink{classns3_1_1Icmpv6L4Protocol_adb98e7ef239b59c186a7c96bf9735068}{Forge\+NS} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} src, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dst, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} target, \hyperlink{classns3_1_1Address}{Address} hardware\+Address)
\begin{DoxyCompactList}\small\item\em Forge a Neighbor Solicitation. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1NdiscCache_a29c07f4c9da0e923f442f6440666240e}{Ndisc\+Cache\+::\+Ipv6\+Payload\+Header\+Pair} \hyperlink{classns3_1_1Icmpv6L4Protocol_a687a096d8c5580cb3a80bec95b0dd689}{Forge\+NA} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} src, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dst, \hyperlink{classns3_1_1Address}{Address} $\ast$hardware\+Address, uint8\+\_\+t flags)
\begin{DoxyCompactList}\small\item\em Forge a Neighbor Advertisement. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1NdiscCache_a29c07f4c9da0e923f442f6440666240e}{Ndisc\+Cache\+::\+Ipv6\+Payload\+Header\+Pair} \hyperlink{classns3_1_1Icmpv6L4Protocol_ad9a2cfbf2b47401ba857e937081612c2}{Forge\+RS} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} src, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dst, \hyperlink{classns3_1_1Address}{Address} hardware\+Address)
\begin{DoxyCompactList}\small\item\em Forge a Router Solicitation. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1NdiscCache_a29c07f4c9da0e923f442f6440666240e}{Ndisc\+Cache\+::\+Ipv6\+Payload\+Header\+Pair} \hyperlink{classns3_1_1Icmpv6L4Protocol_a2145831e01c5804d4d10d4fa4c5930ba}{Forge\+Echo\+Request} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} src, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dst, uint16\+\_\+t id, uint16\+\_\+t seq, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{topology-example-sim_8cc_a26c65296e316af77b787dc77469bb2a4}{data})
\begin{DoxyCompactList}\small\item\em Forge an Echo Request. \end{DoxyCompactList}\item 
virtual enum \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80e}{Ip\+L4\+Protocol\+::\+Rx\+Status} \hyperlink{classns3_1_1Icmpv6L4Protocol_aedf7165666f27e8907a56247f2da9a88}{Receive} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Ipv4Header}{Ipv4\+Header} const \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv4Interface}{Ipv4\+Interface} $>$ interface)
\begin{DoxyCompactList}\small\item\em Receive method. \end{DoxyCompactList}\item 
virtual enum \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80e}{Ip\+L4\+Protocol\+::\+Rx\+Status} \hyperlink{classns3_1_1Icmpv6L4Protocol_a31342a8123eab651a5cabd1a197b0145}{Receive} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} const \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Interface}{Ipv6\+Interface} $>$ interface)
\begin{DoxyCompactList}\small\item\em Receive method. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Icmpv6L4Protocol_abfb3e1df3fc0d57d3076aa00edba62cd}{Lookup} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dst, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NdiscCache}{Ndisc\+Cache} $>$ cache, \hyperlink{classns3_1_1Address}{Address} $\ast$hardware\+Destination)
\begin{DoxyCompactList}\small\item\em Lookup in the ND cache for the I\+Pv6 address. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Icmpv6L4Protocol_aa4d97bb59a89c2d5b41c76ebe9a54f14}{Lookup} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} \&ip\+Header, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dst, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NdiscCache}{Ndisc\+Cache} $>$ cache, \hyperlink{classns3_1_1Address}{Address} $\ast$hardware\+Destination)
\begin{DoxyCompactList}\small\item\em Lookup in the ND cache for the I\+Pv6 address (similar as A\+RP protocol). \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Icmpv6L4Protocol_aaf09883d79f1a055df31d23089a0ea3b}{Send\+RS} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} src, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dst, \hyperlink{classns3_1_1Address}{Address} hardware\+Address)
\begin{DoxyCompactList}\small\item\em Send a Router Solicitation. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NdiscCache}{Ndisc\+Cache} $>$ \hyperlink{classns3_1_1Icmpv6L4Protocol_a2ef0a9fca4f92a30636372bd6f524847}{Create\+Cache} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Interface}{Ipv6\+Interface} $>$ interface)
\begin{DoxyCompactList}\small\item\em Create a neighbor cache. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Icmpv6L4Protocol_a4accbc330d1a40eca87f03a519d4b1e2}{Is\+Always\+Dad} () const 
\begin{DoxyCompactList}\small\item\em Is the node must do D\+AD. \end{DoxyCompactList}\item 
int64\+\_\+t \hyperlink{classns3_1_1Icmpv6L4Protocol_a04e895ff9568d57d5d97de08577f08b9}{Assign\+Streams} (int64\+\_\+t stream)
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1Icmpv6L4Protocol_ae9378d66f274973df9ddf3bd098499d7}{Get\+Type\+Id} ()
\begin{DoxyCompactList}\small\item\em Get the type ID. \end{DoxyCompactList}\item 
static uint16\+\_\+t \hyperlink{classns3_1_1Icmpv6L4Protocol_af845269e6c3f4509a4e287195c965afc}{Get\+Static\+Protocol\+Number} ()
\begin{DoxyCompactList}\small\item\em Get I\+C\+M\+Pv6 protocol number. \end{DoxyCompactList}\item 
static void \hyperlink{classns3_1_1Icmpv6L4Protocol_a0a7a989da20971c66f85b210be7559c1}{Function\+Dad\+Timeout} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Icmpv6L4Protocol}{Icmpv6\+L4\+Protocol} $>$ icmpv6, \hyperlink{classns3_1_1Ipv6Interface}{Ipv6\+Interface} $\ast$interface, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} addr)
\begin{DoxyCompactList}\small\item\em Function called when D\+AD timeout. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const uint8\+\_\+t \hyperlink{classns3_1_1Icmpv6L4Protocol_aa56c41a886a45b8b4f22a19afc827e2d}{P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER} = 58
\begin{DoxyCompactList}\small\item\em I\+C\+M\+Pv6 protocol number (58). \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1Icmpv6L4Protocol_a6aae989edf64bb22eaaab064d04ba725}{Do\+Dispose} ()
\begin{DoxyCompactList}\small\item\em Dispose this object. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NdiscCache}{Ndisc\+Cache} $>$ $>$ \hyperlink{classns3_1_1Icmpv6L4Protocol_ac7bab2dfb09ca225828e92673c9e3b11}{Cache\+List}
\begin{DoxyCompactList}\small\item\em container of Ndisc\+Caches \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classns3_1_1Icmpv6L4Protocol_a0564a55a65b9c577ecf1de0e6893ebc9}{Forward} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} source, \hyperlink{classns3_1_1Icmpv6Header}{Icmpv6\+Header} icmp, uint32\+\_\+t info, \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} ip\+Header, const uint8\+\_\+t payload\mbox{[}8\mbox{]})
\begin{DoxyCompactList}\small\item\em Notify an I\+C\+M\+Pv6 reception to upper layers (if requested). \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Icmpv6L4Protocol_acec910926a1fdbbea699c10d638aa704}{Handle\+NS} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} const \&src, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} const \&dst, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Interface}{Ipv6\+Interface} $>$ interface)
\begin{DoxyCompactList}\small\item\em Receive Neighbor Solicitation method. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Icmpv6L4Protocol_a5ad8cee1b6e1884f9c833fc09ff4f4e8}{Handle\+RS} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} const \&src, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} const \&dst, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Interface}{Ipv6\+Interface} $>$ interface)
\begin{DoxyCompactList}\small\item\em Receive Router Solicitation method. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Icmpv6L4Protocol_af1a56b5658c12d34615aa712758359d5}{Handle\+RA} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} const \&src, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} const \&dst, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Interface}{Ipv6\+Interface} $>$ interface)
\begin{DoxyCompactList}\small\item\em Receive Router Advertisement method. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Icmpv6L4Protocol_ac3f01017288992311264ef54c57e539b}{Handle\+Echo\+Request} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} const \&src, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} const \&dst, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Interface}{Ipv6\+Interface} $>$ interface)
\begin{DoxyCompactList}\small\item\em Receive Echo Request method. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Icmpv6L4Protocol_a6c3a2ecce98fa29743eb177b613490e5}{Handle\+NA} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} const \&src, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} const \&dst, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Interface}{Ipv6\+Interface} $>$ interface)
\begin{DoxyCompactList}\small\item\em Receive Neighbor Advertisement method. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Icmpv6L4Protocol_ac23066adbd141142fd8d6a86fa1cc4ef}{Handle\+Redirection} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} const \&src, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} const \&dst, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Interface}{Ipv6\+Interface} $>$ interface)
\begin{DoxyCompactList}\small\item\em Receive Redirection method. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Icmpv6L4Protocol_ac7cc1db0945e6dc5be05c82a4aa746be}{Handle\+Destination\+Unreachable} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} const \&src, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} const \&dst, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Interface}{Ipv6\+Interface} $>$ interface)
\begin{DoxyCompactList}\small\item\em Receive Destination Unreachable method. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Icmpv6L4Protocol_ab83a1f9bbf51d2df18d893bb8b2f37ab}{Handle\+Time\+Exceeded} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} const \&src, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} const \&dst, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Interface}{Ipv6\+Interface} $>$ interface)
\begin{DoxyCompactList}\small\item\em Receive \hyperlink{classns3_1_1Time}{Time} Exceeded method. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Icmpv6L4Protocol_a5508e43a5549288270fc050b8b072f51}{Handle\+Packet\+Too\+Big} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} const \&src, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} const \&dst, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Interface}{Ipv6\+Interface} $>$ interface)
\begin{DoxyCompactList}\small\item\em Receive \hyperlink{classns3_1_1Packet}{Packet} Too Big method. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Icmpv6L4Protocol_ae1ec3272a15fdf3bde7037b86191a365}{Handle\+Parameter\+Error} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} const \&src, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} const \&dst, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Interface}{Ipv6\+Interface} $>$ interface)
\begin{DoxyCompactList}\small\item\em Receive Parameter Error method. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Icmpv6L4Protocol_ad6670739eba9c44ba37bf9644bfcdde5}{Receive\+L\+LA} (\hyperlink{classns3_1_1Icmpv6OptionLinkLayerAddress}{Icmpv6\+Option\+Link\+Layer\+Address} lla, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} const \&src, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} const \&dst, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Interface}{Ipv6\+Interface} $>$ interface)
\begin{DoxyCompactList}\small\item\em Link layer address option processing. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NdiscCache}{Ndisc\+Cache} $>$ \hyperlink{classns3_1_1Icmpv6L4Protocol_a90167126423f3957718e22a8bcd325c8}{Find\+Cache} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device)
\begin{DoxyCompactList}\small\item\em Get the cache corresponding to the device. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Icmpv6L4Protocol_a00e5888c45d07ad5a35b98995b813f23}{Set\+Down\+Target} (\hyperlink{classns3_1_1IpL4Protocol_ae3ba76c0a48fbaa90529c528a15f12b6}{Ip\+L4\+Protocol\+::\+Down\+Target\+Callback} cb)
\item 
virtual void \hyperlink{classns3_1_1Icmpv6L4Protocol_aa0f5416435059e873d216ffc07928f23}{Set\+Down\+Target6} (\hyperlink{classns3_1_1IpL4Protocol_a039f3d1883632ab922fa958fc9ecd97f}{Ip\+L4\+Protocol\+::\+Down\+Target\+Callback6} cb)
\item 
virtual \hyperlink{classns3_1_1IpL4Protocol_ae3ba76c0a48fbaa90529c528a15f12b6}{Ip\+L4\+Protocol\+::\+Down\+Target\+Callback} \hyperlink{classns3_1_1Icmpv6L4Protocol_a896e8109bbc5441c6aceb0c7e7a76549}{Get\+Down\+Target} (void) const 
\item 
virtual \hyperlink{classns3_1_1IpL4Protocol_a039f3d1883632ab922fa958fc9ecd97f}{Ip\+L4\+Protocol\+::\+Down\+Target\+Callback6} \hyperlink{classns3_1_1Icmpv6L4Protocol_a192cbd6ca4abe12cb15ea46856d85bb7}{Get\+Down\+Target6} (void) const 
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
uint8\+\_\+t \hyperlink{classns3_1_1Icmpv6L4Protocol_a10486bb2cca386e400fa833e19f93502}{m\+\_\+max\+Multicast\+Solicit}
\begin{DoxyCompactList}\small\item\em Neighbor Discovery node constants\+: max multicast solicitations. \end{DoxyCompactList}\item 
uint8\+\_\+t \hyperlink{classns3_1_1Icmpv6L4Protocol_a772aa2162734a24996b92d673127e7eb}{m\+\_\+max\+Unicast\+Solicit}
\begin{DoxyCompactList}\small\item\em Neighbor Discovery node constants\+: max unicast solicitations. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1Icmpv6L4Protocol_a18fdc8ec4b55d2192edffb949e89f593}{m\+\_\+reachable\+Time}
\begin{DoxyCompactList}\small\item\em Neighbor Discovery node constants\+: reachable time. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1Icmpv6L4Protocol_ab06c636fc6de4e1deefb8e9e53bd0dd4}{m\+\_\+retransmission\+Time}
\begin{DoxyCompactList}\small\item\em Neighbor Discovery node constants\+: retransmission timer. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Time}{Time} \hyperlink{classns3_1_1Icmpv6L4Protocol_acaf08c9a0615db56d8b0a2632abef51a}{m\+\_\+delay\+First\+Probe}
\begin{DoxyCompactList}\small\item\em Neighbor Discovery node constants\+: delay for the first probe. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1Icmpv6L4Protocol_a8968d1631f94f0b1cc1fd0e71ea0d0fe}{m\+\_\+node}
\begin{DoxyCompactList}\small\item\em The node. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Icmpv6L4Protocol_ac7bab2dfb09ca225828e92673c9e3b11}{Cache\+List} \hyperlink{classns3_1_1Icmpv6L4Protocol_af48a7cf3be7bc3d413c9302b10314244}{m\+\_\+cache\+List}
\begin{DoxyCompactList}\small\item\em A list of cache by device. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Icmpv6L4Protocol_aa21acf24e3acd05c073c0b15d94b6759}{m\+\_\+always\+Dad}
\begin{DoxyCompactList}\small\item\em Always do D\+AD ? \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1RandomVariableStream}{Random\+Variable\+Stream} $>$ \hyperlink{classns3_1_1Icmpv6L4Protocol_ac7e4a25978a861e34cef7bdd27efb1d9}{m\+\_\+solicitation\+Jitter}
\begin{DoxyCompactList}\small\item\em Random jitter before sending solicitations. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1IpL4Protocol_a039f3d1883632ab922fa958fc9ecd97f}{Ip\+L4\+Protocol\+::\+Down\+Target\+Callback6} \hyperlink{classns3_1_1Icmpv6L4Protocol_a8cd5beb542044689be316d6e6963bb3a}{m\+\_\+down\+Target}
\begin{DoxyCompactList}\small\item\em callback to \hyperlink{classns3_1_1Ipv6_a2aad308983b20eb54334bb0d3db31004}{Ipv6\+::\+Send} \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
An implementation of the I\+C\+M\+Pv6 protocol. 

\subsection{Member Typedef Documentation}
\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Cache\+List@{Cache\+List}}
\index{Cache\+List@{Cache\+List}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Cache\+List}{CacheList}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Ptr}$<${\bf Ndisc\+Cache}$>$ $>$ {\bf ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Cache\+List}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_ac7bab2dfb09ca225828e92673c9e3b11}{}\label{classns3_1_1Icmpv6L4Protocol_ac7bab2dfb09ca225828e92673c9e3b11}


container of Ndisc\+Caches 



\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Icmpv6\+L4\+Protocol@{Icmpv6\+L4\+Protocol}}
\index{Icmpv6\+L4\+Protocol@{Icmpv6\+L4\+Protocol}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Icmpv6\+L4\+Protocol()}{Icmpv6L4Protocol()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Icmpv6\+L4\+Protocol (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Icmpv6L4Protocol_accdeaa226eb8d84ef23a96e60881f3de}{}\label{classns3_1_1Icmpv6L4Protocol_accdeaa226eb8d84ef23a96e60881f3de}


Constructor. 


\begin{DoxyCode}
103   : \hyperlink{classns3_1_1Icmpv6L4Protocol_a8968d1631f94f0b1cc1fd0e71ea0d0fe}{m\_node} (0)
104 \{
105   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
106 \}
\end{DoxyCode}
\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!````~Icmpv6\+L4\+Protocol@{$\sim$\+Icmpv6\+L4\+Protocol}}
\index{````~Icmpv6\+L4\+Protocol@{$\sim$\+Icmpv6\+L4\+Protocol}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{$\sim$\+Icmpv6\+L4\+Protocol()}{~Icmpv6L4Protocol()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Icmpv6\+L4\+Protocol\+::$\sim$\+Icmpv6\+L4\+Protocol (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_aad392a1007a7d6b775654c9829389b26}{}\label{classns3_1_1Icmpv6L4Protocol_aad392a1007a7d6b775654c9829389b26}


Destructor. 


\begin{DoxyCode}
109 \{
110   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
111 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Assign\+Streams@{Assign\+Streams}}
\index{Assign\+Streams@{Assign\+Streams}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Assign\+Streams(int64\+\_\+t stream)}{AssignStreams(int64_t stream)}}]{\setlength{\rightskip}{0pt plus 5cm}int64\+\_\+t ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Assign\+Streams (
\begin{DoxyParamCaption}
\item[{int64\+\_\+t}]{stream}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Icmpv6L4Protocol_a04e895ff9568d57d5d97de08577f08b9}{}\label{classns3_1_1Icmpv6L4Protocol_a04e895ff9568d57d5d97de08577f08b9}
Assign a fixed random variable stream number to the random variables used by this model. Return the number of streams (possibly zero) that have been assigned.


\begin{DoxyParams}{Parameters}
{\em stream} & first stream index to use \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of stream indices assigned by this model 
\end{DoxyReturn}

\begin{DoxyCode}
130 \{
131   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << stream);
132   \hyperlink{classns3_1_1Icmpv6L4Protocol_ac7e4a25978a861e34cef7bdd27efb1d9}{m\_solicitationJitter}->\hyperlink{classns3_1_1RandomVariableStream_add11aaf975607746b7e271d300659a94}{SetStream} (stream);
133   \textcolor{keywordflow}{return} 1;
134 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 2


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Create\+Cache@{Create\+Cache}}
\index{Create\+Cache@{Create\+Cache}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Create\+Cache(\+Ptr$<$ Net\+Device $>$ device, Ptr$<$ Ipv6\+Interface $>$ interface)}{CreateCache(Ptr< NetDevice > device, Ptr< Ipv6Interface > interface)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ndisc\+Cache} $>$ ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Create\+Cache (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{device, }
\item[{{\bf Ptr}$<$ {\bf Ipv6\+Interface} $>$}]{interface}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Icmpv6L4Protocol_a2ef0a9fca4f92a30636372bd6f524847}{}\label{classns3_1_1Icmpv6L4Protocol_a2ef0a9fca4f92a30636372bd6f524847}


Create a neighbor cache. 


\begin{DoxyParams}{Parameters}
{\em device} & thet \hyperlink{classns3_1_1NetDevice}{Net\+Device} \\
\hline
{\em interface} & the I\+Pv6 interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a smart pointer of Nd\+Cache or 0 if problem 
\end{DoxyReturn}

\begin{DoxyCode}
1286 \{
1287   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << device << interface);
1288 
1289   Ptr<NdiscCache> cache = CreateObject<NdiscCache> ();
1290 
1291   cache->SetDevice (device, interface, \textcolor{keyword}{this});
1292   device->AddLinkChangeCallback (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&\hyperlink{classns3_1_1NdiscCache_a2ff148596a97706775544a0597669dfa}{NdiscCache::Flush}, cache));
1293   \hyperlink{classns3_1_1Icmpv6L4Protocol_af48a7cf3be7bc3d413c9302b10314244}{m\_cacheList}.push\_back (cache);
1294   \textcolor{keywordflow}{return} cache;
1295 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Delayed\+Send\+Message@{Delayed\+Send\+Message}}
\index{Delayed\+Send\+Message@{Delayed\+Send\+Message}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Delayed\+Send\+Message(\+Ptr$<$ Packet $>$ packet, Ipv6\+Address src, Ipv6\+Address dst, uint8\+\_\+t ttl)}{DelayedSendMessage(Ptr< Packet > packet, Ipv6Address src, Ipv6Address dst, uint8_t ttl)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Delayed\+Send\+Message (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Ipv6\+Address}}]{src, }
\item[{{\bf Ipv6\+Address}}]{dst, }
\item[{uint8\+\_\+t}]{ttl}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Icmpv6L4Protocol_a3c4b85301ce19b8b2791402972553127}{}\label{classns3_1_1Icmpv6L4Protocol_a3c4b85301ce19b8b2791402972553127}


Helper function used during delayed solicitation. Calls Send\+Message internally. 


\begin{DoxyParams}{Parameters}
{\em packet} & the packet to send which contains I\+C\+M\+Pv6 header \\
\hline
{\em src} & source address \\
\hline
{\em dst} & destination address \\
\hline
{\em ttl} & next hop limit \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
912 \{
913   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << src << dst << (uint32\_t)ttl);
914   \hyperlink{classns3_1_1Icmpv6L4Protocol_aca22b3999b518531f807d822060a06a8}{SendMessage} (packet, src, dst, ttl);
915 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4




Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Do\+D\+AD@{Do\+D\+AD}}
\index{Do\+D\+AD@{Do\+D\+AD}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Do\+D\+A\+D(\+Ipv6\+Address target, Ptr$<$ Ipv6\+Interface $>$ interface)}{DoDAD(Ipv6Address target, Ptr< Ipv6Interface > interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Do\+D\+AD (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{target, }
\item[{{\bf Ptr}$<$ {\bf Ipv6\+Interface} $>$}]{interface}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Icmpv6L4Protocol_a926ea8e638e30cee8c3c17d4141f3f58}{}\label{classns3_1_1Icmpv6L4Protocol_a926ea8e638e30cee8c3c17d4141f3f58}


Do the Duplication \hyperlink{classns3_1_1Address}{Address} Detection (D\+AD). It consists in sending a NS with our I\+Pv6 as target. If we received a NA with matched target address, we could not use the address, else the address pass from T\+E\+N\+T\+A\+T\+I\+VE to P\+E\+R\+M\+A\+N\+E\+NT. 


\begin{DoxyParams}{Parameters}
{\em target} & target address \\
\hline
{\em interface} & interface \\
\hline
\end{DoxyParams}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000038}{Todo}]disable multicast loopback to prevent NS probing to be received by the sender \end{DoxyRefDesc}

\begin{DoxyCode}
189 \{
190   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << target << interface);
191   Ipv6Address addr;
192   Ptr<Ipv6L3Protocol> ipv6 = \hyperlink{classns3_1_1Icmpv6L4Protocol_a8968d1631f94f0b1cc1fd0e71ea0d0fe}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv6L3Protocol> ();
193 
194   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (ipv6);
195 
196   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1Icmpv6L4Protocol_aa21acf24e3acd05c073c0b15d94b6759}{m\_alwaysDad})
197     \{
198       \textcolor{keywordflow}{return};
199     \}
200 
203   \hyperlink{classns3_1_1NdiscCache_a29c07f4c9da0e923f442f6440666240e}{NdiscCache::Ipv6PayloadHeaderPair} \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = 
      \hyperlink{classns3_1_1Icmpv6L4Protocol_adb98e7ef239b59c186a7c96bf9735068}{ForgeNS} (\textcolor{stringliteral}{"::"},\hyperlink{classns3_1_1Ipv6Address_a1f6831d89cb902b8af5c73baaab97832}{Ipv6Address::MakeSolicitedAddress} (target), target, 
      interface->GetDevice ()->GetAddress ());
204 
205   \textcolor{comment}{/* update last packet UID */}
206   interface->SetNsDadUid (target, p.first->GetUid ());
207   \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (\hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (
      \hyperlink{classns3_1_1Icmpv6L4Protocol_ac7e4a25978a861e34cef7bdd27efb1d9}{m\_solicitationJitter}->\hyperlink{classns3_1_1RandomVariableStream_a4fa5944dc4cb11544e661ed23072b36c}{GetValue} ())), &
      \hyperlink{classns3_1_1Ipv6Interface_aa3be8d7a7f0d8232e2ec9e900a98f727}{Ipv6Interface::Send}, interface, p.first, p.second, 
      \hyperlink{classns3_1_1Ipv6Address_a1f6831d89cb902b8af5c73baaab97832}{Ipv6Address::MakeSolicitedAddress} (target));
208 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6




Here is the caller graph for this function\+:
% FIG 7


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Do\+Dispose()}{DoDispose()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_a6aae989edf64bb22eaaab064d04ba725}{}\label{classns3_1_1Icmpv6L4Protocol_a6aae989edf64bb22eaaab064d04ba725}


Dispose this object. 



Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.


\begin{DoxyCode}
114 \{
115   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
116   \textcolor{keywordflow}{for} (CacheList::const\_iterator it = \hyperlink{classns3_1_1Icmpv6L4Protocol_af48a7cf3be7bc3d413c9302b10314244}{m\_cacheList}.begin (); it != 
      \hyperlink{classns3_1_1Icmpv6L4Protocol_af48a7cf3be7bc3d413c9302b10314244}{m\_cacheList}.end (); it++)
117     \{
118       Ptr<NdiscCache> cache = *it;
119       cache->Dispose ();
120       cache = 0;
121     \}
122   \hyperlink{classns3_1_1Icmpv6L4Protocol_af48a7cf3be7bc3d413c9302b10314244}{m\_cacheList}.clear ();
123   \hyperlink{classns3_1_1Icmpv6L4Protocol_a8cd5beb542044689be316d6e6963bb3a}{m\_downTarget}.\hyperlink{classns3_1_1Callback_ab24de4ac458fc5b1ac6f7a672c4c6cea}{Nullify} ();
124 
125   \hyperlink{classns3_1_1Icmpv6L4Protocol_a8968d1631f94f0b1cc1fd0e71ea0d0fe}{m\_node} = 0;
126   \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{IpL4Protocol::DoDispose} ();
127 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Find\+Cache@{Find\+Cache}}
\index{Find\+Cache@{Find\+Cache}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Find\+Cache(\+Ptr$<$ Net\+Device $>$ device)}{FindCache(Ptr< NetDevice > device)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ndisc\+Cache} $>$ ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Find\+Cache (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{device}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_a90167126423f3957718e22a8bcd325c8}{}\label{classns3_1_1Icmpv6L4Protocol_a90167126423f3957718e22a8bcd325c8}


Get the cache corresponding to the device. 


\begin{DoxyParams}{Parameters}
{\em device} & the device \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the \hyperlink{classns3_1_1NdiscCache}{Ndisc\+Cache} associated with the device 
\end{DoxyReturn}

\begin{DoxyCode}
1269 \{
1270   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << device);
1271 
1272   \textcolor{keywordflow}{for} (CacheList::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = \hyperlink{classns3_1_1Icmpv6L4Protocol_af48a7cf3be7bc3d413c9302b10314244}{m\_cacheList}.begin (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} != 
      \hyperlink{classns3_1_1Icmpv6L4Protocol_af48a7cf3be7bc3d413c9302b10314244}{m\_cacheList}.end (); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
1273     \{
1274       \textcolor{keywordflow}{if} ((*i)->GetDevice () == device)
1275         \{
1276           \textcolor{keywordflow}{return} *\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
1277         \}
1278     \}
1279 
1280   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (\textcolor{keyword}{false});
1281   \textcolor{comment}{/* quiet compiler */}
1282   \textcolor{keywordflow}{return} 0;
1283 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 9


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Forge\+Echo\+Request@{Forge\+Echo\+Request}}
\index{Forge\+Echo\+Request@{Forge\+Echo\+Request}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Forge\+Echo\+Request(\+Ipv6\+Address src, Ipv6\+Address dst, uint16\+\_\+t id, uint16\+\_\+t seq, Ptr$<$ Packet $>$ data)}{ForgeEchoRequest(Ipv6Address src, Ipv6Address dst, uint16_t id, uint16_t seq, Ptr< Packet > data)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ndisc\+Cache\+::\+Ipv6\+Payload\+Header\+Pair} ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Forge\+Echo\+Request (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{src, }
\item[{{\bf Ipv6\+Address}}]{dst, }
\item[{uint16\+\_\+t}]{id, }
\item[{uint16\+\_\+t}]{seq, }
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{data}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Icmpv6L4Protocol_a2145831e01c5804d4d10d4fa4c5930ba}{}\label{classns3_1_1Icmpv6L4Protocol_a2145831e01c5804d4d10d4fa4c5930ba}


Forge an Echo Request. 


\begin{DoxyParams}{Parameters}
{\em src} & source address \\
\hline
{\em dst} & destination address \\
\hline
{\em id} & ID of the packet \\
\hline
{\em seq} & sequence number \\
\hline
{\em data} & the data \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Echo Request packet (with I\+Pv6 header) 
\end{DoxyReturn}

\begin{DoxyCode}
596 \{
597   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << src << dst << \textcolor{keywordtype}{id} << seq << data);
598   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = data->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} ();
599   Ipv6Header ipHeader;
600   Icmpv6Echo req (1);
601 
602   req.SetId (\textcolor{keywordtype}{id});
603   req.SetSeq (seq);
604 
605   req.CalculatePseudoHeaderChecksum (src, dst, p->GetSize () + req.GetSerializedSize (), 
      \hyperlink{classns3_1_1Icmpv6L4Protocol_aa56c41a886a45b8b4f22a19afc827e2d}{PROT\_NUMBER});
606   p->AddHeader (req);
607 
608   ipHeader.SetSourceAddress (src);
609   ipHeader.SetDestinationAddress (dst);
610   ipHeader.SetNextHeader (\hyperlink{classns3_1_1Icmpv6L4Protocol_aa56c41a886a45b8b4f22a19afc827e2d}{PROT\_NUMBER});
611   ipHeader.SetPayloadLength (p->GetSize ());
612   ipHeader.SetHopLimit (255);
613 
614   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1NdiscCache_a29c07f4c9da0e923f442f6440666240e}{NdiscCache::Ipv6PayloadHeaderPair} (p, ipHeader);
615 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Forge\+NA@{Forge\+NA}}
\index{Forge\+NA@{Forge\+NA}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Forge\+N\+A(\+Ipv6\+Address src, Ipv6\+Address dst, Address $\ast$hardware\+Address, uint8\+\_\+t flags)}{ForgeNA(Ipv6Address src, Ipv6Address dst, Address *hardwareAddress, uint8_t flags)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ndisc\+Cache\+::\+Ipv6\+Payload\+Header\+Pair} ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Forge\+NA (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{src, }
\item[{{\bf Ipv6\+Address}}]{dst, }
\item[{{\bf Address} $\ast$}]{hardware\+Address, }
\item[{uint8\+\_\+t}]{flags}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Icmpv6L4Protocol_a687a096d8c5580cb3a80bec95b0dd689}{}\label{classns3_1_1Icmpv6L4Protocol_a687a096d8c5580cb3a80bec95b0dd689}


Forge a Neighbor Advertisement. 


\begin{DoxyParams}{Parameters}
{\em src} & source I\+Pv6 address \\
\hline
{\em dst} & destination I\+Pv6 address \\
\hline
{\em hardware\+Address} & our mac address \\
\hline
{\em flags} & flags (bitfield =$>$ R (4), S (2), O (1)) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
NA packet (with I\+Pv6 header) 
\end{DoxyReturn}

\begin{DoxyCode}
1200 \{
1201   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << src << dst << hardwareAddress << (uint32\_t)flags);
1202   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = Create<Packet> ();
1203   Ipv6Header ipHeader;
1204   Icmpv6NA na;
1205   Icmpv6OptionLinkLayerAddress llOption (0, *hardwareAddress);  \textcolor{comment}{/* we give our mac address in response */}
1206 
1207   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Send NA ( from "} << src << \textcolor{stringliteral}{" to "} << dst << \textcolor{stringliteral}{")"});
1208 
1209   \textcolor{comment}{/* forge the entire NA packet from IPv6 header to ICMPv6 link-layer option, so that the packet does not
       pass by Icmpv6L4Protocol::Lookup again */}
1210 
1211   p->AddHeader (llOption);
1212   na.SetIpv6Target (src);
1213 
1214   \textcolor{keywordflow}{if} ((flags & 1))
1215     \{
1216       na.SetFlagO (\textcolor{keyword}{true});
1217     \}
1218   \textcolor{keywordflow}{if} ((flags & 2) && src != \hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} ())
1219     \{
1220       na.SetFlagS (\textcolor{keyword}{true});
1221     \}
1222   \textcolor{keywordflow}{if} ((flags & 4))
1223     \{
1224       na.SetFlagR (\textcolor{keyword}{true});
1225     \}
1226 
1227   na.CalculatePseudoHeaderChecksum (src, dst, p->GetSize () + na.GetSerializedSize (), 
      \hyperlink{classns3_1_1Icmpv6L4Protocol_aa56c41a886a45b8b4f22a19afc827e2d}{PROT\_NUMBER});
1228   p->AddHeader (na);
1229 
1230   ipHeader.SetSourceAddress (src);
1231   ipHeader.SetDestinationAddress (dst);
1232   ipHeader.SetNextHeader (\hyperlink{classns3_1_1Icmpv6L4Protocol_aa56c41a886a45b8b4f22a19afc827e2d}{PROT\_NUMBER});
1233   ipHeader.SetPayloadLength (p->GetSize ());
1234   ipHeader.SetHopLimit (255);
1235 
1236   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1NdiscCache_a29c07f4c9da0e923f442f6440666240e}{NdiscCache::Ipv6PayloadHeaderPair} (p, ipHeader);
1237 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 11




Here is the caller graph for this function\+:
% FIG 12


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Forge\+NS@{Forge\+NS}}
\index{Forge\+NS@{Forge\+NS}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Forge\+N\+S(\+Ipv6\+Address src, Ipv6\+Address dst, Ipv6\+Address target, Address hardware\+Address)}{ForgeNS(Ipv6Address src, Ipv6Address dst, Ipv6Address target, Address hardwareAddress)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ndisc\+Cache\+::\+Ipv6\+Payload\+Header\+Pair} ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Forge\+NS (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{src, }
\item[{{\bf Ipv6\+Address}}]{dst, }
\item[{{\bf Ipv6\+Address}}]{target, }
\item[{{\bf Address}}]{hardware\+Address}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Icmpv6L4Protocol_adb98e7ef239b59c186a7c96bf9735068}{}\label{classns3_1_1Icmpv6L4Protocol_adb98e7ef239b59c186a7c96bf9735068}


Forge a Neighbor Solicitation. 


\begin{DoxyParams}{Parameters}
{\em src} & source I\+Pv6 address \\
\hline
{\em dst} & destination I\+Pv6 address \\
\hline
{\em target} & target I\+Pv6 address \\
\hline
{\em hardware\+Address} & our mac address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
NS packet (with I\+Pv6 header) 
\end{DoxyReturn}

\begin{DoxyCode}
1240 \{
1241   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << src << dst << target << hardwareAddress);
1242   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = Create<Packet> ();
1243   Ipv6Header ipHeader;
1244   Icmpv6NS ns (target);
1245   Icmpv6OptionLinkLayerAddress llOption (1, hardwareAddress);  \textcolor{comment}{/* we give our mac address in response */}
1246 
1247   \textcolor{comment}{/* if the source is unspec, multicast the NA to all-nodes multicast */}
1248   \textcolor{keywordflow}{if} (src == \hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} ())
1249     \{
1250       dst = \hyperlink{classns3_1_1Ipv6Address_a11e6e4228d3d6e814b2c5ffc18c8ed20}{Ipv6Address::GetAllNodesMulticast} ();
1251     \}
1252 
1253   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Send NS ( from "} << src << \textcolor{stringliteral}{" to "} << dst << \textcolor{stringliteral}{" target "} << target << \textcolor{stringliteral}{")"});
1254 
1255   p->AddHeader (llOption);
1256   ns.CalculatePseudoHeaderChecksum (src, dst, p->GetSize () + ns.GetSerializedSize (), 
      \hyperlink{classns3_1_1Icmpv6L4Protocol_aa56c41a886a45b8b4f22a19afc827e2d}{PROT\_NUMBER});
1257   p->AddHeader (ns);
1258 
1259   ipHeader.SetSourceAddress (src);
1260   ipHeader.SetDestinationAddress (dst);
1261   ipHeader.SetNextHeader (\hyperlink{classns3_1_1Icmpv6L4Protocol_aa56c41a886a45b8b4f22a19afc827e2d}{PROT\_NUMBER});
1262   ipHeader.SetPayloadLength (p->GetSize ());
1263   ipHeader.SetHopLimit (255);
1264 
1265   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1NdiscCache_a29c07f4c9da0e923f442f6440666240e}{NdiscCache::Ipv6PayloadHeaderPair} (p, ipHeader);
1266 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 13




Here is the caller graph for this function\+:
% FIG 14


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Forge\+RS@{Forge\+RS}}
\index{Forge\+RS@{Forge\+RS}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Forge\+R\+S(\+Ipv6\+Address src, Ipv6\+Address dst, Address hardware\+Address)}{ForgeRS(Ipv6Address src, Ipv6Address dst, Address hardwareAddress)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ndisc\+Cache\+::\+Ipv6\+Payload\+Header\+Pair} ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Forge\+RS (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{src, }
\item[{{\bf Ipv6\+Address}}]{dst, }
\item[{{\bf Address}}]{hardware\+Address}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Icmpv6L4Protocol_ad9a2cfbf2b47401ba857e937081612c2}{}\label{classns3_1_1Icmpv6L4Protocol_ad9a2cfbf2b47401ba857e937081612c2}


Forge a Router Solicitation. 


\begin{DoxyParams}{Parameters}
{\em src} & source I\+Pv6 address \\
\hline
{\em dst} & destination I\+Pv6 address \\
\hline
{\em hardware\+Address} & our mac address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
RS packet (with I\+Pv6 header) 
\end{DoxyReturn}

\begin{DoxyCode}
573 \{
574   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << src << dst << hardwareAddress);
575   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = Create<Packet> ();
576   Ipv6Header ipHeader;
577   Icmpv6RS rs;
578   Icmpv6OptionLinkLayerAddress llOption (1, hardwareAddress);  \textcolor{comment}{/* we give our mac address in response */}
579 
580   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Send RS ( from "} << src << \textcolor{stringliteral}{" to "} << dst << \textcolor{stringliteral}{")"});
581   p->AddHeader (llOption);
582 
583   rs.CalculatePseudoHeaderChecksum (src, dst, p->GetSize () + rs.GetSerializedSize (), 
      \hyperlink{classns3_1_1Icmpv6L4Protocol_aa56c41a886a45b8b4f22a19afc827e2d}{PROT\_NUMBER});
584   p->AddHeader (rs);
585 
586   ipHeader.SetSourceAddress (src);
587   ipHeader.SetDestinationAddress (dst);
588   ipHeader.SetNextHeader (\hyperlink{classns3_1_1Icmpv6L4Protocol_aa56c41a886a45b8b4f22a19afc827e2d}{PROT\_NUMBER});
589   ipHeader.SetPayloadLength (p->GetSize ());
590   ipHeader.SetHopLimit (255);
591 
592   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1NdiscCache_a29c07f4c9da0e923f442f6440666240e}{NdiscCache::Ipv6PayloadHeaderPair} (p, ipHeader);
593 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 15


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Forward@{Forward}}
\index{Forward@{Forward}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Forward(\+Ipv6\+Address source, Icmpv6\+Header icmp, uint32\+\_\+t info, Ipv6\+Header ip\+Header, const uint8\+\_\+t payload[8])}{Forward(Ipv6Address source, Icmpv6Header icmp, uint32_t info, Ipv6Header ipHeader, const uint8_t payload[8])}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Forward (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{source, }
\item[{{\bf Icmpv6\+Header}}]{icmp, }
\item[{uint32\+\_\+t}]{info, }
\item[{{\bf Ipv6\+Header}}]{ip\+Header, }
\item[{const uint8\+\_\+t}]{payload\mbox{[}8\mbox{]}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_a0564a55a65b9c577ecf1de0e6893ebc9}{}\label{classns3_1_1Icmpv6L4Protocol_a0564a55a65b9c577ecf1de0e6893ebc9}


Notify an I\+C\+M\+Pv6 reception to upper layers (if requested). 


\begin{DoxyParams}{Parameters}
{\em source} & the I\+C\+MP source \\
\hline
{\em icmp} & the I\+C\+MP header \\
\hline
{\em info} & information about the I\+C\+MP \\
\hline
{\em ip\+Header} & the IP header carried by the I\+C\+MP \\
\hline
{\em payload} & the data carried by the I\+C\+MP \\
\hline
\end{DoxyParams}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000040}{Todo}]assuming the I\+C\+MP is carrying a extensionless IP packet \end{DoxyRefDesc}

\begin{DoxyCode}
280 \{
281   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << source << icmp << info << ipHeader << payload);
282 
283   Ptr<Ipv6L3Protocol> ipv6 = \hyperlink{classns3_1_1Icmpv6L4Protocol_a8968d1631f94f0b1cc1fd0e71ea0d0fe}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv6L3Protocol> ();
284 
286 
287   uint8\_t nextHeader = ipHeader.GetNextHeader ();
288 
289   \textcolor{keywordflow}{if} (nextHeader != \hyperlink{classns3_1_1Icmpv6L4Protocol_aa56c41a886a45b8b4f22a19afc827e2d}{Icmpv6L4Protocol::PROT\_NUMBER})
290     \{
291       Ptr<IpL4Protocol> l4 = ipv6->GetProtocol (nextHeader);
292       \textcolor{keywordflow}{if} (l4 != 0)
293         \{
294           l4->ReceiveIcmp (source, ipHeader.GetHopLimit (), icmp.GetType (), icmp.GetCode (),
295                            info, ipHeader.GetSourceAddress (), ipHeader.GetDestinationAddress (), payload);
296         \}
297     \}
298 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 16




Here is the caller graph for this function\+:
% FIG 17


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Function\+Dad\+Timeout@{Function\+Dad\+Timeout}}
\index{Function\+Dad\+Timeout@{Function\+Dad\+Timeout}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Function\+Dad\+Timeout(\+Ptr$<$ Icmpv6\+L4\+Protocol $>$ icmpv6, Ipv6\+Interface $\ast$interface, Ipv6\+Address addr)}{FunctionDadTimeout(Ptr< Icmpv6L4Protocol > icmpv6, Ipv6Interface *interface, Ipv6Address addr)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Function\+Dad\+Timeout (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Icmpv6\+L4\+Protocol} $>$}]{icmpv6, }
\item[{{\bf Ipv6\+Interface} $\ast$}]{interface, }
\item[{{\bf Ipv6\+Address}}]{addr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_a0a7a989da20971c66f85b210be7559c1}{}\label{classns3_1_1Icmpv6L4Protocol_a0a7a989da20971c66f85b210be7559c1}


Function called when D\+AD timeout. 


\begin{DoxyParams}{Parameters}
{\em icmpv6} & \hyperlink{classns3_1_1Icmpv6L4Protocol}{Icmpv6\+L4\+Protocol} instance \\
\hline
{\em interface} & the interface \\
\hline
{\em addr} & the I\+Pv6 address \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1404 \{
1405   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
1406   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (interface << \textcolor{stringliteral}{" "} << addr);
1407   Ipv6InterfaceAddress ifaddr;
1408   \textcolor{keywordtype}{bool} found = \textcolor{keyword}{false};
1409   uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0;
1410   uint32\_t nb = interface->GetNAddresses ();
1411 
1412   \textcolor{keywordflow}{for} (i = 0; i < nb; i++)
1413     \{
1414       ifaddr = interface->GetAddress (i);
1415 
1416       \textcolor{keywordflow}{if} (ifaddr.GetAddress () == addr)
1417         \{
1418           found = \textcolor{keyword}{true};
1419           \textcolor{keywordflow}{break};
1420         \}
1421     \}
1422 
1423   \textcolor{comment}{/* for the moment, this function is always called, if we was victim of a DAD the address is INVALID}
1424 \textcolor{comment}{   * and we do not set it to PREFERRED}
1425 \textcolor{comment}{   */}
1426   \textcolor{keywordflow}{if} (found && ifaddr.GetState () != \hyperlink{classns3_1_1Ipv6InterfaceAddress_aa01e95b0e78bf3f0200a98f6bfe64f07a5b475f38730e5a2cd323cc530163e47c}{Ipv6InterfaceAddress::INVALID})
1427     \{
1428       interface->SetState (ifaddr.GetAddress (), \hyperlink{classns3_1_1Ipv6InterfaceAddress_aa01e95b0e78bf3f0200a98f6bfe64f07a26b8f336e0dd1571057d46f7a703f626}{Ipv6InterfaceAddress::PREFERRED}
      );
1429       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"DAD OK, interface in state PREFERRED"});
1430 
1431       \textcolor{comment}{/* send an RS if our interface is not forwarding (router) and if address is a link-local ones}
1432 \textcolor{comment}{       * (because we will send RS with it)}
1433 \textcolor{comment}{       */}
1434       Ptr<Ipv6> ipv6 = icmpv6->m\_node->GetObject<Ipv6> ();
1435 
1436       \textcolor{keywordflow}{if} (!ipv6->IsForwarding (ipv6->GetInterfaceForDevice (interface->GetDevice ())) && addr.IsLinkLocal (
      ))
1437         \{
1438           \textcolor{comment}{/* \(\backslash\)todo Add random delays before sending RS}
1439 \textcolor{comment}{           * because all nodes start at the same time, there will be many of RS arround 1 second of
       simulation time}
1440 \textcolor{comment}{           */}
1441           \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (0.0), &
      \hyperlink{classns3_1_1Icmpv6L4Protocol_aaf09883d79f1a055df31d23089a0ea3b}{Icmpv6L4Protocol::SendRS}, \hyperlink{namespacens3_af2a7557fe9afdd98d8f6f8f6e412cf5a}{PeekPointer} (icmpv6), ifaddr.GetAddress (), 
      \hyperlink{classns3_1_1Ipv6Address_aae006ec0f2c8e0cfd792cc1427f493cf}{Ipv6Address::GetAllRoutersMulticast} (), interface->GetDevice ()->
      GetAddress ());
1442         \}
1443     \}
1444 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 18




Here is the caller graph for this function\+:
% FIG 19


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Get\+Delay\+First\+Probe@{Get\+Delay\+First\+Probe}}
\index{Get\+Delay\+First\+Probe@{Get\+Delay\+First\+Probe}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Delay\+First\+Probe() const }{GetDelayFirstProbe() const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Get\+Delay\+First\+Probe (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Icmpv6L4Protocol_af9f99267d950310856adcde5a37da210}{}\label{classns3_1_1Icmpv6L4Protocol_af9f99267d950310856adcde5a37da210}


Neighbor Discovery node constants \+: delay for the first probe. 

\begin{DoxyReturn}{Returns}
The time before a first probe for an Neighbor cache entry. 
\end{DoxyReturn}

\begin{DoxyCode}
1499 \{
1500   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Icmpv6L4Protocol_acaf08c9a0615db56d8b0a2632abef51a}{m\_delayFirstProbe};
1501 \}
\end{DoxyCode}
\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Get\+Down\+Target@{Get\+Down\+Target}}
\index{Get\+Down\+Target@{Get\+Down\+Target}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Down\+Target(void) const }{GetDownTarget(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ip\+L4\+Protocol\+::\+Down\+Target\+Callback} ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Get\+Down\+Target (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_a896e8109bbc5441c6aceb0c7e7a76549}{}\label{classns3_1_1Icmpv6L4Protocol_a896e8109bbc5441c6aceb0c7e7a76549}
This method allows a caller to get the current down target callback set for this L4 protocol (I\+Pv4 case)

\begin{DoxyReturn}{Returns}
current \hyperlink{classns3_1_1Callback}{Callback} for the L4 protocol 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1IpL4Protocol_ac0689deffbf226af223668bca54870d0}{ns3\+::\+Ip\+L4\+Protocol}.


\begin{DoxyCode}
1461 \{
1462   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1463   \textcolor{keywordflow}{return} (\hyperlink{classns3_1_1IpL4Protocol_ae3ba76c0a48fbaa90529c528a15f12b6}{IpL4Protocol::DownTargetCallback})NULL;
1464 \}
\end{DoxyCode}
\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Get\+Down\+Target6@{Get\+Down\+Target6}}
\index{Get\+Down\+Target6@{Get\+Down\+Target6}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Down\+Target6(void) const }{GetDownTarget6(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ip\+L4\+Protocol\+::\+Down\+Target\+Callback6} ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Get\+Down\+Target6 (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_a192cbd6ca4abe12cb15ea46856d85bb7}{}\label{classns3_1_1Icmpv6L4Protocol_a192cbd6ca4abe12cb15ea46856d85bb7}
This method allows a caller to get the current down target callback set for this L4 protocol (I\+Pv6 case)

\begin{DoxyReturn}{Returns}
current \hyperlink{classns3_1_1Callback}{Callback} for the L4 protocol 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1IpL4Protocol_a208389e5d6362765a58c50264b13b18d}{ns3\+::\+Ip\+L4\+Protocol}.


\begin{DoxyCode}
1468 \{
1469   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
1470   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Icmpv6L4Protocol_a8cd5beb542044689be316d6e6963bb3a}{m\_downTarget};
1471 \}
\end{DoxyCode}
\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Get\+Max\+Multicast\+Solicit@{Get\+Max\+Multicast\+Solicit}}
\index{Get\+Max\+Multicast\+Solicit@{Get\+Max\+Multicast\+Solicit}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Max\+Multicast\+Solicit() const }{GetMaxMulticastSolicit() const }}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Get\+Max\+Multicast\+Solicit (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Icmpv6L4Protocol_abb4118285596e2a14fd32270b34025da}{}\label{classns3_1_1Icmpv6L4Protocol_abb4118285596e2a14fd32270b34025da}


Neighbor Discovery node constants\+: max multicast solicitations. 

\begin{DoxyReturn}{Returns}
The max multicast solicitations number. 
\end{DoxyReturn}

\begin{DoxyCode}
1475 \{
1476   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Icmpv6L4Protocol_a10486bb2cca386e400fa833e19f93502}{m\_maxMulticastSolicit};
1477 \}
\end{DoxyCode}
\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Get\+Max\+Unicast\+Solicit@{Get\+Max\+Unicast\+Solicit}}
\index{Get\+Max\+Unicast\+Solicit@{Get\+Max\+Unicast\+Solicit}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Max\+Unicast\+Solicit() const }{GetMaxUnicastSolicit() const }}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Get\+Max\+Unicast\+Solicit (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Icmpv6L4Protocol_a6e9aed5e1a7770899a458b65f00ef62f}{}\label{classns3_1_1Icmpv6L4Protocol_a6e9aed5e1a7770899a458b65f00ef62f}


Neighbor Discovery node constants\+: max unicast solicitations. 

\begin{DoxyReturn}{Returns}
The max unicast solicitations number. 
\end{DoxyReturn}

\begin{DoxyCode}
1481 \{
1482   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Icmpv6L4Protocol_a772aa2162734a24996b92d673127e7eb}{m\_maxUnicastSolicit};
1483 \}
\end{DoxyCode}
\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Get\+Protocol\+Number@{Get\+Protocol\+Number}}
\index{Get\+Protocol\+Number@{Get\+Protocol\+Number}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Protocol\+Number() const }{GetProtocolNumber() const }}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Get\+Protocol\+Number (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_ae84d887e897f60fb4fb41f3f93989825}{}\label{classns3_1_1Icmpv6L4Protocol_ae84d887e897f60fb4fb41f3f93989825}


Get the protocol number. 

\begin{DoxyReturn}{Returns}
protocol number 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1IpL4Protocol_aa5b2c5a670f5304b1a36b890ea858977}{ns3\+::\+Ip\+L4\+Protocol}.


\begin{DoxyCode}
171 \{
172   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
173   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Icmpv6L4Protocol_aa56c41a886a45b8b4f22a19afc827e2d}{PROT\_NUMBER};
174 \}
\end{DoxyCode}
\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Get\+Reachable\+Time@{Get\+Reachable\+Time}}
\index{Get\+Reachable\+Time@{Get\+Reachable\+Time}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Reachable\+Time() const }{GetReachableTime() const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Get\+Reachable\+Time (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Icmpv6L4Protocol_a5fb975cf28febe9997ee704d89bdd9fb}{}\label{classns3_1_1Icmpv6L4Protocol_a5fb975cf28febe9997ee704d89bdd9fb}


Neighbor Discovery node constants\+: reachable time. 

\begin{DoxyReturn}{Returns}
The Reachable time for an Neighbor cache entry. 
\end{DoxyReturn}

\begin{DoxyCode}
1487 \{
1488   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Icmpv6L4Protocol_a18fdc8ec4b55d2192edffb949e89f593}{m\_reachableTime};
1489 \}
\end{DoxyCode}
\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Get\+Retransmission\+Time@{Get\+Retransmission\+Time}}
\index{Get\+Retransmission\+Time@{Get\+Retransmission\+Time}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Retransmission\+Time() const }{GetRetransmissionTime() const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Get\+Retransmission\+Time (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Icmpv6L4Protocol_ad756130c71199a72cf34336fea7f4541}{}\label{classns3_1_1Icmpv6L4Protocol_ad756130c71199a72cf34336fea7f4541}


Neighbor Discovery node constants\+: retransmission timer. 

\begin{DoxyReturn}{Returns}
The Retransmission time for an Neighbor cache entry probe. 
\end{DoxyReturn}

\begin{DoxyCode}
1493 \{
1494   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Icmpv6L4Protocol_ab06c636fc6de4e1deefb8e9e53bd0dd4}{m\_retransmissionTime};
1495 \}
\end{DoxyCode}
\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Get\+Static\+Protocol\+Number@{Get\+Static\+Protocol\+Number}}
\index{Get\+Static\+Protocol\+Number@{Get\+Static\+Protocol\+Number}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Static\+Protocol\+Number()}{GetStaticProtocolNumber()}}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Get\+Static\+Protocol\+Number (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_af845269e6c3f4509a4e287195c965afc}{}\label{classns3_1_1Icmpv6L4Protocol_af845269e6c3f4509a4e287195c965afc}


Get I\+C\+M\+Pv6 protocol number. 

\begin{DoxyReturn}{Returns}
protocol number 
\end{DoxyReturn}

\begin{DoxyCode}
165 \{
166   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
167   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Icmpv6L4Protocol_aa56c41a886a45b8b4f22a19afc827e2d}{PROT\_NUMBER};
168 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 20


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id()}{GetTypeId()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_ae9378d66f274973df9ddf3bd098499d7}{}\label{classns3_1_1Icmpv6L4Protocol_ae9378d66f274973df9ddf3bd098499d7}


Get the type ID. 

\begin{DoxyReturn}{Returns}
the object \hyperlink{classns3_1_1TypeId}{Type\+Id} 
\end{DoxyReturn}

\begin{DoxyCode}
65 \{
66   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::Icmpv6L4Protocol"})
67     .SetParent<IpL4Protocol> ()
68     .SetGroupName (\textcolor{stringliteral}{"Internet"})
69     .AddConstructor<\hyperlink{classns3_1_1Icmpv6L4Protocol_accdeaa226eb8d84ef23a96e60881f3de}{Icmpv6L4Protocol}> ()
70     .AddAttribute (\textcolor{stringliteral}{"DAD"}, \textcolor{stringliteral}{"Always do DAD check."},
71                    BooleanValue (\textcolor{keyword}{true}),
72                    MakeBooleanAccessor (&\hyperlink{classns3_1_1Icmpv6L4Protocol_aa21acf24e3acd05c073c0b15d94b6759}{Icmpv6L4Protocol::m\_alwaysDad}),
73                    MakeBooleanChecker ())
74     .AddAttribute (\textcolor{stringliteral}{"SolicitationJitter"}, \textcolor{stringliteral}{"The jitter in ms a node is allowed to wait before sending any
       solicitation. Some jitter aims to prevent collisions. By default, the model will wait for a duration in ms
       defined by a uniform random-variable between 0 and SolicitationJitter"},
75                    StringValue (\textcolor{stringliteral}{"ns3::UniformRandomVariable[Min=0.0|Max=10.0]"}),
76                    MakePointerAccessor (&\hyperlink{classns3_1_1Icmpv6L4Protocol_ac7e4a25978a861e34cef7bdd27efb1d9}{Icmpv6L4Protocol::m\_solicitationJitter}
      ),
77                    MakePointerChecker<RandomVariableStream> ())
78     .AddAttribute (\textcolor{stringliteral}{"MaxMulticastSolicit"}, \textcolor{stringliteral}{"Neighbor Discovery node constants: max multicast solicitations."}
      ,
79                    IntegerValue (3),
80                    MakeIntegerAccessor (&\hyperlink{classns3_1_1Icmpv6L4Protocol_a10486bb2cca386e400fa833e19f93502}{Icmpv6L4Protocol::m\_maxMulticastSolicit}
      ),
81                    MakeIntegerChecker<uint8\_t> ())
82     .AddAttribute (\textcolor{stringliteral}{"MaxUnicastSolicit"}, \textcolor{stringliteral}{"Neighbor Discovery node constants: max unicast solicitations."},
83                    IntegerValue (3),
84                    MakeIntegerAccessor (&\hyperlink{classns3_1_1Icmpv6L4Protocol_a772aa2162734a24996b92d673127e7eb}{Icmpv6L4Protocol::m\_maxUnicastSolicit}
      ),
85                    MakeIntegerChecker<uint8\_t> ())
86     .AddAttribute (\textcolor{stringliteral}{"ReachableTime"}, \textcolor{stringliteral}{"Neighbor Discovery node constants: reachable time."},
87                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (30)),
88                    MakeTimeAccessor (&\hyperlink{classns3_1_1Icmpv6L4Protocol_a18fdc8ec4b55d2192edffb949e89f593}{Icmpv6L4Protocol::m\_reachableTime}),
89                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
90     .AddAttribute (\textcolor{stringliteral}{"RetransmissionTime"}, \textcolor{stringliteral}{"Neighbor Discovery node constants: retransmission timer."},
91                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (1)),
92                    MakeTimeAccessor (&\hyperlink{classns3_1_1Icmpv6L4Protocol_ab06c636fc6de4e1deefb8e9e53bd0dd4}{Icmpv6L4Protocol::m\_retransmissionTime}
      ),
93                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
94     .AddAttribute (\textcolor{stringliteral}{"DelayFirstProbe"}, \textcolor{stringliteral}{"Neighbor Discovery node constants: delay for the first probe."},
95                    TimeValue (\hyperlink{group__timecivil_ga33c34b816f8ff6628e33d5c8e9713b9e}{Seconds} (5)),
96                    MakeTimeAccessor (&\hyperlink{classns3_1_1Icmpv6L4Protocol_acaf08c9a0615db56d8b0a2632abef51a}{Icmpv6L4Protocol::m\_delayFirstProbe}
      ),
97                    \hyperlink{group__time_ga7032965bd4afa578691d88c09e4481c1}{MakeTimeChecker} ())
98     ;
99   \textcolor{keywordflow}{return} tid;
100 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 21


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Get\+Version@{Get\+Version}}
\index{Get\+Version@{Get\+Version}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Version() const }{GetVersion() const }}]{\setlength{\rightskip}{0pt plus 5cm}int ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Get\+Version (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_a3ea4485be0a45707fd5e72363c737df2}{}\label{classns3_1_1Icmpv6L4Protocol_a3ea4485be0a45707fd5e72363c737df2}


Get the version of the protocol. 

\begin{DoxyReturn}{Returns}
version 
\end{DoxyReturn}

\begin{DoxyCode}
177 \{
178   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
179   \textcolor{keywordflow}{return} 1;
180 \}
\end{DoxyCode}
\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Handle\+Destination\+Unreachable@{Handle\+Destination\+Unreachable}}
\index{Handle\+Destination\+Unreachable@{Handle\+Destination\+Unreachable}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Handle\+Destination\+Unreachable(\+Ptr$<$ Packet $>$ p, Ipv6\+Address const \&src, Ipv6\+Address const \&dst, Ptr$<$ Ipv6\+Interface $>$ interface)}{HandleDestinationUnreachable(Ptr< Packet > p, Ipv6Address const &src, Ipv6Address const &dst, Ptr< Ipv6Interface > interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Handle\+Destination\+Unreachable (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{{\bf Ipv6\+Address} const \&}]{src, }
\item[{{\bf Ipv6\+Address} const \&}]{dst, }
\item[{{\bf Ptr}$<$ {\bf Ipv6\+Interface} $>$}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_ac7cc1db0945e6dc5be05c82a4aa746be}{}\label{classns3_1_1Icmpv6L4Protocol_ac7cc1db0945e6dc5be05c82a4aa746be}


Receive Destination Unreachable method. 


\begin{DoxyParams}{Parameters}
{\em p} & the packet \\
\hline
{\em src} & source address \\
\hline
{\em dst} & destination address \\
\hline
{\em interface} & the interface from which the packet is coming \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
829 \{
830   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << *p << src << dst << interface);
831   Ptr<Packet> pkt = p->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} ();
832 
833   Icmpv6DestinationUnreachable unreach;
834   pkt->\hyperlink{classns3_1_1Packet_a0961eccf975d75f902d40956c93ba63e}{RemoveHeader} (unreach);
835   Ptr<Packet> origPkt = unreach.GetPacket ();
836 
837   Ipv6Header ipHeader;
838   \textcolor{keywordflow}{if} ( origPkt->GetSize () > ipHeader.GetSerializedSize () )
839     \{
840       origPkt->RemoveHeader (ipHeader);
841       uint8\_t payload[8];
842       origPkt->CopyData (payload, 8);
843       \hyperlink{classns3_1_1Icmpv6L4Protocol_a0564a55a65b9c577ecf1de0e6893ebc9}{Forward} (src, unreach, unreach.GetCode (), ipHeader, payload);
844     \}
845 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 22




Here is the caller graph for this function\+:
% FIG 23


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Handle\+Echo\+Request@{Handle\+Echo\+Request}}
\index{Handle\+Echo\+Request@{Handle\+Echo\+Request}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Handle\+Echo\+Request(\+Ptr$<$ Packet $>$ p, Ipv6\+Address const \&src, Ipv6\+Address const \&dst, Ptr$<$ Ipv6\+Interface $>$ interface)}{HandleEchoRequest(Ptr< Packet > p, Ipv6Address const &src, Ipv6Address const &dst, Ptr< Ipv6Interface > interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Handle\+Echo\+Request (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{{\bf Ipv6\+Address} const \&}]{src, }
\item[{{\bf Ipv6\+Address} const \&}]{dst, }
\item[{{\bf Ptr}$<$ {\bf Ipv6\+Interface} $>$}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_ac3f01017288992311264ef54c57e539b}{}\label{classns3_1_1Icmpv6L4Protocol_ac3f01017288992311264ef54c57e539b}


Receive Echo Request method. 


\begin{DoxyParams}{Parameters}
{\em p} & the packet \\
\hline
{\em src} & source address \\
\hline
{\em dst} & destination address \\
\hline
{\em interface} & the interface from which the packet is coming \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
301 \{
302   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << src << dst << interface);
303   Icmpv6Echo request;
304   uint8\_t* buf = \textcolor{keyword}{new} uint8\_t[packet->GetSize ()];
305 
306   packet->RemoveHeader (request);
307   \textcolor{comment}{/* XXX IPv6 extension: obtain a fresh copy of data otherwise it crash... */}
308   packet->CopyData (buf, packet->GetSize ());
309   Ptr<Packet> p = Create<Packet> (buf, packet->GetSize ());
310 
311   \textcolor{comment}{/* if we send message from ff02::* (link-local multicast), we use our link-local address */}
312   \hyperlink{classns3_1_1Icmpv6L4Protocol_ad7408b6e4b818a857783a4ec373f2a66}{SendEchoReply} (dst.IsMulticast () ? interface->GetLinkLocalAddress ().GetAddress () : dst, 
      src, request.GetId (), request.GetSeq (), \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p});
313   \textcolor{keyword}{delete}[] buf;
314 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 24




Here is the caller graph for this function\+:
% FIG 25


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Handle\+NA@{Handle\+NA}}
\index{Handle\+NA@{Handle\+NA}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Handle\+N\+A(\+Ptr$<$ Packet $>$ p, Ipv6\+Address const \&src, Ipv6\+Address const \&dst, Ptr$<$ Ipv6\+Interface $>$ interface)}{HandleNA(Ptr< Packet > p, Ipv6Address const &src, Ipv6Address const &dst, Ptr< Ipv6Interface > interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Handle\+NA (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{{\bf Ipv6\+Address} const \&}]{src, }
\item[{{\bf Ipv6\+Address} const \&}]{dst, }
\item[{{\bf Ptr}$<$ {\bf Ipv6\+Interface} $>$}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_a6c3a2ecce98fa29743eb177b613490e5}{}\label{classns3_1_1Icmpv6L4Protocol_a6c3a2ecce98fa29743eb177b613490e5}


Receive Neighbor Advertisement method. 


\begin{DoxyParams}{Parameters}
{\em p} & the packet \\
\hline
{\em src} & source address \\
\hline
{\em dst} & destination address \\
\hline
{\em interface} & the interface from which the packet is coming \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
618 \{
619   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << src << dst << interface);
620   Icmpv6NA naHeader;
621   Icmpv6OptionLinkLayerAddress lla (1);
622 
623   packet->RemoveHeader (naHeader);
624   Ipv6Address target = naHeader.GetIpv6Target ();
625 
626   Address hardwareAddress;
627   NdiscCache::Entry* entry = 0;
628   Ptr<NdiscCache> cache = \hyperlink{classns3_1_1Icmpv6L4Protocol_a90167126423f3957718e22a8bcd325c8}{FindCache} (interface->GetDevice ());
629   std::list<NdiscCache::Ipv6PayloadHeaderPair> waiting;
630 
631   \textcolor{comment}{/* check if we have something in our cache */}
632   entry = cache->Lookup (target);
633 
634   \textcolor{keywordflow}{if} (!entry)
635     \{
636       \textcolor{comment}{/* ouch!! we might be victim of a DAD */}
637       
638       Ipv6InterfaceAddress ifaddr;
639       \textcolor{keywordtype}{bool} found = \textcolor{keyword}{false};
640       uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0;
641       uint32\_t nb = interface->GetNAddresses ();
642 
643       \textcolor{keywordflow}{for} (i = 0; i < nb; i++)
644         \{
645           ifaddr = interface->GetAddress (i);
646           \textcolor{keywordflow}{if} (ifaddr.GetAddress () == target)
647             \{
648               found = \textcolor{keyword}{true};
649               \textcolor{keywordflow}{break};
650             \}
651         \}
652 
653       \textcolor{keywordflow}{if} (found)
654         \{
655           \textcolor{keywordflow}{if} (ifaddr.GetState () == \hyperlink{classns3_1_1Ipv6InterfaceAddress_aa01e95b0e78bf3f0200a98f6bfe64f07ab063514dcc5adedfd56f1ad77fec415c}{Ipv6InterfaceAddress::TENTATIVE} || 
      ifaddr.GetState () == \hyperlink{classns3_1_1Ipv6InterfaceAddress_aa01e95b0e78bf3f0200a98f6bfe64f07a53eead20cfcd55f67318da206a7a109f}{Ipv6InterfaceAddress::TENTATIVE\_OPTIMISTIC})
656             \{
657               interface->SetState (ifaddr.GetAddress (), 
      \hyperlink{classns3_1_1Ipv6InterfaceAddress_aa01e95b0e78bf3f0200a98f6bfe64f07a5b475f38730e5a2cd323cc530163e47c}{Ipv6InterfaceAddress::INVALID});
658             \}
659         \}
660 
661       \textcolor{comment}{/* we have not initiated any communication with the target so... discard the NA */}
662       \textcolor{keywordflow}{return};
663     \}
664 
665   \textcolor{comment}{/* XXX search all options following the NA header */}
666   \textcolor{comment}{/* Get LLA */}
667   uint8\_t \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type};
668   packet->CopyData (&type, \textcolor{keyword}{sizeof}(type));
669 
670   \textcolor{keywordflow}{if} (type != \hyperlink{classns3_1_1Icmpv6Header_a1992e0e28c453f5e23b1ad55a49b7908a9a014e199d5c5492a04523cf04938b26}{Icmpv6Header::ICMPV6\_OPT\_LINK\_LAYER\_TARGET})
671     \{
672       \textcolor{keywordflow}{return};
673     \}
674   packet->RemoveHeader (lla);
675 
676   \textcolor{keywordflow}{if} (entry->IsIncomplete ())
677     \{
678       \textcolor{comment}{/* we receive a NA so stop the retransmission timer */}
679       entry->StopNudTimer ();
680 
681       \textcolor{keywordflow}{if} (naHeader.GetFlagS ())
682         \{
683           \textcolor{comment}{/* mark it to reachable */}
684           waiting = entry->MarkReachable (lla.GetAddress ());
685           entry->StartReachableTimer ();
686           \textcolor{comment}{/* send out waiting packet */}
687           \textcolor{keywordflow}{for} (std::list<NdiscCache::Ipv6PayloadHeaderPair>::const\_iterator it = waiting.begin (); it != 
      waiting.end (); it++)
688             \{
689               cache->GetInterface ()->Send (it->first, it->second, src);
690             \}
691           entry->ClearWaitingPacket ();
692         \}
693       \textcolor{keywordflow}{else}
694         \{
695           entry->MarkStale (lla.GetAddress ());
696         \}
697 
698       \textcolor{keywordflow}{if} (naHeader.GetFlagR ())
699         \{
700           entry->SetRouter (\textcolor{keyword}{true});
701         \}
702     \}
703   \textcolor{keywordflow}{else}
704     \{
705       \textcolor{comment}{/* we receive a NA so stop the probe timer or delay timer if any */}
706       entry->StopNudTimer ();
707 
708       \textcolor{comment}{/* if the Flag O is clear and mac address differs from the cache */}
709       \textcolor{keywordflow}{if} (!naHeader.GetFlagO () && lla.GetAddress () != entry->GetMacAddress ())
710         \{
711           \textcolor{keywordflow}{if} (entry->IsReachable ())
712             \{
713               entry->MarkStale ();
714             \}
715           \textcolor{keywordflow}{return};
716         \}
717       \textcolor{keywordflow}{else}
718         \{
719           \textcolor{keywordflow}{if} ((!naHeader.GetFlagO () && lla.GetAddress () == entry->GetMacAddress ()) || naHeader.GetFlagO 
      ()) \textcolor{comment}{/* XXX lake "no target link-layer address option supplied" */}
720             \{
721               entry->SetMacAddress (lla.GetAddress ());
722 
723               \textcolor{keywordflow}{if} (naHeader.GetFlagS ())
724                 \{
725                   \textcolor{keywordflow}{if} (!entry->IsReachable () || !entry->IsPermanent ())
726                     \{
727                       \textcolor{keywordflow}{if} (entry->IsProbe ())
728                         \{
729                           waiting = entry->MarkReachable (lla.GetAddress ());
730                           \textcolor{keywordflow}{for} (std::list<NdiscCache::Ipv6PayloadHeaderPair>::const\_iterator it = waiting.
      begin (); it != waiting.end (); it++)
731                             \{
732                               cache->GetInterface ()->Send (it->first, it->second, src);
733                             \}
734                           entry->ClearWaitingPacket ();
735                         \}
736                       \textcolor{keywordflow}{else}
737                         \{
738                           entry->MarkReachable (lla.GetAddress ());
739                         \}
740                     \}
741                   \textcolor{keywordflow}{if} (!entry->IsPermanent ())
742                     \{
743                       entry->StartReachableTimer ();
744                     \}
745                 \}
746               \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (lla.GetAddress () != entry->GetMacAddress ())
747                 \{
748                   entry->MarkStale ();
749                 \}
750               entry->SetRouter (naHeader.GetFlagR ());
751             \}
752         \}
753     \}
754 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 26




Here is the caller graph for this function\+:
% FIG 27


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Handle\+NS@{Handle\+NS}}
\index{Handle\+NS@{Handle\+NS}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Handle\+N\+S(\+Ptr$<$ Packet $>$ p, Ipv6\+Address const \&src, Ipv6\+Address const \&dst, Ptr$<$ Ipv6\+Interface $>$ interface)}{HandleNS(Ptr< Packet > p, Ipv6Address const &src, Ipv6Address const &dst, Ptr< Ipv6Interface > interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Handle\+NS (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{{\bf Ipv6\+Address} const \&}]{src, }
\item[{{\bf Ipv6\+Address} const \&}]{dst, }
\item[{{\bf Ptr}$<$ {\bf Ipv6\+Interface} $>$}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_acec910926a1fdbbea699c10d638aa704}{}\label{classns3_1_1Icmpv6L4Protocol_acec910926a1fdbbea699c10d638aa704}


Receive Neighbor Solicitation method. 


\begin{DoxyParams}{Parameters}
{\em p} & the packet \\
\hline
{\em src} & source address \\
\hline
{\em dst} & destination address \\
\hline
{\em interface} & the interface from which the packet is coming \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
480 \{
481   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << src << dst << interface);
482   Icmpv6NS nsHeader (\textcolor{stringliteral}{"::"});
483   Ipv6InterfaceAddress ifaddr;
484   uint32\_t nb = interface->GetNAddresses ();
485   uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0;
486   \textcolor{keywordtype}{bool} found = \textcolor{keyword}{false};
487 
488   packet->RemoveHeader (nsHeader);
489 
490   Ipv6Address target = nsHeader.GetIpv6Target ();
491 
492   \textcolor{keywordflow}{for} (i = 0; i < nb; i++)
493     \{
494       ifaddr = interface->GetAddress (i);
495 
496       \textcolor{keywordflow}{if} (ifaddr.GetAddress () == target)
497         \{
498           found = \textcolor{keyword}{true};
499           \textcolor{keywordflow}{break};
500         \}
501     \}
502 
503   \textcolor{keywordflow}{if} (!found)
504     \{
505       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Not a NS for us"});
506       \textcolor{keywordflow}{return};
507     \}
508 
509   \textcolor{keywordflow}{if} (packet->GetUid () == ifaddr.GetNsDadUid ())
510     \{
511       \textcolor{comment}{/* don't process our own DAD probe */}
512       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Hey we receive our DAD probe!"});
513       \textcolor{keywordflow}{return};
514     \}
515 
516   Icmpv6OptionLinkLayerAddress lla (1);
517   Address hardwareAddress;
518   NdiscCache::Entry* entry = 0;
519   Ptr<NdiscCache> cache = \hyperlink{classns3_1_1Icmpv6L4Protocol_a90167126423f3957718e22a8bcd325c8}{FindCache} (interface->GetDevice ());
520   uint8\_t flags = 0;
521 
522   \textcolor{comment}{/* XXX search all options following the NS header */}
523 
524   \textcolor{keywordflow}{if} (src != \hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} ())
525     \{
526       uint8\_t \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type};
527       packet->CopyData (&type, \textcolor{keyword}{sizeof}(type));
528 
529       \textcolor{keywordflow}{if} (type != \hyperlink{classns3_1_1Icmpv6Header_a1992e0e28c453f5e23b1ad55a49b7908a07035de174ae9be5f6818c46eb299c48}{Icmpv6Header::ICMPV6\_OPT\_LINK\_LAYER\_SOURCE})
530         \{
531           \textcolor{keywordflow}{return};
532         \}
533 
534       \textcolor{comment}{/* Get LLA */}
535       packet->RemoveHeader (lla);
536 
537       entry = cache->Lookup (src);
538       \textcolor{keywordflow}{if} (!entry)
539         \{
540           entry = cache->Add (src);
541           entry->SetRouter (\textcolor{keyword}{false});
542           entry->MarkStale (lla.GetAddress ());
543         \}
544       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (entry->GetMacAddress () != lla.GetAddress ())
545         \{
546           entry->MarkStale (lla.GetAddress ());
547         \}
548 
549       flags = 3; \textcolor{comment}{/* S + O flags */}
550     \}
551   \textcolor{keywordflow}{else}
552     \{
553       \textcolor{comment}{/* it means someone do a DAD */}
554       flags = 1; \textcolor{comment}{/* O flag */}
555     \}
556 
557   \textcolor{comment}{/* send a NA to src */}
558   Ptr<Ipv6L3Protocol> ipv6 = \hyperlink{classns3_1_1Icmpv6L4Protocol_a8968d1631f94f0b1cc1fd0e71ea0d0fe}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv6L3Protocol> ();
559 
560   \textcolor{keywordflow}{if} (ipv6->IsForwarding (ipv6->GetInterfaceForDevice (interface->GetDevice ())))
561     \{
562       flags += 4; \textcolor{comment}{/* R flag */}
563     \}
564 
565   hardwareAddress = interface->GetDevice ()->GetAddress ();
566   \hyperlink{classns3_1_1NdiscCache_a29c07f4c9da0e923f442f6440666240e}{NdiscCache::Ipv6PayloadHeaderPair} p = \hyperlink{classns3_1_1Icmpv6L4Protocol_a687a096d8c5580cb3a80bec95b0dd689}{ForgeNA} (target.IsLinkLocal
       () ? interface->GetLinkLocalAddress ().GetAddress () : ifaddr.GetAddress (), src.IsAny () ? 
      \hyperlink{classns3_1_1Ipv6Address_a11e6e4228d3d6e814b2c5ffc18c8ed20}{Ipv6Address::GetAllNodesMulticast} () : src, &hardwareAddress, flags );
567   interface->Send (p.first, p.second, src.IsAny () ? 
      \hyperlink{classns3_1_1Ipv6Address_a11e6e4228d3d6e814b2c5ffc18c8ed20}{Ipv6Address::GetAllNodesMulticast} () : src);
568 
569   \textcolor{comment}{/* not a NS for us discard it */}
570 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 28




Here is the caller graph for this function\+:
% FIG 29


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Handle\+Packet\+Too\+Big@{Handle\+Packet\+Too\+Big}}
\index{Handle\+Packet\+Too\+Big@{Handle\+Packet\+Too\+Big}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Handle\+Packet\+Too\+Big(\+Ptr$<$ Packet $>$ p, Ipv6\+Address const \&src, Ipv6\+Address const \&dst, Ptr$<$ Ipv6\+Interface $>$ interface)}{HandlePacketTooBig(Ptr< Packet > p, Ipv6Address const &src, Ipv6Address const &dst, Ptr< Ipv6Interface > interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Handle\+Packet\+Too\+Big (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{{\bf Ipv6\+Address} const \&}]{src, }
\item[{{\bf Ipv6\+Address} const \&}]{dst, }
\item[{{\bf Ptr}$<$ {\bf Ipv6\+Interface} $>$}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_a5508e43a5549288270fc050b8b072f51}{}\label{classns3_1_1Icmpv6L4Protocol_a5508e43a5549288270fc050b8b072f51}


Receive \hyperlink{classns3_1_1Packet}{Packet} Too Big method. 


\begin{DoxyParams}{Parameters}
{\em p} & the packet \\
\hline
{\em src} & source address \\
\hline
{\em dst} & destination address \\
\hline
{\em interface} & the interface from which the packet is coming \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
864 \{
865   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << *p << src << dst << interface);
866   Ptr<Packet> pkt = p->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} ();
867 
868   Icmpv6TooBig tooBig;
869   pkt->\hyperlink{classns3_1_1Packet_a0961eccf975d75f902d40956c93ba63e}{RemoveHeader} (tooBig);
870   Ptr<Packet> origPkt = tooBig.GetPacket ();
871 
872   Ipv6Header ipHeader;
873   origPkt->RemoveHeader (ipHeader);
874   uint8\_t payload[8];
875   origPkt->CopyData (payload, 8);
876 
877   Ptr<Ipv6L3Protocol> ipv6 = \hyperlink{classns3_1_1Icmpv6L4Protocol_a8968d1631f94f0b1cc1fd0e71ea0d0fe}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv6L3Protocol> ();
878   ipv6->SetPmtu(ipHeader.GetDestinationAddress(), tooBig.GetMtu ());
879 
880   \hyperlink{classns3_1_1Icmpv6L4Protocol_a0564a55a65b9c577ecf1de0e6893ebc9}{Forward} (src, tooBig, tooBig.GetMtu (), ipHeader, payload);
881 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 30




Here is the caller graph for this function\+:
% FIG 31


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Handle\+Parameter\+Error@{Handle\+Parameter\+Error}}
\index{Handle\+Parameter\+Error@{Handle\+Parameter\+Error}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Handle\+Parameter\+Error(\+Ptr$<$ Packet $>$ p, Ipv6\+Address const \&src, Ipv6\+Address const \&dst, Ptr$<$ Ipv6\+Interface $>$ interface)}{HandleParameterError(Ptr< Packet > p, Ipv6Address const &src, Ipv6Address const &dst, Ptr< Ipv6Interface > interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Handle\+Parameter\+Error (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{{\bf Ipv6\+Address} const \&}]{src, }
\item[{{\bf Ipv6\+Address} const \&}]{dst, }
\item[{{\bf Ptr}$<$ {\bf Ipv6\+Interface} $>$}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_ae1ec3272a15fdf3bde7037b86191a365}{}\label{classns3_1_1Icmpv6L4Protocol_ae1ec3272a15fdf3bde7037b86191a365}


Receive Parameter Error method. 


\begin{DoxyParams}{Parameters}
{\em p} & the packet \\
\hline
{\em src} & source address \\
\hline
{\em dst} & destination address \\
\hline
{\em interface} & the interface from which the packet is coming \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
884 \{
885   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << *p << src << dst << interface);
886   Ptr<Packet> pkt = p->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} ();
887 
888   Icmpv6ParameterError paramErr;
889   pkt->\hyperlink{classns3_1_1Packet_a0961eccf975d75f902d40956c93ba63e}{RemoveHeader} (paramErr);
890   Ptr<Packet> origPkt = paramErr.GetPacket ();
891 
892   Ipv6Header ipHeader;
893   origPkt->RemoveHeader (ipHeader);
894   uint8\_t payload[8];
895   origPkt->CopyData (payload, 8);
896   \hyperlink{classns3_1_1Icmpv6L4Protocol_a0564a55a65b9c577ecf1de0e6893ebc9}{Forward} (src, paramErr, paramErr.GetCode (), ipHeader, payload);
897 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 32




Here is the caller graph for this function\+:
% FIG 33


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Handle\+RA@{Handle\+RA}}
\index{Handle\+RA@{Handle\+RA}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Handle\+R\+A(\+Ptr$<$ Packet $>$ p, Ipv6\+Address const \&src, Ipv6\+Address const \&dst, Ptr$<$ Ipv6\+Interface $>$ interface)}{HandleRA(Ptr< Packet > p, Ipv6Address const &src, Ipv6Address const &dst, Ptr< Ipv6Interface > interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Handle\+RA (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{{\bf Ipv6\+Address} const \&}]{src, }
\item[{{\bf Ipv6\+Address} const \&}]{dst, }
\item[{{\bf Ptr}$<$ {\bf Ipv6\+Interface} $>$}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_af1a56b5658c12d34615aa712758359d5}{}\label{classns3_1_1Icmpv6L4Protocol_af1a56b5658c12d34615aa712758359d5}


Receive Router Advertisement method. 


\begin{DoxyParams}{Parameters}
{\em p} & the packet \\
\hline
{\em src} & source address \\
\hline
{\em dst} & destination address \\
\hline
{\em interface} & the interface from which the packet is coming \\
\hline
\end{DoxyParams}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000041}{Todo}]case of multiple prefix on single interface \end{DoxyRefDesc}

\begin{DoxyCode}
317 \{
318   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << src << dst << interface);
319   Ptr<Packet> p = packet->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} ();
320   Icmpv6RA raHeader;
321   Ptr<Ipv6L3Protocol> ipv6 = \hyperlink{classns3_1_1Icmpv6L4Protocol_a8968d1631f94f0b1cc1fd0e71ea0d0fe}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv6L3Protocol> ();
322   Icmpv6OptionPrefixInformation prefixHdr;
323   Icmpv6OptionMtu mtuHdr;
324   Icmpv6OptionLinkLayerAddress llaHdr;
325   \textcolor{keywordtype}{bool} next = \textcolor{keyword}{true};
326   \textcolor{keywordtype}{bool} hasLla = \textcolor{keyword}{false};
327   \textcolor{keywordtype}{bool} hasMtu = \textcolor{keyword}{false};
328   Ipv6Address defaultRouter = \hyperlink{classns3_1_1Ipv6Address_a63a34bdb1505e05fbdd07d316d0bd7e6}{Ipv6Address::GetZero} ();
329 
330   p->RemoveHeader (raHeader);
331 
332   \textcolor{keywordflow}{if} (raHeader.GetLifeTime())
333     \{
334       defaultRouter = src;
335     \}
336 
337   \textcolor{keywordflow}{while} (next == \textcolor{keyword}{true})
338     \{
339       uint8\_t \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type} = 0;
340       p->CopyData (&type, \textcolor{keyword}{sizeof}(type));
341 
342       \textcolor{keywordflow}{switch} (type)
343         \{
344         \textcolor{keywordflow}{case} \hyperlink{classns3_1_1Icmpv6Header_a1992e0e28c453f5e23b1ad55a49b7908ad2ca2001cf55fb44a575a7dc992e0e2e}{Icmpv6Header::ICMPV6\_OPT\_PREFIX}:
345           p->RemoveHeader (prefixHdr);
346           ipv6->AddAutoconfiguredAddress (ipv6->GetInterfaceForDevice (interface->GetDevice ()), prefixHdr.
      GetPrefix (), prefixHdr.GetPrefixLength (),
347                                           prefixHdr.GetFlags (), prefixHdr.GetValidTime (), prefixHdr.
      GetPreferredTime (), defaultRouter);
348           \textcolor{keywordflow}{break};
349         \textcolor{keywordflow}{case} \hyperlink{classns3_1_1Icmpv6Header_a1992e0e28c453f5e23b1ad55a49b7908a01736885b7e667e2ec3b76f9bae8b0cb}{Icmpv6Header::ICMPV6\_OPT\_MTU}:
350           \textcolor{comment}{/* take in account the first MTU option */}
351           \textcolor{keywordflow}{if} (!hasMtu)
352             \{
353               p->RemoveHeader (mtuHdr);
354               hasMtu = \textcolor{keyword}{true};
356               \textcolor{comment}{/* interface->GetDevice ()->SetMtu (m.GetMtu ()); */}
357             \}
358           \textcolor{keywordflow}{break};
359         \textcolor{keywordflow}{case} \hyperlink{classns3_1_1Icmpv6Header_a1992e0e28c453f5e23b1ad55a49b7908a07035de174ae9be5f6818c46eb299c48}{Icmpv6Header::ICMPV6\_OPT\_LINK\_LAYER\_SOURCE}:
360           \textcolor{comment}{/* take in account the first LLA option */}
361           \textcolor{keywordflow}{if} (!hasLla)
362             \{
363               p->RemoveHeader (llaHdr);
364               \hyperlink{classns3_1_1Icmpv6L4Protocol_ad6670739eba9c44ba37bf9644bfcdde5}{ReceiveLLA} (llaHdr, src, dst, interface);
365               hasLla = \textcolor{keyword}{true};
366             \}
367           \textcolor{keywordflow}{break};
368         \textcolor{keywordflow}{default}:
369           \textcolor{comment}{/* unknow option, quit */}
370           next = \textcolor{keyword}{false};
371         \}
372     \}
373 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 34




Here is the caller graph for this function\+:
% FIG 35


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Handle\+Redirection@{Handle\+Redirection}}
\index{Handle\+Redirection@{Handle\+Redirection}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Handle\+Redirection(\+Ptr$<$ Packet $>$ p, Ipv6\+Address const \&src, Ipv6\+Address const \&dst, Ptr$<$ Ipv6\+Interface $>$ interface)}{HandleRedirection(Ptr< Packet > p, Ipv6Address const &src, Ipv6Address const &dst, Ptr< Ipv6Interface > interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Handle\+Redirection (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{{\bf Ipv6\+Address} const \&}]{src, }
\item[{{\bf Ipv6\+Address} const \&}]{dst, }
\item[{{\bf Ptr}$<$ {\bf Ipv6\+Interface} $>$}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_ac23066adbd141142fd8d6a86fa1cc4ef}{}\label{classns3_1_1Icmpv6L4Protocol_ac23066adbd141142fd8d6a86fa1cc4ef}


Receive Redirection method. 


\begin{DoxyParams}{Parameters}
{\em p} & the packet \\
\hline
{\em src} & source address \\
\hline
{\em dst} & destination address \\
\hline
{\em interface} & the interface from which the packet is coming \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
757 \{
758   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << src << dst << interface);
759   \textcolor{keywordtype}{bool} hasLla = \textcolor{keyword}{false};
760   Ptr<Packet> p = packet->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} ();
761   Icmpv6OptionLinkLayerAddress llOptionHeader (0);
762 
763   Icmpv6Redirection redirectionHeader;
764   p->RemoveHeader (redirectionHeader);
765 
766   \textcolor{comment}{/* little ugly try to find a better way */}
767   uint8\_t \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type};
768   p->CopyData (&type, \textcolor{keyword}{sizeof}(type));
769   \textcolor{keywordflow}{if} (type == \hyperlink{classns3_1_1Icmpv6Header_a1992e0e28c453f5e23b1ad55a49b7908a9a014e199d5c5492a04523cf04938b26}{Icmpv6Header::ICMPV6\_OPT\_LINK\_LAYER\_TARGET})
770     \{
771       hasLla = \textcolor{keyword}{true};
772       p->RemoveHeader (llOptionHeader);
773     \}
774 
775   Icmpv6OptionRedirected redirectedOptionHeader;
776   p->RemoveHeader (redirectedOptionHeader);
777 
778   Ipv6Address redirTarget = redirectionHeader.GetTarget ();
779   Ipv6Address redirDestination = redirectionHeader.GetDestination ();
780 
781   \textcolor{keywordflow}{if} (hasLla)
782     \{
783       \textcolor{comment}{/* update the cache if needed */}
784       NdiscCache::Entry* entry = 0;
785       Ptr<NdiscCache> cache = \hyperlink{classns3_1_1Icmpv6L4Protocol_a90167126423f3957718e22a8bcd325c8}{FindCache} (interface->GetDevice ());
786 
787       entry = cache->Lookup (redirTarget);
788       \textcolor{keywordflow}{if} (!entry)
789         \{
790           entry = cache->Add (redirTarget);
791           \textcolor{comment}{/* destination and target different => necessarily a router */}
792           entry->SetRouter (!redirTarget.IsEqual (redirDestination) ? \textcolor{keyword}{true} : \textcolor{keyword}{false});
793           entry->SetMacAddress (llOptionHeader.GetAddress ());
794           entry->MarkStale ();
795         \}
796       \textcolor{keywordflow}{else}
797         \{
798           \textcolor{keywordflow}{if} (entry->IsIncomplete () || entry->GetMacAddress () != llOptionHeader.GetAddress ())
799             \{
800               \textcolor{comment}{/* update entry to STALE */}
801               \textcolor{keywordflow}{if} (entry->GetMacAddress () != llOptionHeader.GetAddress ())
802                 \{
803                   entry->SetMacAddress (llOptionHeader.GetAddress ());
804                   entry->MarkStale ();
805                 \}
806             \}
807           \textcolor{keywordflow}{else}
808             \{
809               \textcolor{comment}{/* stay unchanged */}
810             \}
811         \}
812     \}
813 
814   \textcolor{comment}{/* add redirection in routing table */}
815   Ptr<Ipv6> ipv6 = \hyperlink{classns3_1_1Icmpv6L4Protocol_a8968d1631f94f0b1cc1fd0e71ea0d0fe}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv6> ();
816 
817   \textcolor{keywordflow}{if} (redirTarget.IsEqual (redirDestination))
818     \{
819       ipv6->GetRoutingProtocol ()->NotifyAddRoute (redirDestination, Ipv6Prefix (128), Ipv6Address (\textcolor{stringliteral}{"::"}), 
      ipv6->GetInterfaceForAddress (dst));
820     \}
821   \textcolor{keywordflow}{else}
822     \{
823       uint32\_t ifIndex = ipv6->GetInterfaceForAddress (dst);
824       ipv6->GetRoutingProtocol ()->NotifyAddRoute (redirDestination, Ipv6Prefix (128), redirTarget, ifIndex
      );
825     \}
826 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 36




Here is the caller graph for this function\+:
% FIG 37


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Handle\+RS@{Handle\+RS}}
\index{Handle\+RS@{Handle\+RS}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Handle\+R\+S(\+Ptr$<$ Packet $>$ p, Ipv6\+Address const \&src, Ipv6\+Address const \&dst, Ptr$<$ Ipv6\+Interface $>$ interface)}{HandleRS(Ptr< Packet > p, Ipv6Address const &src, Ipv6Address const &dst, Ptr< Ipv6Interface > interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Handle\+RS (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{{\bf Ipv6\+Address} const \&}]{src, }
\item[{{\bf Ipv6\+Address} const \&}]{dst, }
\item[{{\bf Ptr}$<$ {\bf Ipv6\+Interface} $>$}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_a5ad8cee1b6e1884f9c833fc09ff4f4e8}{}\label{classns3_1_1Icmpv6L4Protocol_a5ad8cee1b6e1884f9c833fc09ff4f4e8}


Receive Router Solicitation method. 


\begin{DoxyParams}{Parameters}
{\em p} & the packet \\
\hline
{\em src} & source address \\
\hline
{\em dst} & destination address \\
\hline
{\em interface} & the interface from which the packet is coming \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
441 \{
442   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << src << dst << interface);
443   Ptr<Ipv6L3Protocol> ipv6 = \hyperlink{classns3_1_1Icmpv6L4Protocol_a8968d1631f94f0b1cc1fd0e71ea0d0fe}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv6L3Protocol> ();
444   Icmpv6RS rsHeader;
445   packet->RemoveHeader (rsHeader);
446   Address hardwareAddress;
447   Icmpv6OptionLinkLayerAddress lla (1);
448   NdiscCache::Entry* entry = 0;
449   Ptr<NdiscCache> cache = \hyperlink{classns3_1_1Icmpv6L4Protocol_a90167126423f3957718e22a8bcd325c8}{FindCache} (interface->GetDevice ());
450 
451   \textcolor{keywordflow}{if} (src != \hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} ())
452     \{
453       \textcolor{comment}{/* XXX search all options following the RS header */}
454       \textcolor{comment}{/* test if the next option is SourceLinkLayerAddress */}
455       uint8\_t \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type};
456       packet->CopyData (&type, \textcolor{keyword}{sizeof}(type));
457 
458       \textcolor{keywordflow}{if} (type != \hyperlink{classns3_1_1Icmpv6Header_a1992e0e28c453f5e23b1ad55a49b7908a07035de174ae9be5f6818c46eb299c48}{Icmpv6Header::ICMPV6\_OPT\_LINK\_LAYER\_SOURCE})
459         \{
460           \textcolor{keywordflow}{return};
461         \}
462       packet->RemoveHeader (lla);
463       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Cache updated by RS"});
464 
465       entry = cache->Lookup (src);
466       \textcolor{keywordflow}{if} (!entry)
467         \{
468           entry = cache->Add (src);
469           entry->SetRouter (\textcolor{keyword}{false});
470           entry->MarkStale (lla.GetAddress ());
471         \}
472       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (entry->GetMacAddress () != lla.GetAddress ())
473         \{
474           entry->MarkStale (lla.GetAddress ());
475         \}
476     \}
477 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 38




Here is the caller graph for this function\+:
% FIG 39


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Handle\+Time\+Exceeded@{Handle\+Time\+Exceeded}}
\index{Handle\+Time\+Exceeded@{Handle\+Time\+Exceeded}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Handle\+Time\+Exceeded(\+Ptr$<$ Packet $>$ p, Ipv6\+Address const \&src, Ipv6\+Address const \&dst, Ptr$<$ Ipv6\+Interface $>$ interface)}{HandleTimeExceeded(Ptr< Packet > p, Ipv6Address const &src, Ipv6Address const &dst, Ptr< Ipv6Interface > interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Handle\+Time\+Exceeded (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{{\bf Ipv6\+Address} const \&}]{src, }
\item[{{\bf Ipv6\+Address} const \&}]{dst, }
\item[{{\bf Ptr}$<$ {\bf Ipv6\+Interface} $>$}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_ab83a1f9bbf51d2df18d893bb8b2f37ab}{}\label{classns3_1_1Icmpv6L4Protocol_ab83a1f9bbf51d2df18d893bb8b2f37ab}


Receive \hyperlink{classns3_1_1Time}{Time} Exceeded method. 


\begin{DoxyParams}{Parameters}
{\em p} & the packet \\
\hline
{\em src} & source address \\
\hline
{\em dst} & destination address \\
\hline
{\em interface} & the interface from which the packet is coming \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
848 \{
849   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << *p << src << dst << interface);
850   Ptr<Packet> pkt = p->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} ();
851 
852   Icmpv6TimeExceeded timeexceeded;
853   pkt->\hyperlink{classns3_1_1Packet_a0961eccf975d75f902d40956c93ba63e}{RemoveHeader} (timeexceeded);
854   Ptr<Packet> origPkt = timeexceeded.GetPacket ();
855   Ipv6Header ipHeader;
856   uint8\_t payload[8];
857   origPkt->RemoveHeader (ipHeader);
858   origPkt->CopyData (payload, 8);
859 
860   \hyperlink{classns3_1_1Icmpv6L4Protocol_a0564a55a65b9c577ecf1de0e6893ebc9}{Forward} (src, timeexceeded, timeexceeded.GetCode (), ipHeader, payload);
861 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 40




Here is the caller graph for this function\+:
% FIG 41


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Is\+Always\+Dad@{Is\+Always\+Dad}}
\index{Is\+Always\+Dad@{Is\+Always\+Dad}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Is\+Always\+Dad() const }{IsAlwaysDad() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Is\+Always\+Dad (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Icmpv6L4Protocol_a4accbc330d1a40eca87f03a519d4b1e2}{}\label{classns3_1_1Icmpv6L4Protocol_a4accbc330d1a40eca87f03a519d4b1e2}


Is the node must do D\+AD. 

\begin{DoxyReturn}{Returns}
true if node has to do D\+AD. 
\end{DoxyReturn}

\begin{DoxyCode}
183 \{
184   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
185   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Icmpv6L4Protocol_aa21acf24e3acd05c073c0b15d94b6759}{m\_alwaysDad};
186 \}
\end{DoxyCode}
\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Lookup@{Lookup}}
\index{Lookup@{Lookup}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Lookup(\+Ipv6\+Address dst, Ptr$<$ Net\+Device $>$ device, Ptr$<$ Ndisc\+Cache $>$ cache, Address $\ast$hardware\+Destination)}{Lookup(Ipv6Address dst, Ptr< NetDevice > device, Ptr< NdiscCache > cache, Address *hardwareDestination)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Lookup (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{dst, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{device, }
\item[{{\bf Ptr}$<$ {\bf Ndisc\+Cache} $>$}]{cache, }
\item[{{\bf Address} $\ast$}]{hardware\+Destination}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Icmpv6L4Protocol_abfb3e1df3fc0d57d3076aa00edba62cd}{}\label{classns3_1_1Icmpv6L4Protocol_abfb3e1df3fc0d57d3076aa00edba62cd}


Lookup in the ND cache for the I\+Pv6 address. 

\begin{DoxyNote}{Note}
Unlike other Lookup method, it does not send NS request!
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em dst} & destination address \\
\hline
{\em device} & device \\
\hline
{\em cache} & the neighbor cache \\
\hline
{\em hardware\+Destination} & hardware address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the address is in the ND cache, the hardware\+Destination is updated. 
\end{DoxyReturn}

\begin{DoxyCode}
1298 \{
1299   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << dst << device << cache << hardwareDestination);
1300 
1301   \textcolor{keywordflow}{if} (!cache)
1302     \{
1303       \textcolor{comment}{/* try to find the cache */}
1304       cache = \hyperlink{classns3_1_1Icmpv6L4Protocol_a90167126423f3957718e22a8bcd325c8}{FindCache} (device);
1305     \}
1306   \textcolor{keywordflow}{if} (cache)
1307     \{
1308       NdiscCache::Entry* entry = cache->Lookup (dst);
1309       \textcolor{keywordflow}{if} (entry)
1310         \{
1311           \textcolor{keywordflow}{if} (entry->IsReachable () || entry->IsDelay () || entry->IsPermanent ())
1312             \{
1313               *hardwareDestination = entry->GetMacAddress ();
1314               \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1315             \}
1316           \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (entry->IsStale ())
1317             \{
1318               entry->StartDelayTimer ();
1319               entry->MarkDelay ();
1320               *hardwareDestination = entry->GetMacAddress ();
1321               \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1322             \}
1323         \}
1324     \}
1325   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1326 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 42


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Lookup@{Lookup}}
\index{Lookup@{Lookup}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Lookup(\+Ptr$<$ Packet $>$ p, const Ipv6\+Header \&ip\+Header, Ipv6\+Address dst, Ptr$<$ Net\+Device $>$ device, Ptr$<$ Ndisc\+Cache $>$ cache, Address $\ast$hardware\+Destination)}{Lookup(Ptr< Packet > p, const Ipv6Header &ipHeader, Ipv6Address dst, Ptr< NetDevice > device, Ptr< NdiscCache > cache, Address *hardwareDestination)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Lookup (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv6\+Header} \&}]{ip\+Header, }
\item[{{\bf Ipv6\+Address}}]{dst, }
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{device, }
\item[{{\bf Ptr}$<$ {\bf Ndisc\+Cache} $>$}]{cache, }
\item[{{\bf Address} $\ast$}]{hardware\+Destination}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Icmpv6L4Protocol_aa4d97bb59a89c2d5b41c76ebe9a54f14}{}\label{classns3_1_1Icmpv6L4Protocol_aa4d97bb59a89c2d5b41c76ebe9a54f14}


Lookup in the ND cache for the I\+Pv6 address (similar as A\+RP protocol). 

It also send NS request to target and store the waiting packet. 
\begin{DoxyParams}{Parameters}
{\em p} & the packet \\
\hline
{\em ip\+Header} & I\+Pv6 header \\
\hline
{\em dst} & destination address \\
\hline
{\em device} & device \\
\hline
{\em cache} & the neighbor cache \\
\hline
{\em hardware\+Destination} & hardware address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the address is in the ND cache, the hardware\+Destination is updated. 
\end{DoxyReturn}

\begin{DoxyCode}
1329 \{
1330   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << p << ipHeader << dst << device << cache << hardwareDestination);
1331 
1332   \textcolor{keywordflow}{if} (!cache)
1333     \{
1334       \textcolor{comment}{/* try to find the cache */}
1335       cache = \hyperlink{classns3_1_1Icmpv6L4Protocol_a90167126423f3957718e22a8bcd325c8}{FindCache} (device);
1336     \}
1337   \textcolor{keywordflow}{if} (!cache)
1338     \{
1339       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1340     \}
1341 
1342   NdiscCache::Entry* entry = cache->Lookup (dst);
1343   \textcolor{keywordflow}{if} (entry)
1344     \{
1345       \textcolor{keywordflow}{if} (entry->IsReachable () || entry->IsDelay () || entry->IsPermanent ())
1346         \{
1347           \textcolor{comment}{/* XXX check reachability time */}
1348           \textcolor{comment}{/* send packet */}
1349           *hardwareDestination = entry->GetMacAddress ();
1350           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1351         \}
1352       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (entry->IsStale ())
1353         \{
1354           \textcolor{comment}{/* start delay timer */}
1355           entry->StartDelayTimer ();
1356           entry->MarkDelay ();
1357           *hardwareDestination = entry->GetMacAddress ();
1358           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1359         \}
1360       \textcolor{keywordflow}{else} \textcolor{comment}{/* INCOMPLETE or PROBE */}
1361         \{
1362           \textcolor{comment}{/* queue packet */}
1363           entry->AddWaitingPacket (\hyperlink{classns3_1_1NdiscCache_a29c07f4c9da0e923f442f6440666240e}{NdiscCache::Ipv6PayloadHeaderPair} (p, 
      ipHeader));
1364           \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1365         \}
1366     \}
1367   \textcolor{keywordflow}{else}
1368     \{
1369       \textcolor{comment}{/* we contact this node for the first time}
1370 \textcolor{comment}{       * add it to the cache and send an NS}
1371 \textcolor{comment}{       */}
1372       Ipv6Address addr;
1373       NdiscCache::Entry* entry = cache->Add (dst);
1374       entry->MarkIncomplete (\hyperlink{classns3_1_1NdiscCache_a29c07f4c9da0e923f442f6440666240e}{NdiscCache::Ipv6PayloadHeaderPair} (p, 
      ipHeader));
1375       entry->SetRouter (\textcolor{keyword}{false});
1376 
1377       \textcolor{keywordflow}{if} (dst.IsLinkLocal ())
1378         \{
1379           addr = cache->GetInterface ()->GetLinkLocalAddress ().GetAddress ();
1380         \}
1381       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (cache->GetInterface ()->GetNAddresses () == 1) \textcolor{comment}{/* an interface have at least one address
       (link-local) */}
1382         \{
1383           \textcolor{comment}{/* try to resolve global address without having global address so return! */}
1384           cache->Remove (entry);
1385           \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1386         \}
1387       \textcolor{keywordflow}{else}
1388         \{
1389           \textcolor{comment}{/* find source address that match destination */}
1390           addr = cache->GetInterface ()->GetAddressMatchingDestination (dst).GetAddress ();
1391         \}
1392 
1393       \hyperlink{classns3_1_1Icmpv6L4Protocol_aacd8a4ff185f48e74f4c4b8dc0da4398}{SendNS} (addr, \hyperlink{classns3_1_1Ipv6Address_a1f6831d89cb902b8af5c73baaab97832}{Ipv6Address::MakeSolicitedAddress} (dst), dst, 
      cache->GetDevice ()->GetAddress ());
1394 
1395       \textcolor{comment}{/* start retransmit timer */}
1396       entry->StartRetransmitTimer ();
1397       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1398     \}
1399 
1400   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1401 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 43


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Notify\+New\+Aggregate@{Notify\+New\+Aggregate}}
\index{Notify\+New\+Aggregate@{Notify\+New\+Aggregate}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Notify\+New\+Aggregate()}{NotifyNewAggregate()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Notify\+New\+Aggregate (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_a5b150b21ea7d5337ec2021092fcf972b}{}\label{classns3_1_1Icmpv6L4Protocol_a5b150b21ea7d5337ec2021092fcf972b}


This method is called by Add\+Agregate and completes the aggregation by setting the node in the I\+C\+M\+Pv6 stack and adding I\+C\+M\+Pv6 factory to I\+Pv6 stack connected to the node. 



Reimplemented from \hyperlink{classns3_1_1Object_a1bd7211125185a6cd511c35fea4e500f}{ns3\+::\+Object}.


\begin{DoxyCode}
137 \{
138   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
139   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Icmpv6L4Protocol_a8968d1631f94f0b1cc1fd0e71ea0d0fe}{m\_node} == 0)
140     \{
141       Ptr<Node> node = this->GetObject<Node> ();
142       \textcolor{keywordflow}{if} (node != 0)
143         \{
144           Ptr<Ipv6> ipv6 = this->GetObject<Ipv6> ();
145           \textcolor{keywordflow}{if} (ipv6 != 0 && \hyperlink{classns3_1_1Icmpv6L4Protocol_a8cd5beb542044689be316d6e6963bb3a}{m\_downTarget}.\hyperlink{classns3_1_1Callback_aa8e27826badbf37f84763f36f70d9b54}{IsNull} ())
146             \{
147               \hyperlink{classns3_1_1Icmpv6L4Protocol_af6108107ea3ca1dee9495671183bd31f}{SetNode} (node);
148               ipv6->Insert (\textcolor{keyword}{this});
149               Ptr<Ipv6RawSocketFactoryImpl> rawFactory = CreateObject<Ipv6RawSocketFactoryImpl> ();
150               ipv6->AggregateObject (rawFactory);
151               \hyperlink{classns3_1_1Icmpv6L4Protocol_aa0f5416435059e873d216ffc07928f23}{SetDownTarget6} (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1Ipv6_a2aad308983b20eb54334bb0d3db31004}{Ipv6::Send}, ipv6));
152             \}
153         \}
154     \}
155   \hyperlink{classns3_1_1Object_a1bd7211125185a6cd511c35fea4e500f}{IpL4Protocol::NotifyNewAggregate} ();
156 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 44


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Receive@{Receive}}
\index{Receive@{Receive}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Receive(\+Ptr$<$ Packet $>$ p, Ipv6\+Header const \&header, Ptr$<$ Ipv6\+Interface $>$ interface)}{Receive(Ptr< Packet > p, Ipv6Header const &header, Ptr< Ipv6Interface > interface)}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Ip\+L4\+Protocol\+::\+Rx\+Status} ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Receive (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{{\bf Ipv6\+Header} const \&}]{header, }
\item[{{\bf Ptr}$<$ {\bf Ipv6\+Interface} $>$}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_a31342a8123eab651a5cabd1a197b0145}{}\label{classns3_1_1Icmpv6L4Protocol_a31342a8123eab651a5cabd1a197b0145}


Receive method. 


\begin{DoxyParams}{Parameters}
{\em p} & the packet \\
\hline
{\em header} & the I\+Pv6 header \\
\hline
{\em interface} & the interface from which the packet is coming \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the receive status 
\end{DoxyReturn}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000039}{Todo}]implement request / reply consistency check. \end{DoxyRefDesc}


Implements \hyperlink{classns3_1_1IpL4Protocol_a1722da521b414c28875cb2a4f4aaf242}{ns3\+::\+Ip\+L4\+Protocol}.


\begin{DoxyCode}
217 \{
218   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << header.GetSourceAddress () << header.
      GetDestinationAddress () << interface);
219   Ptr<Packet> p = packet->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} ();
220   Ptr<Ipv6> ipv6 = \hyperlink{classns3_1_1Icmpv6L4Protocol_a8968d1631f94f0b1cc1fd0e71ea0d0fe}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv6> ();
221 
222   \textcolor{comment}{/* very ugly! try to find something better in the future */}
223   uint8\_t \hyperlink{visualizer-ideas_8txt_add98db9e15e2a58cf2b57623e7aa893a}{type};
224   p->CopyData (&type, \textcolor{keyword}{sizeof}(type));
225 
226   \textcolor{keywordflow}{switch} (type)
227     \{
228     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1Icmpv6Header_ad13fcbee075bf00f66ffbc57dfbecb70a8620b40d78b2bf3cc1fe4b3a555de671}{Icmpv6Header::ICMPV6\_ND\_ROUTER\_SOLICITATION}:
229       \textcolor{keywordflow}{if} (ipv6->IsForwarding (ipv6->GetInterfaceForDevice (interface->GetDevice ())))
230         \{
231           \hyperlink{classns3_1_1Icmpv6L4Protocol_a5ad8cee1b6e1884f9c833fc09ff4f4e8}{HandleRS} (p, header.GetSourceAddress (), header.GetDestinationAddress (), interface);
232         \}
233       \textcolor{keywordflow}{break};
234     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1Icmpv6Header_ad13fcbee075bf00f66ffbc57dfbecb70a3b4761cf875ed921c977c877f804dbf4}{Icmpv6Header::ICMPV6\_ND\_ROUTER\_ADVERTISEMENT}:
235       \textcolor{keywordflow}{if} (!ipv6->IsForwarding (ipv6->GetInterfaceForDevice (interface->GetDevice ())))
236         \{
237           \hyperlink{classns3_1_1Icmpv6L4Protocol_af1a56b5658c12d34615aa712758359d5}{HandleRA} (p, header.GetSourceAddress (), header.GetDestinationAddress (), interface);
238         \}
239       \textcolor{keywordflow}{break};
240     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1Icmpv6Header_ad13fcbee075bf00f66ffbc57dfbecb70ad34550bf091d453d25f2f9e2df2594e0}{Icmpv6Header::ICMPV6\_ND\_NEIGHBOR\_SOLICITATION}:
241       \hyperlink{classns3_1_1Icmpv6L4Protocol_acec910926a1fdbbea699c10d638aa704}{HandleNS} (p, header.GetSourceAddress (), header.GetDestinationAddress (), interface);
242       \textcolor{keywordflow}{break};
243     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1Icmpv6Header_ad13fcbee075bf00f66ffbc57dfbecb70a702ff072042857f6e5d2b118aad703b2}{Icmpv6Header::ICMPV6\_ND\_NEIGHBOR\_ADVERTISEMENT}:
244       \hyperlink{classns3_1_1Icmpv6L4Protocol_a6c3a2ecce98fa29743eb177b613490e5}{HandleNA} (p, header.GetSourceAddress (), header.GetDestinationAddress (), interface);
245       \textcolor{keywordflow}{break};
246     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1Icmpv6Header_ad13fcbee075bf00f66ffbc57dfbecb70aeb20b493d906ead8f08096e0d9c120e8}{Icmpv6Header::ICMPV6\_ND\_REDIRECTION}:
247       \hyperlink{classns3_1_1Icmpv6L4Protocol_ac23066adbd141142fd8d6a86fa1cc4ef}{HandleRedirection} (p, header.GetSourceAddress (), header.GetDestinationAddress (), 
      interface);
248       \textcolor{keywordflow}{break};
249     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1Icmpv6Header_ad13fcbee075bf00f66ffbc57dfbecb70aee9d19b2f71a1cb9b076d170cfcd4231}{Icmpv6Header::ICMPV6\_ECHO\_REQUEST}:
250       \hyperlink{classns3_1_1Icmpv6L4Protocol_ac3f01017288992311264ef54c57e539b}{HandleEchoRequest} (p, header.GetSourceAddress (), header.GetDestinationAddress (), 
      interface);
251       \textcolor{keywordflow}{break};
252     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1Icmpv6Header_ad13fcbee075bf00f66ffbc57dfbecb70aa20a65a542b5851b5e711d036f1d0533}{Icmpv6Header::ICMPV6\_ECHO\_REPLY}:
253       \textcolor{comment}{// EchoReply does not contain any info about L4}
254       \textcolor{comment}{// so we can not forward it up.}
256 \textcolor{comment}{}      \textcolor{keywordflow}{break};
257     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1Icmpv6Header_ad13fcbee075bf00f66ffbc57dfbecb70a888f534b20f4895d2c440cd1631eeaed}{Icmpv6Header::ICMPV6\_ERROR\_DESTINATION\_UNREACHABLE}
      :
258       \hyperlink{classns3_1_1Icmpv6L4Protocol_ac7cc1db0945e6dc5be05c82a4aa746be}{HandleDestinationUnreachable} (p, header.GetSourceAddress (), header.
      GetDestinationAddress (), interface);
259       \textcolor{keywordflow}{break};
260     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1Icmpv6Header_ad13fcbee075bf00f66ffbc57dfbecb70ab681c1f821b9ac4ec7719dd3f6b72050}{Icmpv6Header::ICMPV6\_ERROR\_PACKET\_TOO\_BIG}:
261       \hyperlink{classns3_1_1Icmpv6L4Protocol_a5508e43a5549288270fc050b8b072f51}{HandlePacketTooBig} (p, header.GetSourceAddress (), header.GetDestinationAddress (),
       interface);
262       \textcolor{keywordflow}{break};
263     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1Icmpv6Header_ad13fcbee075bf00f66ffbc57dfbecb70a25b87a102ea5fadefe07c5981cbf3446}{Icmpv6Header::ICMPV6\_ERROR\_TIME\_EXCEEDED}:
264       \hyperlink{classns3_1_1Icmpv6L4Protocol_ab83a1f9bbf51d2df18d893bb8b2f37ab}{HandleTimeExceeded} (p, header.GetSourceAddress (), header.GetDestinationAddress (),
       interface);
265       \textcolor{keywordflow}{break};
266     \textcolor{keywordflow}{case} \hyperlink{classns3_1_1Icmpv6Header_ad13fcbee075bf00f66ffbc57dfbecb70a021325d1f6f21b068d6d48d06c837906}{Icmpv6Header::ICMPV6\_ERROR\_PARAMETER\_ERROR}:
267       \hyperlink{classns3_1_1Icmpv6L4Protocol_ae1ec3272a15fdf3bde7037b86191a365}{HandleParameterError} (p, header.GetSourceAddress (), header.GetDestinationAddress
       (), interface);
268       \textcolor{keywordflow}{break};
269     \textcolor{keywordflow}{default}:
270       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Unknown ICMPv6 message type="} << type);
271       \textcolor{keywordflow}{break};
272     \}
273 
274   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80eabd979bce2f3b22521c81c4115c66317e}{IpL4Protocol::RX\_OK};
275 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 45


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Receive@{Receive}}
\index{Receive@{Receive}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Receive(\+Ptr$<$ Packet $>$ p, Ipv4\+Header const \&header, Ptr$<$ Ipv4\+Interface $>$ interface)}{Receive(Ptr< Packet > p, Ipv4Header const &header, Ptr< Ipv4Interface > interface)}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Ip\+L4\+Protocol\+::\+Rx\+Status} ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Receive (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{{\bf Ipv4\+Header} const \&}]{header, }
\item[{{\bf Ptr}$<$ {\bf Ipv4\+Interface} $>$}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_aedf7165666f27e8907a56247f2da9a88}{}\label{classns3_1_1Icmpv6L4Protocol_aedf7165666f27e8907a56247f2da9a88}


Receive method. 


\begin{DoxyParams}{Parameters}
{\em p} & the packet \\
\hline
{\em header} & the I\+Pv4 header \\
\hline
{\em interface} & the interface from which the packet is coming \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the receive status 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1IpL4Protocol_ad184969a1d9fd630f09e61d15ccad19d}{ns3\+::\+Ip\+L4\+Protocol}.


\begin{DoxyCode}
211 \{
212   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << header);
213   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80ea00e3d2a534b8bd353395254c0735948b}{IpL4Protocol::RX\_ENDPOINT\_UNREACH};
214 \}
\end{DoxyCode}
\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Receive\+L\+LA@{Receive\+L\+LA}}
\index{Receive\+L\+LA@{Receive\+L\+LA}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Receive\+L\+L\+A(\+Icmpv6\+Option\+Link\+Layer\+Address lla, Ipv6\+Address const \&src, Ipv6\+Address const \&dst, Ptr$<$ Ipv6\+Interface $>$ interface)}{ReceiveLLA(Icmpv6OptionLinkLayerAddress lla, Ipv6Address const &src, Ipv6Address const &dst, Ptr< Ipv6Interface > interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Receive\+L\+LA (
\begin{DoxyParamCaption}
\item[{{\bf Icmpv6\+Option\+Link\+Layer\+Address}}]{lla, }
\item[{{\bf Ipv6\+Address} const \&}]{src, }
\item[{{\bf Ipv6\+Address} const \&}]{dst, }
\item[{{\bf Ptr}$<$ {\bf Ipv6\+Interface} $>$}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_ad6670739eba9c44ba37bf9644bfcdde5}{}\label{classns3_1_1Icmpv6L4Protocol_ad6670739eba9c44ba37bf9644bfcdde5}


Link layer address option processing. 


\begin{DoxyParams}{Parameters}
{\em lla} & L\+LA option \\
\hline
{\em src} & source address \\
\hline
{\em dst} & destination address \\
\hline
{\em interface} & the interface from which the packet is coming \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
376 \{
377   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << lla << src << dst << interface);
378   Address hardwareAddress;
379   NdiscCache::Entry* entry = 0;
380   Ptr<NdiscCache> cache = \hyperlink{classns3_1_1Icmpv6L4Protocol_a90167126423f3957718e22a8bcd325c8}{FindCache} (interface->GetDevice ());
381 
382   \textcolor{comment}{/* check if we have this address in our cache */}
383   entry = cache->Lookup (src);
384 
385   \textcolor{keywordflow}{if} (!entry)
386     \{
387       entry = cache->Add (src);
388       entry->SetRouter (\textcolor{keyword}{true});
389       entry->SetMacAddress (lla.GetAddress ());
390       entry->MarkReachable ();
391       entry->StartReachableTimer ();
392     \}
393   \textcolor{keywordflow}{else}
394     \{
395       std::list<NdiscCache::Ipv6PayloadHeaderPair> waiting;
396       \textcolor{keywordflow}{if} (entry->IsIncomplete ())
397         \{
398           entry->StopNudTimer ();
399           \textcolor{comment}{// mark it to reachable}
400           waiting = entry->MarkReachable (lla.GetAddress ());
401           entry->StartReachableTimer ();
402           \textcolor{comment}{// send out waiting packet}
403           \textcolor{keywordflow}{for} (std::list<NdiscCache::Ipv6PayloadHeaderPair>::const\_iterator it = waiting.begin (); it != 
      waiting.end (); it++)
404             \{
405               cache->GetInterface ()->Send (it->first, it->second, src);
406             \}
407           entry->ClearWaitingPacket ();
408         \}
409       \textcolor{keywordflow}{else}
410         \{
411           \textcolor{keywordflow}{if} (entry->GetMacAddress () != lla.GetAddress ())
412             \{
413               entry->SetMacAddress (lla.GetAddress ());
414               entry->MarkStale ();
415               entry->SetRouter (\textcolor{keyword}{true});
416             \}
417           \textcolor{keywordflow}{else}
418             \{
419               \textcolor{keywordflow}{if} (!entry->IsReachable () || !entry->IsPermanent ())
420                 \{
421                   entry->StopNudTimer ();
422                   waiting = entry->MarkReachable (lla.GetAddress ());
423                   \textcolor{keywordflow}{if} (entry->IsProbe ())
424                     \{
425                       \textcolor{keywordflow}{for} (std::list<NdiscCache::Ipv6PayloadHeaderPair>::const\_iterator it = waiting.begin 
      (); it != waiting.end (); it++)
426                         \{
427                           cache->GetInterface ()->Send (it->first, it->second, src);
428                         \}
429                     \}
430                   \textcolor{keywordflow}{if} (!entry->IsPermanent ())
431                     \{
432                       entry->StartReachableTimer ();
433                     \}
434                 \}
435             \}
436         \}
437     \}
438 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 46




Here is the caller graph for this function\+:
% FIG 47


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Send\+Echo\+Reply@{Send\+Echo\+Reply}}
\index{Send\+Echo\+Reply@{Send\+Echo\+Reply}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Echo\+Reply(\+Ipv6\+Address src, Ipv6\+Address dst, uint16\+\_\+t id, uint16\+\_\+t seq, Ptr$<$ Packet $>$ data)}{SendEchoReply(Ipv6Address src, Ipv6Address dst, uint16_t id, uint16_t seq, Ptr< Packet > data)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Send\+Echo\+Reply (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{src, }
\item[{{\bf Ipv6\+Address}}]{dst, }
\item[{uint16\+\_\+t}]{id, }
\item[{uint16\+\_\+t}]{seq, }
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{data}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Icmpv6L4Protocol_ad7408b6e4b818a857783a4ec373f2a66}{}\label{classns3_1_1Icmpv6L4Protocol_ad7408b6e4b818a857783a4ec373f2a66}


Send a Echo Reply. 


\begin{DoxyParams}{Parameters}
{\em src} & source I\+Pv6 address \\
\hline
{\em dst} & destination I\+Pv6 address \\
\hline
{\em id} & id of the packet \\
\hline
{\em seq} & sequence number \\
\hline
{\em data} & auxiliary data \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
979 \{
980   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << src << dst << \textcolor{keywordtype}{id} << seq << data);
981   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = data->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} ();
982   Icmpv6Echo reply (0); \textcolor{comment}{/* echo reply */}
983 
984   reply.SetId (\textcolor{keywordtype}{id});
985   reply.SetSeq (seq);
986 
987   reply.CalculatePseudoHeaderChecksum (src, dst, p->GetSize () + reply.GetSerializedSize (), 
      \hyperlink{classns3_1_1Icmpv6L4Protocol_aa56c41a886a45b8b4f22a19afc827e2d}{PROT\_NUMBER});
988   p->AddHeader (reply);
989   \hyperlink{classns3_1_1Icmpv6L4Protocol_aca22b3999b518531f807d822060a06a8}{SendMessage} (p, src, dst, 64);
990 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 48




Here is the caller graph for this function\+:
% FIG 49


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Send\+Error\+Destination\+Unreachable@{Send\+Error\+Destination\+Unreachable}}
\index{Send\+Error\+Destination\+Unreachable@{Send\+Error\+Destination\+Unreachable}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Error\+Destination\+Unreachable(\+Ptr$<$ Packet $>$ malformed\+Packet, Ipv6\+Address dst, uint8\+\_\+t code)}{SendErrorDestinationUnreachable(Ptr< Packet > malformedPacket, Ipv6Address dst, uint8_t code)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Send\+Error\+Destination\+Unreachable (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{malformed\+Packet, }
\item[{{\bf Ipv6\+Address}}]{dst, }
\item[{uint8\+\_\+t}]{code}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Icmpv6L4Protocol_aa54ff6a5f2486f62dc15aa657dd947a0}{}\label{classns3_1_1Icmpv6L4Protocol_aa54ff6a5f2486f62dc15aa657dd947a0}


Send an error Destination Unreachable. 


\begin{DoxyParams}{Parameters}
{\em malformed\+Packet} & the malformed packet \\
\hline
{\em dst} & destination I\+Pv6 address \\
\hline
{\em code} & code of the error \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1051 \{
1052   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << malformedPacket << dst << (uint32\_t)code);
1053   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = Create<Packet> ();
1054   uint32\_t malformedPacketSize = malformedPacket->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ();
1055   Icmpv6DestinationUnreachable header;
1056 
1057   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Send Destination Unreachable ( to "} << dst << \textcolor{stringliteral}{" code "} << (uint32\_t)code << \textcolor{stringliteral}{"
       )"});
1058 
1059   \textcolor{comment}{/* 48 = sizeof IPv6 header + sizeof ICMPv6 error header */}
1060   \textcolor{keywordflow}{if} (malformedPacketSize <= 1280 - 48)
1061     \{
1062       header.SetPacket (malformedPacket);
1063     \}
1064   \textcolor{keywordflow}{else}
1065     \{
1066       Ptr<Packet> fragment = malformedPacket->\hyperlink{classns3_1_1Packet_a16f6113606b355b2b346e2245fa2a3d0}{CreateFragment} (0, 1280 - 48);
1067       header.SetPacket (fragment);
1068     \}
1069 
1070   header.SetCode (code);
1071   \hyperlink{classns3_1_1Icmpv6L4Protocol_aca22b3999b518531f807d822060a06a8}{SendMessage} (p, dst, header, 255);
1072 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 50


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Send\+Error\+Parameter\+Error@{Send\+Error\+Parameter\+Error}}
\index{Send\+Error\+Parameter\+Error@{Send\+Error\+Parameter\+Error}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Error\+Parameter\+Error(\+Ptr$<$ Packet $>$ malformed\+Packet, Ipv6\+Address dst, uint8\+\_\+t code, uint32\+\_\+t ptr)}{SendErrorParameterError(Ptr< Packet > malformedPacket, Ipv6Address dst, uint8_t code, uint32_t ptr)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Send\+Error\+Parameter\+Error (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{malformed\+Packet, }
\item[{{\bf Ipv6\+Address}}]{dst, }
\item[{uint8\+\_\+t}]{code, }
\item[{uint32\+\_\+t}]{ptr}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Icmpv6L4Protocol_a5ab4894cdec7b35c4c43f0ee82d61aa6}{}\label{classns3_1_1Icmpv6L4Protocol_a5ab4894cdec7b35c4c43f0ee82d61aa6}


Send an error Parameter Error. 


\begin{DoxyParams}{Parameters}
{\em malformed\+Packet} & the malformed packet \\
\hline
{\em dst} & destination I\+Pv6 address \\
\hline
{\em code} & code of the error \\
\hline
{\em ptr} & byte of p where the error is located \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1124 \{
1125   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << malformedPacket << dst << static\_cast<uint32\_t> (code) << ptr);
1126   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = Create<Packet> ();
1127   uint32\_t malformedPacketSize = malformedPacket->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ();
1128   Icmpv6ParameterError header;
1129 
1130   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Send Parameter Error ( to "} << dst << \textcolor{stringliteral}{" code "} << (uint32\_t)code << \textcolor{stringliteral}{" )"});
1131 
1132   \textcolor{comment}{/* 48 = sizeof IPv6 header + sizeof ICMPv6 error header */}
1133   \textcolor{keywordflow}{if} (malformedPacketSize <= 1280 - 48 )
1134     \{
1135       header.SetPacket (malformedPacket);
1136     \}
1137   \textcolor{keywordflow}{else}
1138     \{
1139       Ptr<Packet> fragment = malformedPacket->\hyperlink{classns3_1_1Packet_a16f6113606b355b2b346e2245fa2a3d0}{CreateFragment} (0, 1280 - 48);
1140       header.SetPacket (fragment);
1141     \}
1142 
1143   header.SetCode (code);
1144   header.SetPtr (ptr);
1145   \hyperlink{classns3_1_1Icmpv6L4Protocol_aca22b3999b518531f807d822060a06a8}{SendMessage} (p, dst, header, 255);
1146 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 51


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Send\+Error\+Time\+Exceeded@{Send\+Error\+Time\+Exceeded}}
\index{Send\+Error\+Time\+Exceeded@{Send\+Error\+Time\+Exceeded}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Error\+Time\+Exceeded(\+Ptr$<$ Packet $>$ malformed\+Packet, Ipv6\+Address dst, uint8\+\_\+t code)}{SendErrorTimeExceeded(Ptr< Packet > malformedPacket, Ipv6Address dst, uint8_t code)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Send\+Error\+Time\+Exceeded (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{malformed\+Packet, }
\item[{{\bf Ipv6\+Address}}]{dst, }
\item[{uint8\+\_\+t}]{code}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Icmpv6L4Protocol_a0912f3bc9bfb032dafe0c295e2dcb047}{}\label{classns3_1_1Icmpv6L4Protocol_a0912f3bc9bfb032dafe0c295e2dcb047}


Send an error \hyperlink{classns3_1_1Time}{Time} Exceeded. 


\begin{DoxyParams}{Parameters}
{\em malformed\+Packet} & the malformed packet \\
\hline
{\em dst} & destination I\+Pv6 address \\
\hline
{\em code} & code of the error \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1100 \{
1101   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << malformedPacket << dst << static\_cast<uint32\_t> (code));
1102   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = Create<Packet> ();
1103   uint32\_t malformedPacketSize = malformedPacket->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ();
1104   Icmpv6TimeExceeded header;
1105 
1106   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Send Time Exceeded ( to "} << dst << \textcolor{stringliteral}{" code "} << (uint32\_t)code << \textcolor{stringliteral}{" )"});
1107 
1108   \textcolor{comment}{/* 48 = sizeof IPv6 header + sizeof ICMPv6 error header */}
1109   \textcolor{keywordflow}{if} (malformedPacketSize <= 1280 - 48)
1110     \{
1111       header.SetPacket (malformedPacket);
1112     \}
1113   \textcolor{keywordflow}{else}
1114     \{
1115       Ptr<Packet> fragment = malformedPacket->\hyperlink{classns3_1_1Packet_a16f6113606b355b2b346e2245fa2a3d0}{CreateFragment} (0, 1280 - 48);
1116       header.SetPacket (fragment);
1117     \}
1118 
1119   header.SetCode (code);
1120   \hyperlink{classns3_1_1Icmpv6L4Protocol_aca22b3999b518531f807d822060a06a8}{SendMessage} (p, dst, header, 255);
1121 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 52


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Send\+Error\+Too\+Big@{Send\+Error\+Too\+Big}}
\index{Send\+Error\+Too\+Big@{Send\+Error\+Too\+Big}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Error\+Too\+Big(\+Ptr$<$ Packet $>$ malformed\+Packet, Ipv6\+Address dst, uint32\+\_\+t mtu)}{SendErrorTooBig(Ptr< Packet > malformedPacket, Ipv6Address dst, uint32_t mtu)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Send\+Error\+Too\+Big (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{malformed\+Packet, }
\item[{{\bf Ipv6\+Address}}]{dst, }
\item[{uint32\+\_\+t}]{mtu}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Icmpv6L4Protocol_a103bf3fdf3212b7fdd351d89adac59d7}{}\label{classns3_1_1Icmpv6L4Protocol_a103bf3fdf3212b7fdd351d89adac59d7}


Send an error Too Big. 


\begin{DoxyParams}{Parameters}
{\em malformed\+Packet} & the malformed packet \\
\hline
{\em dst} & destination I\+Pv6 address \\
\hline
{\em mtu} & the mtu \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1075 \{
1076   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << malformedPacket << dst << mtu);
1077   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = Create<Packet> ();
1078   uint32\_t malformedPacketSize = malformedPacket->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ();
1079   Icmpv6TooBig header;
1080 
1081   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Send Too Big ( to "} << dst << \textcolor{stringliteral}{" )"});
1082 
1083   \textcolor{comment}{/* 48 = sizeof IPv6 header + sizeof ICMPv6 error header */}
1084   \textcolor{keywordflow}{if} (malformedPacketSize <= 1280 - 48)
1085     \{
1086       header.SetPacket (malformedPacket);
1087     \}
1088   \textcolor{keywordflow}{else}
1089     \{
1090       Ptr<Packet> fragment = malformedPacket->\hyperlink{classns3_1_1Packet_a16f6113606b355b2b346e2245fa2a3d0}{CreateFragment} (0, 1280 - 48);
1091       header.SetPacket (fragment);
1092     \}
1093 
1094   header.SetCode (0);
1095   header.SetMtu (mtu);
1096   \hyperlink{classns3_1_1Icmpv6L4Protocol_aca22b3999b518531f807d822060a06a8}{SendMessage} (p, dst, header, 255);
1097 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 53


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Send\+Message@{Send\+Message}}
\index{Send\+Message@{Send\+Message}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Message(\+Ptr$<$ Packet $>$ packet, Ipv6\+Address src, Ipv6\+Address dst, uint8\+\_\+t ttl)}{SendMessage(Ptr< Packet > packet, Ipv6Address src, Ipv6Address dst, uint8_t ttl)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Send\+Message (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Ipv6\+Address}}]{src, }
\item[{{\bf Ipv6\+Address}}]{dst, }
\item[{uint8\+\_\+t}]{ttl}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Icmpv6L4Protocol_aca22b3999b518531f807d822060a06a8}{}\label{classns3_1_1Icmpv6L4Protocol_aca22b3999b518531f807d822060a06a8}


Send a packet via I\+C\+M\+Pv6, note that packet already contains I\+C\+M\+Pv6 header. 


\begin{DoxyParams}{Parameters}
{\em packet} & the packet to send which contains I\+C\+M\+Pv6 header \\
\hline
{\em src} & source address \\
\hline
{\em dst} & destination address \\
\hline
{\em ttl} & next hop limit \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
900 \{
901   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << src << dst << (uint32\_t)ttl);
902   Ptr<Ipv6L3Protocol> ipv6 = \hyperlink{classns3_1_1Icmpv6L4Protocol_a8968d1631f94f0b1cc1fd0e71ea0d0fe}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv6L3Protocol> ();
903   SocketIpTtlTag tag;
904   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (ipv6 != 0);
905 
906   tag.SetTtl (ttl);
907   packet->\hyperlink{classns3_1_1Packet_a7400b8655852f5271c5957250d0141af}{AddPacketTag} (tag);
908   \hyperlink{classns3_1_1Icmpv6L4Protocol_a8cd5beb542044689be316d6e6963bb3a}{m\_downTarget} (packet, src, dst, \hyperlink{classns3_1_1Icmpv6L4Protocol_aa56c41a886a45b8b4f22a19afc827e2d}{PROT\_NUMBER}, 0);
909 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 54




Here is the caller graph for this function\+:
% FIG 55


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Send\+Message@{Send\+Message}}
\index{Send\+Message@{Send\+Message}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Message(\+Ptr$<$ Packet $>$ packet, Ipv6\+Address dst, Icmpv6\+Header \&icmpv6\+Hdr, uint8\+\_\+t ttl)}{SendMessage(Ptr< Packet > packet, Ipv6Address dst, Icmpv6Header &icmpv6Hdr, uint8_t ttl)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Send\+Message (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Ipv6\+Address}}]{dst, }
\item[{{\bf Icmpv6\+Header} \&}]{icmpv6\+Hdr, }
\item[{uint8\+\_\+t}]{ttl}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Icmpv6L4Protocol_a62a9a177dd81ee6d5323e50b0954ed70}{}\label{classns3_1_1Icmpv6L4Protocol_a62a9a177dd81ee6d5323e50b0954ed70}


Send a packet via I\+C\+M\+Pv6. 


\begin{DoxyParams}{Parameters}
{\em packet} & the packet to send \\
\hline
{\em dst} & destination address \\
\hline
{\em icmpv6\+Hdr} & I\+C\+M\+Pv6 header (needed to calculate checksum after source address is determined by routing stuff \\
\hline
{\em ttl} & next hop limit \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
918 \{
919   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << dst << icmpv6Hdr << (uint32\_t)ttl);
920   Ptr<Ipv6L3Protocol> ipv6 = \hyperlink{classns3_1_1Icmpv6L4Protocol_a8968d1631f94f0b1cc1fd0e71ea0d0fe}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv6L3Protocol> ();
921   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (ipv6 != 0 && ipv6->GetRoutingProtocol () != 0);
922   Ipv6Header header;
923   SocketIpTtlTag tag;
924   \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket::SocketErrno} err;
925   Ptr<Ipv6Route> route;
926   Ptr<NetDevice> oif (0); \textcolor{comment}{//specify non-zero if bound to a source address}
927 
928   header.SetDestinationAddress (dst);
929   route = ipv6->GetRoutingProtocol ()->RouteOutput (packet, header, oif, err);
930 
931   \textcolor{keywordflow}{if} (route != 0)
932     \{
933       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Route exists"});
934       tag.SetTtl (ttl);
935       packet->\hyperlink{classns3_1_1Packet_a7400b8655852f5271c5957250d0141af}{AddPacketTag} (tag);
936       Ipv6Address src = route->GetSource ();
937 
938       icmpv6Hdr.CalculatePseudoHeaderChecksum (src, dst, packet->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} () + icmpv6Hdr.
      GetSerializedSize (), \hyperlink{classns3_1_1Icmpv6L4Protocol_aa56c41a886a45b8b4f22a19afc827e2d}{PROT\_NUMBER});
939       packet->\hyperlink{classns3_1_1Packet_a465108c595a0bc592095cbcab1832ed8}{AddHeader} (icmpv6Hdr);
940       \hyperlink{classns3_1_1Icmpv6L4Protocol_a8cd5beb542044689be316d6e6963bb3a}{m\_downTarget} (packet, src, dst, \hyperlink{classns3_1_1Icmpv6L4Protocol_aa56c41a886a45b8b4f22a19afc827e2d}{PROT\_NUMBER}, route);
941     \}
942   \textcolor{keywordflow}{else}
943     \{
944       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"drop icmp message"});
945     \}
946 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 56


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Send\+NA@{Send\+NA}}
\index{Send\+NA@{Send\+NA}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+N\+A(\+Ipv6\+Address src, Ipv6\+Address dst, Address $\ast$hardware\+Address, uint8\+\_\+t flags)}{SendNA(Ipv6Address src, Ipv6Address dst, Address *hardwareAddress, uint8_t flags)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Send\+NA (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{src, }
\item[{{\bf Ipv6\+Address}}]{dst, }
\item[{{\bf Address} $\ast$}]{hardware\+Address, }
\item[{uint8\+\_\+t}]{flags}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Icmpv6L4Protocol_ae4324a775e75486fad5de41ec3030a0c}{}\label{classns3_1_1Icmpv6L4Protocol_ae4324a775e75486fad5de41ec3030a0c}


Send a Neighbor Adverstisement. 


\begin{DoxyParams}{Parameters}
{\em src} & source I\+Pv6 address \\
\hline
{\em dst} & destination I\+Pv6 address \\
\hline
{\em hardware\+Address} & our M\+AC address \\
\hline
{\em flags} & to set (4 = flag R, 2 = flag S, 3 = flag O) \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
949 \{
950   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << src << dst << hardwareAddress << static\_cast<uint32\_t> (flags));
951   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = Create<Packet> ();
952   Icmpv6NA na;
953   Icmpv6OptionLinkLayerAddress llOption (0, *hardwareAddress); \textcolor{comment}{/* not a source link layer */}
954 
955   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Send NA ( from "} << src << \textcolor{stringliteral}{" to "} << dst << \textcolor{stringliteral}{" target "} << src << \textcolor{stringliteral}{")"});
956   na.SetIpv6Target (src);
957 
958   \textcolor{keywordflow}{if} ((flags & 1))
959     \{
960       na.SetFlagO (\textcolor{keyword}{true});
961     \}
962   \textcolor{keywordflow}{if} ((flags & 2) && src != \hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} ())
963     \{
964       na.SetFlagS (\textcolor{keyword}{true});
965     \}
966   \textcolor{keywordflow}{if} ((flags & 4))
967     \{
968       na.SetFlagR (\textcolor{keyword}{true});
969     \}
970 
971   p->AddHeader (llOption);
972   na.CalculatePseudoHeaderChecksum (src, dst, p->GetSize () + na.GetSerializedSize (), 
      \hyperlink{classns3_1_1Icmpv6L4Protocol_aa56c41a886a45b8b4f22a19afc827e2d}{PROT\_NUMBER});
973   p->AddHeader (na);
974 
975   \hyperlink{classns3_1_1Icmpv6L4Protocol_aca22b3999b518531f807d822060a06a8}{SendMessage} (p, src, dst, 255);
976 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 57


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Send\+NS@{Send\+NS}}
\index{Send\+NS@{Send\+NS}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+N\+S(\+Ipv6\+Address src, Ipv6\+Address dst, Ipv6\+Address target, Address hardware\+Address)}{SendNS(Ipv6Address src, Ipv6Address dst, Ipv6Address target, Address hardwareAddress)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Send\+NS (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{src, }
\item[{{\bf Ipv6\+Address}}]{dst, }
\item[{{\bf Ipv6\+Address}}]{target, }
\item[{{\bf Address}}]{hardware\+Address}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Icmpv6L4Protocol_aacd8a4ff185f48e74f4c4b8dc0da4398}{}\label{classns3_1_1Icmpv6L4Protocol_aacd8a4ff185f48e74f4c4b8dc0da4398}


Send a Neighbor Solicitation. 


\begin{DoxyParams}{Parameters}
{\em src} & source I\+Pv6 address \\
\hline
{\em dst} & destination I\+Pv6 address \\
\hline
{\em target} & target I\+Pv6 address \\
\hline
{\em hardware\+Address} & our mac address \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
993 \{
994   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << src << dst << target << hardwareAddress);
995   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = Create<Packet> ();
996   \textcolor{comment}{/* Ipv6Header ipHeader; */}
997   Icmpv6NS ns (target);
998   Icmpv6OptionLinkLayerAddress llOption (1, hardwareAddress);  \textcolor{comment}{/* we give our mac address in response */}
999 
1000   \textcolor{comment}{/* if the source is unspec, multicast the NA to all-nodes multicast */}
1001   \textcolor{keywordflow}{if} (src == \hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} ())
1002     \{
1003       dst = \hyperlink{classns3_1_1Ipv6Address_a11e6e4228d3d6e814b2c5ffc18c8ed20}{Ipv6Address::GetAllNodesMulticast} ();
1004     \}
1005 
1006   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Send NS ( from "} << src << \textcolor{stringliteral}{" to "} << dst << \textcolor{stringliteral}{" target "} << target << \textcolor{stringliteral}{")"});
1007 
1008   p->AddHeader (llOption);
1009   ns.CalculatePseudoHeaderChecksum (src, dst, p->GetSize () + ns.GetSerializedSize (), 
      \hyperlink{classns3_1_1Icmpv6L4Protocol_aa56c41a886a45b8b4f22a19afc827e2d}{PROT\_NUMBER});
1010   p->AddHeader (ns);
1011   \textcolor{keywordflow}{if} (!dst.IsMulticast ())
1012     \{
1013       \hyperlink{classns3_1_1Icmpv6L4Protocol_aca22b3999b518531f807d822060a06a8}{SendMessage} (p, src, dst, 255);
1014     \}
1015   \textcolor{keywordflow}{else}
1016     \{
1017       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Destination is Multicast, using DelayedSendMessage"});
1018       \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (\hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (
      \hyperlink{classns3_1_1Icmpv6L4Protocol_ac7e4a25978a861e34cef7bdd27efb1d9}{m\_solicitationJitter}->\hyperlink{classns3_1_1RandomVariableStream_a4fa5944dc4cb11544e661ed23072b36c}{GetValue} ())), &
      \hyperlink{classns3_1_1Icmpv6L4Protocol_a3c4b85301ce19b8b2791402972553127}{Icmpv6L4Protocol::DelayedSendMessage}, \textcolor{keyword}{this}, 
      \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, src, dst, 255);
1019     \}
1020 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 58




Here is the caller graph for this function\+:
% FIG 59


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Send\+Redirection@{Send\+Redirection}}
\index{Send\+Redirection@{Send\+Redirection}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Redirection(\+Ptr$<$ Packet $>$ redirected\+Packet, Ipv6\+Address src, Ipv6\+Address dst, Ipv6\+Address redir\+Target, Ipv6\+Address redir\+Destination, Address redir\+Hardware\+Target)}{SendRedirection(Ptr< Packet > redirectedPacket, Ipv6Address src, Ipv6Address dst, Ipv6Address redirTarget, Ipv6Address redirDestination, Address redirHardwareTarget)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Send\+Redirection (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{redirected\+Packet, }
\item[{{\bf Ipv6\+Address}}]{src, }
\item[{{\bf Ipv6\+Address}}]{dst, }
\item[{{\bf Ipv6\+Address}}]{redir\+Target, }
\item[{{\bf Ipv6\+Address}}]{redir\+Destination, }
\item[{{\bf Address}}]{redir\+Hardware\+Target}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Icmpv6L4Protocol_a775f19603b15e25f287f54096a3f26cb}{}\label{classns3_1_1Icmpv6L4Protocol_a775f19603b15e25f287f54096a3f26cb}


Send an I\+C\+M\+Pv6 Redirection. 


\begin{DoxyParams}{Parameters}
{\em redirected\+Packet} & the redirected packet \\
\hline
{\em src} & I\+Pv6 address to send the redirect from \\
\hline
{\em dst} & I\+Pv6 address to send the redirect to \\
\hline
{\em redir\+Target} & I\+Pv6 target address for \hyperlink{classns3_1_1Icmpv6Redirection}{Icmpv6\+Redirection} \\
\hline
{\em redir\+Destination} & I\+Pv6 destination address for \hyperlink{classns3_1_1Icmpv6Redirection}{Icmpv6\+Redirection} \\
\hline
{\em redir\+Hardware\+Target} & L2 target address for Icmpv6\+Option\+Rdirected \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1149 \{
1150   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << redirectedPacket << dst << redirTarget << redirDestination << 
      redirHardwareTarget);
1151   uint32\_t llaSize = 0;
1152   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = Create<Packet> ();
1153   uint32\_t redirectedPacketSize = redirectedPacket->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} ();
1154   Icmpv6OptionLinkLayerAddress llOption (0);
1155 
1156   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Send Redirection ( to "} << dst << \textcolor{stringliteral}{" target "} << redirTarget << \textcolor{stringliteral}{" destination "}
       << redirDestination << \textcolor{stringliteral}{" )"});
1157 
1158   Icmpv6OptionRedirected redirectedOptionHeader;
1159 
1160   \textcolor{keywordflow}{if} ((redirectedPacketSize % 8) != 0)
1161     \{
1162       Ptr<Packet> pad = Create<Packet> (8 - (redirectedPacketSize % 8));
1163       redirectedPacket->\hyperlink{classns3_1_1Packet_a14ec3d4250b425468764de58f5837b6b}{AddAtEnd} (pad);
1164     \}
1165 
1166   \textcolor{keywordflow}{if} (redirHardwareTarget.GetLength ())
1167     \{
1168       llOption.SetAddress (redirHardwareTarget);
1169       llaSize = llOption.GetSerializedSize ();
1170     \}
1171 
1172   \textcolor{comment}{/* 56 = sizeof IPv6 header + sizeof ICMPv6 error header + sizeof redirected option */}
1173   \textcolor{keywordflow}{if} (redirectedPacketSize <= (1280 - 56 - llaSize))
1174     \{
1175       redirectedOptionHeader.SetPacket (redirectedPacket);
1176     \}
1177   \textcolor{keywordflow}{else}
1178     \{
1179       Ptr<Packet> fragment = redirectedPacket->\hyperlink{classns3_1_1Packet_a16f6113606b355b2b346e2245fa2a3d0}{CreateFragment} (0, 1280 - 56 - llaSize);
1180       redirectedOptionHeader.SetPacket (fragment);
1181     \}
1182 
1183   p->\hyperlink{classns3_1_1Packet_a465108c595a0bc592095cbcab1832ed8}{AddHeader} (redirectedOptionHeader);
1184 
1185   \textcolor{keywordflow}{if} (llaSize)
1186     \{
1187       p->AddHeader (llOption);
1188     \}
1189 
1190   Icmpv6Redirection redirectionHeader;
1191   redirectionHeader.SetTarget (redirTarget);
1192   redirectionHeader.SetDestination (redirDestination);
1193   redirectionHeader.CalculatePseudoHeaderChecksum (src, dst, p->GetSize () + redirectionHeader.
      GetSerializedSize (), \hyperlink{classns3_1_1Icmpv6L4Protocol_aa56c41a886a45b8b4f22a19afc827e2d}{PROT\_NUMBER});
1194   p->AddHeader (redirectionHeader);
1195 
1196   \hyperlink{classns3_1_1Icmpv6L4Protocol_aca22b3999b518531f807d822060a06a8}{SendMessage} (p, src, dst, 64);
1197 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 60


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Send\+RS@{Send\+RS}}
\index{Send\+RS@{Send\+RS}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+R\+S(\+Ipv6\+Address src, Ipv6\+Address dst, Address hardware\+Address)}{SendRS(Ipv6Address src, Ipv6Address dst, Address hardwareAddress)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Send\+RS (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{src, }
\item[{{\bf Ipv6\+Address}}]{dst, }
\item[{{\bf Address}}]{hardware\+Address}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Icmpv6L4Protocol_aaf09883d79f1a055df31d23089a0ea3b}{}\label{classns3_1_1Icmpv6L4Protocol_aaf09883d79f1a055df31d23089a0ea3b}


Send a Router Solicitation. 


\begin{DoxyParams}{Parameters}
{\em src} & link-\/local source address \\
\hline
{\em dst} & destination address (usealy ff02\+:\+:2 i.\+e all-\/routers) \\
\hline
{\em hardware\+Address} & link-\/layer address (S\+H\+O\+U\+LD be included if src is not \+:\+:) \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1023 \{
1024   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << src << dst << hardwareAddress);
1025   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = Create<Packet> ();
1026   Icmpv6RS rs;
1027   Icmpv6OptionLinkLayerAddress llOption (1, hardwareAddress);  \textcolor{comment}{/* we give our mac address in response */}
1028 
1029   \textcolor{comment}{/* if the source is unspec, multicast the NA to all-nodes multicast */}
1030   \textcolor{keywordflow}{if} (src != \hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} ())
1031     \{
1032       p->AddHeader (llOption);
1033     \}
1034 
1035   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Send RS ( from "} << src << \textcolor{stringliteral}{" to "} << dst << \textcolor{stringliteral}{")"});
1036 
1037   rs.CalculatePseudoHeaderChecksum (src, dst, p->GetSize () + rs.GetSerializedSize (), 
      \hyperlink{classns3_1_1Icmpv6L4Protocol_aa56c41a886a45b8b4f22a19afc827e2d}{PROT\_NUMBER});
1038   p->AddHeader (rs);
1039   \textcolor{keywordflow}{if} (!dst.IsMulticast ())
1040     \{
1041       \hyperlink{classns3_1_1Icmpv6L4Protocol_aca22b3999b518531f807d822060a06a8}{SendMessage} (p, src, dst, 255);
1042     \}
1043   \textcolor{keywordflow}{else}
1044     \{
1045       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Destination is Multicast, using DelayedSendMessage"});
1046       \hyperlink{classns3_1_1Simulator_a671882c894a08af4a5e91181bf1eec13}{Simulator::Schedule} (\hyperlink{namespacens3_1_1TracedValueCallback_a7ffd3e7c142ffe7c8a1d2db9b8de38ec}{Time} (\hyperlink{group__timecivil_gaf26127cf4571146b83a92ee18679c7a9}{MilliSeconds} (
      \hyperlink{classns3_1_1Icmpv6L4Protocol_ac7e4a25978a861e34cef7bdd27efb1d9}{m\_solicitationJitter}->\hyperlink{classns3_1_1RandomVariableStream_a4fa5944dc4cb11544e661ed23072b36c}{GetValue} ())), &
      \hyperlink{classns3_1_1Icmpv6L4Protocol_a3c4b85301ce19b8b2791402972553127}{Icmpv6L4Protocol::DelayedSendMessage}, \textcolor{keyword}{this}, 
      \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, src, dst, 255);
1047     \}
1048 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 61




Here is the caller graph for this function\+:
% FIG 62


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Set\+Down\+Target@{Set\+Down\+Target}}
\index{Set\+Down\+Target@{Set\+Down\+Target}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Down\+Target(\+Ip\+L4\+Protocol\+::\+Down\+Target\+Callback cb)}{SetDownTarget(IpL4Protocol::DownTargetCallback cb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Set\+Down\+Target (
\begin{DoxyParamCaption}
\item[{{\bf Ip\+L4\+Protocol\+::\+Down\+Target\+Callback}}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_a00e5888c45d07ad5a35b98995b813f23}{}\label{classns3_1_1Icmpv6L4Protocol_a00e5888c45d07ad5a35b98995b813f23}
This method allows a caller to set the current down target callback set for this L4 protocol (I\+Pv4 case)


\begin{DoxyParams}{Parameters}
{\em cb} & current \hyperlink{classns3_1_1Callback}{Callback} for the L4 protocol \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1IpL4Protocol_a9fc5e8e30a16bdc87623fa2ebc981af3}{ns3\+::\+Ip\+L4\+Protocol}.


\begin{DoxyCode}
1448 \{
1449   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << &callback);
1450 \}
\end{DoxyCode}
\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Set\+Down\+Target6@{Set\+Down\+Target6}}
\index{Set\+Down\+Target6@{Set\+Down\+Target6}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Down\+Target6(\+Ip\+L4\+Protocol\+::\+Down\+Target\+Callback6 cb)}{SetDownTarget6(IpL4Protocol::DownTargetCallback6 cb)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Set\+Down\+Target6 (
\begin{DoxyParamCaption}
\item[{{\bf Ip\+L4\+Protocol\+::\+Down\+Target\+Callback6}}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_aa0f5416435059e873d216ffc07928f23}{}\label{classns3_1_1Icmpv6L4Protocol_aa0f5416435059e873d216ffc07928f23}
This method allows a caller to set the current down target callback set for this L4 protocol (I\+Pv6 case)


\begin{DoxyParams}{Parameters}
{\em cb} & current \hyperlink{classns3_1_1Callback}{Callback} for the L4 protocol \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1IpL4Protocol_a2c3427eada095f3ae9a5e78fe6523e1e}{ns3\+::\+Ip\+L4\+Protocol}.


\begin{DoxyCode}
1454 \{
1455   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << &callback);
1456   \hyperlink{classns3_1_1Icmpv6L4Protocol_a8cd5beb542044689be316d6e6963bb3a}{m\_downTarget} = callback;
1457 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 63


\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!Set\+Node@{Set\+Node}}
\index{Set\+Node@{Set\+Node}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Node(\+Ptr$<$ Node $>$ node)}{SetNode(Ptr< Node > node)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Icmpv6\+L4\+Protocol\+::\+Set\+Node (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Icmpv6L4Protocol_af6108107ea3ca1dee9495671183bd31f}{}\label{classns3_1_1Icmpv6L4Protocol_af6108107ea3ca1dee9495671183bd31f}


Set the node. 


\begin{DoxyParams}{Parameters}
{\em node} & the node to set \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
159 \{
160   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << node);
161   \hyperlink{classns3_1_1Icmpv6L4Protocol_a8968d1631f94f0b1cc1fd0e71ea0d0fe}{m\_node} = node;
162 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 64




\subsection{Member Data Documentation}
\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!m\+\_\+always\+Dad@{m\+\_\+always\+Dad}}
\index{m\+\_\+always\+Dad@{m\+\_\+always\+Dad}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+always\+Dad}{m_alwaysDad}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Icmpv6\+L4\+Protocol\+::m\+\_\+always\+Dad\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_aa21acf24e3acd05c073c0b15d94b6759}{}\label{classns3_1_1Icmpv6L4Protocol_aa21acf24e3acd05c073c0b15d94b6759}


Always do D\+AD ? 

\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!m\+\_\+cache\+List@{m\+\_\+cache\+List}}
\index{m\+\_\+cache\+List@{m\+\_\+cache\+List}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+cache\+List}{m_cacheList}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cache\+List} ns3\+::\+Icmpv6\+L4\+Protocol\+::m\+\_\+cache\+List\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_af48a7cf3be7bc3d413c9302b10314244}{}\label{classns3_1_1Icmpv6L4Protocol_af48a7cf3be7bc3d413c9302b10314244}


A list of cache by device. 

\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!m\+\_\+delay\+First\+Probe@{m\+\_\+delay\+First\+Probe}}
\index{m\+\_\+delay\+First\+Probe@{m\+\_\+delay\+First\+Probe}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+delay\+First\+Probe}{m_delayFirstProbe}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Icmpv6\+L4\+Protocol\+::m\+\_\+delay\+First\+Probe\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_acaf08c9a0615db56d8b0a2632abef51a}{}\label{classns3_1_1Icmpv6L4Protocol_acaf08c9a0615db56d8b0a2632abef51a}


Neighbor Discovery node constants\+: delay for the first probe. 

\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!m\+\_\+down\+Target@{m\+\_\+down\+Target}}
\index{m\+\_\+down\+Target@{m\+\_\+down\+Target}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+down\+Target}{m_downTarget}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ip\+L4\+Protocol\+::\+Down\+Target\+Callback6} ns3\+::\+Icmpv6\+L4\+Protocol\+::m\+\_\+down\+Target\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_a8cd5beb542044689be316d6e6963bb3a}{}\label{classns3_1_1Icmpv6L4Protocol_a8cd5beb542044689be316d6e6963bb3a}


callback to \hyperlink{classns3_1_1Ipv6_a2aad308983b20eb54334bb0d3db31004}{Ipv6\+::\+Send} 

\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!m\+\_\+max\+Multicast\+Solicit@{m\+\_\+max\+Multicast\+Solicit}}
\index{m\+\_\+max\+Multicast\+Solicit@{m\+\_\+max\+Multicast\+Solicit}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Multicast\+Solicit}{m_maxMulticastSolicit}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::\+Icmpv6\+L4\+Protocol\+::m\+\_\+max\+Multicast\+Solicit\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_a10486bb2cca386e400fa833e19f93502}{}\label{classns3_1_1Icmpv6L4Protocol_a10486bb2cca386e400fa833e19f93502}


Neighbor Discovery node constants\+: max multicast solicitations. 

\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!m\+\_\+max\+Unicast\+Solicit@{m\+\_\+max\+Unicast\+Solicit}}
\index{m\+\_\+max\+Unicast\+Solicit@{m\+\_\+max\+Unicast\+Solicit}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+max\+Unicast\+Solicit}{m_maxUnicastSolicit}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::\+Icmpv6\+L4\+Protocol\+::m\+\_\+max\+Unicast\+Solicit\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_a772aa2162734a24996b92d673127e7eb}{}\label{classns3_1_1Icmpv6L4Protocol_a772aa2162734a24996b92d673127e7eb}


Neighbor Discovery node constants\+: max unicast solicitations. 

\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!m\+\_\+node@{m\+\_\+node}}
\index{m\+\_\+node@{m\+\_\+node}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+node}{m_node}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Node}$>$ ns3\+::\+Icmpv6\+L4\+Protocol\+::m\+\_\+node\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_a8968d1631f94f0b1cc1fd0e71ea0d0fe}{}\label{classns3_1_1Icmpv6L4Protocol_a8968d1631f94f0b1cc1fd0e71ea0d0fe}


The node. 

\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!m\+\_\+reachable\+Time@{m\+\_\+reachable\+Time}}
\index{m\+\_\+reachable\+Time@{m\+\_\+reachable\+Time}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+reachable\+Time}{m_reachableTime}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Icmpv6\+L4\+Protocol\+::m\+\_\+reachable\+Time\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_a18fdc8ec4b55d2192edffb949e89f593}{}\label{classns3_1_1Icmpv6L4Protocol_a18fdc8ec4b55d2192edffb949e89f593}


Neighbor Discovery node constants\+: reachable time. 

\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!m\+\_\+retransmission\+Time@{m\+\_\+retransmission\+Time}}
\index{m\+\_\+retransmission\+Time@{m\+\_\+retransmission\+Time}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+retransmission\+Time}{m_retransmissionTime}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} ns3\+::\+Icmpv6\+L4\+Protocol\+::m\+\_\+retransmission\+Time\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_ab06c636fc6de4e1deefb8e9e53bd0dd4}{}\label{classns3_1_1Icmpv6L4Protocol_ab06c636fc6de4e1deefb8e9e53bd0dd4}


Neighbor Discovery node constants\+: retransmission timer. 

\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!m\+\_\+solicitation\+Jitter@{m\+\_\+solicitation\+Jitter}}
\index{m\+\_\+solicitation\+Jitter@{m\+\_\+solicitation\+Jitter}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+solicitation\+Jitter}{m_solicitationJitter}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Random\+Variable\+Stream}$>$ ns3\+::\+Icmpv6\+L4\+Protocol\+::m\+\_\+solicitation\+Jitter\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_ac7e4a25978a861e34cef7bdd27efb1d9}{}\label{classns3_1_1Icmpv6L4Protocol_ac7e4a25978a861e34cef7bdd27efb1d9}


Random jitter before sending solicitations. 

\index{ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}!P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER@{P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER}}
\index{P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER@{P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER}!ns3\+::\+Icmpv6\+L4\+Protocol@{ns3\+::\+Icmpv6\+L4\+Protocol}}
\subsubsection[{\texorpdfstring{P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER}{PROT_NUMBER}}]{\setlength{\rightskip}{0pt plus 5cm}const uint8\+\_\+t ns3\+::\+Icmpv6\+L4\+Protocol\+::\+P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER = 58\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Icmpv6L4Protocol_aa56c41a886a45b8b4f22a19afc827e2d}{}\label{classns3_1_1Icmpv6L4Protocol_aa56c41a886a45b8b4f22a19afc827e2d}


I\+C\+M\+Pv6 protocol number (58). 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/model/\hyperlink{icmpv6-l4-protocol_8h}{icmpv6-\/l4-\/protocol.\+h}\item 
internet/model/\hyperlink{icmpv6-l4-protocol_8cc}{icmpv6-\/l4-\/protocol.\+cc}\end{DoxyCompactItemize}
