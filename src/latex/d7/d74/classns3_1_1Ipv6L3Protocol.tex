\hypertarget{classns3_1_1Ipv6L3Protocol}{}\section{ns3\+:\+:Ipv6\+L3\+Protocol Class Reference}
\label{classns3_1_1Ipv6L3Protocol}\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}


I\+Pv6 layer implementation.  




{\ttfamily \#include $<$ipv6-\/l3-\/protocol.\+h$>$}



Inheritance diagram for ns3\+:\+:Ipv6\+L3\+Protocol\+:
% FIG 0


Collaboration diagram for ns3\+:\+:Ipv6\+L3\+Protocol\+:
% FIG 1
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37a}{Drop\+Reason} \{ \\*
\hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa49c4e7173190b1bbba7d6300b06a16ed}{D\+R\+O\+P\+\_\+\+T\+T\+L\+\_\+\+E\+X\+P\+I\+R\+ED} = 1, 
\hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa97de4f69c19b2f94b684448beee892f4}{D\+R\+O\+P\+\_\+\+N\+O\+\_\+\+R\+O\+U\+TE}, 
\hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa72b499545685a47a7cf3588d1330d5d0}{D\+R\+O\+P\+\_\+\+I\+N\+T\+E\+R\+F\+A\+C\+E\+\_\+\+D\+O\+WN}, 
\hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa3690e9264e4d2307050512b833df4946}{D\+R\+O\+P\+\_\+\+R\+O\+U\+T\+E\+\_\+\+E\+R\+R\+OR}, 
\\*
\hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aaaf932a981ea33f927add80ea8ed41b05}{D\+R\+O\+P\+\_\+\+U\+N\+K\+N\+O\+W\+N\+\_\+\+P\+R\+O\+T\+O\+C\+OL}, 
\hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa803fe59e441ce2bc53f0fe19df60c14a}{D\+R\+O\+P\+\_\+\+U\+N\+K\+N\+O\+W\+N\+\_\+\+O\+P\+T\+I\+ON}, 
\hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aaddfae41b279341b99d46df16e0d4ea7b}{D\+R\+O\+P\+\_\+\+M\+A\+L\+F\+O\+R\+M\+E\+D\+\_\+\+H\+E\+A\+D\+ER}, 
\hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa27ee7f562d7201ffd26f3e08bf620d0a}{D\+R\+O\+P\+\_\+\+F\+R\+A\+G\+M\+E\+N\+T\+\_\+\+T\+I\+M\+E\+O\+UT}
 \}\begin{DoxyCompactList}\small\item\em Reason why a packet has been dropped. \end{DoxyCompactList}
\item 
typedef void($\ast$ \hyperlink{classns3_1_1Ipv6L3Protocol_a15e365bcfa93746691e7acf8a9ef7718}{Sent\+Traced\+Callback}) (const \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, uint32\+\_\+t interface)
\item 
typedef void($\ast$ \hyperlink{classns3_1_1Ipv6L3Protocol_a5b967a1009f9c57047f135573fd5519f}{Tx\+Rx\+Traced\+Callback}) (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6}{Ipv6} $>$ ipv6, uint32\+\_\+t interface)
\item 
typedef void($\ast$ \hyperlink{classns3_1_1Ipv6L3Protocol_a9b04d0fb9a344dce07430ba7d90f0995}{Drop\+Traced\+Callback}) (const \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} \&header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37a}{Drop\+Reason} reason, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6}{Ipv6} $>$ ipv6, uint32\+\_\+t interface)
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1Ipv6L3Protocol_aed69fbc6c2eca9a88dfb50f12b419902}{Ipv6\+L3\+Protocol} ()
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ipv6L3Protocol_a169c63b470b2de16ee8c9d5e241488a8}{$\sim$\+Ipv6\+L3\+Protocol} ()
\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6L3Protocol_a53796a2747cb5edcd1c762f44043b061}{Set\+Node} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ node)
\begin{DoxyCompactList}\small\item\em Set node associated with this stack. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6L3Protocol_afcdf13ca065622b8cb4691f2d3e92002}{Insert} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} $>$ protocol)
\begin{DoxyCompactList}\small\item\em Add a L4 protocol. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6L3Protocol_a8b7f000d9d6d897dff787bfddab34872}{Insert} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} $>$ protocol, uint32\+\_\+t interface\+Index)
\begin{DoxyCompactList}\small\item\em Add a L4 protocol to a specific interface. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6L3Protocol_a70024f0b3f0cca53815ddf98eb49176a}{Remove} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} $>$ protocol)
\begin{DoxyCompactList}\small\item\em Remove a L4 protocol. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6L3Protocol_a2119b6e87a951156aec7a93199bf2b19}{Remove} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} $>$ protocol, uint32\+\_\+t interface\+Index)
\begin{DoxyCompactList}\small\item\em Remove a L4 protocol from a specific interface. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} $>$ \hyperlink{classns3_1_1Ipv6L3Protocol_acb189bb5deceb95e78f2a443609c8d64}{Get\+Protocol} (int protocol\+Number) const 
\begin{DoxyCompactList}\small\item\em Get L4 protocol by protocol number. \end{DoxyCompactList}\item 
virtual \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} $>$ \hyperlink{classns3_1_1Ipv6L3Protocol_a8c7d6e8831a6606311f0dd0eab0a3f56}{Get\+Protocol} (int protocol\+Number, int32\+\_\+t interface\+Index) const 
\begin{DoxyCompactList}\small\item\em Get L4 protocol by protocol number for the specified interface. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$ \hyperlink{classns3_1_1Ipv6L3Protocol_a6aa13fd7fb8a9afa3c017ff15799fd23}{Create\+Raw\+Socket} ()
\begin{DoxyCompactList}\small\item\em Create raw I\+Pv6 socket. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6L3Protocol_ab490d143f904a9899e3dd21ac8942016}{Delete\+Raw\+Socket} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Socket}{Socket} $>$ socket)
\begin{DoxyCompactList}\small\item\em Remove raw I\+Pv6 socket. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6L3Protocol_a7eadd617007c0f0515d4d6b1c393f45e}{Set\+Default\+Ttl} (uint8\+\_\+t ttl)
\begin{DoxyCompactList}\small\item\em Set the default T\+TL. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6L3Protocol_ac4da722470be0e2869f11b6835cc3579}{Set\+Default\+Tclass} (uint8\+\_\+t tclass)
\begin{DoxyCompactList}\small\item\em Set the default T\+C\+L\+A\+SS. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6L3Protocol_a8a95d576e8aee9a571db93bf686d850a}{Receive} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, uint16\+\_\+t protocol, const \hyperlink{classns3_1_1Address}{Address} \&\hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from}, const \hyperlink{classns3_1_1Address}{Address} \&to, \hyperlink{classns3_1_1NetDevice_ace65153f09144f55a0d3e702fc29d6b2}{Net\+Device\+::\+Packet\+Type} packet\+Type)
\begin{DoxyCompactList}\small\item\em Receive method when a packet arrive in the stack. This method removes I\+Pv6 header and forward up to L4 protocol. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6L3Protocol_ac281dd6c5aff55330904e7a298c1881b}{Send} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} source, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} destination, uint8\+\_\+t protocol, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Route}{Ipv6\+Route} $>$ route)
\begin{DoxyCompactList}\small\item\em Higher-\/level layers call this method to send a packet down the stack to the M\+AC and P\+HY layers. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6L3Protocol_a9f65728e13ee4a2fb5588d3601e7634f}{Set\+Routing\+Protocol} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} $>$ routing\+Protocol)
\begin{DoxyCompactList}\small\item\em Set routing protocol for this stack. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} $>$ \hyperlink{classns3_1_1Ipv6L3Protocol_aea90446045bb78b99b150ef1dd9afdb4}{Get\+Routing\+Protocol} () const 
\begin{DoxyCompactList}\small\item\em Get current routing protocol used. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1Ipv6L3Protocol_a56047c2ee7db15185af07538c609cbb5}{Add\+Interface} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device)
\begin{DoxyCompactList}\small\item\em Add I\+Pv6 interface for a device. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Interface}{Ipv6\+Interface} $>$ \hyperlink{classns3_1_1Ipv6L3Protocol_a2e53b72d76bceb713f2d3cb54e24f5a1}{Get\+Interface} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) const 
\begin{DoxyCompactList}\small\item\em Get an interface. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1Ipv6L3Protocol_a53882c40f6fb32e2a6fe0a7a2858698d}{Get\+N\+Interfaces} () const 
\begin{DoxyCompactList}\small\item\em Get current number of interface on this stack. \end{DoxyCompactList}\item 
int32\+\_\+t \hyperlink{classns3_1_1Ipv6L3Protocol_ae8d652431e374e8b05425ae9e1bf0f1b}{Get\+Interface\+For\+Address} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} addr) const 
\begin{DoxyCompactList}\small\item\em Get interface index which has specified I\+Pv6 address. \end{DoxyCompactList}\item 
int32\+\_\+t \hyperlink{classns3_1_1Ipv6L3Protocol_ad6454a2718ec03a97ff11a29bc015ef2}{Get\+Interface\+For\+Prefix} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} addr, \hyperlink{classns3_1_1Ipv6Prefix}{Ipv6\+Prefix} mask) const 
\begin{DoxyCompactList}\small\item\em Get interface index which match specified address/prefix. \end{DoxyCompactList}\item 
int32\+\_\+t \hyperlink{classns3_1_1Ipv6L3Protocol_a878292513d6294e2dfdeccbe1ed1d996}{Get\+Interface\+For\+Device} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ device) const 
\begin{DoxyCompactList}\small\item\em Get interface index which is on a specified net device. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Ipv6L3Protocol_a33135677dcaa195be223eaf4f38a6efe}{Add\+Address} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, \hyperlink{classns3_1_1Ipv6InterfaceAddress}{Ipv6\+Interface\+Address} address)
\begin{DoxyCompactList}\small\item\em Add an address on interface. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6InterfaceAddress}{Ipv6\+Interface\+Address} \hyperlink{classns3_1_1Ipv6L3Protocol_a0321a9ac3f79b5a7b7542cecf11bfe44}{Get\+Address} (uint32\+\_\+t interface\+Index, uint32\+\_\+t address\+Index) const 
\begin{DoxyCompactList}\small\item\em Get an address. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1Ipv6L3Protocol_a3b09a9f504a311ecc08fdc026d897514}{Get\+N\+Addresses} (uint32\+\_\+t interface) const 
\begin{DoxyCompactList}\small\item\em Get number of address for an interface. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Ipv6L3Protocol_a6e955b0de62f2c28fea71108e8df2545}{Remove\+Address} (uint32\+\_\+t interface\+Index, uint32\+\_\+t address\+Index)
\begin{DoxyCompactList}\small\item\em Remove an address from an interface. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Ipv6L3Protocol_a7e3a0ee9e79a09f208285e4f788ad4ed}{Remove\+Address} (uint32\+\_\+t interface\+Index, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} address)
\begin{DoxyCompactList}\small\item\em Remove a specified \hyperlink{classns3_1_1Ipv6}{Ipv6} address from an interface. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6L3Protocol_a5d0a141d4b667d8f39f903b9d3fbeffd}{Set\+Metric} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, uint16\+\_\+t metric)
\begin{DoxyCompactList}\small\item\em Set metric for an interface. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1Ipv6L3Protocol_ad8b41a67f3f99823d6d5e0a5441970de}{Get\+Metric} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) const 
\begin{DoxyCompactList}\small\item\em Get metric for an interface. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{classns3_1_1Ipv6L3Protocol_a33cfa3ccae2ee968d581fc689c73beb5}{Get\+Mtu} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) const 
\begin{DoxyCompactList}\small\item\em Get M\+TU for an interface. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6L3Protocol_ab99ee90351fb7bbe9d2582376c3597ae}{Set\+Pmtu} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dst, uint32\+\_\+t pmtu)
\begin{DoxyCompactList}\small\item\em Set the Path M\+TU for the specified I\+Pv6 destination address. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Ipv6L3Protocol_a34fb6e5caedebf7c257bb4fa7c125a3c}{Is\+Up} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) const 
\begin{DoxyCompactList}\small\item\em Is specified interface up ? \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6L3Protocol_a834eba3100efc8f71e5292bbfdcde6e6}{Set\+Up} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
\begin{DoxyCompactList}\small\item\em Set an interface up. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6L3Protocol_aac61d62990fdfa91000cffe7fd918062}{Set\+Down} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
\begin{DoxyCompactList}\small\item\em set an interface down. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Ipv6L3Protocol_adae9c781382073a1db0429a4f156dee2}{Is\+Forwarding} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) const 
\begin{DoxyCompactList}\small\item\em Is interface allows forwarding ? \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6L3Protocol_a1a8bef4362f31f4f2b32ea6e7051467a}{Set\+Forwarding} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, bool val)
\begin{DoxyCompactList}\small\item\em Enable or disable forwarding on interface. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} \hyperlink{classns3_1_1Ipv6L3Protocol_a77acb50e395f36951381977368ebc5cb}{Source\+Address\+Selection} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dest)
\begin{DoxyCompactList}\small\item\em Choose the source address to use with destination address. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ \hyperlink{classns3_1_1Ipv6L3Protocol_a574d1beafc86062acf582e75dc437a47}{Get\+Net\+Device} (uint32\+\_\+t \hyperlink{lte__uplink__power__control_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})
\begin{DoxyCompactList}\small\item\em Get device by index. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Icmpv6L4Protocol}{Icmpv6\+L4\+Protocol} $>$ \hyperlink{classns3_1_1Ipv6L3Protocol_a10384a4dc85c61e65cf73b47ec9da90d}{Get\+Icmpv6} () const 
\begin{DoxyCompactList}\small\item\em Get I\+C\+M\+Pv6 protocol. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6L3Protocol_a1806de87b35929a2181c2985e5df1ec0}{Add\+Autoconfigured\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} network, \hyperlink{classns3_1_1Ipv6Prefix}{Ipv6\+Prefix} mask, uint8\+\_\+t flags, uint32\+\_\+t valid\+Time, uint32\+\_\+t preferred\+Time, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} default\+Router=\hyperlink{classns3_1_1Ipv6Address_a63a34bdb1505e05fbdd07d316d0bd7e6}{Ipv6\+Address\+::\+Get\+Zero}())
\begin{DoxyCompactList}\small\item\em Add an autoconfigured address with RA information. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6L3Protocol_a6e8db427dbb1dfcaeecee8a6d793e94a}{Remove\+Autoconfigured\+Address} (uint32\+\_\+t interface, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} network, \hyperlink{classns3_1_1Ipv6Prefix}{Ipv6\+Prefix} mask, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} default\+Router)
\begin{DoxyCompactList}\small\item\em Remove an autoconfigured address. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6L3Protocol_a25cb7eac8f79c3461ec50b8464db2f8f}{Register\+Extensions} ()
\begin{DoxyCompactList}\small\item\em Register the I\+Pv6 Extensions. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6L3Protocol_ac9c52b73b294e0b592a5034b87278d92}{Register\+Options} ()
\begin{DoxyCompactList}\small\item\em Register the I\+Pv6 Options. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6L3Protocol_a65592c538120dd1b628727c1fae71bcf}{Report\+Drop} (\hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} ip\+Header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37a}{Drop\+Reason} drop\+Reason)
\begin{DoxyCompactList}\small\item\em Report a packet drop. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6L3Protocol_a63db5954bff57ed45b1a6f1847949e11}{Add\+Multicast\+Address} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} address)
\item 
void \hyperlink{classns3_1_1Ipv6L3Protocol_aa1b596016a4983592469afcbcbc3be24}{Add\+Multicast\+Address} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} address, uint32\+\_\+t interface)
\item 
void \hyperlink{classns3_1_1Ipv6L3Protocol_a989f80923c9a36329391c932c66eb023}{Remove\+Multicast\+Address} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} address)
\item 
void \hyperlink{classns3_1_1Ipv6L3Protocol_a8d44abee229e1b89199fc7f1dec1919a}{Remove\+Multicast\+Address} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} address, uint32\+\_\+t interface)
\item 
bool \hyperlink{classns3_1_1Ipv6L3Protocol_ad883e42df23aa1fc0fe38a1489830b1a}{Is\+Registered\+Multicast\+Address} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} address) const 
\item 
bool \hyperlink{classns3_1_1Ipv6L3Protocol_a6c649bc2bafa7ef1c2a7ec9ef0674e2b}{Is\+Registered\+Multicast\+Address} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} address, uint32\+\_\+t interface) const 
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classns3_1_1TypeId}{Type\+Id} \hyperlink{classns3_1_1Ipv6L3Protocol_afb1b9affe13b7f2c4ccc0923fa291e11}{Get\+Type\+Id} ()
\begin{DoxyCompactList}\small\item\em Get the type ID of this class. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const uint16\+\_\+t \hyperlink{classns3_1_1Ipv6L3Protocol_ac44af6866e3ddd3f0cb9fbe228afdfe9}{P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER} = 0x86\+DD
\begin{DoxyCompactList}\small\item\em The protocol number for I\+Pv6 (0x86\+DD). \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classns3_1_1Ipv6L3Protocol_ae5d9eccbe1a381fa00d38400989551e4}{Do\+Dispose} ()
\begin{DoxyCompactList}\small\item\em Dispose object. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6L3Protocol_ae07ff89952d068d18fb5650ffd1f5378}{Notify\+New\+Aggregate} ()
\begin{DoxyCompactList}\small\item\em Notify other components connected to the node that a new stack member is now connected. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
typedef std\+::vector$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Interface}{Ipv6\+Interface} $>$ $>$ \hyperlink{classns3_1_1Ipv6L3Protocol_a3324185c048c5bcd0a4511b8ebf166db}{Ipv6\+Interface\+List}
\begin{DoxyCompactList}\small\item\em Container of the I\+Pv6 Interfaces. \end{DoxyCompactList}\item 
typedef std\+::map$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$, uint32\+\_\+t $>$ \hyperlink{classns3_1_1Ipv6L3Protocol_a1fb40e4ad1a4612f73c192418df88228}{Ipv6\+Interface\+Reverse\+Container}
\begin{DoxyCompactList}\small\item\em Container of Net\+Devices registered to I\+Pv6 and their interface indexes. \end{DoxyCompactList}\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6RawSocketImpl}{Ipv6\+Raw\+Socket\+Impl} $>$ $>$ \hyperlink{classns3_1_1Ipv6L3Protocol_ab5dd63c7563ecb5ac6a2b019ad7fa484}{Socket\+List}
\begin{DoxyCompactList}\small\item\em Container of the I\+Pv6 Raw Sockets. \end{DoxyCompactList}\item 
typedef std\+::pair$<$ int, int32\+\_\+t $>$ \hyperlink{classns3_1_1Ipv6L3Protocol_ade8066a20a3494dbda177322b1d18c21}{L4\+List\+Key\+\_\+t}
\begin{DoxyCompactList}\small\item\em Container of the I\+Pv6 L4 keys\+: protocol number, interface index. \end{DoxyCompactList}\item 
typedef std\+::map$<$ \hyperlink{classns3_1_1Ipv6L3Protocol_ade8066a20a3494dbda177322b1d18c21}{L4\+List\+Key\+\_\+t}, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} $>$ $>$ \hyperlink{classns3_1_1Ipv6L3Protocol_a081eeffb80d91d0702285b6bb5687082}{L4\+List\+\_\+t}
\begin{DoxyCompactList}\small\item\em Container of the I\+Pv6 L4 instances. \end{DoxyCompactList}\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6AutoconfiguredPrefix}{Ipv6\+Autoconfigured\+Prefix} $>$ $>$ \hyperlink{classns3_1_1Ipv6L3Protocol_a9da53420c273775a4a089b4d2273e38f}{Ipv6\+Autoconfigured\+Prefix\+List}
\begin{DoxyCompactList}\small\item\em Container of the I\+Pv6 Autoconfigured addresses. \end{DoxyCompactList}\item 
typedef \hyperlink{openflow-interface_8h_afd9bcfa176617760671b67580f536fa7}{std\+::list}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6AutoconfiguredPrefix}{Ipv6\+Autoconfigured\+Prefix} $>$ $>$\+::iterator \hyperlink{classns3_1_1Ipv6L3Protocol_af00957df9fbda1b1427ad41dd788b99a}{Ipv6\+Autoconfigured\+Prefix\+ListI}
\begin{DoxyCompactList}\small\item\em Iterator of the container of the I\+Pv6 Autoconfigured addresses. \end{DoxyCompactList}\item 
typedef std\+::pair$<$ \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address}, uint64\+\_\+t $>$ \hyperlink{classns3_1_1Ipv6L3Protocol_ad85035c0604805049efdc7a5b3d99082}{Ipv6\+Registered\+Multicast\+Address\+Key\+\_\+t}
\begin{DoxyCompactList}\small\item\em I\+Pv6 multicast addresses / interface key. \end{DoxyCompactList}\item 
typedef std\+::map$<$ \hyperlink{classns3_1_1Ipv6L3Protocol_ad85035c0604805049efdc7a5b3d99082}{Ipv6\+Registered\+Multicast\+Address\+Key\+\_\+t}, uint32\+\_\+t $>$ \hyperlink{classns3_1_1Ipv6L3Protocol_a42035d08aa8b69e38952370622db7f80}{Ipv6\+Registered\+Multicast\+Address\+\_\+t}
\begin{DoxyCompactList}\small\item\em Container of the I\+Pv6 multicast addresses. \end{DoxyCompactList}\item 
typedef std\+::map$<$ \hyperlink{classns3_1_1Ipv6L3Protocol_ad85035c0604805049efdc7a5b3d99082}{Ipv6\+Registered\+Multicast\+Address\+Key\+\_\+t}, uint32\+\_\+t $>$\+::iterator \hyperlink{classns3_1_1Ipv6L3Protocol_aaa04da26fa5428e033aae963d54185fd}{Ipv6\+Registered\+Multicast\+Address\+Iter\+\_\+t}
\begin{DoxyCompactList}\small\item\em Container Iterator of the I\+Pv6 multicast addresses. \end{DoxyCompactList}\item 
typedef std\+::map$<$ \hyperlink{classns3_1_1Ipv6L3Protocol_ad85035c0604805049efdc7a5b3d99082}{Ipv6\+Registered\+Multicast\+Address\+Key\+\_\+t}, uint32\+\_\+t $>$\+::const\+\_\+iterator \hyperlink{classns3_1_1Ipv6L3Protocol_a656104cdf393b6e6a41c79d172c8e8fb}{Ipv6\+Registered\+Multicast\+Address\+C\+Iter\+\_\+t}
\begin{DoxyCompactList}\small\item\em Container Const Iterator of the I\+Pv6 multicast addresses. \end{DoxyCompactList}\item 
typedef std\+::map$<$ \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address}, uint32\+\_\+t $>$ \hyperlink{classns3_1_1Ipv6L3Protocol_a21d330eef03b790c7ff3330abfa738fa}{Ipv6\+Registered\+Multicast\+Address\+No\+Interface\+\_\+t}
\begin{DoxyCompactList}\small\item\em Container of the I\+Pv6 multicast addresses. \end{DoxyCompactList}\item 
typedef std\+::map$<$ \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address}, uint32\+\_\+t $>$\+::iterator \hyperlink{classns3_1_1Ipv6L3Protocol_ae91d00bae00de8b86d6bacdf8101864b}{Ipv6\+Registered\+Multicast\+Address\+No\+Interface\+Iter\+\_\+t}
\begin{DoxyCompactList}\small\item\em Container Iterator of the I\+Pv6 multicast addresses. \end{DoxyCompactList}\item 
typedef std\+::map$<$ \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address}, uint32\+\_\+t $>$\+::const\+\_\+iterator \hyperlink{classns3_1_1Ipv6L3Protocol_a635e981d0b583b98e00909163710dea9}{Ipv6\+Registered\+Multicast\+Address\+No\+Interface\+C\+Iter\+\_\+t}
\begin{DoxyCompactList}\small\item\em Container Const Iterator of the I\+Pv6 multicast addresses. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classns3_1_1Ipv6L3Protocol_a40e29e34a97639ad1caad6b64e732454}{Call\+Tx\+Trace} (const \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} \&ip\+Header, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6}{Ipv6} $>$ ipv6, uint32\+\_\+t interface)
\begin{DoxyCompactList}\small\item\em Make a copy of the packet, add the header and invoke the TX trace callback. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6L3Protocol_aa0f0403d05feecc7cac4745a66b0aaad}{Ipv6\+L3\+Protocol} (const \hyperlink{classns3_1_1Ipv6L3Protocol}{Ipv6\+L3\+Protocol} \&)
\begin{DoxyCompactList}\small\item\em Copy constructor. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6L3Protocol}{Ipv6\+L3\+Protocol} \& \hyperlink{classns3_1_1Ipv6L3Protocol_a623d2b2cf5c444973830dd12cb584554}{operator=} (const \hyperlink{classns3_1_1Ipv6L3Protocol}{Ipv6\+L3\+Protocol} \&)
\begin{DoxyCompactList}\small\item\em Copy constructor. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} \hyperlink{classns3_1_1Ipv6L3Protocol_a5374a6687ad09cfcd48ef13a99b48d16}{Build\+Header} (\hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} src, \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} dst, uint8\+\_\+t protocol, uint16\+\_\+t payload\+Size, uint8\+\_\+t hop\+Limit, uint8\+\_\+t tclass)
\begin{DoxyCompactList}\small\item\em Construct an I\+Pv6 header. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6L3Protocol_adad363af4c50cd94505b918b15f228d4}{Send\+Real\+Out} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Route}{Ipv6\+Route} $>$ route, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Packet}{Packet} $>$ packet, \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} const \&ip\+Header)
\begin{DoxyCompactList}\small\item\em Send packet with route. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6L3Protocol_ac956e0aaed5e961b6c25210c2b696da6}{Ip\+Forward} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ idev, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Route}{Ipv6\+Route} $>$ rtentry, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} \&header)
\begin{DoxyCompactList}\small\item\em Forward a packet. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6L3Protocol_aa65d2e4894ea499415227e232e854824}{Ip\+Multicast\+Forward} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1NetDevice}{Net\+Device} $>$ idev, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6MulticastRoute}{Ipv6\+Multicast\+Route} $>$ mrtentry, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} \&header)
\begin{DoxyCompactList}\small\item\em Forward a multicast packet. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6L3Protocol_a8e2c7a80851d870812295c19dc908a38}{Local\+Deliver} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} const \&ip, uint32\+\_\+t iif)
\begin{DoxyCompactList}\small\item\em Deliver a packet. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6L3Protocol_a0cdd2195de560337df8dbe1a412cbaf6}{Route\+Input\+Error} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$ \hyperlink{lte__link__budget__x2__handover__measures_8m_ac9de518908a968428863f829398a4e62}{p}, const \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} \&ip\+Header, \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket\+::\+Socket\+Errno} sock\+Errno)
\begin{DoxyCompactList}\small\item\em Fallback when no route is found. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{classns3_1_1Ipv6L3Protocol_aa0c786fd0209504c82b7278297a62f99}{Add\+Ipv6\+Interface} (\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6Interface}{Ipv6\+Interface} $>$ interface)
\begin{DoxyCompactList}\small\item\em Add an I\+Pv6 interface to the stack. \end{DoxyCompactList}\item 
void \hyperlink{classns3_1_1Ipv6L3Protocol_a69a1ef7b49dd3aa80c6807f467720005}{Setup\+Loopback} ()
\begin{DoxyCompactList}\small\item\em Setup loopback interface. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6L3Protocol_af305cd631f4f5b4acaf75f3d4243c08b}{Set\+Ip\+Forward} (bool forward)
\begin{DoxyCompactList}\small\item\em Set I\+Pv6 forwarding state. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1Ipv6L3Protocol_a5ea6340dc5eef31896c71201dd789d49}{Get\+Ip\+Forward} () const 
\begin{DoxyCompactList}\small\item\em Get I\+Pv6 forwarding state. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6L3Protocol_a9954be60f9cfc8b7570a18eb0b8b92f9}{Set\+Mtu\+Discover} (bool mtu\+Discover)
\begin{DoxyCompactList}\small\item\em Set I\+Pv6 M\+TU discover state. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1Ipv6L3Protocol_a3214a558eb2b6549243f39eb821bd543}{Get\+Mtu\+Discover} (void) const 
\begin{DoxyCompactList}\small\item\em Get I\+Pv6 M\+TU discover state. \end{DoxyCompactList}\item 
virtual void \hyperlink{classns3_1_1Ipv6L3Protocol_aa5c6bd6e857b631c812ed5bbe4566241}{Set\+Send\+Icmpv6\+Redirect} (bool send\+Icmpv6\+Redirect)
\begin{DoxyCompactList}\small\item\em Set the I\+C\+M\+Pv6 Redirect sending state. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classns3_1_1Ipv6L3Protocol_a4445c0e64ff312aedff3c5644fd6e99d}{Get\+Send\+Icmpv6\+Redirect} () const 
\begin{DoxyCompactList}\small\item\em Get the I\+C\+M\+Pv6 Redirect sending state. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6}{Ipv6} $>$, uint32\+\_\+t $>$ \hyperlink{classns3_1_1Ipv6L3Protocol_a2037be8528273f3495216a09384e38e7}{m\+\_\+tx\+Trace}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Callback}{Callback} to trace TX (transmission) packets. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6}{Ipv6} $>$, uint32\+\_\+t $>$ \hyperlink{classns3_1_1Ipv6L3Protocol_a2fc8b57fc958fccd7c708f8c8ca03da5}{m\+\_\+rx\+Trace}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Callback}{Callback} to trace RX (reception) packets. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ const \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} \&, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$, \hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37a}{Drop\+Reason}, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6}{Ipv6} $>$, uint32\+\_\+t $>$ \hyperlink{classns3_1_1Ipv6L3Protocol_ac22d2d63cac436267ae6cafc46880a6e}{m\+\_\+drop\+Trace}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Callback}{Callback} to trace drop packets. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ const \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} \&, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$, uint32\+\_\+t $>$ \hyperlink{classns3_1_1Ipv6L3Protocol_aac1ff242aa91275202e37cf7d805eec8}{m\+\_\+send\+Outgoing\+Trace}
\begin{DoxyCompactList}\small\item\em Trace of sent packets. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ const \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} \&, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$, uint32\+\_\+t $>$ \hyperlink{classns3_1_1Ipv6L3Protocol_a76b5cbe054e52a240d3e1a3ea0f891fd}{m\+\_\+unicast\+Forward\+Trace}
\begin{DoxyCompactList}\small\item\em Trace of unicast forwarded packets. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback}$<$ const \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} \&, \hyperlink{classns3_1_1Ptr}{Ptr}$<$ const \hyperlink{classns3_1_1Packet}{Packet} $>$, uint32\+\_\+t $>$ \hyperlink{classns3_1_1Ipv6L3Protocol_afd8b2aef3c54456b509cdc7356db577e}{m\+\_\+local\+Deliver\+Trace}
\begin{DoxyCompactList}\small\item\em Trace of locally delivered packets. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Node}{Node} $>$ \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\+\_\+node}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Node}{Node} attached to stack. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Ipv6L3Protocol_a3dbdeac3cc4ec17f5a6ab9475fc8e7a8}{m\+\_\+ip\+Forward}
\begin{DoxyCompactList}\small\item\em Forwarding packets (i.\+e. router mode) state. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Ipv6L3Protocol_a7b38ce20301ab4b5db712d45536d6e19}{m\+\_\+mtu\+Discover}
\begin{DoxyCompactList}\small\item\em M\+TU Discover (i.\+e. Path M\+TU) state. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6PmtuCache}{Ipv6\+Pmtu\+Cache} $>$ \hyperlink{classns3_1_1Ipv6L3Protocol_a03a839bfaf9ae8763a58a42e60b08ec5}{m\+\_\+pmtu\+Cache}
\begin{DoxyCompactList}\small\item\em Path M\+TU Cache. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6L3Protocol_a081eeffb80d91d0702285b6bb5687082}{L4\+List\+\_\+t} \hyperlink{classns3_1_1Ipv6L3Protocol_a5a68c54b92d81f93c41983ebdc0ef5b3}{m\+\_\+protocols}
\begin{DoxyCompactList}\small\item\em List of transport protocol. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6L3Protocol_a3324185c048c5bcd0a4511b8ebf166db}{Ipv6\+Interface\+List} \hyperlink{classns3_1_1Ipv6L3Protocol_a425d8738fd30fbc9345d57cfddd0d6d0}{m\+\_\+interfaces}
\begin{DoxyCompactList}\small\item\em List of I\+Pv6 interfaces. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6L3Protocol_a1fb40e4ad1a4612f73c192418df88228}{Ipv6\+Interface\+Reverse\+Container} \hyperlink{classns3_1_1Ipv6L3Protocol_aba2395fbe747b5c8d0f46d65556eea0c}{m\+\_\+reverse\+Interfaces\+Container}
\item 
uint32\+\_\+t \hyperlink{classns3_1_1Ipv6L3Protocol_a61c0b45c983a905ebfe4ebce1a90a1d7}{m\+\_\+n\+Interfaces}
\begin{DoxyCompactList}\small\item\em Number of I\+Pv6 interfaces managed by the stack. \end{DoxyCompactList}\item 
uint8\+\_\+t \hyperlink{classns3_1_1Ipv6L3Protocol_a2857858d48a3ce4f6bc1912d721825b7}{m\+\_\+default\+Ttl}
\begin{DoxyCompactList}\small\item\em Default T\+TL for outgoing packets. \end{DoxyCompactList}\item 
uint8\+\_\+t \hyperlink{classns3_1_1Ipv6L3Protocol_a0ead80eb6fa685c54dc155dff9157345}{m\+\_\+default\+Tclass}
\begin{DoxyCompactList}\small\item\em Default T\+C\+L\+A\+SS for outgoing packets. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Ipv6L3Protocol_ac00aee071bc7ab2096efbf8fdc5e3814}{m\+\_\+strong\+End\+System\+Model}
\begin{DoxyCompactList}\small\item\em Rejects packets directed to an interface with wrong address (\{1222\}). \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ptr}{Ptr}$<$ \hyperlink{classns3_1_1Ipv6RoutingProtocol}{Ipv6\+Routing\+Protocol} $>$ \hyperlink{classns3_1_1Ipv6L3Protocol_aa0df547e5240b218dc1f4742a2a00117}{m\+\_\+routing\+Protocol}
\begin{DoxyCompactList}\small\item\em Routing protocol. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6L3Protocol_ab5dd63c7563ecb5ac6a2b019ad7fa484}{Socket\+List} \hyperlink{classns3_1_1Ipv6L3Protocol_a515e9cba13d7fd95e5613f5c95ccc7b5}{m\+\_\+sockets}
\begin{DoxyCompactList}\small\item\em List of I\+Pv6 raw sockets. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6L3Protocol_a9da53420c273775a4a089b4d2273e38f}{Ipv6\+Autoconfigured\+Prefix\+List} \hyperlink{classns3_1_1Ipv6L3Protocol_a402d76e60e8ac25eeb200d2b288732c0}{m\+\_\+prefixes}
\begin{DoxyCompactList}\small\item\em List of I\+Pv6 prefix received from RA. \end{DoxyCompactList}\item 
bool \hyperlink{classns3_1_1Ipv6L3Protocol_a23aef420bfb1d9dd634681c4a78a0352}{m\+\_\+send\+Icmpv6\+Redirect}
\begin{DoxyCompactList}\small\item\em Allow I\+C\+M\+Pv6 Redirect sending state. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6L3Protocol_a42035d08aa8b69e38952370622db7f80}{Ipv6\+Registered\+Multicast\+Address\+\_\+t} \hyperlink{classns3_1_1Ipv6L3Protocol_a6d7573453cf2a73d44bfb2d68eed19c4}{m\+\_\+multicast\+Addresses}
\begin{DoxyCompactList}\small\item\em List of multicast IP addresses of interest, divided per interface. \end{DoxyCompactList}\item 
\hyperlink{classns3_1_1Ipv6L3Protocol_a21d330eef03b790c7ff3330abfa738fa}{Ipv6\+Registered\+Multicast\+Address\+No\+Interface\+\_\+t} \hyperlink{classns3_1_1Ipv6L3Protocol_a4b31a418ae742bed8835981afb433b1c}{m\+\_\+multicast\+Addresses\+No\+Interface}
\begin{DoxyCompactList}\small\item\em List of multicast IP addresses of interest for all the interfaces. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classns3_1_1Ipv6L3Protocol_a09b6212a5017142b4f4244e3809708b9}{\+::\+Ipv6\+L3\+Protocol\+Test\+Case}
\begin{DoxyCompactList}\small\item\em \hyperlink{classIpv6L3ProtocolTestCase}{Ipv6\+L3\+Protocol\+Test\+Case} test case. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Related Functions}
(Note that these are not member functions.) \begin{DoxyCompactItemize}
\item 
class \hyperlink{classns3_1_1Ipv6L3Protocol_aa3cefd4bf01ad6e80cfae2da346cccc2}{Ipv6\+Extension\+Loose\+Routing}
\begin{DoxyCompactList}\small\item\em \hyperlink{classns3_1_1Ipv6ExtensionLooseRouting}{Ipv6\+Extension\+Loose\+Routing}. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
I\+Pv6 layer implementation. 

This class contains two distinct groups of trace sources. The trace sources \textquotesingle{}Rx\textquotesingle{} and \textquotesingle{}Tx\textquotesingle{} are called, respectively, immediately after receiving from the \hyperlink{classns3_1_1NetDevice}{Net\+Device} and immediately before sending to a \hyperlink{classns3_1_1NetDevice}{Net\+Device} for transmitting a packet. These are low level trace sources that include the \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} already serialized into the packet. In contrast, the Drop, Send\+Outgoing, Unicast\+Forward, and Local\+Deliver trace sources are slightly higher-\/level and pass around the \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header} as an explicit parameter and not as part of the packet. 

\subsection{Member Typedef Documentation}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Drop\+Traced\+Callback@{Drop\+Traced\+Callback}}
\index{Drop\+Traced\+Callback@{Drop\+Traced\+Callback}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Drop\+Traced\+Callback}{DropTracedCallback}}]{\setlength{\rightskip}{0pt plus 5cm}typedef void($\ast$  ns3\+::\+Ipv6\+L3\+Protocol\+::\+Drop\+Traced\+Callback) (const {\bf Ipv6\+Header} \&header, {\bf Ptr}$<$ const {\bf Packet} $>$ packet, {\bf Drop\+Reason} reason, {\bf Ptr}$<$ {\bf Ipv6} $>$ ipv6, uint32\+\_\+t interface)}\hypertarget{classns3_1_1Ipv6L3Protocol_a9b04d0fb9a344dce07430ba7d90f0995}{}\label{classns3_1_1Ipv6L3Protocol_a9b04d0fb9a344dce07430ba7d90f0995}
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback} signature for packet drop events.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em header} & The \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header}. \\
\hline
\mbox{\tt in}  & {\em packet} & The packet. \\
\hline
\mbox{\tt in}  & {\em reason} & The reason the packet was dropped. \\
\hline
\mbox{\tt in}  & {\em ipv6} & \\
\hline
\mbox{\tt in}  & {\em interface} & \\
\hline
\end{DoxyParams}
\begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000012}{Deprecated}]The non-\/const {\ttfamily Ptr$<$\+Ipv6$>$} argument is deprecated and will be changed to {\ttfamily Ptr$<$const Ipv6$>$} in a future release. \end{DoxyRefDesc}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Ipv6\+Autoconfigured\+Prefix\+List@{Ipv6\+Autoconfigured\+Prefix\+List}}
\index{Ipv6\+Autoconfigured\+Prefix\+List@{Ipv6\+Autoconfigured\+Prefix\+List}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Ipv6\+Autoconfigured\+Prefix\+List}{Ipv6AutoconfiguredPrefixList}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<$ {\bf Ptr}$<${\bf Ipv6\+Autoconfigured\+Prefix}$>$ $>$ {\bf ns3\+::\+Ipv6\+L3\+Protocol\+::\+Ipv6\+Autoconfigured\+Prefix\+List}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a9da53420c273775a4a089b4d2273e38f}{}\label{classns3_1_1Ipv6L3Protocol_a9da53420c273775a4a089b4d2273e38f}


Container of the I\+Pv6 Autoconfigured addresses. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Ipv6\+Autoconfigured\+Prefix\+ListI@{Ipv6\+Autoconfigured\+Prefix\+ListI}}
\index{Ipv6\+Autoconfigured\+Prefix\+ListI@{Ipv6\+Autoconfigured\+Prefix\+ListI}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Ipv6\+Autoconfigured\+Prefix\+ListI}{Ipv6AutoconfiguredPrefixListI}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<$ {\bf Ptr}$<${\bf Ipv6\+Autoconfigured\+Prefix}$>$ $>$\+::iterator {\bf ns3\+::\+Ipv6\+L3\+Protocol\+::\+Ipv6\+Autoconfigured\+Prefix\+ListI}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_af00957df9fbda1b1427ad41dd788b99a}{}\label{classns3_1_1Ipv6L3Protocol_af00957df9fbda1b1427ad41dd788b99a}


Iterator of the container of the I\+Pv6 Autoconfigured addresses. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Ipv6\+Interface\+List@{Ipv6\+Interface\+List}}
\index{Ipv6\+Interface\+List@{Ipv6\+Interface\+List}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Ipv6\+Interface\+List}{Ipv6InterfaceList}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::vector$<${\bf Ptr}$<${\bf Ipv6\+Interface}$>$ $>$ {\bf ns3\+::\+Ipv6\+L3\+Protocol\+::\+Ipv6\+Interface\+List}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a3324185c048c5bcd0a4511b8ebf166db}{}\label{classns3_1_1Ipv6L3Protocol_a3324185c048c5bcd0a4511b8ebf166db}


Container of the I\+Pv6 Interfaces. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Ipv6\+Interface\+Reverse\+Container@{Ipv6\+Interface\+Reverse\+Container}}
\index{Ipv6\+Interface\+Reverse\+Container@{Ipv6\+Interface\+Reverse\+Container}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Ipv6\+Interface\+Reverse\+Container}{Ipv6InterfaceReverseContainer}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::map$<${\bf Ptr}$<$const {\bf Net\+Device}$>$, uint32\+\_\+t $>$ {\bf ns3\+::\+Ipv6\+L3\+Protocol\+::\+Ipv6\+Interface\+Reverse\+Container}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a1fb40e4ad1a4612f73c192418df88228}{}\label{classns3_1_1Ipv6L3Protocol_a1fb40e4ad1a4612f73c192418df88228}


Container of Net\+Devices registered to I\+Pv6 and their interface indexes. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Ipv6\+Registered\+Multicast\+Address\+\_\+t@{Ipv6\+Registered\+Multicast\+Address\+\_\+t}}
\index{Ipv6\+Registered\+Multicast\+Address\+\_\+t@{Ipv6\+Registered\+Multicast\+Address\+\_\+t}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Ipv6\+Registered\+Multicast\+Address\+\_\+t}{Ipv6RegisteredMulticastAddress_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::map$<${\bf Ipv6\+Registered\+Multicast\+Address\+Key\+\_\+t}, uint32\+\_\+t$>$ {\bf ns3\+::\+Ipv6\+L3\+Protocol\+::\+Ipv6\+Registered\+Multicast\+Address\+\_\+t}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a42035d08aa8b69e38952370622db7f80}{}\label{classns3_1_1Ipv6L3Protocol_a42035d08aa8b69e38952370622db7f80}


Container of the I\+Pv6 multicast addresses. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Ipv6\+Registered\+Multicast\+Address\+C\+Iter\+\_\+t@{Ipv6\+Registered\+Multicast\+Address\+C\+Iter\+\_\+t}}
\index{Ipv6\+Registered\+Multicast\+Address\+C\+Iter\+\_\+t@{Ipv6\+Registered\+Multicast\+Address\+C\+Iter\+\_\+t}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Ipv6\+Registered\+Multicast\+Address\+C\+Iter\+\_\+t}{Ipv6RegisteredMulticastAddressCIter_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::map$<${\bf Ipv6\+Registered\+Multicast\+Address\+Key\+\_\+t}, uint32\+\_\+t$>$\+::const\+\_\+iterator {\bf ns3\+::\+Ipv6\+L3\+Protocol\+::\+Ipv6\+Registered\+Multicast\+Address\+C\+Iter\+\_\+t}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a656104cdf393b6e6a41c79d172c8e8fb}{}\label{classns3_1_1Ipv6L3Protocol_a656104cdf393b6e6a41c79d172c8e8fb}


Container Const Iterator of the I\+Pv6 multicast addresses. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Ipv6\+Registered\+Multicast\+Address\+Iter\+\_\+t@{Ipv6\+Registered\+Multicast\+Address\+Iter\+\_\+t}}
\index{Ipv6\+Registered\+Multicast\+Address\+Iter\+\_\+t@{Ipv6\+Registered\+Multicast\+Address\+Iter\+\_\+t}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Ipv6\+Registered\+Multicast\+Address\+Iter\+\_\+t}{Ipv6RegisteredMulticastAddressIter_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::map$<${\bf Ipv6\+Registered\+Multicast\+Address\+Key\+\_\+t}, uint32\+\_\+t$>$\+::iterator {\bf ns3\+::\+Ipv6\+L3\+Protocol\+::\+Ipv6\+Registered\+Multicast\+Address\+Iter\+\_\+t}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_aaa04da26fa5428e033aae963d54185fd}{}\label{classns3_1_1Ipv6L3Protocol_aaa04da26fa5428e033aae963d54185fd}


Container Iterator of the I\+Pv6 multicast addresses. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Ipv6\+Registered\+Multicast\+Address\+Key\+\_\+t@{Ipv6\+Registered\+Multicast\+Address\+Key\+\_\+t}}
\index{Ipv6\+Registered\+Multicast\+Address\+Key\+\_\+t@{Ipv6\+Registered\+Multicast\+Address\+Key\+\_\+t}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Ipv6\+Registered\+Multicast\+Address\+Key\+\_\+t}{Ipv6RegisteredMulticastAddressKey_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::pair$<${\bf Ipv6\+Address}, uint64\+\_\+t$>$ {\bf ns3\+::\+Ipv6\+L3\+Protocol\+::\+Ipv6\+Registered\+Multicast\+Address\+Key\+\_\+t}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_ad85035c0604805049efdc7a5b3d99082}{}\label{classns3_1_1Ipv6L3Protocol_ad85035c0604805049efdc7a5b3d99082}


I\+Pv6 multicast addresses / interface key. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Ipv6\+Registered\+Multicast\+Address\+No\+Interface\+\_\+t@{Ipv6\+Registered\+Multicast\+Address\+No\+Interface\+\_\+t}}
\index{Ipv6\+Registered\+Multicast\+Address\+No\+Interface\+\_\+t@{Ipv6\+Registered\+Multicast\+Address\+No\+Interface\+\_\+t}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Ipv6\+Registered\+Multicast\+Address\+No\+Interface\+\_\+t}{Ipv6RegisteredMulticastAddressNoInterface_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::map$<${\bf Ipv6\+Address}, uint32\+\_\+t$>$ {\bf ns3\+::\+Ipv6\+L3\+Protocol\+::\+Ipv6\+Registered\+Multicast\+Address\+No\+Interface\+\_\+t}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a21d330eef03b790c7ff3330abfa738fa}{}\label{classns3_1_1Ipv6L3Protocol_a21d330eef03b790c7ff3330abfa738fa}


Container of the I\+Pv6 multicast addresses. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Ipv6\+Registered\+Multicast\+Address\+No\+Interface\+C\+Iter\+\_\+t@{Ipv6\+Registered\+Multicast\+Address\+No\+Interface\+C\+Iter\+\_\+t}}
\index{Ipv6\+Registered\+Multicast\+Address\+No\+Interface\+C\+Iter\+\_\+t@{Ipv6\+Registered\+Multicast\+Address\+No\+Interface\+C\+Iter\+\_\+t}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Ipv6\+Registered\+Multicast\+Address\+No\+Interface\+C\+Iter\+\_\+t}{Ipv6RegisteredMulticastAddressNoInterfaceCIter_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::map$<${\bf Ipv6\+Address}, uint32\+\_\+t$>$\+::const\+\_\+iterator {\bf ns3\+::\+Ipv6\+L3\+Protocol\+::\+Ipv6\+Registered\+Multicast\+Address\+No\+Interface\+C\+Iter\+\_\+t}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a635e981d0b583b98e00909163710dea9}{}\label{classns3_1_1Ipv6L3Protocol_a635e981d0b583b98e00909163710dea9}


Container Const Iterator of the I\+Pv6 multicast addresses. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Ipv6\+Registered\+Multicast\+Address\+No\+Interface\+Iter\+\_\+t@{Ipv6\+Registered\+Multicast\+Address\+No\+Interface\+Iter\+\_\+t}}
\index{Ipv6\+Registered\+Multicast\+Address\+No\+Interface\+Iter\+\_\+t@{Ipv6\+Registered\+Multicast\+Address\+No\+Interface\+Iter\+\_\+t}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Ipv6\+Registered\+Multicast\+Address\+No\+Interface\+Iter\+\_\+t}{Ipv6RegisteredMulticastAddressNoInterfaceIter_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::map$<${\bf Ipv6\+Address}, uint32\+\_\+t$>$\+::iterator {\bf ns3\+::\+Ipv6\+L3\+Protocol\+::\+Ipv6\+Registered\+Multicast\+Address\+No\+Interface\+Iter\+\_\+t}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_ae91d00bae00de8b86d6bacdf8101864b}{}\label{classns3_1_1Ipv6L3Protocol_ae91d00bae00de8b86d6bacdf8101864b}


Container Iterator of the I\+Pv6 multicast addresses. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!L4\+List\+\_\+t@{L4\+List\+\_\+t}}
\index{L4\+List\+\_\+t@{L4\+List\+\_\+t}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{L4\+List\+\_\+t}{L4List_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::map$<${\bf L4\+List\+Key\+\_\+t}, {\bf Ptr}$<${\bf Ip\+L4\+Protocol}$>$ $>$ {\bf ns3\+::\+Ipv6\+L3\+Protocol\+::\+L4\+List\+\_\+t}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a081eeffb80d91d0702285b6bb5687082}{}\label{classns3_1_1Ipv6L3Protocol_a081eeffb80d91d0702285b6bb5687082}


Container of the I\+Pv6 L4 instances. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!L4\+List\+Key\+\_\+t@{L4\+List\+Key\+\_\+t}}
\index{L4\+List\+Key\+\_\+t@{L4\+List\+Key\+\_\+t}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{L4\+List\+Key\+\_\+t}{L4ListKey_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::pair$<$int, int32\+\_\+t$>$ {\bf ns3\+::\+Ipv6\+L3\+Protocol\+::\+L4\+List\+Key\+\_\+t}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_ade8066a20a3494dbda177322b1d18c21}{}\label{classns3_1_1Ipv6L3Protocol_ade8066a20a3494dbda177322b1d18c21}


Container of the I\+Pv6 L4 keys\+: protocol number, interface index. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Sent\+Traced\+Callback@{Sent\+Traced\+Callback}}
\index{Sent\+Traced\+Callback@{Sent\+Traced\+Callback}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Sent\+Traced\+Callback}{SentTracedCallback}}]{\setlength{\rightskip}{0pt plus 5cm}typedef void($\ast$  ns3\+::\+Ipv6\+L3\+Protocol\+::\+Sent\+Traced\+Callback) (const {\bf Ipv6\+Header} \&header, {\bf Ptr}$<$ const {\bf Packet} $>$ packet, uint32\+\_\+t interface)}\hypertarget{classns3_1_1Ipv6L3Protocol_a15e365bcfa93746691e7acf8a9ef7718}{}\label{classns3_1_1Ipv6L3Protocol_a15e365bcfa93746691e7acf8a9ef7718}
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback} signature for packet sent, forwarded or local-\/delivered events.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em header} & The \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header}. \\
\hline
\mbox{\tt in}  & {\em packet} & The packet. \\
\hline
\mbox{\tt in}  & {\em interface} & \\
\hline
\end{DoxyParams}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Socket\+List@{Socket\+List}}
\index{Socket\+List@{Socket\+List}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Socket\+List}{SocketList}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std\+::list}$<${\bf Ptr}$<${\bf Ipv6\+Raw\+Socket\+Impl}$>$ $>$ {\bf ns3\+::\+Ipv6\+L3\+Protocol\+::\+Socket\+List}\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_ab5dd63c7563ecb5ac6a2b019ad7fa484}{}\label{classns3_1_1Ipv6L3Protocol_ab5dd63c7563ecb5ac6a2b019ad7fa484}


Container of the I\+Pv6 Raw Sockets. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Tx\+Rx\+Traced\+Callback@{Tx\+Rx\+Traced\+Callback}}
\index{Tx\+Rx\+Traced\+Callback@{Tx\+Rx\+Traced\+Callback}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Tx\+Rx\+Traced\+Callback}{TxRxTracedCallback}}]{\setlength{\rightskip}{0pt plus 5cm}typedef void($\ast$  ns3\+::\+Ipv6\+L3\+Protocol\+::\+Tx\+Rx\+Traced\+Callback) ({\bf Ptr}$<$ const {\bf Packet} $>$ packet, {\bf Ptr}$<$ {\bf Ipv6} $>$ ipv6, uint32\+\_\+t interface)}\hypertarget{classns3_1_1Ipv6L3Protocol_a5b967a1009f9c57047f135573fd5519f}{}\label{classns3_1_1Ipv6L3Protocol_a5b967a1009f9c57047f135573fd5519f}
\hyperlink{classns3_1_1TracedCallback}{Traced\+Callback} signature for packet transmission or reception events.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em header} & The \hyperlink{classns3_1_1Ipv6Header}{Ipv6\+Header}. \\
\hline
\mbox{\tt in}  & {\em packet} & The packet. \\
\hline
\mbox{\tt in}  & {\em ipv6} & \\
\hline
\mbox{\tt in}  & {\em interface} & \\
\hline
\end{DoxyParams}
\begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000011}{Deprecated}]The non-\/const {\ttfamily Ptr$<$\+Ipv6$>$} argument is deprecated and will be changed to {\ttfamily Ptr$<$const Ipv6$>$} in a future release. \end{DoxyRefDesc}


\subsection{Member Enumeration Documentation}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Drop\+Reason@{Drop\+Reason}}
\index{Drop\+Reason@{Drop\+Reason}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Drop\+Reason}{DropReason}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf ns3\+::\+Ipv6\+L3\+Protocol\+::\+Drop\+Reason}}\hypertarget{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37a}{}\label{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37a}


Reason why a packet has been dropped. 

\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{D\+R\+O\+P\+\_\+\+T\+T\+L\+\_\+\+E\+X\+P\+I\+R\+ED@{D\+R\+O\+P\+\_\+\+T\+T\+L\+\_\+\+E\+X\+P\+I\+R\+ED}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!D\+R\+O\+P\+\_\+\+T\+T\+L\+\_\+\+E\+X\+P\+I\+R\+ED@{D\+R\+O\+P\+\_\+\+T\+T\+L\+\_\+\+E\+X\+P\+I\+R\+ED}}\item[{\em 
D\+R\+O\+P\+\_\+\+T\+T\+L\+\_\+\+E\+X\+P\+I\+R\+ED\hypertarget{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa49c4e7173190b1bbba7d6300b06a16ed}{}\label{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa49c4e7173190b1bbba7d6300b06a16ed}
}]\hyperlink{classns3_1_1Packet}{Packet} T\+TL has expired \index{D\+R\+O\+P\+\_\+\+N\+O\+\_\+\+R\+O\+U\+TE@{D\+R\+O\+P\+\_\+\+N\+O\+\_\+\+R\+O\+U\+TE}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!D\+R\+O\+P\+\_\+\+N\+O\+\_\+\+R\+O\+U\+TE@{D\+R\+O\+P\+\_\+\+N\+O\+\_\+\+R\+O\+U\+TE}}\item[{\em 
D\+R\+O\+P\+\_\+\+N\+O\+\_\+\+R\+O\+U\+TE\hypertarget{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa97de4f69c19b2f94b684448beee892f4}{}\label{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa97de4f69c19b2f94b684448beee892f4}
}]No route to host \index{D\+R\+O\+P\+\_\+\+I\+N\+T\+E\+R\+F\+A\+C\+E\+\_\+\+D\+O\+WN@{D\+R\+O\+P\+\_\+\+I\+N\+T\+E\+R\+F\+A\+C\+E\+\_\+\+D\+O\+WN}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!D\+R\+O\+P\+\_\+\+I\+N\+T\+E\+R\+F\+A\+C\+E\+\_\+\+D\+O\+WN@{D\+R\+O\+P\+\_\+\+I\+N\+T\+E\+R\+F\+A\+C\+E\+\_\+\+D\+O\+WN}}\item[{\em 
D\+R\+O\+P\+\_\+\+I\+N\+T\+E\+R\+F\+A\+C\+E\+\_\+\+D\+O\+WN\hypertarget{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa72b499545685a47a7cf3588d1330d5d0}{}\label{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa72b499545685a47a7cf3588d1330d5d0}
}]Interface is down so can not send packet \index{D\+R\+O\+P\+\_\+\+R\+O\+U\+T\+E\+\_\+\+E\+R\+R\+OR@{D\+R\+O\+P\+\_\+\+R\+O\+U\+T\+E\+\_\+\+E\+R\+R\+OR}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!D\+R\+O\+P\+\_\+\+R\+O\+U\+T\+E\+\_\+\+E\+R\+R\+OR@{D\+R\+O\+P\+\_\+\+R\+O\+U\+T\+E\+\_\+\+E\+R\+R\+OR}}\item[{\em 
D\+R\+O\+P\+\_\+\+R\+O\+U\+T\+E\+\_\+\+E\+R\+R\+OR\hypertarget{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa3690e9264e4d2307050512b833df4946}{}\label{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa3690e9264e4d2307050512b833df4946}
}]Route error \index{D\+R\+O\+P\+\_\+\+U\+N\+K\+N\+O\+W\+N\+\_\+\+P\+R\+O\+T\+O\+C\+OL@{D\+R\+O\+P\+\_\+\+U\+N\+K\+N\+O\+W\+N\+\_\+\+P\+R\+O\+T\+O\+C\+OL}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!D\+R\+O\+P\+\_\+\+U\+N\+K\+N\+O\+W\+N\+\_\+\+P\+R\+O\+T\+O\+C\+OL@{D\+R\+O\+P\+\_\+\+U\+N\+K\+N\+O\+W\+N\+\_\+\+P\+R\+O\+T\+O\+C\+OL}}\item[{\em 
D\+R\+O\+P\+\_\+\+U\+N\+K\+N\+O\+W\+N\+\_\+\+P\+R\+O\+T\+O\+C\+OL\hypertarget{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aaaf932a981ea33f927add80ea8ed41b05}{}\label{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aaaf932a981ea33f927add80ea8ed41b05}
}]Unknown L4 protocol \index{D\+R\+O\+P\+\_\+\+U\+N\+K\+N\+O\+W\+N\+\_\+\+O\+P\+T\+I\+ON@{D\+R\+O\+P\+\_\+\+U\+N\+K\+N\+O\+W\+N\+\_\+\+O\+P\+T\+I\+ON}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!D\+R\+O\+P\+\_\+\+U\+N\+K\+N\+O\+W\+N\+\_\+\+O\+P\+T\+I\+ON@{D\+R\+O\+P\+\_\+\+U\+N\+K\+N\+O\+W\+N\+\_\+\+O\+P\+T\+I\+ON}}\item[{\em 
D\+R\+O\+P\+\_\+\+U\+N\+K\+N\+O\+W\+N\+\_\+\+O\+P\+T\+I\+ON\hypertarget{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa803fe59e441ce2bc53f0fe19df60c14a}{}\label{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa803fe59e441ce2bc53f0fe19df60c14a}
}]Unknown option \index{D\+R\+O\+P\+\_\+\+M\+A\+L\+F\+O\+R\+M\+E\+D\+\_\+\+H\+E\+A\+D\+ER@{D\+R\+O\+P\+\_\+\+M\+A\+L\+F\+O\+R\+M\+E\+D\+\_\+\+H\+E\+A\+D\+ER}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!D\+R\+O\+P\+\_\+\+M\+A\+L\+F\+O\+R\+M\+E\+D\+\_\+\+H\+E\+A\+D\+ER@{D\+R\+O\+P\+\_\+\+M\+A\+L\+F\+O\+R\+M\+E\+D\+\_\+\+H\+E\+A\+D\+ER}}\item[{\em 
D\+R\+O\+P\+\_\+\+M\+A\+L\+F\+O\+R\+M\+E\+D\+\_\+\+H\+E\+A\+D\+ER\hypertarget{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aaddfae41b279341b99d46df16e0d4ea7b}{}\label{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aaddfae41b279341b99d46df16e0d4ea7b}
}]Malformed header \index{D\+R\+O\+P\+\_\+\+F\+R\+A\+G\+M\+E\+N\+T\+\_\+\+T\+I\+M\+E\+O\+UT@{D\+R\+O\+P\+\_\+\+F\+R\+A\+G\+M\+E\+N\+T\+\_\+\+T\+I\+M\+E\+O\+UT}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!D\+R\+O\+P\+\_\+\+F\+R\+A\+G\+M\+E\+N\+T\+\_\+\+T\+I\+M\+E\+O\+UT@{D\+R\+O\+P\+\_\+\+F\+R\+A\+G\+M\+E\+N\+T\+\_\+\+T\+I\+M\+E\+O\+UT}}\item[{\em 
D\+R\+O\+P\+\_\+\+F\+R\+A\+G\+M\+E\+N\+T\+\_\+\+T\+I\+M\+E\+O\+UT\hypertarget{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa27ee7f562d7201ffd26f3e08bf620d0a}{}\label{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa27ee7f562d7201ffd26f3e08bf620d0a}
}]Fragment timeout \end{description}
\end{Desc}

\begin{DoxyCode}
81   \{
82     \hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa49c4e7173190b1bbba7d6300b06a16ed}{DROP\_TTL\_EXPIRED} = 1, 
83     \hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa97de4f69c19b2f94b684448beee892f4}{DROP\_NO\_ROUTE}, 
84     \hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa72b499545685a47a7cf3588d1330d5d0}{DROP\_INTERFACE\_DOWN}, 
85     \hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa3690e9264e4d2307050512b833df4946}{DROP\_ROUTE\_ERROR}, 
86     \hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aaaf932a981ea33f927add80ea8ed41b05}{DROP\_UNKNOWN\_PROTOCOL}, 
87     \hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa803fe59e441ce2bc53f0fe19df60c14a}{DROP\_UNKNOWN\_OPTION}, 
88     \hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aaddfae41b279341b99d46df16e0d4ea7b}{DROP\_MALFORMED\_HEADER}, 
89     \hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa27ee7f562d7201ffd26f3e08bf620d0a}{DROP\_FRAGMENT\_TIMEOUT}, 
90   \};
\end{DoxyCode}


\subsection{Constructor \& Destructor Documentation}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Ipv6\+L3\+Protocol@{Ipv6\+L3\+Protocol}}
\index{Ipv6\+L3\+Protocol@{Ipv6\+L3\+Protocol}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Ipv6\+L3\+Protocol()}{Ipv6L3Protocol()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv6\+L3\+Protocol\+::\+Ipv6\+L3\+Protocol (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6L3Protocol_aed69fbc6c2eca9a88dfb50f12b419902}{}\label{classns3_1_1Ipv6L3Protocol_aed69fbc6c2eca9a88dfb50f12b419902}


Constructor. 


\begin{DoxyCode}
126   : \hyperlink{classns3_1_1Ipv6L3Protocol_a61c0b45c983a905ebfe4ebce1a90a1d7}{m\_nInterfaces} (0)
127 \{
128   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
129   \hyperlink{classns3_1_1Ipv6L3Protocol_a03a839bfaf9ae8763a58a42e60b08ec5}{m\_pmtuCache} = CreateObject<Ipv6PmtuCache> ();
130 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!````~Ipv6\+L3\+Protocol@{$\sim$\+Ipv6\+L3\+Protocol}}
\index{````~Ipv6\+L3\+Protocol@{$\sim$\+Ipv6\+L3\+Protocol}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{$\sim$\+Ipv6\+L3\+Protocol()}{~Ipv6L3Protocol()}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv6\+L3\+Protocol\+::$\sim$\+Ipv6\+L3\+Protocol (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a169c63b470b2de16ee8c9d5e241488a8}{}\label{classns3_1_1Ipv6L3Protocol_a169c63b470b2de16ee8c9d5e241488a8}


Destructor. 


\begin{DoxyCode}
133 \{
134   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
135 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Ipv6\+L3\+Protocol@{Ipv6\+L3\+Protocol}}
\index{Ipv6\+L3\+Protocol@{Ipv6\+L3\+Protocol}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Ipv6\+L3\+Protocol(const Ipv6\+L3\+Protocol \&)}{Ipv6L3Protocol(const Ipv6L3Protocol &)}}]{\setlength{\rightskip}{0pt plus 5cm}ns3\+::\+Ipv6\+L3\+Protocol\+::\+Ipv6\+L3\+Protocol (
\begin{DoxyParamCaption}
\item[{const {\bf Ipv6\+L3\+Protocol} \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_aa0f0403d05feecc7cac4745a66b0aaad}{}\label{classns3_1_1Ipv6L3Protocol_aa0f0403d05feecc7cac4745a66b0aaad}


Copy constructor. 

Defined but not implemented to avoid misuse 

\subsection{Member Function Documentation}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Add\+Address@{Add\+Address}}
\index{Add\+Address@{Add\+Address}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Add\+Address(uint32\+\_\+t i, Ipv6\+Interface\+Address address)}{AddAddress(uint32_t i, Ipv6InterfaceAddress address)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv6\+L3\+Protocol\+::\+Add\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i, }
\item[{{\bf Ipv6\+Interface\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a33135677dcaa195be223eaf4f38a6efe}{}\label{classns3_1_1Ipv6L3Protocol_a33135677dcaa195be223eaf4f38a6efe}


Add an address on interface. 


\begin{DoxyParams}{Parameters}
{\em i} & interface index \\
\hline
{\em address} & to add \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the operation succeeded 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv6_a5cd576e83cf65445be3a0b5ffd1ddc5c}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
413 \{
414   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} << address);
415   Ptr<Ipv6Interface> \textcolor{keyword}{interface }= GetInterface (i);
416   \textcolor{keywordtype}{bool} ret = interface->AddAddress (address);
417 
418   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6L3Protocol_aa0df547e5240b218dc1f4742a2a00117}{m\_routingProtocol} != 0)
419     \{
420       \hyperlink{classns3_1_1Ipv6L3Protocol_aa0df547e5240b218dc1f4742a2a00117}{m\_routingProtocol}->NotifyAddAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, address);
421     \}
422   \textcolor{keywordflow}{return} ret;
423 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 2


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Add\+Autoconfigured\+Address@{Add\+Autoconfigured\+Address}}
\index{Add\+Autoconfigured\+Address@{Add\+Autoconfigured\+Address}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Add\+Autoconfigured\+Address(uint32\+\_\+t interface, Ipv6\+Address network, Ipv6\+Prefix mask, uint8\+\_\+t flags, uint32\+\_\+t valid\+Time, uint32\+\_\+t preferred\+Time, Ipv6\+Address default\+Router=\+Ipv6\+Address\+::\+Get\+Zero())}{AddAutoconfiguredAddress(uint32_t interface, Ipv6Address network, Ipv6Prefix mask, uint8_t flags, uint32_t validTime, uint32_t preferredTime, Ipv6Address defaultRouter=Ipv6Address::GetZero())}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Add\+Autoconfigured\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv6\+Address}}]{network, }
\item[{{\bf Ipv6\+Prefix}}]{mask, }
\item[{uint8\+\_\+t}]{flags, }
\item[{uint32\+\_\+t}]{valid\+Time, }
\item[{uint32\+\_\+t}]{preferred\+Time, }
\item[{{\bf Ipv6\+Address}}]{default\+Router = {\ttfamily {\bf Ipv6\+Address\+::\+Get\+Zero}~()}}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6L3Protocol_a1806de87b35929a2181c2985e5df1ec0}{}\label{classns3_1_1Ipv6L3Protocol_a1806de87b35929a2181c2985e5df1ec0}


Add an autoconfigured address with RA information. 


\begin{DoxyParams}{Parameters}
{\em interface} & interface index \\
\hline
{\em network} & network prefix \\
\hline
{\em mask} & network mask \\
\hline
{\em flags} & flags of the prefix information option (home agent, ...) \\
\hline
{\em valid\+Time} & valid time of the prefix \\
\hline
{\em preferred\+Time} & preferred time of the prefix \\
\hline
{\em default\+Router} & default router address \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
304 \{
305   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << interface << network << mask << (uint32\_t)flags << validTime << 
      preferredTime);
306   Ipv6InterfaceAddress address;
307 
308   Address addr = \hyperlink{classns3_1_1Ipv6L3Protocol_a2e53b72d76bceb713f2d3cb54e24f5a1}{GetInterface} (interface)->GetDevice ()->GetAddress ();
309 
310   \textcolor{keywordflow}{if} (flags & (1 << 6)) \textcolor{comment}{/* auto flag */}
311     \{
312       \textcolor{comment}{// In case of new MacAddress types, remember to change Ipv6L3Protocol::RemoveAutoconfiguredAddress as
       well}
313       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Mac64Address_a50014d1350f72b89857f0262be927073}{Mac64Address::IsMatchingType} (addr))
314         \{
315           address = Ipv6InterfaceAddress (\hyperlink{classns3_1_1Ipv6Address_a74e6a79f61e9edd0ebdbafb4db88dc35}{Ipv6Address::MakeAutoconfiguredAddress}
       (\hyperlink{classns3_1_1Mac64Address_a9d73aef28cf6b6edf423b418ce014b10}{Mac64Address::ConvertFrom} (addr), network));
316         \}
317       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Mac48Address_a55cc1e3c6aa63fd1a4f8f7d9be4ae182}{Mac48Address::IsMatchingType} (addr))
318         \{
319           address = Ipv6InterfaceAddress (\hyperlink{classns3_1_1Ipv6Address_a74e6a79f61e9edd0ebdbafb4db88dc35}{Ipv6Address::MakeAutoconfiguredAddress}
       (\hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (addr), network));
320         \}
321       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Mac16Address_a2d7aa9e24afc8e02a25ab449b0b99b1f}{Mac16Address::IsMatchingType} (addr))
322         \{
323           address = Ipv6InterfaceAddress (\hyperlink{classns3_1_1Ipv6Address_a74e6a79f61e9edd0ebdbafb4db88dc35}{Ipv6Address::MakeAutoconfiguredAddress}
       (\hyperlink{classns3_1_1Mac16Address_a6822cde696a7be24782dc8e1de2f1449}{Mac16Address::ConvertFrom} (addr), network));
324         \}
325       \textcolor{keywordflow}{else}
326         \{
327           \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Unknown method to make autoconfigured address for this kind of
       device."});
328           \textcolor{keywordflow}{return};
329         \}
330 
331       \textcolor{comment}{/* see if we have already the prefix */}
332       \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv6L3Protocol_af00957df9fbda1b1427ad41dd788b99a}{Ipv6AutoconfiguredPrefixListI} it = 
      \hyperlink{classns3_1_1Ipv6L3Protocol_a402d76e60e8ac25eeb200d2b288732c0}{m\_prefixes}.begin (); it != \hyperlink{classns3_1_1Ipv6L3Protocol_a402d76e60e8ac25eeb200d2b288732c0}{m\_prefixes}.end (); ++it)
333         \{
334           \textcolor{keywordflow}{if} ((*it)->GetInterface () == \textcolor{keyword}{interface }&& (*it)->GetPrefix () == network && (*it)->GetMask () ==
       mask)
335             \{
336               (*it)->StopPreferredTimer ();
337               (*it)->StopValidTimer ();
338               (*it)->StartPreferredTimer ();
339               \textcolor{keywordflow}{return};
340             \}
341         \}
342 
343       \textcolor{comment}{/* no prefix found, add autoconfigured address and the prefix */}
344       \hyperlink{group__logging_gafbd73ee2cf9f26b319f49086d8e860fb}{NS\_LOG\_INFO} (\textcolor{stringliteral}{"Autoconfigured address is :"} << address.GetAddress ());
345       \hyperlink{classns3_1_1Ipv6L3Protocol_a33135677dcaa195be223eaf4f38a6efe}{AddAddress} (interface, address);
346 
347       \textcolor{comment}{/* add default router}
348 \textcolor{comment}{       * if a previous default route exists, the new ones is simply added}
349 \textcolor{comment}{       */}
350       \textcolor{keywordflow}{if} (!defaultRouter.IsAny())
351         \{
352           \hyperlink{classns3_1_1Ipv6L3Protocol_aea90446045bb78b99b150ef1dd9afdb4}{GetRoutingProtocol} ()->NotifyAddRoute (
      \hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} (), Ipv6Prefix ((uint8\_t)0), defaultRouter, interface, network);
353         \}
354 
355       Ptr<Ipv6AutoconfiguredPrefix> aPrefix = CreateObject<Ipv6AutoconfiguredPrefix> (
      \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}, interface, network, mask, preferredTime, validTime, defaultRouter);
356       aPrefix->StartPreferredTimer ();
357 
358       \hyperlink{classns3_1_1Ipv6L3Protocol_a402d76e60e8ac25eeb200d2b288732c0}{m\_prefixes}.push\_back (aPrefix);
359     \}
360 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 3


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Add\+Interface@{Add\+Interface}}
\index{Add\+Interface@{Add\+Interface}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Add\+Interface(\+Ptr$<$ Net\+Device $>$ device)}{AddInterface(Ptr< NetDevice > device)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Ipv6\+L3\+Protocol\+::\+Add\+Interface (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{device}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a56047c2ee7db15185af07538c609cbb5}{}\label{classns3_1_1Ipv6L3Protocol_a56047c2ee7db15185af07538c609cbb5}


Add I\+Pv6 interface for a device. 


\begin{DoxyParams}{Parameters}
{\em device} & net device \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
interface index 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv6_a4fd7da82c16b8abf9ca15f982918e6a4}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
192 \{
193   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << device);
194   Ptr<Ipv6Interface> \textcolor{keyword}{interface }= \hyperlink{group__object_gad1d36559be10afa72c3656fd8598c1e2}{CreateObject}<Ipv6Interface> ();
195 
196   Ptr<TrafficControlLayer> tc = \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<TrafficControlLayer> ();
197 
198   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (tc != 0);
199 
200   \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->\hyperlink{classns3_1_1Node_af713f0e7ea5c49b4fa0b3613405c45fa}{RegisterProtocolHandler} (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1TrafficControlLayer_ac8d6ccbab480b6b288aa155b8485e178}{TrafficControlLayer::Receive}, tc),
201                                    \hyperlink{classns3_1_1Ipv6L3Protocol_ac44af6866e3ddd3f0cb9fbe228afdfe9}{Ipv6L3Protocol::PROT\_NUMBER}, device);
202 
203   tc->RegisterProtocolHandler (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1Ipv6L3Protocol_a8a95d576e8aee9a571db93bf686d850a}{Ipv6L3Protocol::Receive}, \textcolor{keyword}{this}),
204                                \hyperlink{classns3_1_1Ipv6L3Protocol_ac44af6866e3ddd3f0cb9fbe228afdfe9}{Ipv6L3Protocol::PROT\_NUMBER}, device);
205 
206   interface->SetNode (\hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node});
207   interface->SetDevice (device);
208   interface->SetTrafficControl (tc);
209   interface->SetForwarding (\hyperlink{classns3_1_1Ipv6L3Protocol_a3dbdeac3cc4ec17f5a6ab9475fc8e7a8}{m\_ipForward});
210   tc->SetupDevice (device);
211   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv6L3Protocol_aa0c786fd0209504c82b7278297a62f99}{AddIpv6Interface} (interface);
212 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 4


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Add\+Ipv6\+Interface@{Add\+Ipv6\+Interface}}
\index{Add\+Ipv6\+Interface@{Add\+Ipv6\+Interface}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Add\+Ipv6\+Interface(\+Ptr$<$ Ipv6\+Interface $>$ interface)}{AddIpv6Interface(Ptr< Ipv6Interface > interface)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Ipv6\+L3\+Protocol\+::\+Add\+Ipv6\+Interface (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv6\+Interface} $>$}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_aa0c786fd0209504c82b7278297a62f99}{}\label{classns3_1_1Ipv6L3Protocol_aa0c786fd0209504c82b7278297a62f99}


Add an I\+Pv6 interface to the stack. 


\begin{DoxyParams}{Parameters}
{\em interface} & interface to add \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
index of newly added interface 
\end{DoxyReturn}

\begin{DoxyCode}
215 \{
216   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << interface);
217   uint32\_t index = \hyperlink{classns3_1_1Ipv6L3Protocol_a61c0b45c983a905ebfe4ebce1a90a1d7}{m\_nInterfaces};
218 
219   \hyperlink{classns3_1_1Ipv6L3Protocol_a425d8738fd30fbc9345d57cfddd0d6d0}{m\_interfaces}.push\_back (interface);
220   \hyperlink{classns3_1_1Ipv6L3Protocol_aba2395fbe747b5c8d0f46d65556eea0c}{m\_reverseInterfacesContainer}[interface->GetDevice ()] = index;
221   \hyperlink{classns3_1_1Ipv6L3Protocol_a61c0b45c983a905ebfe4ebce1a90a1d7}{m\_nInterfaces}++;
222   \textcolor{keywordflow}{return} index;
223 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 5


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Add\+Multicast\+Address@{Add\+Multicast\+Address}}
\index{Add\+Multicast\+Address@{Add\+Multicast\+Address}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Add\+Multicast\+Address(\+Ipv6\+Address address)}{AddMulticastAddress(Ipv6Address address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Add\+Multicast\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{address}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6L3Protocol_a63db5954bff57ed45b1a6f1847949e11}{}\label{classns3_1_1Ipv6L3Protocol_a63db5954bff57ed45b1a6f1847949e11}
Adds a multicast address to the list of addresses to pass to local deliver. 
\begin{DoxyParams}{Parameters}
{\em address} & the address. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1554 \{
1555   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (address);
1556 
1557   \textcolor{keywordflow}{if} (!address.IsMulticast ())
1558     \{
1559       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Not adding a non-multicast address "} << address);
1560       \textcolor{keywordflow}{return};
1561     \}
1562 
1563   \hyperlink{classns3_1_1Ipv6L3Protocol_a4b31a418ae742bed8835981afb433b1c}{m\_multicastAddressesNoInterface}[address]++;
1564 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 6


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Add\+Multicast\+Address@{Add\+Multicast\+Address}}
\index{Add\+Multicast\+Address@{Add\+Multicast\+Address}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Add\+Multicast\+Address(\+Ipv6\+Address address, uint32\+\_\+t interface)}{AddMulticastAddress(Ipv6Address address, uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Add\+Multicast\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{address, }
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6L3Protocol_aa1b596016a4983592469afcbcbc3be24}{}\label{classns3_1_1Ipv6L3Protocol_aa1b596016a4983592469afcbcbc3be24}
Adds a multicast address to the list of addresses to pass to local deliver. 
\begin{DoxyParams}{Parameters}
{\em address} & the address. \\
\hline
{\em interface} & the incoming interface. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1540 \{
1541   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (address << interface);
1542 
1543   \textcolor{keywordflow}{if} (!address.IsMulticast ())
1544     \{
1545       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Not adding a non-multicast address "} << address);
1546       \textcolor{keywordflow}{return};
1547     \}
1548 
1549   \hyperlink{classns3_1_1Ipv6L3Protocol_ad85035c0604805049efdc7a5b3d99082}{Ipv6RegisteredMulticastAddressKey\_t} key = std::make\_pair (address, 
      interface);
1550   \hyperlink{classns3_1_1Ipv6L3Protocol_a6d7573453cf2a73d44bfb2d68eed19c4}{m\_multicastAddresses}[key]++;
1551 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 7


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Build\+Header@{Build\+Header}}
\index{Build\+Header@{Build\+Header}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Build\+Header(\+Ipv6\+Address src, Ipv6\+Address dst, uint8\+\_\+t protocol, uint16\+\_\+t payload\+Size, uint8\+\_\+t hop\+Limit, uint8\+\_\+t tclass)}{BuildHeader(Ipv6Address src, Ipv6Address dst, uint8_t protocol, uint16_t payloadSize, uint8_t hopLimit, uint8_t tclass)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+Header} ns3\+::\+Ipv6\+L3\+Protocol\+::\+Build\+Header (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{src, }
\item[{{\bf Ipv6\+Address}}]{dst, }
\item[{uint8\+\_\+t}]{protocol, }
\item[{uint16\+\_\+t}]{payload\+Size, }
\item[{uint8\+\_\+t}]{hop\+Limit, }
\item[{uint8\+\_\+t}]{tclass}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a5374a6687ad09cfcd48ef13a99b48d16}{}\label{classns3_1_1Ipv6L3Protocol_a5374a6687ad09cfcd48ef13a99b48d16}


Construct an I\+Pv6 header. 


\begin{DoxyParams}{Parameters}
{\em src} & source I\+Pv6 address \\
\hline
{\em dst} & destination I\+Pv6 address \\
\hline
{\em protocol} & L4 protocol \\
\hline
{\em payload\+Size} & payload size \\
\hline
{\em hop\+Limit} & Hop limit \\
\hline
{\em tclass} & Tclass \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
newly created I\+Pv6 header 
\end{DoxyReturn}

\begin{DoxyCode}
1466 \{
1467   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << src << dst << (uint32\_t)protocol << (uint32\_t)payloadSize << (
      uint32\_t)ttl << (uint32\_t)tclass);
1468   Ipv6Header hdr;
1469 
1470   hdr.SetSourceAddress (src);
1471   hdr.SetDestinationAddress (dst);
1472   hdr.SetNextHeader (protocol);
1473   hdr.SetPayloadLength (payloadSize);
1474   hdr.SetHopLimit (ttl);
1475   hdr.SetTrafficClass (tclass);
1476   \textcolor{keywordflow}{return} hdr;
1477 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 8




Here is the caller graph for this function\+:
% FIG 9


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Call\+Tx\+Trace@{Call\+Tx\+Trace}}
\index{Call\+Tx\+Trace@{Call\+Tx\+Trace}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Call\+Tx\+Trace(const Ipv6\+Header \&ip\+Header, Ptr$<$ Packet $>$ packet, Ptr$<$ Ipv6 $>$ ipv6, uint32\+\_\+t interface)}{CallTxTrace(const Ipv6Header &ipHeader, Ptr< Packet > packet, Ptr< Ipv6 > ipv6, uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Call\+Tx\+Trace (
\begin{DoxyParamCaption}
\item[{const {\bf Ipv6\+Header} \&}]{ip\+Header, }
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Ptr}$<$ {\bf Ipv6} $>$}]{ipv6, }
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a40e29e34a97639ad1caad6b64e732454}{}\label{classns3_1_1Ipv6L3Protocol_a40e29e34a97639ad1caad6b64e732454}


Make a copy of the packet, add the header and invoke the TX trace callback. 


\begin{DoxyParams}{Parameters}
{\em ip\+Header} & the IP header that will be added to the packet \\
\hline
{\em packet} & the packet \\
\hline
{\em ipv6} & the \hyperlink{classns3_1_1Ipv6}{Ipv6} protocol \\
\hline
{\em interface} & the interface index\\
\hline
\end{DoxyParams}
Note\+: If the \hyperlink{classns3_1_1TracedCallback}{Traced\+Callback} A\+PI ever is extended, we could consider to check for connected functions before adding the header 
\begin{DoxyCode}
1096 \{
1097   Ptr<Packet> packetCopy = packet->\hyperlink{classns3_1_1Packet_a5d5c70802a5f77fc5f0001e0cfc1898b}{Copy} ();
1098   packetCopy->\hyperlink{classns3_1_1Packet_a465108c595a0bc592095cbcab1832ed8}{AddHeader} (ipHeader);
1099   \hyperlink{classns3_1_1Ipv6L3Protocol_a2037be8528273f3495216a09384e38e7}{m\_txTrace} (packetCopy, ipv6, interface);
1100 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 10




Here is the caller graph for this function\+:
% FIG 11


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Create\+Raw\+Socket@{Create\+Raw\+Socket}}
\index{Create\+Raw\+Socket@{Create\+Raw\+Socket}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Create\+Raw\+Socket()}{CreateRawSocket()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Socket} $>$ ns3\+::\+Ipv6\+L3\+Protocol\+::\+Create\+Raw\+Socket (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6L3Protocol_a6aa13fd7fb8a9afa3c017ff15799fd23}{}\label{classns3_1_1Ipv6L3Protocol_a6aa13fd7fb8a9afa3c017ff15799fd23}


Create raw I\+Pv6 socket. 

\begin{DoxyReturn}{Returns}
newly raw socket 
\end{DoxyReturn}

\begin{DoxyCode}
807 \{
808   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
809   Ptr<Ipv6RawSocketImpl> sock = CreateObject<Ipv6RawSocketImpl> ();
810   sock->SetNode (\hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node});
811   \hyperlink{classns3_1_1Ipv6L3Protocol_a515e9cba13d7fd95e5613f5c95ccc7b5}{m\_sockets}.push\_back (sock);
812   \textcolor{keywordflow}{return} sock;
813 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Delete\+Raw\+Socket@{Delete\+Raw\+Socket}}
\index{Delete\+Raw\+Socket@{Delete\+Raw\+Socket}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Delete\+Raw\+Socket(\+Ptr$<$ Socket $>$ socket)}{DeleteRawSocket(Ptr< Socket > socket)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Delete\+Raw\+Socket (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Socket} $>$}]{socket}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6L3Protocol_ab490d143f904a9899e3dd21ac8942016}{}\label{classns3_1_1Ipv6L3Protocol_ab490d143f904a9899e3dd21ac8942016}


Remove raw I\+Pv6 socket. 


\begin{DoxyParams}{Parameters}
{\em socket} & socket to remove \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
816 \{
817   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << socket);
818 
819   \textcolor{keywordflow}{for} (SocketList::iterator it = \hyperlink{classns3_1_1Ipv6L3Protocol_a515e9cba13d7fd95e5613f5c95ccc7b5}{m\_sockets}.begin (); it != \hyperlink{classns3_1_1Ipv6L3Protocol_a515e9cba13d7fd95e5613f5c95ccc7b5}{m\_sockets}.end (); ++it)
820     \{
821       \textcolor{keywordflow}{if} ((*it) == socket)
822         \{
823           \hyperlink{classns3_1_1Ipv6L3Protocol_a515e9cba13d7fd95e5613f5c95ccc7b5}{m\_sockets}.erase (it);
824           \textcolor{keywordflow}{return};
825         \}
826     \}
827 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Do\+Dispose@{Do\+Dispose}}
\index{Do\+Dispose@{Do\+Dispose}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Do\+Dispose()}{DoDispose()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Do\+Dispose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_ae5d9eccbe1a381fa00d38400989551e4}{}\label{classns3_1_1Ipv6L3Protocol_ae5d9eccbe1a381fa00d38400989551e4}


Dispose object. 



Reimplemented from \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{ns3\+::\+Object}.


\begin{DoxyCode}
138 \{
139   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
140 
141   \textcolor{comment}{/* clear protocol and interface list */}
142   \textcolor{keywordflow}{for} (L4List\_t::iterator it = \hyperlink{classns3_1_1Ipv6L3Protocol_a5a68c54b92d81f93c41983ebdc0ef5b3}{m\_protocols}.begin (); it != 
      \hyperlink{classns3_1_1Ipv6L3Protocol_a5a68c54b92d81f93c41983ebdc0ef5b3}{m\_protocols}.end (); ++it)
143     \{
144       it->second = 0;
145     \}
146   \hyperlink{classns3_1_1Ipv6L3Protocol_a5a68c54b92d81f93c41983ebdc0ef5b3}{m\_protocols}.clear ();
147 
148   \textcolor{comment}{/* remove interfaces */}
149   \textcolor{keywordflow}{for} (Ipv6InterfaceList::iterator it = \hyperlink{classns3_1_1Ipv6L3Protocol_a425d8738fd30fbc9345d57cfddd0d6d0}{m\_interfaces}.begin (); it != 
      \hyperlink{classns3_1_1Ipv6L3Protocol_a425d8738fd30fbc9345d57cfddd0d6d0}{m\_interfaces}.end (); ++it)
150     \{
151       *it = 0;
152     \}
153   \hyperlink{classns3_1_1Ipv6L3Protocol_a425d8738fd30fbc9345d57cfddd0d6d0}{m\_interfaces}.clear ();
154   \hyperlink{classns3_1_1Ipv6L3Protocol_aba2395fbe747b5c8d0f46d65556eea0c}{m\_reverseInterfacesContainer}.clear ();
155 
156   \textcolor{comment}{/* remove raw sockets */}
157   \textcolor{keywordflow}{for} (SocketList::iterator it = \hyperlink{classns3_1_1Ipv6L3Protocol_a515e9cba13d7fd95e5613f5c95ccc7b5}{m\_sockets}.begin (); it != \hyperlink{classns3_1_1Ipv6L3Protocol_a515e9cba13d7fd95e5613f5c95ccc7b5}{m\_sockets}.end (); ++it)
158     \{
159       *it = 0;
160     \}
161   \hyperlink{classns3_1_1Ipv6L3Protocol_a515e9cba13d7fd95e5613f5c95ccc7b5}{m\_sockets}.clear ();
162 
163   \textcolor{comment}{/* remove list of prefix */}
164   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv6L3Protocol_af00957df9fbda1b1427ad41dd788b99a}{Ipv6AutoconfiguredPrefixListI} it = 
      \hyperlink{classns3_1_1Ipv6L3Protocol_a402d76e60e8ac25eeb200d2b288732c0}{m\_prefixes}.begin (); it != \hyperlink{classns3_1_1Ipv6L3Protocol_a402d76e60e8ac25eeb200d2b288732c0}{m\_prefixes}.end (); ++it)
165     \{
166       (*it)->StopValidTimer ();
167       (*it)->StopPreferredTimer ();
168       (*it) = 0;
169     \}
170   \hyperlink{classns3_1_1Ipv6L3Protocol_a402d76e60e8ac25eeb200d2b288732c0}{m\_prefixes}.clear ();
171 
172   \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node} = 0;
173   \hyperlink{classns3_1_1Ipv6L3Protocol_aa0df547e5240b218dc1f4742a2a00117}{m\_routingProtocol} = 0;
174   \hyperlink{classns3_1_1Ipv6L3Protocol_a03a839bfaf9ae8763a58a42e60b08ec5}{m\_pmtuCache} = 0;
175   \hyperlink{classns3_1_1Object_a475d429a75d302d4775f4ae32479b287}{Object::DoDispose} ();
176 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 12


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Get\+Address@{Get\+Address}}
\index{Get\+Address@{Get\+Address}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Address(uint32\+\_\+t interface\+Index, uint32\+\_\+t address\+Index) const }{GetAddress(uint32_t interfaceIndex, uint32_t addressIndex) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+Interface\+Address} ns3\+::\+Ipv6\+L3\+Protocol\+::\+Get\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface\+Index, }
\item[{uint32\+\_\+t}]{address\+Index}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a0321a9ac3f79b5a7b7542cecf11bfe44}{}\label{classns3_1_1Ipv6L3Protocol_a0321a9ac3f79b5a7b7542cecf11bfe44}


Get an address. 


\begin{DoxyParams}{Parameters}
{\em interface\+Index} & interface index \\
\hline
{\em address\+Index} & address index on the interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{classns3_1_1Ipv6InterfaceAddress}{Ipv6\+Interface\+Address} or assert if not found 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv6_a00f1aa203323d9afa48d58af8af0e73b}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
433 \{
434   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} << addressIndex);
435   Ptr<Ipv6Interface> \textcolor{keyword}{interface }= GetInterface (i);
436   \textcolor{keywordflow}{return} interface->GetAddress (addressIndex);
437 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 13


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Get\+Icmpv6@{Get\+Icmpv6}}
\index{Get\+Icmpv6@{Get\+Icmpv6}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Icmpv6() const }{GetIcmpv6() const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Icmpv6\+L4\+Protocol} $>$ ns3\+::\+Ipv6\+L3\+Protocol\+::\+Get\+Icmpv6 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv6L3Protocol_a10384a4dc85c61e65cf73b47ec9da90d}{}\label{classns3_1_1Ipv6L3Protocol_a10384a4dc85c61e65cf73b47ec9da90d}


Get I\+C\+M\+Pv6 protocol. 

\begin{DoxyReturn}{Returns}
\hyperlink{classns3_1_1Icmpv6L4Protocol}{Icmpv6\+L4\+Protocol} pointer 
\end{DoxyReturn}

\begin{DoxyCode}
830 \{
831   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
832   Ptr<IpL4Protocol> protocol = \hyperlink{classns3_1_1Ipv6L3Protocol_acb189bb5deceb95e78f2a443609c8d64}{GetProtocol} (
      \hyperlink{classns3_1_1Icmpv6L4Protocol_af845269e6c3f4509a4e287195c965afc}{Icmpv6L4Protocol::GetStaticProtocolNumber} ());
833 
834   \textcolor{keywordflow}{if} (protocol)
835     \{
836       \textcolor{keywordflow}{return} protocol->GetObject<Icmpv6L4Protocol> ();
837     \}
838   \textcolor{keywordflow}{else}
839     \{
840       \textcolor{keywordflow}{return} 0;
841     \}
842 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 14




Here is the caller graph for this function\+:
% FIG 15


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Get\+Interface@{Get\+Interface}}
\index{Get\+Interface@{Get\+Interface}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Interface(uint32\+\_\+t i) const }{GetInterface(uint32_t i) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv6\+Interface} $>$ ns3\+::\+Ipv6\+L3\+Protocol\+::\+Get\+Interface (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv6L3Protocol_a2e53b72d76bceb713f2d3cb54e24f5a1}{}\label{classns3_1_1Ipv6L3Protocol_a2e53b72d76bceb713f2d3cb54e24f5a1}


Get an interface. 


\begin{DoxyParams}{Parameters}
{\em i} & interface index \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
I\+Pv6 interface pointer 
\end{DoxyReturn}

\begin{DoxyCode}
226 \{
227   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << index);
228 
229   \textcolor{keywordflow}{if} (index < \hyperlink{classns3_1_1Ipv6L3Protocol_a425d8738fd30fbc9345d57cfddd0d6d0}{m\_interfaces}.size ())
230     \{
231       \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv6L3Protocol_a425d8738fd30fbc9345d57cfddd0d6d0}{m\_interfaces}[index];
232     \}
233   \textcolor{keywordflow}{return} 0;
234 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 16


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Get\+Interface\+For\+Address@{Get\+Interface\+For\+Address}}
\index{Get\+Interface\+For\+Address@{Get\+Interface\+For\+Address}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Interface\+For\+Address(\+Ipv6\+Address addr) const }{GetInterfaceForAddress(Ipv6Address addr) const }}]{\setlength{\rightskip}{0pt plus 5cm}int32\+\_\+t ns3\+::\+Ipv6\+L3\+Protocol\+::\+Get\+Interface\+For\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{addr}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_ae8d652431e374e8b05425ae9e1bf0f1b}{}\label{classns3_1_1Ipv6L3Protocol_ae8d652431e374e8b05425ae9e1bf0f1b}


Get interface index which has specified I\+Pv6 address. 


\begin{DoxyParams}{Parameters}
{\em addr} & I\+Pv6 address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
interface index or -\/1 if not found 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv6_aa8003b6741a18e196d7cb8369e2ef80f}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
243 \{
244   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << address);
245   int32\_t index = 0;
246 
247   \textcolor{keywordflow}{for} (Ipv6InterfaceList::const\_iterator it = \hyperlink{classns3_1_1Ipv6L3Protocol_a425d8738fd30fbc9345d57cfddd0d6d0}{m\_interfaces}.begin (); it != 
      \hyperlink{classns3_1_1Ipv6L3Protocol_a425d8738fd30fbc9345d57cfddd0d6d0}{m\_interfaces}.end (); it++)
248     \{
249       uint32\_t j = 0;
250       uint32\_t \hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{max} = (*it)->GetNAddresses ();
251 
252       \textcolor{keywordflow}{for} (j = 0; j < \hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{max}; j++)
253         \{
254           \textcolor{keywordflow}{if} ((*it)->GetAddress (j).GetAddress () == address)
255             \{
256               \textcolor{keywordflow}{return} index;
257             \}
258         \}
259       index++;
260     \}
261   \textcolor{keywordflow}{return} -1;
262 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 17


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Get\+Interface\+For\+Device@{Get\+Interface\+For\+Device}}
\index{Get\+Interface\+For\+Device@{Get\+Interface\+For\+Device}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Interface\+For\+Device(\+Ptr$<$ const Net\+Device $>$ device) const }{GetInterfaceForDevice(Ptr< const NetDevice > device) const }}]{\setlength{\rightskip}{0pt plus 5cm}int32\+\_\+t ns3\+::\+Ipv6\+L3\+Protocol\+::\+Get\+Interface\+For\+Device (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Net\+Device} $>$}]{device}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a878292513d6294e2dfdeccbe1ed1d996}{}\label{classns3_1_1Ipv6L3Protocol_a878292513d6294e2dfdeccbe1ed1d996}


Get interface index which is on a specified net device. 


\begin{DoxyParams}{Parameters}
{\em device} & net device \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the interface index 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv6_a3337dc6ce66612b0fa9b57f7f0338745}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
291 \{
292   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << device);
293 
294   Ipv6InterfaceReverseContainer::const\_iterator iter = 
      \hyperlink{classns3_1_1Ipv6L3Protocol_aba2395fbe747b5c8d0f46d65556eea0c}{m\_reverseInterfacesContainer}.find (device);
295   \textcolor{keywordflow}{if} (iter != \hyperlink{classns3_1_1Ipv6L3Protocol_aba2395fbe747b5c8d0f46d65556eea0c}{m\_reverseInterfacesContainer}.end ())
296     \{
297       \textcolor{keywordflow}{return} (*iter).second;
298     \}
299 
300   \textcolor{keywordflow}{return} -1;
301 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 18


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Get\+Interface\+For\+Prefix@{Get\+Interface\+For\+Prefix}}
\index{Get\+Interface\+For\+Prefix@{Get\+Interface\+For\+Prefix}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Interface\+For\+Prefix(\+Ipv6\+Address addr, Ipv6\+Prefix mask) const }{GetInterfaceForPrefix(Ipv6Address addr, Ipv6Prefix mask) const }}]{\setlength{\rightskip}{0pt plus 5cm}int32\+\_\+t ns3\+::\+Ipv6\+L3\+Protocol\+::\+Get\+Interface\+For\+Prefix (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{addr, }
\item[{{\bf Ipv6\+Prefix}}]{mask}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_ad6454a2718ec03a97ff11a29bc015ef2}{}\label{classns3_1_1Ipv6L3Protocol_ad6454a2718ec03a97ff11a29bc015ef2}


Get interface index which match specified address/prefix. 


\begin{DoxyParams}{Parameters}
{\em addr} & I\+Pv6 address \\
\hline
{\em mask} & I\+Pv6 prefix (mask) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
interface index or -\/1 if not found 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv6_a5f3369dd6c6b2e40aae5af0eed096f48}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
265 \{
266   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << address << mask);
267   int32\_t index = 0;
268 
269   \textcolor{keywordflow}{for} (Ipv6InterfaceList::const\_iterator it = \hyperlink{classns3_1_1Ipv6L3Protocol_a425d8738fd30fbc9345d57cfddd0d6d0}{m\_interfaces}.begin (); it != 
      \hyperlink{classns3_1_1Ipv6L3Protocol_a425d8738fd30fbc9345d57cfddd0d6d0}{m\_interfaces}.end (); it++)
270     \{
271       uint32\_t j = 0;
272       \textcolor{keywordflow}{for} (j = 0; j < (*it)->GetNAddresses (); j++)
273         \{
274           \textcolor{keywordflow}{if} ((*it)->GetAddress (j).GetAddress ().CombinePrefix (mask) == address.CombinePrefix (mask))
275             \{
276               \textcolor{keywordflow}{return} index;
277             \}
278         \}
279       index++;
280     \}
281   \textcolor{keywordflow}{return} -1;
282 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 19


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Get\+Ip\+Forward@{Get\+Ip\+Forward}}
\index{Get\+Ip\+Forward@{Get\+Ip\+Forward}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Ip\+Forward() const }{GetIpForward() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv6\+L3\+Protocol\+::\+Get\+Ip\+Forward (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a5ea6340dc5eef31896c71201dd789d49}{}\label{classns3_1_1Ipv6L3Protocol_a5ea6340dc5eef31896c71201dd789d49}


Get I\+Pv6 forwarding state. 

\begin{DoxyReturn}{Returns}
forwarding state (enabled or not) 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv6_a26466999fd77426c00a4afd8b9a1ba32}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
663 \{
664   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
665   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv6L3Protocol_a3dbdeac3cc4ec17f5a6ab9475fc8e7a8}{m\_ipForward};
666 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Get\+Metric@{Get\+Metric}}
\index{Get\+Metric@{Get\+Metric}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Metric(uint32\+\_\+t i) const }{GetMetric(uint32_t i) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Ipv6\+L3\+Protocol\+::\+Get\+Metric (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_ad8b41a67f3f99823d6d5e0a5441970de}{}\label{classns3_1_1Ipv6L3Protocol_ad8b41a67f3f99823d6d5e0a5441970de}


Get metric for an interface. 


\begin{DoxyParams}{Parameters}
{\em i} & index \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
metric 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv6_a6bae4637f2a7f1e566a53c3270b891d4}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
487 \{
488   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
489   Ptr<Ipv6Interface> \textcolor{keyword}{interface }= GetInterface (i);
490   \textcolor{keywordflow}{return} interface->GetMetric ();
491 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Get\+Mtu@{Get\+Mtu}}
\index{Get\+Mtu@{Get\+Mtu}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Mtu(uint32\+\_\+t i) const }{GetMtu(uint32_t i) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t ns3\+::\+Ipv6\+L3\+Protocol\+::\+Get\+Mtu (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a33cfa3ccae2ee968d581fc689c73beb5}{}\label{classns3_1_1Ipv6L3Protocol_a33cfa3ccae2ee968d581fc689c73beb5}


Get M\+TU for an interface. 


\begin{DoxyParams}{Parameters}
{\em i} & index \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
M\+TU 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv6_a2eb71c704b0ed9f92161a988b644600d}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
494 \{
495   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
496 
497   \textcolor{comment}{// RFC 1981, if PMTU is disabled, return the minimum MTU}
498   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1Ipv6L3Protocol_a7b38ce20301ab4b5db712d45536d6e19}{m\_mtuDiscover})
499     \{
500       \textcolor{keywordflow}{return} \hyperlink{ipv6-l3-protocol_8cc_aa406701b90eb85102aab8f2bacd44c55}{IPV6\_MIN\_MTU};
501     \}
502 
503   Ptr<Ipv6Interface> \textcolor{keyword}{interface }= GetInterface (i);
504   \textcolor{keywordflow}{return} interface->GetDevice ()->GetMtu ();
505 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Get\+Mtu\+Discover@{Get\+Mtu\+Discover}}
\index{Get\+Mtu\+Discover@{Get\+Mtu\+Discover}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Mtu\+Discover(void) const }{GetMtuDiscover(void) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv6\+L3\+Protocol\+::\+Get\+Mtu\+Discover (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a3214a558eb2b6549243f39eb821bd543}{}\label{classns3_1_1Ipv6L3Protocol_a3214a558eb2b6549243f39eb821bd543}


Get I\+Pv6 M\+TU discover state. 

\begin{DoxyReturn}{Returns}
M\+TU discover state (enabled or not) 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv6_a0de538c1b10148675d4d49efa32258f9}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
675 \{
676   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this});
677   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv6L3Protocol_a7b38ce20301ab4b5db712d45536d6e19}{m\_mtuDiscover};
678 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Get\+N\+Addresses@{Get\+N\+Addresses}}
\index{Get\+N\+Addresses@{Get\+N\+Addresses}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+N\+Addresses(uint32\+\_\+t interface) const }{GetNAddresses(uint32_t interface) const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Ipv6\+L3\+Protocol\+::\+Get\+N\+Addresses (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a3b09a9f504a311ecc08fdc026d897514}{}\label{classns3_1_1Ipv6L3Protocol_a3b09a9f504a311ecc08fdc026d897514}


Get number of address for an interface. 


\begin{DoxyParams}{Parameters}
{\em interface} & interface index \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of address 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv6_ac62012f48487d1e957a45f40a9386697}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
426 \{
427   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
428   Ptr<Ipv6Interface> \textcolor{keyword}{interface }= GetInterface (i);
429   \textcolor{keywordflow}{return} interface->GetNAddresses ();
430 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 20


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Get\+Net\+Device@{Get\+Net\+Device}}
\index{Get\+Net\+Device@{Get\+Net\+Device}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Net\+Device(uint32\+\_\+t i)}{GetNetDevice(uint32_t i)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Net\+Device} $>$ ns3\+::\+Ipv6\+L3\+Protocol\+::\+Get\+Net\+Device (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a574d1beafc86062acf582e75dc437a47}{}\label{classns3_1_1Ipv6L3Protocol_a574d1beafc86062acf582e75dc437a47}


Get device by index. 


\begin{DoxyParams}{Parameters}
{\em i} & device index on this stack \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{classns3_1_1NetDevice}{Net\+Device} pointer 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv6_a6e7c9dea7730b4414e543241399faecf}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
285 \{
286   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
287   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv6L3Protocol_a2e53b72d76bceb713f2d3cb54e24f5a1}{GetInterface} (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i})->GetDevice ();
288 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 21




Here is the caller graph for this function\+:
% FIG 22


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Get\+N\+Interfaces@{Get\+N\+Interfaces}}
\index{Get\+N\+Interfaces@{Get\+N\+Interfaces}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+N\+Interfaces() const }{GetNInterfaces() const }}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Ipv6\+L3\+Protocol\+::\+Get\+N\+Interfaces (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a53882c40f6fb32e2a6fe0a7a2858698d}{}\label{classns3_1_1Ipv6L3Protocol_a53882c40f6fb32e2a6fe0a7a2858698d}


Get current number of interface on this stack. 

\begin{DoxyReturn}{Returns}
number of interface registered 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv6_af024eb66563d0958b00ba79ed00b0642}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
237 \{
238   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
239   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv6L3Protocol_a61c0b45c983a905ebfe4ebce1a90a1d7}{m\_nInterfaces};
240 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 23


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Get\+Protocol@{Get\+Protocol}}
\index{Get\+Protocol@{Get\+Protocol}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Protocol(int protocol\+Number) const }{GetProtocol(int protocolNumber) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ip\+L4\+Protocol} $>$ ns3\+::\+Ipv6\+L3\+Protocol\+::\+Get\+Protocol (
\begin{DoxyParamCaption}
\item[{int}]{protocol\+Number}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_acb189bb5deceb95e78f2a443609c8d64}{}\label{classns3_1_1Ipv6L3Protocol_acb189bb5deceb95e78f2a443609c8d64}


Get L4 protocol by protocol number. 


\begin{DoxyParams}{Parameters}
{\em protocol\+Number} & protocol number \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
corresponding \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} or 0 if not found 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv6_aef0e6be6a6def36087298f48e0b235a3}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
773 \{
774   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << protocolNumber);
775 
776   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv6L3Protocol_acb189bb5deceb95e78f2a443609c8d64}{GetProtocol} (protocolNumber, -1);
777 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 24


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Get\+Protocol@{Get\+Protocol}}
\index{Get\+Protocol@{Get\+Protocol}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Protocol(int protocol\+Number, int32\+\_\+t interface\+Index) const }{GetProtocol(int protocolNumber, int32_t interfaceIndex) const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ip\+L4\+Protocol} $>$ ns3\+::\+Ipv6\+L3\+Protocol\+::\+Get\+Protocol (
\begin{DoxyParamCaption}
\item[{int}]{protocol\+Number, }
\item[{int32\+\_\+t}]{interface\+Index}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a8c7d6e8831a6606311f0dd0eab0a3f56}{}\label{classns3_1_1Ipv6L3Protocol_a8c7d6e8831a6606311f0dd0eab0a3f56}


Get L4 protocol by protocol number for the specified interface. 


\begin{DoxyParams}{Parameters}
{\em protocol\+Number} & protocol number \\
\hline
{\em interface\+Index} & interface index, -\/1 means \char`\"{}any\char`\"{} interface. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
corresponding \hyperlink{classns3_1_1IpL4Protocol}{Ip\+L4\+Protocol} or 0 if not found 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv6_a8fa557713b63afce0b11b720d6e639d4}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
780 \{
781   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << protocolNumber << interfaceIndex);
782 
783   \hyperlink{classns3_1_1Ipv6L3Protocol_ade8066a20a3494dbda177322b1d18c21}{L4ListKey\_t} key;
784   L4List\_t::const\_iterator \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i};
785   \textcolor{keywordflow}{if} (interfaceIndex >= 0)
786     \{
787       \textcolor{comment}{// try the interface-specific protocol.}
788       key = std::make\_pair (protocolNumber, interfaceIndex);
789       i = \hyperlink{classns3_1_1Ipv6L3Protocol_a5a68c54b92d81f93c41983ebdc0ef5b3}{m\_protocols}.find (key);
790       \textcolor{keywordflow}{if} (i != \hyperlink{classns3_1_1Ipv6L3Protocol_a5a68c54b92d81f93c41983ebdc0ef5b3}{m\_protocols}.end ())
791         \{
792           \textcolor{keywordflow}{return} i->second;
793         \}
794     \}
795   \textcolor{comment}{// try the generic protocol.}
796   key = std::make\_pair (protocolNumber, -1);
797   i = \hyperlink{classns3_1_1Ipv6L3Protocol_a5a68c54b92d81f93c41983ebdc0ef5b3}{m\_protocols}.find (key);
798   \textcolor{keywordflow}{if} (i != \hyperlink{classns3_1_1Ipv6L3Protocol_a5a68c54b92d81f93c41983ebdc0ef5b3}{m\_protocols}.end ())
799     \{
800       \textcolor{keywordflow}{return} i->second;
801     \}
802 
803   \textcolor{keywordflow}{return} 0;
804 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Get\+Routing\+Protocol@{Get\+Routing\+Protocol}}
\index{Get\+Routing\+Protocol@{Get\+Routing\+Protocol}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Routing\+Protocol() const }{GetRoutingProtocol() const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<$ {\bf Ipv6\+Routing\+Protocol} $>$ ns3\+::\+Ipv6\+L3\+Protocol\+::\+Get\+Routing\+Protocol (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_aea90446045bb78b99b150ef1dd9afdb4}{}\label{classns3_1_1Ipv6L3Protocol_aea90446045bb78b99b150ef1dd9afdb4}


Get current routing protocol used. 

\begin{DoxyReturn}{Returns}
routing protocol 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv6_af14dc67ff4c251776e5d0fca16c5cc7c}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
186 \{
187   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
188   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv6L3Protocol_aa0df547e5240b218dc1f4742a2a00117}{m\_routingProtocol};
189 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 25


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Get\+Send\+Icmpv6\+Redirect@{Get\+Send\+Icmpv6\+Redirect}}
\index{Get\+Send\+Icmpv6\+Redirect@{Get\+Send\+Icmpv6\+Redirect}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Send\+Icmpv6\+Redirect() const }{GetSendIcmpv6Redirect() const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv6\+L3\+Protocol\+::\+Get\+Send\+Icmpv6\+Redirect (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a4445c0e64ff312aedff3c5644fd6e99d}{}\label{classns3_1_1Ipv6L3Protocol_a4445c0e64ff312aedff3c5644fd6e99d}


Get the I\+C\+M\+Pv6 Redirect sending state. 

\begin{DoxyReturn}{Returns}
I\+C\+M\+Pv6 Redirect sending state (enabled or not) 
\end{DoxyReturn}

\begin{DoxyCode}
687 \{
688   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
689   \textcolor{keywordflow}{return} \hyperlink{classns3_1_1Ipv6L3Protocol_a23aef420bfb1d9dd634681c4a78a0352}{m\_sendIcmpv6Redirect};
690 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 26


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Get\+Type\+Id@{Get\+Type\+Id}}
\index{Get\+Type\+Id@{Get\+Type\+Id}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Get\+Type\+Id()}{GetTypeId()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type\+Id} ns3\+::\+Ipv6\+L3\+Protocol\+::\+Get\+Type\+Id (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv6L3Protocol_afb1b9affe13b7f2c4ccc0923fa291e11}{}\label{classns3_1_1Ipv6L3Protocol_afb1b9affe13b7f2c4ccc0923fa291e11}


Get the type ID of this class. 

\begin{DoxyReturn}{Returns}
type ID 
\end{DoxyReturn}

\begin{DoxyCode}
60 \{
61   \textcolor{keyword}{static} TypeId tid = TypeId (\textcolor{stringliteral}{"ns3::Ipv6L3Protocol"})
62     .SetParent<\hyperlink{classns3_1_1Ipv6_adccc58acd14d3f9a28f75dc09e794998}{Ipv6}> ()
63     .SetGroupName (\textcolor{stringliteral}{"Internet"})
64     .AddConstructor<\hyperlink{classns3_1_1Ipv6L3Protocol_aed69fbc6c2eca9a88dfb50f12b419902}{Ipv6L3Protocol}> ()
65     .AddAttribute (\textcolor{stringliteral}{"DefaultTtl"},
66                    \textcolor{stringliteral}{"The TTL value set by default on all "}
67                    \textcolor{stringliteral}{"outgoing packets generated on this node."},
68                    UintegerValue (64),
69                    MakeUintegerAccessor (&\hyperlink{classns3_1_1Ipv6L3Protocol_a2857858d48a3ce4f6bc1912d721825b7}{Ipv6L3Protocol::m\_defaultTtl}),
70                    MakeUintegerChecker<uint8\_t> ())
71     .AddAttribute (\textcolor{stringliteral}{"DefaultTclass"},
72                    \textcolor{stringliteral}{"The TCLASS value set by default on all "}
73                    \textcolor{stringliteral}{"outgoing packets generated on this node."},
74                    UintegerValue (0),
75                    MakeUintegerAccessor (&\hyperlink{classns3_1_1Ipv6L3Protocol_a0ead80eb6fa685c54dc155dff9157345}{Ipv6L3Protocol::m\_defaultTclass}),
76                    MakeUintegerChecker<uint8\_t> ())
77     .AddAttribute (\textcolor{stringliteral}{"InterfaceList"},
78                    \textcolor{stringliteral}{"The set of IPv6 interfaces associated to this IPv6 stack."},
79                    \hyperlink{namespacens3_a5de726d8bcea7a51fd68ce5167a66713}{ObjectVectorValue} (),
80                    \hyperlink{namespacens3_a6ad5b3621a5dc72b7030cbb07c73adf6}{MakeObjectVectorAccessor} (&
      \hyperlink{classns3_1_1Ipv6L3Protocol_a425d8738fd30fbc9345d57cfddd0d6d0}{Ipv6L3Protocol::m\_interfaces}),
81                    MakeObjectVectorChecker<Ipv6Interface> ())
82     .AddAttribute (\textcolor{stringliteral}{"SendIcmpv6Redirect"},
83                    \textcolor{stringliteral}{"Send the ICMPv6 Redirect when appropriate."},
84                    BooleanValue (\textcolor{keyword}{true}),
85                    MakeBooleanAccessor (&\hyperlink{classns3_1_1Ipv6L3Protocol_aa5c6bd6e857b631c812ed5bbe4566241}{Ipv6L3Protocol::SetSendIcmpv6Redirect}
      ,
86                                         &\hyperlink{classns3_1_1Ipv6L3Protocol_a4445c0e64ff312aedff3c5644fd6e99d}{Ipv6L3Protocol::GetSendIcmpv6Redirect}
      ),
87                    MakeBooleanChecker ())
88     .AddAttribute (\textcolor{stringliteral}{"StrongEndSystemModel"},
89                    \textcolor{stringliteral}{"Reject packets for an address not configured on the interface they're coming from
       (RFC1222)."},
90                    BooleanValue (\textcolor{keyword}{true}),
91                    MakeBooleanAccessor (&\hyperlink{classns3_1_1Ipv6L3Protocol_ac00aee071bc7ab2096efbf8fdc5e3814}{Ipv6L3Protocol::m\_strongEndSystemModel}
      ),
92                    MakeBooleanChecker ())
93     .AddTraceSource (\textcolor{stringliteral}{"Tx"},
94                      \textcolor{stringliteral}{"Send IPv6 packet to outgoing interface."},
95                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1Ipv6L3Protocol_a2037be8528273f3495216a09384e38e7}{Ipv6L3Protocol::m\_txTrace}),
96                      \textcolor{stringliteral}{"ns3::Ipv6L3Protocol::TxRxTracedCallback"})
97     .AddTraceSource (\textcolor{stringliteral}{"Rx"},
98                      \textcolor{stringliteral}{"Receive IPv6 packet from incoming interface."},
99                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1Ipv6L3Protocol_a2fc8b57fc958fccd7c708f8c8ca03da5}{Ipv6L3Protocol::m\_rxTrace}),
100                      \textcolor{stringliteral}{"ns3::Ipv6L3Protocol::TxRxTracedCallback"})
101     .AddTraceSource (\textcolor{stringliteral}{"Drop"},
102                      \textcolor{stringliteral}{"Drop IPv6 packet"},
103                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1Ipv6L3Protocol_ac22d2d63cac436267ae6cafc46880a6e}{Ipv6L3Protocol::m\_dropTrace}),
104                      \textcolor{stringliteral}{"ns3::Ipv6L3Protocol::DropTracedCallback"})
105 
106     .AddTraceSource (\textcolor{stringliteral}{"SendOutgoing"},
107                      \textcolor{stringliteral}{"A newly-generated packet by this node is "}
108                      \textcolor{stringliteral}{"about to be queued for transmission"},
109                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1Ipv6L3Protocol_aac1ff242aa91275202e37cf7d805eec8}{Ipv6L3Protocol::m\_sendOutgoingTrace}),
110                      \textcolor{stringliteral}{"ns3::Ipv6L3Protocol::SentTracedCallback"})
111     .AddTraceSource (\textcolor{stringliteral}{"UnicastForward"},
112                      \textcolor{stringliteral}{"A unicast IPv6 packet was received by this node "}
113                      \textcolor{stringliteral}{"and is being forwarded to another node"},
114                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1Ipv6L3Protocol_a76b5cbe054e52a240d3e1a3ea0f891fd}{Ipv6L3Protocol::m\_unicastForwardTrace}),
115                      \textcolor{stringliteral}{"ns3::Ipv6L3Protocol::SentTracedCallback"})
116     .AddTraceSource (\textcolor{stringliteral}{"LocalDeliver"},
117                      \textcolor{stringliteral}{"An IPv6 packet was received by/for this node, "}
118                      \textcolor{stringliteral}{"and it is being forward up the stack"},
119                      \hyperlink{group__tracing_gab21a770b9855af4e8f69f7531ea4a6b0}{MakeTraceSourceAccessor} (&
      \hyperlink{classns3_1_1Ipv6L3Protocol_afd8b2aef3c54456b509cdc7356db577e}{Ipv6L3Protocol::m\_localDeliverTrace}),
120                      \textcolor{stringliteral}{"ns3::Ipv6L3Protocol::SentTracedCallback"})
121   ;
122   \textcolor{keywordflow}{return} tid;
123 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 27


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Insert@{Insert}}
\index{Insert@{Insert}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Insert(\+Ptr$<$ Ip\+L4\+Protocol $>$ protocol)}{Insert(Ptr< IpL4Protocol > protocol)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Insert (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ip\+L4\+Protocol} $>$}]{protocol}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_afcdf13ca065622b8cb4691f2d3e92002}{}\label{classns3_1_1Ipv6L3Protocol_afcdf13ca065622b8cb4691f2d3e92002}


Add a L4 protocol. 


\begin{DoxyParams}{Parameters}
{\em protocol} & L4 protocol \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6_af696a13faee7772aa155e6b06a752220}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
718 \{
719   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << protocol);
720   \hyperlink{classns3_1_1Ipv6L3Protocol_ade8066a20a3494dbda177322b1d18c21}{L4ListKey\_t} key = std::make\_pair (protocol->GetProtocolNumber (), -1);
721   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6L3Protocol_a5a68c54b92d81f93c41983ebdc0ef5b3}{m\_protocols}.find (key) != \hyperlink{classns3_1_1Ipv6L3Protocol_a5a68c54b92d81f93c41983ebdc0ef5b3}{m\_protocols}.end ())
722     \{
723       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Overwriting default protocol "} << \textcolor{keywordtype}{int}(protocol->GetProtocolNumber ()));
724     \}
725   \hyperlink{classns3_1_1Ipv6L3Protocol_a5a68c54b92d81f93c41983ebdc0ef5b3}{m\_protocols}[key] = protocol;
726 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Insert@{Insert}}
\index{Insert@{Insert}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Insert(\+Ptr$<$ Ip\+L4\+Protocol $>$ protocol, uint32\+\_\+t interface\+Index)}{Insert(Ptr< IpL4Protocol > protocol, uint32_t interfaceIndex)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Insert (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ip\+L4\+Protocol} $>$}]{protocol, }
\item[{uint32\+\_\+t}]{interface\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a8b7f000d9d6d897dff787bfddab34872}{}\label{classns3_1_1Ipv6L3Protocol_a8b7f000d9d6d897dff787bfddab34872}


Add a L4 protocol to a specific interface. 

This may be called multiple times for multiple interfaces for the same protocol. To insert for all interfaces, use the separate Insert (Ptr$<$\+Ip\+L4\+Protocol$>$ protocol) method.

Setting a protocol on a specific interface will overwrite the previously bound protocol.


\begin{DoxyParams}{Parameters}
{\em protocol} & L4 protocol. \\
\hline
{\em interface\+Index} & interface index. \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6_abac82ab5421240d8011131f0f49a080b}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
729 \{
730   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << protocol << interfaceIndex);
731 
732   \hyperlink{classns3_1_1Ipv6L3Protocol_ade8066a20a3494dbda177322b1d18c21}{L4ListKey\_t} key = std::make\_pair (protocol->GetProtocolNumber (), interfaceIndex);
733   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6L3Protocol_a5a68c54b92d81f93c41983ebdc0ef5b3}{m\_protocols}.find (key) != \hyperlink{classns3_1_1Ipv6L3Protocol_a5a68c54b92d81f93c41983ebdc0ef5b3}{m\_protocols}.end ())
734     \{
735       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Overwriting protocol "} << \textcolor{keywordtype}{int}(protocol->GetProtocolNumber ()) << \textcolor{stringliteral}{" on
       interface "} << \textcolor{keywordtype}{int}(interfaceIndex));
736     \}
737   \hyperlink{classns3_1_1Ipv6L3Protocol_a5a68c54b92d81f93c41983ebdc0ef5b3}{m\_protocols}[key] = protocol;
738 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Ip\+Forward@{Ip\+Forward}}
\index{Ip\+Forward@{Ip\+Forward}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Ip\+Forward(\+Ptr$<$ const Net\+Device $>$ idev, Ptr$<$ Ipv6\+Route $>$ rtentry, Ptr$<$ const Packet $>$ p, const Ipv6\+Header \&header)}{IpForward(Ptr< const NetDevice > idev, Ptr< Ipv6Route > rtentry, Ptr< const Packet > p, const Ipv6Header &header)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Ip\+Forward (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Net\+Device} $>$}]{idev, }
\item[{{\bf Ptr}$<$ {\bf Ipv6\+Route} $>$}]{rtentry, }
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv6\+Header} \&}]{header}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_ac956e0aaed5e961b6c25210c2b696da6}{}\label{classns3_1_1Ipv6L3Protocol_ac956e0aaed5e961b6c25210c2b696da6}


Forward a packet. 


\begin{DoxyParams}{Parameters}
{\em idev} & Pointer to ingress network device \\
\hline
{\em rtentry} & route \\
\hline
{\em p} & packet to forward \\
\hline
{\em header} & I\+Pv6 header to add to the packet \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1223 \{
1224   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << rtentry << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} << header);
1225   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Forwarding logic for node: "} << \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->\hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} ());
1226 
1227   \textcolor{comment}{// Drop RFC 3849 packets: 2001:db8::/32}
1228   \textcolor{keywordflow}{if} (header.GetDestinationAddress().IsDocumentation ())
1229     \{
1230       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Received a packet for 2001:db8::/32 (documentation class).  Drop."});
1231       \hyperlink{classns3_1_1Ipv6L3Protocol_ac22d2d63cac436267ae6cafc46880a6e}{m\_dropTrace} (header, \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa3690e9264e4d2307050512b833df4946}{DROP\_ROUTE\_ERROR}, 
      \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<\hyperlink{classns3_1_1Ipv6_adccc58acd14d3f9a28f75dc09e794998}{Ipv6}> (), 0);
1232       \textcolor{keywordflow}{return};
1233     \}
1234 
1235   \textcolor{comment}{// Forwarding}
1236   Ipv6Header ipHeader = header;
1237   Ptr<Packet> packet = \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->Copy ();
1238   ipHeader.SetHopLimit (ipHeader.GetHopLimit () - 1);
1239 
1240   \textcolor{keywordflow}{if} (ipHeader.GetSourceAddress ().IsLinkLocal ())
1241     \{
1242       \textcolor{comment}{/* no forward for link-local address */}
1243       \textcolor{keywordflow}{return};
1244     \}
1245 
1246   \textcolor{keywordflow}{if} (ipHeader.GetHopLimit () == 0)
1247     \{
1248       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"TTL exceeded.  Drop."});
1249       \hyperlink{classns3_1_1Ipv6L3Protocol_ac22d2d63cac436267ae6cafc46880a6e}{m\_dropTrace} (ipHeader, packet, \hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa49c4e7173190b1bbba7d6300b06a16ed}{DROP\_TTL\_EXPIRED}, 
      \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<\hyperlink{classns3_1_1Ipv6_adccc58acd14d3f9a28f75dc09e794998}{Ipv6}> (), 0);
1250       \textcolor{comment}{// Do not reply to multicast IPv6 address}
1251       \textcolor{keywordflow}{if} (ipHeader.GetDestinationAddress ().IsMulticast () == \textcolor{keyword}{false})
1252         \{
1253           packet->AddHeader (ipHeader);
1254           \hyperlink{classns3_1_1Ipv6L3Protocol_a10384a4dc85c61e65cf73b47ec9da90d}{GetIcmpv6} ()->SendErrorTimeExceeded (packet, ipHeader.GetSourceAddress (), 
      \hyperlink{classns3_1_1Icmpv6Header_a643af752203ad4456f89d3d1ab49943aa2f477ba611ff7d0606adbca6c61e318d}{Icmpv6Header::ICMPV6\_HOPLIMIT});
1255         \}
1256       \textcolor{keywordflow}{return};
1257     \}
1258 
1259   \textcolor{comment}{/* ICMPv6 Redirect */}
1260 
1261   \textcolor{comment}{/* if we forward to a machine on the same network as the source,}
1262 \textcolor{comment}{   * we send him an ICMPv6 redirect message to notify him that a short route}
1263 \textcolor{comment}{   * exists.}
1264 \textcolor{comment}{   */}
1265 
1266   \textcolor{comment}{/* Theoretically we should also check if the redirect target is on the same network}
1267 \textcolor{comment}{   * as the source node. On the other hand, we are sure that the router we're redirecting to}
1268 \textcolor{comment}{   * used a link-local address. As a consequence, they MUST be on the same network, the link-local net.}
1269 \textcolor{comment}{   */}
1270 
1271   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6L3Protocol_a23aef420bfb1d9dd634681c4a78a0352}{m\_sendIcmpv6Redirect} && (rtentry->GetOutputDevice ()==idev))
1272     \{
1273       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"ICMPv6 redirect!"});
1274       Ptr<Icmpv6L4Protocol> icmpv6 = \hyperlink{classns3_1_1Ipv6L3Protocol_a10384a4dc85c61e65cf73b47ec9da90d}{GetIcmpv6} ();
1275       Address hardwareTarget;
1276       Ipv6Address dst = header.GetDestinationAddress ();
1277       Ipv6Address src = header.GetSourceAddress ();
1278       Ipv6Address target = rtentry->GetGateway ();
1279       Ptr<Packet> copy = \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->Copy ();
1280 
1281       \textcolor{keywordflow}{if} (target.IsAny ())
1282         \{
1283           target = dst;
1284         \}
1285 
1286       copy->AddHeader (header);
1287       Ipv6Address linkLocal = \hyperlink{classns3_1_1Ipv6L3Protocol_a2e53b72d76bceb713f2d3cb54e24f5a1}{GetInterface} (\hyperlink{classns3_1_1Ipv6L3Protocol_a878292513d6294e2dfdeccbe1ed1d996}{GetInterfaceForDevice} (rtentry
      ->GetOutputDevice ()))->GetLinkLocalAddress ().GetAddress ();
1288 
1289       \textcolor{keywordflow}{if} (icmpv6->Lookup (target, rtentry->GetOutputDevice (), 0, &hardwareTarget))
1290         \{
1291           icmpv6->SendRedirection (copy, linkLocal, src, target, dst, hardwareTarget);
1292         \}
1293       \textcolor{keywordflow}{else}
1294         \{
1295           icmpv6->SendRedirection (copy, linkLocal, src, target, dst, Address ());
1296         \}
1297     \}
1298   \textcolor{comment}{// in case the packet still has a priority tag attached, remove it}
1299   SocketPriorityTag priorityTag;
1300   packet->RemovePacketTag (priorityTag);
1301   int32\_t \textcolor{keyword}{interface }= \hyperlink{classns3_1_1Ipv6L3Protocol_a878292513d6294e2dfdeccbe1ed1d996}{GetInterfaceForDevice} (rtentry->GetOutputDevice ());
1302   \hyperlink{classns3_1_1Ipv6L3Protocol_a76b5cbe054e52a240d3e1a3ea0f891fd}{m\_unicastForwardTrace} (ipHeader, packet, interface);
1303   \hyperlink{classns3_1_1Ipv6L3Protocol_adad363af4c50cd94505b918b15f228d4}{SendRealOut} (rtentry, packet, ipHeader);
1304 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 28




Here is the caller graph for this function\+:
% FIG 29


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Ip\+Multicast\+Forward@{Ip\+Multicast\+Forward}}
\index{Ip\+Multicast\+Forward@{Ip\+Multicast\+Forward}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Ip\+Multicast\+Forward(\+Ptr$<$ const Net\+Device $>$ idev, Ptr$<$ Ipv6\+Multicast\+Route $>$ mrtentry, Ptr$<$ const Packet $>$ p, const Ipv6\+Header \&header)}{IpMulticastForward(Ptr< const NetDevice > idev, Ptr< Ipv6MulticastRoute > mrtentry, Ptr< const Packet > p, const Ipv6Header &header)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Ip\+Multicast\+Forward (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Net\+Device} $>$}]{idev, }
\item[{{\bf Ptr}$<$ {\bf Ipv6\+Multicast\+Route} $>$}]{mrtentry, }
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv6\+Header} \&}]{header}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_aa65d2e4894ea499415227e232e854824}{}\label{classns3_1_1Ipv6L3Protocol_aa65d2e4894ea499415227e232e854824}


Forward a multicast packet. 


\begin{DoxyParams}{Parameters}
{\em idev} & Pointer to ingress network device \\
\hline
{\em mrtentry} & route \\
\hline
{\em p} & packet to forward \\
\hline
{\em header} & I\+Pv6 header to add to the packet \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1307 \{
1308   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << mrtentry << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} << header);
1309   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Multicast forwarding logic for node: "} << \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->
      \hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} ());
1310 
1311   std::map<uint32\_t, uint32\_t> ttlMap = mrtentry->GetOutputTtlMap ();
1312   std::map<uint32\_t, uint32\_t>::iterator mapIter;
1313 
1314   \textcolor{keywordflow}{for} (mapIter = ttlMap.begin (); mapIter != ttlMap.end (); mapIter++)
1315     \{
1316       uint32\_t interfaceId = mapIter->first;
1317       \textcolor{comment}{//uint32\_t outputTtl = mapIter->second;  // Unused for now}
1318       Ptr<Packet> packet = \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->Copy ();
1319       Ipv6Header h = header;
1320       h.SetHopLimit (header.GetHopLimit () - 1);
1321       \textcolor{keywordflow}{if} (h.GetHopLimit () == 0)
1322         \{
1323           \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"TTL exceeded.  Drop."});
1324           \hyperlink{classns3_1_1Ipv6L3Protocol_ac22d2d63cac436267ae6cafc46880a6e}{m\_dropTrace} (header, packet, \hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa49c4e7173190b1bbba7d6300b06a16ed}{DROP\_TTL\_EXPIRED}, 
      \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<\hyperlink{classns3_1_1Ipv6_adccc58acd14d3f9a28f75dc09e794998}{Ipv6}> (), interfaceId);
1325           \textcolor{keywordflow}{return};
1326         \}
1327       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Forward multicast via interface "} << interfaceId);
1328       Ptr<Ipv6Route> rtentry = Create<Ipv6Route> ();
1329       rtentry->SetSource (h.GetSourceAddress ());
1330       rtentry->SetDestination (h.GetDestinationAddress ());
1331       rtentry->SetGateway (\hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} ());
1332       rtentry->SetOutputDevice (\hyperlink{classns3_1_1Ipv6L3Protocol_a574d1beafc86062acf582e75dc437a47}{GetNetDevice} (interfaceId));
1333       \hyperlink{classns3_1_1Ipv6L3Protocol_adad363af4c50cd94505b918b15f228d4}{SendRealOut} (rtentry, packet, h);
1334       \textcolor{keywordflow}{continue};
1335     \}
1336 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 30




Here is the caller graph for this function\+:
% FIG 31


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Is\+Forwarding@{Is\+Forwarding}}
\index{Is\+Forwarding@{Is\+Forwarding}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Is\+Forwarding(uint32\+\_\+t i) const }{IsForwarding(uint32_t i) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv6\+L3\+Protocol\+::\+Is\+Forwarding (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_adae9c781382073a1db0429a4f156dee2}{}\label{classns3_1_1Ipv6L3Protocol_adae9c781382073a1db0429a4f156dee2}


Is interface allows forwarding ? 


\begin{DoxyParams}{Parameters}
{\em i} & interface index \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the interface is forwarding 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv6_a7240bf60410f8398d072641c6460339f}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
597 \{
598   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
599   Ptr<Ipv6Interface> \textcolor{keyword}{interface }= GetInterface (i);
600 
601   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Forwarding state: "} << interface->IsForwarding ());
602   \textcolor{keywordflow}{return} interface->IsForwarding ();
603 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Is\+Registered\+Multicast\+Address@{Is\+Registered\+Multicast\+Address}}
\index{Is\+Registered\+Multicast\+Address@{Is\+Registered\+Multicast\+Address}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Is\+Registered\+Multicast\+Address(\+Ipv6\+Address address) const }{IsRegisteredMulticastAddress(Ipv6Address address) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv6\+L3\+Protocol\+::\+Is\+Registered\+Multicast\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{address}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv6L3Protocol_ad883e42df23aa1fc0fe38a1489830b1a}{}\label{classns3_1_1Ipv6L3Protocol_ad883e42df23aa1fc0fe38a1489830b1a}
Checks if the address has been registered. 
\begin{DoxyParams}{Parameters}
{\em address} & the address. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the address is registered. 
\end{DoxyReturn}

\begin{DoxyCode}
1605 \{
1606   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (address);
1607 
1608   \hyperlink{classns3_1_1Ipv6L3Protocol_a635e981d0b583b98e00909163710dea9}{Ipv6RegisteredMulticastAddressNoInterfaceCIter\_t} iter = 
      \hyperlink{classns3_1_1Ipv6L3Protocol_a4b31a418ae742bed8835981afb433b1c}{m\_multicastAddressesNoInterface}.find (address);
1609 
1610   \textcolor{keywordflow}{if} (iter == \hyperlink{classns3_1_1Ipv6L3Protocol_a4b31a418ae742bed8835981afb433b1c}{m\_multicastAddressesNoInterface}.end ())
1611     \{
1612       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1613     \}
1614   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1615 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 32


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Is\+Registered\+Multicast\+Address@{Is\+Registered\+Multicast\+Address}}
\index{Is\+Registered\+Multicast\+Address@{Is\+Registered\+Multicast\+Address}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Is\+Registered\+Multicast\+Address(\+Ipv6\+Address address, uint32\+\_\+t interface) const }{IsRegisteredMulticastAddress(Ipv6Address address, uint32_t interface) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv6\+L3\+Protocol\+::\+Is\+Registered\+Multicast\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{address, }
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
) const}\hypertarget{classns3_1_1Ipv6L3Protocol_a6c649bc2bafa7ef1c2a7ec9ef0674e2b}{}\label{classns3_1_1Ipv6L3Protocol_a6c649bc2bafa7ef1c2a7ec9ef0674e2b}
Checks if the address has been registered for a specific interface. 
\begin{DoxyParams}{Parameters}
{\em address} & the address. \\
\hline
{\em interface} & the incoming interface. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the address is registered. 
\end{DoxyReturn}

\begin{DoxyCode}
1591 \{
1592   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (address << interface);
1593 
1594   \hyperlink{classns3_1_1Ipv6L3Protocol_ad85035c0604805049efdc7a5b3d99082}{Ipv6RegisteredMulticastAddressKey\_t} key = std::make\_pair (address, 
      interface);
1595   \hyperlink{classns3_1_1Ipv6L3Protocol_a656104cdf393b6e6a41c79d172c8e8fb}{Ipv6RegisteredMulticastAddressCIter\_t} iter = 
      \hyperlink{classns3_1_1Ipv6L3Protocol_a6d7573453cf2a73d44bfb2d68eed19c4}{m\_multicastAddresses}.find (key);
1596 
1597   \textcolor{keywordflow}{if} (iter == \hyperlink{classns3_1_1Ipv6L3Protocol_a6d7573453cf2a73d44bfb2d68eed19c4}{m\_multicastAddresses}.end ())
1598     \{
1599       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1600     \}
1601   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1602 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Is\+Up@{Is\+Up}}
\index{Is\+Up@{Is\+Up}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Is\+Up(uint32\+\_\+t i) const }{IsUp(uint32_t i) const }}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv6\+L3\+Protocol\+::\+Is\+Up (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a34fb6e5caedebf7c257bb4fa7c125a3c}{}\label{classns3_1_1Ipv6L3Protocol_a34fb6e5caedebf7c257bb4fa7c125a3c}


Is specified interface up ? 


\begin{DoxyParams}{Parameters}
{\em i} & interface index \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the interface is up 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv6_a4aad08a05734df75ca70bff43188068f}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
515 \{
516   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
517   Ptr<Ipv6Interface> \textcolor{keyword}{interface }= GetInterface (i);
518   \textcolor{keywordflow}{return} interface->IsUp ();
519 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Local\+Deliver@{Local\+Deliver}}
\index{Local\+Deliver@{Local\+Deliver}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Local\+Deliver(\+Ptr$<$ const Packet $>$ p, Ipv6\+Header const \&ip, uint32\+\_\+t iif)}{LocalDeliver(Ptr< const Packet > p, Ipv6Header const &ip, uint32_t iif)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Local\+Deliver (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p, }
\item[{{\bf Ipv6\+Header} const \&}]{ip, }
\item[{uint32\+\_\+t}]{iif}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a8e2c7a80851d870812295c19dc908a38}{}\label{classns3_1_1Ipv6L3Protocol_a8e2c7a80851d870812295c19dc908a38}


Deliver a packet. 


\begin{DoxyParams}{Parameters}
{\em p} & packet delivered \\
\hline
{\em ip} & I\+Pv6 header \\
\hline
{\em iif} & input interface packet was received \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1339 \{
1340   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << ip << iif);
1341   Ptr<Packet> \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} = packet->Copy ();
1342   Ptr<IpL4Protocol> protocol = 0;
1343   Ptr<Ipv6ExtensionDemux> ipv6ExtensionDemux = \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv6ExtensionDemux> ();
1344   Ptr<Ipv6Extension> ipv6Extension = 0;
1345   Ipv6Address src = ip.GetSourceAddress ();
1346   Ipv6Address dst = ip.GetDestinationAddress ();
1347   uint8\_t nextHeader = ip.GetNextHeader ();
1348   uint8\_t nextHeaderPosition = 0;
1349   \textcolor{keywordtype}{bool} isDropped = \textcolor{keyword}{false};
1350   \textcolor{keywordtype}{bool} stopProcessing = \textcolor{keyword}{false};
1351   \hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37a}{DropReason} dropReason;
1352 
1353   \textcolor{comment}{// check for a malformed hop-by-hop extension}
1354   \textcolor{comment}{// this is a common case when forging IPv6 raw packets}
1355   \textcolor{keywordflow}{if} (nextHeader == \hyperlink{classns3_1_1Ipv6Header_a226429221a066c5e3b1f260caf27d1e9aa0413202f88bebb4f91a138e317b6bbd}{Ipv6Header::IPV6\_EXT\_HOP\_BY\_HOP})
1356     \{
1357       uint8\_t buf;
1358       p->CopyData (&buf, 1);
1359       \textcolor{keywordflow}{if} (buf == \hyperlink{classns3_1_1Ipv6Header_a226429221a066c5e3b1f260caf27d1e9aa0413202f88bebb4f91a138e317b6bbd}{Ipv6Header::IPV6\_EXT\_HOP\_BY\_HOP})
1360         \{
1361           \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN}(\textcolor{stringliteral}{"Double Ipv6Header::IPV6\_EXT\_HOP\_BY\_HOP in packet, dropping packet"});
1362           \textcolor{keywordflow}{return};
1363         \}
1364     \}
1365 
1366   \textcolor{comment}{/* process all the extensions found and the layer 4 protocol */}
1367   \textcolor{keywordflow}{do}
1368     \{
1369       \textcolor{comment}{/* it return 0 for non-extension (i.e. layer 4 protocol) */}
1370       ipv6Extension = ipv6ExtensionDemux->GetExtension (nextHeader);
1371 
1372       \textcolor{keywordflow}{if} (ipv6Extension)
1373         \{
1374           uint8\_t nextHeaderStep = 0;
1375           uint8\_t curHeader = nextHeader;
1376           nextHeaderStep = ipv6Extension->Process (p, nextHeaderPosition, ip, dst, &nextHeader, 
      stopProcessing, isDropped, dropReason);
1377           nextHeaderPosition += nextHeaderStep;
1378 
1379           \textcolor{keywordflow}{if} (isDropped)
1380             \{
1381               \hyperlink{classns3_1_1Ipv6L3Protocol_ac22d2d63cac436267ae6cafc46880a6e}{m\_dropTrace} (ip, packet, dropReason, \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->
      \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<\hyperlink{classns3_1_1Ipv6_adccc58acd14d3f9a28f75dc09e794998}{Ipv6}> (), iif);
1382             \}
1383 
1384           \textcolor{keywordflow}{if} (stopProcessing)
1385             \{
1386               \textcolor{keywordflow}{return};
1387             \}
1388           \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (nextHeaderStep != 0 || curHeader == 
      \hyperlink{classns3_1_1Ipv6Header_a226429221a066c5e3b1f260caf27d1e9a5839daf3fdfb16dfdc94a208ca6ebc5a}{Ipv6Header::IPV6\_EXT\_FRAGMENTATION},
1389                          \textcolor{stringliteral}{"Zero-size IPv6 Option Header, aborting"} << *packet );
1390         \}
1391       \textcolor{keywordflow}{else}
1392         \{
1393           protocol = \hyperlink{classns3_1_1Ipv6L3Protocol_acb189bb5deceb95e78f2a443609c8d64}{GetProtocol} (nextHeader, iif);
1394 
1395           \textcolor{keywordflow}{if} (!protocol)
1396             \{
1397               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Unknown Next Header. Drop!"});
1398 
1399               \textcolor{comment}{// For ICMPv6 Error packets}
1400               Ptr<Packet> malformedPacket  = packet->Copy ();
1401               malformedPacket->AddHeader (ip);
1402 
1403               \textcolor{keywordflow}{if} (nextHeaderPosition == 0)
1404                 \{
1405                   \hyperlink{classns3_1_1Ipv6L3Protocol_a10384a4dc85c61e65cf73b47ec9da90d}{GetIcmpv6} ()->SendErrorParameterError (malformedPacket, dst, 
      \hyperlink{classns3_1_1Icmpv6Header_ae9230cd167393f553a3c2ded106858caa0eae2e0ddc20524b6a988de9631096c6}{Icmpv6Header::ICMPV6\_UNKNOWN\_NEXT\_HEADER}, 40);
1406                 \}
1407               \textcolor{keywordflow}{else}
1408                 \{
1409                   \hyperlink{classns3_1_1Ipv6L3Protocol_a10384a4dc85c61e65cf73b47ec9da90d}{GetIcmpv6} ()->SendErrorParameterError (malformedPacket, dst, 
      \hyperlink{classns3_1_1Icmpv6Header_ae9230cd167393f553a3c2ded106858caa0eae2e0ddc20524b6a988de9631096c6}{Icmpv6Header::ICMPV6\_UNKNOWN\_NEXT\_HEADER}, ip.GetSerializedSize () +
       nextHeaderPosition);
1410                 \}
1411               \hyperlink{classns3_1_1Ipv6L3Protocol_ac22d2d63cac436267ae6cafc46880a6e}{m\_dropTrace} (ip, p, \hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aaaf932a981ea33f927add80ea8ed41b05}{DROP\_UNKNOWN\_PROTOCOL}, 
      \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<\hyperlink{classns3_1_1Ipv6_adccc58acd14d3f9a28f75dc09e794998}{Ipv6}> (), iif);
1412               \textcolor{keywordflow}{break};
1413             \}
1414           \textcolor{keywordflow}{else}
1415             \{
1416               p->RemoveAtStart (nextHeaderPosition);
1417               \textcolor{comment}{/* protocol->Receive (p, src, dst, incomingInterface); */}
1418 
1419               \textcolor{comment}{/* L4 protocol */}
1420               Ptr<Packet> copy = p->Copy ();
1421 
1422               \hyperlink{classns3_1_1Ipv6L3Protocol_afd8b2aef3c54456b509cdc7356db577e}{m\_localDeliverTrace} (ip, p, iif);
1423 
1424               \textcolor{keyword}{enum} \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80e}{IpL4Protocol::RxStatus} status = protocol->Receive (p, ip, 
      \hyperlink{classns3_1_1Ipv6L3Protocol_a2e53b72d76bceb713f2d3cb54e24f5a1}{GetInterface} (iif));
1425 
1426               \textcolor{keywordflow}{switch} (status)
1427                 \{
1428                 \textcolor{keywordflow}{case} \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80eabd979bce2f3b22521c81c4115c66317e}{IpL4Protocol::RX\_OK}:
1429                   \textcolor{keywordflow}{break};
1430                 \textcolor{keywordflow}{case} \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80eaba0111c02656760e18ca30479e297b07}{IpL4Protocol::RX\_CSUM\_FAILED}:
1431                   \textcolor{keywordflow}{break};
1432                 \textcolor{keywordflow}{case} \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80eac7f4577d3ab1a219d6cb2b6964c49afd}{IpL4Protocol::RX\_ENDPOINT\_CLOSED}:
1433                   \textcolor{keywordflow}{break};
1434                 \textcolor{keywordflow}{case} \hyperlink{classns3_1_1IpL4Protocol_afd3744c89902fff232e2fd45f558c80ea00e3d2a534b8bd353395254c0735948b}{IpL4Protocol::RX\_ENDPOINT\_UNREACH}:
1435                   \textcolor{keywordflow}{if} (ip.GetDestinationAddress ().IsMulticast ())
1436                     \{
1437                       \textcolor{comment}{/* do not rely on multicast address */}
1438                       \textcolor{keywordflow}{break};
1439                     \}
1440 
1441                   copy->AddHeader (ip);
1442                   \hyperlink{classns3_1_1Ipv6L3Protocol_a10384a4dc85c61e65cf73b47ec9da90d}{GetIcmpv6} ()->SendErrorDestinationUnreachable (copy, ip.GetSourceAddress (), 
      \hyperlink{classns3_1_1Icmpv6Header_a2609b9581c3de3d6bbf8d55f5adf0d1daa4d55a0485155408f083e4fadcfbee48}{Icmpv6Header::ICMPV6\_PORT\_UNREACHABLE});
1443                 \}
1444             \}
1445         \}
1446     \}
1447   \textcolor{keywordflow}{while} (ipv6Extension);
1448 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 33




Here is the caller graph for this function\+:
% FIG 34


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Notify\+New\+Aggregate@{Notify\+New\+Aggregate}}
\index{Notify\+New\+Aggregate@{Notify\+New\+Aggregate}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Notify\+New\+Aggregate()}{NotifyNewAggregate()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Notify\+New\+Aggregate (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_ae07ff89952d068d18fb5650ffd1f5378}{}\label{classns3_1_1Ipv6L3Protocol_ae07ff89952d068d18fb5650ffd1f5378}


Notify other components connected to the node that a new stack member is now connected. 

This will be used to notify Layer 3 protocol of layer 4 protocol stack to connect them together. 

Reimplemented from \hyperlink{classns3_1_1Object_a1bd7211125185a6cd511c35fea4e500f}{ns3\+::\+Object}.


\begin{DoxyCode}
693 \{
694   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
695 
696   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node} == 0)
697     \{
698       Ptr<Node> node = this->GetObject<Node> ();
699       \textcolor{comment}{// verify that it's a valid node and that}
700       \textcolor{comment}{// the node has not been set before}
701       \textcolor{keywordflow}{if} (node != 0)
702         \{
703           this->\hyperlink{classns3_1_1Ipv6L3Protocol_a53796a2747cb5edcd1c762f44043b061}{SetNode} (node);
704         \}
705     \}
706   \hyperlink{classns3_1_1Object_a1bd7211125185a6cd511c35fea4e500f}{Ipv6::NotifyNewAggregate} ();
707 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 35


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!operator=@{operator=}}
\index{operator=@{operator=}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{operator=(const Ipv6\+L3\+Protocol \&)}{operator=(const Ipv6L3Protocol &)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+L3\+Protocol}\& ns3\+::\+Ipv6\+L3\+Protocol\+::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf Ipv6\+L3\+Protocol} \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a623d2b2cf5c444973830dd12cb584554}{}\label{classns3_1_1Ipv6L3Protocol_a623d2b2cf5c444973830dd12cb584554}


Copy constructor. 

Defined but not implemented to avoid misuse \begin{DoxyReturn}{Returns}
the copied object 
\end{DoxyReturn}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Receive@{Receive}}
\index{Receive@{Receive}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Receive(\+Ptr$<$ Net\+Device $>$ device, Ptr$<$ const Packet $>$ p, uint16\+\_\+t protocol, const Address \&from, const Address \&to, Net\+Device\+::\+Packet\+Type packet\+Type)}{Receive(Ptr< NetDevice > device, Ptr< const Packet > p, uint16_t protocol, const Address &from, const Address &to, NetDevice::PacketType packetType)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Receive (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Net\+Device} $>$}]{device, }
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p, }
\item[{uint16\+\_\+t}]{protocol, }
\item[{const {\bf Address} \&}]{from, }
\item[{const {\bf Address} \&}]{to, }
\item[{{\bf Net\+Device\+::\+Packet\+Type}}]{packet\+Type}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6L3Protocol_a8a95d576e8aee9a571db93bf686d850a}{}\label{classns3_1_1Ipv6L3Protocol_a8a95d576e8aee9a571db93bf686d850a}


Receive method when a packet arrive in the stack. This method removes I\+Pv6 header and forward up to L4 protocol. 


\begin{DoxyParams}{Parameters}
{\em device} & network device \\
\hline
{\em p} & the packet \\
\hline
{\em protocol} & next header value \\
\hline
{\em from} & address of the correspondent \\
\hline
{\em to} & address of the destination \\
\hline
{\em packet\+Type} & type of the packet \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
941 \{
942   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << device << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} << protocol << \hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from} << to << packetType);
943   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Packet from "} << \hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from} << \textcolor{stringliteral}{" received on node "} << 
      \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->\hyperlink{classns3_1_1Node_aaf49b64a843565ce3812326313b370ac}{GetId} ());
944 
945   \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\hyperlink{classns3_1_1Ipv6L3Protocol_a878292513d6294e2dfdeccbe1ed1d996}{GetInterfaceForDevice}(device) != -1, \textcolor{stringliteral}{"Received a packet
       from an interface that is not known to IPv6"});
946   uint32\_t \textcolor{keyword}{interface }= GetInterfaceForDevice(device);
947 
948   Ptr<Ipv6Interface> ipv6Interface = \hyperlink{classns3_1_1Ipv6L3Protocol_a425d8738fd30fbc9345d57cfddd0d6d0}{m\_interfaces}[interface];
949   Ptr<Packet> packet = \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->Copy ();
950 
951   \textcolor{keywordflow}{if} (ipv6Interface->IsUp ())
952     \{
953       \hyperlink{classns3_1_1Ipv6L3Protocol_a2fc8b57fc958fccd7c708f8c8ca03da5}{m\_rxTrace} (packet, \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<\hyperlink{classns3_1_1Ipv6_adccc58acd14d3f9a28f75dc09e794998}{Ipv6}> (), interface);
954     \}
955   \textcolor{keywordflow}{else}
956     \{
957       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Dropping received packet-- interface is down"});
958       Ipv6Header hdr;
959       packet->RemoveHeader (hdr);
960       \hyperlink{classns3_1_1Ipv6L3Protocol_ac22d2d63cac436267ae6cafc46880a6e}{m\_dropTrace} (hdr, packet, \hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa72b499545685a47a7cf3588d1330d5d0}{DROP\_INTERFACE\_DOWN}, 
      \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<\hyperlink{classns3_1_1Ipv6_adccc58acd14d3f9a28f75dc09e794998}{Ipv6}> (), interface);
961       \textcolor{keywordflow}{return};
962     \}
963 
964   Ipv6Header hdr;
965   packet->RemoveHeader (hdr);
966 
967   \textcolor{comment}{// Trim any residual frame padding from underlying devices}
968   \textcolor{keywordflow}{if} (hdr.GetPayloadLength () < packet->GetSize ())
969     \{
970       packet->RemoveAtEnd (packet->GetSize () - hdr.GetPayloadLength ());
971     \}
972 
973   \textcolor{comment}{// the packet is valid, we update the NDISC cache entry (if present)}
974   Ptr<NdiscCache> ndiscCache = ipv6Interface->GetNdiscCache ();
975   \textcolor{keywordflow}{if} (ndiscCache)
976     \{
977       \textcolor{comment}{// case one, it's a a direct routing.}
978       NdiscCache::Entry *entry = ndiscCache->Lookup (hdr.GetSourceAddress ());
979       \textcolor{keywordflow}{if} (entry)
980         \{
981           entry->UpdateReachableTimer ();
982         \}
983       \textcolor{keywordflow}{else}
984         \{
985           \textcolor{comment}{// It's not in the direct routing, so it's the router, and it could have multiple IP addresses.}
986           \textcolor{comment}{// In doubt, update all of them.}
987           \textcolor{comment}{// Note: it's a confirmed behavior for Linux routers.}
988           std::list<NdiscCache::Entry *> entryList = ndiscCache->LookupInverse (
      \hyperlink{lte__amc_8m_a1b4c81ff74eb1a626b5ade44c81004b3}{from});
989           std::list<NdiscCache::Entry *>::iterator iter;
990           \textcolor{keywordflow}{for} (iter = entryList.begin (); iter != entryList.end (); iter ++)
991             \{
992               (*iter)->UpdateReachableTimer ();
993             \}
994         \}
995     \}
996 
997 
998 
999   \textcolor{comment}{/* forward up to IPv6 raw sockets */}
1000   \textcolor{keywordflow}{for} (SocketList::iterator it = \hyperlink{classns3_1_1Ipv6L3Protocol_a515e9cba13d7fd95e5613f5c95ccc7b5}{m\_sockets}.begin (); it != \hyperlink{classns3_1_1Ipv6L3Protocol_a515e9cba13d7fd95e5613f5c95ccc7b5}{m\_sockets}.end (); ++it)
1001     \{
1002       Ptr<Ipv6RawSocketImpl> socket = *it;
1003       socket->ForwardUp (packet, hdr, device);
1004     \}
1005 
1006   Ptr<Ipv6ExtensionDemux> ipv6ExtensionDemux = \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv6ExtensionDemux> ();
1007   Ptr<Ipv6Extension> ipv6Extension = 0;
1008   uint8\_t nextHeader = hdr.GetNextHeader ();
1009   \textcolor{keywordtype}{bool} stopProcessing = \textcolor{keyword}{false};
1010   \textcolor{keywordtype}{bool} isDropped = \textcolor{keyword}{false};
1011   \hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37a}{DropReason} dropReason;
1012 
1013   \textcolor{keywordflow}{if} (nextHeader == \hyperlink{classns3_1_1Ipv6Header_a226429221a066c5e3b1f260caf27d1e9aa0413202f88bebb4f91a138e317b6bbd}{Ipv6Header::IPV6\_EXT\_HOP\_BY\_HOP})
1014     \{
1015       ipv6Extension = ipv6ExtensionDemux->GetExtension (nextHeader);
1016 
1017       \textcolor{keywordflow}{if} (ipv6Extension)
1018         \{
1019           ipv6Extension->Process (packet, 0, hdr, hdr.GetDestinationAddress (), (uint8\_t *)0, 
      stopProcessing, isDropped, dropReason);
1020         \}
1021 
1022       \textcolor{keywordflow}{if} (isDropped)
1023         \{
1024           \hyperlink{classns3_1_1Ipv6L3Protocol_ac22d2d63cac436267ae6cafc46880a6e}{m\_dropTrace} (hdr, packet, dropReason, \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->
      \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<\hyperlink{classns3_1_1Ipv6_adccc58acd14d3f9a28f75dc09e794998}{Ipv6}> (), interface);
1025         \}
1026 
1027       \textcolor{keywordflow}{if} (stopProcessing)
1028         \{
1029           \textcolor{keywordflow}{return};
1030         \}
1031     \}
1032 
1033   \textcolor{keywordflow}{if} (hdr.GetDestinationAddress ().IsAllNodesMulticast ())
1034     \{
1035       \hyperlink{classns3_1_1Ipv6L3Protocol_a8e2c7a80851d870812295c19dc908a38}{LocalDeliver} (packet, hdr, interface);
1036       \textcolor{keywordflow}{return};
1037     \}
1038   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (hdr.GetDestinationAddress ().IsAllRoutersMulticast() && ipv6Interface->IsForwarding ())
1039     \{
1040       \hyperlink{classns3_1_1Ipv6L3Protocol_a8e2c7a80851d870812295c19dc908a38}{LocalDeliver} (packet, hdr, interface);
1041       \textcolor{keywordflow}{return};
1042     \}
1043   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (hdr.GetDestinationAddress ().IsMulticast ())
1044     \{
1045       \textcolor{keywordtype}{bool} isSolicited = ipv6Interface->IsSolicitedMulticastAddress (hdr.GetDestinationAddress ());
1046       \textcolor{keywordtype}{bool} isRegisteredOnInterface = \hyperlink{classns3_1_1Ipv6L3Protocol_ad883e42df23aa1fc0fe38a1489830b1a}{IsRegisteredMulticastAddress} (hdr.
      GetDestinationAddress (), interface);
1047       \textcolor{keywordtype}{bool} isRegisteredGlobally = \hyperlink{classns3_1_1Ipv6L3Protocol_ad883e42df23aa1fc0fe38a1489830b1a}{IsRegisteredMulticastAddress} (hdr.
      GetDestinationAddress ());
1048       \textcolor{keywordflow}{if} (isSolicited || isRegisteredGlobally || isRegisteredOnInterface)
1049         \{
1050           \hyperlink{classns3_1_1Ipv6L3Protocol_a8e2c7a80851d870812295c19dc908a38}{LocalDeliver} (packet, hdr, interface);
1051           \textcolor{comment}{// do not return, the packet could be handled by a routing protocol}
1052         \}
1053     \}
1054 
1055 
1056   \textcolor{keywordflow}{for} (uint32\_t j = 0; j < \hyperlink{classns3_1_1Ipv6L3Protocol_a53882c40f6fb32e2a6fe0a7a2858698d}{GetNInterfaces} (); j++)
1057     \{
1058       \textcolor{keywordflow}{if} (j == interface || !\hyperlink{classns3_1_1Ipv6L3Protocol_ac00aee071bc7ab2096efbf8fdc5e3814}{m\_strongEndSystemModel})
1059         \{
1060           \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1Ipv6L3Protocol_a3b09a9f504a311ecc08fdc026d897514}{GetNAddresses} (j); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
1061             \{
1062               Ipv6InterfaceAddress iaddr = \hyperlink{classns3_1_1Ipv6L3Protocol_a0321a9ac3f79b5a7b7542cecf11bfe44}{GetAddress} (j, \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
1063               Ipv6Address addr = iaddr.GetAddress ();
1064               \textcolor{keywordflow}{if} (addr.IsEqual (hdr.GetDestinationAddress ()))
1065                 \{
1066                   \textcolor{keywordflow}{if} (j == interface)
1067                     \{
1068                       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"For me (destination "} << addr << \textcolor{stringliteral}{" match)"});
1069                     \}
1070                   \textcolor{keywordflow}{else}
1071                     \{
1072                       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"For me (destination "} << addr << \textcolor{stringliteral}{" match) on another
       interface "} << hdr.GetDestinationAddress ());
1073                     \}
1074                   \hyperlink{classns3_1_1Ipv6L3Protocol_a8e2c7a80851d870812295c19dc908a38}{LocalDeliver} (packet, hdr, interface);
1075                   \textcolor{keywordflow}{return};
1076                 \}
1077               \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Address "} << addr << \textcolor{stringliteral}{" not a match"});
1078             \}
1079         \}
1080     \}
1081 
1082   \textcolor{keywordflow}{if} (!\hyperlink{classns3_1_1Ipv6L3Protocol_aa0df547e5240b218dc1f4742a2a00117}{m\_routingProtocol}->RouteInput (packet, hdr, device,
1083                                       \hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1Ipv6L3Protocol_ac956e0aaed5e961b6c25210c2b696da6}{Ipv6L3Protocol::IpForward}, \textcolor{keyword}{this}),
1084                                       \hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1Ipv6L3Protocol_aa65d2e4894ea499415227e232e854824}{Ipv6L3Protocol::IpMulticastForward}, \textcolor{keyword}{this}),
1085                                       \hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1Ipv6L3Protocol_a8e2c7a80851d870812295c19dc908a38}{Ipv6L3Protocol::LocalDeliver}, \textcolor{keyword}{this}),
1086                                       \hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1Ipv6L3Protocol_a0cdd2195de560337df8dbe1a412cbaf6}{Ipv6L3Protocol::RouteInputError}, \textcolor{keyword}{this})))
1087     \{
1088       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"No route found for forwarding packet.  Drop."});
1089       \textcolor{comment}{// Drop trace and ICMPs are courtesy of RouteInputError}
1090     \}
1091 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 36




Here is the caller graph for this function\+:
% FIG 37


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Register\+Extensions@{Register\+Extensions}}
\index{Register\+Extensions@{Register\+Extensions}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Register\+Extensions()}{RegisterExtensions()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Register\+Extensions (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a25cb7eac8f79c3461ec50b8464db2f8f}{}\label{classns3_1_1Ipv6L3Protocol_a25cb7eac8f79c3461ec50b8464db2f8f}


Register the I\+Pv6 Extensions. 



Implements \hyperlink{classns3_1_1Ipv6_a57bd0dd1c4b1b9bb63b748124a548fe5}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
1480 \{
1481   Ptr<Ipv6ExtensionDemux> ipv6ExtensionDemux = CreateObject<Ipv6ExtensionDemux> ();
1482   ipv6ExtensionDemux->SetNode (\hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node});
1483 
1484   Ptr<Ipv6ExtensionHopByHop> hopbyhopExtension = CreateObject<Ipv6ExtensionHopByHop> ();
1485   hopbyhopExtension->SetNode (\hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node});
1486   Ptr<Ipv6ExtensionDestination> destinationExtension = CreateObject<Ipv6ExtensionDestination> ();
1487   destinationExtension->SetNode (\hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node});
1488   Ptr<Ipv6ExtensionFragment> fragmentExtension = CreateObject<Ipv6ExtensionFragment> ();
1489   fragmentExtension->SetNode (\hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node});
1490   Ptr<Ipv6ExtensionRouting> routingExtension = CreateObject<Ipv6ExtensionRouting> ();
1491   routingExtension->SetNode (\hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node});
1492   \textcolor{comment}{// Ptr<Ipv6ExtensionESP> espExtension = CreateObject<Ipv6ExtensionESP> ();}
1493   \textcolor{comment}{// Ptr<Ipv6ExtensionAH> ahExtension = CreateObject<Ipv6ExtensionAH> ();}
1494 
1495   ipv6ExtensionDemux->Insert (hopbyhopExtension);
1496   ipv6ExtensionDemux->Insert (destinationExtension);
1497   ipv6ExtensionDemux->Insert (fragmentExtension);
1498   ipv6ExtensionDemux->Insert (routingExtension);
1499   \textcolor{comment}{// ipv6ExtensionDemux->Insert (espExtension);}
1500   \textcolor{comment}{// ipv6ExtensionDemux->Insert (ahExtension);}
1501 
1502   Ptr<Ipv6ExtensionRoutingDemux> routingExtensionDemux = CreateObject<Ipv6ExtensionRoutingDemux> ();
1503   routingExtensionDemux->SetNode (\hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node});
1504   Ptr<Ipv6ExtensionLooseRouting> looseRoutingExtension = CreateObject<Ipv6ExtensionLooseRouting> ();
1505   looseRoutingExtension->SetNode (\hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node});
1506   routingExtensionDemux->Insert (looseRoutingExtension);
1507 
1508   \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->\hyperlink{classns3_1_1Object_a79dd435d300f3deca814553f561a2922}{AggregateObject} (routingExtensionDemux);
1509   \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->\hyperlink{classns3_1_1Object_a79dd435d300f3deca814553f561a2922}{AggregateObject} (ipv6ExtensionDemux);
1510 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 38




Here is the caller graph for this function\+:
% FIG 39


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Register\+Options@{Register\+Options}}
\index{Register\+Options@{Register\+Options}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Register\+Options()}{RegisterOptions()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Register\+Options (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_ac9c52b73b294e0b592a5034b87278d92}{}\label{classns3_1_1Ipv6L3Protocol_ac9c52b73b294e0b592a5034b87278d92}


Register the I\+Pv6 Options. 



Implements \hyperlink{classns3_1_1Ipv6_a95905b14fff6edf0c4de70f47f6312cb}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
1513 \{
1514   Ptr<Ipv6OptionDemux> ipv6OptionDemux = CreateObject<Ipv6OptionDemux> ();
1515   ipv6OptionDemux->SetNode (\hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node});
1516 
1517   Ptr<Ipv6OptionPad1> pad1Option = CreateObject<Ipv6OptionPad1> ();
1518   pad1Option->SetNode (\hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node});
1519   Ptr<Ipv6OptionPadn> padnOption = CreateObject<Ipv6OptionPadn> ();
1520   padnOption->SetNode (\hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node});
1521   Ptr<Ipv6OptionJumbogram> jumbogramOption = CreateObject<Ipv6OptionJumbogram> ();
1522   jumbogramOption->SetNode (\hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node});
1523   Ptr<Ipv6OptionRouterAlert> routerAlertOption = CreateObject<Ipv6OptionRouterAlert> ();
1524   routerAlertOption->SetNode (\hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node});
1525 
1526   ipv6OptionDemux->Insert (pad1Option);
1527   ipv6OptionDemux->Insert (padnOption);
1528   ipv6OptionDemux->Insert (jumbogramOption);
1529   ipv6OptionDemux->Insert (routerAlertOption);
1530 
1531   \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->\hyperlink{classns3_1_1Object_a79dd435d300f3deca814553f561a2922}{AggregateObject} (ipv6OptionDemux);
1532 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 40




Here is the caller graph for this function\+:
% FIG 41


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Remove@{Remove}}
\index{Remove@{Remove}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Remove(\+Ptr$<$ Ip\+L4\+Protocol $>$ protocol)}{Remove(Ptr< IpL4Protocol > protocol)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Remove (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ip\+L4\+Protocol} $>$}]{protocol}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a70024f0b3f0cca53815ddf98eb49176a}{}\label{classns3_1_1Ipv6L3Protocol_a70024f0b3f0cca53815ddf98eb49176a}


Remove a L4 protocol. 


\begin{DoxyParams}{Parameters}
{\em protocol} & L4 protocol to remove. \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6_abb09312c165a45923cd88061a3be2c82}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
741 \{
742   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << protocol);
743 
744   \hyperlink{classns3_1_1Ipv6L3Protocol_ade8066a20a3494dbda177322b1d18c21}{L4ListKey\_t} key = std::make\_pair (protocol->GetProtocolNumber (), -1);
745   L4List\_t::iterator iter = \hyperlink{classns3_1_1Ipv6L3Protocol_a5a68c54b92d81f93c41983ebdc0ef5b3}{m\_protocols}.find (key);
746   \textcolor{keywordflow}{if} (iter == \hyperlink{classns3_1_1Ipv6L3Protocol_a5a68c54b92d81f93c41983ebdc0ef5b3}{m\_protocols}.end ())
747     \{
748       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Trying to remove an non-existent default protocol "} << \textcolor{keywordtype}{int}(protocol->
      GetProtocolNumber ()));
749     \}
750   \textcolor{keywordflow}{else}
751     \{
752       \hyperlink{classns3_1_1Ipv6L3Protocol_a5a68c54b92d81f93c41983ebdc0ef5b3}{m\_protocols}.erase (key);
753     \}
754 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Remove@{Remove}}
\index{Remove@{Remove}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Remove(\+Ptr$<$ Ip\+L4\+Protocol $>$ protocol, uint32\+\_\+t interface\+Index)}{Remove(Ptr< IpL4Protocol > protocol, uint32_t interfaceIndex)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Remove (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ip\+L4\+Protocol} $>$}]{protocol, }
\item[{uint32\+\_\+t}]{interface\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a2119b6e87a951156aec7a93199bf2b19}{}\label{classns3_1_1Ipv6L3Protocol_a2119b6e87a951156aec7a93199bf2b19}


Remove a L4 protocol from a specific interface. 


\begin{DoxyParams}{Parameters}
{\em protocol} & L4 protocol to remove. \\
\hline
{\em interface\+Index} & interface index. \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6_ac8f460ea4a38988cbc80b91a14e45912}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
757 \{
758   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << protocol << interfaceIndex);
759 
760   \hyperlink{classns3_1_1Ipv6L3Protocol_ade8066a20a3494dbda177322b1d18c21}{L4ListKey\_t} key = std::make\_pair (protocol->GetProtocolNumber (), interfaceIndex);
761   L4List\_t::iterator iter = \hyperlink{classns3_1_1Ipv6L3Protocol_a5a68c54b92d81f93c41983ebdc0ef5b3}{m\_protocols}.find (key);
762   \textcolor{keywordflow}{if} (iter == \hyperlink{classns3_1_1Ipv6L3Protocol_a5a68c54b92d81f93c41983ebdc0ef5b3}{m\_protocols}.end ())
763     \{
764       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Trying to remove an non-existent protocol "} << \textcolor{keywordtype}{int}(protocol->
      GetProtocolNumber ()) << \textcolor{stringliteral}{" on interface "} << \textcolor{keywordtype}{int}(interfaceIndex));
765     \}
766   \textcolor{keywordflow}{else}
767     \{
768       \hyperlink{classns3_1_1Ipv6L3Protocol_a5a68c54b92d81f93c41983ebdc0ef5b3}{m\_protocols}.erase (key);
769     \}
770 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Remove\+Address@{Remove\+Address}}
\index{Remove\+Address@{Remove\+Address}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Remove\+Address(uint32\+\_\+t interface\+Index, uint32\+\_\+t address\+Index)}{RemoveAddress(uint32_t interfaceIndex, uint32_t addressIndex)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv6\+L3\+Protocol\+::\+Remove\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface\+Index, }
\item[{uint32\+\_\+t}]{address\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a6e955b0de62f2c28fea71108e8df2545}{}\label{classns3_1_1Ipv6L3Protocol_a6e955b0de62f2c28fea71108e8df2545}


Remove an address from an interface. 


\begin{DoxyParams}{Parameters}
{\em interface\+Index} & interface index \\
\hline
{\em address\+Index} & address index on the interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the operation succeeded 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv6_ad1e1c4d33ad96a76683ce8cea9d01780}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
440 \{
441   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} << addressIndex);
442   Ptr<Ipv6Interface> \textcolor{keyword}{interface }= GetInterface (i);
443   Ipv6InterfaceAddress address = interface->RemoveAddress (addressIndex);
444 
445   \textcolor{keywordflow}{if} (address != Ipv6InterfaceAddress ())
446     \{
447       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6L3Protocol_aa0df547e5240b218dc1f4742a2a00117}{m\_routingProtocol} != 0)
448         \{
449           \hyperlink{classns3_1_1Ipv6L3Protocol_aa0df547e5240b218dc1f4742a2a00117}{m\_routingProtocol}->NotifyRemoveAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, address);
450         \}
451       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
452     \}
453   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
454 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 42


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Remove\+Address@{Remove\+Address}}
\index{Remove\+Address@{Remove\+Address}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Remove\+Address(uint32\+\_\+t interface\+Index, Ipv6\+Address address)}{RemoveAddress(uint32_t interfaceIndex, Ipv6Address address)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv6\+L3\+Protocol\+::\+Remove\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface\+Index, }
\item[{{\bf Ipv6\+Address}}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a7e3a0ee9e79a09f208285e4f788ad4ed}{}\label{classns3_1_1Ipv6L3Protocol_a7e3a0ee9e79a09f208285e4f788ad4ed}


Remove a specified \hyperlink{classns3_1_1Ipv6}{Ipv6} address from an interface. 


\begin{DoxyParams}{Parameters}
{\em interface\+Index} & interface index \\
\hline
{\em address} & \hyperlink{classns3_1_1Ipv6Address}{Ipv6\+Address} to be removed from the interface \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the operation succeeded 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv6_a29f451acbf047880073add4d0bd40550}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
458 \{
459   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} << address);
460 
461   \textcolor{keywordflow}{if} (address == \hyperlink{classns3_1_1Ipv6Address_af62754355f28fadc671584dd02cd79b7}{Ipv6Address::GetLoopback}())
462     \{
463       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"Cannot remove loopback address."});
464       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
465     \}
466   Ptr<Ipv6Interface> \textcolor{keyword}{interface }= GetInterface (i);
467   Ipv6InterfaceAddress ifAddr = interface->RemoveAddress (address);
468   \textcolor{keywordflow}{if} (ifAddr != Ipv6InterfaceAddress ())
469   \{
470     \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6L3Protocol_aa0df547e5240b218dc1f4742a2a00117}{m\_routingProtocol} != 0)
471     \{
472       \hyperlink{classns3_1_1Ipv6L3Protocol_aa0df547e5240b218dc1f4742a2a00117}{m\_routingProtocol}->NotifyRemoveAddress (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}, ifAddr);
473     \}
474     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
475   \}
476   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
477 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 43


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Remove\+Autoconfigured\+Address@{Remove\+Autoconfigured\+Address}}
\index{Remove\+Autoconfigured\+Address@{Remove\+Autoconfigured\+Address}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Remove\+Autoconfigured\+Address(uint32\+\_\+t interface, Ipv6\+Address network, Ipv6\+Prefix mask, Ipv6\+Address default\+Router)}{RemoveAutoconfiguredAddress(uint32_t interface, Ipv6Address network, Ipv6Prefix mask, Ipv6Address defaultRouter)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Remove\+Autoconfigured\+Address (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv6\+Address}}]{network, }
\item[{{\bf Ipv6\+Prefix}}]{mask, }
\item[{{\bf Ipv6\+Address}}]{default\+Router}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6L3Protocol_a6e8db427dbb1dfcaeecee8a6d793e94a}{}\label{classns3_1_1Ipv6L3Protocol_a6e8db427dbb1dfcaeecee8a6d793e94a}


Remove an autoconfigured address. 

Typically it is used when an autoconfigured address expires. 
\begin{DoxyParams}{Parameters}
{\em interface} & interface index \\
\hline
{\em network} & network prefix \\
\hline
{\em mask} & network mask \\
\hline
{\em default\+Router} & gateway \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
363 \{
364   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << interface << network << mask);
365   Ptr<Ipv6Interface> iface = \hyperlink{classns3_1_1Ipv6L3Protocol_a2e53b72d76bceb713f2d3cb54e24f5a1}{GetInterface} (interface);
366   Address addr = iface->GetDevice ()->GetAddress ();
367   uint32\_t \hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{max} = iface->GetNAddresses ();
368   uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0;
369   Ipv6Address toFound;
370 
371   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Mac64Address_a50014d1350f72b89857f0262be927073}{Mac64Address::IsMatchingType} (addr))
372     \{
373       toFound = \hyperlink{classns3_1_1Ipv6Address_a74e6a79f61e9edd0ebdbafb4db88dc35}{Ipv6Address::MakeAutoconfiguredAddress} (
      \hyperlink{classns3_1_1Mac64Address_a9d73aef28cf6b6edf423b418ce014b10}{Mac64Address::ConvertFrom} (addr), network);
374     \}
375   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Mac48Address_a55cc1e3c6aa63fd1a4f8f7d9be4ae182}{Mac48Address::IsMatchingType} (addr))
376     \{
377       toFound = \hyperlink{classns3_1_1Ipv6Address_a74e6a79f61e9edd0ebdbafb4db88dc35}{Ipv6Address::MakeAutoconfiguredAddress} (
      \hyperlink{classns3_1_1Mac48Address_a911ce13603a9ef837545a032b6523ae4}{Mac48Address::ConvertFrom} (addr), network);
378     \}
379   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Mac16Address_a2d7aa9e24afc8e02a25ab449b0b99b1f}{Mac16Address::IsMatchingType} (addr))
380     \{
381       toFound = \hyperlink{classns3_1_1Ipv6Address_a74e6a79f61e9edd0ebdbafb4db88dc35}{Ipv6Address::MakeAutoconfiguredAddress} (
      \hyperlink{classns3_1_1Mac16Address_a6822cde696a7be24782dc8e1de2f1449}{Mac16Address::ConvertFrom} (addr), network);
382     \}
383   \textcolor{keywordflow}{else}
384     \{
385       \hyperlink{group__fatal_ga5131d5e3f75d7d4cbfd706ac456fdc85}{NS\_FATAL\_ERROR} (\textcolor{stringliteral}{"Unknown method to make autoconfigured address for this kind of device.
      "});
386       \textcolor{keywordflow}{return};
387     \}
388 
389   \textcolor{keywordflow}{for} (i = 0; i < \hyperlink{80211b_8c_affe776513b24d84b39af8ab0930fef7f}{max}; i++)
390     \{
391       \textcolor{keywordflow}{if} (iface->GetAddress (i).GetAddress () == toFound)
392         \{
393           \hyperlink{classns3_1_1Ipv6L3Protocol_a6e955b0de62f2c28fea71108e8df2545}{RemoveAddress} (interface, i);
394           \textcolor{keywordflow}{break};
395         \}
396     \}
397 
398   \textcolor{comment}{/* remove from list of autoconfigured address */}
399   \textcolor{keywordflow}{for} (\hyperlink{classns3_1_1Ipv6L3Protocol_af00957df9fbda1b1427ad41dd788b99a}{Ipv6AutoconfiguredPrefixListI} it = 
      \hyperlink{classns3_1_1Ipv6L3Protocol_a402d76e60e8ac25eeb200d2b288732c0}{m\_prefixes}.begin (); it != \hyperlink{classns3_1_1Ipv6L3Protocol_a402d76e60e8ac25eeb200d2b288732c0}{m\_prefixes}.end (); ++it)
400     \{
401       \textcolor{keywordflow}{if} ((*it)->GetInterface () == \textcolor{keyword}{interface }&& (*it)->GetPrefix () == network && (*it)->GetMask () == 
      mask)
402         \{
403           *it = 0;
404           \hyperlink{classns3_1_1Ipv6L3Protocol_a402d76e60e8ac25eeb200d2b288732c0}{m\_prefixes}.erase (it);
405           \textcolor{keywordflow}{break};
406         \}
407     \}
408 
409   \hyperlink{classns3_1_1Ipv6L3Protocol_aea90446045bb78b99b150ef1dd9afdb4}{GetRoutingProtocol} ()->NotifyRemoveRoute (
      \hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} (), Ipv6Prefix ((uint8\_t)0), defaultRouter, interface, network);
410 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 44


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Remove\+Multicast\+Address@{Remove\+Multicast\+Address}}
\index{Remove\+Multicast\+Address@{Remove\+Multicast\+Address}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Remove\+Multicast\+Address(\+Ipv6\+Address address)}{RemoveMulticastAddress(Ipv6Address address)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Remove\+Multicast\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{address}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6L3Protocol_a989f80923c9a36329391c932c66eb023}{}\label{classns3_1_1Ipv6L3Protocol_a989f80923c9a36329391c932c66eb023}
Removes a multicast address from the list of addresses to pass to local deliver. 
\begin{DoxyParams}{Parameters}
{\em address} & the address. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1580 \{
1581   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (address);
1582 
1583   \hyperlink{classns3_1_1Ipv6L3Protocol_a4b31a418ae742bed8835981afb433b1c}{m\_multicastAddressesNoInterface}[address]--;
1584   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6L3Protocol_a4b31a418ae742bed8835981afb433b1c}{m\_multicastAddressesNoInterface}[address] == 0)
1585     \{
1586       \hyperlink{classns3_1_1Ipv6L3Protocol_a4b31a418ae742bed8835981afb433b1c}{m\_multicastAddressesNoInterface}.erase (address);
1587     \}
1588 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Remove\+Multicast\+Address@{Remove\+Multicast\+Address}}
\index{Remove\+Multicast\+Address@{Remove\+Multicast\+Address}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Remove\+Multicast\+Address(\+Ipv6\+Address address, uint32\+\_\+t interface)}{RemoveMulticastAddress(Ipv6Address address, uint32_t interface)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Remove\+Multicast\+Address (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{address, }
\item[{uint32\+\_\+t}]{interface}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6L3Protocol_a8d44abee229e1b89199fc7f1dec1919a}{}\label{classns3_1_1Ipv6L3Protocol_a8d44abee229e1b89199fc7f1dec1919a}
Removes a multicast address from the list of addresses to pass to local deliver. 
\begin{DoxyParams}{Parameters}
{\em address} & the address. \\
\hline
{\em interface} & the incoming interface. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1567 \{
1568   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (address << interface);
1569 
1570   \hyperlink{classns3_1_1Ipv6L3Protocol_ad85035c0604805049efdc7a5b3d99082}{Ipv6RegisteredMulticastAddressKey\_t} key = std::make\_pair (address, 
      interface);
1571 
1572   \hyperlink{classns3_1_1Ipv6L3Protocol_a6d7573453cf2a73d44bfb2d68eed19c4}{m\_multicastAddresses}[key]--;
1573   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6L3Protocol_a6d7573453cf2a73d44bfb2d68eed19c4}{m\_multicastAddresses}[key] == 0)
1574     \{
1575       \hyperlink{classns3_1_1Ipv6L3Protocol_a6d7573453cf2a73d44bfb2d68eed19c4}{m\_multicastAddresses}.erase (key);
1576     \}
1577 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Report\+Drop@{Report\+Drop}}
\index{Report\+Drop@{Report\+Drop}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Report\+Drop(\+Ipv6\+Header ip\+Header, Ptr$<$ Packet $>$ p, Drop\+Reason drop\+Reason)}{ReportDrop(Ipv6Header ipHeader, Ptr< Packet > p, DropReason dropReason)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Report\+Drop (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Header}}]{ip\+Header, }
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{p, }
\item[{{\bf Drop\+Reason}}]{drop\+Reason}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a65592c538120dd1b628727c1fae71bcf}{}\label{classns3_1_1Ipv6L3Protocol_a65592c538120dd1b628727c1fae71bcf}


Report a packet drop. 

This function is used by Fragment Timeout handling to signal a fragment drop.


\begin{DoxyParams}{Parameters}
{\em ip\+Header} & the I\+Pv6 header of dropped packet \\
\hline
{\em p} & the packet (if available) \\
\hline
{\em drop\+Reason} & the drop reason \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1535 \{
1536   \hyperlink{classns3_1_1Ipv6L3Protocol_ac22d2d63cac436267ae6cafc46880a6e}{m\_dropTrace} (ipHeader, p, dropReason, \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<
      \hyperlink{classns3_1_1Ipv6_adccc58acd14d3f9a28f75dc09e794998}{Ipv6}> (), 0);
1537 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 45


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Route\+Input\+Error@{Route\+Input\+Error}}
\index{Route\+Input\+Error@{Route\+Input\+Error}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Route\+Input\+Error(\+Ptr$<$ const Packet $>$ p, const Ipv6\+Header \&ip\+Header, Socket\+::\+Socket\+Errno sock\+Errno)}{RouteInputError(Ptr< const Packet > p, const Ipv6Header &ipHeader, Socket::SocketErrno sockErrno)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Route\+Input\+Error (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ const {\bf Packet} $>$}]{p, }
\item[{const {\bf Ipv6\+Header} \&}]{ip\+Header, }
\item[{{\bf Socket\+::\+Socket\+Errno}}]{sock\+Errno}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a0cdd2195de560337df8dbe1a412cbaf6}{}\label{classns3_1_1Ipv6L3Protocol_a0cdd2195de560337df8dbe1a412cbaf6}


Fallback when no route is found. 


\begin{DoxyParams}{Parameters}
{\em p} & packet \\
\hline
{\em ip\+Header} & I\+Pv6 header \\
\hline
{\em sock\+Errno} & error number \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1451 \{
1452   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p} << ipHeader << sockErrno);
1453   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Route input failure-- dropping packet to "} << ipHeader << \textcolor{stringliteral}{" with errno "} << 
      sockErrno);
1454 
1455   \hyperlink{classns3_1_1Ipv6L3Protocol_ac22d2d63cac436267ae6cafc46880a6e}{m\_dropTrace} (ipHeader, \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}, \hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa3690e9264e4d2307050512b833df4946}{DROP\_ROUTE\_ERROR}, \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->
      \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<\hyperlink{classns3_1_1Ipv6_adccc58acd14d3f9a28f75dc09e794998}{Ipv6}> (), 0);
1456 
1457   \textcolor{keywordflow}{if} (!ipHeader.GetDestinationAddress ().IsMulticast ())
1458     \{
1459       Ptr<Packet> packet = \hyperlink{lte__link__budget_8m_ac9de518908a968428863f829398a4e62}{p}->Copy ();
1460       packet->AddHeader (ipHeader);
1461       \hyperlink{classns3_1_1Ipv6L3Protocol_a10384a4dc85c61e65cf73b47ec9da90d}{GetIcmpv6} ()->SendErrorDestinationUnreachable (packet, ipHeader.GetSourceAddress (), 
      \hyperlink{classns3_1_1Icmpv6Header_a2609b9581c3de3d6bbf8d55f5adf0d1da87eecfb727188f14485806388ca7839a}{Icmpv6Header::ICMPV6\_NO\_ROUTE});
1462     \}
1463 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 46




Here is the caller graph for this function\+:
% FIG 47


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Send@{Send}}
\index{Send@{Send}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Send(\+Ptr$<$ Packet $>$ packet, Ipv6\+Address source, Ipv6\+Address destination, uint8\+\_\+t protocol, Ptr$<$ Ipv6\+Route $>$ route)}{Send(Ptr< Packet > packet, Ipv6Address source, Ipv6Address destination, uint8_t protocol, Ptr< Ipv6Route > route)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Send (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Ipv6\+Address}}]{source, }
\item[{{\bf Ipv6\+Address}}]{destination, }
\item[{uint8\+\_\+t}]{protocol, }
\item[{{\bf Ptr}$<$ {\bf Ipv6\+Route} $>$}]{route}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_ac281dd6c5aff55330904e7a298c1881b}{}\label{classns3_1_1Ipv6L3Protocol_ac281dd6c5aff55330904e7a298c1881b}


Higher-\/level layers call this method to send a packet down the stack to the M\+AC and P\+HY layers. 


\begin{DoxyParams}{Parameters}
{\em packet} & packet to send \\
\hline
{\em source} & source address of packet \\
\hline
{\em destination} & address of packet \\
\hline
{\em protocol} & number of packet \\
\hline
{\em route} & route to take \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6_a2aad308983b20eb54334bb0d3db31004}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
857 \{
858   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << packet << source << destination << (uint32\_t)protocol << route);
859   Ipv6Header hdr;
860   uint8\_t ttl = \hyperlink{classns3_1_1Ipv6L3Protocol_a2857858d48a3ce4f6bc1912d721825b7}{m\_defaultTtl};
861   SocketIpv6HopLimitTag tag;
862   \textcolor{keywordtype}{bool} found = packet->\hyperlink{classns3_1_1Packet_a078fe922d976a417ab25ba2f3c2fd667}{RemovePacketTag} (tag);
863 
864   \textcolor{keywordflow}{if} (found)
865     \{
866       ttl = tag.GetHopLimit ();
867     \}
868 
869   SocketIpv6TclassTag tclassTag;
870   uint8\_t tclass = \hyperlink{classns3_1_1Ipv6L3Protocol_a0ead80eb6fa685c54dc155dff9157345}{m\_defaultTclass};
871   found = packet->\hyperlink{classns3_1_1Packet_a078fe922d976a417ab25ba2f3c2fd667}{RemovePacketTag} (tclassTag);
872   
873   \textcolor{keywordflow}{if} (found)
874     \{
875       tclass = tclassTag.GetTclass ();
876     \}
877 
878   \textcolor{comment}{/* Handle 3 cases:}
879 \textcolor{comment}{   * 1) Packet is passed in with a route entry}
880 \textcolor{comment}{   * 2) Packet is passed in with a route entry but route->GetGateway is not set (e.g., same network)}
881 \textcolor{comment}{   * 3) route is NULL (e.g., a raw socket call or ICMPv6)}
882 \textcolor{comment}{   */}
883 
884   \textcolor{comment}{/* 1) */}
885   \textcolor{keywordflow}{if} (route && route->GetGateway () != \hyperlink{classns3_1_1Ipv6Address_a63a34bdb1505e05fbdd07d316d0bd7e6}{Ipv6Address::GetZero} ())
886     \{
887       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Ipv6L3Protocol::Send case 1: passed in with a route"});
888       hdr = \hyperlink{classns3_1_1Ipv6L3Protocol_a5374a6687ad09cfcd48ef13a99b48d16}{BuildHeader} (source, destination, protocol, packet->
      \hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} (), ttl, tclass);
889       int32\_t \textcolor{keyword}{interface }= \hyperlink{classns3_1_1Ipv6L3Protocol_a878292513d6294e2dfdeccbe1ed1d996}{GetInterfaceForDevice} (route->GetOutputDevice ());
890       \hyperlink{classns3_1_1Ipv6L3Protocol_aac1ff242aa91275202e37cf7d805eec8}{m\_sendOutgoingTrace} (hdr, packet, interface);
891       \hyperlink{classns3_1_1Ipv6L3Protocol_adad363af4c50cd94505b918b15f228d4}{SendRealOut} (route, packet, hdr);
892       \textcolor{keywordflow}{return};
893     \}
894 
895   \textcolor{comment}{/* 2) */}
896   \textcolor{keywordflow}{if} (route && route->GetGateway () == \hyperlink{classns3_1_1Ipv6Address_a63a34bdb1505e05fbdd07d316d0bd7e6}{Ipv6Address::GetZero} ())
897     \{
898       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Ipv6L3Protocol::Send case 1: probably sent to machine on same IPv6 network
      "});
899       \textcolor{comment}{/* NS\_FATAL\_ERROR ("This case is not yet implemented"); */}
900       hdr = \hyperlink{classns3_1_1Ipv6L3Protocol_a5374a6687ad09cfcd48ef13a99b48d16}{BuildHeader} (source, destination, protocol, packet->
      \hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} (), ttl, tclass);
901       int32\_t \textcolor{keyword}{interface }= \hyperlink{classns3_1_1Ipv6L3Protocol_a878292513d6294e2dfdeccbe1ed1d996}{GetInterfaceForDevice} (route->GetOutputDevice ());
902       \hyperlink{classns3_1_1Ipv6L3Protocol_aac1ff242aa91275202e37cf7d805eec8}{m\_sendOutgoingTrace} (hdr, packet, interface);
903       \hyperlink{classns3_1_1Ipv6L3Protocol_adad363af4c50cd94505b918b15f228d4}{SendRealOut} (route, packet, hdr);
904       \textcolor{keywordflow}{return};
905     \}
906 
907   \textcolor{comment}{/* 3) */}
908   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Ipv6L3Protocol::Send case 3: passed in with no route "} << destination);
909   \hyperlink{classns3_1_1Socket_ada1328c5ae0c28cb2a982caf8f6d6cca}{Socket::SocketErrno} err;
910   Ptr<NetDevice> oif (0);
911   Ptr<Ipv6Route> newRoute = 0;
912 
913   hdr = \hyperlink{classns3_1_1Ipv6L3Protocol_a5374a6687ad09cfcd48ef13a99b48d16}{BuildHeader} (source, destination, protocol, packet->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} (), ttl, tclass);
914 
915   \textcolor{comment}{//for link-local traffic, we need to determine the interface}
916   \textcolor{keywordflow}{if} (source.IsLinkLocal ()
917       || destination.IsLinkLocal ()
918       || destination.IsLinkLocalMulticast ())
919     \{
920       int32\_t index = \hyperlink{classns3_1_1Ipv6L3Protocol_ae8d652431e374e8b05425ae9e1bf0f1b}{GetInterfaceForAddress} (source);
921       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (index >= 0, \textcolor{stringliteral}{"Can not find an outgoing interface for a packet with src "} 
      << source << \textcolor{stringliteral}{" and dst "} << destination);
922       oif = \hyperlink{classns3_1_1Ipv6L3Protocol_a574d1beafc86062acf582e75dc437a47}{GetNetDevice} (index);
923     \}
924 
925   newRoute = \hyperlink{classns3_1_1Ipv6L3Protocol_aa0df547e5240b218dc1f4742a2a00117}{m\_routingProtocol}->RouteOutput (packet, hdr, oif, err);
926 
927   \textcolor{keywordflow}{if} (newRoute)
928     \{
929       int32\_t \textcolor{keyword}{interface }= \hyperlink{classns3_1_1Ipv6L3Protocol_a878292513d6294e2dfdeccbe1ed1d996}{GetInterfaceForDevice} (newRoute->GetOutputDevice ());
930       \hyperlink{classns3_1_1Ipv6L3Protocol_aac1ff242aa91275202e37cf7d805eec8}{m\_sendOutgoingTrace} (hdr, packet, interface);
931       \hyperlink{classns3_1_1Ipv6L3Protocol_adad363af4c50cd94505b918b15f228d4}{SendRealOut} (newRoute, packet, hdr);
932     \}
933   \textcolor{keywordflow}{else}
934     \{
935       \hyperlink{group__logging_gade7208b4009cdf0e25783cd26766f559}{NS\_LOG\_WARN} (\textcolor{stringliteral}{"No route to host, drop!"});
936       \hyperlink{classns3_1_1Ipv6L3Protocol_ac22d2d63cac436267ae6cafc46880a6e}{m\_dropTrace} (hdr, packet, \hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa97de4f69c19b2f94b684448beee892f4}{DROP\_NO\_ROUTE}, \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->
      \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<\hyperlink{classns3_1_1Ipv6_adccc58acd14d3f9a28f75dc09e794998}{Ipv6}> (), \hyperlink{classns3_1_1Ipv6L3Protocol_a878292513d6294e2dfdeccbe1ed1d996}{GetInterfaceForDevice} (oif));
937     \}
938 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 48


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Send\+Real\+Out@{Send\+Real\+Out}}
\index{Send\+Real\+Out@{Send\+Real\+Out}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Send\+Real\+Out(\+Ptr$<$ Ipv6\+Route $>$ route, Ptr$<$ Packet $>$ packet, Ipv6\+Header const \&ip\+Header)}{SendRealOut(Ptr< Ipv6Route > route, Ptr< Packet > packet, Ipv6Header const &ipHeader)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Send\+Real\+Out (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv6\+Route} $>$}]{route, }
\item[{{\bf Ptr}$<$ {\bf Packet} $>$}]{packet, }
\item[{{\bf Ipv6\+Header} const \&}]{ip\+Header}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_adad363af4c50cd94505b918b15f228d4}{}\label{classns3_1_1Ipv6L3Protocol_adad363af4c50cd94505b918b15f228d4}


Send packet with route. 


\begin{DoxyParams}{Parameters}
{\em route} & route \\
\hline
{\em packet} & packet to send \\
\hline
{\em ip\+Header} & I\+Pv6 header to add to the packet \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1103 \{
1104   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << route << packet << ipHeader);
1105 
1106   \textcolor{keywordflow}{if} (!route)
1107     \{
1108       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"No route to host, drop!."});
1109       \textcolor{keywordflow}{return};
1110     \}
1111 
1112   Ptr<NetDevice> dev = route->GetOutputDevice ();
1113   int32\_t \textcolor{keyword}{interface }= GetInterfaceForDevice (dev);
1114   \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (interface >= 0);
1115 
1116   Ptr<Ipv6Interface> outInterface = \hyperlink{classns3_1_1Ipv6L3Protocol_a2e53b72d76bceb713f2d3cb54e24f5a1}{GetInterface} (interface);
1117   \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Send via NetDevice ifIndex "} << dev->GetIfIndex () << \textcolor{stringliteral}{" Ipv6InterfaceIndex "} <
      < interface);
1118 
1119   \textcolor{comment}{// Check packet size}
1120   std::list<Ipv6ExtensionFragment::Ipv6PayloadHeaderPair> fragments;
1121 
1122   \textcolor{comment}{// Check if we have a Path MTU stored. If so, use it. Else, use the link MTU.}
1123   \textcolor{keywordtype}{size\_t} targetMtu = (size\_t)(\hyperlink{classns3_1_1Ipv6L3Protocol_a03a839bfaf9ae8763a58a42e60b08ec5}{m\_pmtuCache}->GetPmtu (ipHeader.GetDestinationAddress()));
1124   \textcolor{keywordflow}{if} (targetMtu == 0)
1125     \{
1126       targetMtu = dev->GetMtu ();
1127     \}
1128 
1129   \textcolor{keywordflow}{if} (packet->\hyperlink{classns3_1_1Packet_a462855c9929954d4301a4edfe55f4f1c}{GetSize} () > targetMtu + 40) \textcolor{comment}{/* 40 => size of IPv6 header */}
1130     \{
1131       \textcolor{comment}{// Router => drop}
1132 
1133       \textcolor{keywordtype}{bool} fromMe = \textcolor{keyword}{false};
1134       \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}=0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}<\hyperlink{classns3_1_1Ipv6L3Protocol_a53882c40f6fb32e2a6fe0a7a2858698d}{GetNInterfaces}(); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++ )
1135         \{
1136           \textcolor{keywordflow}{for} (uint32\_t j=0; j<\hyperlink{classns3_1_1Ipv6L3Protocol_a3b09a9f504a311ecc08fdc026d897514}{GetNAddresses}(\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}); j++ )
1137             \{
1138               \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6L3Protocol_a0321a9ac3f79b5a7b7542cecf11bfe44}{GetAddress}(\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i},j).\hyperlink{classns3_1_1Ipv6InterfaceAddress_a80d4caacff72bddc3045a5929519e107}{GetAddress}() == ipHeader.GetSourceAddress())
1139                 \{
1140                   fromMe = \textcolor{keyword}{true};
1141                   \textcolor{keywordflow}{break};
1142                 \}
1143             \}
1144         \}
1145       \textcolor{keywordflow}{if} (!fromMe)
1146         \{
1147           Ptr<Icmpv6L4Protocol> icmpv6 = \hyperlink{classns3_1_1Ipv6L3Protocol_a10384a4dc85c61e65cf73b47ec9da90d}{GetIcmpv6} ();
1148           \textcolor{keywordflow}{if} ( icmpv6 )
1149             \{
1150               packet->\hyperlink{classns3_1_1Packet_a465108c595a0bc592095cbcab1832ed8}{AddHeader}(ipHeader);
1151               icmpv6->SendErrorTooBig (packet, ipHeader.GetSourceAddress (), dev->GetMtu ());
1152             \}
1153           \textcolor{keywordflow}{return};
1154         \}
1155 
1156       Ptr<Ipv6ExtensionDemux> ipv6ExtensionDemux = \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<Ipv6ExtensionDemux> ();
1157 
1158       \textcolor{comment}{// To get specific method GetFragments from Ipv6ExtensionFragmentation}
1159       Ipv6ExtensionFragment *ipv6Fragment = \textcolor{keyword}{dynamic\_cast<}Ipv6ExtensionFragment *\textcolor{keyword}{>} (
      \hyperlink{namespacens3_af2a7557fe9afdd98d8f6f8f6e412cf5a}{PeekPointer} (ipv6ExtensionDemux->GetExtension (
      \hyperlink{classns3_1_1Ipv6Header_a226429221a066c5e3b1f260caf27d1e9a5839daf3fdfb16dfdc94a208ca6ebc5a}{Ipv6Header::IPV6\_EXT\_FRAGMENTATION})));
1160       \hyperlink{assert_8h_a6dccdb0de9b252f60088ce281c49d052}{NS\_ASSERT} (ipv6Fragment != 0);
1161       ipv6Fragment->GetFragments (packet, ipHeader, targetMtu, fragments);
1162     \}
1163 
1164   \textcolor{keywordflow}{if} (!route->GetGateway ().IsEqual (\hyperlink{classns3_1_1Ipv6Address_a2783e8badfc98c8b0a8508bba6e1b91e}{Ipv6Address::GetAny} ()))
1165     \{
1166       \textcolor{keywordflow}{if} (outInterface->IsUp ())
1167         \{
1168           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Send to gateway "} << route->GetGateway ());
1169 
1170           \textcolor{keywordflow}{if} (fragments.size () != 0)
1171             \{
1172               std::ostringstream oss;
1173 
1174               \textcolor{keywordflow}{for} (std::list<Ipv6ExtensionFragment::Ipv6PayloadHeaderPair>::const\_iterator it = fragments.
      begin (); it != fragments.end (); it++)
1175                 \{
1176                   \hyperlink{classns3_1_1Ipv6L3Protocol_a40e29e34a97639ad1caad6b64e732454}{CallTxTrace} (it->second, it->first, \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->
      \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<\hyperlink{classns3_1_1Ipv6_adccc58acd14d3f9a28f75dc09e794998}{Ipv6}> (), interface);
1177                   outInterface->Send (it->first, it->second, route->GetGateway ());
1178                 \}
1179             \}
1180           \textcolor{keywordflow}{else}
1181             \{
1182               \hyperlink{classns3_1_1Ipv6L3Protocol_a40e29e34a97639ad1caad6b64e732454}{CallTxTrace} (ipHeader, packet, \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<
      \hyperlink{classns3_1_1Ipv6_adccc58acd14d3f9a28f75dc09e794998}{Ipv6}> (), interface);
1183               outInterface->Send (packet, ipHeader, route->GetGateway ());
1184             \}
1185         \}
1186       \textcolor{keywordflow}{else}
1187         \{
1188           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Dropping-- outgoing interface is down: "} << route->GetGateway ());
1189           \hyperlink{classns3_1_1Ipv6L3Protocol_ac22d2d63cac436267ae6cafc46880a6e}{m\_dropTrace} (ipHeader, packet, \hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa72b499545685a47a7cf3588d1330d5d0}{DROP\_INTERFACE\_DOWN}, 
      \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<\hyperlink{classns3_1_1Ipv6_adccc58acd14d3f9a28f75dc09e794998}{Ipv6}> (), interface);
1190         \}
1191     \}
1192   \textcolor{keywordflow}{else}
1193     \{
1194       \textcolor{keywordflow}{if} (outInterface->IsUp ())
1195         \{
1196           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Send to destination "} << ipHeader.GetDestinationAddress ());
1197 
1198           \textcolor{keywordflow}{if} (fragments.size () != 0)
1199             \{
1200               std::ostringstream oss;
1201 
1202               \textcolor{keywordflow}{for} (std::list<Ipv6ExtensionFragment::Ipv6PayloadHeaderPair>::const\_iterator it = fragments.
      begin (); it != fragments.end (); it++)
1203                 \{
1204                   \hyperlink{classns3_1_1Ipv6L3Protocol_a40e29e34a97639ad1caad6b64e732454}{CallTxTrace} (it->second, it->first, \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->
      \hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<\hyperlink{classns3_1_1Ipv6_adccc58acd14d3f9a28f75dc09e794998}{Ipv6}> (), interface);
1205                   outInterface->Send (it->first, it->second, ipHeader.GetDestinationAddress ());
1206                 \}
1207             \}
1208           \textcolor{keywordflow}{else}
1209             \{
1210               \hyperlink{classns3_1_1Ipv6L3Protocol_a40e29e34a97639ad1caad6b64e732454}{CallTxTrace} (ipHeader, packet, \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<
      \hyperlink{classns3_1_1Ipv6_adccc58acd14d3f9a28f75dc09e794998}{Ipv6}> (), interface);
1211               outInterface->Send (packet, ipHeader, ipHeader.GetDestinationAddress ());
1212             \}
1213         \}
1214       \textcolor{keywordflow}{else}
1215         \{
1216           \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Dropping-- outgoing interface is down: "} << ipHeader.
      GetDestinationAddress ());
1217           \hyperlink{classns3_1_1Ipv6L3Protocol_ac22d2d63cac436267ae6cafc46880a6e}{m\_dropTrace} (ipHeader, packet, \hyperlink{classns3_1_1Ipv6L3Protocol_a33c64db9bc35f71ff368b132bfffa37aa72b499545685a47a7cf3588d1330d5d0}{DROP\_INTERFACE\_DOWN}, 
      \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->\hyperlink{classns3_1_1Object_a13e18c00017096c8381eb651d5bd0783}{GetObject}<\hyperlink{classns3_1_1Ipv6_adccc58acd14d3f9a28f75dc09e794998}{Ipv6}> (), interface);
1218         \}
1219     \}
1220 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 49




Here is the caller graph for this function\+:
% FIG 50


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Set\+Default\+Tclass@{Set\+Default\+Tclass}}
\index{Set\+Default\+Tclass@{Set\+Default\+Tclass}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Default\+Tclass(uint8\+\_\+t tclass)}{SetDefaultTclass(uint8_t tclass)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Set\+Default\+Tclass (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{tclass}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6L3Protocol_ac4da722470be0e2869f11b6835cc3579}{}\label{classns3_1_1Ipv6L3Protocol_ac4da722470be0e2869f11b6835cc3579}


Set the default T\+C\+L\+A\+SS. 


\begin{DoxyParams}{Parameters}
{\em tclass} & T\+C\+L\+A\+SS to set \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
851 \{
852   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << tclass);
853   \hyperlink{classns3_1_1Ipv6L3Protocol_a0ead80eb6fa685c54dc155dff9157345}{m\_defaultTclass} = tclass;
854 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Set\+Default\+Ttl@{Set\+Default\+Ttl}}
\index{Set\+Default\+Ttl@{Set\+Default\+Ttl}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Default\+Ttl(uint8\+\_\+t ttl)}{SetDefaultTtl(uint8_t ttl)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Set\+Default\+Ttl (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{ttl}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6L3Protocol_a7eadd617007c0f0515d4d6b1c393f45e}{}\label{classns3_1_1Ipv6L3Protocol_a7eadd617007c0f0515d4d6b1c393f45e}


Set the default T\+TL. 


\begin{DoxyParams}{Parameters}
{\em ttl} & T\+TL to set \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
845 \{
846   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << ttl);
847   \hyperlink{classns3_1_1Ipv6L3Protocol_a2857858d48a3ce4f6bc1912d721825b7}{m\_defaultTtl} = ttl;
848 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Set\+Down@{Set\+Down}}
\index{Set\+Down@{Set\+Down}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Down(uint32\+\_\+t i)}{SetDown(uint32_t i)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Set\+Down (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_aac61d62990fdfa91000cffe7fd918062}{}\label{classns3_1_1Ipv6L3Protocol_aac61d62990fdfa91000cffe7fd918062}


set an interface down. 


\begin{DoxyParams}{Parameters}
{\em i} & interface index \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6_ada8ade0638959d7acf65682580c43ee6}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
547 \{
548   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
549   Ptr<Ipv6Interface> \textcolor{keyword}{interface }= GetInterface (i);
550 
551   interface->SetDown ();
552 
553   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6L3Protocol_aa0df547e5240b218dc1f4742a2a00117}{m\_routingProtocol} != 0)
554     \{
555       \hyperlink{classns3_1_1Ipv6L3Protocol_aa0df547e5240b218dc1f4742a2a00117}{m\_routingProtocol}->NotifyInterfaceDown (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
556     \}
557 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Set\+Forwarding@{Set\+Forwarding}}
\index{Set\+Forwarding@{Set\+Forwarding}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Forwarding(uint32\+\_\+t i, bool val)}{SetForwarding(uint32_t i, bool val)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Set\+Forwarding (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i, }
\item[{bool}]{val}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a1a8bef4362f31f4f2b32ea6e7051467a}{}\label{classns3_1_1Ipv6L3Protocol_a1a8bef4362f31f4f2b32ea6e7051467a}


Enable or disable forwarding on interface. 


\begin{DoxyParams}{Parameters}
{\em i} & interface index \\
\hline
{\em val} & true = enable forwarding, false = disable \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6_a8f7c711267860c54bf3a645b24bf2eef}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
606 \{
607   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} << val);
608   Ptr<Ipv6Interface> \textcolor{keyword}{interface }= GetInterface (i);
609   interface->SetForwarding (val);
610 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Set\+Ip\+Forward@{Set\+Ip\+Forward}}
\index{Set\+Ip\+Forward@{Set\+Ip\+Forward}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Ip\+Forward(bool forward)}{SetIpForward(bool forward)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Set\+Ip\+Forward (
\begin{DoxyParamCaption}
\item[{bool}]{forward}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_af305cd631f4f5b4acaf75f3d4243c08b}{}\label{classns3_1_1Ipv6L3Protocol_af305cd631f4f5b4acaf75f3d4243c08b}


Set I\+Pv6 forwarding state. 


\begin{DoxyParams}{Parameters}
{\em forward} & I\+Pv6 forwarding enabled or not \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6_a173e9acf3a03e1d333ca3be56a6c4f38}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
652 \{
653   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << forward);
654   \hyperlink{classns3_1_1Ipv6L3Protocol_a3dbdeac3cc4ec17f5a6ab9475fc8e7a8}{m\_ipForward} = forward;
655 
656   \textcolor{keywordflow}{for} (Ipv6InterfaceList::const\_iterator it = \hyperlink{classns3_1_1Ipv6L3Protocol_a425d8738fd30fbc9345d57cfddd0d6d0}{m\_interfaces}.begin (); it != 
      \hyperlink{classns3_1_1Ipv6L3Protocol_a425d8738fd30fbc9345d57cfddd0d6d0}{m\_interfaces}.end (); it++)
657     \{
658       (*it)->SetForwarding (forward);
659     \}
660 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Set\+Metric@{Set\+Metric}}
\index{Set\+Metric@{Set\+Metric}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Metric(uint32\+\_\+t i, uint16\+\_\+t metric)}{SetMetric(uint32_t i, uint16_t metric)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Set\+Metric (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i, }
\item[{uint16\+\_\+t}]{metric}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a5d0a141d4b667d8f39f903b9d3fbeffd}{}\label{classns3_1_1Ipv6L3Protocol_a5d0a141d4b667d8f39f903b9d3fbeffd}


Set metric for an interface. 


\begin{DoxyParams}{Parameters}
{\em i} & index \\
\hline
{\em metric} & \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6_ab8dfd51c931ebc11c107bff673bae827}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
480 \{
481   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} << metric);
482   Ptr<Ipv6Interface> \textcolor{keyword}{interface }= GetInterface (i);
483   interface->SetMetric (metric);
484 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Set\+Mtu\+Discover@{Set\+Mtu\+Discover}}
\index{Set\+Mtu\+Discover@{Set\+Mtu\+Discover}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Mtu\+Discover(bool mtu\+Discover)}{SetMtuDiscover(bool mtuDiscover)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Set\+Mtu\+Discover (
\begin{DoxyParamCaption}
\item[{bool}]{mtu\+Discover}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a9954be60f9cfc8b7570a18eb0b8b92f9}{}\label{classns3_1_1Ipv6L3Protocol_a9954be60f9cfc8b7570a18eb0b8b92f9}


Set I\+Pv6 M\+TU discover state. 


\begin{DoxyParams}{Parameters}
{\em mtu\+Discover} & I\+Pv6 M\+TU discover enabled or not \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6_a3204b23a92a2495b428bd882a988369a}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
669 \{
670   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \textcolor{keywordtype}{int}(mtuDiscover));
671   \hyperlink{classns3_1_1Ipv6L3Protocol_a7b38ce20301ab4b5db712d45536d6e19}{m\_mtuDiscover} = mtuDiscover;
672 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Set\+Node@{Set\+Node}}
\index{Set\+Node@{Set\+Node}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Node(\+Ptr$<$ Node $>$ node)}{SetNode(Ptr< Node > node)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Set\+Node (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Node} $>$}]{node}
\end{DoxyParamCaption}
)}\hypertarget{classns3_1_1Ipv6L3Protocol_a53796a2747cb5edcd1c762f44043b061}{}\label{classns3_1_1Ipv6L3Protocol_a53796a2747cb5edcd1c762f44043b061}


Set node associated with this stack. 


\begin{DoxyParams}{Parameters}
{\em node} & node to set \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
710 \{
711   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << node);
712   \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node} = node;
713   \textcolor{comment}{/* add LoopbackNetDevice if needed, and an Ipv6Interface on top of it */}
714   \hyperlink{classns3_1_1Ipv6L3Protocol_a69a1ef7b49dd3aa80c6807f467720005}{SetupLoopback} ();
715 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 51




Here is the caller graph for this function\+:
% FIG 52


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Set\+Pmtu@{Set\+Pmtu}}
\index{Set\+Pmtu@{Set\+Pmtu}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Pmtu(\+Ipv6\+Address dst, uint32\+\_\+t pmtu)}{SetPmtu(Ipv6Address dst, uint32_t pmtu)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Set\+Pmtu (
\begin{DoxyParamCaption}
\item[{{\bf Ipv6\+Address}}]{dst, }
\item[{uint32\+\_\+t}]{pmtu}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_ab99ee90351fb7bbe9d2582376c3597ae}{}\label{classns3_1_1Ipv6L3Protocol_ab99ee90351fb7bbe9d2582376c3597ae}


Set the Path M\+TU for the specified I\+Pv6 destination address. 


\begin{DoxyParams}{Parameters}
{\em dst} & \hyperlink{classns3_1_1Ipv6}{Ipv6} destination address \\
\hline
{\em pmtu} & the Path M\+TU \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6_a2f791bd08927bcbbba2694813cb52710}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
508 \{
509   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << dst << \textcolor{keywordtype}{int}(pmtu));
510   \hyperlink{classns3_1_1Ipv6L3Protocol_a03a839bfaf9ae8763a58a42e60b08ec5}{m\_pmtuCache}->SetPmtu (dst, pmtu);
511 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Set\+Routing\+Protocol@{Set\+Routing\+Protocol}}
\index{Set\+Routing\+Protocol@{Set\+Routing\+Protocol}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Routing\+Protocol(\+Ptr$<$ Ipv6\+Routing\+Protocol $>$ routing\+Protocol)}{SetRoutingProtocol(Ptr< Ipv6RoutingProtocol > routingProtocol)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Set\+Routing\+Protocol (
\begin{DoxyParamCaption}
\item[{{\bf Ptr}$<$ {\bf Ipv6\+Routing\+Protocol} $>$}]{routing\+Protocol}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a9f65728e13ee4a2fb5588d3601e7634f}{}\label{classns3_1_1Ipv6L3Protocol_a9f65728e13ee4a2fb5588d3601e7634f}


Set routing protocol for this stack. 


\begin{DoxyParams}{Parameters}
{\em routing\+Protocol} & I\+Pv6 routing protocol to set \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6_aa889d2174527a1df773d65974de83f8f}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
179 \{
180   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << routingProtocol);
181   \hyperlink{classns3_1_1Ipv6L3Protocol_aa0df547e5240b218dc1f4742a2a00117}{m\_routingProtocol} = routingProtocol;
182   \hyperlink{classns3_1_1Ipv6L3Protocol_aa0df547e5240b218dc1f4742a2a00117}{m\_routingProtocol}->SetIpv6 (\textcolor{keyword}{this});
183 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 53


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Set\+Send\+Icmpv6\+Redirect@{Set\+Send\+Icmpv6\+Redirect}}
\index{Set\+Send\+Icmpv6\+Redirect@{Set\+Send\+Icmpv6\+Redirect}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Send\+Icmpv6\+Redirect(bool send\+Icmpv6\+Redirect)}{SetSendIcmpv6Redirect(bool sendIcmpv6Redirect)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Set\+Send\+Icmpv6\+Redirect (
\begin{DoxyParamCaption}
\item[{bool}]{send\+Icmpv6\+Redirect}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_aa5c6bd6e857b631c812ed5bbe4566241}{}\label{classns3_1_1Ipv6L3Protocol_aa5c6bd6e857b631c812ed5bbe4566241}


Set the I\+C\+M\+Pv6 Redirect sending state. 


\begin{DoxyParams}{Parameters}
{\em send\+Icmpv6\+Redirect} & I\+C\+M\+Pv6 Redirect sending enabled or not \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
681 \{
682   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << sendIcmpv6Redirect);
683   \hyperlink{classns3_1_1Ipv6L3Protocol_a23aef420bfb1d9dd634681c4a78a0352}{m\_sendIcmpv6Redirect} = sendIcmpv6Redirect;
684 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
% FIG 54


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Set\+Up@{Set\+Up}}
\index{Set\+Up@{Set\+Up}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Set\+Up(uint32\+\_\+t i)}{SetUp(uint32_t i)}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Set\+Up (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a834eba3100efc8f71e5292bbfdcde6e6}{}\label{classns3_1_1Ipv6L3Protocol_a834eba3100efc8f71e5292bbfdcde6e6}


Set an interface up. 


\begin{DoxyParams}{Parameters}
{\em i} & interface index \\
\hline
\end{DoxyParams}


Implements \hyperlink{classns3_1_1Ipv6_a8e61d85ec7fd342ed38fef2d040ed1b9}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
522 \{
523   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
524   Ptr<Ipv6Interface> \textcolor{keyword}{interface }= GetInterface (i);
525 
526   \textcolor{comment}{// RFC 2460, Section 5, pg. 24:}
527   \textcolor{comment}{//  IPv6 requires that every link in the internet have an MTU of 1280}
528   \textcolor{comment}{//  octets or greater.  On any link that cannot convey a 1280-octet}
529   \textcolor{comment}{//  packet in one piece, link-specific fragmentation and reassembly must}
530   \textcolor{comment}{//  be provided at a layer below IPv6.}
531   \textcolor{keywordflow}{if} (interface->GetDevice ()->GetMtu () >= 1280)
532     \{
533       interface->SetUp ();
534 
535       \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6L3Protocol_aa0df547e5240b218dc1f4742a2a00117}{m\_routingProtocol} != 0)
536         \{
537           \hyperlink{classns3_1_1Ipv6L3Protocol_aa0df547e5240b218dc1f4742a2a00117}{m\_routingProtocol}->NotifyInterfaceUp (\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
538         \}
539     \}
540   \textcolor{keywordflow}{else}
541     \{
542       \hyperlink{group__logging_ga88acd260151caf2db9c0fc84997f45ce}{NS\_LOG\_LOGIC} (\textcolor{stringliteral}{"Interface "} << \textcolor{keywordtype}{int}(\hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}) << \textcolor{stringliteral}{" is set to be down for IPv6. Reason: not
       respecting minimum IPv6 MTU (1280 octets)"});
543     \}
544 \}
\end{DoxyCode}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Setup\+Loopback@{Setup\+Loopback}}
\index{Setup\+Loopback@{Setup\+Loopback}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Setup\+Loopback()}{SetupLoopback()}}]{\setlength{\rightskip}{0pt plus 5cm}void ns3\+::\+Ipv6\+L3\+Protocol\+::\+Setup\+Loopback (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a69a1ef7b49dd3aa80c6807f467720005}{}\label{classns3_1_1Ipv6L3Protocol_a69a1ef7b49dd3aa80c6807f467720005}


Setup loopback interface. 


\begin{DoxyCode}
560 \{
561   \hyperlink{log-macros-disabled_8h_a8f7e4afc291c9d29a65c18ac1f79197b}{NS\_LOG\_FUNCTION\_NOARGS} ();
562   Ptr<Ipv6Interface> \textcolor{keyword}{interface }= \hyperlink{group__object_gad1d36559be10afa72c3656fd8598c1e2}{CreateObject}<Ipv6Interface> ();
563   Ptr<LoopbackNetDevice> device = 0;
564   uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0;
565 
566   \textcolor{comment}{/* see if we have already an loopback NetDevice */}
567   \textcolor{keywordflow}{for} (i = 0; i < \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->\hyperlink{classns3_1_1Node_a531554d2241ba4fa1cd74e3360be6bce}{GetNDevices} (); i++)
568     \{
569       \textcolor{keywordflow}{if} ((device = DynamicCast<LoopbackNetDevice> (\hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->\hyperlink{classns3_1_1Node_a5918dfd24ef632efc9a83a5f6561c76e}{GetDevice} (i))))
570         \{
571           \textcolor{keywordflow}{break};
572         \}
573     \}
574 
575   \textcolor{keywordflow}{if} (device == 0)
576     \{
577       device = CreateObject<LoopbackNetDevice> ();
578       \hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node}->\hyperlink{classns3_1_1Node_a42ff83ee1d5d1649c770d3f5b62375de}{AddDevice} (device);
579     \}
580 
581   interface->SetDevice (device);
582   interface->SetNode (\hyperlink{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{m\_node});
583   Ipv6InterfaceAddress ifaceAddr = Ipv6InterfaceAddress (
      \hyperlink{classns3_1_1Ipv6Address_af62754355f28fadc671584dd02cd79b7}{Ipv6Address::GetLoopback} (), Ipv6Prefix (128));
584   interface->AddAddress (ifaceAddr);
585   uint32\_t index = \hyperlink{classns3_1_1Ipv6L3Protocol_aa0c786fd0209504c82b7278297a62f99}{AddIpv6Interface} (interface);
586   Ptr<Node> node = GetObject<Node> ();
587   node->RegisterProtocolHandler (\hyperlink{group__makecallbackmemptr_ga9376283685aa99d204048d6a4b7610a4}{MakeCallback} (&
      \hyperlink{classns3_1_1Ipv6L3Protocol_a8a95d576e8aee9a571db93bf686d850a}{Ipv6L3Protocol::Receive}, \textcolor{keyword}{this}), 
      \hyperlink{classns3_1_1Ipv6L3Protocol_ac44af6866e3ddd3f0cb9fbe228afdfe9}{Ipv6L3Protocol::PROT\_NUMBER}, device);
588   interface->SetUp ();
589 
590   \textcolor{keywordflow}{if} (\hyperlink{classns3_1_1Ipv6L3Protocol_aa0df547e5240b218dc1f4742a2a00117}{m\_routingProtocol} != 0)
591     \{
592       \hyperlink{classns3_1_1Ipv6L3Protocol_aa0df547e5240b218dc1f4742a2a00117}{m\_routingProtocol}->NotifyInterfaceUp (index);
593     \}
594 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 55




Here is the caller graph for this function\+:
% FIG 56


\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Source\+Address\+Selection@{Source\+Address\+Selection}}
\index{Source\+Address\+Selection@{Source\+Address\+Selection}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Source\+Address\+Selection(uint32\+\_\+t interface, Ipv6\+Address dest)}{SourceAddressSelection(uint32_t interface, Ipv6Address dest)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+Address} ns3\+::\+Ipv6\+L3\+Protocol\+::\+Source\+Address\+Selection (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{interface, }
\item[{{\bf Ipv6\+Address}}]{dest}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a77acb50e395f36951381977368ebc5cb}{}\label{classns3_1_1Ipv6L3Protocol_a77acb50e395f36951381977368ebc5cb}


Choose the source address to use with destination address. 


\begin{DoxyParams}{Parameters}
{\em interface} & interface index \\
\hline
{\em dest} & I\+Pv6 destination address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
I\+Pv6 source address to use 
\end{DoxyReturn}


Implements \hyperlink{classns3_1_1Ipv6_a07bfb23e4bee98b2a2bfb56c16908cd4}{ns3\+::\+Ipv6}.


\begin{DoxyCode}
613 \{
614   \hyperlink{log-macros-disabled_8h_a90b90d5bad1f39cb1b64923ea94c0761}{NS\_LOG\_FUNCTION} (\textcolor{keyword}{this} << interface << dest);
615   Ipv6Address ret;
616 
617   \textcolor{keywordflow}{if} (dest.IsLinkLocal () || dest.IsLinkLocalMulticast ())
618     \{
619       \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1Ipv6L3Protocol_a3b09a9f504a311ecc08fdc026d897514}{GetNAddresses} (interface); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
620         \{
621           Ipv6InterfaceAddress \hyperlink{main-test-sync_8cc_a708a4c1a4d0c4acc4c447310dd4db27f}{test} = \hyperlink{classns3_1_1Ipv6L3Protocol_a0321a9ac3f79b5a7b7542cecf11bfe44}{GetAddress} (interface, \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
622           \textcolor{keywordflow}{if} (test.GetScope () == \hyperlink{classns3_1_1Ipv6InterfaceAddress_ad3f03debf9dae475b81ea9cdf81f4f27a29f5cd6ebe813216f28d906d89d4c56d}{Ipv6InterfaceAddress::LINKLOCAL})
623             \{
624               \textcolor{keywordflow}{return} test.GetAddress ();
625             \}
626         \}
627       \hyperlink{assert_8h_aff5ece9066c74e681e74999856f08539}{NS\_ASSERT\_MSG} (\textcolor{keyword}{false}, \textcolor{stringliteral}{"No link-local address found on interface "} << interface);
628     \}
629 
630   \textcolor{keywordflow}{for} (uint32\_t \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} = 0; \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i} < \hyperlink{classns3_1_1Ipv6L3Protocol_a3b09a9f504a311ecc08fdc026d897514}{GetNAddresses} (interface); \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i}++)
631     \{
632       Ipv6InterfaceAddress test = \hyperlink{classns3_1_1Ipv6L3Protocol_a0321a9ac3f79b5a7b7542cecf11bfe44}{GetAddress} (interface, \hyperlink{bernuolliDistribution_8m_a6f6ccfcf58b31cb6412107d9d5281426}{i});
633 
634       \textcolor{keywordflow}{if} (test.GetScope () == \hyperlink{classns3_1_1Ipv6InterfaceAddress_ad3f03debf9dae475b81ea9cdf81f4f27aaf504a3b8c1562206e6ba65b4a6cff1d}{Ipv6InterfaceAddress::GLOBAL})
635         \{
636           \textcolor{keywordflow}{if} (test.IsInSameSubnet (dest))
637             \{
638               \textcolor{keywordflow}{return} test.GetAddress ();
639             \}
640           \textcolor{keywordflow}{else}
641             \{
642               ret = test.GetAddress ();
643             \}
644         \}
645     \}
646 
647   \textcolor{comment}{// no specific match found. Use a global address (any useful is fine).}
648   \textcolor{keywordflow}{return} ret;
649 \}
\end{DoxyCode}


Here is the call graph for this function\+:
% FIG 57




\subsection{Friends And Related Function Documentation}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!\+::\+Ipv6\+L3\+Protocol\+Test\+Case@{\+::\+Ipv6\+L3\+Protocol\+Test\+Case}}
\index{\+::\+Ipv6\+L3\+Protocol\+Test\+Case@{\+::\+Ipv6\+L3\+Protocol\+Test\+Case}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{\+::\+Ipv6\+L3\+Protocol\+Test\+Case}{::Ipv6L3ProtocolTestCase}}]{\setlength{\rightskip}{0pt plus 5cm}friend class \+::{\bf Ipv6\+L3\+Protocol\+Test\+Case}\hspace{0.3cm}{\ttfamily [friend]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a09b6212a5017142b4f4244e3809708b9}{}\label{classns3_1_1Ipv6L3Protocol_a09b6212a5017142b4f4244e3809708b9}


\hyperlink{classIpv6L3ProtocolTestCase}{Ipv6\+L3\+Protocol\+Test\+Case} test case. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!Ipv6\+Extension\+Loose\+Routing@{Ipv6\+Extension\+Loose\+Routing}}
\index{Ipv6\+Extension\+Loose\+Routing@{Ipv6\+Extension\+Loose\+Routing}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{Ipv6\+Extension\+Loose\+Routing}{Ipv6ExtensionLooseRouting}}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf Ipv6\+Extension\+Loose\+Routing}\hspace{0.3cm}{\ttfamily [friend]}}\hypertarget{classns3_1_1Ipv6L3Protocol_aa3cefd4bf01ad6e80cfae2da346cccc2}{}\label{classns3_1_1Ipv6L3Protocol_aa3cefd4bf01ad6e80cfae2da346cccc2}


\hyperlink{classns3_1_1Ipv6ExtensionLooseRouting}{Ipv6\+Extension\+Loose\+Routing}. 



\subsection{Member Data Documentation}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!m\+\_\+default\+Tclass@{m\+\_\+default\+Tclass}}
\index{m\+\_\+default\+Tclass@{m\+\_\+default\+Tclass}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+default\+Tclass}{m_defaultTclass}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::\+Ipv6\+L3\+Protocol\+::m\+\_\+default\+Tclass\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a0ead80eb6fa685c54dc155dff9157345}{}\label{classns3_1_1Ipv6L3Protocol_a0ead80eb6fa685c54dc155dff9157345}


Default T\+C\+L\+A\+SS for outgoing packets. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!m\+\_\+default\+Ttl@{m\+\_\+default\+Ttl}}
\index{m\+\_\+default\+Ttl@{m\+\_\+default\+Ttl}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+default\+Ttl}{m_defaultTtl}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t ns3\+::\+Ipv6\+L3\+Protocol\+::m\+\_\+default\+Ttl\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a2857858d48a3ce4f6bc1912d721825b7}{}\label{classns3_1_1Ipv6L3Protocol_a2857858d48a3ce4f6bc1912d721825b7}


Default T\+TL for outgoing packets. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!m\+\_\+drop\+Trace@{m\+\_\+drop\+Trace}}
\index{m\+\_\+drop\+Trace@{m\+\_\+drop\+Trace}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+drop\+Trace}{m_dropTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<$const {\bf Ipv6\+Header} \&, {\bf Ptr}$<$const {\bf Packet}$>$, {\bf Drop\+Reason}, {\bf Ptr}$<${\bf Ipv6}$>$, uint32\+\_\+t$>$ ns3\+::\+Ipv6\+L3\+Protocol\+::m\+\_\+drop\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_ac22d2d63cac436267ae6cafc46880a6e}{}\label{classns3_1_1Ipv6L3Protocol_ac22d2d63cac436267ae6cafc46880a6e}


\hyperlink{classns3_1_1Callback}{Callback} to trace drop packets. 

\begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000015}{Deprecated}]The non-\/const {\ttfamily Ptr$<$\+Ipv6$>$} argument is deprecated and will be changed to {\ttfamily Ptr$<$const Ipv6$>$} in a future release. \end{DoxyRefDesc}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!m\+\_\+interfaces@{m\+\_\+interfaces}}
\index{m\+\_\+interfaces@{m\+\_\+interfaces}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+interfaces}{m_interfaces}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+Interface\+List} ns3\+::\+Ipv6\+L3\+Protocol\+::m\+\_\+interfaces\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a425d8738fd30fbc9345d57cfddd0d6d0}{}\label{classns3_1_1Ipv6L3Protocol_a425d8738fd30fbc9345d57cfddd0d6d0}


List of I\+Pv6 interfaces. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!m\+\_\+ip\+Forward@{m\+\_\+ip\+Forward}}
\index{m\+\_\+ip\+Forward@{m\+\_\+ip\+Forward}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+ip\+Forward}{m_ipForward}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv6\+L3\+Protocol\+::m\+\_\+ip\+Forward\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a3dbdeac3cc4ec17f5a6ab9475fc8e7a8}{}\label{classns3_1_1Ipv6L3Protocol_a3dbdeac3cc4ec17f5a6ab9475fc8e7a8}


Forwarding packets (i.\+e. router mode) state. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!m\+\_\+local\+Deliver\+Trace@{m\+\_\+local\+Deliver\+Trace}}
\index{m\+\_\+local\+Deliver\+Trace@{m\+\_\+local\+Deliver\+Trace}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+local\+Deliver\+Trace}{m_localDeliverTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<$const {\bf Ipv6\+Header} \&, {\bf Ptr}$<$const {\bf Packet}$>$, uint32\+\_\+t$>$ ns3\+::\+Ipv6\+L3\+Protocol\+::m\+\_\+local\+Deliver\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_afd8b2aef3c54456b509cdc7356db577e}{}\label{classns3_1_1Ipv6L3Protocol_afd8b2aef3c54456b509cdc7356db577e}


Trace of locally delivered packets. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!m\+\_\+mtu\+Discover@{m\+\_\+mtu\+Discover}}
\index{m\+\_\+mtu\+Discover@{m\+\_\+mtu\+Discover}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+mtu\+Discover}{m_mtuDiscover}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv6\+L3\+Protocol\+::m\+\_\+mtu\+Discover\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a7b38ce20301ab4b5db712d45536d6e19}{}\label{classns3_1_1Ipv6L3Protocol_a7b38ce20301ab4b5db712d45536d6e19}


M\+TU Discover (i.\+e. Path M\+TU) state. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!m\+\_\+multicast\+Addresses@{m\+\_\+multicast\+Addresses}}
\index{m\+\_\+multicast\+Addresses@{m\+\_\+multicast\+Addresses}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+multicast\+Addresses}{m_multicastAddresses}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+Registered\+Multicast\+Address\+\_\+t} ns3\+::\+Ipv6\+L3\+Protocol\+::m\+\_\+multicast\+Addresses\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a6d7573453cf2a73d44bfb2d68eed19c4}{}\label{classns3_1_1Ipv6L3Protocol_a6d7573453cf2a73d44bfb2d68eed19c4}


List of multicast IP addresses of interest, divided per interface. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!m\+\_\+multicast\+Addresses\+No\+Interface@{m\+\_\+multicast\+Addresses\+No\+Interface}}
\index{m\+\_\+multicast\+Addresses\+No\+Interface@{m\+\_\+multicast\+Addresses\+No\+Interface}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+multicast\+Addresses\+No\+Interface}{m_multicastAddressesNoInterface}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+Registered\+Multicast\+Address\+No\+Interface\+\_\+t} ns3\+::\+Ipv6\+L3\+Protocol\+::m\+\_\+multicast\+Addresses\+No\+Interface\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a4b31a418ae742bed8835981afb433b1c}{}\label{classns3_1_1Ipv6L3Protocol_a4b31a418ae742bed8835981afb433b1c}


List of multicast IP addresses of interest for all the interfaces. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!m\+\_\+n\+Interfaces@{m\+\_\+n\+Interfaces}}
\index{m\+\_\+n\+Interfaces@{m\+\_\+n\+Interfaces}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+n\+Interfaces}{m_nInterfaces}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t ns3\+::\+Ipv6\+L3\+Protocol\+::m\+\_\+n\+Interfaces\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a61c0b45c983a905ebfe4ebce1a90a1d7}{}\label{classns3_1_1Ipv6L3Protocol_a61c0b45c983a905ebfe4ebce1a90a1d7}


Number of I\+Pv6 interfaces managed by the stack. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!m\+\_\+node@{m\+\_\+node}}
\index{m\+\_\+node@{m\+\_\+node}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+node}{m_node}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Node}$>$ ns3\+::\+Ipv6\+L3\+Protocol\+::m\+\_\+node\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}{}\label{classns3_1_1Ipv6L3Protocol_a543d8509395ee76de15d039ff1fce642}


\hyperlink{classns3_1_1Node}{Node} attached to stack. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!m\+\_\+pmtu\+Cache@{m\+\_\+pmtu\+Cache}}
\index{m\+\_\+pmtu\+Cache@{m\+\_\+pmtu\+Cache}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+pmtu\+Cache}{m_pmtuCache}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Ipv6\+Pmtu\+Cache}$>$ ns3\+::\+Ipv6\+L3\+Protocol\+::m\+\_\+pmtu\+Cache\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a03a839bfaf9ae8763a58a42e60b08ec5}{}\label{classns3_1_1Ipv6L3Protocol_a03a839bfaf9ae8763a58a42e60b08ec5}


Path M\+TU Cache. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!m\+\_\+prefixes@{m\+\_\+prefixes}}
\index{m\+\_\+prefixes@{m\+\_\+prefixes}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+prefixes}{m_prefixes}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+Autoconfigured\+Prefix\+List} ns3\+::\+Ipv6\+L3\+Protocol\+::m\+\_\+prefixes\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a402d76e60e8ac25eeb200d2b288732c0}{}\label{classns3_1_1Ipv6L3Protocol_a402d76e60e8ac25eeb200d2b288732c0}


List of I\+Pv6 prefix received from RA. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!m\+\_\+protocols@{m\+\_\+protocols}}
\index{m\+\_\+protocols@{m\+\_\+protocols}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+protocols}{m_protocols}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf L4\+List\+\_\+t} ns3\+::\+Ipv6\+L3\+Protocol\+::m\+\_\+protocols\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a5a68c54b92d81f93c41983ebdc0ef5b3}{}\label{classns3_1_1Ipv6L3Protocol_a5a68c54b92d81f93c41983ebdc0ef5b3}


List of transport protocol. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!m\+\_\+reverse\+Interfaces\+Container@{m\+\_\+reverse\+Interfaces\+Container}}
\index{m\+\_\+reverse\+Interfaces\+Container@{m\+\_\+reverse\+Interfaces\+Container}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+reverse\+Interfaces\+Container}{m_reverseInterfacesContainer}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ipv6\+Interface\+Reverse\+Container} ns3\+::\+Ipv6\+L3\+Protocol\+::m\+\_\+reverse\+Interfaces\+Container\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_aba2395fbe747b5c8d0f46d65556eea0c}{}\label{classns3_1_1Ipv6L3Protocol_aba2395fbe747b5c8d0f46d65556eea0c}
Container of \hyperlink{classns3_1_1NetDevice}{Net\+Device} / Interface index associations. \index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!m\+\_\+routing\+Protocol@{m\+\_\+routing\+Protocol}}
\index{m\+\_\+routing\+Protocol@{m\+\_\+routing\+Protocol}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+routing\+Protocol}{m_routingProtocol}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Ptr}$<${\bf Ipv6\+Routing\+Protocol}$>$ ns3\+::\+Ipv6\+L3\+Protocol\+::m\+\_\+routing\+Protocol\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_aa0df547e5240b218dc1f4742a2a00117}{}\label{classns3_1_1Ipv6L3Protocol_aa0df547e5240b218dc1f4742a2a00117}


Routing protocol. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!m\+\_\+rx\+Trace@{m\+\_\+rx\+Trace}}
\index{m\+\_\+rx\+Trace@{m\+\_\+rx\+Trace}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+rx\+Trace}{m_rxTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$, {\bf Ptr}$<${\bf Ipv6}$>$, uint32\+\_\+t$>$ ns3\+::\+Ipv6\+L3\+Protocol\+::m\+\_\+rx\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a2fc8b57fc958fccd7c708f8c8ca03da5}{}\label{classns3_1_1Ipv6L3Protocol_a2fc8b57fc958fccd7c708f8c8ca03da5}


\hyperlink{classns3_1_1Callback}{Callback} to trace RX (reception) packets. 

\begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000014}{Deprecated}]The non-\/const {\ttfamily Ptr$<$\+Ipv6$>$} argument is deprecated and will be changed to {\ttfamily Ptr$<$const Ipv6$>$} in a future release. \end{DoxyRefDesc}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!m\+\_\+send\+Icmpv6\+Redirect@{m\+\_\+send\+Icmpv6\+Redirect}}
\index{m\+\_\+send\+Icmpv6\+Redirect@{m\+\_\+send\+Icmpv6\+Redirect}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+send\+Icmpv6\+Redirect}{m_sendIcmpv6Redirect}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv6\+L3\+Protocol\+::m\+\_\+send\+Icmpv6\+Redirect\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a23aef420bfb1d9dd634681c4a78a0352}{}\label{classns3_1_1Ipv6L3Protocol_a23aef420bfb1d9dd634681c4a78a0352}


Allow I\+C\+M\+Pv6 Redirect sending state. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!m\+\_\+send\+Outgoing\+Trace@{m\+\_\+send\+Outgoing\+Trace}}
\index{m\+\_\+send\+Outgoing\+Trace@{m\+\_\+send\+Outgoing\+Trace}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+send\+Outgoing\+Trace}{m_sendOutgoingTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<$const {\bf Ipv6\+Header} \&, {\bf Ptr}$<$const {\bf Packet}$>$, uint32\+\_\+t$>$ ns3\+::\+Ipv6\+L3\+Protocol\+::m\+\_\+send\+Outgoing\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_aac1ff242aa91275202e37cf7d805eec8}{}\label{classns3_1_1Ipv6L3Protocol_aac1ff242aa91275202e37cf7d805eec8}


Trace of sent packets. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!m\+\_\+sockets@{m\+\_\+sockets}}
\index{m\+\_\+sockets@{m\+\_\+sockets}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+sockets}{m_sockets}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Socket\+List} ns3\+::\+Ipv6\+L3\+Protocol\+::m\+\_\+sockets\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a515e9cba13d7fd95e5613f5c95ccc7b5}{}\label{classns3_1_1Ipv6L3Protocol_a515e9cba13d7fd95e5613f5c95ccc7b5}


List of I\+Pv6 raw sockets. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!m\+\_\+strong\+End\+System\+Model@{m\+\_\+strong\+End\+System\+Model}}
\index{m\+\_\+strong\+End\+System\+Model@{m\+\_\+strong\+End\+System\+Model}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+strong\+End\+System\+Model}{m_strongEndSystemModel}}]{\setlength{\rightskip}{0pt plus 5cm}bool ns3\+::\+Ipv6\+L3\+Protocol\+::m\+\_\+strong\+End\+System\+Model\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_ac00aee071bc7ab2096efbf8fdc5e3814}{}\label{classns3_1_1Ipv6L3Protocol_ac00aee071bc7ab2096efbf8fdc5e3814}


Rejects packets directed to an interface with wrong address (\{1222\}). 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!m\+\_\+tx\+Trace@{m\+\_\+tx\+Trace}}
\index{m\+\_\+tx\+Trace@{m\+\_\+tx\+Trace}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+tx\+Trace}{m_txTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<${\bf Ptr}$<$const {\bf Packet}$>$, {\bf Ptr}$<${\bf Ipv6}$>$, uint32\+\_\+t$>$ ns3\+::\+Ipv6\+L3\+Protocol\+::m\+\_\+tx\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a2037be8528273f3495216a09384e38e7}{}\label{classns3_1_1Ipv6L3Protocol_a2037be8528273f3495216a09384e38e7}


\hyperlink{classns3_1_1Callback}{Callback} to trace TX (transmission) packets. 

\begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000013}{Deprecated}]The non-\/const {\ttfamily Ptr$<$\+Ipv6$>$} argument is deprecated and will be changed to {\ttfamily Ptr$<$const Ipv6$>$} in a future release. \end{DoxyRefDesc}
\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!m\+\_\+unicast\+Forward\+Trace@{m\+\_\+unicast\+Forward\+Trace}}
\index{m\+\_\+unicast\+Forward\+Trace@{m\+\_\+unicast\+Forward\+Trace}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{m\+\_\+unicast\+Forward\+Trace}{m_unicastForwardTrace}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Traced\+Callback}$<$const {\bf Ipv6\+Header} \&, {\bf Ptr}$<$const {\bf Packet}$>$, uint32\+\_\+t$>$ ns3\+::\+Ipv6\+L3\+Protocol\+::m\+\_\+unicast\+Forward\+Trace\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{classns3_1_1Ipv6L3Protocol_a76b5cbe054e52a240d3e1a3ea0f891fd}{}\label{classns3_1_1Ipv6L3Protocol_a76b5cbe054e52a240d3e1a3ea0f891fd}


Trace of unicast forwarded packets. 

\index{ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}!P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER@{P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER}}
\index{P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER@{P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER}!ns3\+::\+Ipv6\+L3\+Protocol@{ns3\+::\+Ipv6\+L3\+Protocol}}
\subsubsection[{\texorpdfstring{P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER}{PROT_NUMBER}}]{\setlength{\rightskip}{0pt plus 5cm}const uint16\+\_\+t ns3\+::\+Ipv6\+L3\+Protocol\+::\+P\+R\+O\+T\+\_\+\+N\+U\+M\+B\+ER = 0x86\+DD\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classns3_1_1Ipv6L3Protocol_ac44af6866e3ddd3f0cb9fbe228afdfe9}{}\label{classns3_1_1Ipv6L3Protocol_ac44af6866e3ddd3f0cb9fbe228afdfe9}


The protocol number for I\+Pv6 (0x86\+DD). 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
internet/model/\hyperlink{ipv6-l3-protocol_8h}{ipv6-\/l3-\/protocol.\+h}\item 
internet/model/\hyperlink{ipv6-l3-protocol_8cc}{ipv6-\/l3-\/protocol.\+cc}\end{DoxyCompactItemize}
